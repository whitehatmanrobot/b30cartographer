 //
        // Transfer its contents into a CVar
        //

        CVarVector* pvv = new CVarVector(VT_UI1);
        if(pvv == NULL)
        {
            FreeSid(pSid);
            return FALSE;
        }

        for(int i = 0; i < GetLengthSid(pSid); i++)
            pvv->Add(CVar(pBuffer[i]));

        FreeSid(pSid);
        v.SetVarVector(pvv, TRUE);
        return TRUE;
    }
    else
        return FALSE;
}

void CSystemClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__SystemClass");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CParametersClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__PARAMETERS");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CGenericClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__GENERIC");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"sample", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


//******************************************************************************

void CNotifyStatusClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__NotifyStatus");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vs((LONG) 0);
    CVar vs;
    vs.SetAsNull();
    hRes = SetPropValue(L"StatusCode", &vs, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    // all error classes are like that!
    hRes = SetQualifier(L"abstract", &vt, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
                                   WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
                                   WBEM_FLAVOR_NOT_OVERRIDABLE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CNamespaceClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__NAMESPACE");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark name as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

CNamespaceClass* CNamespace::mstatic_pClass = NULL;
CStaticCritSec CNamespace::mstatic_cs;
CNamespace::__CleanUp CNamespace::cleanup;

void CNamespace::Init(LPWSTR pName)
{
    CInCritSec local_lock (&mstatic_cs);  // SEC:REVIEWED 2002-03-22 : Assumes entry
    if(mstatic_pClass == NULL)
    {
        wmilib::auto_ptr<CNamespaceClass> p(new CNamespaceClass);
        if (p.get() == 0)
        {
            throw CX_MemoryException();
        }
        p->Init();
        mstatic_pClass = p.release();
    }
    if (FAILED(InitNew(mstatic_pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();

    CVar vk(VT_BSTR, pName);
    HRESULT hRes = SetPropValue(L"Name", &vk, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CProviderClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Provider");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CWin32ProviderClass::Init()
{
    CProviderClass ProviderClass;
    ProviderClass.Init();
    HRESULT hRes = CreateDerivedClass(&ProviderClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Win32Provider");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ClientLoadableCLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"DefaultMachineName", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"UnloadTimeout", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"InitializeAsAdminFirst", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Version", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vZero;
    vZero.SetLong(0);
    hRes = SetPropValue(L"ImpersonationLevel", &vZero, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"InitializationReentrancy", &vZero, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"PerUserInitialization", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"PerLocaleInitialization", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropValue(L"Pure", &vTrue, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vInterval(VT_BSTR, L"interval");
    hRes = SetPropQualifier(L"UnloadTimeout", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vProtectedClsid(VT_BSTR, L"CLSID");
    CVar vProtectedNamespace(VT_BSTR, L"Namespace");
    CVar vProtectedComObject(VT_BSTR, L"COM Object");
    CVarVector *pvvReentrancy = new CVarVector(VT_BSTR);
    if (pvvReentrancy == 0)
        throw CX_MemoryException();
    if (pvvReentrancy->Add(vProtectedClsid) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvReentrancy->Add(vProtectedNamespace) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvReentrancy->Add(vProtectedComObject) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vReentrancy(pvvReentrancy, TRUE);
    hRes = SetPropQualifier(L"InitializationReentrancy", L"Values",
            WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vReentrancy);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vLevelNone(VT_BSTR, L"None");
    CVarVector* pvvLevel = new CVarVector(VT_BSTR);
    if (pvvLevel == 0)
        throw CX_MemoryException();
    if (pvvLevel->Add(vLevelNone) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vLevel(pvvLevel, TRUE);
    hRes = SetPropQualifier(L"ImpersonationLevel", L"Values",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vLevel);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    hRes = SetPropValue(L"HostingModel", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	CVar vHosting_WmiCore (VT_BSTR, L"WmiCore");
	CVar vHosting_WmiCoreSelfHost (VT_BSTR, L"WmiCoreOrSelfHost");
	CVar vHosting_SelfHost (VT_BSTR, L"SelfHost");
	CVar vHosting_Decoupled (VT_BSTR, L"Decoupled");
	CVar vHosting_LocalSystemHost (VT_BSTR, L"LocalSystemHost");
	CVar vHosting_LocalSystemHostOrSelfHost (VT_BSTR, L"LocalSystemHostOrSelfHost");
	CVar vHosting_LocalServiceHost (VT_BSTR, L"LocalServiceHost");
	CVar vHosting_NetworkServiceHost (VT_BSTR, L"NetworkServiceHost");
	CVar vHosting_UserHost (VT_BSTR, L"UserHost");

    CVarVector *pvvHostingModels = new CVarVector(VT_BSTR);
    if (pvvHostingModels == 0)
        throw CX_MemoryException();

    if (pvvLevel->Add(vHosting_WmiCore) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_WmiCoreSelfHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_SelfHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_Decoupled) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_LocalSystemHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_LocalSystemHostOrSelfHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_LocalServiceHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_NetworkServiceHost) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvLevel->Add(vHosting_UserHost) != CVarVector::no_error)
        throw CX_MemoryException();

    CVar vHostingModels(pvvHostingModels, TRUE);
    hRes = SetPropQualifier(L"HostingModel", L"Values",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vHostingModels);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Concurrency", &vNull, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsSendStatus", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsExplicitShutdown", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsExtendedStatus", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsThrottling", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"OperationTimeoutInterval", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"OperationTimeoutInterval", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"InitializationTimeoutInterval", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"InitializationTimeoutInterval", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsQuotas", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Enabled", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsShutdown", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SecurityDescriptor", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CProviderRegistrationClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes =CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Provider", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vCimtype(VT_BSTR, L"ref:__Provider");
    hRes = SetPropQualifier(L"Provider", L"cimtype", 0, &vCimtype);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
};

void CObjectProviderRegistrationClass::Init()
{
    CProviderRegistrationClass RegClass;
    RegClass.Init();
    HRESULT hRes = CreateDerivedClass(&RegClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ObjectProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);

    hRes = SetPropValue(L"SupportsPut", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsGet", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsDelete", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsEnumeration", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"QuerySupportLevels", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vZero;
    vZero.SetLong(0);
    hRes = SetPropValue(L"InteractionType", &vZero, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);

    CVar vPull(VT_BSTR, L"Pull");
    CVar vPush(VT_BSTR, L"Push");
    CVar vPushVerify(VT_BSTR, L"PushVerify");
    CVarVector* pvvInteraction = new CVarVector(VT_BSTR);
    if (pvvInteraction == 0)
        throw CX_MemoryException();
    if (pvvInteraction->Add(vPull) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvInteraction->Add(vPush) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvInteraction->Add(vPushVerify) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vInteraction(pvvInteraction, TRUE);
    hRes = SetPropQualifier(L"InteractionType", L"Values",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vInteraction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vUnarySelect(VT_BSTR, L"WQL:UnarySelect");
    CVar vProvDef(VT_BSTR, L"WQL:V1ProviderDefined");
    CVar vAssoc(VT_BSTR, L"WQL:Associators");
    CVar vRef(VT_BSTR, L"WQL:References");
    CVarVector* pvvQueries = new CVarVector(VT_BSTR);
    if (pvvQueries == 0)
        throw CX_MemoryException();
    if (pvvQueries->Add(vUnarySelect) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvQueries->Add(vRef) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvQueries->Add(vAssoc) != CVarVector::no_error)
        throw CX_MemoryException();
    if (pvvQueries->Add(vProvDef) != CVarVector::no_error)
        throw CX_MemoryException();
    CVar vQueries(pvvQueries, TRUE);
    hRes = SetPropQualifier(L"QuerySupportLevels", L"ValueMap",
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS, &vQueries);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
	
    hRes = SetPropValue(L"SupportsBatching", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"SupportsTransactions", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CClassProviderRegistrationClass::Init()
{
    CObjectProviderRegistrationClass ObjectClass;
    ObjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&ObjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ClassProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    hRes = SetPropValue(L"Version", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ResultSetQueries", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ReferencedSetQueries", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"UnsupportedQueries", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"CacheRefreshInterval", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vInterval(VT_BSTR, L"interval");
    hRes = SetPropQualifier(L"CacheRefreshInterval", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"PerUserSchema", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ReSynchroniseOnNamespaceOpen", &vNull, CIM_BOOLEAN );
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CInstanceProviderRegistrationClass::Init()
{
    CObjectProviderRegistrationClass ObjectClass;
    ObjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&ObjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__InstanceProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CPropertyProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__PropertyProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"SupportsPut", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SupportsGet", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CMethodProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__MethodProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"EventQueryList", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventConsumerProviderRegistrationClass::Init()
{
    CProviderRegistrationClass ProvReg;
    ProvReg.Init();
    HRESULT hRes = CreateDerivedClass(&ProvReg);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventConsumerProviderRegistration");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vProp;
    vProp.SetAsNull();
    hRes = SetPropValue(L"ConsumerClassNames", &vProp, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Provider", L"key", 0, &vk);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


void CCIMOMIdentificationClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__CIMOMIdentification");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

//  Registry r1(WBEM_REG_WBEM);
    Registry r(WBEM_REG_WINMGMT);
    SetPropFromReg(&r, __TEXT("Working Directory"), L"WorkingDirectory");
    SetPropFromReg(&r, __TEXT("SetupTime"), L"SetupTime");
    SetPropFromReg(&r, __TEXT("SetupDate"), L"SetupDate");

    // Get the current dll version info

    WCHAR wcVer[MAX_PATH];
    BOOL bRet = ConfigMgr::GetDllVersion(__TEXT("wbemcore.dll"), __TEXT("ProductVersion"),
                                                wcVer, MAX_PATH);
    if(bRet)
    {
        CVar v2(VT_BSTR, wcVer);
        hRes = SetPropValue(L"VersionUsedToCreateDB", &v2, CIM_STRING);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
    }
    else
    {
        hRes = Put(L"VersionUsedToCreateDB", 0, NULL, VT_BSTR);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
    }
    hRes = Put(L"VersionCurrentlyRunning", 0, NULL, VT_BSTR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CCIMOMIdentificationClass::SetPropFromReg(Registry * pReg, TCHAR * pcRegName,
                                                    WCHAR * pwcPropName)
{

    WCHAR wcTemp[MAX_PATH];
    TCHAR *pTemp = NULL;
    int iRet = pReg->GetStr(pcRegName, &pTemp);
    if (((iRet != Registry::no_error) && (pReg->GetLastError() == 0)) || ((iRet != Registry::no_error) && (pReg->GetLastError() == ERROR_OUTOFMEMORY)))
        throw CX_MemoryException();
    if (pTemp == NULL)
        return;

    StringCchCopyW(wcTemp, MAX_PATH, pTemp);
    CVar vVersion(VT_BSTR, wcTemp);
    HRESULT hRes = SetPropValue(pwcPropName, &vVersion, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
    {
        delete pTemp;
        throw CX_MemoryException();
    }

    delete pTemp;
}

// __AdapStatus

void CAdapStatusClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__AdapStatus");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"LastStartTime", &vEmpty, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"LastStopTime", &vEmpty, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Status", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CAdapStatusInstance::Init(CAdapStatusClass* pClass)
{
    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();

    WCHAR wszBuffer[100];
    StringCchPrintfW(wszBuffer, 100, L"%04u%02u%02u%02u%02u%02u.%06u:000",
                0, 0, 0, 0, 0, 0, 0);

    CVar v(VT_BSTR, wszBuffer);
    HRESULT hRes = SetPropValue(L"LastStartTime", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"LastStopTime", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar Var; //(VT_I4);
    Var.SetLong(0);
    hRes = SetPropValue(L"Status", &Var, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

// __CIMOMIdentification

void CIdentificationClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__CIMOMIdentification");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"WorkingDirectory", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SetupTime", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SetupDate", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"VersionUsedToCreateDB", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"VersionCurrentlyRunning", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CIdentificationInstance::Init(CIdentificationClass* pClass)
{

    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();

    HRESULT hRes;
    WCHAR wcVer[MAX_PATH];
    BOOL bRet = ConfigMgr::GetDllVersion(__TEXT("wbemcore.dll"), __TEXT("ProductVersion"), wcVer, MAX_PATH);
    if(bRet)
    {
        TCHAR *szDate;
        TCHAR *szTime;
        TCHAR *szWorkDir;

        //Get the time of installation
        Registry r(WBEM_REG_WINMGMT);
        r.GetStr(__TEXT("SetupDate"), (TCHAR **)&szDate);
        CDeleteMe<TCHAR> delMe1(szDate);
        r.GetStr(__TEXT("SetupTime"), (TCHAR **)&szTime);
        CDeleteMe<TCHAR> delMe2(szTime);
        r.GetStr(__TEXT("Working Directory"), (TCHAR **)&szWorkDir);
        CDeleteMe<TCHAR> delMe3(szWorkDir);


        if ((szDate == NULL) || (szTime == NULL) || (szWorkDir == NULL))
        {
            return;
        }

        CVar v(VT_BSTR, wcVer);
        hRes = SetPropValue(L"VersionUsedToCreateDB", &v, CIM_STRING);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        hRes = SetPropValue(L"VersionCurrentlyRunning", &v, CIM_STRING);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        BSTR TmpBString = SysAllocString(szDate);
        if (TmpBString)
        {
	        CVar v2(VT_BSTR,auto_bstr(TmpBString));
	        hRes = SetPropValue(L"SetupDate", &v2, CIM_STRING);
	        if (hRes == WBEM_E_OUT_OF_MEMORY)
	            throw CX_MemoryException();
        }
        else
        {
            throw CX_MemoryException();
        }

        TmpBString = SysAllocString(szTime);
        if (TmpBString)
        {
	        CVar v3(VT_BSTR,auto_bstr(TmpBString));
	        hRes = SetPropValue(L"SetupTime", &v3, CIM_STRING);
	        if (hRes == WBEM_E_OUT_OF_MEMORY)
	            throw CX_MemoryException();
        }
        else
        {
            throw CX_MemoryException();
        }

        TmpBString = SysAllocString(szWorkDir);
        if (TmpBString)
        {
	        CVar v4(VT_BSTR,auto_bstr(TmpBString));
	        hRes = SetPropValue(L"WorkingDirectory", &v4, CIM_STRING);
	        if (hRes == WBEM_E_OUT_OF_MEMORY)
	            throw CX_MemoryException();
	    }
	    else
	    {
	        throw CX_MemoryException();
	    }


    }


}



void CCacheControlClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__CacheControl");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CSpecificCacheControlClass::Init(LPCWSTR wszClassName)
{
    CCacheControlClass CacheControl;
    CacheControl.Init();
    HRESULT hRes = CreateDerivedClass(&CacheControl);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, (LPWSTR)wszClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();

    hRes = SetPropValue(L"ClearAfter", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vInterval(VT_BSTR, L"interval");
    hRes = SetPropQualifier(L"ClearAfter", L"SUBTYPE", SYNTAX_FLAVOR, &vInterval);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CCacheControlInstance::Init(CSpecificCacheControlClass* pClass,
                                    DWORD dwSeconds)
{
    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();

    DWORD dwDays = dwSeconds / (3600 * 24);
    dwSeconds -= dwDays * 3600 * 24;

    DWORD dwHours = dwSeconds / 3600;
    dwSeconds -= dwHours * 3600;

    DWORD dwMinutes = dwSeconds / 60;
    dwSeconds -= dwMinutes * 60;

    WCHAR wszBuffer[100];
    StringCchPrintfW(wszBuffer, 100, L"%04u%02u%02u%02u%02u%02u.%06u:000",
                0, 0, dwDays, dwHours, dwMinutes, dwSeconds, 0);

    CVar v(VT_BSTR, wszBuffer);
    HRESULT hRes = SetPropValue(L"ClearAfter", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CActiveNamespacesClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ListOfEventActiveNamespaces");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Namespaces", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CIndicationRelatedClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__IndicationRelated");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Event");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"TIME_CREATED", &vEmpty, CIM_UINT64);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    vEmpty.SetAsNull();
    hRes = SetPropValue(L"SECURITY_DESCRIPTOR", &vEmpty, CIM_FLAG_ARRAY | CIM_UINT8);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    // abstract forever --- all events are such.
    hRes = SetQualifier(L"abstract", &vk, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
                                   WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS |
                                   WBEM_FLAVOR_NOT_OVERRIDABLE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEmptyEventClass::Init(LPWSTR wszName)
{
    CEventClass EventClass;
    EventClass.Init();
    HRESULT hRes = CreateDerivedClass(&EventClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, wszName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CGenericDataEventClass::Init(LPWSTR wszCimType, LPWSTR wszPropSuffix)
{
    CEventClass EventClass;
    EventClass.Init();
    HRESULT hRes = CreateDerivedClass(&EventClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    WString wsClassName = L"__";
    wsClassName += wszPropSuffix;
    wsClassName += L"OperationEvent";

    CVar v(VT_BSTR, wsClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vCimType(VT_BSTR, wszCimType);
    CVar vEmpty;
    vEmpty.SetAsNull();

    WString wsPropName = L"Target";
    wsPropName += wszPropSuffix;
    hRes = SetPropValue(wsPropName, &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(wsPropName, TYPEQUAL, SYNTAX_FLAVOR, &vCimType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CDataEventClass::Init(CWbemClass& Parent,
                                LPWSTR wszCimType, LPWSTR wszPropSuffix,
                                int nFlags)
{
    HRESULT hRes = CreateDerivedClass(&Parent);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    WString wsClassName = L"__";
    wsClassName += wszPropSuffix;
    if(nFlags == include_new)
        wsClassName += L"Creation";
    else if(nFlags == include_old)
        wsClassName += L"Deletion";
    else
        wsClassName += L"Modification";
    wsClassName += L"Event";

    CVar v(VT_BSTR, wsClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    if(nFlags == (include_old | include_new))
    {
        CVar vCimType(VT_BSTR, wszCimType);
        CVar vEmpty;
        vEmpty.SetAsNull();

        WString wsPropName = L"Previous";
        wsPropName += wszPropSuffix;
        hRes = SetPropValue(wsPropName, &vEmpty, CIM_OBJECT);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        hRes = SetPropQualifier(wsPropName, TYPEQUAL, SYNTAX_FLAVOR, &vCimType);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
    }
}

void CMethodEventClass::Init()
{
    CGenericDataEventClass InstanceOp;
    InstanceOp.Init(L"object", L"Instance");

    HRESULT hRes = CreateDerivedClass(&InstanceOp);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__MethodInvocationEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes= SetPropValue(L"Method", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"PreCall", &vEmpty, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Parameters", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CTimerEventClass::Init()
{
    CEventClass EventClass;
    EventClass.Init();
    HRESULT hRes = CreateDerivedClass(&EventClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__TimerEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes= SetPropValue(L"TimerId", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"NumFirings", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CAggregateEventClass::Init()
{
    CIndicationRelatedClass IndClass;
    IndClass.Init();
    HRESULT hRes = CreateDerivedClass(&IndClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__AggregateEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"NumberOfEvents", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Representative", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CSystemEventClass::Init()
{
    CEmptyEventClass ExtClass;
    ExtClass.Init(L"__ExtrinsicEvent");
    HRESULT hRes = CreateDerivedClass(&ExtClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__SystemEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventDroppedEventClass::Init()
{
    CSystemEventClass SysClass;
    SysClass.Init();
    HRESULT hRes = CreateDerivedClass(&SysClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventDroppedEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Event", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"IntendedConsumer", &vEmpty, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEventType(VT_BSTR, L"object:__Event");
    hRes = SetPropQualifier(L"Event", TYPEQUAL, SYNTAX_FLAVOR, &vEventType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vConsType(VT_BSTR, L"ref:__EventConsumer");
    hRes = SetPropQualifier(L"IntendedConsumer", TYPEQUAL, SYNTAX_FLAVOR, &vConsType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CQueueOverflowEventClass::Init()
{
    CEventDroppedEventClass DropClass;
    DropClass.Init();
    HRESULT hRes = CreateDerivedClass(&DropClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventQueueOverflowEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"CurrentQueueSize", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vBytes(VT_BSTR, L"bytes");
    hRes = SetPropQualifier(L"CurrentQueueSize", L"units", UNITS_FLAVOR, &vBytes);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CConsumerFailureEventClass::Init()
{
    CEventDroppedEventClass DropClass;
    DropClass.Init();
    HRESULT hRes = CreateDerivedClass(&DropClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ConsumerFailureEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();

    hRes = SetPropValue(L"ErrorCode", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ErrorDescription", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ErrorObject", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmbType(VT_BSTR, L"object:__ExtendedStatus");
    hRes = SetPropQualifier(L"ErrorObject", L"CIMTYPE", 0, &vEmbType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CQoSFailureEventClass::Init()
{
    CEventDroppedEventClass DropClass;
    DropClass.Init();
    HRESULT hRes = CreateDerivedClass(&DropClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__QOSFailureEvent");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();

    hRes = SetPropValue(L"ErrorCode", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ErrorDescription", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CEventConsumerClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventConsumer");
    hRes = SetPropValue(L"__CLASS", &v, 0);

    CVar vProp;
    vProp.SetAsNull();

    hRes = SetPropValue(L"MachineName", &vProp, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"MaximumQueueSize", &vProp, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);

    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vt);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vBytes(VT_BSTR, L"bytes");
    hRes = SetPropQualifier(L"MaximumQueueSize", L"units", UNITS_FLAVOR, &vBytes);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CConditionalInstructionClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ConditionalInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue(VARIANT_TRUE, VT_BOOL);

    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Condition", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ConditionNamespace", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ConditionLanguage", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventFilterClass::Init()
{
#ifdef WHISTLER_UNCUT
    CConditionalInstructionClass ConditionalInstruction;
#else
    CIndicationRelatedClass ConditionalInstruction;
#endif

    ConditionalInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&ConditionalInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventFilter");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue(VARIANT_TRUE, VT_BOOL);

#ifdef WHISTLER_UNCUT
#else

    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

#endif

    hRes = SetPropValue(L"QueryLanguage", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Query", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"EventNamespace", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"EventAccess", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"Name", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CEventMonitorClass::Init()
{
    CConditionalInstructionClass ConditionalInstruction;
    ConditionalInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&ConditionalInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__MonitorInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue(VARIANT_TRUE, VT_BOOL);

    hRes = SetPropValue(L"QueryLanguage", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Query", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"TargetNamespace", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"Name", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CFilterConsumerBindingClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__FilterToConsumerBinding");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Filter", &vEmpty, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Consumer", &vEmpty, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFilterRef(VT_BSTR, L"ref:__EventFilter");
    hRes = SetPropQualifier(L"Filter", TYPEQUAL, SYNTAX_FLAVOR, &vFilterRef);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vConsumerRef(VT_BSTR, L"ref:__EventConsumer");
    hRes = SetPropQualifier(L"Consumer", TYPEQUAL, SYNTAX_FLAVOR, &vConsumerRef);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Filter", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"Consumer", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetQualifier(L"Association", &vTrue, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue( L"DeliveryQoS", &vEmpty, CIM_UINT32 );
    if ( hRes == WBEM_E_OUT_OF_MEMORY )
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"DeliverSynchronously", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"MaintainSecurityContext", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"SlowDownProviders", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vSid;
    if(!GetLocalSystemSid(vSid))
        throw CX_MemoryException();

    hRes = SetPropValue(L"CreatorSID", &vSid, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"DeliverSynchronously", L"not_null",
                        NOT_NULL_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"CreatorSID", L"read", READ_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CMonitorEventClass::Init(CWbemClass& Parent, LPCWSTR wszClassName)
{
    HRESULT hRes = CreateDerivedClass(&Parent);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    CVar v(VT_BSTR, (LPWSTR)wszClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"MonitorName", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"TotalObjects", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
};

void CMonitorDataEventClass::Init(CWbemClass& Parent, LPCWSTR wszClassName)
{
    HRESULT hRes = CreateDerivedClass(&Parent);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, (LPWSTR)wszClassName);
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"RowObject", &vEmpty, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"GuaranteedNew", &vEmpty, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
};


//*****************************************************************************

void CEventGeneratorClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__EventGenerator");
    hRes = SetPropValue(L"__CLASS", &v, 0);

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CTimerInstructionClass::Init()
{
    CEventGeneratorClass EventGenerator;
    EventGenerator.Init();
    HRESULT hRes = CreateDerivedClass(&EventGenerator);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__TimerInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"TimerId", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse(VARIANT_FALSE, VT_BOOL);
    hRes = SetPropValue(L"SkipIfPassed", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"TimerId", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CAbsoluteTimerInstructionClass::Init()
{
    CTimerInstructionClass TimerInstruction;
    TimerInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&TimerInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__AbsoluteTimerInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"EventDateTime", &vEmpty, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"EventDateTime", L"not_null", NOT_NULL_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CIntervalTimerInstructionClass::Init()
{
    CTimerInstructionClass TimerInstruction;
    TimerInstruction.Init();
    HRESULT hRes = CreateDerivedClass(&TimerInstruction);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__IntervalTimerInstruction");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vZero((LONG)0);
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"IntervalBetweenEvents", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"IntervalBetweenEvents", L"not_null", NOT_NULL_FLAVOR,
                        &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vSeconds(VT_BSTR, L"milliseconds");
    hRes = SetPropQualifier(L"IntervalBetweenEvents", L"units", UNITS_FLAVOR,
                        &vSeconds);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CTimerNextFiringClass::Init()
{
    CIndicationRelatedClass IndicationRelated;
    IndicationRelated.Init();
    HRESULT hRes = CreateDerivedClass(&IndicationRelated);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__TimerNextFiring");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    //CVar vEmpty(VT_BSTR, L"");
    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"TimerId", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"NextEvent64BitTime", &vEmpty, CIM_SINT64);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"TimerId", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"NextEvent64BitTime", L"not_null", NOT_NULL_FLAVOR, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

//******************************************************************************

void CSecurityBaseClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__SecurityRelatedClass");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CSubjectClass::Init()
{
    CSecurityBaseClass Base;
    Base.Init();
    HRESULT hRes = CreateDerivedClass(&Base);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Subject");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vDefAuth(VT_BSTR, L".");
    hRes = SetPropValue(L"Authority", &vDefAuth, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vFalse;
    vFalse.SetBool(VARIANT_FALSE);
    hRes = SetPropValue(L"Enabled", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Permissions", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ExecuteMethods", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"EditSecurity", &vFalse, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"Authority", L"key", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CUserClass::Init()
{
    CSubjectClass SubjectClass;
    SubjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&SubjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__User");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CNTLMUserClass::Init()
{
    CUserClass UserClass;
    UserClass.Init();
    HRESULT hRes = CreateDerivedClass(&UserClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__NTLMUser");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"GroupType", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CGroupClass::Init()
{
    CSubjectClass SubjectClass;
    SubjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&SubjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__Group");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    hRes = SetQualifier(L"abstract", &vTrue, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CNtlmGroupClass::Init()
{
    CSubjectClass SubjectClass;
    SubjectClass.Init();
    HRESULT hRes = CreateDerivedClass(&SubjectClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__NTLMGroup");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"GroupType", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


void CNTLM9XUserClass::Init()
{

    CSecurityBaseClass Base;
    Base.Init();
    HRESULT hRes = CreateDerivedClass(&Base);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    CVar v(VT_BSTR, L"__NTLMUser9X");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"Name", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vDefAuth(VT_BSTR, L".");
    hRes = SetPropValue(L"Authority", &vDefAuth, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Flags", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Mask", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Type", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}


void CSystemConfigClass::AddStaticQual(LPWSTR pMethodName)
{
    IWbemQualifierSet* pQualSet = NULL;
    HRESULT hRes = GetMethodQualifierSet(pMethodName, &pQualSet);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    if(pQualSet)
    {
        VARIANT var;
        var.vt = VT_BOOL; var.boolVal = VARIANT_TRUE;
        hRes = pQualSet->Put(L"Static", &var, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
        pQualSet->Release();
    }
}

void CSystemConfigClass::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}
    CVar v(VT_BSTR, L"__SystemSecurity");
    CVar vEmpty;
    vEmpty.SetAsNull();
    CVar vTrue;
    vTrue.SetBool(VARIANT_TRUE);
    CVar vID;
    vID.SetLong(0);

    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetQualifier(L"singleton", &vTrue, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the "uint32 GetSD([out, id(0)]uint8 sd[])" method

    CParametersClass * pGetSDOutputArgs = new CParametersClass;
    if(pGetSDOutputArgs == NULL)
        throw CX_MemoryException();
	pGetSDOutputArgs->Init();

    CReleaseMe relMe((IWbemClassObject*)pGetSDOutputArgs);
    hRes = pGetSDOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetSDOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pGetSDOutputArgs->SetPropValue(L"SD", &vEmpty, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetSDOutputArgs->SetPropQualifier(L"SD", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetSDOutputArgs->SetPropQualifier(L"SD", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method and clean up

    hRes = PutMethod(L"GetSD", 0, NULL, pGetSDOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    AddStaticQual(L"GetSD");

    // Add the "uint32 Get9XUserList([out, id(0)]instance of __NTLMUser9X ul[])" method

    CParametersClass * pGet9XOutputArgs = new CParametersClass;
    if(pGet9XOutputArgs == NULL)
        throw CX_MemoryException();
	pGet9XOutputArgs->Init();

    CReleaseMe relMe1((IWbemClassObject*)pGet9XOutputArgs);
    hRes = pGet9XOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pGet9XOutputArgs->SetPropValue(L"ul", &vEmpty, CIM_OBJECT | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ul", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ul", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vType;
    vType.SetBSTR(L"object:__ntlmuser9x");
    hRes = pGet9XOutputArgs->SetPropQualifier(L"ul", L"CIMTYPE", 0, &vType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method and clean up

    hRes = PutMethod(L"Get9XUserList", 0, NULL, pGet9XOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    AddStaticQual(L"Get9XUserList");

    // Add the "uint32 SetSD([in, id(0)]uint8 sd[])" method

    CParametersClass * pSetSDInputArgs = new CParametersClass;
    if(pSetSDInputArgs == NULL)
        throw CX_MemoryException();
	pSetSDInputArgs->Init();

	CParametersClass * pSetSDOutputArgs = new CParametersClass;
    if(pSetSDOutputArgs == NULL)
        throw CX_MemoryException();
	pSetSDOutputArgs->Init();

    CReleaseMe relMe2((IWbemClassObject*)pSetSDInputArgs);
    CReleaseMe relMe3((IWbemClassObject*)pSetSDOutputArgs);
    hRes = pSetSDInputArgs->SetPropValue(L"SD", &vEmpty, CIM_UINT8 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSetSDInputArgs->SetPropQualifier(L"SD", L"in", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSetSDInputArgs->SetPropQualifier(L"SD", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pSetSDOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSetSDOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method

    hRes = PutMethod(L"SetSD", 0, pSetSDInputArgs, pSetSDOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    AddStaticQual(L"SetSD");

    // Add the "uint32 Set9XUserList([in, id(0)]instance of __NTLMUser9X ul[])" method

    CParametersClass * pSet9XInputArgs = new CParametersClass;
    if(pSet9XInputArgs == NULL)
        throw CX_MemoryException();
	pSet9XInputArgs->Init();

    CParametersClass * pSet9XOutputArgs = new CParametersClass;
    if(pSet9XOutputArgs == NULL)
        throw CX_MemoryException();
	pSet9XOutputArgs->Init();

    CReleaseMe relMe4((IWbemClassObject*)pSet9XInputArgs);
    CReleaseMe relMe5((IWbemClassObject*)pSet9XOutputArgs);
    hRes = pSet9XInputArgs->SetPropValue(L"ul", &vEmpty, CIM_OBJECT | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSet9XInputArgs->SetPropQualifier(L"ul", L"in", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSet9XInputArgs->SetPropQualifier(L"ul", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    CVar vCimType;
    vCimType.SetBSTR(L"object:__ntlmuser9x");
    hRes = pSet9XInputArgs->SetPropQualifier(L"ul", L"CIMTYPE", 0, &vCimType);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pSet9XOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pSet9XOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method

    hRes = PutMethod(L"Set9XUserList", 0, pSet9XInputArgs, pSet9XOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    AddStaticQual(L"Set9XUserList");

    // Add the "uint32 GetCallerAccessRights([out, id(0)]sint32 rights)" method

	CParametersClass * pGetCallerAccessOutputArgs = new CParametersClass;
    if(pGetCallerAccessOutputArgs == NULL)
        throw CX_MemoryException();
	pGetCallerAccessOutputArgs->Init();

    CReleaseMe relMe6((IWbemClassObject*)pGetCallerAccessOutputArgs);
    hRes = pGetCallerAccessOutputArgs->SetPropValue(L"ReturnValue", &vEmpty, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetCallerAccessOutputArgs->SetPropQualifier(L"ReturnValue", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = pGetCallerAccessOutputArgs->SetPropValue(L"rights", &vEmpty, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetCallerAccessOutputArgs->SetPropQualifier(L"rights", L"out", 0, &vTrue);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = pGetCallerAccessOutputArgs->SetPropQualifier(L"rights", L"ID", 0, &vID);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Add the method and clean up

    hRes = PutMethod(L"GetCallerAccessRights", 0, NULL, pGetCallerAccessOutputArgs);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    AddStaticQual(L"GetCallerAccessRights");

}


void CSystemConfigInstance::Init(CSystemConfigClass* pClass)
{
    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();
}


//******************************************************************************

void CErrorObjectClass::Init()
{
    CNotifyStatusClass NotifyClass;
    NotifyClass.Init();
    HRESULT hRes = CreateDerivedClass(&NotifyClass);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__ExtendedStatus");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"ProviderName", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Operation", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ParameterInfo", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"Description", &vEmpty, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

CErrorObjectClass* CErrorObject::mstatic_pClass = NULL;
CStaticCritSec CErrorObject::mstatic_cs;
CErrorObject::__CleanUp CErrorObject::cleanup;

CErrorObject::CErrorObject(ADDREF IWbemClassObject* pObject)
{
    // Check for proper inheritance if we have an object.
    // Throw an OOM exception if we hit an OOM error condition.

    HRESULT hres = ( NULL != pObject ?
        pObject->InheritsFrom( L"__ExtendedStatus" ) :
        WBEM_E_FAILED );

    if( S_OK == hres )
    {
        m_pObject = (CWbemInstance*)pObject;
        m_pObject->AddRef();
    }
    else if ( WBEM_E_OUT_OF_MEMORY == hres )
    {
        throw CX_MemoryException();
    }
    else
    {
        CInCritSec local_lock (&mstatic_cs);  // SEC:REVIEWED 2002-03-22 : Assumes entry
        if(mstatic_pClass == NULL)
        {
			wmilib::auto_ptr<CErrorObjectClass> p(new CErrorObjectClass);
            if (p.get() == 0)
            {
                throw CX_MemoryException();
            }
            p->Init();
			mstatic_pClass = p.release();
        }

        m_pObject = new CWbemInstance;
        if (m_pObject == 0)
            throw CX_MemoryException();

		// Only reason this fails is OOM
        if ( FAILED( m_pObject->InitNew(mstatic_pClass, NEW_INSTANCE_PRECREATE_SIZE) ) )
		{
            throw CX_MemoryException();
		}
    }
}

CErrorObject::~CErrorObject()
{
    m_pObject->Release();
}

RELEASE_ME IWbemClassObject* CErrorObject::GetObject()
{
    m_pObject->AddRef();
    return (IWbemClassObject*)m_pObject;
}

BOOL CErrorObject::SetStatusCode(SCODE sRes)
{
    CVar v((LONG)sRes);
    HRESULT hRes = m_pObject->SetPropValue(L"StatusCode", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    return SUCCEEDED(hRes);
}

BOOL CErrorObject::SetOperation(COPY LPWSTR wszOperation)
{
    CVar vOldOperation;
    HRESULT hRes = m_pObject->GetProperty(L"Operation", &vOldOperation);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
   if(vOldOperation.IsNull())
    {
        CVar v(VT_BSTR, wszOperation);
        hRes = m_pObject->SetPropValue(L"Operation", &v, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        return SUCCEEDED(hRes);
    }
    else return FALSE;
}

BOOL CErrorObject::SetParamInformation(COPY LPWSTR wszExtraInfo)
{
    CVar vOldInfo;
    HRESULT hRes = m_pObject->GetProperty(L"ParameterInfo", &vOldInfo);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(vOldInfo.IsNull())
    {
        CVar v(VT_BSTR, wszExtraInfo);
        hRes = m_pObject->SetPropValue(L"ParameterInfo", &v, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        return SUCCEEDED(hRes);
    }
    else return FALSE;
}

BOOL CErrorObject::SetProviderName(COPY LPWSTR wszName)
{
    // Check if already set
    // ====================

    CVar vOldName;
    HRESULT hRes = m_pObject->GetProperty(L"ProviderName", &vOldName);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(vOldName.IsNull() || vOldName.GetType() == VT_EMPTY ||
                                !wbem_wcsicmp(vOldName.GetLPWSTR(), L"WinMgmt"))
    {
        CVar v(VT_BSTR, wszName);
        hRes = m_pObject->SetPropValue(L"ProviderName", &v, 0);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

        return SUCCEEDED(hRes);
    }
    else return WBEM_S_NO_ERROR;
}

BOOL CErrorObject::MarkAsInternal()
{
    return SetProviderName(L"WinMgmt");
}

BOOL CErrorObject::ContainsOperationInfo()
{
    CVar v;
    HRESULT hRes = m_pObject->GetProperty(L"Operation", &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(FAILED(hRes))
        return FALSE;
    return !v.IsNull();
}

BOOL CErrorObject::ContainsStatusCode()
{
    CVar v;
    HRESULT hRes = m_pObject->GetProperty(L"StatusCode", &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    if(FAILED(hRes))
        return FALSE;
    return !v.IsNull();
}




//******************************************************************************

/*
Blackcomb only

LPCWSTR	g_awszTxnClass[] = { L"Prestart", L"Pending", L"Precommit", L"Commit", L"EventPlayback", L"Completed", L"RolledBack",
							L"Cleanup", L"Fatal" };
void CTransactionClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__Transaction");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"GUID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark GUID as key
    // ================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"GUID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"ClientComment", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ClientID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"State", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	SAFEARRAY *pArray = NULL;
    SAFEARRAYBOUND aBounds[1];
    long lLBound = 0, lUBound = 9;

    aBounds[0].cElements = lUBound;
    aBounds[0].lLbound = 0;

    pArray = SafeArrayCreate(VT_BSTR, 1, aBounds);
    if (pArray)
    {
		long	lNumElements = sizeof(g_awszTxnClass)/sizeof(LPCWSTR);

		for ( long	lCtr = 0; lCtr < lNumElements; lCtr++ )
		{
			BSTR	bstrTemp = SysAllocString( g_awszTxnClass[lCtr] );
			if ( NULL == bstrTemp )
			{
				throw CX_MemoryException();
			}

			// SafeArrayPutElement copies the BSTR so we still have to free it
			CSysFreeMe	sfm( bstrTemp );
			long lTemp[1];
			lTemp[0] = lCtr;
			if ( FAILED( SafeArrayPutElement(pArray, lTemp, bstrTemp) ) )
			{
				throw CX_MemoryException();
			}
		}

        CVar vc(VT_BSTR, pArray);
        hRes = SetPropQualifier(L"State", L"values", VALUES_FLAVOR, &vc);
        if (hRes == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();

		// We won't need the safe array anymore, so go ahead and destroy it
		SafeArrayDestroy( pArray );
    }

    hRes = SetPropValue(L"Start", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"LastUpdate", &vNull, CIM_DATETIME);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}


void CUncommittedEventClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__UncommittedEvent");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"EventID", &vNull, CIM_UINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark EventID as key, keyhole.
    // =============================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"EventID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"EventID", L"keyhole", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Transaction GUID is indexed
    // ===========================

    hRes = SetPropValue(L"TransactionGUID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropQualifier(L"TransactionGUID", L"indexed", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamespaceName", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"ClassName", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"OldObject", &vNull, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
    hRes = SetPropValue(L"NewObject", &vNull, CIM_OBJECT);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Transacted", &vNull, CIM_BOOLEAN);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

*/



//******************************************************************************
/*
void CNamespaceMapClass::Init()
{
    CNamespaceClass NsBase;
    NsBase.Init();
    HRESULT hRes = CreateDerivedClass(&NsBase);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__WmiMappedDriverNamespace");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Server", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Database", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"UserID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Password", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Config", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}
*/

//******************************************************************************

/* The following system classes were removed for Whistler, but may
   be reintroduced for Blackcomb

void CClassInstanceSecurity::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__ClassInstancesSecurity");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CClassSecurity::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__ClassSecurity");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"Name", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}
*/


void CClasses::Init()
{
    if ( FAILED( InitEmpty(NEW_CLASS_PRECREATE_SIZE) ) )
	{
		throw CX_MemoryException();
	}

    CVar v(VT_BSTR, L"__Classes");
    HRESULT hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vb, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

//================================================================
struct { const wchar_t *wszPropName; DWORD dwPropValue; } g_arbitratorConfigurationDefaults[] =
{
		{ L"OutstandingTasksTotal",         3000 },		//Total
		{ L"OutstandingTasksPerUser",       30 },		//Total

		{ L"TaskThreadsTotal",              30 },		//Total
		{ L"TaskThreadsPerUser",            3 },		//Total

		{ L"QuotaRetryCount",               10 },		//Total
		{ L"QuotaRetryWaitInterval",        15000 },	//Milliseconds

		{ L"TotalUsers",                    50 },		//Total

		{ L"TotalCacheMemoryPerTask",       1024 },		//1 MB
		{ L"TotalCacheMemoryPerUser",       2048 },		//2 MB
		{ L"TotalCacheMemory",              10240 },	//10 MB

		{ L"TotalCacheDiskPerTask",         51250 },	//50 MB
		{ L"TotalCacheDiskPerUser",         102500 },	//100 MB
		{ L"TotalCacheDisk",                1048576 },	//1 GB

		{ L"TemporarySubscriptionsPerUser", 1000 },	    //Total
		{ L"PermanentSubscriptionsPerUser",	1000 },	    //Total
		{ L"PollingInstructionsPerUser",	1000 },	    //Total
		{ L"PollingMemoryPerUser",	5000000 },	    //Total

		{ L"TemporarySubscriptionsTotal",   10000 },	//Total
		{ L"PermanentSubscriptionsTotal",	10000 },	//Total
		{ L"PollingInstructionsTotal",	    10000 },	//Total
		{ L"PollingMemoryTotal",	    10000000 },	//Total

		{ NULL,							0 }
};
void CArbitratorConfiguration::Init()
{
	//This is derived from __SystemClass
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	//Set class name
	{
		CVar v(VT_BSTR, L"__ArbitratorConfiguration");
		hRes = SetPropValue(L"__CLASS", &v, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Singleton object
	{
		CVar vk(VARIANT_TRUE, VT_BOOL);
		hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Add properties
	CVar vs;
	vs.SetAsNull();
	for (int i = 0; g_arbitratorConfigurationDefaults[i].wszPropName != NULL; i++)
	{
		hRes = SetPropValue(g_arbitratorConfigurationDefaults[i].wszPropName, &vs, CIM_UINT32);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

}


void CArbitratorConfigurationInstance::Init(CArbitratorConfiguration* pClass)
{
    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();

	//Set propery values
	for (int i = 0; g_arbitratorConfigurationDefaults[i].wszPropName != NULL; i++)
	{
		CVar var;
		var.SetLong(g_arbitratorConfigurationDefaults[i].dwPropValue);
		HRESULT hRes = SetPropValue(g_arbitratorConfigurationDefaults[i].wszPropName, &var, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct { const wchar_t *wszPropName; UINT32 dwPropValue; } g_ProviderHostQuotaConfigurationDefaultsUint32[] =
{
		{ L"ThreadsPerHost",		0x00000100 },
		{ L"HandlesPerHost",		0x00001000 },
		{ L"ProcessLimitAllHosts",	0x00000020 },
		{ NULL,						0 }
} ;

struct { const wchar_t *wszPropName; UINT64 dwPropValue; } g_ProviderHostQuotaConfigurationDefaultsUint64[] =
{
		{ L"MemoryPerHost",			0x0000000008000000 },
		{ L"MemoryAllHosts",		0x0000000040000000 },
		{ NULL,						0 }
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CProviderHostQuotaConfiguration::Init()
{
	//This is derived from __SystemClass
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	//Set class name
	{
		CVar v(VT_BSTR, L"__ProviderHostQuotaConfiguration");
		hRes = SetPropValue(L"__CLASS", &v, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Singleton object
	{
		CVar vk(VARIANT_TRUE, VT_BOOL);
		hRes = SetQualifier(L"singleton", &vk, SINGLETON_FLAVOR);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	//Add properties
	CVar vs;
	vs.SetAsNull();
	for (int i = 0; g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName != NULL; i++)
	{
		hRes = SetPropValue(g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName, &vs, CIM_UINT32);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	for (i = 0; g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName != NULL; i++)
	{
		hRes = SetPropValue(g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName, &vs, CIM_UINT64);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void CProviderHostQuotaConfigurationInstance::Init(CProviderHostQuotaConfiguration* pClass)
{
    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();

	//Set propery values
	for (int i = 0; g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName != NULL; i++)
	{
		CVar var;
		var.SetLong(g_ProviderHostQuotaConfigurationDefaultsUint32[i].dwPropValue);
		HRESULT hRes = SetPropValue(g_ProviderHostQuotaConfigurationDefaultsUint32[i].wszPropName, &var, 0);
		if (hRes == WBEM_E_OUT_OF_MEMORY)
			throw CX_MemoryException();
	}

	_IWmiObject *t_FastThis = NULL ;
	HRESULT hRes = QueryInterface ( IID__IWmiObject , ( void ** ) & t_FastThis ) ;
	if ( SUCCEEDED ( hRes ) )
	{
		for (i = 0; g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName != NULL; i++)
		{
			hRes = t_FastThis->WriteProp (

				g_ProviderHostQuotaConfigurationDefaultsUint64[i].wszPropName,
				0 ,
				sizeof ( UINT64 ) ,
				1 ,
				CIM_UINT64 ,
				& g_ProviderHostQuotaConfigurationDefaultsUint64[i].dwPropValue
			) ;

			if (hRes == WBEM_E_OUT_OF_MEMORY)
				throw CX_MemoryException();
		}

		t_FastThis->Release () ;
	}
}

/*
Removed for Whistler

void CComTaxonomyClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__COMTaxonomy");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vk(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vk, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

void CComInterfaceSetClass::Init()
{
    CComTaxonomyClass ComTaxonomy;
    ComTaxonomy.Init();
    HRESULT hRes = CreateDerivedClass(&ComTaxonomy);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMInterfaceSet");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark CLSID as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"CLSID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"IID", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"IIDNames", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CComDispatchElementClass::Init()
{
    CComTaxonomyClass ComTaxonomy;
    ComTaxonomy.Init();
    HRESULT hRes = CreateDerivedClass(&ComTaxonomy);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMDispatchElement");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"DISPID", &vNull, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    // Mark CLSID and DispId as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"CLSID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"DISPID", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArguments", &vNull, CIM_STRING | CIM_FLAG_ARRAY );
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArgumentDISPIDs", &vNull, CIM_SINT32 | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArgumentTypes", &vNull, CIM_STRING | CIM_FLAG_ARRAY);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CComDispatchInfoClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__COMDispatchInfo");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"CLSID", &vNull, CIM_STRING);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"DISPID", &vNull, CIM_SINT32);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"NamedArgumentDISPIDs", &vNull, CIM_SINT32 | CIM_FLAG_ARRAY );
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CComBindingClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__COMBinding");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"abstract", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}


void CComInterfaceSetBindingClass::Init()
{
    CComBindingClass ComBinding;
    ComBinding.Init();
    HRESULT hRes = CreateDerivedClass(&ComBinding);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMInterfaceSetToClassBinding");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Association
    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"association", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// HasClassRefs
    hRes = SetQualifier(L"HasClassRefs", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"InterfaceSet", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"TargetClass", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark proeprties as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"InterfaceSet", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"TargetClass", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Both properties are strongly typed references.
	v.Empty();
	v.SetBSTR( L"ref:__COMInterfaceSet" );
    hRes = SetPropQualifier(L"InterfaceSet", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	v.Empty();
	v.SetBSTR( L"ref:__ClassVector" );
    hRes = SetPropQualifier(L"TargetClass", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();



}

void CComDispatchElementBindingClass::Init()
{
    CComBindingClass ComBinding;
    ComBinding.Init();
    HRESULT hRes = CreateDerivedClass(&ComBinding);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__COMDispatchElementToClassBinding");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Association
    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"association", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// HasClassRefs
    hRes = SetQualifier(L"HasClassRefs", &vt, ASSOC_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"DispatchElement", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropValue(L"TargetClass", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    // Mark proeprties as 'key'.
    // ===================
    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"DispatchElement", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    hRes = SetPropQualifier(L"TargetClass", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	// Both properties are strongly typed references.
	v.Empty();
	v.SetBSTR( L"ref:__COMDispatchElement" );
    hRes = SetPropQualifier(L"DispatchElement", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

	v.Empty();
	v.SetBSTR( L"ref:__ClassVector" );
    hRes = SetPropQualifier(L"TargetClass", L"CIMTYPE", 0, &v);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


}

void CClassVectorClass::Init()
{
    InitEmpty(NEW_CLASS_PRECREATE_SIZE);

    CVar v(VT_BSTR, L"__ClassVector");
    HRESULT	hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vt(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"vector", &vt, ABSTRACT_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vNull;
    vNull.SetAsNull();
    hRes = SetPropValue(L"ClassPath", &vNull, CIM_REFERENCE);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar vb(VARIANT_TRUE, VT_BOOL);
    hRes = SetPropQualifier(L"ClassPath", L"key", 0, &vb);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\sysclass.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    sysclass.CPP

Abstract:

    System class generation function.

History:

--*/

#include "precomp.h"
#include "wbemcore.h"

HRESULT GetSystemStdObjects(CFlexArray * pResults)
{
	HRESULT hr = S_OK;

    // Create system classes
    // =====================

    CSystemClass * pSystemClass = new CSystemClass;
	if(pSystemClass) pSystemClass->Init();
	if(pSystemClass == NULL || CFlexArray::no_error != pResults->Add(pSystemClass))
		return WBEM_E_OUT_OF_MEMORY;
	

    CNamespaceClass * pNamespaceClass = new CNamespaceClass;
    if(pNamespaceClass) pNamespaceClass->Init();
	if(pNamespaceClass == NULL || CFlexArray::no_error != pResults->Add(pNamespaceClass))
		return WBEM_E_OUT_OF_MEMORY;

    CThisNamespaceClass * pThisNamespaceClass = new CThisNamespaceClass;
    if(pThisNamespaceClass) pThisNamespaceClass->Init();
	if(pThisNamespaceClass == NULL || CFlexArray::no_error != pResults->Add(pThisNamespaceClass))
		return WBEM_E_OUT_OF_MEMORY;

    CProviderClass * pProviderClass = new CProviderClass;
    if(pProviderClass) pProviderClass->Init();
	if(pProviderClass == NULL || CFlexArray::no_error != pResults->Add(pProviderClass))
		return WBEM_E_OUT_OF_MEMORY;

    CWin32ProviderClass * pWin32Prov = new CWin32ProviderClass;
    if(pWin32Prov) pWin32Prov->Init();
	if(pWin32Prov == NULL || CFlexArray::no_error != pResults->Add(pWin32Prov))
		return WBEM_E_OUT_OF_MEMORY;

    CProviderRegistrationClass * pProvRegistration = new CProviderRegistrationClass;
    if(pProvRegistration) pProvRegistration->Init();
	if(pProvRegistration == NULL || CFlexArray::no_error != pResults->Add(pProvRegistration))
		return WBEM_E_OUT_OF_MEMORY;

    CObjectProviderRegistrationClass *  pObjectProvReg = new CObjectProviderRegistrationClass;
    if(pObjectProvReg) pObjectProvReg->Init();
	if(pObjectProvReg == NULL || CFlexArray::no_error != pResults->Add(pObjectProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CClassProviderRegistrationClass  * pClassProvReg = new CClassProviderRegistrationClass;
    if(pClassProvReg) pClassProvReg->Init();
	if(pClassProvReg == NULL || CFlexArray::no_error != pResults->Add(pClassProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceProviderRegistrationClass * pInstProvReg = new CInstanceProviderRegistrationClass;
    if(pInstProvReg) pInstProvReg->Init();
	if(pInstProvReg == NULL || CFlexArray::no_error != pResults->Add(pInstProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CPropertyProviderRegistrationClass * pPropProvReg = new CPropertyProviderRegistrationClass;
    if(pPropProvReg) pPropProvReg->Init();
	if(pPropProvReg == NULL || CFlexArray::no_error != pResults->Add(pPropProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CMethodProviderRegistrationClass * pMethodProvReg = new CMethodProviderRegistrationClass;
    if(pMethodProvReg) pMethodProvReg->Init();
	if(pMethodProvReg == NULL || CFlexArray::no_error != pResults->Add(pMethodProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CEventProviderRegistrationClass *pEventProvReg = new CEventProviderRegistrationClass;
    if(pEventProvReg) pEventProvReg->Init();
	if(pEventProvReg == NULL || CFlexArray::no_error != pResults->Add(pEventProvReg))
		return WBEM_E_OUT_OF_MEMORY;

    CEventConsumerProviderRegistrationClass *  pEventConsumer = new CEventConsumerProviderRegistrationClass;
    if(pEventConsumer) pEventConsumer->Init();
	if(pEventConsumer == NULL || CFlexArray::no_error != pResults->Add(pEventConsumer))
		return WBEM_E_OUT_OF_MEMORY;

    CNotifyStatusClass  * pNotifyStatusClass = new CNotifyStatusClass;
    if(pNotifyStatusClass) pNotifyStatusClass->Init();
	if(pNotifyStatusClass == NULL || CFlexArray::no_error != pResults->Add(pNotifyStatusClass))
		return WBEM_E_OUT_OF_MEMORY;

    CErrorObjectClass * pErrorObjectClass = new CErrorObjectClass;
    if(pErrorObjectClass) pErrorObjectClass->Init();
	if(pErrorObjectClass == NULL || CFlexArray::no_error != pResults->Add(pErrorObjectClass))
		return WBEM_E_OUT_OF_MEMORY;

    CSecurityBaseClass * pSecurityBaseClass = new CSecurityBaseClass;
    if(pSecurityBaseClass) pSecurityBaseClass->Init();
	if(pSecurityBaseClass == NULL || CFlexArray::no_error != pResults->Add(pSecurityBaseClass))
		return WBEM_E_OUT_OF_MEMORY;

    CNTLM9XUserClass * pNTLM9XUser = new CNTLM9XUserClass;
    if(pNTLM9XUser) pNTLM9XUser->Init();
	if(pNTLM9XUser == NULL || CFlexArray::no_error != pResults->Add(pNTLM9XUser))
		return WBEM_E_OUT_OF_MEMORY;


    // Create event classes
    // ====================

    CIndicationRelatedClass * IndicationRelated = new CIndicationRelatedClass;
    if(IndicationRelated)IndicationRelated->Init();
	if(IndicationRelated == NULL || CFlexArray::no_error != pResults->Add(IndicationRelated))
		return WBEM_E_OUT_OF_MEMORY;

    CEventClass * Event = new CEventClass;
    if(Event)Event->Init();
	if(Event == NULL || CFlexArray::no_error != pResults->Add(Event))
		return WBEM_E_OUT_OF_MEMORY;

    CParametersClass * Parameters = new CParametersClass;
    if(Parameters)Parameters->Init();
	if(Parameters == NULL || CFlexArray::no_error != pResults->Add(Parameters))
		return WBEM_E_OUT_OF_MEMORY;

    CEmptyEventClass * pExtrinsicEvent = new CEmptyEventClass;
    if(pExtrinsicEvent)pExtrinsicEvent->Init(L"__ExtrinsicEvent");
	if(pExtrinsicEvent == NULL ||
            CFlexArray::no_error != pResults->Add(pExtrinsicEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CGenericDataEventClass * NamespaceEvent = new CGenericDataEventClass;
    if(NamespaceEvent)NamespaceEvent->Init(L"object:__Namespace", L"Namespace");
	if(NamespaceEvent == NULL || CFlexArray::no_error != pResults->Add(NamespaceEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CNamespaceEventClass * E1 = new CNamespaceEventClass;
    if(E1)E1->Init(*NamespaceEvent, CDataEventClass::type_create);
	if(E1 == NULL || CFlexArray::no_error != pResults->Add(E1))
		return WBEM_E_OUT_OF_MEMORY;

	CNamespaceEventClass * E2 = new CNamespaceEventClass;
    if(E2)E2->Init(*NamespaceEvent, CDataEventClass::type_delete);
	if(E2 == NULL || CFlexArray::no_error != pResults->Add(E2))
		return WBEM_E_OUT_OF_MEMORY;

	CNamespaceEventClass * E3 = new CNamespaceEventClass;
    E3->Init(*NamespaceEvent, CDataEventClass::type_change);
	if(E3 == NULL || CFlexArray::no_error != pResults->Add(E3))
		return WBEM_E_OUT_OF_MEMORY;

    CGenericDataEventClass * ClassEvent = new CGenericDataEventClass;
    if(ClassEvent)ClassEvent->Init(L"object", L"Class");
	if(ClassEvent == NULL || CFlexArray::no_error != pResults->Add(ClassEvent))
		return WBEM_E_OUT_OF_MEMORY;


    CClassEventClass * E4 = new CClassEventClass;
    if(E4)E4->Init(*ClassEvent, CDataEventClass::type_create);
	if(E4 == NULL || CFlexArray::no_error != pResults->Add(E4))
		return WBEM_E_OUT_OF_MEMORY;

    CClassEventClass * E5 = new CClassEventClass;
    if(E5)E5->Init(*ClassEvent, CDataEventClass::type_delete);
	if(E5 == NULL || CFlexArray::no_error != pResults->Add(E5))
		return WBEM_E_OUT_OF_MEMORY;

    CClassEventClass * E6 = new CClassEventClass;
    if(E6)E6->Init(*ClassEvent, CDataEventClass::type_change);
	if(E6 == NULL || CFlexArray::no_error != pResults->Add(E6))
		return WBEM_E_OUT_OF_MEMORY;

    CGenericDataEventClass * InstanceEvent = new CGenericDataEventClass;
    if(InstanceEvent)InstanceEvent->Init(L"object", L"Instance");
	if(InstanceEvent == NULL || CFlexArray::no_error != pResults->Add(InstanceEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceEventClass * E7 = new CInstanceEventClass;
    if(E7)E7->Init(*InstanceEvent, CDataEventClass::type_create);
	if(E7 == NULL || CFlexArray::no_error != pResults->Add(E7))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceEventClass * E8 = new CInstanceEventClass;
    if(E8)E8->Init(*InstanceEvent, CDataEventClass::type_delete);
	if(E8 == NULL || CFlexArray::no_error != pResults->Add(E8))
		return WBEM_E_OUT_OF_MEMORY;

    CInstanceEventClass * E9 = new CInstanceEventClass;
    if(E9)E9->Init(*InstanceEvent, CDataEventClass::type_change);
	if(E9 == NULL || CFlexArray::no_error != pResults->Add(E9))
		return WBEM_E_OUT_OF_MEMORY;

    CMethodEventClass * EE9 = new CMethodEventClass;
    if(EE9)EE9->Init();
	if(EE9 == NULL || CFlexArray::no_error != pResults->Add(EE9))
		return WBEM_E_OUT_OF_MEMORY;

    CTimerEventClass * Event14 = new CTimerEventClass;
    if(Event14)Event14->Init();
	if(Event14 == NULL || CFlexArray::no_error != pResults->Add(Event14))
		return WBEM_E_OUT_OF_MEMORY;

    CAggregateEventClass * Event15 = new CAggregateEventClass;
    if(Event15)Event15->Init();
	if(Event15 == NULL || CFlexArray::no_error != pResults->Add(Event15))
		return WBEM_E_OUT_OF_MEMORY;

#ifdef __WHISTLER_UNCUT

    // Add monitor events
    // ==================

    CMonitorEventClass* pMonitorEvent = new CMonitorEventClass;
    if(pMonitorEvent) pMonitorEvent->Init(*pExtrinsicEvent, L"__MonitorEvent");
	if(pMonitorEvent == NULL ||
            CFlexArray::no_error != pResults->Add(pMonitorEvent))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorEventClass* pMEUp = new CMonitorEventClass;
    if(pMEUp) pMEUp->Init(*pMonitorEvent, L"__MonitorUpEvent");
	if(pMEUp == NULL || CFlexArray::no_error != pResults->Add(pMEUp))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorEventClass* pMEDown = new CMonitorEventClass;
    if(pMEDown) pMEDown->Init(*pMonitorEvent, L"__MonitorDownEvent");
	if(pMEDown == NULL || CFlexArray::no_error != pResults->Add(pMEDown))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorEventClass* pMEError = new CMonitorEventClass;
    if(pMEError) pMEError->Init(*pMonitorEvent, L"__MonitorErrorEvent");
	if(pMEError == NULL || CFlexArray::no_error != pResults->Add(pMEError))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorDataEventClass* pMEData = new CMonitorDataEventClass;
    if(pMEData) pMEData->Init(*pMonitorEvent, L"__MonitorDataEvent");
	if(pMEData == NULL || CFlexArray::no_error != pResults->Add(pMEData))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorDataEventClass* pMEAssert = new CMonitorDataEventClass;
    if(pMEAssert) pMEAssert->Init(*pMEData, L"__MonitorAssertEvent");
	if(pMEAssert == NULL || CFlexArray::no_error != pResults->Add(pMEAssert))
		return WBEM_E_OUT_OF_MEMORY;

    CMonitorDataEventClass* pMERetract = new CMonitorDataEventClass;
    if(pMERetract) pMERetract->Init(*pMEData, L"__MonitorRetractEvent");
	if(pMERetract == NULL || CFlexArray::no_error != pResults->Add(pMERetract))
		return WBEM_E_OUT_OF_MEMORY;

#endif

    // Create event consumer class
    // ===========================

    CEventConsumerClass * Consumer = new CEventConsumerClass;
    if(Consumer)Consumer->Init();
	if(Consumer == NULL || CFlexArray::no_error != pResults->Add(Consumer))
		return WBEM_E_OUT_OF_MEMORY;


    // Create event filter classes
    // ===========================


#ifdef __WHISTLER_UNCUT
    CConditionalInstructionClass * CondInst = new CConditionalInstructionClass;
    if(CondInst)CondInst->Init();
	if(CondInst == NULL || CFlexArray::no_error != pResults->Add(CondInst))
		return WBEM_E_OUT_OF_MEMORY;

    CEventMonitorClass * EventMonitor = new CEventMonitorClass;
    if(EventMonitor)EventMonitor->Init();
	if(EventMonitor == NULL ||
            CFlexArray::no_error != pResults->Add(EventMonitor))
		return WBEM_E_OUT_OF_MEMORY;

#endif

    CEventFilterClass * Filter = new CEventFilterClass;
    if(Filter)Filter->Init();
	if(Filter == NULL || CFlexArray::no_error != pResults->Add(Filter))
		return WBEM_E_OUT_OF_MEMORY;

    // Create the binding class
    // ========================

    CFilterConsumerBindingClass * Binding = new CFilterConsumerBindingClass;
    if(Binding)Binding->Init();
	if(Binding == NULL || CFlexArray::no_error != pResults->Add(Binding))
		return WBEM_E_OUT_OF_MEMORY;

    // Create timer generators
    // =======================

    CEventGeneratorClass * Generator = new CEventGeneratorClass;
    if(Generator)Generator->Init();
	if(Generator == NULL || CFlexArray::no_error != pResults->Add(Generator))
		return WBEM_E_OUT_OF_MEMORY;

    CTimerInstructionClass * TI = new CTimerInstructionClass;
    if(TI)TI->Init();
	if(TI == NULL || CFlexArray::no_error != pResults->Add(TI))
		return WBEM_E_OUT_OF_MEMORY;

    CAbsoluteTimerInstructionClass * ATI = new CAbsoluteTimerInstructionClass;
    if(ATI)ATI->Init();
	if(ATI == NULL || CFlexArray::no_error != pResults->Add(ATI))
		return WBEM_E_OUT_OF_MEMORY;

    CIntervalTimerInstructionClass * ITI = new CIntervalTimerInstructionClass;
    if(ITI)ITI->Init();
	if(ITI == NULL || CFlexArray::no_error != pResults->Add(ITI))
		return WBEM_E_OUT_OF_MEMORY;

    CTimerNextFiringClass * TNF = new CTimerNextFiringClass;
    if(TNF)TNF->Init();
	if(TNF == NULL || CFlexArray::no_error != pResults->Add(TNF))
		return WBEM_E_OUT_OF_MEMORY;

    // Create error event classes
    // ==========================


    CSystemEventClass * Event16 = new CSystemEventClass;
    if(Event16)Event16->Init();
	if(Event16 == NULL || CFlexArray::no_error != pResults->Add(Event16))
		return WBEM_E_OUT_OF_MEMORY;

    CEventDroppedEventClass * Event17 = new CEventDroppedEventClass;
    if(Event17)Event17->Init();
	if(Event17 == NULL || CFlexArray::no_error != pResults->Add(Event17))
		return WBEM_E_OUT_OF_MEMORY;

    CQueueOverflowEventClass * Event18 = new CQueueOverflowEventClass;
    if(Event18)Event18->Init();
	if(Event18 == NULL || CFlexArray::no_error != pResults->Add(Event18))
		return WBEM_E_OUT_OF_MEMORY;

    CConsumerFailureEventClass * Event19 = new CConsumerFailureEventClass;
    if(Event19)Event19->Init();
	if(Event19 == NULL || CFlexArray::no_error != pResults->Add(Event19))
		return WBEM_E_OUT_OF_MEMORY;


    CQoSFailureEventClass * Event20 = new CQoSFailureEventClass;
    if(Event20)Event20->Init();
	if(Event20 == NULL || CFlexArray::no_error != pResults->Add(Event20))
		return WBEM_E_OUT_OF_MEMORY;

/*
    CTransactionClass * TransactionClass = new CTransactionClass;
    if(TransactionClass)TransactionClass->Init();
	if(TransactionClass == NULL || CFlexArray::no_error != pResults->Add(TransactionClass))
		return WBEM_E_OUT_OF_MEMORY;

    CUncommittedEventClass * UncommittedEventClass = new CUncommittedEventClass;
    if(UncommittedEventClass)UncommittedEventClass->Init();
	if(UncommittedEventClass == NULL || CFlexArray::no_error != pResults->Add(UncommittedEventClass))
		return WBEM_E_OUT_OF_MEMORY;

    CClassSecurity * ClassSecurity = new CClassSecurity;
    if(ClassSecurity)ClassSecurity->Init();
	if(ClassSecurity == NULL || CFlexArray::no_error != pResults->Add(ClassSecurity))
		return WBEM_E_OUT_OF_MEMORY;

    CClassInstanceSecurity * ClassInstanceSecurity = new CClassInstanceSecurity;
    if(ClassInstanceSecurity)ClassInstanceSecurity->Init();
	if(ClassInstanceSecurity == NULL || CFlexArray::no_error != pResults->Add(ClassInstanceSecurity))
		return WBEM_E_OUT_OF_MEMORY;

    CClasses * Classes = new CClasses;
    if(Classes)Classes->Init();
	if(Classes == NULL || CFlexArray::no_error != pResults->Add(Classes))
		return WBEM_E_OUT_OF_MEMORY;
*/

    // Add the security object which provides methods for getting/setting
    // the security descriptor
    // ==================================================================
    CSystemConfigClass  * pConfigClass = new CSystemConfigClass;
    pConfigClass->Init();
	if(pConfigClass == NULL || CFlexArray::no_error != pResults->Add(pConfigClass))
		return WBEM_E_OUT_OF_MEMORY;

   // Add in namespace mapping classes.
    // =================================
/*    
    CNamespaceMapClass *pNsClass = new CNamespaceMapClass;
    pNsClass->Init();
	if (pNsClass == NULL || CFlexArray::no_error != pResults->Add(pNsClass))
		return WBEM_E_OUT_OF_MEMORY;
*/		

	// New Class Vector class
/* Removed for Whistler

    CClassVectorClass *pClassVectorClass = new CClassVectorClass;
    pClassVectorClass->Init();
	if (pClassVectorClass == NULL || CFlexArray::no_error != pResults->Add(pClassVectorClass))
		return WBEM_E_OUT_OF_MEMORY;

	// COM Taxonomy classes
    CComTaxonomyClass *pComTaxonomyClass = new CComTaxonomyClass;
    pComTaxonomyClass->Init();
	if (pComTaxonomyClass == NULL || CFlexArray::no_error != pResults->Add(pComTaxonomyClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComInterfaceSetClass *pComInterfaceSetClass = new CComInterfaceSetClass;
    pComInterfaceSetClass->Init();
	if (pComInterfaceSetClass == NULL || CFlexArray::no_error != pResults->Add(pComInterfaceSetClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComDispatchElementClass *pComDispatchElementClass = new CComDispatchElementClass;
    pComDispatchElementClass->Init();
	if (pComDispatchElementClass == NULL || CFlexArray::no_error != pResults->Add(pComDispatchElementClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComDispatchInfoClass *pComDispatchInfoClass = new CComDispatchInfoClass;
    pComDispatchInfoClass->Init();
	if (pComDispatchInfoClass == NULL || CFlexArray::no_error != pResults->Add(pComDispatchInfoClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComBindingClass *pComBindingClass = new CComBindingClass;
    pComBindingClass->Init();
	if (pComBindingClass == NULL || CFlexArray::no_error != pResults->Add(pComBindingClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComInterfaceSetBindingClass *pComInterfaceSetBindingClass = new CComInterfaceSetBindingClass;
    pComInterfaceSetBindingClass->Init();
	if (pComInterfaceSetBindingClass == NULL || CFlexArray::no_error != pResults->Add(pComInterfaceSetBindingClass))
		return WBEM_E_OUT_OF_MEMORY;

    CComDispatchElementBindingClass *pComDispatchElementBindingClass = new CComDispatchElementBindingClass;
    pComDispatchElementBindingClass->Init();
	if (pComDispatchElementBindingClass == NULL || CFlexArray::no_error != pResults->Add(pComDispatchElementBindingClass))
		return WBEM_E_OUT_OF_MEMORY;
*/

    return 0;
}

HRESULT GetSystemSecurityObjects(CFlexArray * pResults)
{
	
	HRESULT hr = S_OK;
    CSubjectClass * pSubject = new CSubjectClass;
	if(pSubject)pSubject->Init();
	if(pSubject == NULL || CFlexArray::no_error != pResults->Add(pSubject))
		return WBEM_E_OUT_OF_MEMORY;

    CUserClass * pUser = new CUserClass;
	if(pUser)pUser->Init();
	if(pUser == NULL || CFlexArray::no_error != pResults->Add(pUser))
		return WBEM_E_OUT_OF_MEMORY;

    CNTLMUserClass * pNTLMUser = new CNTLMUserClass;
	if(pNTLMUser)pNTLMUser->Init();
	if(pNTLMUser == NULL || CFlexArray::no_error != pResults->Add(pNTLMUser))
		return WBEM_E_OUT_OF_MEMORY;

    CGroupClass * pGroup = new CGroupClass;
	if(pGroup)pGroup->Init();
	if(pGroup == NULL || CFlexArray::no_error != pResults->Add(pGroup))
		return WBEM_E_OUT_OF_MEMORY;

    CNtlmGroupClass * pNtlmGroup = new CNtlmGroupClass;
	if(pNtlmGroup)pNtlmGroup->Init();
	if(pNtlmGroup == NULL || CFlexArray::no_error != pResults->Add(pNtlmGroup))
		return WBEM_E_OUT_OF_MEMORY;
	return S_OK;
}

HRESULT GetStandardInstances(CFlexArray * pResults)
{
	HRESULT hr = S_OK;

    // Create the __systemsecurity=@ instance

    CSystemConfigClass  * pConfigClass = new CSystemConfigClass;
	if(pConfigClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<CSystemConfigClass> dm(pConfigClass);
	pConfigClass->Init();

    CSystemConfigInstance * pConfigInstance = new CSystemConfigInstance;
    if(pConfigInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pConfigInstance->Init(pConfigClass);
	if(CFlexArray::no_error != pResults->Add(pConfigInstance))
		return WBEM_E_OUT_OF_MEMORY;

    CThisNamespaceClass * pThisNamespaceClass = new CThisNamespaceClass;
    if(pThisNamespaceClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<CThisNamespaceClass> dm2(pThisNamespaceClass);
	pThisNamespaceClass->Init();

    CThisNamespaceInstance * pThisNamespaceInstance = new CThisNamespaceInstance;
    if(pThisNamespaceInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pThisNamespaceInstance->Init(pThisNamespaceClass);
	if(CFlexArray::no_error != pResults->Add(pThisNamespaceInstance))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}

HRESULT CreateCacheControl2(CFlexArray * pResults, LPCWSTR wszClassName, DWORD dwSeconds)
{
    CSpecificCacheControlClass * ControlClass = new CSpecificCacheControlClass;
    if(ControlClass)ControlClass->Init(wszClassName);
	if(ControlClass == NULL || CFlexArray::no_error != pResults->Add(ControlClass))
		return WBEM_E_OUT_OF_MEMORY;

    CCacheControlInstance * ControlInstance = new CCacheControlInstance;
    if(ControlInstance)ControlInstance->Init(ControlClass, dwSeconds);
	if(ControlInstance == NULL || CFlexArray::no_error != pResults->Add(ControlInstance))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}

HRESULT GetSystemRootObjects(CFlexArray * pResults)
{

    CCacheControlClass * pCacheControlCache = new CCacheControlClass;
    if(pCacheControlCache) pCacheControlCache->Init();
	if(pCacheControlCache == NULL || CFlexArray::no_error != pResults->Add(pCacheControlCache))
		return WBEM_E_OUT_OF_MEMORY;

	BOOL t_ShortTimeout = TRUE ;

	OSVERSIONINFOEX t_VersionInfo ;
	t_VersionInfo.dwOSVersionInfoSize = sizeof ( t_VersionInfo ) ;

	BOOL t_Status = GetVersionEx ( ( OSVERSIONINFO * ) & t_VersionInfo ) ;
	if ( t_Status )
	{
		if ( t_VersionInfo.wProductType != VER_NT_WORKSTATION )
		{
			t_ShortTimeout = FALSE ;
		}
	}

	HRESULT hr;
    hr = CreateCacheControl2(pResults, L"__ObjectProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__PropertyProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__EventProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__EventConsumerProviderCacheControl", t_ShortTimeout ? 30 : 300 );
	if(FAILED(hr))
		return hr;
    hr = CreateCacheControl2(pResults, L"__EventSinkCacheControl", t_ShortTimeout ? 15 : 150  );
	if(FAILED(hr))
		return hr;

	//Provider Host class
	CProviderHostQuotaConfiguration *pProviderHostQuotaConfigurationClass = new CProviderHostQuotaConfiguration;
	if (pProviderHostQuotaConfigurationClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pProviderHostQuotaConfigurationClass->Init();
	if (CFlexArray::no_error != pResults->Add(pProviderHostQuotaConfigurationClass))
		return WBEM_E_OUT_OF_MEMORY;

	//Provider Host  class
	CProviderHostQuotaConfigurationInstance *pProviderHostQuotaConfigurationInstance = new CProviderHostQuotaConfigurationInstance;
	if (pProviderHostQuotaConfigurationInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pProviderHostQuotaConfigurationInstance->Init(pProviderHostQuotaConfigurationClass);
	if (CFlexArray::no_error != pResults->Add(pProviderHostQuotaConfigurationInstance))
		return WBEM_E_OUT_OF_MEMORY;

    CActiveNamespacesClass * pActiveNSClass = new CActiveNamespacesClass;
    if(pActiveNSClass) pActiveNSClass->Init();
	if(pActiveNSClass == NULL || CFlexArray::no_error != pResults->Add(pActiveNSClass))
		return WBEM_E_OUT_OF_MEMORY;

	//Arbitrator class
	CArbitratorConfiguration *pArbClass = new CArbitratorConfiguration;
	if (pArbClass == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pArbClass->Init();
	if (CFlexArray::no_error != pResults->Add(pArbClass))
		return WBEM_E_OUT_OF_MEMORY;
	
	//Arbitrator instance
	CArbitratorConfigurationInstance *pArbInstance = new CArbitratorConfigurationInstance;
	if (pArbInstance == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	pArbInstance->Init(pArbClass);
	if (CFlexArray::no_error != pResults->Add(pArbInstance))
		return WBEM_E_OUT_OF_MEMORY;

    CCIMOMIdentificationClass * pIdentClass = new CCIMOMIdentificationClass;
    if(pIdentClass) pIdentClass->Init();
	if(pIdentClass == NULL || CFlexArray::no_error != pResults->Add(pIdentClass))
		return WBEM_E_OUT_OF_MEMORY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\svcq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SVCQ.H

Abstract:

	Declarations for asynchronous request queue classes.

	Classes defined:

	CAsyncReq and derivatives    Asynchrnous requests to WINMGMT.
	CAsyncServiceQueue           The queue of such requests.

History:

	a-raymcc        16-Jul-96       Created.
	a-levn          12-Sep-96       Implemented a few requests.
								  Added LoadProviders

--*/

#ifndef _ASYNC_Q_H_
#define _ASYNC_Q_H_

class CWbemNamespace;
class CBasicObjectSink;
class CStdSink;
class CWbemObject;

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq
//
//  Represents an asynchrnous request to WINMGMT, such as GetObjectAsync.
//  This class is derived from CExecRequest (execq.h), a generic request for
//  execution queues. For more information on queues and requests, see execq.h
//
//******************************************************************************
//
//  Contructor
//
//  Every asynchrnous request has an IWbemObjectSink pointer associated with it.
//  In addition, assigns a unique integer to this object which becomes its
//  request handle.
//
//  PARAMETERS:
//
//      IWbemObjectSink* pHandler    The handler associated with this request.
//                                  AddRefs and stores this pointer.
//
//******************************************************************************
//
//  Destructor
//
//  Releases the stored handler.
//
//******************************************************************************
//
//  GetRequestHandle
//
//  Returns the unique request handle assigned to this request in constructor.
//
//  RETURN VALUES:
//
//      long
//
//******************************************************************************

class CAsyncReq : public CWbemRequest
{
protected:
    CStdSink *m_pHandler;
    long m_lRequestHandle;

    void SetRequestHandle(long lHandle) {m_lRequestHandle = lHandle;}
    void SetNoAuthentication(IWbemObjectSink* pHandler);
public:
    CAsyncReq(IWbemObjectSink* pHandler, IWbemContext* pContext,
                bool bSeparatelyThreaded = false);
    virtual ~CAsyncReq();
    virtual HRESULT Execute() = 0;

    virtual CWbemQueue* GetQueue();
    virtual BOOL IsInternal() {return TRUE;}
    void TerminateRequest(HRESULT hRes);
	HRESULT SetTaskHandle(_IWmiCoreHandle *phTask);
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncServiceQueue
//
//  This class represents the queue of asynchrnous requests into WINMGMT (every
//  request into WINMGMT becomes asynchronous, since synchronous methods call
//  asynchrnous ones and wait). There is almost no additional functionality
//  here, see CExecQueue in execq.h for all details
//
//******************************************************************************
//
//  Constructor
//
//  In addition to normal CExecQueue construction, launches the processing
//  thread by calling Run.
//
//******************************************************************************

class CAsyncServiceQueue : public CWbemQueue
{
private:
    BOOL m_bInit;
public:
    CAsyncServiceQueue(_IWmiArbitrator * pArb);
    HRESULT InitializeThread();
    void UninitializeThread();
    void IncThreadLimit();
    void DecThreadLimit();
    BOOL IsInit(){ return m_bInit; };
};



//******************************************************************************
//******************************************************************************
//
//  class CNamespaceReq
//
//  Another abstract class, albeit derived from CAsyncReq. This one is for
//  asynchrnous requests to a particular namespace.
//
//******************************************************************************
//
//  Constructor.
//
//  In addition to the CAsyncReq's IWbemObjectSink*, takes the
//  namespace pointer against which the request is to be executed. Most of
//  the time, the execute function calls one of Exec_... members of
//  CWbemNamespace.
//
//******************************************************************************
class CNamespaceReq : public CAsyncReq
{
protected:
    CWbemNamespace* m_pNamespace;
public:
    CNamespaceReq(CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
                    IWbemContext* pContext, bool bSeparatelyThreaded = false);
    virtual ~CNamespaceReq();
    virtual HRESULT Execute() = 0;  
    static WCHAR s_DumpBuffer[128];    
};


//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DeleteClassAsync
//
//  Encapsulates a request to execute DeleteClassAsync against a particular
//  namespace. Does it by calling Exec_DeleteClass and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN LPWSTR wszClass              The class to delete.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_DeleteClassAsync : public CNamespaceReq
{
    WString m_wsClass;
    LONG m_lFlags;

public:
    CAsyncReq_DeleteClassAsync(
        ADDREF CWbemNamespace *pNamespace,
        READONLY LPWSTR wszClass,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsClass(wszClass), m_lFlags(lFlags)
    {}

    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsClass; };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DeleteInstanceAsync
//
//  Encapsulates a request to execute DeleteInstanceAsync against a particular
//  namespace. Does it by calling Exec_DeleteInstance and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN LPWSTR wszObjectPath         The path to the instance to delete.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_DeleteInstanceAsync : public CNamespaceReq
{
    WString m_wsPath;
    LONG m_lFlags;

public:
    CAsyncReq_DeleteInstanceAsync(
        ADDREF CWbemNamespace *pNamespace,
        READONLY LPWSTR wszPath,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext), m_wsPath(wszPath),
            m_lFlags(lFlags)
    {}

    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsPath; };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_PutClassAsync
//
//  Encapsulates a request to execute PutClassAsync against a particular
//  namespace. Does it by calling Exec_PutClass and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN IWbemClassObject* pClass      The class to put.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_PutClassAsync : public CNamespaceReq
{
    IWbemClassObject* m_pClass;
    LONG m_lFlags;

public:
    CAsyncReq_PutClassAsync(
        ADDREF CWbemNamespace *pNamespace,
        ADDREF IWbemClassObject* pClass,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext), m_pClass(pClass),
            m_lFlags(lFlags)
    {
        m_pClass->AddRef();
    }

    ~CAsyncReq_PutClassAsync()
    {
        m_pClass->Release();
    }
    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo()
    {
        _variant_t varClass;
        if (FAILED(m_pClass->Get(L"__CLASS",0,&varClass,0,0))) return L"";
        if (VT_BSTR == V_VT(&varClass)) 
        {
            StringCchCopyW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,V_BSTR(&varClass));
            return CNamespaceReq::s_DumpBuffer;
        }
    	else return L""; 
    };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_PutInstanceAsync
//
//  Encapsulates a request to execute PutInstanceAsync against a particular
//  namespace. Does it by calling Exec_PutInstance and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN IWbemClassObject* pInstance   The instance to put.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_PutInstanceAsync : public CNamespaceReq
{
    IWbemClassObject* m_pInstance;
    LONG m_lFlags;

public:
    CAsyncReq_PutInstanceAsync(
        ADDREF CWbemNamespace *pNamespace,
        ADDREF IWbemClassObject* pInstance,
        LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext),
            m_pInstance(pInstance), m_lFlags(lFlags)
    {
        m_pInstance->AddRef();
    }

    ~CAsyncReq_PutInstanceAsync()
    {
        m_pInstance->Release();
    }
    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo()
    {
        _variant_t varRelPath;
        if (FAILED(m_pInstance->Get(L"__RELPATH",0,&varRelPath,0,0))) return L"";
        if (VT_BSTR == V_VT(&varRelPath)) 
        {
            StringCchCopyW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,V_BSTR(&varRelPath));
            return CNamespaceReq::s_DumpBuffer;
        }
    	else return L""; 
    };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CreateClassEnumAsync
//
//  Encapsulates a request to execute CreateClassEnumAsync against a particular
//  namespace. Does it by calling Exec_CreateClassEnum and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR Parent                  The name of the parent class. If NULL,
//                                      start at the top level.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_CreateClassEnumAsync : public CNamespaceReq
{
    WString m_wsParent;
    LONG m_lFlags;

public:
    CAsyncReq_CreateClassEnumAsync(CWbemNamespace* pNamespace,
        BSTR Parent, LONG lFlags, ADDREF IWbemObjectSink* pHandler,
        ADDREF IWbemContext* pContext
        ) : CNamespaceReq(pNamespace, pHandler, pContext), m_wsParent(Parent),
            m_lFlags(lFlags)
    {}
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsParent; };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CreateInstanceEnumAsync
//
//  Encapsulates a request to execute CreateInstanceEnumAsync against a
//  particular
//  namespace. Does it by calling Exec_CreateInstanceEnum and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR Class                   The name of the class.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************

class CAsyncReq_CreateInstanceEnumAsync : public CNamespaceReq
{
    WString m_wsClass;
    LONG m_lFlags;
public:
    CAsyncReq_CreateInstanceEnumAsync(
        CWbemNamespace* pNamespace, BSTR Class, LONG lFlags,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext)
        : CNamespaceReq(pNamespace, pHandler, pContext), m_wsClass(Class),
            m_lFlags(lFlags)
    {}
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsClass; };    
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_GetObjectByPathAsync
//
//  Encapsulates a request to execute GetObjectAsync against a
//  particular
//  namespace. Does it by calling Exec_GetObjectByPath and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR ObjectPath              The path to the object to get.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_GetObjectAsync : public CNamespaceReq
{
    WString m_wsObjectPath;
    long m_lFlags;

public:
    CAsyncReq_GetObjectAsync(
        CWbemNamespace* pNamespace, BSTR ObjectPath,  long lFlags,
        ADDREF IWbemObjectSink *pHandler, ADDREF IWbemContext* pContext) :
            CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsObjectPath(ObjectPath), m_lFlags(lFlags)
    {}

    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsObjectPath; }; 
};


//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_ExecMethodAsync
//
//  Encapsulates a request to execute ExecMethodAsync against a
//  particular
//  namespace. Does it by calling Exec_ExecMethodAsync and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR ObjectPath              The path to the object to get.
//      IN BSTR MethodName              The name of the method
//      IN LONG lFlags                  Flags
//      IN IWbemClassObject* pInParams   The in-parameter of the method
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_ExecMethodAsync : public CNamespaceReq
{
    WString m_wsObjectPath;
    WString m_wsMethodName;
    IWbemClassObject* m_pInParams;
    long m_lFlags;

public:
    CAsyncReq_ExecMethodAsync(
        CWbemNamespace* pNamespace,
        BSTR ObjectPath,
        BSTR MethodName,
        long lFlags,
        IWbemClassObject* pInParams,
        ADDREF IWbemObjectSink *pHandler,
        ADDREF IWbemContext* pContext)
         : CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsObjectPath(ObjectPath), m_wsMethodName(MethodName),
            m_pInParams(pInParams), m_lFlags(lFlags)
    {
        if(m_pInParams)
            m_pInParams->AddRef();
    }

    ~CAsyncReq_ExecMethodAsync()
    {
        if(m_pInParams)
            m_pInParams->Release();
    }
    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsMethodName; }; 
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_ExecQueryAsync
//
//  Encapsulates a request to execute ExecQueryAsync against a
//  particular
//  namespace. Does it by calling CQueryEngine::ExecQuery and converting the
//  results to the asynchrnous format.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR QueryFormat             The query language
//      IN BSTR Query                   The query string.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_ExecQueryAsync : public CNamespaceReq
{
    WString m_wsQueryFormat;
    WString m_wsQuery;
    long m_lFlags;

public:
    CAsyncReq_ExecQueryAsync(CWbemNamespace* pNamespace,
        BSTR QueryFormat, BSTR Query, long lFlags,
        IWbemObjectSink *pHandler, IWbemContext* pContext) :
            CNamespaceReq(pNamespace, pHandler, pContext),
            m_wsQueryFormat(QueryFormat), m_wsQuery(Query), m_lFlags(lFlags)
    {}
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsQuery; };     
};


//******************************************************************************
//
//******************************************************************************
//
class CCallResult;
class CAsyncReq_OpenNamespace : public CAsyncReq
{
    CWbemNamespace* m_pParentNs;
    WString m_wsNamespace;
    long m_lSecurityFlags;
    DWORD m_dwPermission;
    CCallResult* m_pResult;
    bool m_bForClient;

public:
    CAsyncReq_OpenNamespace(CWbemNamespace* pParentNs, LPWSTR wszNamespace,
        long lSecurityFlags, DWORD dwPermission,
        IWbemContext* pContext, CCallResult* pResult, bool bForClient);
    ~CAsyncReq_OpenNamespace();
    HRESULT Execute();
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsNamespace; };     
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_ExecNotificationQueryAsync
//
//  Encapsulates a request to execute ExecNotificationQueryAsync against a
//  particular
//  namespace. Does it by calling ESS RegisterNotificationSink.
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//      IN CWbemNamespace* pNamespace    The namespace to execute against.
//      IN BSTR QueryFormat             The query language
//      IN BSTR Query                   The query string.
//      IN LONG lFlags                  Flags
//      IN IWbemObjectSink* pHandler     The handler to put results in.
//
//******************************************************************************
class CAsyncReq_ExecNotificationQueryAsync : public CNamespaceReq
{
    WString m_wsQueryFormat;
    WString m_wsQuery;
    long m_lFlags;
    HRESULT *m_phRes;
    IWbemEventSubsystem_m4* m_pEss;
    HANDLE m_hEssDoneEvent;

public:
    CAsyncReq_ExecNotificationQueryAsync(CWbemNamespace* pNamespace,
        IWbemEventSubsystem_m4* pEss,
        BSTR QueryFormat, BSTR Query, long lFlags,
        IWbemObjectSink *pHandler, IWbemContext* pContext, HRESULT* phRes,
        HANDLE hEssApprovalEvent
        );
    ~CAsyncReq_ExecNotificationQueryAsync();
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo(){ return (WCHAR *)m_wsQuery; };         
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CancelAsyncCall
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//******************************************************************************

class CAsyncReq_CancelAsyncCall : public CAsyncReq
{
protected:
    HRESULT* m_phres;
    IWbemObjectSink* m_pSink;

public:
    CAsyncReq_CancelAsyncCall(IWbemObjectSink* pSink, HRESULT* phres);
    ~CAsyncReq_CancelAsyncCall();
    HRESULT Execute();
    void DumpError(){    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CancelAsyncCall call failed\n"));};
    LPCWSTR GetReqInfo()
    { 
        StringCchPrintfW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,L"CancelAsyncCall for sink %p",m_pSink);
        return CNamespaceReq::s_DumpBuffer;    
    };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_CancelProvAsyncCall
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//******************************************************************************

class CAsyncReq_CancelProvAsyncCall : public CAsyncReq
{
protected:
	IWbemServices* m_pProv;
    IWbemObjectSink* m_pSink;
	IWbemObjectSink* m_pStatusSink;

public:
    CAsyncReq_CancelProvAsyncCall( IWbemServices* pProv, IWbemObjectSink* pSink,
									IWbemObjectSink* pStatusSink );
    ~CAsyncReq_CancelProvAsyncCall();
    HRESULT Execute();
    void DumpError(){    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CancelProvAsyncCall call failed\n"));};
    LPCWSTR GetReqInfo()
    { 
        StringCchPrintfW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,L"CancelProvAsyncCall for sink %p",m_pProv);
        return CNamespaceReq::s_DumpBuffer;    
    };
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DynAux_GetInstances
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//    READONLY CWbemObject *pClassDef,
//    long lFlags,
//    IWbemContext* pCtx,
//    CBasicObjectSink* pSink
//
//******************************************************************************

class CAsyncReq_DynAux_GetInstances : public CNamespaceReq
{
private:

	CWbemObject *m_pClassDef ;
	IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;

public:

    CAsyncReq_DynAux_GetInstances (
		CWbemNamespace *pNamespace ,
		CWbemObject *pClassDef ,
		long lFlags ,
		IWbemContext *pCtx ,
		CBasicObjectSink *pSink);

   ~CAsyncReq_DynAux_GetInstances();

    HRESULT Execute ();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo()
    { 
        _variant_t varClass;
        if (FAILED(m_pClassDef->Get(L"__CLASS",0,&varClass,0,0))) return L"";
        if (VT_BSTR == V_VT(&varClass))
        {
	        StringCchCopyW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,V_BSTR(&varClass));
    	    return CNamespaceReq::s_DumpBuffer;    
        }
        else return L"";
    };    
};

//******************************************************************************
//******************************************************************************
//
//  class CAsyncReq_DynAux_ExecQueryAsync
//
//
//******************************************************************************
//
//  Constructor.
//
//  PARAMETERS:
//
//
//		CWbemNamespace *pNamespace ,
//		CWbemObject *pClassDef ,
//		LPWSTR Query,
//		LPWSTR QueryFormat,
//		long lFlags ,
//		IWbemContext *pCtx ,
//		CBasicObjectSink *pSink
//
//******************************************************************************

class CAsyncReq_DynAux_ExecQueryAsync : public CNamespaceReq
{
private:
	CWbemObject *m_pClassDef ;
	LPWSTR m_Query ;
	LPWSTR m_QueryFormat ;
	IWbemContext *m_pCtx ;
	long m_lFlags ;
	CBasicObjectSink *m_pSink ;
	HRESULT m_Result ;
public:

    CAsyncReq_DynAux_ExecQueryAsync (CWbemNamespace *pNamespace ,
									CWbemObject *pClassDef ,
									LPWSTR Query,
									LPWSTR QueryFormat,
									long lFlags ,
									IWbemContext *pCtx ,
									CBasicObjectSink *pSink);
    
    ~CAsyncReq_DynAux_ExecQueryAsync();

	HRESULT Initialize () 
	{
		return m_Result ;
	}

    HRESULT Execute ();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo()
    { 
        return (WCHAR * )m_Query;
    };    
};

class CAsyncReq_RemoveNotifySink : public CAsyncReq
{
private:
    IWbemObjectSink * m_pSink;
	IWbemObjectSink* m_pStatusSink;
public:
    CAsyncReq_RemoveNotifySink(IWbemObjectSink* pSink, IWbemObjectSink* pStatusSink);
    ~CAsyncReq_RemoveNotifySink();
    HRESULT Execute();
    void DumpError(){};
    LPCWSTR GetReqInfo()
    { 
        StringCchPrintfW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,L"RemoveNotifySink for sink %p",m_pSink);
   	    return CNamespaceReq::s_DumpBuffer;    
    }; 

    void SetStatusSink(IWbemObjectSink * pStatusSink)
    {
        if (m_pStatusSink) m_pStatusSink->Release();
        m_pStatusSink = pStatusSink;
        if (m_pStatusSink) m_pStatusSink->AddRef();            
    }
    void SetSink(IWbemObjectSink * pSink)
    {
        if (m_pSink) m_pSink->Release();
        m_pSink = pSink;
        if (m_pSink) m_pSink->AddRef();            
    }    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\svcq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SVCQ.CPP

Abstract:

    Implemntation of asynchronous request queue classes.

    Classes implemented:

    CAsyncReq and derivatives    Asynchrnous requests to WINMGMT.
    CAsyncServiceQueue           The queue of such requests.

History:

    raymcc        16-Jul-96       Created.
    levn          12-Sep-96       Implemented a few requests.
                                  Added LoadProviders

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <svcq.h>
#include <oahelp.inl>

WCHAR CNamespaceReq::s_DumpBuffer[128];

CAsyncServiceQueue::CAsyncServiceQueue(_IWmiArbitrator * pArb)
: m_bInit( FALSE )
{
    m_lRef = 1;
    m_bInit = SetThreadLimits(50, 60, 0);
    CCoreQueue::SetArbitrator(pArb);
}

void CAsyncServiceQueue::IncThreadLimit()
{
    InterlockedIncrement(&m_lMaxThreads);
    InterlockedIncrement(&m_lHiPriMaxThreads);
}

void CAsyncServiceQueue::DecThreadLimit()
{
    InterlockedDecrement(&m_lMaxThreads);
    InterlockedDecrement(&m_lHiPriMaxThreads);
}


HRESULT CAsyncServiceQueue::InitializeThread()
{
    DEBUGTRACE((LOG_WBEMCORE, 
                           "STARTING a main queue thread %d for a total of %d\n", 
                           GetCurrentThreadId(), m_lNumThreads));
    return CWbemQueue::InitializeThread();
}

void CAsyncServiceQueue::UninitializeThread()
{
    DEBUGTRACE((LOG_WBEMCORE, 
                           "STOPPING a main queue thread %d for a total of %d\n", 
                           GetCurrentThreadId(), m_lNumThreads));
    CWbemQueue::UninitializeThread();
}


//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq::CAsyncReq(IWbemObjectSink* pHandler, IWbemContext* pContext,
                        bool bSeparatelyThreaded)
    : CWbemRequest(pContext, bSeparatelyThreaded)
{
    if(pHandler)
    {
        if(m_pContext == NULL)
        {
            // Oop!
            m_pHandler = NULL;
            m_fOk = false;
            return;
        }
        IWbemCausalityAccess* pCA = NULL;
        m_pContext->QueryInterface(IID_IWbemCausalityAccess, (void**)&pCA);  // SEC:REVIEWED 2002-03-22 : Needs check, but highly reliable
        REQUESTID id;
        pCA->GetRequestId(&id);
        pCA->Release();

        m_pHandler = new CStdSink(pHandler);
        if (m_pHandler)
        {
            m_pHandler->AddRef();
        }
        else
        {
            m_fOk = false;
        }

    }
    else
    {
        m_pHandler = NULL;
    }
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq::~CAsyncReq()
{
    if(m_pHandler)
        m_pHandler->Release();
}

void CAsyncReq::TerminateRequest(HRESULT hRes)
{
    if(m_pHandler)
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    return;
}


/*
    * =============================================================================
    |
    | HRESULT CAsyncReq::SetTaskHandle ( _IWmiCoreHandle *phTask )
    | ------------------------------------------------------------
    |
    | Sets the task handle for the request. This is overrides the virtual
    | SetTaskHandle declared in CCoreExecReq. We need additional functionality,
    | specifically the ability to set the request sink. In order to do so, we first
    | need a valid request sink which we have at this level.
    |
    |
    * =============================================================================
*/

HRESULT CAsyncReq::SetTaskHandle ( _IWmiCoreHandle *phTask )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    if (phTask)
    {
        phTask->AddRef();
        m_phTask = phTask;
    }
    
    if ( m_pHandler )
    {
        ((CWmiTask*)m_phTask)->SetRequestSink(m_pHandler) ;
    }
    return hRes ;
}


CWbemQueue* CAsyncReq::GetQueue()
{
    return ConfigMgr::GetAsyncSvcQueue();
}
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CNamespaceReq::CNamespaceReq(CWbemNamespace* pNamespace,
                             IWbemObjectSink* pHandler, IWbemContext* pContext,
                             bool bSeparatelyThreaded)
                    : CAsyncReq(pHandler, pContext, bSeparatelyThreaded)
{
    m_pNamespace = pNamespace;
    pNamespace->AddRef();
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CNamespaceReq::~CNamespaceReq()
{
    m_pNamespace->Release();
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq_OpenNamespace::CAsyncReq_OpenNamespace(CWbemNamespace* pParentNs,
                                                 LPWSTR wszNamespace,
                                                 long lSecurityFlags,
                                                 DWORD dwPermission,
                                                 IWbemContext* pContext,
                                                 CCallResult* pResult, bool bForClient)
              : CAsyncReq(NULL, pContext), m_wsNamespace(wszNamespace),
                m_lSecurityFlags(lSecurityFlags), m_dwPermission(dwPermission), m_pResult(pResult),
                m_pParentNs(pParentNs), m_bForClient(bForClient)
{
    m_pResult->AddRef();
    m_pParentNs->AddRef();
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
CAsyncReq_OpenNamespace::~CAsyncReq_OpenNamespace()
{
    m_pResult->Release();
    m_pParentNs->Release();
}

//***************************************************************************
//
//  See svcq.h for documentation.
//
//***************************************************************************
HRESULT CAsyncReq_OpenNamespace::Execute()
{
    SCODE hres;

    BOOL bRepositoryOnly = (m_lSecurityFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY);
    m_lSecurityFlags &= ~WBEM_FLAG_CONNECT_REPOSITORY_ONLY;

    CWbemNamespace* pNewNs = CWbemNamespace::CreateInstance();

    if (pNewNs == NULL)
    {
        m_pResult->SetStatus(WBEM_E_OUT_OF_MEMORY, NULL, NULL);
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = pNewNs->Initialize(m_wsNamespace,
                        m_pParentNs->GetUserName(),     // SEC:REVIEWED 2002-03-22 : OK
                        m_lSecurityFlags, m_dwPermission, m_bForClient, bRepositoryOnly,
                        m_pParentNs->GetClientMachine(), m_pParentNs->GetClientProcID(), FALSE, NULL);

    if (FAILED(hres))
    {
        m_pResult->SetStatus(hres, NULL, NULL);
        pNewNs->Release();
        return hres;
    }
    if (hres = pNewNs->GetStatus())
    {
        m_pResult->SetStatus(hres, NULL, NULL);
        pNewNs->Release();
        return hres;
    }

    // check for security if this isnt the local 9x case

    if((m_lSecurityFlags & SecFlagWin9XLocal) == 0)
    {
        DWORD dwAccess = pNewNs->GetUserAccess();
        if((dwAccess  & WBEM_ENABLE) == 0)
        {
            pNewNs->Release();
            m_pResult->SetStatus(WBEM_E_ACCESS_DENIED, NULL, NULL);
            return WBEM_E_ACCESS_DENIED;
        }
        pNewNs->SetPermissions(dwAccess);
    }

    pNewNs->SetLocale(m_pParentNs->GetLocale());
    m_pResult->SetResultServices(pNewNs);
    pNewNs->Release();

    m_pResult->SetStatus(WBEM_S_NO_ERROR, NULL, NULL);
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_DeleteClassAsync::Execute()
{
    HRESULT hRes;
    try
    {
        hRes = m_pNamespace->Exec_DeleteClass(m_wsClass, m_lFlags, m_pContext,
                                            m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_ExecQueryAsync::Execute()
{
    HRESULT hRes;
    //
    // the CQueryEngine::ExecQuery has a guard for calling SetStatus on the Sink
    //
    hRes = CQueryEngine::ExecQuery(m_pNamespace, m_wsQueryFormat, m_wsQuery,
                            m_lFlags, m_pContext, m_pHandler);
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_PutClassAsync::Execute()
{
    HRESULT hRes;
    try
    {
        hRes = m_pNamespace->Exec_PutClass(m_pClass, m_lFlags, m_pContext,m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_DeleteInstanceAsync::Execute()
{
    HRESULT hRes;
    try
    {
        hRes = m_pNamespace->Exec_DeleteInstance(m_wsPath, m_lFlags, m_pContext,m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_PutInstanceAsync::Execute()
{
    HRESULT hRes;


    try
    {
      hRes= m_pNamespace->Exec_PutInstance(m_pInstance, m_lFlags, m_pContext,m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CreateClassEnumAsync::Execute()
{
    HRESULT hRes;
    try
    {
        hRes = m_pNamespace->Exec_CreateClassEnum(m_wsParent, m_lFlags, m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CreateInstanceEnumAsync::Execute()
{
    HRESULT hRes;

    try
    {
        hRes = m_pNamespace->Exec_CreateInstanceEnum(m_wsClass, m_lFlags,m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_GetObjectAsync::Execute()
{
    HRESULT hRes;
    try
    {
        hRes = m_pNamespace->Exec_GetObject(m_wsObjectPath, m_lFlags,m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_ExecMethodAsync::Execute()
{
    HRESULT hRes;
    try
    {
        hRes = m_pNamespace->Exec_ExecMethod(m_wsObjectPath, m_wsMethodName,m_lFlags, m_pInParams, m_pContext, m_pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }
    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_ExecNotificationQueryAsync::CAsyncReq_ExecNotificationQueryAsync(
    CWbemNamespace* pNamespace,
    IWbemEventSubsystem_m4* pEss,
    BSTR QueryFormat, BSTR Query, long lFlags,
    IWbemObjectSink *pHandler, IWbemContext* pContext, HRESULT* phRes,
    HANDLE hEssDoneEvent
    ) :
        CNamespaceReq(pNamespace, pHandler, pContext, false),// no threadswitch!
        m_wsQueryFormat(QueryFormat), m_wsQuery(Query), m_lFlags(lFlags),
        m_phRes(phRes), m_pEss(pEss), m_hEssDoneEvent(hEssDoneEvent)
{
    if (m_pEss)
        m_pEss->AddRef();
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_ExecNotificationQueryAsync::~CAsyncReq_ExecNotificationQueryAsync()
{
    if (m_pEss)
        m_pEss->Release();
}


//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_ExecNotificationQueryAsync::Execute()
{
    _DBG_ASSERT(m_phTask);
    _DBG_ASSERT(m_hEssDoneEvent);

    HRESULT hRes;
    CAutoSignal SetMe(m_hEssDoneEvent);

    try
    {
        hRes = m_pEss->RegisterNotificationSink(m_pNamespace->GetNameFull(), m_wsQueryFormat, m_wsQuery, m_lFlags,
                    m_pContext, m_pHandler);

        *m_phRes = hRes;
    }
    catch(...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
        m_pHandler->SetStatus( 0, hRes, NULL, NULL);
    }

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelAsyncCall::CAsyncReq_CancelAsyncCall(
                            IWbemObjectSink* pSink, HRESULT* phres)
    : CAsyncReq(NULL, NULL), m_phres(phres), m_pSink(pSink)
{
    if (m_pSink)
        m_pSink->AddRef();
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelAsyncCall::~CAsyncReq_CancelAsyncCall()
{
    if(m_pSink)
        m_pSink->Release();
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CancelAsyncCall::Execute()
{
    HRESULT hres;
    try
    {
        hres = CWbemNamespace::Exec_CancelAsyncCall(m_pSink);
        if(m_phres)
            *m_phres = hres;
    }
    catch(...)
    {
        ExceptionCounter c;
        hres = WBEM_E_CRITICAL_ERROR;
    }
    return hres;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelProvAsyncCall::CAsyncReq_CancelProvAsyncCall(
                            IWbemServices* pProv, IWbemObjectSink* pSink,
                            IWbemObjectSink* pStatusSink )
    : CAsyncReq(NULL, NULL), m_pProv(pProv), m_pSink(pSink), m_pStatusSink( pStatusSink )
{
    if (m_pProv) m_pProv->AddRef();
    if (m_pSink) m_pSink->AddRef();
    if (m_pStatusSink) m_pStatusSink->AddRef();
    SetForceRun(1);
    SetPriority(PriorityFreeMemRequests);    
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_CancelProvAsyncCall::~CAsyncReq_CancelProvAsyncCall()
{
    if ( NULL != m_pProv )
        m_pProv->Release();

    if ( NULL != m_pSink )
        m_pSink->Release();

    if ( NULL != m_pStatusSink )
        m_pStatusSink->Release();
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_CancelProvAsyncCall::Execute()
{
    HRESULT hres = CWbemNamespace::Exec_CancelProvAsyncCall( m_pProv, m_pSink );

    if ( NULL != m_pStatusSink )
    {
        m_pStatusSink->SetStatus( 0L, hres, NULL, NULL );
    }

    return hres;
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_RemoveNotifySink::CAsyncReq_RemoveNotifySink(
                            IWbemObjectSink* pSink, IWbemObjectSink* pStatusSink)
    : CAsyncReq(NULL, NULL), m_pSink(pSink),m_pStatusSink( pStatusSink )
{
    if (m_pSink) m_pSink->AddRef();
    if (m_pStatusSink) m_pStatusSink->AddRef();
    SetForceRun(1);
    SetPriority(PriorityFreeMemRequests);    
}

//******************************************************************************
//
//******************************************************************************
//
CAsyncReq_RemoveNotifySink::~CAsyncReq_RemoveNotifySink()
{
    if(m_pSink) m_pSink->Release();
    if (m_pStatusSink) m_pStatusSink->Release();
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT CAsyncReq_RemoveNotifySink::Execute()
{
    HRESULT hRes = WBEM_E_FAILED;
    IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
    if (pEss)
    {
        if (m_pSink)
            hRes = pEss->RemoveNotificationSink(m_pSink);
        pEss->Release();
    }

    if (m_pStatusSink) m_pStatusSink->SetStatus( 0L, hRes, NULL, NULL );

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_OpenNamespace::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_OpenNamespace, Name= %S, in parent namespace %S\n", m_wsNamespace,
        m_pParentNs->GetName()));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_DeleteClassAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_DeleteClassAsync, class=%S in namespace %S using flags 0x%x\n", m_wsClass, m_pNamespace->GetName(), m_lFlags));
};

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_ExecQueryAsync::DumpError()
{
    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_ExecQueryAsync, Query= %S in namespace %S using flags 0x%x\n", m_wsQuery,
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_PutClassAsync::DumpError()
{
    CVar var;
    CWbemClass * pCls = (CWbemClass *)m_pClass;
    if(0 == pCls->GetProperty(L"__class", &var))
        DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_PutClassAsync, class=%S in namespace %S using flags 0x%x\n", var.GetLPWSTR(),
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_PutInstanceAsync::DumpError()
{
    BSTR mof = 0;
    if(0 == m_pInstance->GetObjectText(0, &mof))
    {
        DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_PutInstanceAsync instance= %S in namespace %S using flags 0x%x\n", mof, m_pNamespace->GetName(), m_lFlags));
        SysFreeString(mof);
    }
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_CreateClassEnumAsync::DumpError()
{
    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CreateClassEnumAsync, Parent= %S in namespace %S using flags 0x%x\n",
         m_wsParent, m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_CreateInstanceEnumAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_CreateInstanceEnumAsync, Class= %S in namespace %S using flags 0x%x\n",
            m_wsClass, m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_GetObjectAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_GetObjectAsync, Path= %S in namespace %S using flags 0x%x\n", m_wsObjectPath,
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_ExecMethodAsync::DumpError()
{
    BSTR bstrArgs = NULL;
    if(m_pInParams)
        m_pInParams->GetObjectText(0, &bstrArgs);

    DEBUGTRACE((LOG_WBEMCORE,
    "CAsyncReq_ExecMethodAsync, Path= %S, Method=%S, args=%S in namespace %S using flags 0x%x\n",
        m_wsObjectPath, m_wsMethodName, (bstrArgs) ? bstrArgs : L"<no args>",
        m_pNamespace->GetName(), m_lFlags));
    if(bstrArgs)
        SysFreeString(bstrArgs);
}

//******************************************************************************
//
//******************************************************************************

void CAsyncReq_ExecNotificationQueryAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_ExecNotificationQueryAsync, Query= %S in namespace %S using flags 0x%x\n", m_wsQuery,
        m_pNamespace->GetName(), m_lFlags));
}

//******************************************************************************
//
//******************************************************************************

void CAsyncReq_DeleteInstanceAsync::DumpError()
{    DEBUGTRACE((LOG_WBEMCORE,
        "CAsyncReq_DeleteInstanceAsync, path=%S in namespace %S using flags 0x%x\n", m_wsPath, m_pNamespace->GetName(), m_lFlags));
};

//******************************************************************************
//
//******************************************************************************
//


CAsyncReq_DynAux_GetInstances::CAsyncReq_DynAux_GetInstances(CWbemNamespace *pNamespace,
                                                                                                        CWbemObject *pClassDef,
                                                                                                        long lFlags,
                                                                                                        IWbemContext *pCtx,
                                                                                                        CBasicObjectSink *pSink):    
    CNamespaceReq (pNamespace,pSink,pCtx,true),
    m_pClassDef(pClassDef), 
    m_pCtx(pCtx), 
    m_pSink(pSink),
    m_lFlags(lFlags)
{
        if (m_pClassDef) m_pClassDef->AddRef();
        if (m_pCtx)  m_pCtx->AddRef();
        if (m_pSink) m_pSink->AddRef();
}

CAsyncReq_DynAux_GetInstances::~CAsyncReq_DynAux_GetInstances()
    {
        if (m_pClassDef) m_pClassDef->Release();
        if (m_pCtx) m_pCtx->Release();
        if (m_pSink) m_pSink->Release();
    }


//******************************************************************************
//
//******************************************************************************
//

HRESULT CAsyncReq_DynAux_GetInstances :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_GetInstances (

        m_pClassDef ,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_DynAux_GetInstances ::DumpError()
{
    // none
}

//******************************************************************************
//
//******************************************************************************
//

CAsyncReq_DynAux_ExecQueryAsync::CAsyncReq_DynAux_ExecQueryAsync(CWbemNamespace *pNamespace ,
                                                                                                                    CWbemObject *pClassDef ,
                                                                                                                    LPWSTR Query,
                                                                                                                    LPWSTR QueryFormat,
                                                                                                                    long lFlags ,
                                                                                                                    IWbemContext *pCtx ,
                                                                                                                    CBasicObjectSink *pSink):
    CNamespaceReq(pNamespace,pSink, pCtx, true),
        m_pClassDef(pClassDef), 
        m_pCtx(pCtx), 
        m_pSink(pSink),
        m_lFlags(lFlags),
        m_Query(NULL),
        m_QueryFormat(NULL),
        m_Result (S_OK)
{
    if (m_pClassDef) m_pClassDef->AddRef () ;
    if (m_pCtx) m_pCtx->AddRef () ;
    if (m_pSink)  m_pSink->AddRef () ;


    if (Query)
    {
        m_Query = SysAllocString ( Query ) ;
        if ( m_Query == NULL )
        {
            m_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }

    if (QueryFormat)
    {
        m_QueryFormat = SysAllocString ( QueryFormat ) ;
        if ( m_QueryFormat == NULL )
        {
            m_Result = WBEM_E_OUT_OF_MEMORY ;
        }
    }
}

CAsyncReq_DynAux_ExecQueryAsync :: ~CAsyncReq_DynAux_ExecQueryAsync ()
{
    if (m_pClassDef) m_pClassDef->Release();
    if (m_pCtx) m_pCtx->Release();
    if (m_pSink) m_pSink->Release();

    SysFreeString(m_Query);
    SysFreeString(m_QueryFormat);
}


HRESULT CAsyncReq_DynAux_ExecQueryAsync :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_ExecQueryAsync (

        m_pClassDef ,
        m_Query,
        m_QueryFormat,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

//******************************************************************************
//
//******************************************************************************
//
void CAsyncReq_DynAux_ExecQueryAsync ::DumpError()
{
    // none
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\sysclass.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SYSCLASS.H

Abstract:

    System class generation function.


History:

--*/

#ifndef __SYSCLASS__H_
#define __SYSCLASS__H_

HRESULT GetSystemStdObjects(CFlexArray * Results);
HRESULT GetSystemSecurityObjects(CFlexArray * Results);
HRESULT GetSystemRootObjects(CFlexArray * Results);
HRESULT GetStandardInstances(CFlexArray * Results);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wbemcore.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMCORE.H

Abstract:

	Master include files. Include everything WinMgmt includes..

History:

	23-Jul-96   raymcc    Created.
	3/10/97     a-levn    Fully documented

--*/

#ifndef _WBEMIMPL_H_
#define _WBEMIMPL_H_

#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <io.h>

#include <wbemidl.h>
#include <wbemint.h>
#include "CliCnt.h"
#include <reposit.h>

// This keeps track of when the core can be unloaded

extern CClientCnt gClientCounter;

// Parameter flow indicators.
// ==========================

#define READONLY
    // The value should be treated as read-only

#define ACQUIRED
    // Ownership of the object/pointer is acquired.

#define COPIED
    // The function makes a copy of the object/pointer.

#define PREALLOCATED
    // The out-param uses caller's memory.

#define NEWOBJECT
    // The return value or out parameter is a new
    // allocation which must be deallocated by
    // the caller if the call succeeds.

#define READWRITE
    // The in-param is will be treated as read-write,
    // but will not be deallocated.

#define INTERNAL
    // Returns a pointer to internal memory object
    // which should not be deleted.

#define ADDREF
    // On a parameter, indicates that the called
    // function will do an AddRef() on the interface
    // and retain it after the call completes.

#define TYPEQUAL L"CIMTYPE"
#define ADMINISTRATIVE_USER L".\\SYSTEM"

#define ReleaseIfNotNULL(p) if(p) p->Release(); p=NULL;
#define DeleteAndNull(p) delete p; p=NULL;

#include <WinMgmtR.h>
#include <cominit.h>
#include <unk.h>
#include <str_res.h>
#include <wbemutil.h>
#include <fastall.h>
#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <objpath.h>
#include <arena.h>
#include <reg.h>
#include <wstring.h>
#include <flexarry.h>
#include <flexq.h>
#include <arrtempl.h>

#include <winntsec.h>
#include <callsec.h>
#include <coreq.h>
#include <wbemq.h>
#include <safearry.h>
#include <var.h>
#include <strm.h>
#include <dynasty.h>
#include <stdclass.h>
#include <svcq.h>
#include <cwbemtime.h>
#include <evtlog.h>
#include <decor.h>
#include <crep.h>
#include <wmitask.h>
#include <cfgmgr.h>
#include "wqlnode.h"
#include "wqlscan.h"
#include <protoq.h>
#include <assocqp.h>
#include <assocqe.h>
#include <sinks.h>
#include <qengine.h>
#include <callres.h>
#include <wbemname.h>
#include <login.h>
#include "secure.h"
#include "coresvc.h"
#include "sysclass.h"

// Autosignal event
class CAutoSignal
{
private:
    HANDLE m_hEvent;
    
public:
    CAutoSignal (HANDLE hEvent) : m_hEvent(hEvent) { ; }
    ~CAutoSignal() { if ( m_hEvent ) SetEvent(m_hEvent); }
    HANDLE dismiss(){ HANDLE hTmp = m_hEvent; m_hEvent = NULL; return hTmp; }
};

class NullPointer
{
private:
     PVOID * ToBeNulled_;
public:    
	NullPointer(PVOID * ToBeNulled):ToBeNulled_(ToBeNulled){};
	~NullPointer(){ *ToBeNulled_ = NULL; };
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wbemname.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNAME.H

Abstract:

    Implements the COM layer of WINMGMT --- the class representing a namespace.
    It is defined in wbemname.h

History:

    23-Jul-96   raymcc    Created.
    3/10/97     levn      Fully documented (ha ha)
    22-Feb-00   raymcc    Whistler revisions/extensions

--*/

#ifndef _WBEM_NAME_H_
#define _WBEM_NAME_H_

#include <winntsec.h>
#include <statsync.h>
#include <sinks.h>

extern DWORD g_IdentifierLimit;
extern DWORD g_QueryLimit;
extern DWORD g_PathLimit;


#define WBEM_FLAG_NO_STATIC 0x80000000
#define WBEM_FLAG_ONLY_STATIC 0x40000000

#ifdef DBG
class OperationStat
{
	
	enum { HistoryLength = 122 };
	DWORD signature;
	DWORD historycData_[HistoryLength];
	DWORD historyIndex_;
	DWORD opCount_;
	DWORD avgTime_;
	DWORD maxTime_;
	LONG zeroTime_;

	
public:
	static CStaticCritSec lock_;
	OperationStat() :
	historyIndex_(0), opCount_(0), avgTime_(0), maxTime_(0),signature((DWORD)'nCpO')
	{
		memset(historycData_, 0, sizeof(historycData_));  // SEC:REVIEWED 2002-03-22 : OK, debug code only
	};
	void addTime(DWORD duration)
	{
		
 		if (duration==0)
		{
			InterlockedIncrement(&zeroTime_);
 			return;
		}
		if (CStaticCritSec::anyFailure()) return ;
		
		lock_.Enter();
		
		historycData_[historyIndex_++]=duration;
		historyIndex_%=HistoryLength;

		if (++opCount_ == 0) ++opCount_;
			
		double avg = (double)avgTime_ + ((double)duration-avgTime_)/opCount_;
		avgTime_ = (DWORD)avg;
		if (duration > maxTime_)
		{
			maxTime_ = duration;
		};
		
		lock_.Leave();
	};
};

class TimeTraces
{
public:
	typedef enum{ GetObject=0, GetObjectByPath, ExecQuery, ExecMethod, DeleteInstance, DeleteClass, CreateInstanceEnum, CreateClassEnum, PutClass, PutInstance, Invalid } tracedOp;
	TimeTraces() :zeroTime_(0) {};
 	void addTime(tracedOp operation, DWORD duration)
 		{
 		if (duration==0) InterlockedIncrement(&zeroTime_);
		_DBG_ASSERT(operation >= GetObject);
		_DBG_ASSERT(operation < Invalid);
		allCounters[operation].addTime(duration);
 		}
private:
	OperationStat allCounters[Invalid];
	LONG zeroTime_;
};
extern TimeTraces gTimeTraceHistory;


class TimeTrace
{
	TimeTraces::tracedOp operation_;
	DWORD start_;
public:
	TimeTrace(TimeTraces::tracedOp operation ):
		operation_(operation), start_(GetTickCount())
		{ 	}
	~TimeTrace()
		{
		gTimeTraceHistory.addTime(operation_, GetTickCount()-start_);
		}
	
};

	#define TIMETRACE(x) TimeTrace timeTrace(x);
#else
	#define TIMETRACE(x)
#endif

class CFlexAceArray;
class CBasicObjectSink;
class CComplexProjectionSink;
class CDynasty;
class CAsyncReq;
class CWmiMerger;

struct SAssocTriad
{
    IWbemClassObject *m_pEp1;
    IWbemClassObject *m_pEp2;
    IWbemClassObject *m_pAssoc;

    SAssocTriad() { m_pEp1 = 0; m_pEp2 = 0; m_pAssoc = 0; }
   ~SAssocTriad() {  ReleaseIfNotNULL(m_pEp1); ReleaseIfNotNULL(m_pEp2); ReleaseIfNotNULL(m_pAssoc); }

    static void ArrayCleanup(CFlexArray &Array)
    {
        for (int i = 0; i < Array.Size(); i++)
            delete (SAssocTriad *) Array[i];
        Array.Empty();
    }
};

//******************************************************************************
//******************************************************************************
//
//  class CWbemNamespace
//
//  This class represents the COM layer of WINMGMT --- what the client sees. An
//  instance of this class is created whenever a namespace is opened by a client
//  (at the moment, we don't cache namespace pointers, so if a client opens the
//  same namespace twice, we will create to of these).
//
//******************************************************************************
//
//  Constructor
//
//  Enumerates all the class providers in this namespace (instances of
//  __Win32Provider with the method mask indicating a class provider), loads
//  them all and initializes them by calling ConnectServer.
//
//******************************************************************************
//*************************** interface IWbemServices **************************
//
//  See help for documentation of the IWbemServices interface.
//
//******************************************************************************
//************************** helper functions **********************************
//
//  Are documented in the wbemname.cpp file.
//
//******************************************************************************

typedef void * IWbemServicesEx;
typedef void * IWbemCallResultEx;

class CWbemNamespace :
    public IWbemServices,
    public IWbemInternalServices
{
public:
	
protected:
    friend class CQueryEngine;

    ULONG m_uSecondaryRefCount;
    BOOL m_bShutDown;

    //
    DWORD Status;


    IWmiDbSession *m_pSession;
    IWmiDbController *m_pDriver;
    IWmiDbHandle *m_pNsHandle;
    IWmiDbHandle *m_pScopeHandle;
    _IWmiArbitrator *m_pArb;
    BOOL          m_bSubscope;

    LPWSTR m_pThisNamespaceFull;
    LPWSTR m_pThisNamespace;

    DWORD m_dwPermission;
    DWORD m_dwSecurityFlags;
    LPWSTR m_wszUserName;

    BOOL m_bProvider;
    BOOL m_bESS;
    BOOL m_bForClient;
    CCritSec m_cs;
    WString m_wsLocale;
    CNtSecurityDescriptor m_sd;
    CNtSecurityDescriptor m_sdCheckAdmin;
    BOOL m_bSecurityInitialized;


    _IWmiProviderFactory    *m_pProvFact;
    _IWmiCoreServices       *m_pCoreSvc;

    BOOL                     m_bRepositOnly;
    IUnknown                *m_pRefreshingSvc;
    LPWSTR                   m_pszClientMachineName;
    DWORD                    m_dwClientProcessID;
    LIST_ENTRY m_Entry; // for the Global Counter
public:
    LIST_ENTRY m_EntryArb; // for the arbitrator
protected:

    // No access
    CWbemNamespace();
   ~CWbemNamespace();


    // Async impl entry points

        virtual HRESULT STDMETHODCALLTYPE _GetObjectAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler
            );

        virtual HRESULT STDMETHODCALLTYPE _PutClassAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _DeleteClassAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strClass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _CreateClassEnumAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strSuperclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _PutInstanceAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _DeleteInstanceAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _CreateInstanceEnumAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strFilter,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _ExecQueryAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _ExecNotificationQueryAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE _ExecMethodAsync(
            IN ULONG uInternalFlags,
            IN _IWmiFinalizer *p,
            IN _IWmiCoreHandle *phTask,
            IN const BSTR strObjectPath,
            IN const BSTR strMethodName,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemClassObject __RPC_FAR *pInParams,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

    HRESULT CreateNamespace(CWbemInstance *pNewInst);

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // Real entry points


    // IWbemServices

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace(
            IN const BSTR strNamespace,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);

        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            IN IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink(
            IN long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE GetObject(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE PutClass(
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutClassAsync(
            IN IWbemClassObject __RPC_FAR *pObject,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteClass(
            IN const BSTR strClass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            IN const BSTR strClass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum(
            IN const BSTR strSuperclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            IN const BSTR strSuperclass,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE PutInstance(
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            IN IWbemClassObject __RPC_FAR *pInst,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE DeleteInstance(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            IN const BSTR strFilter,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            IN const BSTR strFilter,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecQuery(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            IN const BSTR strQueryLanguage,
            IN const BSTR strQuery,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE ExecMethod(
            IN const BSTR strObjectPath,
            IN const BSTR strMethodName,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);

        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync(
            IN const BSTR strObjectPath,
            IN const BSTR strMethodName,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            IN IWbemClassObject __RPC_FAR *pInParams,
            IN IWbemObjectSink __RPC_FAR *pResponseHandler);




    // IWbemInternalServices

    STDMETHOD(FindKeyRoot)(LPCWSTR wszClassName,
                                IWbemClassObject** ppKeyRootClass);
    STDMETHOD(InternalGetClass)(
             LPCWSTR wszClassName,
             IWbemClassObject** ppClass);

    STDMETHOD(InternalGetInstance)(
             LPCWSTR wszPath,
             IWbemClassObject** ppInstance);

    STDMETHOD(InternalExecQuery)(
             LPCWSTR wszQueryLanguage,
             LPCWSTR wszQuery,
             long lFlags,
             IWbemObjectSink* pSink);

    STDMETHOD(InternalCreateInstanceEnum)(
             LPCWSTR wszClassName,
             long lFlags,
             IWbemObjectSink* pSink);

    STDMETHOD(GetDbInstance)(
             LPCWSTR wszDbKey,
             IWbemClassObject** ppInstance);

    STDMETHOD(GetDbReferences)(
             IWbemClassObject* pEndpoint,
             IWbemObjectSink* pSink);

    STDMETHOD(InternalPutInstance)(
             IWbemClassObject* pInst);


    // Other

    STDMETHOD(GetNormalizedPath)( BSTR pstrPath, BSTR* pstrStandardPath );


    static CWbemNamespace* CreateInstance();

    HRESULT Initialize(
        LPWSTR pName,
        LPWSTR wszUserName,
        DWORD dwSecFlags,
        DWORD dwPermission,
        BOOL  bForClient,
        BOOL  bRepositOnly,
        LPCWSTR pszClientMachineName,
        DWORD dwClientProcessID,
        BOOL  bSkipSDInitialize,
        IWmiDbSession *pParentSession
        );

public:

    IWmiDbHandle  *GetNsHandle() { return m_pNsHandle; }
    IWmiDbSession *GetNsSession() { return m_pSession; }
    IWmiDbHandle  *GetScope() { return m_pScopeHandle; }
    BOOL IsSubscope() { return m_bSubscope; }

    INTERNAL LPWSTR GetName() {return m_pThisNamespace;}
    INTERNAL LPWSTR GetNameFull() {return m_pThisNamespaceFull;}    

    DWORD& GetStatus() {return Status;}
    INTERNAL LPWSTR GetUserName() {return m_wszUserName;}  // SEC:REVIEWED 2002-03-22 : OK
    //INTERNAL void SetUserName(LPWSTR wName);
    DWORD GetSecurityFlags() {return m_dwSecurityFlags;}
    bool Allowed(DWORD dwRequired);

    void SetIsProvider(BOOL bProvider)
        {m_bProvider = bProvider;}

    void SetIsESS ( BOOL bESS )
        { m_bESS = bESS; }

    BOOL GetIsESS ( ) { return m_bESS; }
	BOOL GetIsProvider ( ) { return m_bProvider ; }

    void SetLocale(LPCWSTR wszLocale) {m_wsLocale = wszLocale;}
    LPCWSTR GetLocale() {return m_wsLocale;}
    LPWSTR GetClientMachine(){return m_pszClientMachineName;};
    DWORD GetClientProcID(){return m_dwClientProcessID;};

    HRESULT AdjustPutContext(IWbemContext *pCtx);
    HRESULT MergeGetKeysCtx(IN IWbemContext *pCtx);


    HRESULT SplitLocalized (CWbemObject *pOriginal, CWbemObject *pStoredObj = NULL);
    HRESULT FixAmendedQualifiers(IWbemQualifierSet *pOriginal, IWbemQualifierSet *pNew);

    // Worker functions for sync/async
    // ===============================

    HRESULT Exec_DeleteClass(LPWSTR wszClass, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_GetObjectByPath(READONLY LPWSTR wszObjectPath, long lFlags,
        IWbemContext* pContext, IWbemClassObject** ppObj,
        IWbemClassObject** ppErrorObj);
    HRESULT Exec_GetObject(READONLY LPWSTR wszObjectPath, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_DeleteInstance(LPWSTR wszObjectPath, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_PutClass(IWbemClassObject* pClass, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink, BOOL fIsInternal = FALSE);
    HRESULT Exec_PutInstance(IWbemClassObject* pInstance, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_CreateClassEnum(LPWSTR wszParent, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_CreateInstanceEnum(LPWSTR wszClass, long lFlags,
        IWbemContext* pContext, CBasicObjectSink* pSink);
    HRESULT Exec_ExecMethod(LPWSTR wszObjectPath, LPWSTR wszMethodName,
        long lFlags, IWbemClassObject *pInParams, IWbemContext *pCtx,
        CBasicObjectSink* pSink);
    static HRESULT Exec_CancelAsyncCall(IWbemObjectSink* pSink);
    static HRESULT Exec_CancelProvAsyncCall( IWbemServices* pProv, IWbemObjectSink* pSink );
    HRESULT GetImplementationClass(IWbemClassObject *pTestObj,
                                    LPWSTR wszMethodName, IWbemContext* pCtx,
                                    IWbemClassObject **pClassObj);
    HRESULT Exec_GetInstance(LPCWSTR wszObjectPath,
        IWbemPath* pParsedPath, long lFlags, IWbemContext* Context,
        CBasicObjectSink* pSink);

    HRESULT Exec_GetClass(LPCWSTR wszClassName,
        long lFlags, IWbemContext* Context, CBasicObjectSink* pSink);

   // HRESULT SetErrorObj(IWbemClassObject* pErrorObj);
    HRESULT RecursivePutInstance(CWbemInstance* pInst,
            CWbemClass* pClassDef, long lFlags, IWbemContext* pContext,
            CBasicObjectSink* pSink, BOOL bLast);

    HRESULT DeleteSingleInstance(
        READONLY LPWSTR wszObjectPath, long lFlags, IWbemContext* pContext,
        CBasicObjectSink* pSink);

    HRESULT InternalPutStaticClass( IWbemClassObject* pClass );

    HRESULT DeleteObject(const BSTR strObjectPath,
    	               long lFlags,
    	               IWbemContext *pCtx,IWbemCallResult **ppCallResult);



    // Assoc-by-rule helpers
    // =====================

    HRESULT ManufactureAssocs(
        IN  IWbemClassObject *pAssocClass,
        IN  IWbemClassObject *pEp,          // Optional
        IN  IWbemContext *pCtx,
        IN  LPWSTR pszJoinQuery,
        OUT CFlexArray &aTriads
        );

    HRESULT BuildAssocTriads(
        IN  IWbemClassObject *pAssocClass,
        IN  IWbemClassObject *pClsDef1,
        IN  IWbemClassObject *pClsDef2,
        IN  LPWSTR pszJoinProp1,
        IN  LPWSTR pszJoinProp2,
        IN  LPWSTR pszAssocRef1,                        // Prop which points to EP1
        IN  LPWSTR pszAssocRef2,                        // Prop which points to EP2
        IN  CFlexArray &aEp1,
        IN  CFlexArray &aEp2,
        IN OUT CFlexArray &aTriads
        );

    HRESULT BuildRuleBasedPathToInst(
        IN IWbemClassObject *pEp,
        IN LPWSTR pszJoinProp1,
        IN IWbemClassObject *pEp2,
        IN LPWSTR pszJoinProp2,
        OUT WString &wsNewPath);

    HRESULT ExtractEpInfoFromQuery(
        IWbemQuery *pQuery,
        wmilib::auto_buffer<WCHAR> & pszClass1,
        wmilib::auto_buffer<WCHAR> & pszProp1,
        wmilib::auto_buffer<WCHAR> & pClass2,
        wmilib::auto_buffer<WCHAR> & pszProp2);

    HRESULT MapAssocRefsToClasses(
        IN  IWbemClassObject *pAssocClass,
        IN  IWbemClassObject *pClsDef1,
        IN  IWbemClassObject *pClsDef2,
        wmilib::auto_buffer<WCHAR> & pszAssocRef1,
        wmilib::auto_buffer<WCHAR> & pszAssocRef2);


    // Property provider access.
    // =========================

    typedef enum {GET, PUT} Operation;

    HRESULT GetOrPutDynProps (

        IWbemClassObject *pObj,
        Operation op,
        BOOL bIsDynamic = false
    );

    HRESULT Exec_DynAux_GetInstances (

        READONLY CWbemObject *pClassDef,
        long lFlags,
        IWbemContext* pCtx,
        CBasicObjectSink* pSink
    ) ;

    HRESULT DynAux_GetInstances (

        CWbemObject *pClassDef,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink,
        BOOL bComplexQuery
    ) ;

    HRESULT DynAux_GetInstance (

        LPWSTR pObjPath,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
    );

    HRESULT DynAux_AskRecursively (

        CDynasty* pDynasty,
        long lFlags,
        LPWSTR wszObjectPath,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
    );

    HRESULT DynAux_GetSingleInstance (

        CWbemClass* pClassDef,
        long lFlags,
        LPWSTR wszObjectPath,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
    );

    HRESULT Exec_DynAux_ExecQueryAsync (

        CWbemObject* pClassDef,
        LPWSTR Query,
        LPWSTR QueryFormat,
        long lFlags,
        IWbemContext* pCtx,
        CBasicObjectSink* pSink
    ) ;

    HRESULT DynAux_ExecQueryAsync (

        CWbemObject* pClassDef,
        LPWSTR Query,
        LPWSTR QueryFormat,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink,
        BOOL bComplexQuery
    );

    HRESULT DynAux_ExecQueryExtendedAsync(

        LPWSTR wsProvider,
        LPWSTR Query,
        LPWSTR QueryFormat,
        long lFlags,
        IWbemContext* pCtx,
        CComplexProjectionSink* pSink
    ) ;

    HRESULT GetObjectByFullPath(
        READONLY LPWSTR wszObjectPath,
        IWbemPath * pOutput,
        long lFlags,
        IWbemContext* pContext,
        CBasicObjectSink* pSink
        );

    HRESULT DynAux_BuildClassHierarchy(IN LPWSTR wszClassName,
                                       IN LONG lFlags,
                                       IN IWbemContext* pContext,
                                       OUT wmilib::auto_ptr<CDynasty> & pDynasty,
                                       OUT IWbemClassObject** ppErrorObj);
    HRESULT DynAux_BuildChainUp(IN IWbemContext* pContext,
                                                   OUT wmilib::auto_ptr<CDynasty> & ppTop,
                                                   OUT IWbemClassObject** ppErrorObj);

    HRESULT DecorateObject(IWbemClassObject* pObject);


    static HRESULT IsPutRequiredForClass(CWbemClass* pClass,
                            CWbemInstance* pInst, IWbemContext* pContext,
                            BOOL bParentTakenCareOf);

    static HRESULT DoesNeedToBePut(LPCWSTR wszName, CWbemInstance* pInst,
            BOOL bRestrictedPut, BOOL bStrictNulls, BOOL bPropertyList,
            CWStringArray& awsProperties);

    static HRESULT GetContextPutExtensions(IWbemContext* pContext,
            BOOL& bRestrictedPut, BOOL& bStrictNulls, BOOL& bPropertyList,
            CWStringArray& awsProperties);

    static HRESULT GetContextBoolean(IWbemContext* pContext,
                LPCWSTR wszName, BOOL* pbValue);

    HRESULT GetAceList(CFlexAceArray **);
    HRESULT PutAceList(CFlexAceArray *);
    HRESULT InitializeSD(IWmiDbSession *pSession);
    CNtSecurityDescriptor & GetSDRef(){return m_sd;};
    DWORD GetUserAccess();
    DWORD GetNTUserAccess();
    HRESULT EnsureSecurity();
    void SetPermissions(DWORD dwPerm){m_dwPermission = dwPerm;};
    HRESULT InitializeUserLists(CFlexAceArray & AllowList,CFlexAceArray & DenyList);
    HRESULT SecurityMethod(LPWSTR wszMethodName, long lFlags,
        IWbemClassObject *pInParams, IWbemContext *pCtx, IWbemObjectSink* pSink);
    HRESULT GetSDMethod(IWbemClassObject* pOutParams);

    HRESULT RecursiveSDMerge();
    BOOL IsNamespaceSDProtected();
    HRESULT GetParentsInheritableAces(CNtSecurityDescriptor &sd);

    HRESULT SetSDMethod(IWbemClassObject* pInParams);

    HRESULT GetCallerAccessRightsMethod(IWbemClassObject* pOutParams);

    BOOL IsForClient(){return m_bForClient;};
    HRESULT EnumerateSecurityClassInstances(LPWSTR wszClassName,
                    IWbemObjectSink* pOwnSink, IWbemContext* pContext, long lFlags);
    HRESULT PutSecurityClassInstances(LPWSTR wszClassName,  IWbemClassObject * pClass,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags);
    HRESULT DeleteSecurityClassInstances(ParsedObjectPath* pParsedPath,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags);
    HRESULT GetSecurityClassInstances(ParsedObjectPath* pParsedPath, CBasicObjectSink* pSink,
                    IWbemContext* pContext,long lFlags);


    HRESULT CheckNs();


    HRESULT InitNewTask(
        IN CAsyncReq *pReq,
        IN _IWmiFinalizer *pFnz,
        IN ULONG uTaskType,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pAsyncClientSink
        );

    HRESULT CreateAsyncFinalizer(
        IN  IWbemContext *pContext,
        IN  IWbemObjectSink *pStartingSink,
        IN _IWmiFinalizer **pFnz,
        OUT IWbemObjectSink **pResultSinkEx
        );

    HRESULT CreateSyncFinalizer(
        IN  IWbemContext *pContext,
        IN _IWmiFinalizer **pFnz
        );

    HRESULT ExecSyncQuery(
        IN  LPWSTR pszQuery,
        IN  IWbemContext *pCtx,
        IN  LONG lFlags,
        OUT CFlexArray &aDest
        );
	
	// Helper function to shell db queries out to different threads as appropriate
	HRESULT Static_QueryRepository(
		READONLY CWbemObject *pClassDef,
		long lFlags,
		IWbemContext* pCtx,
		CBasicObjectSink* pSink ,
		QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery,
		LPCWSTR pwszClassName,
		CWmiMerger* pWmiMerger
		);

    // Two primary connect functions.
    // ==============================

    static HRESULT UniversalConnect(
        IN CWbemNamespace  *pParent,
        IN IWbemContext    *pCtx,
        IN LPCWSTR pszNewScope,
        IN LPCWSTR pszAssocSelector,
        IN LPCWSTR pszUserName,
        IN _IWmiCallSec    *pCallSec,
        IN _IWmiUserHandle *pUser,
        IN DWORD  dwUserFlags,
        IN DWORD  dwInternalFlags,
        IN DWORD  dwSecFlags,
        IN DWORD  dwPermission,
        IN BOOL   bForClient,
        IN BOOL   bRepositOnly,
        IN LPCWSTR pszClientMachineName,
        IN DWORD dwClientProcessID,
        IN  REFIID riid,
        OUT LPVOID *pConnection
        );

    static HRESULT PathBasedConnect(
            IN LPCWSTR pszPath,
            IN LPCWSTR pszUser,
            IN IWbemContext __RPC_FAR *pCtx,
            IN ULONG uClientFlags,
            IN DWORD dwSecFlags,
            IN DWORD dwPermissions,
            IN ULONG uInternalFlags,
            IN LPCWSTR pszClientMachineName,
            IN DWORD dwClientProcessID,
            IN REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices
            );

    void StopClientCalls(){m_bShutDown = TRUE;};
    HRESULT Dump(FILE *f);  // Debug only

    _IWmiCoreServices*  GetCoreServices( void ) { return m_pCoreSvc; }

	HRESULT GetDynamicReferenceClasses( long lFlags, IWbemContext* pCtx, IWbemObjectSink* pSink );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wbemq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQ.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcore.h>
#include <genutils.h>


CWbemRequest::CWbemRequest(IWbemContext* pContext, BOOL bInternallyIssued)
{
        m_pContext = NULL;
        m_pCA = NULL;
        m_pCallSec = NULL;
        m_ulForceRun = 0;
        m_fOk = false;        

        if(pContext == NULL)
        {
            // See if we can discern the context from the thread
            CWbemRequest* pPrev = CWbemQueue::GetCurrentRequest();
            if(pPrev)
            {
                pContext = pPrev->m_pContext;
                DEBUGTRACE((LOG_WBEMCORE, "Derived context %p from thread. Request was %p\n", pContext, pPrev));
            }
        }

        if(pContext)
        {
            // Create a derived context
            IWbemCausalityAccess* pParentCA;
            if (FAILED(pContext->QueryInterface(IID_IWbemCausalityAccess, (void**)&pParentCA))) return;
            CReleaseMe rm(pParentCA);
            if (FAILED(pParentCA->CreateChild(&m_pCA))) return;
            if(FAILED(m_pCA->QueryInterface(IID_IWbemContext, (void**)&m_pContext))) return;
        }
        else            // Create a fresh context
        {
            m_pContext = ConfigMgr::GetNewContext();
            if (NULL == m_pContext) return;
            if (FAILED( m_pContext->QueryInterface(IID_IWbemCausalityAccess, (void**)&m_pCA)))  return;
            m_lPriority = 0;
        }

        // Clone the call context.
        m_pCallSec = CWbemCallSecurity::CreateInst();
        if (m_pCallSec == 0)
        {    
            return;      // a CWbemRequest cannot be executed without CallSec
        }

        IServerSecurity *pSec = 0;
        HRESULT hRes = m_pCallSec->CloneThreadContext(bInternallyIssued);
        if(FAILED(hRes))
        {
            m_pCallSec->Release();
            m_pCallSec = NULL;
            return;
        }

        m_fOk = true;        
        _DBG_ASSERT(m_pCallSec && m_pContext && m_pCA);
}


CWbemRequest::~CWbemRequest()
{
    if (m_pContext) m_pContext->Release();
    if (m_pCA) m_pCA->Release();
    if (m_pCallSec)  m_pCallSec->Release();
}

BOOL CWbemRequest::IsChildOf(CWbemRequest* pOther)
{
    GUID guid = GUID_NULL;
    pOther->m_pCA->GetRequestId(&guid); 
    return (m_pCA->IsChildOf(guid) == S_OK);
}

BOOL CWbemRequest::IsSpecial()
{
    return (m_pCA->IsSpecial() == S_OK);
}

// Returns TRUE iff this request has otherts that depend on it.
BOOL CWbemRequest::IsDependee()
{
        if(m_pCA == NULL) return FALSE;

        // Check if the context has any "parents".  Note: this test has
        // false-positives if the client uses a context object.
        // ============================================================
        long lNumParents, lNumSiblings;
        m_pCA->GetHistoryInfo(&lNumParents, &lNumSiblings);
        return (lNumParents > 0);
}

// Returns TRUE iff this request has otherts that depend on it.
BOOL CWbemRequest::IsIssuedByProvider()
{
        if (m_pCA == NULL)  return FALSE;

        // Check if the context has any "parents".  Note: this test has
        // false-positives if the client uses a context object.
        // ============================================================
        long lNumParents, lNumSiblings;
        m_pCA->GetHistoryInfo(&lNumParents, &lNumSiblings);
        return (lNumParents > 1);
}

BOOL CWbemRequest::IsAcceptableByParent()
{
    return (!IsLongRunning() || !IsIssuedByProvider());
}

// Returns TRUE iff this request must have a thread created for it if one is
// not available
BOOL CWbemRequest::IsCritical()
{
    return (IsDependee() && !IsAcceptableByParent());
}


BOOL CWbemRequest::IsChildOf(IWbemContext* pOther)
{
    IWbemCausalityAccess* pOtherCA;
    if (FAILED(pOther->QueryInterface(IID_IWbemCausalityAccess, (void**)&pOtherCA)))
        return FALSE;

    GUID guid = GUID_NULL;
    pOtherCA->GetRequestId(&guid);
    pOtherCA->Release();

    return (m_pCA->IsChildOf(guid) == S_OK);
}

void CWbemRequest::GetHistoryInfo(long* plNumParents, long* plNumSiblings)
{
    m_pCA->GetHistoryInfo(plNumParents, plNumSiblings);
}

CWbemQueue::CWbemQueue()
{
    SetRequestLimits(2000, 1500, 1950);
    SetRequestPenalties(1, 1, 1);
    // thread limits are left to derived classes
}

BOOL CWbemQueue::IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq)
{
    CWbemRequest* pParentWbemReq = (CWbemRequest*)pRecord->m_pCurrentRequest;
    if(pParentWbemReq == NULL)
    {
        return TRUE;
    }

    CWbemRequest* pNewWbemReq = (CWbemRequest*)pReq;
    if(pNewWbemReq->IsChildOf(pParentWbemReq))
    {
        // This request is a child of the one this thread is processing.
        // We could use this thread, unless this is a long-running request and
        // this thread might be the one consuming the results.  In that case,
        // we want to create another thread (to avoid the possibility of a
        // deadlock) and let this one continue.
        // ===================================================================

        return pNewWbemReq->IsAcceptableByParent();
    }
    else
    {
        return FALSE;
    }
}

CWbemRequest* CWbemQueue::GetCurrentRequest()
{
    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(GetTlsIndex());
    if(pRecord)
    {
        _DBG_ASSERT(0 == wcsncmp(pRecord->m_pQueue->GetType(), L"WBEMQ", 5))    
         return (CWbemRequest*)pRecord->m_pCurrentRequest;
    }
    return NULL;
}

void CWbemQueue::AdjustInitialPriority(CCoreExecReq* pReq)
{
    CWbemRequest* pRequest = (CWbemRequest*) pReq;

    if(pRequest->IsSpecial() || pRequest->IsCritical())
    {
        pRequest->SetPriority(PriorityCriticalRequests);
    }
    else
    {
        // Get information from the context
        // ================================

        long lNumParents, lNumSiblings;                         // SEC:REVIEWED 2002-03-22 : Init to zero
        pRequest->GetHistoryInfo(&lNumParents, &lNumSiblings);
        pRequest->SetPriority(lNumParents * m_lChildPenalty +
                                lNumSiblings * m_lSiblingPenalty);
    }
}

void CWbemQueue::AdjustPriorityForPassing(CCoreExecReq* pReq)
{
    pReq->SetPriority(pReq->GetPriority() - m_lPassingPenalty);
}

void CWbemQueue::SetRequestPenalties(long lChildPenalty, long lSiblingPenalty,
                                        long lPassingPenalty)
{
    m_lChildPenalty = lChildPenalty;
    m_lSiblingPenalty = lSiblingPenalty;
    m_lPassingPenalty = lPassingPenalty;
}

//
// exit conditions:
// the CThreadRecord has a NULL request
// the event in the request is set
// the request is deleted
//
/////////////////////////////////////
BOOL CWbemQueue::Execute(CThreadRecord* pRecord)
{
    wmilib::auto_ptr<CWbemRequest> pReq( (CWbemRequest *) pRecord->m_pCurrentRequest);
    CAutoSignal SetMe(pReq->GetWhenDoneHandle());
    NullPointer NullMe((PVOID *)&pRecord->m_pCurrentRequest);

    IWbemCallSecurity*  pServerSec = pReq->GetCallSecurity();

    if(NULL == pServerSec )
    {
        ERRORTRACE((LOG_WBEMCORE, "Failing request due to an error retrieving security settings\n"));
        return FALSE;
    }

    pServerSec->AddRef();
    CReleaseMe  rmss( pServerSec );

    IUnknown *pOld = 0;
    // if the thread has OLE initialized, will NEVER fail
    if (FAILED(CoSwitchCallContext( pServerSec,  &pOld ))) 
    {
        return FALSE;
    }

    // Save the old impersonation level
    BOOL bImpersonating = FALSE;
    IServerSecurity* pOldSec = NULL;
    if(pOld)
    {
        if(FAILED(pOld->QueryInterface(IID_IServerSecurity,(void**)&pOldSec))) return FALSE;
        
        bImpersonating = pOldSec->IsImpersonating();
        if (FAILED(pOldSec->RevertToSelf()))
        {
            pOldSec->Release();
            return FALSE;
        }
    }

    // dismiss the objects because the method on the base class will do the work
    SetMe.dismiss();
    pReq.release();
    BOOL bRes = CCoreQueue::Execute(pRecord);

    IUnknown *pNew = 0;
    // if the previous has succeded, this one will succed too
    CoSwitchCallContext(pOld, &pNew); 

    // Restore the old impersonation level
    // ===================================

    if(pOldSec)
    {
        if(bImpersonating)
        {
            if (FAILED(pOldSec->ImpersonateClient()))
            {
                ERRORTRACE((LOG_WBEMCORE, "CWbemQueue::Execute() failed to reimpersonate client\n"));
                bRes = FALSE;
            }
        }

        pOldSec->Release();
    }

    return bRes;
}


BOOL CWbemQueue::DoesNeedNewThread(CCoreExecReq* pRequest, bool bIgnoreNumRequests )
{
    // Check the base class
    if(CCoreQueue::DoesNeedNewThread(pRequest, bIgnoreNumRequests))
        return TRUE;

    if(pRequest)
    {
        // Check if the request is "special".  Special requests are issued by
        // the sink proxy of an out-of-proc event provider. Such requests must
        // be processed at all costs, because their parent thread is stuck in
        // RPC. Additionally, check if this request is marked as "critical",
        // which would mean that its parent thread didn't take it.
        // ===================================================================

        CWbemRequest* pWbemRequest = (CWbemRequest*)pRequest;
        return (pWbemRequest->IsSpecial() || pWbemRequest->IsCritical());
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wbemname.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMNAME.CPP

Abstract:

    Implements the COM layer of WINMGMT --- the class representing a namespace.
    It is defined in wbemname.h

History:

    raymcc    05-Apr-96  Created.
    raymcc    23-Apr-00  Whistler extensions

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include <autoptr.h>
#include <comutl.h>
#include <helper.h>

#include "wmiarbitrator.h"
#include "wmifinalizer.h"
#include "wmimerger.h"

#ifdef DBG
    TimeTraces gTimeTraceHistory;
    CStaticCritSec OperationStat::lock_;
#endif

extern BOOL g_bDontAllowNewConnections;

//***************************************************************************
//
//***************************************************************************

#define WBEM_MASK_DEPTH (WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW)
#define WBEM_MASK_CREATE_UPDATE (WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_CREATE_OR_UPDATE)

bool illFormatedClass2 (const wchar_t * pszSuperclass)
{
  for (const wchar_t * p = pszSuperclass; *p != L'\0'; ++p)
  {
    if (!(isunialphanum (*p) ||  *p == L'_'))
    {
      return true;  //Ill formated
    }
  }
  return false;
};


HRESULT IsDerivedFromSystem(CWbemObject& obj, bool * result)
{
    *result = true;
    CVar vClass;
    HRESULT hr = obj.GetClassName(&vClass);
    if (FAILED(hr)) return hr;

    wchar_t * className = vClass.GetLPWSTR();
    if (className[0] == L'_') return S_OK;

    CVar vDeriv;
    hr = obj.GetDerivation(&vDeriv);
    if (FAILED(hr)) return hr;

    CVarVector *pvTemp = vDeriv.GetVarVector();

    for (int j = 0; j < pvTemp->Size(); j++)
    {
        CVar& vParentName = pvTemp->GetAt(j);
	wchar_t * parentName = vParentName.GetLPWSTR();
        if (parentName[0] == L'_')
        {
	    return S_OK;
        }
    }        
    *result = false;
    return S_OK;
};


//***************************************************************************
//
//  StripServer
//   if the string is \\SOMETHING\namespace1\namespace2
//             returns namespace1\namespace2
// but it pre-allocates \\.\ in front of it, so that you can move back the pointer
//
//***************************************************************************


LPWSTR StripServer(LPWSTR pszNamespace)
{
    LPWSTR lpRet = NULL;
    WCHAR * lpPtr = pszNamespace;
    if (*lpPtr == L'\\' || *lpPtr == L'/')
    {
        lpPtr++;
        if (*lpPtr == L'\\' || *lpPtr == L'/')
        {
            BOOL bSlash = FALSE;
            while (*lpPtr)
            {
                lpPtr++;
                if (*lpPtr == L'\\' || *lpPtr == L'/')
                {
                    bSlash = TRUE;
                    break;
                }
            }
            if (bSlash)
            {
                lpPtr++;
                size_t tmpSize = 4 + wcslen(lpPtr) + 1;
                WCHAR * pFull = new WCHAR[tmpSize];
                if (NULL == pFull) return pFull;
                StringCchCopyW(pFull,tmpSize,L"\\\\.\\");
                StringCchCopyW(pFull+4,tmpSize-4,lpPtr);
                lpRet = pFull;
            }
        }
    }

    if (!lpRet)
    {
        size_t tmpSize = 4 + wcslen(lpPtr) + 1;
        WCHAR * pFull = new WCHAR[tmpSize];
        if (NULL == pFull) return pFull;
        StringCchCopyW(pFull,tmpSize,L"\\\\.\\");
        StringCchCopyW(pFull+4,tmpSize-4,lpPtr);
        lpRet = pFull;        
    }

    return lpRet;
}


//
//
//
///////////////////////////////////////////////////////////////
class CSecureEssNamespaceSink
: public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWbemPtr<CWbemNamespace> m_pNamespace;
    CWbemPtr<IWbemObjectSink> m_pSink;

public:


    CSecureEssNamespaceSink( CWbemNamespace* pNamespace,
                             IWbemObjectSink* pSink )
     : m_pNamespace(pNamespace), m_pSink(pSink) {}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray)
    {
        HRESULT hRes = m_pNamespace->CheckNs();
        if (FAILED(hRes))
            return hRes;

        if ( !m_pNamespace->Allowed( WBEM_FULL_WRITE_REP ) )
            return WBEM_E_ACCESS_DENIED;
        return m_pSink->Indicate( lObjectCount, pObjArray );
    }

    STDMETHOD(SetStatus)(long a, long b, BSTR c, IWbemClassObject* d)
    {
        HRESULT hRes = m_pNamespace->CheckNs();
        if (FAILED(hRes))
            return hRes;

        if ( !m_pNamespace->Allowed( WBEM_FULL_WRITE_REP ) )
            return WBEM_E_ACCESS_DENIED;
        return m_pSink->SetStatus( a, b, c, d );
    }
};



//***************************************************************************
//
//***************************************************************************
//
CWbemNamespace::CWbemNamespace()
{
    m_uSecondaryRefCount = 0;
    m_bShutDown = FALSE;

    m_pSession = 0;
    m_pDriver = 0;
    m_pNsHandle = 0;
    m_pScopeHandle = 0;

    m_pThisNamespace = 0;
    m_pThisNamespaceFull = 0;    
    m_dwPermission = 0;
    m_dwSecurityFlags = 0;
    m_wszUserName = 0;

    m_bProvider = FALSE;
    m_bForClient = FALSE;
    m_bESS = FALSE;

    m_bSecurityInitialized = FALSE;

    m_pProvFact = 0;
    m_pCoreSvc = 0;
    m_bRepositOnly = FALSE;
    m_pRefreshingSvc = NULL;


    m_pszClientMachineName = NULL;
    m_dwClientProcessID = -1;

    m_pArb = CWmiArbitrator::GetRefedArbitrator();
    m_pArb->RegisterNamespace((_IWmiCoreHandle *)this);

    gClientCounter.AddClientPtr(&m_Entry);

}



//***************************************************************************
//
//***************************************************************************
//
CWbemNamespace *CWbemNamespace::CreateInstance()
{
    try
    {
        if (NULL == CWmiArbitrator::GetUnrefedArbitrator()) return NULL;
        CWbemNamespace *pNs = new CWbemNamespace;
        if (pNs) pNs->AddRef();
        return pNs;
    }
    catch(CX_Exception &)
    {
        return 0;
    }
}


//***************************************************************************
//
//  CWbemNamespace::Initialize
//
//  Real constructor. In addition to finding the namespace in the database, this
//  function also enumerates all the class providers in the namespace and
//  loads them. It also notifies the ESS of the opening.
//
//  PARAMETERS:
//
//      LPWSTR Namespace        The full of the namespace to create.
//
//  RETURN VALUES:
//
//      Even though this function has no return values, it indicates success
//      or failure by setting the Status member variable to the error code.
//      WBEM_S_NO_ERROR              On Success
//      WBEM_E_INVALID_NAMESPACE     No such namespace
//      WBEM_E_CRITICAL_ERROR        Other database error.
//
//***************************************************************************

HRESULT CWbemNamespace::Initialize(
    LPWSTR pszNamespace,
    LPWSTR wszUserName,
    DWORD dwSecFlags,
    DWORD dwPermission,
    BOOL  bForClient,
    BOOL  bRepositOnly,
    LPCWSTR pszClientMachineName,
    DWORD dwClientProcessID,
    BOOL  bSkipSDInitialize,
    IWmiDbSession *pParentSession)
{
    try
    {
        m_dwSecurityFlags = dwSecFlags;
        m_dwPermission = dwPermission;
        if(g_bDontAllowNewConnections)
            return WBEM_E_SHUTTING_DOWN;

        PSID pRawSid;
        SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

        if (!AllocateAndInitializeSid( &id, 2,                         // SEC:REVIEWED 2002-03-22 : OK
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0,0,0,0,0,0,&pRawSid))
            return WBEM_E_OUT_OF_MEMORY;

        CNtSid Sid(pRawSid);
        FreeSid( pRawSid );
        if (CNtSid::NoError != Sid.GetStatus()) return WBEM_E_OUT_OF_MEMORY;
 
        CNtAce ace(1,ACCESS_ALLOWED_ACE_TYPE,0,Sid);
        if(ace.GetStatus() != 0)
            return WBEM_E_OUT_OF_MEMORY;

        CNtAcl acl;
        acl.AddAce(&ace);
        m_sdCheckAdmin.SetDacl(&acl);
        CNtSid owner(CNtSid::CURRENT_USER);
        if (CNtSid::NoError != owner.GetStatus()) return WBEM_E_OUT_OF_MEMORY;        
        m_sdCheckAdmin.SetGroup(&owner);
        m_sdCheckAdmin.SetOwner(&owner);

        m_bForClient = bForClient;

        m_pThisNamespaceFull = StripServer(pszNamespace);
        if(m_pThisNamespaceFull == NULL) return WBEM_E_OUT_OF_MEMORY;
        m_pThisNamespace = m_pThisNamespaceFull + 4; // move past "\\.\"

        m_pCoreSvc = CCoreServices::CreateInstance();
        if(m_pCoreSvc == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        m_pProvFact = 0;


        m_bRepositOnly = bRepositOnly;

        // Flip the slashes
        // ================

        WCHAR* pwc = m_pThisNamespace;
        while(*pwc)
        {
            if(*pwc == '/')
                *pwc = '\\';
            pwc++;
        }

        m_wszUserName = (wszUserName?Macro_CloneLPWSTR(wszUserName):NULL);

        // Repository binding.
        // ===================

        m_pNsHandle = 0;
        HRESULT hRes;
        IWmiDbSession *pTempSession= pParentSession;
        if (pTempSession == NULL)
        {
            hRes = CRepository::GetDefaultSession(&pTempSession);
            if (FAILED(hRes)) return hRes;
        }
        else
            pTempSession->AddRef();
        CReleaseMe rmSession(pTempSession);

        hRes = CRepository::OpenScope(pTempSession, m_pThisNamespace, 0, &m_pDriver, &m_pSession, &m_pScopeHandle, &m_pNsHandle);
        if (FAILED(hRes))
        {
            Status = WBEM_E_INVALID_NAMESPACE;
            return hRes;
        }

        if (m_pScopeHandle == 0)
        {
            m_bSubscope = FALSE;
            m_pScopeHandle = m_pNsHandle;
            if(m_pScopeHandle == NULL)
            {
                ERRORTRACE((LOG_WBEMCORE, "OpenScope returned success, yet m_pNsHandle is null!\n"));
                return WBEM_E_CRITICAL_ERROR;
            }
            m_pScopeHandle->AddRef();
        }
        else
        {
#ifdef DBG
            DebugBreak();
#endif
            m_bSubscope = TRUE;
            return WBEM_E_INVALID_NAMESPACE;
        }

        m_pProvFact = 0;
        if (!bRepositOnly)
        {
            _IWmiProvSS *pProvSS = 0;
            m_pCoreSvc->GetProviderSubsystem(0, &pProvSS);
            CReleaseMe _(pProvSS);

            if(pProvSS)
            {
                HRESULT hr = pProvSS->Create(
                    this,                           // Stupid because v-table access can occur before constructor completion
                    0,                              // lFlags
                    0,                              // pCtx
                    m_pThisNamespace,               // Path
                    IID__IWmiProviderFactory,
                    (LPVOID *) &m_pProvFact
                    );

                if (FAILED(hr)) return hr ;
            }
        }

        if(pszClientMachineName)
        {
            delete m_pszClientMachineName;
            DUP_STRING_NEW(m_pszClientMachineName, pszClientMachineName);
            if(m_pszClientMachineName == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
        m_dwClientProcessID = dwClientProcessID;

        Status = WBEM_S_NO_ERROR;

        //Initialize Security descriptor
        if (!bSkipSDInitialize)
        {
            hRes = InitializeSD(pTempSession);
            if (FAILED(hRes)) return hRes;
        }

        m_pCoreSvc->IncrementCounter(WMICORE_SELFINST_CONNECTIONS, 1);

        return Status;

    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_FAILED;
    }
}

//***************************************************************************
//
//  CWbemNamespace::~CWbemNamespace
//
//  Notifies the ESS of namespace closure and frees up all the class providers.
//
//***************************************************************************

CWbemNamespace::~CWbemNamespace()
{
    // do this before releasing the arbitrator
    m_pArb->UnregisterNamespace((_IWmiCoreHandle *)this);

    if (m_pCoreSvc)
        m_pCoreSvc->DecrementCounter(WMICORE_SELFINST_CONNECTIONS, 1);

    ReleaseIfNotNULL(m_pProvFact);
    ReleaseIfNotNULL(m_pCoreSvc);
    ReleaseIfNotNULL(m_pSession);
    ReleaseIfNotNULL(m_pDriver);
    ReleaseIfNotNULL(m_pNsHandle);
    ReleaseIfNotNULL(m_pScopeHandle);
    ReleaseIfNotNULL(m_pRefreshingSvc);
    ReleaseIfNotNULL(m_pArb);

    DeleteAndNull(m_pThisNamespaceFull);
    DeleteAndNull(m_wszUserName);
    DeleteAndNull(m_pszClientMachineName);

    gClientCounter.RemoveClientPtr(&m_Entry);
}

//***************************************************************************
//
//  CWbemNamespace::QueryInterface
//
//  Exports IWbemServices interface.
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{

    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemServices==riid )
    {
        *ppvObj = (IWbemServices*)this;
        AddRef();
        return S_OK;
    }
    else if (IID_IWbemRefreshingServices == riid)
    {
        CInCritSec  ics(&m_cs);

        // Check if we already have this one
        if ( NULL == m_pRefreshingSvc )
        {
            IUnknown * pUnk = NULL;
            // Aggregate this interface - We MUST use IUnknown, so the aggregee does not AddRef us.
            HRESULT hr = CoCreateInstance( CLSID__WbemConfigureRefreshingSvcs,          // SEC:REVIEWED 2002-03-22 : OK
                                         (IWbemServices*) this, CLSCTX_INPROC_SERVER,
                                         IID_IUnknown, (void**) &pUnk );
            if (FAILED(hr)) return hr;
            OnDeleteIf<IUnknown *,void(*)(IUnknown *),RM> rmUnk(pUnk);

            _IWbemConfigureRefreshingSvcs*  pCfgRefrSvc = NULL;
            hr = pUnk->QueryInterface( IID__IWbemConfigureRefreshingSvcs, (void**) &pCfgRefrSvc );
            if (FAILED(hr)) return hr;
            CReleaseMe  rm(pCfgRefrSvc);    

            // Use BSTR's in case any marshaling takes place
            BSTR pstrMachineName = SysAllocString( ConfigMgr::GetMachineName() );
            if (NULL == pstrMachineName) return E_OUTOFMEMORY;
            CSysFreeMe  sfm1( pstrMachineName );

            BSTR    pstrNamespace = SysAllocString( m_pThisNamespace );
            if (NULL == pstrNamespace) return E_OUTOFMEMORY;    
            CSysFreeMe  sfm2( pstrNamespace );

            hr = pCfgRefrSvc->SetServiceData( pstrMachineName, pstrNamespace );

            if (FAILED(hr)) return hr;

            // compensate the Automatic Objects above
            m_pRefreshingSvc = pUnk;
            rmUnk.dismiss();
        }

        return m_pRefreshingSvc->QueryInterface( IID_IWbemRefreshingServices, ppvObj );
    }
    else if(IID_IWbemInternalServices == riid)
    {
        *ppvObj = (IWbemInternalServices*)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWbemNamespace::AddRef()
{
    ULONG uNewCount = InterlockedIncrement((LONG *) &m_uSecondaryRefCount);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWbemNamespace::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uSecondaryRefCount);
    if (0 == uNewCount)  delete this;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::Dump(FILE *f)
{
    // SEC:REVIEWED 2002-03-22 : OK; debugging use only

    fprintf(f, "---Namespace = 0x%p----------------------------\n", this);    // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "    Secondary Refcount = %d\n", m_uSecondaryRefCount);        // SEC:REVIEWED 2002-03-22 : OK
    if(m_pThisNamespace)
        fprintf(f,  "    Name = %ls\n", m_pThisNamespace);                    // SEC:REVIEWED 2002-03-22 : OK
    if(m_wszUserName)
        fprintf(f,  "    User Name = %ls\n", m_wszUserName);                  // SEC:REVIEWED 2002-03-22 : OK
    if(m_pszClientMachineName)
        fprintf(f,  "    Client Machine Name = %ls\n", m_pszClientMachineName);  // SEC:REVIEWED 2002-03-22 : OK
    else
        fprintf(f,  "    Client Machine Name = <unknown>\n");                    // SEC:REVIEWED 2002-03-22 : OK
    if(m_dwClientProcessID)
        fprintf(f,  "    Client Process = 0X%X\n", m_dwClientProcessID);         // SEC:REVIEWED 2002-03-22 : OK
    else
        fprintf(f,  "    Client Process = <unknown>\n");                         // SEC:REVIEWED 2002-03-22 : OK


    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//
/*
HRESULT CWbemNamespace::SetErrorObj(IWbemClassObject* pErrorObj)
{
    if (pErrorObj == NULL)
    {
        return S_OK;
    }

    IErrorInfo* pInfo;
    HRESULT hRes = pErrorObj->QueryInterface(IID_IErrorInfo, (void**)&pInfo);
    if (FAILED(hRes))
        return hRes;

    hRes = SetErrorInfo(0, pInfo);
    pInfo->Release();
    return hRes;
}
*/


//***************************************************************************
//
//  CWbemNamespace::SplitLocalized
//
//***************************************************************************

HRESULT CWbemNamespace::SplitLocalized (
    CWbemObject *pOriginal,
    CWbemObject *pStoredObj
    )
{
    HRESULT hres = 0;

    CVar vProv;

    IWbemQualifierSet *pOrigQs = NULL, *pStoredQs = NULL;
    VARIANT vVal;
    VariantInit(&vVal);

    hres = pOriginal->GetQualifierSet(&pOrigQs);
    if (FAILED(hres))
        return hres;

    if (pStoredObj)
    {
        hres = pStoredObj->GetQualifierSet(&pStoredQs);
        if (FAILED(hres))
        {
            pOrigQs->Release();
            return hres;
        }
    }

    hres = FixAmendedQualifiers(pOrigQs, pStoredQs);
    pOrigQs->Release();
    pOrigQs = NULL;
    if (pStoredQs) 
    {
        pStoredQs->Release();
        pStoredQs = NULL;
    }


    if (SUCCEEDED(hres))
    {
        pOriginal->BeginEnumeration(0);
        LONG lLong;
        CIMTYPE ct;
        VARIANT vNewVal;
        VariantInit(&vNewVal);
        BSTR strPropName = NULL;

        while((hres = pOriginal->Next(0, &strPropName, &vNewVal, &ct, &lLong)) == S_OK)
        {
            CSysFreeMe sfm(strPropName);
            CClearMe   ccm(&vNewVal);
            
            CWStringArray arrDel;
            pOrigQs = NULL;
            pStoredQs = NULL;

            // Ignore system qualifiers.

            if (strPropName[0] == L'_')
            { 
                continue;
            }

            hres = pOriginal->GetPropertyQualifierSet(strPropName, &pOrigQs);
            if (FAILED(hres))
            {
                return hres;
            }

            pStoredQs = NULL;
            if (pStoredObj)
            {
                pStoredObj->GetPropertyQualifierSet(strPropName, &pStoredQs);
            }

            hres = FixAmendedQualifiers(pOrigQs, pStoredQs);
            pOrigQs->Release();
            if (pStoredQs)
                pStoredQs->Release();

        }

        pOriginal->EndEnumeration();

        // Unfortunately, we have to enumerate the methods,
        // and *then* update them...

        BSTR bstrMethodName;

        pOriginal->BeginMethodEnumeration(0);
        IWbemClassObject *pLIn = NULL, *pLOut = NULL, *pOIn = NULL, *pOOut = NULL;

        // first count the number of methods

        while ( pOriginal->NextMethod( 0, &bstrMethodName, 0, 0 ) == S_OK )
        {
            pLIn = pLOut = pOIn = pOOut = NULL;
            pOrigQs = NULL ;
            pStoredQs = NULL ;

            hres = pOriginal->GetMethod(bstrMethodName, 0, &pLIn, &pLOut);
            if ( FAILED ( hres ) )
            {
                continue ;
            }

            CSysFreeMe fm(bstrMethodName);
            CReleaseMe rm0(pLIn);
            CReleaseMe rm2(pLOut);

            hres = pOriginal->GetMethodQualifierSet(bstrMethodName, &pOrigQs);
            if (FAILED(hres))
            {
                continue;
            }

            CReleaseMe rm4 ( pOrigQs ) ;

            if (pStoredObj)
            {
                hres = pStoredObj->GetMethodQualifierSet(bstrMethodName, &pStoredQs);
                if ( FAILED ( hres ) )
                {
                    continue ;
                }
            }

            CReleaseMe rm5 ( pStoredQs ) ;

            // Method qualifiers...

            hres = FixAmendedQualifiers(pOrigQs, pStoredQs);

            if (SUCCEEDED(hres))
            {
                if (pStoredObj)
                    hres = pStoredObj->GetMethod(bstrMethodName, 0, &pOIn, &pOOut);

                CReleaseMe rm1(pOIn);
                CReleaseMe rm3(pOOut);

                if (pLIn)
                    hres = SplitLocalized((CWbemObject *)pLIn, (CWbemObject *)pOIn);

                if (pLOut)
                    hres = SplitLocalized((CWbemObject *)pLOut, (CWbemObject *)pOOut);

                hres = pOriginal->PutMethod(bstrMethodName, 0, pLIn, pLOut);
            }
            else
                break;
        }
        pOriginal->EndMethodEnumeration();

    }

    hres = 0;

    return hres;

}

//***************************************************************************
//
//  CWbemNamespace::FixAmendedQualifiers
//
//***************************************************************************

HRESULT CWbemNamespace::FixAmendedQualifiers(
    IWbemQualifierSet *pOriginal,
    IWbemQualifierSet *pNew
    )
 {
    HRESULT hres = 0;
    CWStringArray arrDelete;
    CWStringArray arrProps;
    BSTR strName = 0;
    long lFlavor;



    int i;

    pOriginal->BeginEnumeration(0);
    // BUGBUG EndEnum
    while(pOriginal->Next(0, &strName, NULL, NULL) == S_OK)
    {
        CSysFreeMe sfm(strName);
        if (CFlexArray::no_error != arrProps.Add(strName))
            return WBEM_E_OUT_OF_MEMORY;
    }

    for (i = 0; i < arrProps.Size(); i++)
    {
        _variant_t vVal;
        pOriginal->Get(arrProps.GetAt(i), 0, &vVal, &lFlavor);
        if (lFlavor & WBEM_FLAVOR_AMENDED)
        {
            // Delete the "amended" qualifier.

            if (CFlexArray::no_error != arrDelete.Add(arrProps.GetAt(i)))
                return WBEM_E_OUT_OF_MEMORY;

            // Restore any original qualifier value.
            if (pNew)
            {
                _variant_t vOldVal;
                long lOldFlavor;
                if (pNew->Get(arrProps.GetAt(i), 0, &vOldVal, &lOldFlavor) != WBEM_E_NOT_FOUND)
                {
                    pOriginal->Put(arrProps.GetAt(i), &vOldVal, lOldFlavor);
                    arrDelete.RemoveAt(arrDelete.Size()-1);
                }
            }
        }
    }
    pOriginal->EndEnumeration();

    for (i = 0; i < arrDelete.Size(); i++)
    {
        pOriginal->Delete(arrDelete.GetAt(i));
    }

    arrDelete.Empty();

    return hres;

 }

//***************************************************************************
//
//  CWbemNamespace::Exec_DeleteClass
//
//  Actually deletes the class from the database. No class provider support.
//  Raises class deletion event.
//
//  Parameters and return values are exacly the same as those for DeleteClass
//  as described in help
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_DeleteClass(
    LPWSTR pszClassName,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    TIMETRACE(TimeTraces::DeleteClass);
    HRESULT hRes;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pStaticClassDef = 0;
    BOOL bInRepository = FALSE;

    if (pszClassName == 0 || pSink == 0)
        return pSink->Return(WBEM_E_INVALID_PARAMETER);

    if (pszClassName[0] == L'_')
        return pSink->Return(WBEM_E_INVALID_OPERATION);

    // Bring up the dynamic class provider symposium for consultation.
    // ===============================================================

    if (!m_bRepositOnly && m_pProvFact)
    {
        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return pSink->Return(hRes);
    }

    CReleaseMe _2(pClassProv);

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes))
        return pSink->Return(hRes);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;


    // First, try repository.
    // ======================

    if (m_bRepositOnly || m_pProvFact == NULL)
    {

        if (!Allowed(WBEM_FULL_WRITE_REP))
            return pSink->Return(WBEM_E_ACCESS_DENIED);

        if (pHook)
            pHook->PreDelete(WBEM_FLAG_CLASS_DELETE, lFlags, pCtx, NULL,
                                       m_pThisNamespace, pszClassName );

        hRes = CRepository::DeleteByPath(m_pSession, m_pNsHandle, pszClassName, lFlags);

        if (pHook)
            pHook->PostDelete(WBEM_FLAG_CLASS_DELETE, hRes, pCtx, NULL, m_pThisNamespace, pszClassName, NULL);

        return pSink->Return(hRes);
    }

    // If here, we have to get it first because dynamic class providers
    // could be seriously affected by the removal of the class.
    // ================================================================

    hRes = CRepository::GetObject(
             m_pSession,
             m_pNsHandle,
             pszClassName,
             0,
             &pStaticClassDef
             );

    CReleaseMe _1(pStaticClassDef);

    if (SUCCEEDED(hRes))
    {
        bInRepository = TRUE;
        if (!Allowed(WBEM_FULL_WRITE_REP))
            return pSink->Return(WBEM_E_ACCESS_DENIED);
        if (pStaticClassDef == 0)
            return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    // Build up a synchronous sink to receive the class.
    // =================================================

    pSyncSink = CSynchronousSink::Create();
    if (pSyncSink == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _3(pSyncSink);

    // Try to get it.
    // ==============

    bstrClass = SysAllocString(pszClassName);
    if (bstrClass == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CSysFreeMe sfm(bstrClass);

    // If the class was in the repository, we are merely advising dynamic
    // class providers that the class is going away.
    // ==================================================================

    if (bInRepository)
        lFlags |= WBEM_FLAG_ADVISORY;
    else
    {
        if (!Allowed(WBEM_WRITE_PROVIDER))
            return pSink->Return(WBEM_E_ACCESS_DENIED);
    }

    hRes = pClassProv->DeleteClassAsync(bstrClass, lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pSyncSink);

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return pSink->Return(hRes);

    pSyncSink->Block();
    IWbemClassObject* pErrorObj = 0;
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
    CReleaseMe rmErrObj(pErrorObj);

    if (FAILED(hRes))
    {
        pSink->Return(hRes, pErrorObj);
        return hRes;
    }

    // If here, we can go ahead with it.
    // =================================

    if (pHook)
        pHook->PreDelete(WBEM_FLAG_CLASS_DELETE, lFlags, pCtx, NULL,
                                       m_pThisNamespace, pszClassName );

    if (bInRepository)
        hRes = CRepository::DeleteByPath(m_pSession, m_pNsHandle, pszClassName, lFlags);

    if (pHook)
        pHook->PostDelete(WBEM_FLAG_CLASS_DELETE, hRes, pCtx, NULL, m_pThisNamespace, pszClassName, NULL);

    return pSink->Return(hRes);
}


//***************************************************************************
//
//  CWbemNamespace::Exec_CreateClassEnum
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CreateClassEnum(
    LPWSTR pszSuperclass,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    TIMETRACE(TimeTraces::CreateClassEnum);
    HRESULT hRes;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pResultObj = 0;
    CCombiningSink* pCombiningSink = NULL;
    CLocaleMergingSink * pLocaleSink = NULL;
    CBasicObjectSink  *pTmp = 0;
    BSTR bstrSuperclass = 0;
    bool bProvSSNotFound = false;
    bool bRepNotFound = false;

    // Quick check of parms.
    // =====================

    if (pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pszSuperclass == 0)     // Ensure we point to a blank instead of NULL with no superclass
        pszSuperclass = L"";
    else
      {
      if (illFormatedClass2 (pszSuperclass))
        return pSink->Return(WBEM_E_INVALID_CLASS);
      }


    // Prepare some sinks to hold everything.
    // ======================================

    if ((lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS))
    {
        pLocaleSink = new CLocaleMergingSink(pSink, m_wsLocale, m_pThisNamespace);
        if (pLocaleSink == NULL)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pLocaleSink->AddRef();
        pTmp = pLocaleSink;
    }
    else
        pTmp = pSink;
    CReleaseMe _1(pLocaleSink);

    pCombiningSink = new CCombiningSink(pTmp);
    if (NULL == pCombiningSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);    
    pCombiningSink->AddRef();    
    CReleaseMe _2(pCombiningSink);

    // Bring up the dynamic class provider symposium for consultation.
    // ===============================================================

    if ( !m_bRepositOnly && m_pProvFact)
    {

        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return pCombiningSink->Return(hRes);
    }

    CReleaseMe _3(pClassProv);

    // Get the repository classes.
    // ===========================

    BOOL bUseStatic = !(lFlags & WBEM_FLAG_NO_STATIC);
    if (bUseStatic)
    {
        if ((lFlags & WBEM_MASK_DEPTH) == WBEM_FLAG_DEEP)
        {
            // DEEP ENUM
            // ==========
            IWbemObjectSink *pObjSink = (IWbemObjectSink *) pCombiningSink;
            hRes = CRepository::QueryClasses(
                        m_pSession,
                        m_pNsHandle,
                        WBEM_FLAG_DEEP | WBEM_FLAG_VALIDATE_CLASS_EXISTENCE,
                        pszSuperclass,
                        pObjSink);
        }
        else
        {
            // SHALLOW ENUM
            // =============
            IWbemObjectSink *pObjSink = (IWbemObjectSink *) pCombiningSink;
            hRes = CRepository::QueryClasses(
                        m_pSession,
                        m_pNsHandle,
                        WBEM_FLAG_SHALLOW | WBEM_FLAG_VALIDATE_CLASS_EXISTENCE,
                        pszSuperclass,
                        pObjSink);
        }

        //If a SetStatus of INVALID_CLASS was indicated it means there is no static
        //class, however we need to continue on with dynamic classes, so we need
        //to clear the error.
        if ((pCombiningSink->GetHResult() == WBEM_E_NOT_FOUND) || (hRes == WBEM_E_NOT_FOUND))
        {
            bRepNotFound = true;
            pCombiningSink->ClearHResult();
            hRes = WBEM_S_NO_ERROR;
        }

        if (FAILED(hRes))
        {
            // A real failure.  Give up.
            // =========================
            return pCombiningSink->Return(hRes);
        }
    }

    if (m_bRepositOnly || m_pProvFact == NULL)
        return pCombiningSink->Return(WBEM_S_NO_ERROR);

    // If here, we have to merge in the dynamic classes.
    // =================================================
    // Build up a synchronous sink to receive the classes.
    // ===================================================

    pSyncSink = CSynchronousSink::Create();
    if (pSyncSink == NULL) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _4(pSyncSink);

    // Try to get it.
    // ==============

    bstrSuperclass = SysAllocString(pszSuperclass);
    if (bstrSuperclass == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CSysFreeMe sfm99(bstrSuperclass);

    CDecoratingSink * pDecore = new CDecoratingSink(pSyncSink, this);
    if(pDecore == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pDecore->AddRef();
    CReleaseMe cdecor(pDecore);
    hRes = pClassProv->CreateClassEnumAsync(bstrSuperclass, (lFlags & (~WBEM_FLAG_USE_AMENDED_QUALIFIERS)) & ~WBEM_FLAG_NO_STATIC, pCtx, pDecore);
    if ((pSyncSink->GetHResult() == WBEM_E_NOT_FOUND) || (hRes == WBEM_E_NOT_FOUND))
    {
        bProvSSNotFound = true;
        pSyncSink->ClearHResult();
        hRes = WBEM_S_NO_ERROR;
    }

    if (bProvSSNotFound && bRepNotFound)
    {
        //Neither the provider subsystem nor the repository found this object,
        //therefore we need to actually return an error!
        return pCombiningSink->Return(WBEM_E_INVALID_CLASS);
    }

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return pCombiningSink->Return(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (FAILED(hRes))
    {
        pCombiningSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // Otherwise, somebody claimed to have supplied some classes.  Add them into to the
    // combining sink.
    // =================================================================================

    CRefedPointerArray<IWbemClassObject>& raObjects = pSyncSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];
        pCombiningSink->Indicate(1, &pClsDef);
    }

    return pCombiningSink->Return(WBEM_S_NO_ERROR);
}


//***************************************************************************
//
//  CWbemNamespace::Exec_PutClass
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_PutClass(
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink,
    BOOL fIsInternal
    )
{
    TIMETRACE(TimeTraces::PutClass);
    HRESULT hRes;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pStaticClassDef = 0;
    BOOL bInRepository = FALSE;

    // Maintains old functionality
    long lRealFlags = lFlags;

    if (pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pObj == 0) return pSink->Return(WBEM_E_INVALID_PARAMETER);

    // Extract the class name.
    // =======================
    CVARIANT v;
    hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes)) return pSink->Return(hRes);

    WCHAR * pClassName = L"";
    if (VT_BSTR == V_VT(&v) && NULL != V_BSTR(&v))
    {
        pClassName = V_BSTR(&v);
    }

    if (wcslen_max(pClassName,g_IdentifierLimit) > g_IdentifierLimit)
        return pSink->Return(WBEM_E_QUOTA_VIOLATION);            
        
    COperationError OpInfo(pSink, L"PutClass",pClassName);
    if (!OpInfo.IsOk()) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    
    _IWmiObject * pIntObj = NULL;
    hRes = pObj->QueryInterface(IID__IWmiObject,(void **)&pIntObj);
    CReleaseMe rm1(pIntObj);
    if (FAILED(hRes)) return OpInfo.ErrorOccurred(WBEM_E_INVALID_PARAMETER);

    if (WBEM_S_NO_ERROR == pIntObj->IsObjectInstance())
        return  OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);

    CVARIANT v2;
    hRes = pObj->Get(L"__SuperClass", 0, &v2, 0, 0);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    if (v2.GetStr() && wcslen(v2.GetStr()))   // SEC:REVIEWED 2002-03-22 : OK; NULL terminator provably exists
    {
        if (CSystemProperties::IsIllegalDerivedClass(v2.GetStr()))
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_SUPERCLASS);
    }

    if (!fIsInternal )
    {
        if ((v.GetStr() == NULL) || (v.GetStr()[0] == '_'))    // SEC:REVIEWED 2002-03-22 : OK; null terminator provably exists
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
        if (v.GetStr()[wcslen(v.GetStr())-1] == '_')           // SEC:REVIEWED 2002-03-22 : OK; null terminator provably exists
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);
    }

    if ( !m_bRepositOnly && !fIsInternal && m_pProvFact )
    {
        // Bring up the dynamic class provider symposium for consultation.
        // ===============================================================

        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return OpInfo.ErrorOccurred(hRes);
    }

    CReleaseMe _2(pClassProv);

    // Set up a new per-task hook.
    // ===========================

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes)) return OpInfo.ErrorOccurred(hRes);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;

    // First, try repository.
    // ======================

    if (m_bRepositOnly || fIsInternal || m_pProvFact == NULL)
    {
        if (!Allowed(WBEM_FULL_WRITE_REP))
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

        if (pHook)
            pHook->PrePut(WBEM_FLAG_CLASS_PUT, lFlags, pCtx, 0,
                          m_pThisNamespace, v.GetStr(), (_IWmiObject *)pObj);

        hRes = CRepository::PutObject(m_pSession, m_pNsHandle, IID_IWbemClassObject, pObj, lFlags);

        if (pHook)
            pHook->PostPut(WBEM_FLAG_CLASS_PUT, hRes, pCtx, 0, m_pThisNamespace, v.GetStr() , (_IWmiObject *)pObj, NULL);

        return OpInfo.ErrorOccurred(hRes);
    }

    hRes = CRepository::GetObject(
             m_pSession,
             m_pNsHandle,
             v.GetStr(),
             0,
             &pStaticClassDef
             );

    CReleaseMe _1(pStaticClassDef);

    if (SUCCEEDED(hRes))
    {
        bInRepository = TRUE;

        if (pStaticClassDef != 0)
        {
            // Remove all the amended qualifiers
            // =================================

            if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS )
            {
                int nRes = SplitLocalized( (CWbemObject*) pObj, (CWbemObject*) pStaticClassDef );
                if (FAILED(nRes))
                {
                    return pSink->Return(nRes);
                }
            }
        }
        else
        {
            return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);
        }
    }

    // Build up a synchronous sink to receive the class.
    // =================================================

    pSyncSink = CSynchronousSink::Create();
    if (pSyncSink == NULL) return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _3(pSyncSink);

    // Try to put it.
    // ==============

    // If the class was in the repository, we are merely advising dynamic
    // class providers that the class is going away.
    // ==================================================================

    if (bInRepository)
        lFlags |= WBEM_FLAG_ADVISORY;

    if (!Allowed(WBEM_WRITE_PROVIDER))
        hRes = WBEM_E_ACCESS_DENIED;
    else
        hRes = pClassProv->PutClassAsync(pObj, lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pSyncSink);


    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return OpInfo.ErrorOccurred(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (SUCCEEDED(hRes)&&(!bInRepository))
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // If here, we can go ahead with it.
    // =================================

    if (!Allowed(WBEM_FULL_WRITE_REP))
        return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

    if (pHook)
    {
        pHook->PrePut(WBEM_FLAG_CLASS_PUT, lFlags, pCtx, 0,
                      m_pThisNamespace, v.GetStr(), (_IWmiObject *)pObj);
    }

    hRes = CRepository::PutObject(m_pSession, m_pNsHandle, IID_IWbemClassObject, pObj, lFlags);

    // Workaround for forceupdate and instances problem
    if ( WBEM_E_CLASS_HAS_INSTANCES == hRes && ( lRealFlags & WBEM_FLAG_UPDATE_FORCE_MODE ) )
    {
        _variant_t v;
        hRes = pObj->Get( L"__CLASS", 0L, &v, NULL, NULL );
        if ( SUCCEEDED( hRes ) && V_VT( &v ) == VT_BSTR )
        {
            hRes = DeleteObject( V_BSTR( &v ), 0L, pCtx, NULL );
            if ( SUCCEEDED( hRes ) )
            {
                hRes = CRepository::PutObject(m_pSession, m_pNsHandle, IID_IWbemClassObject, pObj, lFlags);
            }
        }
        else
        {
            hRes = WBEM_E_CLASS_HAS_INSTANCES;
        }
    }

    if (pHook)
    {
        pHook->PostPut(WBEM_FLAG_CLASS_PUT, hRes, pCtx, 0, m_pThisNamespace, v.GetStr() , (_IWmiObject *)pObj, NULL);
    }


    return OpInfo.ErrorOccurred(hRes);
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CancelAsyncCall(
    IWbemObjectSink* pSink
    )
{

    _IWmiArbitrator *pArb = CWmiArbitrator::GetUnrefedArbitrator();
    HRESULT hRes = pArb->CancelTasksBySink(0, IID_IWbemObjectSink, pSink);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CancelProvAsyncCall(
    IWbemServices* pProv, IWbemObjectSink* pSink
    )
{
    // Call to the actual provider
    HRESULT hRes = pProv->CancelAsyncCall( pSink );
    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::Exec_PutInstance
//
//  Actually stores the instance in the database. If the class is dynamic, the
//  call is propagated to the provider.
//  Raises instance creation or modification event.
//
//  Parameters and return values are exacly the same as those for PutInstance
//  as described in help
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_PutInstance(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    TIMETRACE(TimeTraces::PutInstance);
    HRESULT hRes = CheckNs();
    if (FAILED(hRes)) return hRes;

    if (NULL == pSink) return WBEM_E_INVALID_PARAMETER;
    if(pInst == NULL) return pSink->Return(WBEM_E_INVALID_PARAMETER);

    COperationError OpInfo(pSink, L"PutInstance", L"");
    if (!OpInfo.IsOk()) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    CWbemObject *pObj = (CWbemObject *) pInst;
    HRESULT hres;

    _variant_t v;
    hRes = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if (FAILED(hRes)) return OpInfo.ErrorOccurred(hRes);
    
    if(VT_BSTR == V_VT(&v))
    {
        if (wcslen_max(V_BSTR(&v),g_PathLimit) > g_PathLimit)
            return OpInfo.ErrorOccurred(WBEM_E_QUOTA_VIOLATION);
    }

    if (!pObj->IsInstance())
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    if (!pObj->IsKeyed())
        return OpInfo.ErrorOccurred(WBEM_E_NO_KEY);

    if (pObj->IsLimited())
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    if (pObj->IsClientOnly())
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    // Check if localization bits are set, and if so, that the
    // AMENDED_QUALIFIERS flag was specified.

    if ( ((CWbemObject*) pObj)->IsLocalized() &&
        !( lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS ) )
    {
        return OpInfo.ErrorOccurred( WBEM_E_AMENDED_OBJECT );
    }

    if((lFlags & WBEM_FLAG_UPDATE_ONLY) == 0)
    {
        // Make sure that put extensions are not used without UPDATE_ONLY
        // ==============================================================

        BOOL bExtended;
        hres = GetContextBoolean(pCtx, L"__PUT_EXTENSIONS", &bExtended);
        if(FAILED(hres) || bExtended)
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_CONTEXT);
    }

    BSTR strPropName = NULL;
    CSysFreeMeRef fmref(strPropName);
    if(!pObj->ValidateRange(&strPropName))
    {
        OpInfo.SetParameterInfo(strPropName); // throws
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROPERTY);
    }

    // Build the key string.
    // =====================

    CVar vClass;
    hres = pObj->GetClassName(&vClass); // throw
    if (FAILED(hres))
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT);

    OpInfo.SetParameterInfo(vClass.GetLPWSTR()); // throws

    // Get the class definition
    // ========================
    IWbemClassObject* pErrorObj = NULL;
    IWbemClassObject* pClassObj = NULL;
    hres = Exec_GetObjectByPath(vClass.GetLPWSTR(), 0, pCtx,&pClassObj, &pErrorObj);
    CReleaseMe rmErrObj(pErrorObj);
    CReleaseMe rm1(pClassObj);    
    
    if(hres == WBEM_E_NOT_FOUND) hres = WBEM_E_INVALID_CLASS;

    if(FAILED(hres))  return OpInfo.ErrorOccurred(hres, pErrorObj);


    CWbemClass *pClassDef = (CWbemClass*)pClassObj;

    // Dont allow write of old security classes.  This prevents
    // a nefarious user from trying to slip in some extra rights

    if (wbem_wcsicmp(vClass.GetLPWSTR(), L"__NTLMUser") == 0 ||
        wbem_wcsicmp(vClass.GetLPWSTR(), L"__NTLMGroup") == 0)
    {
        if (!Allowed(WRITE_DAC))
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
        if((lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
        {
            return PutSecurityClassInstances(vClass.GetLPWSTR(), pInst ,
                        pSink, pCtx, lFlags);
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Dont allow write on the __thisnamespace instance -- except during an upgrade in setup
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (wbem_wcsicmp(vClass.GetLPWSTR(), L"__thisnamespace") == 0 && !IsNtSetupRunning())
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }

    // Make sure that the instance and the class match
    // ===============================================

    // SJS - Amendment is the same as Abstract
    if( pClassDef->IsAmendment() || pClassDef->IsAbstract() || !pClassDef->IsKeyed() )
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }

    if(!((CWbemInstance*)pObj)->IsInstanceOf(pClassDef)) // trow
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_CLASS);
    }

    // Verify provider validity
    // ========================

    // Only administrators can change provider registration
    // RAID# 566241
    // ==================================

    if(pObj->InheritsFrom(L"__Provider") == S_OK || pObj->InheritsFrom(L"__ProviderRegistration") == S_OK)
    {
        HANDLE hAccess;
        hres = GetAccessToken(hAccess);
        if ( FAILED (hres) )
        {
            if ( hres != 0x80041007 )
            {
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
        }
        else
        {
            if ( !IsAdmin(hAccess))
            {
                CloseHandle ( hAccess );
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
            CloseHandle ( hAccess );
        }
    }

    // While the class may not be dynamically provided, some of the
    // properties might be.
    // ============================================================

    hres = GetOrPutDynProps(pObj, PUT, pClassDef->IsDynamic());
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "Failed to pre-process an instance of %S using "
                                                         "a property provider. Error code: %X\n",
                                                         vClass.GetLPWSTR(), hres));
    }

    // Recursively Put in all the right places
    // ======================================

    CCombiningSink* pCombSink = new CCombiningSink(OpInfo.GetSink());
    if(pCombSink == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pCombSink->AddRef();
    CReleaseMe rm2(pCombSink);

    return RecursivePutInstance((CWbemInstance*)pObj, pClassDef, lFlags,
                pCtx, pCombSink, TRUE);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::RecursivePutInstance(
    CWbemInstance* pInst,
    CWbemClass* pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink,
    BOOL bLast
    )
{
    HRESULT hRes;

    // See if any action is required at this level
    // ===========================================
    if (pClassDef->IsAbstract() || pClassDef->IsAmendment() || !pClassDef->IsKeyed())
        return WBEM_S_FALSE;

    // See if we need to go up
    // =======================
    BOOL bParentTookCareOfItself = TRUE;

    if (pClassDef->IsDynamic())
    {
        // Get the parent class
        // ====================

        CVar vParentName;
        pClassDef->GetSuperclassName(&vParentName);
        if (!vParentName.IsNull())
        {
            IWbemClassObject* pParentClass = NULL;
            IWbemClassObject* pErrorObj = NULL;
            hRes = Exec_GetObjectByPath(vParentName.GetLPWSTR(), 0, pCtx,&pParentClass, &pErrorObj);
            CReleaseMe rm1(pParentClass);
            CReleaseMe rm2(pErrorObj);
            if (FAILED(hRes))
            {
                pSink->Return(hRes, pErrorObj);
                return hRes;
            }

            // Get it to put it's portion
            // ==========================

            hRes = RecursivePutInstance(pInst, (CWbemClass*)pParentClass,lFlags, pCtx, pSink, FALSE);
            if(FAILED(hRes))
                return hRes;

            if(hRes == WBEM_S_FALSE)
                bParentTookCareOfItself = FALSE;
        }
    }

    // Parent Puts have been taken care of. Call it on our own class.
    // ==============================================================

    // Convert the instance to the right class
    // =======================================

    CWbemInstance* pNewInst = NULL;
    pInst->ConvertToClass(pClassDef, &pNewInst);
    CReleaseMe rm1((IWbemClassObject*)pNewInst);

    if (pNewInst == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Failed to convert an instance to a base class\n"));
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }

    if (pClassDef->IsDynamic())
    {
        // Check if we need to do a put at this level
        // ==========================================

        if (!bLast && (lFlags & WBEM_FLAG_UPDATE_ONLY))
        {
            hRes = IsPutRequiredForClass(pClassDef, pInst, pCtx, bParentTookCareOfItself);
            if (FAILED(hRes))
                return pSink->Return(hRes);
            if (hRes == WBEM_S_FALSE)
            {
                // No need to put this class
                // =========================

                return pSink->Return(WBEM_S_NO_ERROR);
            }
        }

        // Get the provider name.
        // ======================

        CVar vProv;
        hRes = pClassDef->GetQualifier(L"Provider", &vProv);
        if (FAILED(hRes) || vProv.GetType() != VT_BSTR)
        {
            return pSink->Return(WBEM_E_INVALID_PROVIDER_REGISTRATION);
        }

        // Access the provider cache.  First check permission
        // ==================================================

        if (!Allowed(WBEM_WRITE_PROVIDER))
            return pSink->Return(WBEM_E_ACCESS_DENIED);

        CSynchronousSink* pSyncSink = CSynchronousSink::Create(pSink);
        if(pSyncSink == NULL) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pSyncSink->AddRef();
        CReleaseMe rmSync(pSyncSink);

        IWbemServices *pProv = 0;
        if(m_pProvFact == NULL)  return pSink->Return(WBEM_E_CRITICAL_ERROR);

        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ; // SEC:REVIEWED 2002-03-22 : OK

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProv,              // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
        );

        if (FAILED(hRes))  return pSink->Return(hRes);

        CReleaseMe _(pProv);

        pProv->PutInstanceAsync(pNewInst, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pSyncSink);

        pSyncSink->Block();

        IWbemClassObject* pErrorObj = NULL;
        BSTR str;
        pSyncSink->GetStatus(&hRes, &str, &pErrorObj);
        CSysFreeMe sfm(str);
        CReleaseMe rmErrObj(pErrorObj);
        rmSync.release();

        // It is ok if the upper levels report "provider not capable".
        // ===========================================================

        if (!bLast && hRes == WBEM_E_PROVIDER_NOT_CAPABLE)
            hRes = 0;

        if (FAILED(hRes))
        {
            COperationError OpInfo(pSink, L"PutInstance", L"");
            if (!OpInfo.IsOk()) return WBEM_E_OUT_OF_MEMORY;

            OpInfo.ProviderReturned(vProv.GetLPWSTR(), hRes, pErrorObj);
            return hRes;
        }
        else if (str)
        {
            pSink->SetStatus(0, hRes, str, NULL);
        }

        // Provider passes back NULL, we should construct the instance path and return to client
        // NT RAID: 186286 [marioh]
        // ======================================================================================
        else
        {
            BSTR str = NULL;
            LPWSTR wszPath = pNewInst->GetRelPath();
            if (wszPath )
            {
                str = SysAllocString(wszPath);
                delete [] wszPath;
            }

            pSink->SetStatus(0, hRes, str, NULL);
            SysFreeString(str);
        }

        return WBEM_S_NO_ERROR;
    }

    // The class is not dynamically provided.
    // ======================================

    hRes = ((CWbemInstance*)pNewInst)->PlugKeyHoles();
    if (FAILED(hRes))
        return pSink->Return(hRes);

    // Get the path.
    // =============

    CVar vClass;
    hRes = pNewInst->GetClassName(&vClass);
    if (FAILED(hRes))
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    WCHAR * ClassNameStr = vClass.GetLPWSTR();

    // Check permissions for writes on system classes.
    // ===============================================

    bool derivedFromSys = false;
    HRESULT hr = IsDerivedFromSystem(*pNewInst, &derivedFromSys); 	   	
    if (FAILED(hr)) return pSink->Return(hr);

    if (derivedFromSys)
    {
    	if (!Allowed(WBEM_FULL_WRITE_REP))
	return pSink->Return(WBEM_E_ACCESS_DENIED);
    }
    else if (!Allowed(WBEM_PARTIAL_WRITE_REP))
    {
     	return pSink->Return(WBEM_E_ACCESS_DENIED);
    }

    CVARIANT v;
    hRes = pNewInst->Get(L"__RELPATH", 0, &v, 0, 0);
    if(FAILED(hRes))
        return pSink->Return(hRes);
    if(v.GetType() != VT_BSTR)
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    
    // Set up a new per-task hook.
    // ===========================

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes))
        return pSink->Return(hRes);
    CReleaseMe _(pHook);
    HRESULT hHookResult = 0;

    // See if the instance already exists.
    // ===================================

    IWbemClassObject *pExistingObject = 0;
    hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, v.GetStr(),0, &pExistingObject);
    CReleaseMe _2(pExistingObject);


    if (FAILED(hRes))
    {
        // If we here, we failed to get it from the repository.  Thus, it needs to be created from scratch.
        // ================================================================================================

        // Remove all the amended qualifiers
        // =================================

        if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS )
        {
            int nRes = SplitLocalized(pNewInst);
            if (FAILED(nRes))
                return pSink->Return(nRes);
        }

        if((lFlags & WBEM_MASK_CREATE_UPDATE) == WBEM_FLAG_UPDATE_ONLY)
        {
            return pSink->Return(WBEM_E_NOT_FOUND);
        }

        // As a special case, see if the object is
        // of class <__NAMESPACE>.  If so, create a new namespace
        // for it.
        // ======================================================

        if ((wbem_wcsicmp(vClass.GetLPWSTR(), L"__NAMESPACE") == 0) ||
            (CRepository::InheritsFrom(m_pSession, m_pNsHandle, L"__NAMESPACE", vClass.GetLPWSTR()) == 0))
        {
            hRes = CreateNamespace(pNewInst);
            if (FAILED(hRes))
                return pSink->Return(hRes);
        }
        // Not a __NAMESPACE or derivative.
        // ================================

        else
        {
            // If here, the object didn't already exist in the repository, so we
            // can add it to the database.
            // ==================================================================

            // Check if this instance makes any sense to
            // hook callbacks.
            // =========================================

            hRes = DecorateObject(pNewInst);
            if (FAILED(hRes))
                return pSink->Return(hRes);
            IWbemClassObject* pInstObj = pNewInst;
            IWbemClassObject* pOldObj = 0;

            if (pHook)
            {
                // If there are hooks, try them and note whether callback is required.
                // ===================================================================
                hHookResult = pHook->PrePut(WBEM_FLAG_INST_PUT, lFlags, pCtx, 0,
                                            m_pThisNamespace, ClassNameStr, pNewInst
                                            );
            }

            if (FAILED(hHookResult))
            {
                return pSink->Return(hHookResult);
            }

            if (hHookResult == WBEM_S_POSTHOOK_WITH_BOTH)
            {
                CRepository::GetObject(m_pSession, m_pNsHandle, v.GetStr(), 0, &pOldObj);
            }

             // Actually create it in the database
            // ==================================

            hRes = CRepository::PutObject(m_pSession, m_pScopeHandle, IID_IWbemClassObject, LPVOID(pNewInst), DWORD(lFlags));

            if (pHook)
                pHook->PostPut(WBEM_FLAG_INST_PUT, hRes, pCtx, 0, m_pThisNamespace, ClassNameStr, pNewInst, (_IWmiObject *) pOldObj);

            delete pOldObj;

            if (FAILED(hRes))
            {
                return pSink->Return(hRes);
            }
        }
    }

    // If here, the object was already in the repository and requires updating.
    // ========================================================================

    else
    {
        if((lFlags & WBEM_MASK_CREATE_UPDATE) == WBEM_FLAG_CREATE_ONLY)
        {
            return pSink->Return(WBEM_E_ALREADY_EXISTS);
        }

        // Remove all the amended qualifiers
        // =================================

        if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS )
        {
            int nRes = SplitLocalized(pNewInst, (CWbemObject *) pExistingObject);
            if (FAILED(nRes))
            {
                return pSink->Return(nRes);
            }
        }

        // Check if this update makes any sense to the ESS
        // ===============================================

        hRes = DecorateObject(pNewInst);
        if (FAILED(hRes))
            return pSink->Return(hRes);
        IWbemClassObject* pInstObj = pNewInst;

        // Check pre-hook.
        // ===============

        if (pHook)
        {
            // If there are hooks, try them and note whether callback is required.
            // ===================================================================
             hHookResult = pHook->PrePut(WBEM_FLAG_INST_PUT, lFlags, pCtx, 0,
                                         m_pThisNamespace, ClassNameStr, pNewInst
                                        );
        }

        if (FAILED(hHookResult))
            return pSink->Return(hHookResult);

        // Actually create it in the database
        // ==================================

        hRes = CRepository::PutObject(m_pSession, m_pScopeHandle, IID_IWbemClassObject, LPVOID(pNewInst), DWORD(lFlags));

        // Post put.
        // =========

        if (pHook)
            pHook->PostPut(WBEM_FLAG_INST_PUT, hRes, pCtx, 0, m_pThisNamespace, ClassNameStr, pNewInst, (_IWmiObject *) pExistingObject);

        if (FAILED(hRes))
            return pSink->Return(hRes);
    }


    // Assign appropriate value to the path
    // ====================================

    LPWSTR wszPath = pNewInst->GetRelPath();
    BSTR str = SysAllocString(wszPath);
    delete [] wszPath;

    pSink->SetStatus(0, WBEM_S_NO_ERROR, str, NULL);
    SysFreeString(str);

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::CreateNamespace(CWbemInstance *pNewInst)
{
    //
    // internal interface throws
    //
    CVar vNsName;
    HRESULT hRes = pNewInst->GetProperty(L"Name", &vNsName);
    if (FAILED(hRes) || vNsName.IsNull())
    {
        return WBEM_E_INVALID_NAMESPACE;
    }

    // verify that this name is valid
    // ==============================

    if (!IsValidElementName(vNsName.GetLPWSTR(),g_PathLimit-NAMESPACE_ADJUSTMENT))
    {
        return WBEM_E_INVALID_NAMESPACE;
    }

    if (!Allowed(WBEM_FULL_WRITE_REP))
    {
        return WBEM_E_ACCESS_DENIED;
    }

    //Get a new session for transactioning purposes...
    IWmiDbSession *pSession = NULL;
    IWmiDbSessionEx *pSessionEx = NULL;

    hRes = CRepository::GetNewSession(&pSession);
    if (FAILED(hRes))
        return hRes;

    //Get an EX version that supports transactioning...
    pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pSessionEx);
    if (pSessionEx)
    {
        pSession->Release();
        pSession = pSessionEx;
    }
    CReleaseMe relMe1(pSession);

    //If we have transactionable session, use it!
    if (pSessionEx)
    {
        hRes = pSessionEx->BeginWriteTransaction(0);
        if (FAILED(hRes))
        {
            return hRes;
        }
    }

    try
    {
        // Build the new namespace name.
        // =============================

        // Create the namespace
        // =====================
        if (SUCCEEDED(hRes))
            hRes = CRepository::PutObject(pSession, m_pScopeHandle, IID_IWbemClassObject, LPVOID(pNewInst), 0);

        // Set the default instances.
        // ===============================

        CWbemNamespace* pNewNs = NULL;

        if (SUCCEEDED(hRes))
            pNewNs = CWbemNamespace::CreateInstance();

        if (SUCCEEDED(hRes) && pNewNs != NULL)
        {
            int iLen = 2;
            if(m_pThisNamespace)
                iLen += wcslen(m_pThisNamespace);   // SEC:REVIEWED 2002-03-22 : OK; null terminator is there by prior precondition
            if(vNsName.GetLPWSTR())
                iLen += wcslen(vNsName.GetLPWSTR());  // SEC:REVIEWED 2002-03-22 : OK; provably ok or we couldn't be here
            WCHAR * pTemp = new WCHAR[iLen];
            if(pTemp)
            {
                *pTemp = L'\0';
                if(m_pThisNamespace)
                {
                    StringCchCopyW(pTemp, iLen, m_pThisNamespace);
                    StringCchCatW(pTemp, iLen, L"\\");
                }
                if(vNsName.GetLPWSTR())
                    StringCchCatW(pTemp, iLen, vNsName.GetLPWSTR());

                //Initialize the namespace object
                hRes = pNewNs->Initialize(pTemp,GetUserName(), 0, 0, FALSE, TRUE,   // SEC:REVIEWED 2002-03-22 : OK
                                          NULL, 0xFFFFFFFF, TRUE, pSession);
                delete pTemp;
            }
            else
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }

            if(SUCCEEDED(hRes))
            {
                hRes = CRepository::EnsureNsSystemInstances(pSession, pNewNs->m_pNsHandle, pSession, m_pNsHandle);
            }

            if (SUCCEEDED(hRes))
                hRes = InitializeSD(pSession);

            pNewNs->Release();
        }
        else if (SUCCEEDED(hRes))
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
        }
    }
    catch (CX_MemoryException &)
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "Namespace Creation of <%S> caused a very critical error!\n", vNsName.GetLPWSTR()));
        hRes = WBEM_E_CRITICAL_ERROR;
    }
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Namespace Creation of <%S> caused an error <0x%X>!\n", vNsName.GetLPWSTR(), hRes));
        if (pSessionEx)
            pSessionEx->AbortTransaction(0);
    }
    else
    {
        hRes = DecorateObject(pNewInst);
        if (FAILED(hRes))
        {
            if (pSessionEx)
                   pSessionEx->AbortTransaction(0);
        }
        else
        {
            if (pSessionEx)
            {
                hRes = pSessionEx->CommitTransaction(0);
            }
        }
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::Exec_DeleteInstance
//
//  Actually deletes the instance from the database. No instance provider
//  support. Raises instance deletion event.
//
//  Parameters and return values are exacly the same as those for DeleteInstance
//  as described in help
//
//***************************************************************************
HRESULT CWbemNamespace::Exec_DeleteInstance(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    TIMETRACE(TimeTraces::DeleteInstance);
    return DeleteSingleInstance(wszObjectPath, lFlags, pCtx, pSink);
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::DeleteSingleInstance(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    HRESULT hRes;
    int nRes;

    COperationError OpInfo(pSink, L"DeleteInstance", wszObjectPath);
    if ( !OpInfo.IsOk() ) return WBEM_E_OUT_OF_MEMORY;


    // Parse the object path to get the class involved.
    // ================================================
    ParsedObjectPath* pOutput = 0;
    CObjectPathParser p;
    int nStatus = p.Parse(wszObjectPath,  &pOutput);
    OnDeleteObj<ParsedObjectPath*,CObjectPathParser,
                         void (CObjectPathParser:: *)(ParsedObjectPath *pOutput),
                         &CObjectPathParser::Free> FreeMe(&p,pOutput);

    if (nStatus != 0 || !pOutput->IsInstance())
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
    }

    // Exception for __WinMgmtIdentification
    if (!wbem_wcsicmp(pOutput->m_pClass, L"__CIMOMIdentification") ||
        !wbem_wcsicmp(pOutput->m_pClass, L"__SystemSecurity") ||
        !wbem_wcsicmp(pOutput->m_pClass, L"__ADAPStatus" ) )
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Dont allow deletion on the __thisnamespace instance
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (wbem_wcsicmp(pOutput->m_pClass, L"__thisnamespace") == 0 )
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OPERATION);
    }


    // Special case for  the old security classes
    // ==========================================

    if (wbem_wcsicmp(pOutput->m_pClass, L"__NTLMUser") == 0 ||
        wbem_wcsicmp(pOutput->m_pClass, L"__NTLMGroup") == 0)
    {
        if (!Allowed(WRITE_DAC))
        {      
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
        }
        if((lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
        {
            return DeleteSecurityClassInstances(pOutput, pSink, pCtx,lFlags);
        }
    }

    // As a special case, see if the object is
    // of class <__NAMESPACE>.  If so, (TEMP) disallow deletion.
    // =========================================================

    WString wsNamespaceName;

    if (wbem_wcsicmp(pOutput->m_pClass, L"__NAMESPACE") == 0 ||
        CRepository::InheritsFrom(m_pSession, m_pScopeHandle, L"__NAMESPACE", pOutput->m_pClass) == 0
        )

    {
        if (!Allowed(WBEM_FULL_WRITE_REP))
        {
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
        }

        if (pOutput->m_dwNumKeys != 1)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        KeyRef* pKey = pOutput->m_paKeys[0];
        if (pKey->m_pName != NULL && wbem_wcsicmp(pKey->m_pName, L"name"))
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        if (V_VT(&pKey->m_vValue) != VT_BSTR)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
        }

        // Prevent deletion of standard namespaces.
        // ========================================

        if (wbem_wcsicmp(m_pThisNamespace, L"ROOT") == 0)
        {
            BSTR pNs = V_BSTR(&pKey->m_vValue);
            if (!pNs)
            {
                return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
            }
            if (wbem_wcsicmp(pNs, L"SECURITY") == 0)
            {
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
            if (wbem_wcsicmp(pNs, L"DEFAULT") == 0)
            {
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
        }

        // Set up hook.
        // ============

        _IWmiCoreWriteHook *pHook = 0;
        HRESULT hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
        CReleaseMe _(pHook);
        HRESULT hHookResult = 0;
        LPWSTR pszClassName = 0;
        IWbemPath *pPath = 0;

        CVectorDeleteMe<WCHAR> vdmClassName(&pszClassName);

        if (pHook)
        {
            // Parse the object path.
            // ======================

            hRes = m_pCoreSvc->CreatePathParser(0, &pPath);
            if (FAILED(hRes))
            {
                return OpInfo.ErrorOccurred(hRes);
            }

            CReleaseMe _3Path(pPath);

            hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
            if (FAILED(hRes))
            {
                return OpInfo.ErrorOccurred(hRes);
            }

            ULONG uBuf = 0;
            hRes = pPath->GetClassName(&uBuf, 0);
            if (FAILED(hRes))
            {
                return OpInfo.ErrorOccurred(hRes);
            }

            pszClassName = new wchar_t[uBuf+1];
            if (pszClassName == 0)
            {
                return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
            }

            hRes = pPath->GetClassName(&uBuf, pszClassName);
            if (FAILED(hRes))
            {
                return OpInfo.ErrorOccurred(hRes);
            }

            // If there are hooks, try them and note whether callback is required.
            // ===================================================================
            hHookResult = pHook->PreDelete(WBEM_FLAG_INST_DELETE, lFlags, pCtx, pPath,
                                       m_pThisNamespace, pszClassName);

            if (FAILED(hHookResult))
            {
                return OpInfo.ErrorOccurred(hHookResult);
            }

            pPath->AddRef();
        }

        CReleaseMe _2Path(pPath);

        // Ensure the object can be reached so that we can delete it.
        // ==========================================================

        IWbemClassObject *pExistingObject = 0;
        hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, wszObjectPath, 0, &pExistingObject);

        if (FAILED(hRes))
        {
            return OpInfo.ErrorOccurred(hRes);
        }

        CReleaseMe _2(pExistingObject);

        if (hRes == WBEM_S_NO_ERROR)    // new test
        {
            // Check if we may
            // ===============

            if (!Allowed(WBEM_FULL_WRITE_REP))
            {
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }

            // Go ahead and try the deletion.
            // ==============================

            WString sNamespace = "__Namespace='";
            sNamespace += V_BSTR(&pKey->m_vValue);
            sNamespace += "'";

            hRes = CRepository::DeleteByPath(m_pSession, m_pScopeHandle, LPWSTR(sNamespace), 0);

            // Call post hook.
            // ===============
            if (pHook)
                pHook->PostDelete(WBEM_FLAG_INST_DELETE, hRes, pCtx, pPath,
                    m_pThisNamespace, pszClassName, (_IWmiObject *) pExistingObject);

            // Decide what to do if things didn't work out.
            // ============================================

            if (FAILED(hRes))
            {
                return OpInfo.ErrorOccurred(hRes);
            }
        }
        else
        {
            return OpInfo.ErrorOccurred(hRes);
        }

        wsNamespaceName = V_BSTR(&pKey->m_vValue);

        return OpInfo.ErrorOccurred(WBEM_S_NO_ERROR);
    }

    // See if the class is dynamic
    // ===========================

    CWbemObject *pClassDef = 0;
    IWbemClassObject* pErrorObj = NULL;
    IWbemClassObject* pClassObj = NULL;

    HRESULT hres = Exec_GetObjectByPath(pOutput->m_pClass, 0, 
                                                              pCtx,&pClassObj, &pErrorObj);
    CReleaseMe rmErrObj(pErrorObj);
    CReleaseMe rmClsDef(pClassObj);

    if(hres == WBEM_E_NOT_FOUND) hres = WBEM_E_INVALID_CLASS;

    if(FAILED(hres))
    {
        OpInfo.ErrorOccurred(hres, pErrorObj);
        return WBEM_S_NO_ERROR;
    }
    pClassDef = (CWbemObject*)pClassObj;

    CVar vDynFlag;
    hres = pClassDef->GetQualifier(L"Dynamic", &vDynFlag);
    if (SUCCEEDED(hres) && vDynFlag.GetType() == VT_BOOL && vDynFlag.GetBool())
    {
        // Get the provider name.
        CVar vProv;
        hres = pClassDef->GetQualifier(L"Provider", &vProv);
        if (FAILED(hres) || vProv.GetType() != VT_BSTR)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);
        }

        if (!Allowed(WBEM_WRITE_PROVIDER))
            return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

        // Access the provider cache.
        // ==========================

        IWbemServices *pProv = 0;
        HRESULT hRes;
        if(m_pProvFact == NULL)
            return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);

        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) );

        hRes = m_pProvFact->GetProvider(t_InternalContext ,
                                                            0,                  // lFlags
                                                            pCtx,
                                                            0,
                                                            m_wszUserName,
                                                            m_wsLocale,
                                                            0,                      // IWbemPath pointer
                                                            vProv,     // Provider
                                                            IID_IWbemServices,
                                                            (LPVOID *) &pProv);


        if (FAILED(hRes))
        {
            return OpInfo.ErrorOccurred(hRes);
        }

        CReleaseMe rmProv(pProv);

        hRes = pProv->DeleteInstanceAsync( wszObjectPath,
                                                                lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                                pCtx,
                                                                OpInfo.GetSink());

        return WBEM_S_NO_ERROR;
    }

    // The class is not dynamically provided.
    // ======================================

    // Only administrators can change provider registration
    // RAID# 566241
    // ==================================

    if(pClassDef->InheritsFrom(L"__Provider") == S_OK || pClassDef->InheritsFrom(L"__ProviderRegistration") == S_OK)
    {
        HANDLE hAccess;
        hres = GetAccessToken (hAccess);
        if ( FAILED (hres) )
        {
            if ( hres != 0x80041007 )
            {
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
        }
        else
        {
            if ( !IsAdmin(hAccess))
            {
                CloseHandle ( hAccess );
                return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);
            }
            CloseHandle ( hAccess );
        }
    }

    bool derivedFromSys = false;
    HRESULT hr = IsDerivedFromSystem(*pClassDef, &derivedFromSys); 	   	
    if (FAILED(hr)) return pSink->Return(hr);

    if (derivedFromSys)
    {
    	if (!Allowed(WBEM_FULL_WRITE_REP))
	return pSink->Return(WBEM_E_ACCESS_DENIED);
    }
    else if (!Allowed(WBEM_PARTIAL_WRITE_REP))
    {
     	return pSink->Return(WBEM_E_ACCESS_DENIED);
    }

    rmClsDef.release();


    // If here, it is a normal object.   First retrieve
    // the object for the event subsystem, then go ahead and delete it.
    // ================================================================

    // Prehook.
    // ========

    _IWmiCoreWriteHook *pHook = 0;
    hRes = m_pCoreSvc->NewPerTaskHook(&pHook);
    if (FAILED(hRes)) return OpInfo.ErrorOccurred(hRes);
    CReleaseMe rmHook(pHook);
    
    HRESULT hHookResult = 0;
    LPWSTR pszClassName = 0;
    IWbemPath *pPath = 0;
    CReleaseMeRef<IWbemPath*> rmPath(pPath);
    
    CVectorDeleteMe<WCHAR> vdmClassName(&pszClassName);

    if (pHook)
    {
        // Parse the object path.
        hRes = m_pCoreSvc->CreatePathParser(0, &pPath);
        if (FAILED(hRes))  return OpInfo.ErrorOccurred(hRes);

        hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
        if (FAILED(hRes))  return OpInfo.ErrorOccurred(hRes);

        ULONG uBuf = 0;
        hRes = pPath->GetClassName(&uBuf, 0);
        if (FAILED(hRes)) return OpInfo.ErrorOccurred(hRes);


        pszClassName = new wchar_t[uBuf+1];
        if (pszClassName == 0) return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);


        hRes = pPath->GetClassName(&uBuf, pszClassName);
        if (FAILED(hRes)) return OpInfo.ErrorOccurred(hRes);

        // If there are hooks, try them and note whether callback is required.
        // ===================================================================
        hHookResult = pHook->PreDelete(WBEM_FLAG_INST_DELETE, lFlags, pCtx, pPath,m_pThisNamespace, pszClassName);

        if (FAILED(hHookResult))  return OpInfo.ErrorOccurred(hHookResult);

    }

    // If anybody wants to see the old object, get it.
    IWbemClassObject *pDoomedInstance = NULL ;
    if (hHookResult == WBEM_S_POSTHOOK_WITH_OLD)
    {
        hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, wszObjectPath,0, &pDoomedInstance);    
        if (FAILED(hRes)) return OpInfo.ErrorOccurred(hRes);        
    }
    CReleaseMe _Doomed (pDoomedInstance) ;

    hRes = CRepository::DeleteByPath(m_pSession, m_pScopeHandle, wszObjectPath, 0);  // new

    // Posthook.
    if (pHook)
        pHook->PostDelete(WBEM_FLAG_INST_DELETE, hRes, pCtx, pPath,
            m_pThisNamespace, pszClassName, (_IWmiObject *) pDoomedInstance);

    if ( FAILED (hRes) ) return OpInfo.ErrorOccurred(hRes);
    
    return OpInfo.ErrorOccurred(WBEM_NO_ERROR);
}


//***************************************************************************
//
//  CWbemNamespace::Exec_CreateInstanceEnum
//
//  Actually creates the enumerator for all instances of a given class,
//  optionally recursively. Interacts with instance providers. Class provider
//  interaction works, but is sparsely tested.
//
//  Parameters and return values are exacly the same as those for
//  CreateInstanceEnum as described in help
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_CreateInstanceEnum(
    LPWSTR wszClass,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    TIMETRACE(TimeTraces::CreateInstanceEnum);

    COperationError OpInfo(pSink, L"CreateInstanceEnum", wszClass);
    if ( !OpInfo.IsOk() )  return  WBEM_E_OUT_OF_MEMORY;

    // Make sure the name of the class is a name
    // =========================================

    if(wcschr(wszClass, L':'))
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_CLASS);

    // Create equivalent query
    // =======================

    WString wsQuery;
    wsQuery += L"select * from ";
    wsQuery += wszClass;

    if((lFlags & WBEM_MASK_DEPTH) == WBEM_FLAG_SHALLOW)
    {
        wsQuery += L" where __CLASS = \"";
        wsQuery += wszClass;
        wsQuery += L"\"";
    }

    CErrorChangingSink* pErrSink = new CErrorChangingSink(OpInfo.GetSink(),WBEM_E_INVALID_QUERY, WBEM_E_INVALID_CLASS);
    if(pErrSink == NULL) return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    CReleaseMe rmErrorChange(pErrSink);

    // Execute it
    CQueryEngine::ExecQuery(this,L"WQL",(LPWSTR)wsQuery,lFlags,pCtx,pErrSink);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

/*
void CWbemNamespace::SetUserName(LPWSTR wName)
{
    try
    {
        delete m_wszUserName;
        m_wszUserName = (wName) ? Macro_CloneLPWSTR(wName):NULL;
    }
    catch(...)
    {
        ExceptionCounter c;
        m_wszUserName = 0;
    }
}
*/

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::GetObjectByFullPath(
    READONLY LPWSTR wszObjectPath,
    IWbemPath * pOutput,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{

    // Get the namespace part of the path

    DWORD dwSizeNamespace = 0;
    HRESULT hres = pOutput->GetText(WBEMPATH_GET_NAMESPACE_ONLY, &dwSizeNamespace, NULL);
    if(FAILED(hres))
        return hres;

    LPWSTR wszNewNamespace = new WCHAR[dwSizeNamespace];
    if(wszNewNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<WCHAR> dm1(wszNewNamespace);

    hres = pOutput->GetText(WBEMPATH_GET_NAMESPACE_ONLY, &dwSizeNamespace, wszNewNamespace);
    if(FAILED(hres))
        return hres;

    // Get the relative part of the path

    DWORD dwSizeRelative = 0;
    hres = pOutput->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSizeRelative, NULL);
    if(FAILED(hres))
        return hres;

    LPWSTR wszRelativePath = new WCHAR[dwSizeRelative];
    if(wszRelativePath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<WCHAR> dm2(wszRelativePath);

    hres = pOutput->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSizeRelative, wszRelativePath);
    if(FAILED(hres))
        return hres;

    if (pOutput->IsLocal(ConfigMgr::GetMachineName()))
    {
        // In win2k, we allowed \\.\root\default:whatever, but not root\default:whatever
        // So, the following additional test was added

        ULONGLONG uFlags;
        hres = pOutput->GetInfo(0, &uFlags);
        if(SUCCEEDED(hres))
        {
            if((uFlags & WBEMPATH_INFO_PATH_HAD_SERVER) == 0)
                return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);
        }

        bool bAlreadyAuthenticated = (m_dwSecurityFlags & SecFlagWin9XLocal) != 0;
        CWbemNamespace* pNewLocal = CWbemNamespace::CreateInstance();
        if(pNewLocal == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        hres = pNewLocal->Initialize(wszNewNamespace, m_wszUserName,
                                        (bAlreadyAuthenticated) ? m_dwSecurityFlags : 0,
                                        (bAlreadyAuthenticated) ? m_dwPermission : 0,
                                         m_bForClient, false,
                                         m_pszClientMachineName,
                                         m_dwClientProcessID,
                                         FALSE,NULL);
        if (FAILED(hres))
        {
            pNewLocal->Release();
            return hres;
        }
        else if (pNewLocal->GetStatus())
        {
            hres = pNewLocal->GetStatus();
            pNewLocal->Release();
            return hres;
        }

        // check for security if this isnt the local 9x case

        if(!bAlreadyAuthenticated)
        {
            DWORD dwAccess = pNewLocal->GetUserAccess();
            if((dwAccess  & WBEM_ENABLE) == 0)
            {
                delete pNewLocal;
                return WBEM_E_ACCESS_DENIED;
            }
            else
               pNewLocal->SetPermissions(dwAccess);
        }

        if(pNewLocal->GetStatus())
        {
            hres = pNewLocal->GetStatus();
            delete pNewLocal;
            return pSink->Return(hres);
        }

#if 0
        pNewLocal->AddRef();
#endif
        pNewLocal->SetLocale(GetLocale());

        hres = pNewLocal->Exec_GetObject(wszRelativePath,
            lFlags, pCtx, pSink);
        pNewLocal->Release();
        return hres;
    }
    else
    {
        // Disable remote retrieval for V1
        // ===============================

        return pSink->Return(WBEM_E_NOT_SUPPORTED);
    }
}

//***************************************************************************
//
//  CWbemNamespace::Exec_GetObjectByPath
//
//  Actually retrieves an object (a class or an instance) from the database.
//  Interacts properly with class and instance providers and uses property
//  providers for post-processing (See GetOrPutDynProps).
//
//  Parameters and return values are exacly the same as those for GetObject
//  as described in help
//
//***************************************************************************
HRESULT CWbemNamespace::Exec_GetObjectByPath(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IWbemClassObject** ppObj,
    NEWOBJECT IWbemClassObject** ppErrorObj
    )
{
    TIMETRACE(TimeTraces::GetObjectByPath);
    HRESULT hres = WBEM_S_NO_ERROR;

    CSynchronousSink* pSyncSink = CSynchronousSink::Create();
    if(pSyncSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    IWbemClassObject* pErrorObj = NULL;
    IWbemClassObject* pObj = NULL;

    hres = Exec_GetObject(wszObjectPath, lFlags, pCtx, pSyncSink);
    if (SUCCEEDED(hres))
    {
        pSyncSink->Block();
        pSyncSink->GetStatus(&hres, NULL, &pErrorObj);

        if(SUCCEEDED(hres))
        {
            if(pSyncSink->GetObjects().GetSize() < 1)
            {
                pSyncSink->Release();
                ERRORTRACE((LOG_WBEMCORE, "Sync sink returned success with no objects!\n"));
                return WBEM_E_CRITICAL_ERROR;
            }
            pObj = pSyncSink->GetObjects()[0];
            pObj->AddRef();
        }
    }

    pSyncSink->Release();

    if(ppObj) *ppObj = pObj;
    else if(pObj) pObj->Release();

    if(ppErrorObj) *ppErrorObj = pErrorObj;
    else if(pErrorObj) pErrorObj->Release();

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_GetObject(
    READONLY LPWSTR wszObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink)
{

    TIMETRACE(TimeTraces::GetObject);
    
    // Create a sink that will merge the localized qualifiers
    // over the top of the default qualifiers (if specified)
    // ======================================================

    CLocaleMergingSink *pLocaleSink = NULL;

    HRESULT hres = WBEM_S_NO_ERROR;
    if (wszObjectPath && wszObjectPath[0] && wszObjectPath[0] != L'_')   // SEC:REVIEWED 2002-03-22 : OK; prior testing ensures that this is valid
    {
        if ((lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS))
        {
            pLocaleSink = new CLocaleMergingSink(pSink, m_wsLocale, m_pThisNamespace);
            if(pLocaleSink == NULL)
                return pSink->Return(WBEM_E_OUT_OF_MEMORY);
            else
            {
                pLocaleSink->AddRef();
                pSink = pLocaleSink;
            }
        }
    }
    CReleaseMe rm(pLocaleSink);

    COperationError OpInfo(pSink, L"GetObject", wszObjectPath?wszObjectPath:L"");
    if (!OpInfo.IsOk())   return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    // Check if the path is NULL --- that's valid
    // ==========================================
    if (wszObjectPath == NULL || wszObjectPath[0] == 0)   // SEC:REVIEWED 2002-03-22 : OK; null terminator provably exists
    {
        //
        // BUGBUG consider using CoCreateInstance instead of new CWbemClass
        //
        CWbemClass * pNewObj = new CWbemClass;
        if(NULL == pNewObj) return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        CReleaseMe rm_((IWbemClassObject*)pNewObj);
        
        hres = pNewObj->InitEmpty(0);
        if (FAILED(hres)) return OpInfo.ErrorOccurred(hres);

        IWbemClassObject* pObj = pNewObj;
        pSink->Indicate(1, &pObj);
        return OpInfo.ErrorOccurred(WBEM_NO_ERROR);
    }

    // here we are sure the path is not null
    if (wcslen_max(wszObjectPath,g_PathLimit) > g_PathLimit)
        return OpInfo.ErrorOccurred(WBEM_E_QUOTA_VIOLATION);


    // Parse the object path to get the class involved.
    // ================================================

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    if (pPath == 0)
    {
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    }

    CReleaseMe _1(pPath);
    hres = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
    if (FAILED(hres))
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
    }

    ULONGLONG uResponse;
    hres = pPath->GetInfo(0, &uResponse);
    if (FAILED(hres) || (
        (uResponse & WBEMPATH_INFO_IS_INST_REF) == 0 &&
        (uResponse & WBEMPATH_INFO_IS_CLASS_REF) == 0))
    {
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);
    }


    if (!pPath->IsRelative(ConfigMgr::GetMachineName(), m_pThisNamespace))
    {
        // This path points to another namespace. Delegate to it instead
        // =============================================================

        hres = GetObjectByFullPath(wszObjectPath, pPath,
                lFlags, pCtx, OpInfo.GetSink());

        return OpInfo.ErrorOccurred(hres);
    }

    BOOL bInstance = (uResponse & WBEMPATH_INFO_IS_INST_REF);

    // The repository code can't handle paths like root\default:classname
    // So if there is a colon, pass a pointer to one past it

    WCHAR * pRelativePath = wszObjectPath;
    for(WCHAR * pTest = wszObjectPath;*pTest;pTest++)
    {
        if(*pTest == L':')
        {
            // In win2k, we allowed \\.\root\default:whatever, but not root\default:whatever
            // So, the following additional test was added

            if((uResponse & WBEMPATH_INFO_PATH_HAD_SERVER) == 0)
                return OpInfo.ErrorOccurred(WBEM_E_INVALID_OBJECT_PATH);

            pRelativePath = pTest+1;
            break;
        }
        else if (*pTest==L'=')
            break;      //got to key part...
    }

    if (bInstance)
    {
        CFinalizingSink* pFinalSink = new CFinalizingSink(this, OpInfo.GetSink());
        if(pFinalSink == NULL)  return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        pFinalSink->AddRef();
        CReleaseMe rmFinal(pFinalSink);

        hres = Exec_GetInstance(pRelativePath, pPath, lFlags, pCtx, pFinalSink);
        if (FAILED(hres))  return OpInfo.ErrorOccurred(hres);
    }
    else
    {
        hres = Exec_GetClass(pRelativePath, lFlags, pCtx, OpInfo.GetSink());
        if (FAILED(hres))  return OpInfo.ErrorOccurred(hres);
    }

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_GetInstance(LPCWSTR wszObjectPath,
        IWbemPath* pParsedPath, long lFlags, IWbemContext* pCtx,
        CBasicObjectSink* pSink)
{
    if (pParsedPath->IsSameClassName(L"__NTLMUser") ||
        pParsedPath->IsSameClassName(L"__NTLMGroup"))
    {
        if((lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
        {

            ParsedObjectPath* pOutput = 0;         // todo, convert to use new parser
            CObjectPathParser p;
            int nStatus = p.Parse(wszObjectPath,  &pOutput);
            if (nStatus != 0)
            {
                p.Free(pOutput);
                return WBEM_E_INVALID_OBJECT_PATH;
            }

            HRESULT hr = GetSecurityClassInstances(pOutput, pSink, pCtx,lFlags);
            p.Free(pOutput);
            return hr;
        }
    }

    // Try static database first
    // =========================

    if((lFlags & WBEM_FLAG_NO_STATIC) == 0)
    {
        IWbemClassObject *pObj = 0;
        HRESULT hRes = CRepository::GetObject(m_pSession, m_pScopeHandle, wszObjectPath, lFlags, &pObj);

        if (SUCCEEDED(hRes))
        {
            hRes = WBEM_S_NO_ERROR;
            pSink->Add(pObj);
            pObj->Release();
            return pSink->Return(hRes);
        }

    }

    // Try dynamic
    // ===========

    return DynAux_GetInstance((LPWSTR)wszObjectPath, lFlags, pCtx, pSink);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_GetClass(
    LPCWSTR pszClassName,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{
    HRESULT hRes = 0;
    IWbemClassObject* pErrorObj = 0;
    IWbemServices *pClassProv = 0;
    CSynchronousSink* pSyncSink = 0;
    BSTR bstrClass = 0;
    IWbemClassObject* pResultObj = 0;

    if (pszClassName == 0 || pSink == 0)
        return pSink->Return(WBEM_E_INVALID_PARAMETER);


    if (!m_bRepositOnly && m_pProvFact)
    {
        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                     // IWbemPath pointer
                    0,
                    IID_IWbemServices,
                    (LPVOID *) &pClassProv
                    );

        if (FAILED(hRes))
            return pSink->Return(hRes);
    }

    CReleaseMe _1(pClassProv);

    // First, try repository.  If it's there, end of story.
    // ====================================================

    if ((lFlags & WBEM_FLAG_NO_STATIC) == 0)
    {
        if (m_pNsHandle)
        {
            hRes = CRepository::GetObject(
                m_pSession,
                m_pNsHandle,
                pszClassName,
                0,
                &pResultObj
                );
        }
        else        // Something drastically wrong
        {
            hRes = WBEM_E_CRITICAL_ERROR;
            return pSink->Return(hRes);
        }

        if (SUCCEEDED(hRes) && pResultObj)
        {
            pSink->Add(pResultObj);
            pResultObj->Release();
            return pSink->Return(hRes);
        }
    }

    // If we are in repository-only mode, we don't bother
    // with dynamic classes.
    // ===================================================

    if (m_bRepositOnly || m_pProvFact == NULL)
        return pSink->Return(WBEM_E_NOT_FOUND);

    // If here, try the dynamic class providers.
    // =========================================
    // Build up a synchronous sink to receive the class.
    // =================================================

    pSyncSink = CSynchronousSink::Create();
    if (pSyncSink == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pSyncSink->AddRef();
    CReleaseMe _2(pSyncSink);

    // Try to get it.
    // ==============


    bstrClass = SysAllocString(pszClassName);
    if (bstrClass == 0) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CSysFreeMe sfm(bstrClass);

    
    {
        CDecoratingSink * pDecore = new CDecoratingSink(pSyncSink, this);
        if(pDecore == NULL) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pDecore->AddRef();
        CReleaseMe rmDecor(pDecore);
        hRes = pClassProv->GetObjectAsync(bstrClass, lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pDecore);
    }

    if (FAILED(hRes))
        return pSink->Return(hRes);

    pSyncSink->Block();
    pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);

    if (FAILED(hRes))
    {
        pSink->Return(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    // Otherwise, somebody claimed to have supplied it. Do we really believe them?  No choice.
    // =======================================================================================

    if(pSyncSink->GetObjects().GetSize() < 1)
    {
        ERRORTRACE((LOG_WBEMCORE, "Sync sink returned success with no objects!\n"));
        return pSink->Return(WBEM_E_CRITICAL_ERROR);
    }
    pResultObj = pSyncSink->GetObjects()[0];
    pSink->Add(pResultObj);
    pSink->Return(WBEM_S_NO_ERROR);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::ExecNotificationQuery(
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext* pCtx,
    IEnumWbemClassObject** ppEnum
    )
{
    try 
    {    
        HRESULT hRes = CheckNs();
        if (FAILED(hRes))
            return hRes;

        DEBUGTRACE((LOG_WBEMCORE,
            "CALL CWbemNamespace::ExecNotificationQuery\n"
            "   BSTR QueryLanguage = %S\n"
            "   BSTR Query = %S\n"
            "   lFlags = 0x%X\n"
            "   IEnumWbemClassObject **pEnum = 0x%X\n",
            QueryLanguage,
            Query,
            lFlags,
            ppEnum
            ));

        // Validate parameters
        // ===================

        if (ppEnum == NULL)
            return WBEM_E_INVALID_PARAMETER;
        *ppEnum = NULL;

        if ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)
            return WBEM_E_INVALID_PARAMETER;

        if ((lFlags & WBEM_FLAG_FORWARD_ONLY) == 0)
            return WBEM_E_INVALID_PARAMETER;

        if (lFlags
            & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
            & ~WBEM_RETURN_IMMEDIATELY
            & ~WBEM_FLAG_FORWARD_ONLY
        #ifdef _WBEM_WHISTLER_UNCUT
            & ~WBEM_FLAG_MONITOR
        #endif
            )
            return WBEM_E_INVALID_PARAMETER;

        // Create Finalizer.
        // =================

        _IWmiFinalizer *pFnz = 0;
        hRes = CreateSyncFinalizer(pCtx, &pFnz);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pFnz);

        ULONG uTaskType = WMICORE_TASK_EXEC_NOTIFICATION_QUERY;
        if (lFlags & WBEM_RETURN_IMMEDIATELY)
            uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
        else
            uTaskType |= WMICORE_TASK_TYPE_SYNC;

        // Do the work.
        // ============

        hRes = _ExecNotificationQueryAsync(uTaskType, pFnz, 0, QueryLanguage, Query,
                        lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                        pCtx, NULL);

        if (FAILED(hRes))
        {
            return hRes;
        }

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
            pFnz->GetOperationResult(0, INFINITE, &hRes);

        if (SUCCEEDED(hRes))
        {
            IEnumWbemClassObject* pEnum = NULL;
            hRes = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
            if (FAILED(hRes))
                return hRes;
            CReleaseMe _2(pEnum);

            if (SUCCEEDED(hRes))
            {
                *ppEnum = pEnum;
                pEnum->AddRef();    // Counteract CReleaseMe
            }
        }

        return hRes;
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }
}


//
//
// this function can throw or return
//
//////////////////////////////////////////////////////////
HRESULT CWbemNamespace::_ExecNotificationQueryAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    IN const BSTR strQueryLanguage,
    IN const BSTR strQuery,
    IN long lFlags,
    IN IWbemContext __RPC_FAR *pCtx,
    IN IWbemObjectSink __RPC_FAR *pHandler
    )
{

    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::_ExecNotificationQueryAsync\n"
        "   BSTR QueryLanguage = %S\n"
        "   BSTR Query = %S\n"
        "   lFlags = 0x%X\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strQueryLanguage,
        strQuery,
        lFlags,
        pHandler));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;
    
    if (strQueryLanguage == 0 || strQuery == 0 || strQueryLanguage[0] == 0) 
        return WBEM_E_INVALID_PARAMETER;
    
    if (strQuery[0] == 0 )
        return WBEM_E_UNPARSABLE_QUERY;

   if (wcslen_max(strQuery,g_QueryLimit) > g_QueryLimit) return WBEM_E_QUOTA_VIOLATION;            

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS )
        return WBEM_E_INVALID_PARAMETER;

    m_bForClient=FALSE;     // Forces a cheap fast-track

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add the request to the queue.
    // =============================

    IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
    CReleaseMe _3(pEss);
    if (pEss == 0)
    {
        return WBEM_E_NOT_SUPPORTED;  // ESS must be disabled
    }

    HANDLE hEssValidate = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (NULL == hEssValidate) return WBEM_E_OUT_OF_MEMORY;
    CCloseMe cm(hEssValidate);



    HRESULT hResEssCheck = 0;
    wmilib::auto_ptr<CAsyncReq_ExecNotificationQueryAsync> pReq;
    pReq.reset(new CAsyncReq_ExecNotificationQueryAsync(this, pEss, strQueryLanguage,
                        strQuery, lFlags, pPseudoSink, pCtx,
                        &hResEssCheck, hEssValidate));

    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if ( NULL == pReq->GetContext() )  return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))  return hRes;

    _1.release();
     // Enqueue the request.
    hRes = ConfigMgr::EnqueueRequest(pReq.get());

    if (FAILED(hRes))
    {
        pFnz->CancelTask (0);      
        return hRes;
    }

    pReq.release(); // queue took ownership

    // In this case, we have to wait long enough for ESS to accept the task.
    WaitForSingleObject(hEssValidate, INFINITE);

    // If ESS failed, we should cancel the task
    // ========================================
    if ( FAILED (hResEssCheck) )
    {
        pFnz->CancelTask(0);
    }
    return hResEssCheck;
}


//***************************************************************************
//
//***************************************************************************
// done

HRESULT CWbemNamespace::ExecNotificationQueryAsync(
    IN const BSTR strQueryLanguage,
    IN const BSTR strQuery,
    IN long lFlags,
    IN IWbemContext __RPC_FAR *pCtx,
    IN IWbemObjectSink __RPC_FAR *pHandler
    )
{
    try
    {
        return _ExecNotificationQueryAsync(WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_EXEC_NOTIFICATION_QUERY,
                                                             0, 0,
                                                             strQueryLanguage, strQuery, lFlags, pCtx, pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;    
    }
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::GetImplementationClass(
    IWbemClassObject * pTestClass,
    LPWSTR wszMethodName,
    IWbemContext* pCtx,
    IWbemClassObject ** ppClassObj
    )
{
    try
    {
        // If the method is disabled, or implemented in this class, we are done!
        // =====================================================================

        CVar Var;
        CWbemClass * pClassDef = (CWbemClass *)pTestClass;

        HRESULT hres = pClassDef->GetMethodQualifier(wszMethodName, L"DISABLED", &Var);
        if(hres == S_OK && Var.GetBool() == VARIANT_TRUE)
            return WBEM_E_METHOD_DISABLED;

        hres = pClassDef->GetMethodQualifier(wszMethodName, L"IMPLEMENTED", &Var);
        if(hres == S_OK && Var.GetBool() == VARIANT_TRUE)
        {
            // The test class is correct, return it

            pTestClass->AddRef();
            *ppClassObj = pTestClass;
            return S_OK;
        }
        // Not done, get the name of the parent class.

        SCODE hRes = pClassDef->GetSystemPropertyByName(L"__superclass", &Var);
        if(hRes != S_OK)
            return WBEM_E_CRITICAL_ERROR;

        if(Var.GetType() != VT_BSTR)
            return WBEM_E_METHOD_NOT_IMPLEMENTED; // no superclass --- no implementation

        BSTR bstrParent = Var.GetBSTR();
        if(bstrParent == NULL)
            return WBEM_E_CRITICAL_ERROR; // NULL, but not VT_NULL

        if(wcslen(bstrParent) < 1) 
        {
            SysFreeString(bstrParent);
            return WBEM_E_FAILED; // empty parent name????
        }

        IWbemClassObject * pParent = NULL;
        hres = Exec_GetObjectByPath(bstrParent, 0, pCtx, &pParent, NULL);
        SysFreeString(bstrParent);
        if(FAILED(hres))
            return WBEM_E_FAILED; // class provider failure or weird interaction

        hRes = GetImplementationClass(pParent, wszMethodName, pCtx, ppClassObj);
        pParent->Release();
        return hRes;

    }
    catch(CX_Exception &)
    {
        return WBEM_E_FAILED;
    }
}

//***************************************************************************
//
//  CWbemNamespace::Exec_ExecMethod
//
//  Executes a method.  If the method is not tagged by the [bypass_getobject]
//  qualifier, the method is passed directly to the method provider.  Otherwise,
//  a GetObject call is done first to ensure the instance is valid.
//
//***************************************************************************
//
HRESULT CWbemNamespace::Exec_ExecMethod(
    LPWSTR wszObjectPath,
    LPWSTR wszMethodName,
    long lFlags,
    IWbemClassObject *pInParams,
    IWbemContext *pCtx,
    CBasicObjectSink* pSink
    )
{
    TIMETRACE(TimeTraces::ExecMethod);
    // Lotsa useful variables.
    // =======================

    HRESULT hRes;
    IWbemClassObject* pClassDef = NULL;
    IWbemClassObject* pImplementationClass = NULL;
    IWbemPath *pPath = 0;
    IWbemQualifierSet *pQSet = 0;
    IWbemClassObject* pErrorObj = NULL;
    BOOL bPathIsToClassObject = FALSE;
    LPWSTR pszClassName = 0;
    ULONGLONG uInf = 0;

    // Set up a sink error object and check it.
    COperationError OpInfo(pSink, L"ExecMethod", wszObjectPath);
    if ( !OpInfo.IsOk() ) return WBEM_E_OUT_OF_MEMORY;

    // Parse the path to the object.
    // =============================

    // Backwards compatibility - parsing a NULL path returns WBEM_E_INVALID_OBJECT_PATH
    if ( NULL == wszObjectPath || NULL == *wszObjectPath )
    {
        return OpInfo.ErrorOccurred( WBEM_E_INVALID_METHOD );
    }

    hRes = m_pCoreSvc->CreatePathParser(0, &pPath);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);
    CReleaseMe _1(pPath);

    hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, wszObjectPath);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    ULONG uBuf = 0;
    hRes = pPath->GetClassName(&uBuf, 0);      // Discover the buffer size
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    pszClassName = new wchar_t[uBuf+1];         // Allocate a buffer for the class name
    if (pszClassName == 0)
        return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);

    wmilib::auto_buffer <wchar_t> _2(pszClassName);   // Auto-delete buffer

    hRes = pPath->GetClassName(&uBuf, pszClassName);    // Get class name
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    // Find out if a path to an instance or a class.
    // ==============================================
    hRes = pPath->GetInfo(0, &uInf);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    if (uInf & WBEMPATH_INFO_IS_INST_REF)
        bPathIsToClassObject = FALSE;
    else
        bPathIsToClassObject = TRUE;

    // Get the class definition.  We'll need it whether or not we validate the
    // instance or not.
    // =======================================================================

    hRes = Exec_GetObjectByPath(pszClassName,
            (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS),  pCtx,
            &pClassDef, &pErrorObj);

    if (FAILED(hRes))
    {
        OpInfo.ErrorOccurred(hRes, pErrorObj);
        if (pErrorObj)
            pErrorObj->Release();
        return hRes;
    }

    CReleaseMe _3(pClassDef);

    // Now see if the method exists and if the class definition
    // has the [bypass_getobject] qualifier on that method.
    // ========================================================

    hRes = pClassDef->GetMethodQualifierSet(wszMethodName, &pQSet);
    if (FAILED(hRes))
    {
        // Means the method doesn't even exist
        if ( WBEM_E_NOT_FOUND == hRes )
        {
            hRes = WBEM_E_INVALID_METHOD;
        }

        return OpInfo.ErrorOccurred(hRes);
    }
    CReleaseMe _4(pQSet);

    hRes = pQSet->Get(L"bypass_getobject", 0, 0, 0);

    if (hRes == WBEM_E_NOT_FOUND)
    {
        // If here, we are going to get the object pointed to by the path first to ensure it is
        // valid. Note that the object may be either an instance or class object
        //
        // First, merge in the __GET_EXT_KEYS_ONLY during the GetObject calls to allow
        // the provider to quickly verify the existence of the object.  We don't
        // actually care about the property values other than the keys. We use
        // a copy of the context object, as we want to merge in KEYS_ONLY behavior
        // for the next call only.
        // ============================================================================
        IWbemClassObject *pVerifiedObj = 0;
        IWbemContext *pCopy = 0;

        if (pCtx)
            pCtx->Clone(&pCopy);
        hRes = MergeGetKeysCtx(pCopy);
        if (FAILED(hRes))
            return OpInfo.ErrorOccurred(hRes);

        // If here, we are verifying the object exists before passing the
        // control to the method handler.
        // ==============================================================

        hRes = Exec_GetObjectByPath(wszObjectPath, lFlags, pCopy,
            &pVerifiedObj, &pErrorObj);

        if (pCopy)
            pCopy->Release();

        if (FAILED(hRes))
        {
            OpInfo.ErrorOccurred(hRes, pErrorObj);
            if (pErrorObj)
                pErrorObj->Release();
            return hRes;
        }

        // If here, the class or instance exists!!
        // =======================================

        pVerifiedObj->Release();
    }
    else if (FAILED(hRes))
    {
        return OpInfo.ErrorOccurred(hRes);
    }


    // If this is the special internal security object, handle it internally
    // ======================================================================

    CVar Value;
    hRes = ((CWbemClass *) pClassDef)->GetSystemPropertyByName(L"__CLASS", &Value);
    if (hRes == S_OK && Value.GetType() == VT_BSTR && !Value.IsDataNull())
       if (!wbem_wcsicmp(Value.GetLPWSTR(), L"__SystemSecurity"))
           return SecurityMethod(wszMethodName, lFlags, pInParams, pCtx, pSink);

    // Make sure we have security.
    // ===========================

    if (!Allowed(WBEM_METHOD_EXECUTE))
        return OpInfo.ErrorOccurred(WBEM_E_ACCESS_DENIED);

    // Now, we locate the exact implementation of the method. After all, the
    // subclass may have been very lazy and relied on its parent implementation,
    // the way many kids rely on their parents for gas money.
    // =========================================================================

    hRes = GetImplementationClass(pClassDef, wszMethodName, pCtx, &pImplementationClass);
    if (FAILED(hRes))
        return OpInfo.ErrorOccurred(hRes);

    // The "pImplementatinClass" now points to the class object where the methods is implemented
    // =========================================================================================

    CReleaseMe rm2(pImplementationClass);
    CWbemClass * pImplementationDef = (CWbemClass*)pImplementationClass;

    // Make sure that class paths are only used with static methods.
    // =============================================================

    CVar Var;
    if (bPathIsToClassObject)
    {
        hRes = pImplementationDef->GetMethodQualifier(wszMethodName, L"STATIC", &Var);
        if (hRes != S_OK || Var.GetBool() != VARIANT_TRUE)
        {
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_METHOD_PARAMETERS);
        }
    }

    // Get the provider name.
    // ======================

    CVar vProv;
    hRes = pImplementationDef->GetQualifier(L"Provider", &vProv);

    if (FAILED(hRes) || vProv.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);

    // Adjust the path to reference the class of implementation
    // ========================================================

    CVar vImpClassName;
    hRes = pImplementationDef->GetClassName(&vImpClassName);
    if (FAILED(hRes) || vImpClassName.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);

    BSTR strNewPath = CQueryEngine::AdjustPathToClass(wszObjectPath,
                                                    vImpClassName.GetLPWSTR());
    if (strNewPath == NULL)
        return OpInfo.ErrorOccurred(WBEM_E_CRITICAL_ERROR);

    CSysFreeMe sfm1(strNewPath);

    // Load the provider and execute it.
    // ==================================

    CMethodSink * pMethSink = new CMethodSink(OpInfo.GetSink());
    if(pMethSink == NULL)
       return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
    pMethSink->AddRef();
    CReleaseMe _5(pMethSink);

    // Find provider.
    // ==============

    IWbemServices *pProv = 0;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;   // SEC:REVIEWED 2002-03-22 : OK

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProv,     // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
        );
    }

    if (FAILED(hRes))
    {
        return pSink->Return(hRes);
    }

    CReleaseMe _(pProv);

    hRes = pProv->ExecMethodAsync(
        strNewPath,
        wszMethodName,
        lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
        pCtx,
        pInParams,
        pMethSink
        );

    return hRes;
}



//***************************************************************************
//
//  CWbemNamespace::GetOrPutDynProps
//
//  Processes an instance to see if any properties have been marked
//  as 'dynamic'.
//
//  Short-circuit logic is in effect.  The instance as a whole must be
//  marked with the following Qualifier to signal that the instance has
//  dynamic properties which need evaluation:
//
//      "DYNPROPS" (VT_BOOL) = VARIANT_TRUE
//
//  Optionally, the instance may contain:
//      "INSTANCECONTEXT" VT_BSTR = <provider specific string>
//
//  In addition, each dynamic property is marked
//
//      "DYNAMIC"           VT_BOOL     VARIANT_TRUE
//      "LOCATORCLSID"      VT_BSTR     CLSID of the provider
//      "PROPERTYCONTEXT"   VT_BSTR     <provider specific string>
//
//  "INSTANCECONTEXT" and "PROPERTYCONTEXT" are not checked by this code,
//  since they are optional for each provider.
//
//  PARAMETERS:
//
//      IWbemClassObject* pObj       The object to fill in dynamic properties
//                                  in.
//      Operation op                Can be GET or PUT depending on what is
//                                  needed.
//      bool bIsDynamic             True if a dynamically provided class.  Note that it
//                                  would be very strange to have a dynamic class with
//                                  dynamic properties.
//  RETURN VALUES:
//      <WBEM_NO_ERROR>  No provider was involved or if a provider was
//                        involved, properties were all evaluated.
//
//      <WBEM_E_INVALID_OBJECT>
//          Object was marked as dynamic, but other Qualifiers were missing.
//
//      <WBEM_E_PROVIDER_NOT_FOUND>
//          One or more of the specified providers could not be found.
//
//      <WBEM_E_PROVIDER_FAILURE>
//          One or more providers were not able to provide the properties.
//
//      <WBEM_E_CRITICAL_ERROR>
//
//***************************************************************************

HRESULT CWbemNamespace::GetOrPutDynProps(
    IWbemClassObject *pObj,
    Operation op,
    BOOL bIsDynamic
    )
{
    HRESULT hRes;
    IWbemContext *pCtx = 0;
    CVar vDynTest;
    _IWmiDynamicPropertyResolver *pResolver = 0;
    IWbemQualifierSet *pQSet = 0;
    IWbemClassObject *pClassDef = 0;
    CVARIANT v;

    // Examine the instance to see if there are any dynamic properties.
    // ================================================================

    hRes = pObj->GetQualifierSet(&pQSet);
    if (FAILED(hRes))
        return WBEM_NO_ERROR;
    CReleaseMe _1(pQSet);

    hRes = pQSet->Get(L"DYNPROPS", 0, &v, 0);
    if (FAILED(hRes))
        return WBEM_S_NO_ERROR;
    if (v.GetBool() == FALSE)
        return WBEM_S_NO_ERROR;

    v.Clear();
    hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    // Get the class definition for the object.
    // Must be static.
    // ========================================

    hRes = CRepository::GetObject(
             m_pSession,
             m_pNsHandle,
             v.GetStr(),
             0,
             &pClassDef
             );

    CReleaseMe _2(pClassDef);
    if (FAILED(hRes))
        return hRes;

    // Access provider subsystem to do the dirty work.
    // ================================================


    if (m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        pCtx = ConfigMgr::GetNewContext();
        if ( pCtx == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        hRes = m_pProvFact->GetDynamicPropertyResolver (
                                 0,          // lFlags
                                 pCtx,   // context
                                 m_wszUserName,
                                 m_wsLocale,
                                 IID__IWmiDynamicPropertyResolver,
                                 (LPVOID *)&pResolver);
    }

    CReleaseMe _1_pCtx (pCtx) ;

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _3(pResolver);

    // Determine if a put or a get.
    // ============================

    if (op == GET)
    {
        hRes = pResolver->Read(pCtx, pClassDef, &pObj);
    }
    else if (op == PUT)
    {
        hRes = pResolver->Write(pCtx, pClassDef, pObj);
    }
    else
        return WBEM_E_INVALID_PARAMETER;

    return hRes;
}

//***************************************************************************
//
//  AddKey
//
//  Adds a keyname/value pair to a normalized path
//
//  throw CX_MemoryException
//
//***************************************************************************

HRESULT AddKey(WString & wNormalString, WCHAR * pwsKeyName, VARIANT *pvKeyValue,
                                                            int & iNumKey, CWbemInstance* pClassDef)
{
    if(iNumKey++ > 0)
        wNormalString += L",";              // prepend comma for all but the first key

    wNormalString += pwsKeyName;
    wNormalString += "=";
    if(pvKeyValue->vt == VT_BSTR)
    {
        wNormalString += L"\"";

        // if there are any quotes, they must be prepended with a back slash;
        // Also, any back slashes should be doubled up.

        int iLen = 1;       // one for the terminator;
        WCHAR * pTest;
        for(pTest = pvKeyValue->bstrVal;*pTest; pTest++, iLen++)
            if(*pTest == L'\"' || *pTest == L'\\')
                iLen++;
        WCHAR * pString = new WCHAR[iLen];
        if(pString == NULL)
            throw CX_MemoryException();
        wmilib::auto_buffer<WCHAR> rm_(pString);

        WCHAR * pTo = pString;
        for(pTest = pvKeyValue->bstrVal;*pTest; pTest++, pTo++)
        {
            if(*pTest == L'\"' || *pTest == L'\\')
            {
                *pTo = L'\\';
                pTo++;
            }
            *pTo = *pTest;
        }
        *pTo = 0;

        wNormalString += pString;
        wNormalString += L"\"";
        return S_OK;
    }
    if(pvKeyValue->vt != VT_EMPTY && pvKeyValue->vt != VT_NULL)
    {

        // special case for large unsigned numbers
        if(pvKeyValue->vt == VT_I4 && pvKeyValue->lVal < 0)
        {
            CIMTYPE ct;
            HRESULT hRes = pClassDef->Get(pwsKeyName, 0, NULL, &ct, NULL);
            if(hRes == S_OK && ct == CIM_UINT32)
            {
                WCHAR wBuff[32];
                StringCchPrintfW(wBuff, 32, L"%u",pvKeyValue->lVal);
                wNormalString += wBuff;
                return S_OK;
            }
        }

        _variant_t var;
        HRESULT hRes = VariantChangeType(&var, pvKeyValue, 0, VT_BSTR);
        if(hRes == S_OK)
        {
            wNormalString += var.bstrVal;
        }

        return hRes;
    }
    return WBEM_E_INVALID_OBJECT_PATH;
}

//***************************************************************************
//
//  NormalizeObjectPath
//
//  Creates a normalized object path for passing to providers.
//***************************************************************************

HRESULT NormalizeObjectPath(ParsedObjectPath*pOutput, WString & wNormalString,
                            CWbemInstance* pClassDef)
{
    try
    {
        HRESULT hRes;

        // For singleton, so long as the class is singleton

        if(pOutput->m_bSingletonObj)
        {
            CVar Singleton;
            hRes = pClassDef->GetQualifier(L"SINGLETON", &Singleton);
            if (hRes == 0 && Singleton.GetBool() != 0)
            {
                wNormalString = pOutput->m_pClass;
                wNormalString += "=@";
                return S_OK;
            }
            else
                return WBEM_E_INVALID_OBJECT_PATH;
        }

        int iKeyNum = 0;
        int iNumMatch = 0;          // number of keys in the path which were found in the class def

        // Start off by writting the class name followe by a dot

        wNormalString = pOutput->m_pClass;
        wNormalString += L".";

        CWStringArray ClassKeyNames;
        if(!pClassDef->GetKeyProps(ClassKeyNames))
            return WBEM_E_INVALID_CLASS;

        // For each key in the class definition

        for(int iClassKey = 0; iClassKey < ClassKeyNames.Size(); iClassKey++)
        {
            // look for the class key in the path

            bool bClassKeyIsInPath = false;
            int iPathKey;

            for(iPathKey = 0; iPathKey < pOutput->m_dwNumKeys; iPathKey++)
            {
                KeyRef * key = pOutput->m_paKeys[iPathKey];
                if(key->m_pName == 0 && ClassKeyNames.Size() == 1 && pOutput->m_dwNumKeys==1)
                {
                    bClassKeyIsInPath = true;
                    break;
                }
                else if(key->m_pName && !wbem_wcsicmp(key->m_pName, ClassKeyNames[iClassKey]))
                {
                    bClassKeyIsInPath = true;
                    break;
                }
            }
            if(bClassKeyIsInPath)
            {
                iNumMatch++;
                // todo, check type

                KeyRef * key = pOutput->m_paKeys[iPathKey];
                hRes = AddKey(wNormalString, ClassKeyNames[iClassKey],
                                      &key->m_vValue, iKeyNum, pClassDef);
                if(FAILED(hRes))
                    return hRes;
            }
            else
            {
                // If the key has a default value, then use it
                _variant_t var;
                hRes = pClassDef->Get(ClassKeyNames[iClassKey], 0, &var, NULL, NULL);
                if(FAILED(hRes) || var.vt == VT_EMPTY || var.vt == VT_NULL)
                    return WBEM_E_INVALID_OBJECT_PATH;
                hRes = AddKey(wNormalString, ClassKeyNames[iClassKey], &var, iKeyNum,pClassDef);
                if(FAILED(hRes))
                    return hRes;
            }
        }

        if(iNumMatch == pOutput->m_dwNumKeys)
            return S_OK;
        else
            return WBEM_E_INVALID_OBJECT_PATH;
    }
    catch (CX_MemoryException &)
    {

        return WBEM_E_OUT_OF_MEMORY;
    }
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_GetInstance
//
//  Retrieves an instance identified by its path from the dynamic provider
//  registered for that class.
//
//  PARAMETERS:
//
//      IN DWORD  dwNamespace             Namespace handle to the current
//                                        namespace (see objdb.h)
//      IN LPWSTR pObjectPath             Object path to the instance.
//      IN long lFlags                    Flags. Propagated to provider.
//      OUT IWbemClassObject** pObj        Destination for the class definition.
//                                        The caller must release this object
//                                        if the call is successful.
//      OUT IWbemClassObject** ppErrorObj  Destination for the error object. May
//                                        be NULL. Otherwise, the returned
//                                        pointer must be released if not NULL.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              Success.
//      WBEM_E_NOT_FOUND             No such instance, says provider, or the
//                                  class is not dynamic.
//      WBEM_E_INVALID_PARAMETER     One or more parameters are invalid.
//      WBEM_E_INVALID_CLASS         The class specified in the path does not
//                                  exist.
//      WBEM_E_FAILED                Unexpected error occured.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider for this class could not be
//                                  located --- not registered with us or COM.
//      WBEM_E_PROVIDER_FAILURE      Provider reported an error while looking
//                                  for this object.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider for this class is not capable of
//                                  getting objects by path.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_GetInstance(
    IN LPWSTR wszObjectPath,
    IN long lFlags,
    IN IWbemContext* pCtx,
    IN CBasicObjectSink* pSink
    )
{
    // Parse the object path to get the class involved.
    // ================================================
    ParsedObjectPath* pOutput = 0;
    CObjectPathParser p;
    int nStatus = p.Parse(wszObjectPath,  &pOutput);
    OnDeleteObj<ParsedObjectPath*,CObjectPathParser,
                         void (CObjectPathParser:: *)(ParsedObjectPath *),
                         &CObjectPathParser::Free> FreeMe(&p,pOutput);    

    if(CObjectPathParser::NoError != nStatus || !pOutput->IsInstance())
        return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);

    HRESULT hres = WBEM_E_FAILED;
    IWbemClassObject* pErrorObj = NULL;
    CReleaseMeRef<IWbemClassObject*> rmErrObj(pErrorObj);
    CSetStatusOnMe SetMe(pSink,hres,pErrorObj);

    // See if this class is actually provided dynamically

    BSTR strClass = SysAllocString(pOutput->m_pClass);
    if (NULL == strClass) 
    {
        return hres = WBEM_E_OUT_OF_MEMORY;
    }
    CSysFreeMe sfm(strClass);

    CWbemInstance *pClassDef = 0;
    IWbemClassObject* pClassObj = NULL;

    hres = Exec_GetObjectByPath(strClass,
                            lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                            pCtx,&pClassObj, NULL);
    if(FAILED(hres))
    {
        hres = (hres == WBEM_E_NOT_FOUND) ? WBEM_E_INVALID_CLASS : WBEM_E_FAILED;
        return hres;
    }

    CReleaseMe rm(pClassObj);
    pClassDef = (CWbemInstance*)pClassObj;

    WString wNormalPath;
    hres = NormalizeObjectPath(pOutput, wNormalPath, pClassDef);
    if(FAILED(hres)) return hres;

    if(!pClassDef->IsKeyed())
        return hres = WBEM_E_INVALID_CLASS;

    // Make sure that this class is not static ---
    // i.e. either dynamic or abstract
    // ===========================================

    CVar vDynamic;
    hres = pClassDef->GetQualifier(L"Dynamic", &vDynamic);
    if(FAILED(hres) || vDynamic.GetType() != VT_BOOL || !vDynamic.GetBool())
    {
        // Not dynamic. Check if it is abstract
        // ====================================

        CVar vAbstract;
        hres = pClassDef->GetQualifier(L"Abstract", &vAbstract);
        if(FAILED(hres) || vAbstract.GetType() != VT_BOOL || !vAbstract.GetBool())
            return hres = WBEM_E_NOT_FOUND;
    }

    // Build the class hierarchy
    // =========================

    wmilib::auto_ptr<CDynasty> pDynasty;
    hres = DynAux_BuildClassHierarchy(strClass, lFlags, pCtx, pDynasty,&pErrorObj);
    if(FAILED(hres)) return hres;

    rmErrObj.release(); // set it to null anyway


    // If direct read is requested, only ask the provider in question.
    // ===============================================================

    if (lFlags & WBEM_FLAG_DIRECT_READ)
    {
        DynAux_GetSingleInstance((CWbemClass*) pClassObj,lFlags, wszObjectPath, pCtx, pSink);
    }
    else
    {
        // Create merging sink        
        hres = WBEM_E_OUT_OF_MEMORY; // pre-set the failure
        CSingleMergingSink* pMergeSink = new CSingleMergingSink(pSink, strClass); // throw
        if(pMergeSink == NULL)  return hres;
        pMergeSink->AddRef();
        CReleaseMe rm(pMergeSink);

        // Ask all providers
        DynAux_AskRecursively(pDynasty.get(), lFlags, wNormalPath, pCtx,pMergeSink);
    }

    SetMe.dismiss();
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_AskRecursively(CDynasty* pDynasty,
                                              long lFlags,
                                              LPWSTR wszObjectPath,
                                              IWbemContext* pCtx,
                                              CBasicObjectSink* pSink)
{
    // Convert the path to the new class
    // =================================

    BSTR strNewPath = CQueryEngine::AdjustPathToClass(wszObjectPath, pDynasty->m_wszClassName);
    if(strNewPath == NULL) return pSink->Return(WBEM_E_INVALID_OBJECT_PATH);
    CSysFreeMe sfm(strNewPath);

    // Get this provider's object
    // ==========================
    DynAux_GetSingleInstance((CWbemClass*)pDynasty->m_pClassObj,lFlags, strNewPath, pCtx, pSink);

    // Get the children's objects
    // ==========================

    for(int i = 0; i < pDynasty->m_Children.Size(); i++)
    {
        CDynasty* pChildDyn = (CDynasty*)pDynasty->m_Children.GetAt(i);

        DynAux_AskRecursively(pChildDyn, lFlags, wszObjectPath, pCtx,pSink);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_GetSingleInstance(CWbemClass* pClassDef,
                                                 long lFlags,
                                                 LPWSTR wszObjectPath,
                                                 IWbemContext* pCtx,
                                                 CBasicObjectSink* pSink)
{

    COperationError OpInfo(pSink, L"GetObject", wszObjectPath, FALSE);
    // the ctor calls setstatus in bad luck case
    if (!OpInfo.IsOk()) return WBEM_E_OUT_OF_MEMORY;

    // Verify that the class is indeed dynamic
    // =======================================
    if(!pClassDef->IsDynamic())
        return OpInfo.ErrorOccurred(WBEM_E_NOT_FOUND);

    CVar vProvName;
    HRESULT hres = pClassDef->GetQualifier(L"Provider", &vProvName);
    if(FAILED(hres) || vProvName.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);

    OpInfo.SetProviderName(vProvName.GetLPWSTR()); //throw

    // Access the provider cache.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;  // SEC:REVIEWED 2002-03-22 : OK

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProvName,     // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
        );
    }

    if (FAILED(hRes))
    {
     return pSink->Return(hRes);
    }

    CReleaseMe _(pProv);
    CDecoratingSink * pDecore = new CDecoratingSink(OpInfo.GetSink(), this);
    if(pDecore == NULL) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pDecore->AddRef();
    CReleaseMe cdecor(pDecore);

    hRes = pProv->GetObjectAsync(wszObjectPath, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pDecore);

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_GetInstances
//
//  Gets all instances from the provider specified in the class
//  definition.  Does no inheritance joins; this is a simple retrieval
//  of all instances from the specified class.
//
//  Preconditions:
//  1. The class <pClassDef> is known to be marked 'dynamic', but no
//     other verification has been done on the class definition.
//  2. <pClassDef> is not NULL.
//
//  Postconditions:
//  1. <aInstances> is empty on all error conditions.
//
//  PARAMETERS:
//
//      READONLY CWbemObject *pClassDef  The definition of the class to retrieve
//                                      instances of.
//      long lFlags                     The flags (deep/shallow)
//      CFlexArray &aInstances          Destination for the instances.
//      IWbemClassObject** ppErrorObj    Destination for the error object. If
//                                      not NULL, an error object may be placed
//                                      here. It is the caller's responsibility
//                                      to release it if not NULL.
//  RETURN VALUES:
//
//      WBEM_NO_ERROR  No errors. This includes a no-error situation
//                  with zero instances returned.
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_GetInstances(

    READONLY CWbemObject *pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink ,
    BOOL bComplexQuery
)
{
    // First, get the current task - 
    // if there isn't one, then we are on an WbemESS thread
    // ESS use to issue "internal" queries that are processes without arbitration
    CWbemRequest*  pCurrReq = CWbemQueue::GetCurrentRequest();
    CWmiTask * pCurrTask = pCurrReq?((CWmiTask *)pCurrReq->m_phTask):NULL;
        
    // We'll need the finalizer in case we need to cancel something
    HRESULT    hr;
    
    _IWmiFinalizer*    pMainFnz = NULL;    
    if (pCurrTask)
    {
        hr = pCurrTask->GetFinalizer( &pMainFnz );
        if (FAILED(hr)) return hr;
    }    
    CReleaseMe    rm( pMainFnz );
        
    CWmiMerger* pWmiMerger = NULL;

    // Check if query arbitration is enabled
    if ( ConfigMgr::GetEnableQueryArbitration() && pCurrTask)
    {
        // Get the arbitrated query pointer and cast to a merger as appropriate
        _IWmiArbitratedQuery*    pArbQuery = NULL;

        hr = pCurrTask->GetArbitratedQuery( 0L, &pArbQuery );

        if ( SUCCEEDED( hr ) )
        {
            hr = pArbQuery->IsMerger();

            if ( SUCCEEDED( hr ) )
            {
                pWmiMerger = (CWmiMerger*) pArbQuery;
            }
            else
            {
                pArbQuery->Release();
            }
        }

        // Clear errors
        hr = WBEM_S_NO_ERROR;

    }    // IF Query arbitration enabled

    CReleaseMe    rmMerger( (_IWmiArbitratee*) pWmiMerger );

    // Perform correct handling based on whether or not we have a merger
    if ( pWmiMerger )
    {
        hr = pWmiMerger->RegisterArbitratedInstRequest( pClassDef, lFlags, pCtx, pSink,    bComplexQuery, this );

        if (FAILED( hr))
            if (pMainFnz) pMainFnz->CancelTask( 0 );
        
        return hr;
    }

    //
    // when the query arbitration is not enabled we fall here
    //
    CAsyncReq_DynAux_GetInstances * pReq;
    pReq = new CAsyncReq_DynAux_GetInstances (this,
	                                            pClassDef,
	                                            lFlags,
	                                            pCtx,
	                                            pSink); 


    if ( pReq == NULL)
    {
        if (pMainFnz) pMainFnz->CancelTask ( 0 );
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( NULL == pReq->GetContext() )
    {
        if (pMainFnz) pMainFnz->CancelTask ( 0 );
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Set the task for the request - we'll just use the existing one if any
    pReq->m_phTask = pCurrTask;
    if (pReq->m_phTask) pReq->m_phTask->AddRef();
    
    hr = ConfigMgr::EnqueueRequest(pReq);

    if (FAILED(hr))
    {
        if (pMainFnz) pMainFnz->CancelTask ( 0 );
        delete pReq;
    }

    return hr;

}

//***************************************************************************
//
//  CWbemNamespace::DynAux_GetInstances
//
//  Gets all instances from the provider specified in the class
//  definition.  Does no inheritance joins; this is a simple retrieval
//  of all instances from the specified class.
//
//  Preconditions:
//  1. The class <pClassDef> is known to be marked 'dynamic', but no
//     other verification has been done on the class definition.
//  2. <pClassDef> is not NULL.
//
//  Postconditions:
//  1. <aInstances> is empty on all error conditions.
//
//  PARAMETERS:
//
//      READONLY CWbemObject *pClassDef  The definition of the class to retrieve
//                                      instances of.
//      long lFlags                     The flags (deep/shallow)
//      CFlexArray &aInstances          Destination for the instances.
//      IWbemClassObject** ppErrorObj    Destination for the error object. If
//                                      not NULL, an error object may be placed
//                                      here. It is the caller's responsibility
//                                      to release it if not NULL.
//  RETURN VALUES:
//
//      WBEM_NO_ERROR  No errors. This includes a no-error situation
//                  with zero instances returned.
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_DynAux_GetInstances(
    READONLY CWbemObject *pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
    )
{

    COperationError OpInfo(pSink, L"CreateInstanceEnum", L"", FALSE);
    if ( !OpInfo.IsOk() ) return pSink->Return(WBEM_E_OUT_OF_MEMORY);    
    
    CVar vProv;
    CVar vClassName;
    
    // Get the provider name.
    // ======================

    try // internal fastprox interfaces throw
    {
        HRESULT hres = pClassDef->GetQualifier(L"Provider", &vProv);
        if (FAILED(hres) || vProv.GetType() != VT_BSTR)
            return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);
        if (FAILED(pClassDef->GetClassName(&vClassName)))
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        OpInfo.SetParameterInfo(vClassName.GetLPWSTR());
    }
    catch(CX_MemoryException &)
    {
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    }

    // Access Provider Subsystem.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;

    if (m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
            WmiInternalContext t_InternalContext ;
            ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) );

            hRes = m_pProvFact->GetProvider(
                t_InternalContext ,
                0,                  // lFlags
                pCtx,
                0,
                m_wszUserName,
                m_wsLocale,
                0,                      // IWbemPath pointer
                vProv,     // Provider
                IID_IWbemServices,
                (LPVOID *) &pProv);
    }

    if (FAILED(hRes))
         return pSink->Return(hRes);
    CReleaseMe _1(pProv);

    // Set up the sink chain to be delivered to the provider.
    // The code & destruct sequence is critical and the
    // refcounting is very carefully thought out.  Do not
    // change this code unless you know exactly what you are
    // doing.  And don't even change it then.
    // ======================================================

    CProviderSink *pProvSink = new CProviderSink(1, vClassName.GetLPWSTR());
    if (pProvSink == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CReleaseMe _3(pProvSink);

    CDecoratingSink * pDecore = new CDecoratingSink(pSink, this);
    if (pDecore == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pProvSink->SetNextSink(pDecore);

    // Before calling the provider, map the provider to the
    // task so that we can cancel it proactively, if required.
    // =======================================================

    hRes = ((CWmiArbitrator *) m_pArb)->MapProviderToTask(0, pCtx, pProv, pProvSink);
    if (FAILED(hRes))
        return pSink->Return(hRes);

    // Now tell the provider to start enumerating.
    hRes = pProv->CreateInstanceEnumAsync(vClassName.GetLPWSTR(),
                                                                    lFlags & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                                    pCtx,
                                                                    pProvSink
                                                                    );

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_ExecQueryAsync
//
//  Executes a SQL-1 query against a dynamic instance provider for the class
//  in the query.
//
//  PARAMETERS:
//
//      IN DWORD dwNamespace            Namespace handle to the current
//                                      namespace (see objdb.h)
//      IN CWbemObject* pClassDef        Class definition of the class in the
//                                      query. Must be dynamic.
//      IN LPWSTR Query                 The query string.
//      IN LPWSTR QueryFormat           The query language. Must be WQL.
//      IN long lFlags                  The flags. Not used.
//      OUT CFlexArray &aInstances      Destinatino for the instances found.
//      OUT IWbemClassObject** ppErrorObj Destination for the error object. IF
//                                      not NULL, an error object may be placed
//                                      here. In this case, it is the caller's
//                                      responsibility to release it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR                  Success (even though there may not be
//                                      any instances).
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_ExecQueryAsync (

    CWbemObject* pClassDef,
    LPWSTR Query,
    LPWSTR QueryFormat,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink,
    BOOL bComplexQuery
)
{
    // First, get the current task - if there isn't one, something
    // is very wrong.

    CWbemRequest*        pCurrReq = CWbemQueue::GetCurrentRequest();

    _DBG_ASSERT( NULL != pCurrReq && NULL != pCurrReq->m_phTask );

    if ( NULL == pCurrReq || NULL == pCurrReq->m_phTask )
    {
        return WBEM_E_FAILED;
    }

    // We'll need the finalizer in case we need to cancel something
    _IWmiFinalizer*    pMainFnz = NULL;
    
    HRESULT    hr = ((CWmiTask*) pCurrReq->m_phTask)->GetFinalizer( &pMainFnz );
    CReleaseMe    rm( pMainFnz );

    if ( SUCCEEDED( hr ) )
    {
        CWmiMerger*                pWmiMerger = NULL;

        // Check if query arbitration is enabled
        if ( ConfigMgr::GetEnableQueryArbitration() )
        {
            // Get the arbitrated query pointer and cast to a merger as appropriate
            _IWmiArbitratedQuery*    pArbQuery = NULL;

            hr = ((CWmiTask*) pCurrReq->m_phTask)->GetArbitratedQuery( 0L, &pArbQuery );

            if ( SUCCEEDED( hr ) )
            {
                hr = pArbQuery->IsMerger();

                if ( SUCCEEDED( hr ) )
                {
                    pWmiMerger = (CWmiMerger*) pArbQuery;
                }
                else
                {
                    pArbQuery->Release();
                }
            }

            // Clear errors
            hr = WBEM_S_NO_ERROR;

        }    // IF Query arbitration enabled

        // Auto cleanup
        CReleaseMe    rm( (_IWmiArbitratee*) pWmiMerger );

        // Perform correct handling based on whether or not we have a merger
        if ( NULL != pWmiMerger )
        {
            hr = pWmiMerger->RegisterArbitratedQueryRequest( pClassDef, lFlags, Query, QueryFormat, pCtx, pSink, this );

            if (FAILED(hr))
            {
                pMainFnz->CancelTask ( 0 );
            }

        }
        else
        {
            CAsyncReq_DynAux_ExecQueryAsync *pReq = 0;
            try
            {
                pReq = new CAsyncReq_DynAux_ExecQueryAsync (
                    this,
                    pClassDef,
                    Query,
                    QueryFormat,
                    lFlags,
                    pCtx,
                    pSink
                );
            }
            catch(CX_Exception &)
            {
                pReq = 0;
            }

            if (pReq == NULL)
            {
                pMainFnz->CancelTask ( 0 );
                return WBEM_E_OUT_OF_MEMORY;
            }

            if ( NULL == pReq->GetContext() )
            {
                pMainFnz->CancelTask ( 0 );
                delete pReq;
                return WBEM_E_OUT_OF_MEMORY;
            }

            hr = pReq->Initialize () ;
            if ( SUCCEEDED ( hr ) )
            {

                // Set the task for the request - we'll just use the existing one
                pCurrReq->m_phTask->AddRef();
                pReq->m_phTask = pCurrReq->m_phTask;
                
                hr = ConfigMgr::EnqueueRequest(pReq);

                if (FAILED(hr))
                {
                    pMainFnz->CancelTask ( 0 );
                    delete pReq;
                }

            }    // IF Request Initialized
            else
            {
                pMainFnz->CancelTask ( 0 );
                delete pReq;
            }

        }

    }

    return hr;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_ExecQueryAsync
//
//  Executes a SQL-1 query against a dynamic instance provider for the class
//  in the query.
//
//  PARAMETERS:
//
//      IN DWORD dwNamespace            Namespace handle to the current
//                                      namespace (see objdb.h)
//      IN CWbemObject* pClassDef        Class definition of the class in the
//                                      query. Must be dynamic.
//      IN LPWSTR Query                 The query string.
//      IN LPWSTR QueryFormat           The query language. Must be WQL.
//      IN long lFlags                  The flags. Not used.
//      OUT CFlexArray &aInstances      Destinatino for the instances found.
//      OUT IWbemClassObject** ppErrorObj Destination for the error object. IF
//                                      not NULL, an error object may be placed
//                                      here. In this case, it is the caller's
//                                      responsibility to release it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR                  Success (even though there may not be
//                                      any instances).
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::Exec_DynAux_ExecQueryAsync (

    CWbemObject* pClassDef,
    LPWSTR Query,
    LPWSTR QueryFormat,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink
)
{

    COperationError OpInfo(pSink, L"ExecQuery", Query, FALSE);
    if (! OpInfo.IsOk())  return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    // Get the provider name.
    // ======================

    CVar vProv;
    HRESULT hres = pClassDef->GetQualifier(L"Provider", &vProv);
    if (FAILED(hres) || vProv.GetType() != VT_BSTR)
        return OpInfo.ErrorOccurred(WBEM_E_INVALID_PROVIDER_REGISTRATION);

    // Access the provider cache.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;  // SEC:REVIEWED 2002-03-22 : OK

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            vProv,     // Provider
            IID_IWbemServices,
            (LPVOID *) &pProv
            );
    }

    if (FAILED(hRes))
    {
        return pSink->Return(hRes);
    }

    CReleaseMe _1(pProv);

    // Set up the sink chain to be delivered to the provider.
    // The code & destruct sequence is critical and the
    // refcounting is very carefully thought out.  Do not
    // change this code unless you know exactly what you are
    // doing.  And don't even change it then.
    // ======================================================

    CProviderSink *pProvSink = new CProviderSink(1, Query);
    if (pProvSink == 0)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    CReleaseMe _3(pProvSink);

    CDecoratingSink * pDecore = new CDecoratingSink(pSink, this);
    if (pDecore == NULL)
        return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pProvSink->SetNextSink(pDecore);

    // Before calling the provider, map the provider to the
    // task so that we can cancel it proactively, if required.
    // =======================================================

    hRes = ((CWmiArbitrator *) m_pArb)->MapProviderToTask(0, pCtx, pProv, pProvSink);
    if (FAILED(hRes))
        return pSink->Return(hRes);


    // Now tell the provider to start enumerating.
    hRes = pProv->ExecQueryAsync(QueryFormat, 
                                                     Query, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS,
                                                     pCtx, pProvSink);

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::DynAux_ExecQueryAsync
//
//  Executes a SQL-1 query against a dynamic instance provider for the class
//  in the query.
//
//  PARAMETERS:
//
//      IN DWORD dwNamespace            Namespace handle to the current
//                                      namespace (see objdb.h)
//      IN CWbemObject* pClassDef        Class definition of the class in the
//                                      query. Must be dynamic.
//      IN LPWSTR Query                 The query string.
//      IN LPWSTR QueryFormat           The query language. Must be WQL.
//      IN long lFlags                  The flags. Not used.
//      OUT CFlexArray &aInstances      Destinatino for the instances found.
//      OUT IWbemClassObject** ppErrorObj Destination for the error object. IF
//                                      not NULL, an error object may be placed
//                                      here. In this case, it is the caller's
//                                      responsibility to release it.
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR                  Success (even though there may not be
//                                      any instances).
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_ExecQueryExtendedAsync(

    LPWSTR wsProvider,
    LPWSTR Query,
    LPWSTR QueryFormat,
    long lFlags,
    IWbemContext* pCtx,
    CComplexProjectionSink* pSink
)
{
    COperationError OpInfo(pSink, L"ExecQuery", Query, FALSE);
    if ( !OpInfo.IsOk() )  return WBEM_E_OUT_OF_MEMORY;


    // Access the provider cache.
    // ==========================

    IWbemServices *pProv = 0;
    HRESULT hRes;
    if(m_pProvFact == NULL)
        hRes = WBEM_E_CRITICAL_ERROR;
    else
    {
        WmiInternalContext t_InternalContext ;
        ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;  // SEC:REVIEWED 2002-03-22 : OK

        hRes = m_pProvFact->GetProvider(

            t_InternalContext ,
            0,                  // lFlags
            pCtx,
            0,
            m_wszUserName,
            m_wsLocale,
            0,                      // IWbemPath pointer
            wsProvider,              // provider name
            IID_IWbemServices,
            (LPVOID *) &pProv
        );
    }

    if (FAILED(hRes))
    {
        return pSink->Return(hRes);
    }

    CReleaseMe _(pProv);

    _IWmiProviderConfiguration *t_Configuration = NULL ;
    hRes = pProv->QueryInterface ( IID__IWmiProviderConfiguration , ( void ** ) & t_Configuration ) ;
    if ( SUCCEEDED ( hRes ) )
    {
        CReleaseMe _1(t_Configuration);

        VARIANT t_Variant ;
        VariantInit ( & t_Variant ) ;

        hRes = t_Configuration->Query (

            this ,
            lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS ,
            pCtx ,
            WBEM_PROVIDER_CONFIGURATION_CLASS_ID_INSTANCE_PROVIDER_REGISTRATION ,
            WBEM_PROVIDER_CONFIGURATION_PROPERTY_ID_EXTENDEDQUERY_SUPPORT ,
            & t_Variant
        ) ;

        if ( SUCCEEDED ( hRes ) )
        {
            if ( t_Variant.boolVal == VARIANT_TRUE )
            {
                CDecoratingSink * pDecore = new CDecoratingSink(pSink, this);
                if(pDecore == NULL)
                    return pSink->Return(WBEM_E_OUT_OF_MEMORY);
                pDecore->AddRef();
                CReleaseMe cdecor(pDecore);

                hRes = pProv->ExecQueryAsync(QueryFormat, Query, lFlags& ~WBEM_FLAG_USE_AMENDED_QUALIFIERS, pCtx, pDecore);
            }
            else
            {
                hRes = WBEM_E_INVALID_QUERY ;
            }

            VariantClear ( & t_Variant ) ;
        }
        else
        {
            hRes = WBEM_E_UNEXPECTED ;
        }
    }
    else
    {
        hRes = WBEM_E_UNEXPECTED ;
    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::Static_QueryRepository
//
//  Performs query against the repository.  This only happens if there is an
//    associated task.  If not, then we execute the query on the same thread.
//
//  PARAMETERS:
//
//      READONLY CWbemObject *pClassDef  The definition of the class to retrieve
//                                      instances of.
//      long lFlags                     The flags (deep/shallow)
//        
//  RETURN VALUES:
//
//      WBEM_NO_ERROR  No errors. This includes a no-error situation
//                  with zero instances returned.
//      WBEM_E_INVALID_PROVIDE_REGISTRATION  Provider registration for this
//                                          class is incomplete.
//      WBEM_E_PROVIDER_NOT_FOUND    Provider could not be located. It is not
//                                  registered with us or with COM.
//      WBEM_E_PROVIDER_NOT_CAPABLE  Provider is not capable of enumerating
//                                  instances.
//      WBEM_E_FAILED                Unexpected error has occured.
//
//***************************************************************************

HRESULT CWbemNamespace::Static_QueryRepository(

    READONLY CWbemObject *pClassDef,
    long lFlags,
    IWbemContext* pCtx,
    CBasicObjectSink* pSink ,
    QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery,
    LPCWSTR pwszClassName,
    CWmiMerger* pWmiMerger
)
{

    HRESULT    hr = WBEM_S_NO_ERROR;

    // First, get the current task and request.  If there isn't one, we're most
    // likely being called on an ESS callback, and will just perform the call on
    // this thread.

    CWbemRequest*        pCurrReq = CWbemQueue::GetCurrentRequest();

    if ( NULL != pCurrReq && NULL != pCurrReq->m_phTask && 
    	 ConfigMgr::GetEnableQueryArbitration() )
    {
        // We'll need the finalizer in case we need to cancel something
        _IWmiFinalizer*    pMainFnz = NULL;
        
        HRESULT    hr = ((CWmiTask*) pCurrReq->m_phTask)->GetFinalizer( &pMainFnz );
        CReleaseMe    rm( pMainFnz );

        if ( SUCCEEDED( hr ) )
        {
            //
            // creates the CMergerDynReq_Static_GetInstances
            // creates the Merger Request Manager 
            // adds the request to the Request Manager
            //
            hr = pWmiMerger->RegisterArbitratedStaticRequest( pClassDef, lFlags, pCtx, pSink, this, pParsedQuery );

            if (FAILED(hr))
            {
                pMainFnz->CancelTask ( 0 );
            }

        }    // IF Got Finalizer

        // In the case of an error we should do a setstatus of the error.  Otherwise, the setstatus will occur
        // when the new request is processed.
        if ( FAILED( hr ) )
        {
            pSink->SetStatus( 0L, hr, 0L, NULL );
        }
    }
    else
    {
        // If we're here, then we should disallow merger specific throttling since
        // this request is happening through an internal thread without following
        // the request/task hierarchy, meaning that there shouldn't be a hierarchy
        // we need to worry about for this class, so don't let the merger do any
        // internal throttling

        pWmiMerger->EnableMergerThrottling( false );

        int nRes = CQueryEngine::ExecAtomicDbQuery(
                    GetNsSession(),
                    GetNsHandle(),
                    GetScope(),
                    pwszClassName,
                    pParsedQuery,
                    pSink,
                    this );

        if (nRes == CQueryEngine::invalid_query)
            hr = WBEM_E_INVALID_QUERY;
        else if(nRes != 0)
            hr = WBEM_E_FAILED;
        else
            hr = WBEM_S_NO_ERROR;

        pSink->SetStatus( 0L, hr, 0L, NULL );

    }

    return hr;
}

//***************************************************************************
//
//  CWbemNamespace::DecorateObject
//
//  Sets the origin information on a given object to reflect this namespace
//  and this server. See CWbemObject::Decorate in fastobj.h for details.
//  THIS FUNCTION CAN ONLY DECORATE CWbemObject POINTERS, NOT OTHER PEOPLE'S
//  IMPLEMENTATIONS of IWbemClassObject.
//
//  PARAMETERS:
//
//      IWbemClassObject* pObject        The object to decorate.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              Success
//      WBEM_E_INVALID_PARAMETER     pObject == NULL.
//
//***************************************************************************

HRESULT CWbemNamespace::DecorateObject(IWbemClassObject* pObject)
{
    if(pObject == NULL)
        return WBEM_E_INVALID_PARAMETER;

    return ((CWbemObject*)pObject)->Decorate(ConfigMgr::GetMachineName(),
                                          m_pThisNamespace);
}

//***************************************************************************
//
//***************************************************************************

typedef std::vector<CDynasty*, wbem_allocator<CDynasty*> > CDynastyPtrArray;
typedef std::map<LPWSTR, CDynasty*, wcsiless, wbem_allocator<CDynasty*> > CCDynastyMap;

HRESULT AddAllMembers(CDynasty* pDynasty, CCDynastyMap& Map)
{
    // Catch any exceptions the allocator might throw
    try
    {
        Map[pDynasty->m_wszClassName] = pDynasty;
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = WBEM_S_NO_ERROR;

    CFlexArray* pChildren = &pDynasty->m_Children;
    for(int i = 0; SUCCEEDED(hr) && i < pChildren->Size(); i++)
    {
        hr = AddAllMembers((CDynasty*)pChildren->GetAt(i), Map);
    }
    return hr;
}


//***************************************************************************
//
//  CWbemNamespace::DynAux_BuildClassHierarchy
//
//  Recursively builds the hierarchy of classes derived from a given one.
//  The structure used to represent the hierarchy -- CDynasty is described
//  in objdb.h
//
//  PARAMETERS:
//
//      IN LPWSTR wszClassName      The name of the parent class.
//      IN LONG lFlags              If SHALLOW, just the class itself is
//                                  returned. If DEEP, recursive enumeration
//                                  is performed.
//      OUT CDynasty** ppDynasty  Destination for the tree. The caller must
//                                  delete the pointer on success.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              Success
//      Any of the return values returned by GetObject or CreateClassEnum,
//      as documented in the help file.
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_BuildClassHierarchy(
                                              IN LPWSTR wszClassName,
                                              IN LONG lFlags,
                                              IN IWbemContext* pCtx,
                                              OUT wmilib::auto_ptr<CDynasty> & pDynasty,
                                              OUT IWbemClassObject** ppErrorObj)
{
    HRESULT hres;
    *ppErrorObj = NULL;

    // Get the list of classes from all class providers
    // ================================================

    CSynchronousSink* pSyncSink = CSynchronousSink::Create();
    if(pSyncSink == NULL) return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    CReleaseMe rm1(pSyncSink);

    hres = Exec_CreateClassEnum(wszClassName,
                                                  lFlags | WBEM_FLAG_NO_STATIC, 
                                                  pCtx,
                                                  pSyncSink);
    pSyncSink->Block();
    pSyncSink->GetStatus(&hres, NULL, ppErrorObj);

    if(FAILED(hres))
        return hres;

    // Get the static dynasty
    // ======================

    wmilib::auto_ptr<CDynasty> pMainDynasty;

    HRESULT hRes = CRepository::BuildClassHierarchy(m_pSession,
                                                                                m_pNsHandle,
                                                                                wszClassName,
                                                                                lFlags & WBEM_MASK_DEPTH,
                                                                                pMainDynasty);

    if (hRes == WBEM_E_NOT_FOUND)
    {
        IWbemClassObject* pObj;
        HRESULT hres = Exec_GetObjectByPath(wszClassName, lFlags, pCtx,
                                                                  &pObj, 
                                                                  ppErrorObj);
        if(FAILED(hres)) return hres;
        CReleaseMe rmClassObj(pObj);
        
        pMainDynasty.reset(CDynasty::Create(pObj));
        if(NULL == pMainDynasty.get())  return WBEM_E_OUT_OF_MEMORY;
        if(pMainDynasty->m_pClassObj == NULL)
        {
            ERRORTRACE((LOG_WBEMCORE, "Provider returned invalid class for %S\n",wszClassName));
            return WBEM_E_PROVIDER_FAILURE;
        }
        hRes = S_OK;
    }
    if (FAILED(hRes)) return hRes;
    

    CRefedPointerArray<IWbemClassObject> &rProvidedClasses = pSyncSink->GetObjects();

    // Create a map of class names to their dynasties
    // ==============================================

    CCDynastyMap mapClasses;
    hres = AddAllMembers(pMainDynasty.get(), mapClasses);
    if ( FAILED(hres)) return hres;

    CDynastyPtrArray aProvidedDyns;

    try
    {
        aProvidedDyns.reserve(rProvidedClasses.GetSize());
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    for(int i = 0; i < rProvidedClasses.GetSize(); i++)
    {
        CDynasty* pNew = CDynasty::Create(rProvidedClasses[i]);
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(pNew->m_pClassObj == NULL)
        {
            delete pNew;
            ERRORTRACE((LOG_WBEMCORE, "Provider returned invalid class!\n"));
            continue;
        }

        // The vector or the map may throw exceptions
        try
        {
            mapClasses[pNew->m_wszClassName] = pNew;
            aProvidedDyns.push_back(pNew);
        }
        catch(CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    }

    // Go through it once and add all classes to their parent's dynasty
    // ================================================================

    for(CDynastyPtrArray::iterator it = aProvidedDyns.begin();
        it != aProvidedDyns.end(); it++)
    {
        CDynasty* pDyn = *it;
        CVar vParent;
        CWbemObject *pObj = (CWbemObject *) pDyn->m_pClassObj;

        if(FAILED(pObj->GetSuperclassName(&vParent)) ||
                            vParent.IsNull())
        {
            ERRORTRACE((LOG_WBEMCORE,"Provider returned top-level class %S as a child "
                "of %S\n", pDyn->m_wszClassName, wszClassName));
            continue;
        }

        CCDynastyMap::iterator itParent =
            mapClasses.find(vParent.GetLPWSTR());

        if((itParent == mapClasses.end()))
        {
            if(wbem_wcsicmp(pDyn->m_wszClassName, wszClassName))
            {
                ERRORTRACE((LOG_WBEMCORE,"Provider returned class %S without parent!\n",
                    vParent.GetLPWSTR()));
            }
            continue;
        }
        CDynasty* pParentDyn = itParent->second;
        pParentDyn->AddChild(pDyn);
    }

    // Build the chain up to the highest keyed parent
    // ==============================================
    pDynasty = pMainDynasty;
    hres = DynAux_BuildChainUp( pCtx, pDynasty, ppErrorObj);

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DynAux_BuildChainUp( IN IWbemContext* pCtx,
                                                                              OUT wmilib::auto_ptr<CDynasty> & pTop,
                                                                              OUT IWbemClassObject** ppErrorObj)
{
    *ppErrorObj = NULL;

    // Go up while there is a key at this level and we are dynamic
    // ===========================================================

    while( pTop->IsDynamic() && pTop->IsKeyed())
    {
        CVar vParentName;
        CWbemObject *pObj = (CWbemObject *) pTop->m_pClassObj;

        if(FAILED(pObj->GetSuperclassName(&vParentName)) ||
                vParentName.IsNull())
        {
            // Top level --- time to quit
            // ==========================
            return WBEM_S_NO_ERROR;
        }

        IWbemClassObject* pParent;
        HRESULT hres = Exec_GetObjectByPath(vParentName.GetLPWSTR(), 0,pCtx,&pParent,  ppErrorObj);
        if(FAILED(hres))
            return hres;

        if(pParent == NULL)
            return WBEM_E_PROVIDER_FAILURE;

        // SJS - Amendment is the same as Abstract
        if(!((CWbemClass*)pParent)->IsKeyed() ||
            ((CWbemClass*)pParent)->IsAbstract() ||
            ((CWbemClass*)pParent)->IsAmendment() )
        {
            // We are it
            // =========

            pParent->Release();
            return WBEM_S_NO_ERROR;
        }

        // Extend the dynasty by this class
        // ================================

        wmilib::auto_ptr<CDynasty> pNew( CDynasty::Create(pParent));
        if (NULL == pNew.get()) return WBEM_E_OUT_OF_MEMORY;
        pParent->Release();
        if(pNew->m_pClassObj == NULL)
        {
            return WBEM_E_PROVIDER_FAILURE;
        }
        pNew->AddChild(pTop.get());
        pTop.release();
        pTop.reset(pNew.release());
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::IsPutRequiredForClass(CWbemClass* pClass,
                            CWbemInstance* pInst, IWbemContext* pCtx,
                            BOOL bParentTakenCareOf)
{
    HRESULT hres;

    // Get the per-property put information out of the context
    // =======================================================

    BOOL bRestrictedPut = FALSE;
    BOOL bStrictNulls = FALSE;
    BOOL bPropertyList = FALSE;
    CWStringArray awsProperties;

    hres = GetContextPutExtensions(pCtx, bRestrictedPut, bStrictNulls,
                                bPropertyList, awsProperties);
    if(FAILED(hres))
        return hres;

    if(bRestrictedPut && bStrictNulls && !bPropertyList)
    {
        // All properties must be put, even the NULL ones
        // ==============================================

        return WBEM_S_NO_ERROR;
    }

    // Enumerate all properties of the class
    // =====================================

    long lEnumFlags = 0;
    if(bParentTakenCareOf)
    {
        // Only look at local (non-propagated) properties
        // ==============================================
        lEnumFlags = WBEM_FLAG_LOCAL_ONLY;
    }
    else
    {
        // We are in charge of our parent's properties
        // ===========================================
        lEnumFlags = WBEM_FLAG_NONSYSTEM_ONLY;
    }

    pClass->BeginEnumeration(lEnumFlags);
    BSTR strName = NULL;
    while((hres = pClass->Next(0, &strName, NULL, NULL, NULL)) == S_OK)
    {
        hres = DoesNeedToBePut(strName, pInst, bRestrictedPut,
                            bStrictNulls, bPropertyList, awsProperties);
        SysFreeString(strName);
        if(hres == WBEM_S_NO_ERROR)
        {
            // Found a needed property
            // =======================

            return WBEM_S_NO_ERROR;
        }
        if(FAILED(hres))
            return hres;
    }

    // No properties of this class need to be put
    // ==========================================

    return WBEM_S_FALSE;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::DoesNeedToBePut(LPCWSTR wszName, CWbemInstance* pInst,
            BOOL bRestrictedPut, BOOL bStrictNulls, BOOL bPropertyList,
            CWStringArray& awsProperties)
{
    HRESULT hres;

    // Check if the property is a key
    // ==============================

    CVar vKey;
    pInst->GetPropQualifier((LPWSTR)wszName, L"key", &vKey);
    if(vKey.GetType() == VT_BOOL && vKey.GetBool())
    {
        // It's a key --- no such thing as updating its value, and this code
        // only applies to updates.
        // =================================================================

        return WBEM_S_FALSE;
    }

    // Determine if NULLness and or membership in the list play any role
    // =================================================================

    BOOL bCheckNullness = FALSE;
    BOOL bCheckMembership = FALSE;

    if(bRestrictedPut)
    {
        bCheckNullness = !bStrictNulls;
        bCheckMembership = bPropertyList;
    }
    else
    {
        bCheckNullness = TRUE;
        bCheckMembership = FALSE;
    }

    // Check NULLness and/or membership if required
    // ============================================

    BOOL bNullnessChecked = FALSE;
    BOOL bMembershipChecked = FALSE;

    if(bCheckNullness)
    {
        CVar vVal;
        hres = pInst->GetNonsystemPropertyValue((LPWSTR)wszName, &vVal);
        if(FAILED(hres))
            return hres;

        bNullnessChecked = !vVal.IsNull();
    }
    else
        bNullnessChecked = TRUE;

    if(bCheckMembership)
    {
        int nIndex = awsProperties.FindStr(wszName, CWStringArray::no_case);
        bMembershipChecked = (nIndex >= 0);
    }
    else
        bMembershipChecked = TRUE;

    // Make sure that both NULLness and membership either checked out or were
    // not required
    // ======================================================================

    if(bMembershipChecked && bNullnessChecked)
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_S_FALSE;
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::GetContextPutExtensions(IWbemContext* pCtx,
            BOOL& bRestrictedPut, BOOL& bStrictNulls, BOOL& bPropertyList,
            CWStringArray& awsProperties)
{
    HRESULT hres;

    if(pCtx == NULL)
    {
        //
        // Default is: no restructions, which makes the rest of the properties
        // irrelevant
        //

        bRestrictedPut = FALSE;
        return WBEM_S_NO_ERROR;
    }

    // Initialize out-params
    // =====================

    bRestrictedPut = FALSE;
    bStrictNulls = FALSE;
    bPropertyList = FALSE;
    awsProperties.Empty();

    // Check if the context is even present
    // ====================================

    if(pCtx == NULL)
        return WBEM_S_NO_ERROR;

    // Check if put extensions are specified
    // =====================================

    hres = GetContextBoolean(pCtx, L"__PUT_EXTENSIONS", &bRestrictedPut);
    if(FAILED(hres)) return hres;

    if(!bRestrictedPut)
        return WBEM_S_NO_ERROR;

    // Check if NULLs are strict
    // =========================

    hres = GetContextBoolean(pCtx, L"__PUT_EXT_STRICT_NULLS",
                &bStrictNulls);
    if(FAILED(hres)) return hres;

    // Check if the list of properties is available
    // ============================================

    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);

    hres = pCtx->GetValue(L"__PUT_EXT_PROPERTIES", 0, &v);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_NOT_FOUND)
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            ERRORTRACE((LOG_WBEMCORE, "Error retrieving list of properties "
                        "from context: %X\n", hres));
            return hres;
        }
    }

    if(V_VT(&v) != (VT_BSTR | VT_ARRAY))
    {
        ERRORTRACE((LOG_WBEMCORE, "Invalid type is used for "
            "the list of properties in the context: must be "
            "string array.  The value will be ignored\n"));
        return WBEM_S_NO_ERROR;
    }

    bPropertyList = TRUE;

    // Transfer property names to the array
    // ====================================

    CSafeArray saProperties(V_ARRAY(&v), VT_BSTR,
                    CSafeArray::no_delete | CSafeArray::bind);

    for(int i = 0; i < saProperties.Size(); i++)
    {
        BSTR strProp = saProperties.GetBSTRAt(i);
        CSysFreeMe sfm(strProp);
        if (strProp)
        {
            if (CFlexArray::no_error != awsProperties.Add(strProp))
                return WBEM_E_OUT_OF_MEMORY;
        }  
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::GetContextBoolean(IWbemContext* pCtx,
                LPCWSTR wszName, BOOL* pbValue)
{
    HRESULT hres;
    *pbValue = FALSE;

    //
    // NULL context means "FALSE"
    //

    if(pCtx == NULL)
        return WBEM_S_NO_ERROR;

    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);

    hres = pCtx->GetValue((LPWSTR)wszName, 0, &v);
    if(FAILED(hres))
    {
        if(hres == WBEM_E_NOT_FOUND)
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            ERRORTRACE((LOG_WBEMCORE, "Error retrieving context property %S:"
                        " %X\n", wszName, hres));
            return hres;
        }
    }

    if(V_VT(&v) != VT_BOOL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Invalid type is used for "
            "%S property of the context: must be "
            "boolean.  The value will be ignored\n", wszName));
        return WBEM_S_NO_ERROR;
    }

    if(V_BOOL(&v) != VARIANT_TRUE)
    {
        return WBEM_S_NO_ERROR;
    }

    *pbValue = TRUE;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::FindKeyRoot(LPCWSTR wszClassName,
                                IWbemClassObject** ppKeyRootClass)
{
    //
    // Check if the namespace is still valid (returns if not)
    //
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    //
    // Call on the database to do the job
    //

    hRes = CRepository::FindKeyRoot(m_pSession, m_pNsHandle, wszClassName, ppKeyRootClass);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::GetNormalizedPath( BSTR pstrPath,
                                                BSTR* pstrStandardPath )
{
    //
    // Check if the namespace is still valid (returns if not)
    //
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    //
    // check parameters.
    //

    if ( NULL == pstrPath || NULL == pstrStandardPath )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    HRESULT hres;
    *pstrStandardPath = NULL;

    // Parse it
    // ========

    CObjectPathParser Parser;
    ParsedObjectPath* pPath;

    int nRes = Parser.Parse(pstrPath, &pPath);

    if( nRes != CObjectPathParser::NoError )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    CDeleteMe<ParsedObjectPath> dm(pPath);

    //
    // Figure out the class that defined the key
    //

    IWbemClassObject* pKeyRootClass = NULL;

    hres = FindKeyRoot(pPath->m_pClass, &pKeyRootClass);

    if(FAILED(hres))
    {
        return hres;
    }

    CReleaseMe rm(pKeyRootClass);

    _IWmiObject* pWmiObject = NULL;
    hres = pKeyRootClass->QueryInterface(IID__IWmiObject, (void**)&pWmiObject);

    if(FAILED(hres))
    {
        return hres;
    }

    CReleaseMe rm1(pWmiObject);

    long    lHandle = 0L;
    ULONG   uFlags = 0L;
    WCHAR   wszClassName[64];
    DWORD   dwBuffSize = 64;
    DWORD   dwBuffUsed = 0;
    BOOL    fNull = FALSE;
    LPWSTR  pwszName = wszClassName;
    LPWSTR  pwszDelete = NULL;

    // Try to read in the class name.  Allocate a buffer if we have to.
    hres = pWmiObject->ReadProp( L"__CLASS", 0L, dwBuffSize, NULL, NULL, &fNull, &dwBuffUsed, pwszName );

    if ( FAILED( hres ) )
    {
        if ( WBEM_E_BUFFER_TOO_SMALL == hres )
        {
            pwszName = new WCHAR[dwBuffUsed/2];

            if ( NULL == pwszName )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                dwBuffSize = dwBuffUsed;

                // Try to read in the class name.  Allocate a buffer if we have to.
                hres = pWmiObject->ReadProp( L"__CLASS", 0L, dwBuffSize, NULL, NULL, &fNull, &dwBuffUsed, pwszName );

                if ( FAILED( hres ) )
                {
                    delete [] pwszName;
                    return hres;
                }

                // Allows for scoped cleanup only if we alloctaed something
                pwszDelete = pwszName;
            }
        }
        else
        {
            return hres;
        }
    }

    //
    // Ensures proper cleanup.  If we didn't allocate a buffer to delete,
    // this pointer will be NULL.
    //
    CVectorDeleteMe<WCHAR> vdm1(pwszDelete);

    // oop
    if ( fNull )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    //
    // want to normalize out the single key prop exception
    //

    if ( pPath->m_dwNumKeys == 1 )
    {
        delete pPath->m_paKeys[0]->m_pName;
        pPath->m_paKeys[0]->m_pName = NULL;
    }

    //
    // set the normalized class on the path if different
    // than the one in the path.
    //

    if ( wbem_wcsicmp( pPath->m_pClass, pwszName ) != 0 )
    {
        if ( !pPath->SetClassName( pwszName ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    //
    // now unparse the normalized path
    //

    LPWSTR wszNormPath;

    nRes = CObjectPathParser::Unparse( pPath, &wszNormPath );

    if ( nRes != CObjectPathParser::NoError )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    *pstrStandardPath = SysAllocString( wszNormPath );

    delete wszNormPath;

    return *pstrStandardPath != NULL ? WBEM_S_NO_ERROR : WBEM_E_OUT_OF_MEMORY;
}

class CRevertCallSec
{
    BOOL m_bEnabled;
    IUnknown * m_pCallSec;
public:
    CRevertCallSec(BOOL bEnabled,IUnknown * pCallSec):
        m_bEnabled(bEnabled),
        m_pCallSec(pCallSec){};
    ~CRevertCallSec(){
        if (m_bEnabled){
            IUnknown * pOld = NULL;
            CoSwitchCallContext(m_pCallSec,&pOld); 
        }    
    };
};

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalGetClass(
            LPCWSTR wszClassName,
            IWbemClassObject** ppClass)
{
    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    HRESULT hr;

    // determine if there is a call context.  If there is, then we
    // dont do anything.

    IServerSecurity * pSec = NULL;
    IWbemCallSecurity * pCallSec = NULL;
    IUnknown * pOld = NULL, *pNew = NULL;
    hr = CoGetCallContext(IID_IServerSecurity, (void**)&pSec);
    if(SUCCEEDED(hr))
    {
        pSec->Release();
    }
    else
    {
        // provider subsystem needs a call context, so create on

        pCallSec = CWbemCallSecurity::CreateInst();
        if(pCallSec == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    CReleaseMe rm(pCallSec);

    // initialize call security for provider sub system

    if(pCallSec)
    {
        hr = pCallSec->CloneThreadContext(TRUE);
        if(FAILED(hr))
            return hr;
        hr = CoSwitchCallContext(pCallSec, &pOld);
        if(FAILED(hr))
            return hr;
    }
    CRevertCallSec Revert(pCallSec?TRUE:FALSE,pOld);   // SEC:REVIEWED 2002-03-22 : Assumes success; why is this here? It is the only occurrence.

    hr = Exec_GetObjectByPath((LPWSTR)wszClassName, 0, pContext, ppClass, NULL);

    return hr;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalGetInstance(
            LPCWSTR wszPath,
            IWbemClassObject** ppInstance)
{
    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    return Exec_GetObjectByPath((LPWSTR)wszPath, 0, pContext, ppInstance, NULL);
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalExecQuery(
             LPCWSTR wszQueryLanguage,
             LPCWSTR wszQuery,
             long lFlags,
             IWbemObjectSink* pSink)
{
    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSimpleWrapperSink ws(pSink);
    return CQueryEngine::ExecQuery(this, (LPWSTR)wszQueryLanguage,
                (LPWSTR)wszQuery, lFlags, pContext, &ws);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalCreateInstanceEnum(
             LPCWSTR wszClassName,
             long lFlags,
             IWbemObjectSink* pSink)
{
    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSimpleWrapperSink ws(pSink);
    return Exec_CreateInstanceEnum((LPWSTR)wszClassName, lFlags, pContext, &ws);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::InternalPutInstance(
             IWbemClassObject* pInst)
{
    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSynchronousSink* pSink = CSynchronousSink::Create();
    if(pSink == NULL) return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe rm1(pSink);

    Exec_PutInstance(pInst, 0, pContext, pSink);

    HRESULT hres = WBEM_E_CRITICAL_ERROR;
    pSink->GetStatus(&hres, NULL, NULL);
    return hres;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::GetDbInstance(
             LPCWSTR wszDbKey,
             IWbemClassObject** ppInstance
             )
{
    // ESS uses this one
    return CRepository::GetObject(m_pSession, m_pScopeHandle, wszDbKey, 0, ppInstance);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CWbemNamespace::GetDbReferences(
             IWbemClassObject* pEndpoint,
             IWbemObjectSink* pSink)
{
    LPWSTR wszRelPath = ((CWbemObject*)pEndpoint)->GetRelPath();
    CVectorDeleteMe<WCHAR> dm(wszRelPath);

    CSimpleWrapperSink ws(pSink);

    HRESULT hRes = CRepository::GetInstanceRefs(m_pSession,m_pScopeHandle, wszRelPath, &ws);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::InternalPutStaticClass(
             IWbemClassObject* pClass)
{
    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    IWbemContext *pContext = NULL ;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
    {
        pContext = ConfigMgr::GetNewContext();
        if ( pContext == NULL )
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pContext = pReq->GetContext();
        pContext->AddRef () ;   //for CReleaseMe
    }

    CReleaseMe _1_pContext (pContext) ;

    CSynchronousSink* pSink = CSynchronousSink::Create();
    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe rm1(pSink);

    Exec_PutClass( pClass, 0, pContext, pSink, TRUE );

    HRESULT hres = WBEM_E_CRITICAL_ERROR;
    pSink->GetStatus(&hres, NULL, NULL);
    return hres;
}


//***************************************************************************
//
//  CWbemNamespace::AdjustPutContext
//
//***************************************************************************

HRESULT CWbemNamespace::AdjustPutContext(
    IWbemContext *pCtx
    )
{
    // See if per-property puts are being used.
    // ========================================

    HRESULT hRes;

    if (pCtx == 0)
        return WBEM_S_NO_ERROR;

    CVARIANT v;
    hRes = pCtx->GetValue(L"__PUT_EXTENSIONS", 0, &v);

    if (SUCCEEDED(hRes))
    {
        // If here, they are being used.  Next we have to check and see
        // if the reentrancy flag is set or not.
        // =============================================================

        hRes = pCtx->GetValue(L"__PUT_EXT_CLIENT_REQUEST", 0, &v);
        if (SUCCEEDED(hRes))
        {
            pCtx->DeleteValue(L"__PUT_EXT_CLIENT_REQUEST", 0);
            return WBEM_S_NO_ERROR;
        }

        // If here, we have to clear out the put extensions.
        // =================================================
        pCtx->DeleteValue(L"__PUT_EXTENSIONS", 0);
        pCtx->DeleteValue(L"__PUT_EXT_CLIENT_REQUEST", 0);
        pCtx->DeleteValue(L"__PUT_EXT_ATOMIC", 0);
        pCtx->DeleteValue(L"__PUT_EXT_PROPERTIES", 0);
        pCtx->DeleteValue(L"__PUT_EXT_STRICT_NULLS", 0);
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CWbemNamespace::MergeGetKeysCtx
//
//***************************************************************************
//
HRESULT CWbemNamespace::MergeGetKeysCtx(
    IN IWbemContext *pCtx
    )
{
    HRESULT hRes;
    if (pCtx == 0)
        return WBEM_S_NO_ERROR;
    CVARIANT v;
    v.SetBool(TRUE);
    hRes = pCtx->SetValue(L"__GET_EXTENSIONS", 0, &v);
    hRes |= pCtx->SetValue(L"__GET_EXT_KEYS_ONLY", 0, &v);
    hRes |= pCtx->SetValue(L"__GET_EXT_CLIENT_REQUEST", 0, &v);
    return hRes;
}






//***************************************************************************
//
//  CWbemNamespace::CheckNs
//
//  Does a quick check on the available system resources before allowing
//  a new call to proceed.  Retries for 30 seconds.
//
//***************************************************************************
//
HRESULT CWbemNamespace::CheckNs()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (g_bDontAllowNewConnections || m_bShutDown)
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    // Quick memory check. If we are strapped for RAM/Pagefile,
    // wait a while and try again. Requirements are 1 meg of
    // available RAM and 1 meg of available page file.

    int nRetries = 0;

    for (int i = 0; i < 30; i++)
    {
        MEMORYSTATUS ms;
        GlobalMemoryStatus(&ms);

        if (ms.dwMemoryLoad < 99)
            return WBEM_S_NO_ERROR;

        // If here, we have to be careful.  The system is loaded at 99%.
        // =============================================================
        if (nRetries > 30)
        {
            // Sixty seconds waiting for enough memory. Give up.
            return WBEM_E_OUT_OF_MEMORY;
        }

        DWORD dwPracticalMemory = ms.dwAvailPhys + ms.dwAvailPageFile;

        if (dwPracticalMemory < 0x200000)   // 2 meg
        {
            Sleep(2000);
            // Try a 1 meg allocation to see if will succeed.
            LPVOID pTestMem = HeapAlloc(GetProcessHeap(), 0, 0x100000);
            if (pTestMem == 0)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            // Free the memory.  The previous allocation may have
            // grown the pagefile and thus we can succeed.
            HeapFree(GetProcessHeap(), 0, pTestMem);
            nRetries++;
        }
        else
        {
            // If here, we have a load of 99%, yet more than 2 meg of memory
            // still available. Now 99% may mean there is a lot of free memory
            // because the machine has huge resources or it may mean we are just
            // about out of memory completely.  We need hard data. If we
            // have at least 5 meg anyway, this is clearly adequate, so we just
            // break out of the loop and let the call continue.
            //
            // Otherwise, we have between 2 and 5 meg, which is starting to push
            // it. We enter a waiting loop and hope for more memory.  After a few
            // retries if we continue to have between 2 and 5 meg, we'll let the call
            // through and let the arbitrator deal with it, since the system appears
            // to have stabilized at this usage.
            //
            hr = WBEM_S_NO_ERROR;

            if (ms.dwAvailPhys < 0x200000)  // If low on physical memory back off a bit for recovery via pagefile
                Sleep(1000);

            if (dwPracticalMemory > 0x100000 * 5)  // > 5 meg; break out immediately
                break;

            // Under 5 meg free, retry a few times to let things clear up and get
            // more memory.  But, we succeed in the end anyway.
            // ==================================================================
            Sleep(1000);
            if (nRetries++ > 5)
            {
                hr = WBEM_S_NO_ERROR;
                break;
            }
        }
    }

    return hr;
}


//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::UniversalConnect(
    CWbemNamespace  *pParent,
    IWbemContext    *pCtx,
    LPCWSTR pszNewScope,
    LPCWSTR pszAssocSelector,
    LPCWSTR pszUserName,
    _IWmiCallSec    *pCallSec,
    _IWmiUserHandle *pUser,
    DWORD  dwUserFlags,
    DWORD  dwInternalFlags,
    DWORD  dwSecFlags,
    DWORD  dwPermission,
    BOOL   bForClient,
    BOOL   bRepositOnly,
    LPCWSTR pszClientMachineName,
    DWORD dwClientProcessID,
    IN  REFIID riid,
    OUT LPVOID *pConnection
    )
{
    HRESULT hRes;
    if(dwUserFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY)
        bRepositOnly = TRUE;
    
    // Validate.
    if (pszNewScope == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (riid != IID_IWbemServices )
        return E_NOINTERFACE;

    // If no parent, then this is an 'absolute' connect.
    // =================================================

    if (!pParent)
    {
        CWbemNamespace *pNs = CWbemNamespace::CreateInstance();
        if (NULL == pNs) return WBEM_E_OUT_OF_MEMORY;

        hRes = pNs->Initialize(
                        LPWSTR(pszNewScope),
                        LPWSTR(pszUserName),
                        dwSecFlags,
                        dwPermission,
                        bForClient,
                        bRepositOnly,
                        pszClientMachineName,
                        dwClientProcessID,
                        FALSE,
                        NULL);

        if (FAILED(hRes))
        {
            pNs->Release();
            return hRes;
        }

        pNs->SetIsProvider((dwUserFlags & WBEM_FLAG_CONNECT_PROVIDERS)?TRUE:FALSE);

        *pConnection = pNs;
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_E_INVALID_OPERATION;
    }

}

//***************************************************************************
//
//  Called by _IWmiCoreServices to establish a connection from the 'outside'.
//
//***************************************************************************
//
HRESULT CWbemNamespace::PathBasedConnect(
            /* [in] */ LPCWSTR pszPath,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ ULONG uClientFlags,
            /* [in] */ DWORD dwSecFlags,
            /* [in] */ DWORD dwPermissions,
            /* [in] */ ULONG uInternalFlags,
            /* [in] */ LPCWSTR pszClientMachineName,
            /* [in] */ DWORD dwClientProcessID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices
            )
{
    HRESULT hRes;

    BOOL bForClient = FALSE;

    if ((uInternalFlags & WMICORE_CLIENT_ORIGIN_LOCAL) ||
        (uInternalFlags & WMICORE_CLIENT_ORIGIN_REMOTE) ||
        (uInternalFlags & WMICORE_CLIENT_TYPE_ALT_TRANSPORT)
       )
    {
        bForClient = TRUE;
    }

    hRes = UniversalConnect(
        0,                          // Parent CWbemNamespace; not known
        pCtx,                       // Context
        pszPath,                    // Path
        0,                          // No assoc selector at this point
        pszUser,                    // User
        0,                          // Call security
        0,                          // User handle
        uClientFlags,               // Flags from client
        uInternalFlags,             // Internal flags
        dwSecFlags,                 // Copy
        dwPermissions,              // Copy
        bForClient,                 // For client?
        FALSE,                      // Repository only
        pszClientMachineName,
        dwClientProcessID,
        riid,
        pServices
        );

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::InitNewTask(
    IN CAsyncReq *pReq,
    IN _IWmiFinalizer *pFnz,
    IN ULONG uTaskType,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pAsyncClientSink
    )
{
    HRESULT hRes;

    if (pReq == 0 || pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;
    
    // Create a task for tracking the operation.
    // =========================================

    CWmiTask *pNewTask = CWmiTask::CreateTask();
    if (pNewTask == 0)
        return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe _2(pNewTask);

    hRes = pNewTask->Initialize(this, uTaskType, pCtx, pAsyncClientSink,pReq);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetTaskHandle((_IWmiCoreHandle *) pNewTask);
    if (FAILED(hRes))
        return hRes;

    pReq->SetTaskHandle((_IWmiCoreHandle *) pNewTask);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::CreateSyncFinalizer(
        IN  IWbemContext *pCtx,
        IN _IWmiFinalizer **pResultFnz
        )
{
    HRESULT hRes;

    ULONG uFlags = WMI_FNLZR_FLAG_FAST_TRACK;

    // Determine calling context to see if the call is reentrant or what.
    // ==================================================================

    IWbemCausalityAccess *pCaus = 0;
    if (pCtx != 0)
    {
        hRes = pCtx->QueryInterface(IID_IWbemCausalityAccess, (LPVOID *) &pCaus);
        if (SUCCEEDED(hRes))
        {
            long lNumParents = 0;
            long lNumSiblings = 0;
            pCaus->GetHistoryInfo(&lNumParents, &lNumSiblings);
            if (lNumParents)
                uFlags = WMI_FNLZR_FLAG_FAST_TRACK;
            pCaus->Release();
        }
    }

    // Create Finalizer.
    // =================
    _IWmiFinalizer *pFnz = 0;
    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _(pFnz);

    hRes = pFnz->Configure(uFlags, 0);
    if (FAILED(hRes))
        return hRes;

    pFnz->AddRef();
    *pResultFnz = pFnz;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//



HRESULT CWbemNamespace::CreateAsyncFinalizer(
    IWbemContext *pCtx,
    IWbemObjectSink *pStartingSink,
    _IWmiFinalizer **pResultFnz,
    IWbemObjectSink **pResultSinkEx
    )
{
    HRESULT hRes;

    ULONG uFlags = WMI_FNLZR_FLAG_FAST_TRACK;

    if ( m_bForClient )
        uFlags = WMI_FNLZR_FLAG_DECOUPLED;

    // Determine calling context to see if the call is reentrant or what.
    // ==================================================================
    IWbemCausalityAccess *pCaus = 0;
    if (pCtx != 0)
    {
        hRes = pCtx->QueryInterface(IID_IWbemCausalityAccess, (LPVOID *) &pCaus);
        if (SUCCEEDED(hRes))
        {
            long lNumParents = 0;
            long lNumSiblings = 0;
            pCaus->GetHistoryInfo(&lNumParents, &lNumSiblings);
            if (lNumParents)
                uFlags = WMI_FNLZR_FLAG_FAST_TRACK;
            pCaus->Release();
        }
    }

    // Create Finalizer.
    // =================
    _IWmiFinalizer *pFnz = 0;
    hRes = m_pCoreSvc->CreateFinalizer(0, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _(pFnz);

    hRes = pFnz->Configure(uFlags, 0);
    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->SetDestinationSink(0, IID_IWbemObjectSink, (LPVOID) pStartingSink);

    if (FAILED(hRes))
        return hRes;

    hRes = pFnz->NewInboundSink(0, pResultSinkEx);
    if (FAILED(hRes))
        return hRes;

    pFnz->AddRef();
    *pResultFnz = pFnz;
    return WBEM_S_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Native async operations
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  InstEnum    Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  ClassEnum   Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  PutInst     Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  PutClass    Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  DelInst     Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  DelClass    Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  GetObject   Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//  ExecQuery   Sync[ ]  Async Impl[x]  AsyncEntry[x]
//  ExecMethod  Sync[ ]  Async Impl[x]  AsyncEntry[x]
//
//

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::DeleteClassAsync(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try
    {
        return _DeleteClassAsync(
            WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_DELETE_CLASS,
            0, 0, strClass, lFlags, pCtx, pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }    
}

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::CreateClassEnumAsync(
    const BSTR strParent,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try
    {
        return _CreateClassEnumAsync(
            WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_ENUM_CLASSES,
            0, 0, strParent, lFlags, pCtx, pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }    
}

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::PutClassAsync(
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try
    {
        return _PutClassAsync(
            WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_PUT_CLASS,
            0, 0, pObj, lFlags, pCtx, pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }    
}


//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemNamespace::PutInstanceAsync(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try
    {
        return _PutInstanceAsync(WMICORE_TASK_TYPE_ASYNC| WMICORE_TASK_PUT_INSTANCE,
                                              0, 0, pInst, lFlags, pCtx, pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::DeleteInstanceAsync(
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try
    {
    return _DeleteInstanceAsync(
        WMICORE_TASK_TYPE_ASYNC| WMICORE_TASK_DELETE_INSTANCE,
        0, 0, strObjectPath, lFlags, pCtx, pHandler
        );
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }    
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::CreateInstanceEnumAsync(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try
    {
    return _CreateInstanceEnumAsync(
        WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_ENUM_INSTANCES,
        0, 0,
        strClass, lFlags, pCtx, pHandler
        );
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }    
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::ExecQueryAsync(
    const BSTR strQueryFormat,
    const BSTR strQuery,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    try 
    {
        return _ExecQueryAsync(WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_EXEC_QUERY,
                                             0, 0,
                                            strQueryFormat, strQuery, lFlags, pCtx, pHandler);
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }    
}

//***************************************************************************
//
//***************************************************************************
//  ok
HRESULT CWbemNamespace::ExecMethodAsync(
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemObjectSink* pHandler
    )
{
    try
    {
        return _ExecMethodAsync(WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_EXEC_METHOD,
                                                0, 0,
                                                ObjectPath,
                                                MethodName,
                                                lFlags,
                                                pCtx,
                                                pInParams,
                                                pHandler);
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::GetObjectAsync(
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    try
    {
        return _GetObjectAsync(
            WMICORE_TASK_TYPE_ASYNC | WMICORE_TASK_GET_OBJECT,
            0, 0,
            strObjectPath,
            lFlags,
            pCtx,
            pHandler
            );
    }
    catch (...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }
}


//
// can throw
//
///////////////////////////////////////////////////////////////////////
HRESULT CWbemNamespace::_PutInstanceAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::PutInstanceAsync"
        "   long lFlags = 0x%X\n"
        "   IWbemClassObject *pInst = 0x%X\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        lFlags,
        pInst,
        pHandler
        ));

    // Parameter and object validation.
    // ================================

    if (pFnz == 0 && pHandler == 0)
       return WBEM_E_INVALID_PARAMETER;

    if (pInst == NULL)
       return WBEM_E_INVALID_PARAMETER;

    long lMainFlags = lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS & ~WBEM_FLAG_OWNER_UPDATE;

    if (lMainFlags != WBEM_FLAG_CREATE_ONLY &&
        lMainFlags != WBEM_FLAG_UPDATE_ONLY &&
        lMainFlags != WBEM_FLAG_CREATE_OR_UPDATE)
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Check for per-property put context info.
    // ========================================

    if (pCtx) AdjustPutContext(pCtx);

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Schedule the request.
    // =====================

    wmilib::auto_ptr<CAsyncReq_PutInstanceAsync> pReq;

    pReq.reset(new CAsyncReq_PutInstanceAsync( this, pInst, lFlags, pPseudoSink, pCtx));

    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;
    }
    pReq.release();

    return hRes;
}


//
// can throw
//
//////////////////////////////////////////////////////
HRESULT CWbemNamespace::_DeleteClassAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strClassOrg,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Parameter validation.
    // =====================

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strClassOrg == 0 || strClassOrg[0] == 0)
            return WBEM_E_INVALID_PARAMETER;

    if (wcslen_max(strClassOrg,g_IdentifierLimit) > g_IdentifierLimit) return WBEM_E_QUOTA_VIOLATION;

    WCHAR * strClass;
    if (L'\\' == strClassOrg[0]  || L'/' == strClassOrg[0] )
    {
        strClass = wcschr(strClassOrg, L':');
        if (NULL == strClass) return WBEM_E_INVALID_OBJECT_PATH;
        strClass++;
        if (0 == strClass[0]) return WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        strClass = strClassOrg;
    }

    if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_OWNER_UPDATE)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Create request.
    // ===============

    wmilib::auto_ptr<CAsyncReq_DeleteClassAsync> pReq;
    pReq.reset(new CAsyncReq_DeleteClassAsync( this, strClass, lFlags, pPseudoSink, pCtx));
    
    if (pReq.get() == NULL) return WBEM_E_OUT_OF_MEMORY;
    if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;
    }
    pReq.release();

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_CreateClassEnumAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strParent,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateClassEnumAsync\n"
        "   BSTR strParent = %S\n"
        "   long lFlags = 0x%X\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strParent,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;
    
    if (strParent)
    {
        if (wcslen_max(strParent,g_IdentifierLimit) > g_IdentifierLimit) 
            return WBEM_E_QUOTA_VIOLATION;
    }

    if (lFlags & ~(WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW | WBEM_FLAG_SEND_STATUS) & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);


    // Add this request to the queue.
    // ==============================

    wmilib::auto_ptr<CAsyncReq_CreateClassEnumAsync> pReq;
    pReq.reset(new CAsyncReq_CreateClassEnumAsync(this, strParent, lFlags, pPseudoSink,pCtx));

    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;
    }
    pReq.release();

    return hRes;

}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_PutClassAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    CVARIANT vClass;
    if (pObj)
    {
        hRes = pObj->Get(L"__CLASS", 0, &vClass, 0, 0);
    }
    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::PutClassAsync\n"
        "   long lFlags = 0x%X\n"
        "   IWbemClassObject *pObj = 0x%X\n"
        "   IWbemObjectSink* pNotify = 0x%X\n"
        "   __CLASS=%S\n",
        lFlags,
        pObj,
        pHandler,
        vClass.GetStr()
        ));

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pObj == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    long lTestFlags = lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_OWNER_UPDATE
        & ~WBEM_MASK_UPDATE_MODE & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS;

    if (!((lTestFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
          (lTestFlags == WBEM_FLAG_UPDATE_ONLY) ||
          (lTestFlags == WBEM_FLAG_CREATE_ONLY) ||
          (lTestFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
          (lTestFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
          (lTestFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
          (lTestFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE))))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Create request.
    // ===============

    wmilib::auto_ptr<CAsyncReq_PutClassAsync> pReq;
    pReq.reset(new CAsyncReq_PutClassAsync(this, pObj, lFlags, pPseudoSink, pCtx));
   
    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;        
    }
    pReq.release();

    return hRes;
}




//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::_DeleteInstanceAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    READONLY const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::DeleteInstance\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strObjectPath, lFlags, pHandler
        ));

    // Parameter validation.
    // =====================

    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;
    
    if (strObjectPath == 0 || strObjectPath[0] == 0) 
        return WBEM_E_INVALID_PARAMETER;
    
    if (wcslen_max(strObjectPath,g_PathLimit) > g_PathLimit) 
        return WBEM_E_QUOTA_VIOLATION;
        
    if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_OWNER_UPDATE)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & WBEM_FLAG_OWNER_UPDATE)
    {
        lFlags -= WBEM_FLAG_OWNER_UPDATE;
        lFlags += WBEM_FLAG_NO_EVENTS;
    }

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Create request.
    // ===============

    wmilib::auto_ptr<CAsyncReq_DeleteInstanceAsync> pReq;
    pReq.reset(new CAsyncReq_DeleteInstanceAsync(this, strObjectPath, lFlags, pPseudoSink, pCtx));

    if (NULL == pReq.get())return WBEM_E_OUT_OF_MEMORY;
    if ( NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;        
    }
    pReq.release();

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::CreateInstanceEnumAsync
//
//  Schedules an asynchrnous request that eventuall calls
//  Exec_CreateInstanceEnum.
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::_CreateInstanceEnumAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateInstanceEnumAsync\n"
        "   BSTR Class = %S\n"
        "   long lFlags = 0x%X\n"
        "   IWbemObjectSink pHandler = 0x%X\n",
        strClass,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strClass == 0 || strClass[0] == 0)
            return WBEM_E_INVALID_PARAMETER;

   if (wcslen_max(strClass,g_IdentifierLimit) > g_IdentifierLimit) 
            return WBEM_E_QUOTA_VIOLATION;

    if (lFlags & ~(WBEM_FLAG_DEEP | WBEM_FLAG_SHALLOW | WBEM_FLAG_SEND_STATUS |
        WBEM_FLAG_USE_AMENDED_QUALIFIERS | WBEM_FLAG_DIRECT_READ))
            return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add this request to the async queue.
    // ====================================

    wmilib::auto_ptr<CAsyncReq_CreateInstanceEnumAsync> pReq;
    pReq.reset(new CAsyncReq_CreateInstanceEnumAsync(this, strClass, lFlags, pPseudoSink,pCtx));
        
    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if (NULL == pReq->GetContext())  return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;        
    }
    pReq.release();

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::ExecQueryAsync
//
//  Schedules an asynchronous request that eventually calls
//  CQueryEngine::ExecQuery (see qengine.h)
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::_ExecQueryAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strQueryFormat,
    const BSTR strQuery,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecQueryAsync\n"
        "   BSTR QueryFormat = %S\n"
        "   BSTR Query = %S\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strQueryFormat,
        strQuery,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (strQueryFormat == 0 || strQuery == 0)
        return WBEM_E_INVALID_PARAMETER;
    
    if ( 0 == strQueryFormat[0] || 0 == strQuery[0])
        return WBEM_E_INVALID_PARAMETER;

    if (wcslen_max(strQuery,g_QueryLimit) > g_QueryLimit) return WBEM_E_QUOTA_VIOLATION;            

    if (lFlags & ~WBEM_FLAG_PROTOTYPE & ~WBEM_FLAG_SEND_STATUS &
            ~WBEM_FLAG_ENSURE_LOCATABLE & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS &
            ~WBEM_FLAG_KEEP_SHAPE & ~WBEM_FLAG_DIRECT_READ
            )
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe rmPseudoSink(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add the request to the queue.
    // =============================

    // will throw CX_MemoryException
    wmilib::auto_ptr<CAsyncReq_ExecQueryAsync> pReq;
    pReq.reset(new CAsyncReq_ExecQueryAsync(this, strQueryFormat, strQuery, lFlags,pPseudoSink, pCtx));
    
    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if ( NULL == pReq->GetContext() )  return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    rmPseudoSink.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;        
    }
    pReq.release();

    return hRes;
}

//
//
//  CWbemNamespace::_GetObjectAsync
//
//  Schedules an asynchrnous request that eventuall calls Exec_GetObjectByPath.
//
//  Parameters and return values are described in help
//
// throws or return
//
///////////////////////////////////////////////////////////////
HRESULT CWbemNamespace::_GetObjectAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::GetObjectAsync\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemObjectSink* pHandler = 0x%X\n",
        strObjectPath,
        lFlags,
        pHandler
        ));

    // Parameter validation.
    // =====================
    if (pFnz == 0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_DIRECT_READ)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();    // Compensate for CReleaseMe to follow
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add request to the async queue.
    // ===============================

    wmilib::auto_ptr<CAsyncReq_GetObjectAsync> pReq;
    pReq.reset(new CAsyncReq_GetObjectAsync(this, strObjectPath, lFlags, pPseudoSink, pCtx));
    
    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes))  return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask(0);
        return hRes;
    }
    pReq.release();

    return hRes;
}


//
//
//  CWbemNamespace::ExecMethodAsync
//
//  can throw
//
//////////////////////////////////////////////////////////
HRESULT CWbemNamespace::_ExecMethodAsync(
    IN ULONG uInternalFlags,
    IN _IWmiFinalizer *pFnz,
    IN _IWmiCoreHandle *phTask,
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemObjectSink* pHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecMethodAsync\n"
        "   BSTR ObjectPath = %S\n"
        "   BSTR MethodName = %S\n"
        "   long lFlags = %d\n"
        "   IWbemClassObject * pIn = 0x%X\n",
        ObjectPath, MethodName, lFlags, pInParams
        ));

    // Parameter validation.
    // =====================
    if (pFnz ==0 && pHandler == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (lFlags & ~WBEM_FLAG_SEND_STATUS)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    IWbemObjectSink *pPseudoSink = 0;
    if (pFnz == 0)
    {
        hRes = CreateAsyncFinalizer(pCtx, pHandler, &pFnz, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
    }
    else // borrowed finalizer
    {
        hRes = pFnz->NewInboundSink(0, &pPseudoSink);
        if (FAILED(hRes))
            return hRes;
        pFnz->AddRef();
    }

    CReleaseMe _1(pPseudoSink);
    CReleaseMe _2(pFnz);

    // Add request to the async queue.
    // ===============================

    wmilib::auto_ptr<CAsyncReq_ExecMethodAsync> pReq;
    pReq.reset(new CAsyncReq_ExecMethodAsync(this,
                                        ObjectPath,
                                        MethodName,
                                        lFlags,
                                        pInParams,
                                        pPseudoSink,
                                        pCtx));

    if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;
    if ( NULL == pReq->GetContext() ) return WBEM_E_OUT_OF_MEMORY;

    hRes = InitNewTask(pReq.get(), pFnz, uInternalFlags, pReq->GetContext(), pHandler);
    if (FAILED(hRes)) return hRes;

    _1.release();
    hRes = ConfigMgr::EnqueueRequest(pReq.get());
    if (FAILED(hRes))
    {
        pFnz->CancelTask ( 0 );
        return hRes;        
    }
    pReq.release();

    return hRes;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//  Native sync operations
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//***************************************************************************
//
//  CWbemNamespace::DeleteClass
//
//  Calls DeleteClassAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************
//
HRESULT CWbemNamespace::DeleteClass(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    try
    {
        DEBUGTRACE((LOG_WBEMCORE,
            "CALL CWbemNamespace::DeleteClass"
            "   BSTR Class = %S\n"
            "   long lFlags = 0x%X\n",
            strClass,
            lFlags
            ));

        // Parameter validation.
        // =====================

        if (lFlags
            & ~WBEM_FLAG_RETURN_IMMEDIATELY
            & ~WBEM_FLAG_OWNER_UPDATE
            )
            return WBEM_E_INVALID_PARAMETER;

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Create Finalizer.
        // =================

        _IWmiFinalizer *pFnz = 0;
        hRes = CreateSyncFinalizer(pCtx, &pFnz);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pFnz);

        ULONG uTaskType = WMICORE_TASK_DELETE_CLASS;
        if (ppResult)
            uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
        else
            uTaskType |= WMICORE_TASK_TYPE_SYNC;

        // Call the async side.
        // ====================

        hRes = _DeleteClassAsync(uTaskType, pFnz, 0, strClass, 
                                                lFlags & ~WBEM_RETURN_IMMEDIATELY,pCtx, NULL);

        if (FAILED(hRes))
            return hRes;

        // Check for the two return paradigms.
        // ===================================

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        {
            HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
            if (FAILED(hResTemp))
                return hResTemp;
        }
        if (ppResult)
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
        }
        return hRes;
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;        
    }
}

//***************************************************************************
//
//  CWbemNamespace::PutClass
//
//  Calls PutClassAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************

HRESULT CWbemNamespace::PutClass(
    READONLY IWbemClassObject* pObj,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    CVARIANT vClass;
    if (pObj)
    {
        hRes = pObj->Get(L"__CLASS", 0, &vClass, 0, 0);
    }

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::PutClass\n"
        "   long lFlags = 0x%X\n"
        "   IWbemClassObject *pObj = 0x%X\n"
        "   __CLASS=%S\n",
        lFlags,
        pObj,
        vClass.GetStr()
        ));


    if (lFlags
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_OWNER_UPDATE
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_CREATE_OR_UPDATE
        & ~WBEM_FLAG_UPDATE_ONLY
        & ~WBEM_FLAG_CREATE_ONLY
        & ~WBEM_FLAG_UPDATE_SAFE_MODE
        & ~WBEM_FLAG_UPDATE_FORCE_MODE
        )
        return WBEM_E_INVALID_PARAMETER;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        if( ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)&&(ppResult==NULL))
        {
            HANDLE hCurrentToken;
            if(OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE,
                                &hCurrentToken))
            {
                //
                // Got a thread token --- cannot fast-track because otherwise we
                // will have a thread token on a thread executing internal code
                //

                CloseHandle(hCurrentToken);
            }
            else if (CWbemQueue::GetCurrentRequest() == NULL)
            {
                if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
                {
                    return WBEM_E_INVALID_PARAMETER;
                }
                
                if (lFlags & WBEM_FLAG_OWNER_UPDATE)
                {
                    lFlags -= WBEM_FLAG_OWNER_UPDATE;
                    lFlags += WBEM_FLAG_NO_EVENTS;
                }

                IWbemContext *pContext = pCtx ;
                if (pContext)
                    pContext->AddRef () ;
                else
                {
                    pContext = ConfigMgr::GetNewContext();
                    if ( pContext == NULL )
                        return WBEM_E_OUT_OF_MEMORY;
                }

                CReleaseMe _1_pContext (pContext) ;

                CSynchronousSink *pSyncSink = CSynchronousSink::Create();
                if (pSyncSink == NULL)  return WBEM_E_OUT_OF_MEMORY;
                pSyncSink->AddRef();
                CReleaseMe _2(pSyncSink);

                hRes = Exec_PutClass(pObj, lFlags, pContext, pSyncSink);

                // Extract the new object from the sink.
                // ======================================

                pSyncSink->Block();

                IWbemClassObject* pErrorObj = NULL;
                pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
                CReleaseMe rm1(pErrorObj);

                if(pErrorObj)
                {
                    IErrorInfo* pErrorInfo = NULL;
                    pErrorObj->QueryInterface(IID_IErrorInfo,(void**)&pErrorInfo);
                    SetErrorInfo(0, pErrorInfo);
                    pErrorInfo->Release();
                }

                return hRes;
            }
        }

        // Create Finalizer.
        // =================

        _IWmiFinalizer *pFnz = 0;
        hRes = CreateSyncFinalizer(pCtx, &pFnz);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pFnz);

        ULONG uTaskType = WMICORE_TASK_PUT_CLASS;
        if (ppResult)
            uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
        else
            uTaskType |= WMICORE_TASK_TYPE_SYNC;

        // Do the work elsewhere.
        // ======================

        hRes = _PutClassAsync(uTaskType, pFnz, 0, pObj, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                         pCtx, NULL);

        if (FAILED(hRes))
            return hRes;

        // Check for the two return paradigms.
        // ===================================

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        {
            HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
            if (FAILED(hResTemp))
                return hResTemp;
        }
        if (ppResult)
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
        }

        return hRes;

    }
    catch(...) // this interface calls the Exec_[MetrhodName] straight
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::CancelAsyncRequest.
//
//  Currently a noop, eventually this function will cancel an asynchrnous
//  request based on the handle value it returned.
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::CancelAsyncCall(IWbemObjectSink* pSink)
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Note that LOMEM_CHECK is not needed or wanted here

    if (pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Quickly cancel via Arbitrator.
    // ===============================
    if (m_pArb)
    {
        hRes = m_pArb->CancelTasksBySink(WMIARB_CALL_CANCELLED_CLIENT, IID_IWbemObjectSink, pSink);
    }

    return hRes ;

}



//***************************************************************************
//
//  CWbemNamespace::PutInstance
//
//  Calls PutInstanceAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************


HRESULT CWbemNamespace::PutInstance(
    IWbemClassObject* pInst,
    long lFlags,
    IWbemContext* pCtx,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    // Parameter validation.
    // =====================

    if (lFlags
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_OWNER_UPDATE
        & ~WBEM_FLAG_CREATE_ONLY
        & ~WBEM_FLAG_UPDATE_ONLY
        & ~WBEM_FLAG_CREATE_OR_UPDATE
        )
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        DEBUGTRACE((LOG_WBEMCORE,
            "CALL CWbemNamespace::PutInstance"
            "   long lFlags = 0x%X\n"
            "   IWbemClassObject *pInst = 0x%X\n",
            lFlags,
            pInst));
        
        if( ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)&&(ppResult==NULL))
        {
            // trick for allowing setup to set the SD
            AutoRevertSecTlsFlag RevSec ( (LPVOID) 1 );
            if ( IsNtSetupRunning() )
            {
                RevSec.SetSecTlsFlag ( (LPVOID) 0 );
            }

            HANDLE hCurrentToken;
            if(OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE,
                                &hCurrentToken))
            {
                //
                // Got a thread token --- cannot fast-track because otherwise we
                // will have a thread token on a thread executing internal code
                //

                CloseHandle(hCurrentToken);
            }
            else if (CWbemQueue::GetCurrentRequest() == NULL)
            {
                IWbemContext *pContext = pCtx ;
                if (pContext)
                    pContext->AddRef () ;
                else
                {
                    pContext = ConfigMgr::GetNewContext();
                    if ( pContext == NULL )
                        return WBEM_E_OUT_OF_MEMORY;
                }

                CReleaseMe _1_pContext (pContext) ;

                CSynchronousSink *pSyncSink = CSynchronousSink::Create();
                if (pSyncSink == NULL)
                    return WBEM_E_OUT_OF_MEMORY;

                pSyncSink->AddRef();
                CReleaseMe _2(pSyncSink);


                if (!m_bProvider && (lFlags & WBEM_FLAG_OWNER_UPDATE))
                {
                    return WBEM_E_INVALID_PARAMETER;
                }

                if (lFlags & WBEM_FLAG_OWNER_UPDATE)
                {
                    lFlags -= WBEM_FLAG_OWNER_UPDATE;
                    lFlags += WBEM_FLAG_NO_EVENTS;
                }

                hRes = Exec_PutInstance(pInst, lFlags, pContext, pSyncSink);

                // Extract the new object from the sink.
                // ======================================

                pSyncSink->Block();
                IWbemClassObject* pErrorObj = NULL;
                pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
                CReleaseMe rm1(pErrorObj);

                if(pErrorObj)
                {
                    IErrorInfo* pErrorInfo = NULL;
                    pErrorObj->QueryInterface(IID_IErrorInfo,
                                           (void**)&pErrorInfo);
                    SetErrorInfo(0, pErrorInfo);
                    pErrorInfo->Release();
                }

                return hRes;
            }
        }

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Create Finalizer.
        // =================

        _IWmiFinalizer *pFnz = 0;
        hRes = CreateSyncFinalizer(pCtx, &pFnz);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pFnz);

        ULONG uTaskType = WMICORE_TASK_PUT_INSTANCE;
        if (ppResult)
            uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
        else
            uTaskType |= WMICORE_TASK_TYPE_SYNC;

        // Do the work elsewhere.
        // ======================

        hRes = _PutInstanceAsync(uTaskType, pFnz, 0, pInst, 
                                               lFlags & ~WBEM_RETURN_IMMEDIATELY,
                                               pCtx, NULL);

        if (FAILED(hRes))
            return hRes;

        // Check for the two return paradigms.
        // ===================================

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        {
            HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
            if (FAILED(hResTemp))
                return hResTemp;
        }
        if (ppResult)
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
        }

        return hRes;

    }
    catch(...) // this interfaces calls the Exec_[MethodName]
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::DeleteInstance
//
//  Calls DeleteInstanceAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************

HRESULT CWbemNamespace::DeleteInstance(
    READONLY const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::DeleteInstance\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n",
        strObjectPath, lFlags
        ));

    if (lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY &~ WBEM_FLAG_OWNER_UPDATE)
        return WBEM_E_INVALID_PARAMETER;

    if((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;


    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_DELETE_INSTANCE;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _DeleteInstanceAsync(uTaskType, pFnz, 0, strObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                     pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0,INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
    }
    if (ppResult)
    {
        hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::GetObject
//
//  Calls GetObjectAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************

HRESULT CWbemNamespace::GetObject(
    READONLY const BSTR strObjectPath,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IWbemClassObject** ppObj,
    NEWOBJECT IWbemCallResult** ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_ENABLE))
        return WBEM_E_ACCESS_DENIED;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::GetObject\n"
        "   BSTR ObjectPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemClassObject ** pObj = 0x%X\n",
        strObjectPath,
        lFlags,
        ppObj
        ));

    if (ppObj)
        *ppObj = NULL;

    if (lFlags
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_DIRECT_READ
        )
        return WBEM_E_INVALID_PARAMETER;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        if( ((lFlags & WBEM_FLAG_RETURN_IMMEDIATELY) == 0)&&(ppResult==NULL))
        {
            //
            // This is special case GetObject synchronous. We dont want to allow this unless,
            // we're running setup.
            //
            AutoRevertSecTlsFlag RevSec ( (LPVOID) 1 );
            if ( IsNtSetupRunning() )
            {
                RevSec.SetSecTlsFlag ( (LPVOID) 0 );
            }

            HANDLE hCurrentToken;
            if(OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE,
                                &hCurrentToken))
            {
                //
                // Got a thread token --- cannot fast-track because otherwise we
                // will have a thread token on a thread executing internal code
                //

                CloseHandle(hCurrentToken);
            }
            else if (CWbemQueue::GetCurrentRequest() == NULL)
            {
                IWbemContext *pContext = pCtx ;
                if (pContext)
                    pContext->AddRef () ;
                    else
                {
                    pContext = ConfigMgr::GetNewContext();
                    if ( pContext == NULL )
                        return WBEM_E_OUT_OF_MEMORY;
                }

                CReleaseMe _1_pContext (pContext) ;

                CSynchronousSink *pSyncSink = CSynchronousSink::Create();
                if (pSyncSink == NULL)
                    return WBEM_E_OUT_OF_MEMORY;

                pSyncSink->AddRef();
                CReleaseMe _2(pSyncSink);

                hRes = Exec_GetObject(strObjectPath, lFlags, pContext, pSyncSink);
                //if (FAILED(hRes))
                //{
                //  return hRes;
                //}

                // Extract the new object from the sink.
                // ======================================

                pSyncSink->Block();

                IWbemClassObject* pErrorObj = NULL;
                pSyncSink->GetStatus(&hRes, NULL, &pErrorObj);
                CReleaseMe rm1(pErrorObj);

                if(pErrorObj)
                {
                    IErrorInfo* pErrorInfo = NULL;
                    pErrorObj->QueryInterface(IID_IErrorInfo,
                                           (void**)&pErrorInfo);
                    SetErrorInfo(0, pErrorInfo);
                    pErrorInfo->Release();
                }

                if (SUCCEEDED(hRes))
                {
                    if(pSyncSink->GetObjects().GetSize() != 1)
                        return WBEM_E_CRITICAL_ERROR;

                    // Only access the returned object if ppObj is non-NULL.
                    if ( NULL != ppObj )
                    {
                        *ppObj = pSyncSink->GetObjects()[0];
                        (*ppObj)->AddRef();
                    }
                }

                return hRes;
            }
        }

        // Create Finalizer.
        // =================

        _IWmiFinalizer *pFnz = 0;
        hRes = CreateSyncFinalizer(pCtx, &pFnz);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pFnz);

        ULONG uTaskType = WMICORE_TASK_GET_OBJECT;
        if (ppResult)
            uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
        else
            uTaskType |= WMICORE_TASK_TYPE_SYNC;

        // Do the work elsewhere.
        // ======================

        hRes = _GetObjectAsync(uTaskType, pFnz, 0, strObjectPath, lFlags & ~WBEM_RETURN_IMMEDIATELY,
                         pCtx, NULL);

        if (FAILED(hRes))
        {
            return hRes;
        }

        // Check for the two return paradigms.
        // ===================================

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        {
            HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
            if (FAILED(hResTemp))
                return hResTemp;
            if (FAILED(hRes))
                return hRes;
        }

        if (ppResult)
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
            if (FAILED(hRes))
            {
                return hRes;
            }
            if (ppObj && ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0))
                hRes = (*ppResult)->GetResultObject(INFINITE, ppObj);
        }
        else if (ppObj && ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0))
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) ppObj);
        }

        return hRes;
    }
    catch(...) // this interface goes to the Exec_[MethodName straight]
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }
}


//***************************************************************************
//
//  CWbemNamespace::ExecMethod
//
//***************************************************************************

HRESULT CWbemNamespace::ExecMethod(
    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext *pCtx,
    IWbemClassObject *pInParams,
    IWbemClassObject **ppOutParams,
    IWbemCallResult  **ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecMethod\n"
        "   BSTR ObjectPath = %S\n"
        "   BSTR MethodName = %S\n"
        "   long lFlags = %d\n"
        "   IWbemClassObject * pIn = 0x%X\n",
        ObjectPath, MethodName, lFlags, pInParams
        ));

    // Parameter validation.
    // =====================

    if (ppOutParams)
        *ppOutParams = NULL;

    if (lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY)
        return WBEM_E_INVALID_PARAMETER;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_EXEC_METHOD;
    if (ppResult)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work elsewhere.
    // ======================

    hRes = _ExecMethodAsync(uTaskType, pFnz, 0, ObjectPath, MethodName,
               lFlags & ~WBEM_RETURN_IMMEDIATELY, pCtx, pInParams, NULL);

    if (FAILED(hRes))
        return hRes;

    // Check for the two return paradigms.
    // ===================================

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
    {
        HRESULT hResTemp = pFnz->GetOperationResult(0, INFINITE, &hRes);
        if (FAILED(hResTemp))
            return hResTemp;
        if (FAILED(hRes))
            return hRes;
        if (ppResult)
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
            if (FAILED(hRes))
                return hRes;
            if (ppOutParams)
            {
                hRes = (*ppResult)->GetResultObject(INFINITE, ppOutParams);
                if (hRes == WBEM_E_NOT_FOUND)   //If there was no object we still return success!
                    hRes = WBEM_S_NO_ERROR;
            }
        }
        else
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemClassObject, (LPVOID *) ppOutParams);
            if (hRes == WBEM_E_NOT_FOUND)   //If there was no object we still return success!
                hRes = WBEM_S_NO_ERROR;
        }
    }
    else
    {
        //
        // If we have a call result pointer we should try to use it
        //
        if ( ppResult )
        {
            hRes = pFnz->GetResultObject(0, IID_IWbemCallResult, (LPVOID *) ppResult);
            if (hRes == WBEM_E_NOT_FOUND)   //If there was no object we still return success!
                hRes = WBEM_S_NO_ERROR;
        }
        else // semysync and nobody interested
        {
                pFnz->CancelTask(0);
            hRes = WBEM_S_NO_ERROR;            
        }

    }

    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::CreateInstanceEnum
//
//  Calls CreateInstanceEnumAsync and waits for completion
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::CreateInstanceEnum(
    const BSTR strClass,
    long lFlags,
    IWbemContext* pCtx,
    IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateInstanceEnum\n"
        "   long lFlags = 0x%X\n"
        "   BSTR Class = %S\n"
        "   IEnumWbemClassObject **pEnum = 0x%X\n",
        lFlags,
        strClass,
        ppEnum
        ));

    // Validate parameters
    // ===================

    if (lFlags
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
        & ~WBEM_FLAG_DEEP
        & ~WBEM_FLAG_SHALLOW
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_DIRECT_READ
        )
        return WBEM_E_INVALID_PARAMETER;

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *ppEnum = NULL;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ENUM_INSTANCES;
    if (lFlags & WBEM_RETURN_IMMEDIATELY)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work.
    // ============

    hRes = _CreateInstanceEnumAsync(uTaskType, pFnz, 0, strClass,
                    lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                    pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        pFnz->GetOperationResult(0, INFINITE, &hRes);

    if (SUCCEEDED(hRes))
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hResTemp = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
        if (FAILED(hResTemp))
            return hResTemp;
        CReleaseMe _2(pEnum);

        *ppEnum = pEnum;
        pEnum->AddRef();    // counteract CReleaseMe
    }

    return hRes;
}


//***************************************************************************
//
//  CWbemNamespace::CreateClassEnum
//
//  Invokes CreateClassEnumAsync and waits for completion. Actual work is
//  performed in Exec_CreateClassEnum.
//
//  Parameters and return values are described in help
//
//***************************************************************************
HRESULT CWbemNamespace::CreateClassEnum(
    const BSTR strParent,
    long lFlags,
    IWbemContext* pCtx,
    IEnumWbemClassObject **ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::CreateClassEnum\n"
        "   BSTR Parent = %S\n"
        "   long lFlags = 0x%X\n"
        "   IEnumWbemClassObject = 0x%X\n",
        strParent,
        lFlags,
        ppEnum
        ));

    // Validate parameters
    // ===================

   if (lFlags
        & ~WBEM_FLAG_DEEP
        & ~WBEM_FLAG_SHALLOW
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
        )
        return WBEM_E_INVALID_PARAMETER;

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *ppEnum = NULL;

    // Create Finalizer.
    // =================

    _IWmiFinalizer *pFnz = 0;
    hRes = CreateSyncFinalizer(pCtx, &pFnz);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pFnz);

    ULONG uTaskType = WMICORE_TASK_ENUM_CLASSES;
    if (lFlags & WBEM_RETURN_IMMEDIATELY)
        uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
    else
        uTaskType |= WMICORE_TASK_TYPE_SYNC;

    // Do the work.
    // ============

    hRes = _CreateClassEnumAsync(uTaskType, pFnz, 0, strParent,
                    lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                    pCtx, NULL);

    if (FAILED(hRes))
        return hRes;

    if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        pFnz->GetOperationResult(0, INFINITE, &hRes);

    if (SUCCEEDED(hRes))
    {
        IEnumWbemClassObject* pEnum = NULL;
        HRESULT hResTemp = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
        if (FAILED(hResTemp))
            return hResTemp;
        CReleaseMe _2(pEnum);

        *ppEnum = pEnum;
        pEnum->AddRef();    // Counteract CReleaseMe
    }
    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWbemNamespace::ExecQuery(
    READONLY const BSTR strQueryFormat,
    READONLY const BSTR strQuery,
    long lFlags,
    IWbemContext* pCtx,
    NEWOBJECT IEnumWbemClassObject** ppEnum
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::ExecQuery\n"
        "   BSTR QueryFormat = %S\n"
        "   BSTR Query = %S\n"
        "   IEnumWbemClassObject **pEnum = 0x%X\n",
        strQueryFormat,
        strQuery,
        ppEnum
        ));

    // Validate parameters
    // ===================

    if (lFlags
        & ~WBEM_FLAG_PROTOTYPE
        & ~WBEM_FLAG_ENSURE_LOCATABLE
        & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS
        & ~WBEM_FLAG_KEEP_SHAPE
        & ~WBEM_RETURN_IMMEDIATELY
        & ~WBEM_FLAG_FORWARD_ONLY
        & ~WBEM_FLAG_DIRECT_READ
        )
        return WBEM_E_INVALID_PARAMETER;

    if (ppEnum == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        *ppEnum = NULL;

        // Create Finalizer.
        _IWmiFinalizer *pFnz = 0;
        hRes = CreateSyncFinalizer(pCtx, &pFnz);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pFnz);

        ULONG uTaskType = WMICORE_TASK_EXEC_QUERY;
        if (lFlags & WBEM_RETURN_IMMEDIATELY)
            uTaskType |= WMICORE_TASK_TYPE_SEMISYNC;
        else
            uTaskType |= WMICORE_TASK_TYPE_SYNC;

        // Do the work.
        // ============

        hRes = _ExecQueryAsync(uTaskType, pFnz, 0, strQueryFormat, strQuery,
                        lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_FORWARD_ONLY,
                        pCtx, NULL);

        if (FAILED(hRes))
            return hRes;

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
            pFnz->GetOperationResult(0, INFINITE, &hRes);

        if (SUCCEEDED(hRes))
        {
            IEnumWbemClassObject* pEnum = NULL;
            HRESULT hResTemp = pFnz->GetResultObject(lFlags, IID_IEnumWbemClassObject, (LPVOID*)&pEnum);
            if (FAILED(hResTemp))
                return hResTemp;
            CReleaseMe _2(pEnum);

            *ppEnum = pEnum;
            pEnum->AddRef();    // Counteract CReleaseMe
        }

        return hRes;

    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }
}

//***************************************************************************
//
//  CWbemNamespace::QueryObjectSink
//
//  Returns the pointer to the ESS event handler. Clients can use this pointer
//  to supply events to WINMGMT. NOTE: this pointer will be NULL if ESS is
//  disabled (see cfgmgr.h).
//
//  Parameters and return values are described in help
//
//***************************************************************************


HRESULT CWbemNamespace::QueryObjectSink(
    long lFlags,
    IWbemObjectSink** ppHandler
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;
    if (!Allowed(WBEM_FULL_WRITE_REP))
        return WBEM_E_ACCESS_DENIED;

    if (ppHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *ppHandler = NULL;

    if (lFlags != 0)
        return WBEM_E_INVALID_PARAMETER;

    IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
    if (pEss)
    {
        CReleaseMe rm_(pEss);

        CWbemPtr<IWbemObjectSink> pEssSink;
        hRes = pEss->GetNamespaceSink(m_pThisNamespaceFull, &pEssSink);

        if ( FAILED(hRes)) return hRes;

        CWbemPtr<CSecureEssNamespaceSink> pSecureSink = new CSecureEssNamespaceSink(this,pEssSink);

        if ( pSecureSink == NULL )
            return WBEM_E_OUT_OF_MEMORY;

        hRes = pSecureSink->QueryInterface( IID_IWbemObjectSink,
                                            (void**)ppHandler );
        return hRes;
    }
    else
    {
        return WBEM_E_NOT_SUPPORTED;
    }
}



//***************************************************************************
//
//  CWbemNamespace::OpenNamespace
//
//  Opens a child namespace of this one. Username, password, locale id,
//  flags and error object parameters are ignored.
//
//  Parameters:
//
//    BSTR NsPath                   Relative path to the namespace
//    BSTR User                     Reserved, must be NULL.
//    BSTR Password                 Reserved, must be NULL.
//    long lLocaleId                Reserved, must be NULL.
//    long lFlags                   Reserved, must be NULL.
//    IWbemServices **pNewContext    Destination for the new namespace pointer.
//                                  Must be released by the caller.
//    IWbemClassObject** ppErrorObj  Reserved, must be NULL.
//
//  RETURN VALUES:
//
//      WBEM_S_NO_ERROR              On success
//      WBEM_E_INVALID_PARAMETER     Invalid name.
//
//***************************************************************************

HRESULT CWbemNamespace::OpenNamespace(
    const BSTR NsPath,
    long lFlags,
    IWbemContext* pCtx,
    IWbemServices **ppNewNamespace,
    IWbemCallResult **ppResult
    )
{
    HRESULT hRes = CheckNs();
    if (FAILED(hRes))
        return hRes;

    DEBUGTRACE((LOG_WBEMCORE,
        "CALL CWbemNamespace::OpenNamespace\n"
        "   BSTR NsPath = %S\n"
        "   long lFlags = %d\n"
        "   IWbemContext* pCtx = 0x%X\n"
        "   IWbemServices **pNewContext = 0x%X\n",
        NsPath,
        lFlags,
        pCtx,
        ppNewNamespace
        ));

    // Parameter validation.
    // =====================

    try
    {
        if (NsPath == 0 || wcslen(NsPath) == 0 ||                        // SEC:REVIEWED 2002-03-22 : OK
            (ppNewNamespace == NULL && ppResult == NULL))
        {
            return WBEM_E_INVALID_PARAMETER;
        }
 
        if (ppNewNamespace == NULL && (lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        {
            return WBEM_E_INVALID_PARAMETER;
        }
        if ((lFlags & WBEM_RETURN_IMMEDIATELY) && ppNewNamespace)
            return WBEM_E_INVALID_PARAMETER;

        if(ppNewNamespace)
            *ppNewNamespace = NULL;
        if(ppResult)
            *ppResult = NULL;

        if((lFlags & ~WBEM_RETURN_IMMEDIATELY & ~WBEM_FLAG_USE_AMENDED_QUALIFIERS & ~WBEM_FLAG_CONNECT_REPOSITORY_ONLY) != 0)
            return WBEM_E_INVALID_PARAMETER;

        bool bWin9XLocalSecurity = false;

        // If here, we found the object, so we open the
        // corresponding namespace.
        // ============================================

        WString NewNs = m_pThisNamespace;
        NewNs += L"\\";
        NewNs += NsPath;

        CCallResult* pResult = new CCallResult;
        if(pResult == NULL) return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe rmResult(pResult);

        // Schedule a request and wait
        // ===========================

        bool bForClient = m_bForClient ? true : false;

        wmilib::auto_ptr<CAsyncReq_OpenNamespace> pReq;
        pReq.reset( new CAsyncReq_OpenNamespace(this, 
                                               NewNs,
                                               (bWin9XLocalSecurity) ? SecFlagWin9XLocal : lFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY,
                                               (bWin9XLocalSecurity) ? m_dwPermission : 0,
                                               pCtx, pResult, bForClient));

        if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;

        hRes = ConfigMgr::EnqueueRequest(pReq.get());
        if (FAILED(hRes)) return hRes;
        pReq.release(); // ownership transferred to queue

        if (ppResult)
        {
            *ppResult = pResult;
            pResult->AddRef();
        }

        if ((lFlags & WBEM_RETURN_IMMEDIATELY) == 0)
        {
            hRes = pResult->GetResultServices(INFINITE, ppNewNamespace);
        }

        return hRes;
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_FAILED;
    }
    
}



//***************************************************************************
//
//***************************************************************************
//

HRESULT CWbemNamespace::DeleteObject(
            IN const BSTR strObjectPath,
            IN long lFlags,
            IN IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{


    HRESULT hRes;
    ULONGLONG uInf;

    // Parse the path and determine if a class or instance.

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    CReleaseMe _(pPath);

    hRes = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, strObjectPath);
    if (FAILED(hRes))
        return hRes;

    hRes = pPath->GetInfo(0, &uInf);
    if (FAILED(hRes))
        return hRes;

    if (uInf & WBEMPATH_INFO_IS_CLASS_REF)
        return DeleteClass(strObjectPath, lFlags, pCtx, ppCallResult);
    else if (uInf & WBEMPATH_INFO_IS_INST_REF)
        return DeleteInstance(strObjectPath, lFlags, pCtx, ppCallResult);
    else
        return WBEM_E_INVALID_PARAMETER;

}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::ExecSyncQuery(
    IN  LPWSTR pszQuery,
    IN  IWbemContext *pCtx,
    IN  LONG lFlags,
    OUT CFlexArray &aDest
    )
{
    HRESULT hRes;
    CSynchronousSink* pSink = CSynchronousSink::Create();
    if (NULL == pSink) return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();
    CReleaseMe _1(pSink);

    hRes = CQueryEngine::ExecQuery(this, L"WQL", pszQuery, lFlags, pCtx, pSink);
    if (FAILED(hRes)) return hRes;
    pSink->Block();
    pSink->GetStatus(&hRes, NULL, NULL);
    if (FAILED(hRes)) return hRes;    

    aDest.Bind(pSink->GetObjects().GetArray());

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CWbemNamespace::MapAssocRefsToClasses
//
//  Analyzes the association and determines which reference properties
//  point to which endpoints.  <pszAssocRef1> is the ref property
//  which can point to instances of <pClsDef1> and <pszAssocRef2> is
//  the property which can point to instances of <pClsDef2>.
//
//***************************************************************************
//
HRESULT CWbemNamespace::MapAssocRefsToClasses(
    IN  IWbemClassObject *pAssocClass,
    IN  IWbemClassObject *pClsDef1,
    IN  IWbemClassObject *pClsDef2,
    wmilib::auto_buffer<WCHAR> & pszAssocRef1,
    wmilib::auto_buffer<WCHAR> & pszAssocRef2)
{
    HRESULT hRes;

    // Note 97: Not valid for ternary assoc types
    // or derived types.
    // ===========================================

    // For each ref property, see if it can point to one of the endpoints.
    // ===================================================================

    pAssocClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pAssocClass->Next(0,&strPropName,0,0,0);
        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA) break;


        hRes = CAssocQuery::RoleTest(pClsDef1, pAssocClass, this, strPropName, ROLETEST_MODE_CIMREF_TYPE);
        if (SUCCEEDED(hRes))
        {
            pszAssocRef1.reset(Macro_CloneLPWSTR(strPropName));
            if (NULL == pszAssocRef1.get()) return WBEM_E_OUT_OF_MEMORY;
            continue;
        }

        hRes = CAssocQuery::RoleTest(pClsDef2, pAssocClass, this, strPropName, ROLETEST_MODE_CIMREF_TYPE);
        if (SUCCEEDED(hRes))
        {
            pszAssocRef2.reset(Macro_CloneLPWSTR(strPropName));
            if (NULL == pszAssocRef2.get()) return WBEM_E_OUT_OF_MEMORY;            
            continue;
        }
    }   // Enum of ref properties


    pAssocClass->EndEnumeration();

    if (NULL == pszAssocRef1.get() ||NULL == pszAssocRef2.get())
    {
        pszAssocRef1.reset(NULL);
        pszAssocRef2.reset(NULL);
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::BuildAssocTriads(
    IN  IWbemClassObject *pAssocClass,              // Assoc class
    IN  IWbemClassObject *pClsDef1,                 // Class for EP1
    IN  IWbemClassObject *pClsDef2,                 // Class for EP2
    IN  LPWSTR pszJoinProp1,                        // Matching prop in EP1
    IN  LPWSTR pszJoinProp2,                        // Matching prop in EP2
    IN  LPWSTR pszAssocRef1,                        // Prop which points to EP1
    IN  LPWSTR pszAssocRef2,                        // Prop which points to EP2
    IN  CFlexArray &aEp1,                           // EP1 instances
    IN  CFlexArray &aEp2,                           // EP2 instances
    IN OUT CFlexArray &aTriads                      // OUT : Triad list
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (pszJoinProp1 == 0 || pszJoinProp2 == 0 || pAssocClass == 0 ||
        pszAssocRef1 == 0 || pszAssocRef2 == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Do the matching.
    // ================

    for (int i = 0; i < aEp1.Size(); i++)
    {
        IWbemClassObject *pObj1 = (IWbemClassObject *) aEp1[i];
        CVARIANT v1;
        if (FAILED(hRes = pObj1->Get(pszJoinProp1, 0, &v1, 0, 0))) return hRes;

        for (int i2 = 0; i2 < aEp2.Size(); i2++)
        {
            BOOL bMatch = FALSE;

            IWbemClassObject *pObj2 = (IWbemClassObject *) aEp2[i2];
            CVARIANT v2;
            pObj2->Get(pszJoinProp2, 0, &v2, 0, 0);

            if (V_VT(&v1) == VT_I4 && V_VT(&v2) == VT_I4)
            {
                if (v1.GetLONG() == v2.GetLONG())
                {
                    bMatch = TRUE;
                }
            }
            else if (V_VT(&v1) == VT_BSTR && V_VT(&v2) == VT_BSTR)
            {
                if (wbem_wcsicmp(v1.GetStr(), v2.GetStr()) == 0)
                {
                    bMatch = TRUE;
                }
            }

            // If a match, spawn the association and bind it.
            // ==============================================

            if (bMatch)
            {
                IWbemClassObject *pAssocInst = 0;
                if (FAILED(hRes = pAssocClass->SpawnInstance(0, &pAssocInst))) return hRes;
                CReleaseMe rmAssoc(pAssocInst);

                CVARIANT vPath1, vPath2;

                if (FAILED(hRes = pObj1->Get(L"__RELPATH", 0, &vPath1, 0, 0))) return hRes;
                if (FAILED(hRes = pObj2->Get(L"__RELPATH", 0, &vPath2, 0, 0))) return hRes;

                if (FAILED(hRes = pAssocInst->Put(pszAssocRef1, 0, &vPath1, 0))) return hRes;
                if (FAILED(hRes = pAssocInst->Put(pszAssocRef2, 0, &vPath2, 0))) return hRes;

                wmilib::auto_ptr<SAssocTriad> pTriad( new SAssocTriad);
                if (NULL == pTriad.get())  return WBEM_E_OUT_OF_MEMORY;

                pTriad->m_pEp1 = pObj1;
                pTriad->m_pEp1->AddRef();
                pTriad->m_pEp2 = pObj2;
                pTriad->m_pEp2->AddRef();
                pTriad->m_pAssoc = pAssocInst;
                pTriad->m_pAssoc->AddRef();                

                if (CFlexArray::no_error != aTriads.Add(pTriad.get())) return WBEM_E_OUT_OF_MEMORY;
                pTriad.release();
            }
        }
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWbemNamespace::ExtractEpInfoFromQuery(
    IN IWbemQuery *pQuery,
    wmilib::auto_buffer<WCHAR> & pszRetClass1,
    wmilib::auto_buffer<WCHAR> & pszRetProp1,
    wmilib::auto_buffer<WCHAR> & pszRetClass2,
    wmilib::auto_buffer<WCHAR> & pszRetProp2
    )
{
    HRESULT hRes;
    SWQLNode *pRoot;

    hRes = pQuery->GetAnalysis(
        WMIQ_ANALYSIS_RESERVED,
        0,
        (LPVOID *) &pRoot
        );

    if (FAILED(hRes))
        return hRes;

    // Move down the parse tree to find the JOIN clause.
    // =================================================

    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_QueryRoot)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pLeft;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_Select)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pLeft;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_TableRefs)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pRight;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_FromClause)
        return WBEM_E_INVALID_QUERY;
    pRoot = pRoot->m_pLeft;
    if (!pRoot || pRoot->m_dwNodeType != TYPE_SWQLNode_Join)
        return WBEM_E_INVALID_QUERY;

    // We are now at the JOIN node.
    // ============================

    SWQLNode_Join *pJoin = (SWQLNode_Join *) pRoot;

    /* The parse tree is left-heavy and looks like this:

             JN               Join node
            /   \             /        \
          JP     OC       JoinPair     OnClause
         /  \               /   \
        TR   TR        TableRef TableRef
    */

    // First, get the first table & prop.
    // ==================================
    SWQLNode_JoinPair *pPair = (SWQLNode_JoinPair *) pJoin->m_pLeft;
    if (!pPair || pPair->m_dwNodeType != TYPE_SWQLNode_JoinPair)
        return WBEM_E_INVALID_QUERY;

    SWQLNode_TableRef *pT1 = (SWQLNode_TableRef *) pPair->m_pLeft;
    SWQLNode_TableRef *pT2 = (SWQLNode_TableRef *) pPair->m_pRight;

    if (!pT1 || !pT2)
        return WBEM_E_INVALID_QUERY;

    SWQLNode_OnClause *pOC = (SWQLNode_OnClause *) pJoin->m_pRight;
    if (!pOC)
        return WBEM_E_INVALID_QUERY;

    SWQLNode_RelExpr *pRE = (SWQLNode_RelExpr *) pOC->m_pLeft;
    if (!pRE)
        return WBEM_E_INVALID_QUERY;

    if (pRE->m_dwExprType != WQL_TOK_TYPED_EXPR)
        return WBEM_E_INVALID_QUERY;

    // We now have the table names available and the matching condition.
    // ==================================================================

    LPWSTR pszClass = pRE->m_pTypedExpr->m_pTableRef;
    LPWSTR pszProp = pRE->m_pTypedExpr->m_pColRef;
    LPWSTR pszClass2 = pRE->m_pTypedExpr->m_pJoinTableRef;
    LPWSTR pszProp2 = pRE->m_pTypedExpr->m_pJoinColRef;

    if (wbem_wcsicmp(pT1->m_pTableName, pszClass) != 0)
        pszClass = pT1->m_pAlias;

    if (wbem_wcsicmp(pT2->m_pTableName, pszClass2) != 0)
        pszClass2 = pT2->m_pAlias;

    if (pszClass == 0 || pszProp == 0 || pszClass2 == 0 || pszProp2 == 0)
        return WBEM_E_INVALID_QUERY;


    pszRetClass1.reset(Macro_CloneLPWSTR(pszClass));
    if (NULL == pszRetClass1.get()) return WBEM_E_OUT_OF_MEMORY;
    pszRetProp1.reset(Macro_CloneLPWSTR(pszProp));
    if (NULL == pszRetProp1.get()) return WBEM_E_OUT_OF_MEMORY;    
    pszRetClass2.reset(Macro_CloneLPWSTR(pszClass2));
    if (NULL == pszRetClass2.get()) return WBEM_E_OUT_OF_MEMORY;        
    pszRetProp2.reset(Macro_CloneLPWSTR(pszProp2));
    if (NULL ==pszRetProp2.get()) return WBEM_E_OUT_OF_MEMORY;    

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CWbemNamespace::BuildRuleBasedPathToInst
//
//  Based on the incoming info, computes the path to the would-be other
//  endpoint.
//
//  <pEp>           The known endpoint.
//  <pszJoinProp1>  The property in <pEp> which matches the property in the
//                  unknown EP.
//  <pEp2>          Class for the other endpoint.
//  <pszJoinProp2>  The property in the other class which matches the
//                  <pszJoinProp1> in the known endpoint class.
//  <wsNewPath>     The proposed path to the instance of class <pEp2>. Who
//                  knows whether or not we will find it, but we can try.
//
//***************************************************************************
//
HRESULT CWbemNamespace::BuildRuleBasedPathToInst(
    IWbemClassObject *pEp,
    LPWSTR pszJoinProp1,
    IWbemClassObject *pEp2,
    LPWSTR pszJoinProp2,
    OUT WString &wsNewPath
    )
{
    HRESULT hRes;

    // Get the property from the <pEp> which is the cause of all the fuss.
    // ===================================================================

    _variant_t vProp;
    hRes = pEp->Get(pszJoinProp1, 0, &vProp, 0, 0);
    if (FAILED(hRes))
        return hRes;

    _variant_t vClass2;
    hRes = pEp2->Get(L"__CLASS", 0, &vClass2, 0, 0);
    if (FAILED(hRes))  return hRes;    
    if (VT_BSTR != V_VT(&vClass2)) return WBEM_E_INVALID_PARAMETER;

    wsNewPath = V_BSTR(&vClass2);
    wsNewPath += L".";
    wsNewPath += pszJoinProp2;
    wsNewPath += L"=";

    // Note 98: Doesn't work for compound keys!! Yuck.
    // ===============================================

    _variant_t vDest;
    hRes = VariantChangeType(&vDest, &vProp, 0, VT_BSTR);
    if (FAILED(hRes)) return hRes;

    wsNewPath += V_BSTR(&vDest);
    
    return hRes;
}

//***************************************************************************
//
//  CWbemNamespace::ManufactureAssocs
//
//  Manufactures the associations based on the rule in the <pszJoinQuery>
//  which was extracted from the <rulebased> qualifier.  Queries the two
//  endpoint classes and joins the instances to produce the associations
//
//  <pAssocClass>   The association class definition which contains the rule.
//  <pEp>           Optional endpoint object.  If not NULL, only objects
//                  which associate to this endpoint will be returned in
//                  the triad list, typically a single object.
//  <pCtx>          Call context
//  <pszJoinQuery>  The rule query text
//  <aTriads>       Receives the output, an array of SAssocTriad pointers.
//                  Caller must call SAssocTriad::ArrayCleanup.
//
//***************************************************************************

HRESULT CWbemNamespace::ManufactureAssocs(
    IN  IWbemClassObject *pAssocClass,
    IN  IWbemClassObject *pEp,          // Optional
    IN  IWbemContext *pCtx,
    IN  LPWSTR pszJoinQuery,
    OUT CFlexArray &aTriads
    )
{
    HRESULT hRes;
    WString q1, q2;

    CFlexArray aEp1List;
    OnDelete<CFlexArray &,void(*)(CFlexArray &),EmptyObjectList> EmptyMe1(aEp1List);
    CFlexArray aEp2List;
    OnDelete<CFlexArray &,void(*)(CFlexArray  &),EmptyObjectList> EmptyMe2(aEp2List);
    wmilib::auto_buffer<WCHAR> pClassName1;
    wmilib::auto_buffer<WCHAR> pClassName2;
    wmilib::auto_buffer<WCHAR> pszJoinProp1;
    wmilib::auto_buffer<WCHAR> pszJoinProp2;
    wmilib::auto_buffer<WCHAR> pszAssocRef1;
    wmilib::auto_buffer<WCHAR> pszAssocRef2;
    _IWmiQuery *pQuery = 0;

    // Parse the query.
    // ================
    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (NULL == pSvc) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rmSvc(pSvc);

    hRes = pSvc->CreateQueryParser(0, &pQuery);
    if (FAILED(hRes)) return hRes;
    CReleaseMe rmQuery(pQuery);

    hRes = pQuery->Parse(L"SQL", pszJoinQuery, 0);
    if (FAILED(hRes)) return hRes;

    // Extract the endpoint class names.
    // ==================================

    hRes = ExtractEpInfoFromQuery(pQuery, pClassName1,pszJoinProp1, pClassName2, pszJoinProp2);
    if (FAILED(hRes)) return hRes;

    // Get the endpoint class defs.
    // ============================
    IWbemClassObject *pClsDef1 = 0;
    hRes = InternalGetClass(pClassName1.get(), &pClsDef1);
    if (FAILED(hRes)) return hRes;
    CReleaseMe rmCls1(pClsDef1);

    IWbemClassObject *pClsDef2 = 0;
    hRes = InternalGetClass(pClassName2.get(), &pClsDef2);
    if (FAILED(hRes)) return hRes;
    CReleaseMe rmCls2(pClsDef2);

    // Map which assoc ref properties point to which class.
    // ====================================================
    hRes = MapAssocRefsToClasses(pAssocClass, pClsDef1, pClsDef2, pszAssocRef1, pszAssocRef2);
    if (FAILED(hRes)) return hRes;

    // If no specific endpoint, an enumeration is requested.  We query the endpoint
    // classes completely and match everything up.
    // ============================================================================

    IWbemClassObject *pEp2 = 0;
    CReleaseMeRef<IWbemClassObject *> rmRefEp2(pEp2);

    if (pEp == 0)
    {
        // Build the queries.
        // ===================
        q1 = "select * from ";
        q1 += pClassName1.get();
        q2 = "select * from ";
        q2 += pClassName2.get();

        hRes = ExecSyncQuery(q1, pCtx, 0, aEp1List);
        if (FAILED(hRes)) return hRes;

        hRes = ExecSyncQuery(q2, pCtx, 0, aEp2List);
        if (FAILED(hRes)) return hRes;
    }
    else
    {
        // Note 99: Oversimplified in that it doesn't do an enum; assumes a 1:1 mapping.
        // Compute the path to the other endpoint based on the rule.
        // =============================================================================

        WString wsNewPath;
        hRes = BuildRuleBasedPathToInst(pEp, pszJoinProp1.get(), pClsDef2, pszJoinProp2.get(), wsNewPath); // throws
        if (FAILED(hRes)) return hRes;

        // Do a get object.
        // ================

        hRes = InternalGetInstance(wsNewPath, &pEp2);
        if (FAILED(hRes)) return hRes;

        if (CFlexArray::no_error != aEp1List.Add(pEp)) return WBEM_E_OUT_OF_MEMORY;
        pEp->AddRef();
        if (CFlexArray::no_error != aEp2List.Add(pEp2)) return WBEM_E_OUT_OF_MEMORY;
        pEp2->AddRef();
    }

    // Now, match up the results.
    // For single-object type scenarios, the arrays simply have one element in them. Ho hum.
    // =====================================================================================

    OnDeleteIf<CFlexArray &,void(*)(CFlexArray &),EmptyObjectList> EmptyMeTriads(aTriads);

    hRes = BuildAssocTriads(
        pAssocClass,
        pClsDef1,
        pClsDef2,
        pszJoinProp1.get(),
        pszJoinProp2.get(),
        pszAssocRef1.get(),
        pszAssocRef2.get(),
        aEp1List,
        aEp2List,
        aTriads                         // OUT
        );

    if (FAILED(hRes)) return hRes;

    EmptyMeTriads.dismiss();
    return hRes;
}



//***************************************************************************
//
//  CWbemNamespace::GetAceList
//
//  Retrieves the ACEs associated with this namespace
//
//  <ppAceList>     Flexarray to hold ACE list
//
//***************************************************************************
HRESULT CWbemNamespace::GetAceList(CFlexAceArray** ppAceList)
{
    HRESULT hRes=S_OK;

    *ppAceList = new CFlexAceArray;
    if (ppAceList==NULL)
        hRes = WBEM_E_OUT_OF_MEMORY;
    else
    {
        // 1. Get security descriptor
        CNtSecurityDescriptor& sd = GetSDRef();

        // 2. Get the DACL
        CNtAcl* pDacl;
        pDacl = sd.GetDacl();
        if ( pDacl==NULL )
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe<CNtAcl> dm(pDacl);

        // 3. Loop through DACL
        int iNumAces = pDacl->GetNumAces();
        for ( int i=0; i<iNumAces; i++ )
        {
            CNtAce* Ace;
            Ace = pDacl->GetAce(i);
            if ( Ace == NULL )
                return WBEM_E_OUT_OF_MEMORY;

            (*ppAceList)->Add (Ace);
        }
    }
    return hRes;
}



//***************************************************************************
//
//  CWbemNamespace::PutAceList
//
//  Puts the ACEs associated with this namespace
//
//  <ppAceList>     Flexarray ACE list
//
//***************************************************************************
HRESULT CWbemNamespace::PutAceList(CFlexAceArray* pFlex)
{
    SCODE sc = S_OK;

    CNtAcl DestAcl;

    int iNumAces = pFlex->Size();
    for (int i=0; i<iNumAces; i++ )
    {
        if ( DestAcl.AddAce ((CNtAce*) pFlex->GetAt(i)) == FALSE )
        {
            return WBEM_E_INVALID_OBJECT;
        }
    }
    if ( m_sd.SetDacl (&DestAcl) == FALSE )
        return WBEM_E_INVALID_OBJECT;

    sc = StoreSDIntoNamespace(m_pSession, m_pNsHandle, m_sd);
    if ( !FAILED (sc) )
        sc = RecursiveSDMerge();
    return sc;
}

//***************************************************************************
//
//  CWbemNamespace::GetDynamicReferenceClasses
//
//  Asks the provider subsystem for dynamic association classes.
//
//
//***************************************************************************
HRESULT CWbemNamespace::GetDynamicReferenceClasses( long lFlags, IWbemContext
* pCtx, IWbemObjectSink* pSink )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    _IWmiProviderAssociatorsHelper* pAssocHelp = NULL;

    if ( m_pProvFact)
    {
        hRes = m_pProvFact->GetClassProvider(
                    0,                  // lFlags
                    pCtx,
                    m_wszUserName,
                    m_wsLocale,
                    m_pThisNamespace,                   
                    0,
                    IID__IWmiProviderAssociatorsHelper,
                    (LPVOID *) &pAssocHelp
                    );

        CReleaseMe  rm( pAssocHelp );

        if ( SUCCEEDED( hRes ) )
        {
            hRes = pAssocHelp->GetReferencesClasses( lFlags, pCtx, pSink );
        }

        if ( FAILED( hRes ) )
        {
            pSink->SetStatus( 0L, hRes, 0L, 0L );
        }
    }
    else
    {
        pSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, 0L );
    }

    return hRes;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wbemq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WBEMQ.H

Abstract:

History:

--*/

#ifndef __WBEM_QUEUE__H_
#define __WBEM_QUEUE__H_

class CWbemQueue;

class CWbemRequest : public CCoreExecReq
{
protected:
    IWbemContext* m_pContext;
    IWbemCausalityAccess* m_pCA;
    IWbemCallSecurity *m_pCallSec;

	//
	// This flag was added to allow requests to be run immediately rather than being
	// enqueued and serviced at a later point. This is done
	// by bumping the priority of the request up.
	//
	// CAUTION!!!IF THIS FLAG IS SET TO > 0 THE REQUEST WILL RUN NO MATTER WHAT!
	// IF WE'RE OUT OF THREADS ANOTHER THREAD WILL BE CREATED TO HANDLE
	// THE REQUEST! ****** USE CAUTION ******
	//
	// By default this flag is 0.
	//
    ULONG m_ulForceRun;


public:
    CWbemRequest(IWbemContext* pContext, BOOL bInternallyIssued);
    ~CWbemRequest();

    BOOL IsChildOf(CWbemRequest* pOther);
    BOOL IsChildOf(IWbemContext* pOther);

public:
    virtual CWbemQueue* GetQueue() {return NULL;}
    INTERNAL IWbemContext* GetContext() {return m_pContext;}
    void GetHistoryInfo(long* plNumParents, long* plNumSiblings);

    INTERNAL IWbemCallSecurity *GetCallSecurity() { return m_pCallSec; }
    BOOL IsSpecial();
    BOOL IsCritical();
    BOOL IsDependee();
    BOOL IsAcceptableByParent();
    BOOL IsIssuedByProvider();
    VOID SetForceRun ( ULONG ulForce ) { m_ulForceRun = ulForce; }
    ULONG GetForceRun ( ) { return m_ulForceRun; }
    virtual BOOL IsLongRunning() {return FALSE;}
    virtual BOOL IsInternal() = 0;
    virtual void TerminateRequest(HRESULT hRes){return;};
};

class CWbemQueue : public CCoreQueue
{
protected:
    long m_lChildPenalty;
    long m_lSiblingPenalty;
    long m_lPassingPenalty;

public:
    CWbemQueue();

    virtual BOOL IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq);
    virtual LPCWSTR GetType() {return L"WBEMQ";}
    virtual void AdjustPriorityForPassing(CCoreExecReq* pReq);
    virtual void AdjustInitialPriority(CCoreExecReq* pReq);

    static CWbemRequest* GetCurrentRequest();

    void SetRequestPenalties(long lChildPenalty, long lSiblingPenalty,
                                long lPassingPenalty);

    virtual BOOL Execute(CThreadRecord* pRecord);
    virtual BOOL DoesNeedNewThread(CCoreExecReq* pReq, bool bIgnoreNumRequests = false );
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmiarbitrator.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    WmiArbitrator.cpp

Abstract:
    Implementation of the arbitrator.  The arbitrator is the class which
    watches over everything to make sure it is not using too many resources.
    Big brother is watching over you :-)


History:
    paulall     09-Apr-00       Created.
    raymcc      08-Aug-00       Made it actually do something useful

--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"

#include "wbemcore.h"
#include "wmiarbitrator.h"
#include "wmifinalizer.h"
#include "wmimerger.h"
#include "cfgmgr.h"

#include <sync.h>
#include <malloc.h>

CWmiArbitrator *CWmiArbitrator::m_pArb = 0;

static DWORD g_dwHighwaterTasks = 0;
static DWORD g_dwThrottlingEnabled = 1;

extern LONG s_Finalizer_ObjectCount ;

#define MEM_CHECK_INTERVAL              3000            //  3 seconds
#define POLL_INTERVAL                     75            // milliseconds

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Arbitrator defaults
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define ARBITRATOR_NO_THROTTLING        0
#define ARBITRATOR_DO_THROTTLING        1

#define ARB_DEFAULT_SYSTEM_HIGH                0x4c4b400               // System limits [80megs]
#define ARB_DEFAULT_SYSTEM_HIGH_FACTOR        50                        // System limits [80megs] factor
#define ARB_DEFAULT_SYSTEM_REQUEST_FACTOR    0.9                        // Percentage factor determining new request approval
#define ARB_DEFAULT_MAX_SLEEP_TIME            300000                  // Default max sleep time for each task
#define ARB_DEFAULT_HIGH_THRESHOLD1            90                      // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD1MULT        2                       // High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD2            95                      // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD2MULT        3                       // High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD3            98                      // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD3MULT        4                       // High threshold 1 multiplier


#define REGKEY_CIMOM                    "Software\\Microsoft\\Wbem\\CIMOM"
#define REGVALUE_SYSHIGH                "ArbSystemHighMaxLimit"
#define REGVALUE_MAXSLEEP               "ArbTaskMaxSleep"
#define REGVALUE_HT1                    "ArbSystemHighThreshold1"
#define REGVALUE_HT1M                   "ArbSystemHighThreshold1Mult"
#define REGVALUE_HT2                    "ArbSystemHighThreshold2"
#define REGVALUE_HT2M                   "ArbSystemHighThreshold2Mult"
#define REGVALUE_HT3                    "ArbSystemHighThreshold3"
#define REGVALUE_HT3M                   "ArbSystemHighThreshold3Mult"
#define REGVALUE_THROTTLING_ENABLED     "ArbThrottlingEnabled"


static DWORD ProcessCommitCharge();
static DWORD WINAPI TaskDiagnosticThread(CWmiArbitrator *pArb);

// Enables debug messages for additional info.
#ifdef DBG
  //#define __DEBUG_ARBITRATOR_THROTTLING
#endif


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::Initialize(
    IN _IWmiArbitrator ** ppArb
    )
{
    if (!ppArb)
        return WBEM_E_INVALID_PARAMETER;
    if (NULL == m_pArb)
        m_pArb = new CWmiArbitrator; // inital refcout == 1
    if (!m_pArb)
        return WBEM_E_OUT_OF_MEMORY;

    if (m_pArb->m_hTerminateEvent)
    {
        if (!TaskDiagnosticThread(m_pArb))
        {
            // no diagnostic thread, do not leak the vent
            CloseHandle(m_pArb->m_hTerminateEvent);
            m_pArb->m_hTerminateEvent = NULL;
        }
    }


    m_pArb->InitializeRegistryData ( );

    *ppArb = m_pArb;
    (* ppArb)->AddRef();

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::InitializeRegistryData( )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    m_bSetupRunning = FALSE;

    m_uTotalMemoryUsage = 0;
    m_uTotalSleepTime = 0;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Get Arbitrator related info from registry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    ULONG ulSystemHighFactor = ARB_DEFAULT_SYSTEM_HIGH_FACTOR ;

    ConfigMgr::GetArbitratorValues( &g_dwThrottlingEnabled, &ulSystemHighFactor, &m_lMaxSleepTime,
                                &m_dThreshold1, &m_lThreshold1Mult, &m_dThreshold2,
                                &m_lThreshold2Mult, &m_dThreshold3, &m_lThreshold3Mult );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Initially, Floating Low is the same as System High
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    m_fSystemHighFactor = ulSystemHighFactor / ( (double) 100 ) ;
    m_lFloatingLow = 0 ;
    m_uSystemHigh = 0 ;

    UpdateMemoryCounters ( TRUE ) ;                                // TRUE = Force the update of counters since we're just starting up


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Calculate the base multiplier
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    m_lMultiplier = ( ARB_DEFAULT_MAX_SLEEP_TIME / (double) m_uSystemHigh ) ;

    m_bSetupRunning = IsNtSetupRunning();
    if ( m_bSetupRunning )
    {
        g_dwThrottlingEnabled = FALSE;
    }

    m_lUncheckedCount = ConfigMgr::GetUncheckedTaskCount ( );

    return hRes;
}

//***************************************************************************
//
HRESULT CWmiArbitrator::Shutdown(BOOL bIsSystemShutdown)
{
    if (m_pArb)
    {
        // Mark all namespaces so as to no longer accept requests

        {
            CInCritSec _cs ( &m_pArb->m_csNamespace ); // SEC:REVIEWED 2002-03-22 : Assumes entry

            if (m_pArb->m_hTerminateEvent)
                SetEvent(m_pArb->m_hTerminateEvent);

            for (LIST_ENTRY * pNext = m_pArb->m_NameSpaceList.Flink;
                pNext != &m_pArb->m_NameSpaceList;
                )
            {
                CWbemNamespace *pRemove = CONTAINING_RECORD(pNext,CWbemNamespace,m_EntryArb);

                // get the pNext pointer before CoDisconnectObject makes
                // you point to already deleted memory
                pNext = pNext->Flink;

                // here nasty code
                // the arbitrator has an improper reference to the CWbemNamespace
                // hence we might have a thread executing the destructor
                // and stopped in the UnregisterNamespace function
                // in that case avoid double destruction with complicity of CoDisconnect
                pRemove->StopClientCalls();
                if (1 == pRemove->AddRef())
                {
                    // do nothing we've caused a transition 0->1.
                    // since it was zero already it means a final release was being processed
                    // but we are holding the CritSec for UnregisterNamespace
                }
                else
                {
                    CoDisconnectObject((IWbemServices *)pRemove,0);
                    pRemove->Release();
                }
            }
        }

        // cancel all tasks

        CFlexArray aCanceled;  // SEC:REVIEWED 2002-03-22 : Needs EH in case of construct failure

        // Grab all outstanding tasks which require cancellation.
        // ======================================================


        {
            CInCritSec _cs2 ( &m_pArb->m_csTask );  // SEC:REVIEWED 2002-03-22 : Assumes entry
            for (int i = 0; i < m_pArb->m_aTasks.Size(); i++)
            {
                CWmiTask *pTask = (CWmiTask *) m_pArb->m_aTasks[i];
                if (pTask == 0)
                    continue;

                if (CFlexArray::no_error  == aCanceled.Add(pTask))
                {
                    pTask->AddRef();                    
                }
            }
        }


        // Now cancel all those.
        // =====================

        if (!bIsSystemShutdown)
        {
            for (int i = 0; i < aCanceled.Size(); i++)
            {
                CWmiTask *pTask = (CWmiTask *) aCanceled[i];
                if (pTask)
                {
                    pTask->Cancel(WBEM_E_SHUTTING_DOWN);
                    pTask->Release();
                }
            }
        }


        {
            CInCritSec _cs2 ( &m_pArb->m_csTask ); // SEC:REVIEWED 2002-03-22 : Assumes entry
            for (int i = m_pArb->m_aTasks.Size() - 1; i >= 0; i--)
            {
                CWmiTask *pTask = (CWmiTask *) m_pArb->m_aTasks[i];
                if (pTask == 0)
                    continue;

                pTask->Release();
            }
            m_pArb->m_aTasks.Empty();
        }

        {
            CInCritSec cs (  &m_pArb->m_csArbitration );// SEC:REVIEWED 2002-03-22 : Assumes entry

            ULONG lDelta = -(m_pArb->m_uTotalMemoryUsage) ;
            m_pArb->m_uTotalMemoryUsage += lDelta ;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Since the first thing we do in ReportMemoryUsage and Throttle is to
            // call UpdateCounters we could be in the position where someone
            // attempts to call with a delta that drops us below zero. If so, we
            // ignore it
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            m_pArb->m_lFloatingLow -= lDelta;
        }
    }

    if (m_pArb)
    {
        m_pArb->m_bShutdown = TRUE;
        m_pArb->Release();
        m_pArb = NULL;
    }
        
    return WBEM_S_NO_ERROR;
}


//////// test test test test test

BOOL CWmiArbitrator::IsTaskInList(CWmiTask * pf)
{
    CInCritSec cs(&m_csTask); // SEC:REVIEWED 2002-03-22 : Assumes entry

    for (int i = 0; i < m_aTasks.Size(); i++)
    {
        CWmiTask *phTest = (CWmiTask *) m_aTasks[i];

        if (phTest == pf)
        {
            return TRUE;
        }
    }
    return FALSE;
}



//////// test test test test test

//***************************************************************************
//
//***************************************************************************
CWmiArbitrator::CWmiArbitrator():m_bShutdown(FALSE)
{
    m_lRefCount = 1;

    m_uTotalTasks = 0;
    m_uTotalPrimaryTasks = 0;
    m_uTotalThrottledTasks = 0 ;

    m_hTerminateEvent = CreateEvent(NULL,TRUE,FALSE,NULL);   // SEC:REVIEWED 2002-03-22 : OK
    InitializeListHead(&m_NameSpaceList);
}

//***************************************************************************
//
//***************************************************************************
CWmiArbitrator::~CWmiArbitrator()
{
    //DeleteCriticalSection(&m_csTask);
    //DeleteCriticalSection(&m_csNamespace);
    //DeleteCriticalSection( &m_csArbitration );

    if (m_hTerminateEvent)
        CloseHandle(m_hTerminateEvent);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID__IWmiArbitrator==riid)
    {
        *ppvObj = (_IWmiArbitrator*)this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiArbitrator::AddRef()
{
    //DWORD * p = (DWORD *)_alloca(sizeof(DWORD));
    return InterlockedIncrement(&m_lRefCount);
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiArbitrator::Release()
{
    //DWORD * p = (DWORD *)_alloca(sizeof(DWORD));
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterTask(
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    CWmiTask *pTsk = (CWmiTask *) phTask;

    if (pTsk == 0 || phTask == 0)
        return WBEM_E_INVALID_PARAMETER;

    ULONG uTaskType = pTsk->GetTaskType();

    // For primary task types only.
    // ============================

    DWORD dwMaxTasksAllowed = ConfigMgr::GetMaxTaskCount();

    if (dwMaxTasksAllowed && (uTaskType & WMICORE_TASK_TYPE_PRIMARY))
    {
        // Initial check.  If too many tasks, wait a bit.
        // No need for strict synchronization with the critsec
        // or exact maximum.  An approximation can obviously
        // happen (several threads can be let through and the maximum
        // exceeded by several units) No big deal, though.
        // ==========================================================

        int nTotalRetryTime = 0;

        if (
                !pTsk->IsESSNamespace ( ) &&
                !pTsk->IsProviderNamespace ( ) &&                 
                CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY &&
                !m_bSetupRunning &&
                IsTaskArbitrated ( pTsk ) )
          {
            while (m_uTotalPrimaryTasks > dwMaxTasksAllowed)
            {
                Sleep(POLL_INTERVAL);
                nTotalRetryTime += POLL_INTERVAL;
                if (nTotalRetryTime > ConfigMgr::GetMaxWaitBeforeDenial())
                    return WBEM_E_SERVER_TOO_BUSY;
            }
        }

        nTotalRetryTime = 0;

        // Check max committed memory.
        // ============================
        if ( !m_bSetupRunning )
        {
            /*DWORD dwMaxMem = ConfigMgr::GetMaxMemoryQuota();
            DWORD dwCurrentCharge = ProcessCommitCharge();*/

            while ( ( AcceptsNewTasks ( NULL ) == FALSE ) &&
                    ( uTaskType & WMICORE_TASK_TYPE_PRIMARY ) &&
                    ( pTsk->IsESSNamespace ( ) == FALSE ) &&
                    ( pTsk->IsProviderNamespace ( ) == FALSE ) &&
                    ( m_bSetupRunning == FALSE ) &&
                    ( IsTaskArbitrated ( pTsk ) == TRUE ) )

            {
                Sleep(POLL_INTERVAL);
                nTotalRetryTime += POLL_INTERVAL;
                if (nTotalRetryTime > ConfigMgr::GetMaxWaitBeforeDenial())
                    return WBEM_E_QUOTA_VIOLATION;
            }
        }


        // Now, we fit within the max. Still, if there are several
        // ongoing tasks, sleep various amounts.
        // ========================================================

        nTotalRetryTime = 0;


        if (
                !pTsk->IsESSNamespace ( ) &&
                !pTsk->IsProviderNamespace ( ) &&
                CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY &&
                !m_bSetupRunning &&
                IsTaskArbitrated ( pTsk ) )
        {
            if (m_uTotalThrottledTasks > m_lUncheckedCount )
            {
                int nTotalTime = m_uTotalThrottledTasks * ConfigMgr::GetNewTaskResistance();

                while (nTotalRetryTime < nTotalTime)
                {
                    Sleep(POLL_INTERVAL);
                    nTotalRetryTime += POLL_INTERVAL;
                    if (m_uTotalThrottledTasks <= m_lUncheckedCount )
                        break;
                }
            }
        }
    }

    // Go ahead and add the task.
    // ==========================

    {
        CInCritSec _cs2 ( &m_csTask ); // SEC:REVIEWED 2002-03-22 : Assumes entry

        if (CFlexArray::no_error != m_aTasks.Add(phTask))  return WBEM_E_OUT_OF_MEMORY;

        phTask->AddRef();        

        m_uTotalTasks++;

        if (m_uTotalTasks > g_dwHighwaterTasks)
            g_dwHighwaterTasks = m_uTotalTasks;

        if ( ( uTaskType & WMICORE_TASK_TYPE_PRIMARY ) && CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY )
        {
            m_uTotalPrimaryTasks++;
            
            //
            // If this task hasnt been accounted for in the number of throttled tasks,
            // increase the nymber of throttled tasks
            //
            if ( pTsk->IsAccountedForThrottling ( ) == FALSE )
            {
                RegisterTaskForEntryThrottling ( pTsk ) ;
            }
        }
        m_lMultiplierTasks = ( m_uTotalPrimaryTasks / (DOUBLE) 100 ) + 1;
    }
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterTask(
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    CWmiTask *pTsk = (CWmiTask *) phTask;

    if (pTsk == 0)
        return WBEM_E_INVALID_PARAMETER;

    ULONG uTaskType = pTsk->GetTaskType();

    CCheckedInCritSec _cs2 ( &m_csTask );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    for (int i = 0; i < m_aTasks.Size(); i++)
    {
        _IWmiCoreHandle *phTest = (_IWmiCoreHandle *) m_aTasks[i];

        if (phTest == phTask)
        {
            CWmiTask *pTsk = (CWmiTask *) phTask;   // Cannot be NULL due to precondition above

            m_aTasks.RemoveAt(i);
            m_uTotalTasks--;

            ClearCounters ( 0 ) ;
        
            ULONG uType = pTsk->GetTaskType();
            if ( ( uType & WMICORE_TASK_TYPE_PRIMARY ) && CORE_TASK_TYPE(uTaskType) != WMICORE_TASK_EXEC_NOTIFICATION_QUERY )
            {
                m_uTotalPrimaryTasks--;
        
                //
                // If this task hasnt been accounted for in the number of throttled tasks,
                // increase the nymber of throttled tasks
                //
                if ( pTsk->IsAccountedForThrottling ( ) == TRUE )
                {
                    UnregisterTaskForEntryThrottling ( pTsk ) ;
                }
            }

            

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Throttle code
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if ( g_dwThrottlingEnabled )
            {
                if ( IsTaskArbitrated ( pTsk ) )
                {
                    m_lMultiplierTasks = ( m_uTotalPrimaryTasks / (DOUBLE) 100 ) + 1;
                }

                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // When we unregister a task we also have to make sure the task
                // isnt suspended (throttled). If it is, we need to wake up the
                // throttled thread.
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if ( pTsk->GetTaskStatus ( ) == WMICORE_TASK_STATUS_SUSPENDED )
                {
                    if (pTsk->GetTimerHandle())
                        SetEvent ( pTsk->GetTimerHandle());
                }
            }

            _cs2.Leave ( );

            //
            // If we cancelled due to throttling, ensure that we use the client flag to avoid returning -1 as the
            // operation result.
            //
            if ( pTsk->GetCancelledState ( ) == TRUE )
            {
                pTsk->Cancel ( WMIARB_CALL_CANCELLED_THROTTLING) ;
            }
            else
            {
                pTsk->Cancel ( ) ;
            }

            phTask->Release();

            return WBEM_S_NO_ERROR;
        }
    }
    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterUser(
    /*[in]*/ _IWmiCoreHandle *phUser
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterUser(
    /*[in]*/ _IWmiCoreHandle *phUser
    )
{
    return E_NOTIMPL;
}


STDMETHODIMP CWmiArbitrator::CancelTasksBySink(ULONG uFlags,REFIID riid,LPVOID pSink)
{
    if (riid != IID_IWbemObjectSink)
        return WBEM_E_NOT_SUPPORTED;

    if (pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hr;
    GUID PrimaryId = GUID_NULL;
    do
    {
        hr = pCancelTasksBySink(uFlags,riid,pSink,PrimaryId);
    } while(SUCCEEDED(hr));
    
    if (WBEM_E_NOT_FOUND == hr) hr = S_OK;
    return hr;
}

__forceinline void ArrayRelease(IUnknown ** ppUnk,SIZE_T Size)
{
    for (SIZE_T i=0;i<Size;i++)
    	if (ppUnk[i]) ppUnk[i]->Release();
}

//***************************************************************************
//
//***************************************************************************
//
STDMETHODIMP CWmiArbitrator::pCancelTasksBySink(ULONG uFlags,
												REFIID riid,
												LPVOID pSink,
												GUID & PrimaryId)
{

    try
    {
        // Grab all outstanding tasks which require cancellation.
        // ======================================================

        int IndexAdded = 0;
        int InsertionPosition = 0;
        CWmiTask * aDepTask[32];
        memset(aDepTask,0,sizeof(aDepTask));
        int SizeLocalArray = LENGTH_OF(aDepTask);
        OnDeleteIf2<IUnknown ** ,SIZE_T ,
        	        void(*)(IUnknown ** ,SIZE_T ),
        	        ArrayRelease> arrayRelease((IUnknown **)aDepTask,SizeLocalArray);
        
        // scope for critsect
        {
            CInCritSec _cs2 ( &m_csTask ); // SEC:REVIEWED 2002-03-22 : Assumes entry

            // Loop through tasks looking for matchin sink.
            // ============================================


            for (int i = 0; i < m_aTasks.Size() && (IndexAdded < SizeLocalArray); i++)
            {
                CWmiTask *pTask = (CWmiTask *) m_aTasks[i];
                if (pTask == 0)
                    continue;

                if (pTask->HasMatchingSink(pSink, riid) == WBEM_S_NO_ERROR)
                {
                    // since we are using the pre-allocated storage, no failures expected
                    aDepTask[IndexAdded++] = pTask;
                    pTask->AddRef();
                }
            }

            // Next get all dependent tasks, because they also need cancelling.
            // Essentially a transitive closure of all child tasks.
            // ================================================================

            InsertionPosition = IndexAdded;
            if (0 == InsertionPosition && (GUID_NULL != PrimaryId))
           	{
           	    //
           	    // this is the case where we carry over from the previous iteration
           	    // the PrimaryId, but we have already removed the parent task
           	    //
       		    for (int i2 = 0; i2 < m_aTasks.Size() && InsertionPosition < SizeLocalArray; i2++)
                {
                    CWmiTask *pTask2 = (CWmiTask *) m_aTasks[i2];
                    if (pTask2 == 0)
                        continue;

                    CWbemContext *pCtx = pTask2->GetCtx();
                    if (pCtx == 0)
                        continue;
                    HRESULT hRes = pCtx->IsChildOf(PrimaryId);
                    if (hRes == S_OK)
                    {
                        // since we are using the pre-allocated storage, no failures expected                    
                        aDepTask[InsertionPosition++] = pTask2;
                        pTask2->AddRef();                        
                    }
                }
           	}
            else
           	{
	            for (i = 0; i < IndexAdded && (InsertionPosition < SizeLocalArray); i++)
	            {
	                CWmiTask *pTask = (CWmiTask *) aDepTask[i];
	                CWbemContext *pCtx = pTask->GetCtx();
	                if (pCtx == 0)
	                    continue;
	                pCtx->GetRequestId(&PrimaryId);
	                if (PrimaryId == GUID_NULL)
	                    continue;

	                // <Id> is now the context request ID which needs cancellation.

	                for (int i2 = 0; i2 < m_aTasks.Size(); i2++)
	                {
	                    CWmiTask *pTask2 = (CWmiTask *) m_aTasks[i2];
	                    if (pTask2 == 0 || pTask2 == pTask)
	                        continue;

	                    CWbemContext *pCtx = pTask2->GetCtx();
	                    if (pCtx == 0)
	                        continue;
	                    HRESULT hRes = pCtx->IsChildOf(PrimaryId);
	                    if (hRes == S_OK)
	                    {
	                        // since we are using the pre-allocated storage, no failures expected                    
	                        aDepTask[InsertionPosition++] = pTask2;
	                        pTask2->AddRef();                        
	                    }
	                } // for i2
	            } // for i
           	}
        } // critsec block

        if (0 == InsertionPosition) return WBEM_E_NOT_FOUND;

        // Now cancel all those.
        // =====================

        for (int i = 0; i < InsertionPosition; i++)
        {
            CWmiTask *pTask = (CWmiTask *) aDepTask[i];
            aDepTask[i] = NULL;            
            if (!pTask) continue;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Throttle code
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if ( g_dwThrottlingEnabled )
            {
                if ( IsTaskArbitrated ( pTask ) )
                {
                    m_lMultiplierTasks = ( m_uTotalPrimaryTasks / (DOUBLE) 100 ) + 1;
                }

                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // When we unregister a task we also have to make sure the task
                // isnt suspended (throttled). If it is, we need to wake up the
                // throttled thread.
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_SUSPENDED )
                {
                    if (pTask->GetTimerHandle())
                        SetEvent ( pTask->GetTimerHandle());
                }
            }

            if ( uFlags == WMIARB_CALL_CANCELLED_CLIENT )
            {
                pTask->Cancel ( WMIARB_CALL_CANCELLED_CLIENT ) ;
            }
            else
            {
                pTask->Cancel (  ) ;
            }
            pTask->Release();
        }
        arrayRelease.dismiss();

        // fake a NOT_FOUND if we are sure the array never overflew
        if (InsertionPosition < SizeLocalArray) return WBEM_E_NOT_FOUND;
    }
    catch (CX_Exception &) 
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckTask(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::TaskStateChange(
    /*[in]*/ ULONG uNewState,               // Duplicate of the state in the task handle itself
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckThread(
    /*[in]*/ ULONG uFlags
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckUser(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiUserHandle *phUser
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CheckUser(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phUser
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::CancelTask(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CWmiTask* pTask = (CWmiTask*) phTask;
    if ( !pTask )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    hRes = pTask->SignalCancellation ( ) ;
    
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterThreadForTask(
    /*[in]*/_IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterThreadForTask(
    /*[in]*/_IWmiCoreHandle *phTask
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::Maintenance()
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterFinalizer(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ _IWmiCoreHandle *phTask,
    /*[in]*/ _IWmiFinalizer *pFinal
    )
{
    _DBG_ASSERT(FALSE);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterNamespace(
    /*[in]*/_IWmiCoreHandle *phNamespace
    )
{
    if (NULL == phNamespace)
        return WBEM_E_INVALID_PARAMETER;

    LIST_ENTRY * pEntry = &((CWbemNamespace *)phNamespace)->m_EntryArb;

    CInCritSec cs(&m_csNamespace); // SEC:REVIEWED 2002-03-22 : Assumes entry
    InsertTailList(&m_NameSpaceList,pEntry);
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnregisterNamespace(
    /*[in]*/_IWmiCoreHandle *phNamespace
    )
{
    if (NULL == phNamespace) return WBEM_E_INVALID_PARAMETER;

    LIST_ENTRY * pEntry = &((CWbemNamespace *)phNamespace)->m_EntryArb;

    CInCritSec cs(&m_csNamespace); // SEC:REVIEWED 2002-03-22 : Assumes entry
    RemoveEntryList(pEntry);

    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::ReportMemoryUsage(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LONG  lDelta,
        /*[in]*/ _IWmiCoreHandle *phTask
    )
{
    HRESULT hRes = WBEM_S_ARB_NOTHROTTLING;


    CWmiTask* pTsk = (CWmiTask*) phTask;
    if ( !pTsk )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check to see if we have throttling enabled via registry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( g_dwThrottlingEnabled )
    {
        //
        // We want to throttle against the primary task, so get the
        // primary task now. If this is the primary task it will return
        // itself. No special casing needed.
        //
        _IWmiCoreHandle* pCHTask;
        pTsk->GetPrimaryTask ( &pCHTask );
        if ( pCHTask == NULL )
            return WBEM_E_INVALID_PARAMETER;

        CWmiTask* pTask = (CWmiTask*) pCHTask;
        if ( !pTask )
            return WBEM_E_INVALID_PARAMETER;

        
        //
        // Since we have a valid task, update the counters. We _need_ to do this
        // even after the task has been cancelled since we outstanding memory
        // consumption
        //
        UpdateCounters ( lDelta, pTask );


        //
        // Has the task been cancelled, if so return NO_THROTTLING
        //
        if ( pTsk->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
        {
            return WBEM_S_ARB_NOTHROTTLING ;
        }


        if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
        {
            return WBEM_E_CALL_CANCELLED;
        }

        if ( !IsTaskArbitrated ( pTask ) )
        {
            return hRes;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // First thing we do is check if we're pushed over the limit.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        if ( m_uTotalMemoryUsage > m_uSystemHigh )
        {
            hRes = WBEM_E_ARB_CANCEL;
            pTask->SetCancelState ( TRUE );
        }

        else
        {
            pTask->SetCancelState ( FALSE );
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Next, we call our internal function with no
            // throttling
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            hRes = Arbitrate ( ARBITRATOR_NO_THROTTLING, lDelta, pTask );
        }
    }
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::Throttle(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle* phTask
    )
{
    HRESULT hRes = WBEM_S_ARB_NOTHROTTLING;

    if ( !phTask )
    {
        return WBEM_E_INVALID_PARAMETER;
    }


    CWmiTask* pTsk = (CWmiTask*) phTask;
    if ( !pTsk )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Has the task been cancelled, if so return NO_THROTTLING
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( pTsk->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
    {
        return WBEM_S_ARB_NOTHROTTLING;
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check to see if we have throttling enabled via registry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( g_dwThrottlingEnabled )
    {

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // We want to throttle against the primary task, so get the
        // primary task now. If this is the primary task it will return
        // itself. No special casing needed.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        _IWmiCoreHandle* pCHTask;
        pTsk->GetPrimaryTask ( &pCHTask );
        if ( pCHTask == NULL )
            return WBEM_E_INVALID_PARAMETER;

        CWmiTask* pTask = (CWmiTask*) pCHTask;
        if ( !pTask )
            return WBEM_E_INVALID_PARAMETER;


        if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
        {
            return WBEM_E_CALL_CANCELLED;
        }

        if ( !IsTaskArbitrated ( pTask ) )
        {
            return hRes;
        }

        ULONG lCancelState;
        pTask->GetCancelState ( &lCancelState );


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Check if this task was promised to be cancelled
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( ( m_uTotalMemoryUsage > m_uSystemHigh ) && ( lCancelState ) )
        {
            #ifdef __DEBUG_ARBITRATOR_THROTTLING
                WCHAR   wszTemp[128];
                HRESULT h = StringCchPrintfW( wszTemp, 128, L"Task 0x%x cancelled due to arbitrator throttling (max memory threshold reached).\n", pTask );  // SEC:REVIEWED 2002-03-22 : OK
                if (SUCCEEDED(h))
                    OutputDebugStringW( wszTemp );
            #endif
            DEBUGTRACE((LOG_WBEMCORE, "Task 0x%x cancelled due to arbitrator throttling (max memory threshold reached).\n", pTask ) );  // SEC:REVIEWED 2002-03-22 : OK

            pTask->Cancel ( );
            hRes = WBEM_E_ARB_CANCEL;
        }
        else
        {
            hRes = Arbitrate ( ARBITRATOR_DO_THROTTLING, 0, (CWmiTask*) phTask );
        }
    }
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::RegisterArbitratee(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CWmiTask *p = (CWmiTask *) phTask;
    if (!p || !pArbitratee)
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }

    CWmiTask* pTask = (CWmiTask*) phTask;
    if ( !pTask )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    if ( pTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
    {
        return WBEM_E_CALL_CANCELLED;
    }

    if ( SUCCEEDED (hRes) )
    {
        hRes = p->AddArbitratee(0, pArbitratee);
    }

    return hRes;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiArbitrator::UnRegisterArbitratee(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CWmiTask *p = (CWmiTask *) phTask;
    if (!p || !pArbitratee )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }

    if ( SUCCEEDED (hRes) )
    {
        hRes = p->RemoveArbitratee(0, pArbitratee);
    }

    ClearCounters ( 0 ) ;

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::UpdateCounters ( LONG lDelta, CWmiTask* phTask )
{
    CInCritSec cs ( &m_csArbitration ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    //
    // Lets see if we need to update memory counters
    //
    UpdateMemoryCounters ( ) ;

    
#ifdef __DEBUG_ARBITRATOR_THROTTLING    
    _DBG_ASSERT ( m_uTotalMemoryUsage+lDelta <= 0xF0000000 ) ;
#endif

    m_uTotalMemoryUsage += lDelta;
    m_lFloatingLow -= lDelta;

    if ( phTask )
    {
        phTask->UpdateMemoryUsage ( lDelta );
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::Arbitrate ( ULONG uFlags, LONG lDelta, CWmiTask* phTask )
{
    HRESULT hRes = WBEM_S_ARB_NOTHROTTLING;

    ULONG memUsage;
    ULONG sleepTime;

    if ( lDelta > 0 || (uFlags == ARBITRATOR_DO_THROTTLING) )
    {
        LONG lMultiplierHigh = 1;

        phTask->GetMemoryUsage ( &memUsage );
        phTask->GetTotalSleepTime ( &sleepTime );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Did we reach the arbitration point?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( (LONG) memUsage > m_lFloatingLow )
        {
            hRes = WBEM_E_ARB_THROTTLE;
            if ( uFlags == ARBITRATOR_DO_THROTTLING )
            {
                {
                    CInCritSec _cs ( &m_csTask ); // SEC:REVIEWED 2002-03-22 : Assumes entry
                    if ( phTask->GetTaskStatus ( ) != WMICORE_TASK_STATUS_CANCELLED )
                    {
                        if (phTask->GetTimerHandle())
                            ResetEvent ( phTask->GetTimerHandle() );
                    }
                    else
                    {
                        return WBEM_E_CALL_CANCELLED;
                    }
                }

                if ( ( sleepTime < m_lMaxSleepTime ) || ( m_lMaxSleepTime == 0 ) )
                {
                    if ( memUsage >= (m_uSystemHigh * m_dThreshold3) )
                    {
                        lMultiplierHigh = m_lThreshold3Mult;
                    }
                    else if ( memUsage >= (m_uSystemHigh * m_dThreshold2) )
                    {
                        lMultiplierHigh = m_lThreshold2Mult;
                    }
                    else if ( memUsage >= (m_uSystemHigh * m_dThreshold1) )
                    {
                        lMultiplierHigh = m_lThreshold1Mult;
                    }

                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // Do an extra check to make sure the task didnt release some
                    // memory
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    phTask->GetMemoryUsage ( &memUsage );
                    phTask->GetTotalSleepTime ( &sleepTime );

                    //
                    // Floating low could have changed after the conditional below which could
                    // put us in a situation where we get a negative sleep time (BAD)
                    //
                    __int64 tmpFloatingLow = m_lFloatingLow ;

                    if ( (LONG) memUsage > tmpFloatingLow )
                    {
                        ULONG ulSleepTime = (ULONG) ( ( memUsage - tmpFloatingLow ) * m_lMultiplier * m_lMultiplierTasks * lMultiplierHigh );
                        phTask->SetLastSleepTime ( ulSleepTime );
                        m_uTotalSleepTime += ulSleepTime;

                        phTask->UpdateTotalSleepTime ( ulSleepTime );


                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // Delayed creation of event
                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        HRESULT hEventhRes = WBEM_S_NO_ERROR;
                        {
                            CInCritSec _cs ( &m_csArbitration ); // SEC:REVIEWED 2002-03-22 : Assumes entry
                            if ( !phTask->GetTimerHandle())
                            {
                                hEventhRes = phTask->CreateTimerEvent();
                            }
                        }

                        if ( SUCCEEDED ( hEventhRes ) )
                        {
                            hRes = DoThrottle ( phTask, ulSleepTime, memUsage );
                        }
                        else
                        {
                            hRes = hEventhRes;
                        }
                    }
                }
                else
                {
                    hRes = WBEM_E_ARB_CANCEL;
                    if ( uFlags == ARBITRATOR_DO_THROTTLING )
                    {
                        #ifdef __DEBUG_ARBITRATOR_THROTTLING
                            WCHAR   wszTemp[128];
                            HRESULT h = StringCchPrintfW( wszTemp, 128, L"Task 0x%x cancelled due to arbitrator throttling (excessive sleep time = 0x%x).\n", phTask, sleepTime ); // SEC:REVIEWED 2002-03-22 : OK
                            if (SUCCEEDED(h))
                                OutputDebugStringW( wszTemp );
                        #endif
                        DEBUGTRACE((LOG_WBEMCORE, "Task 0x%x cancelled due to arbitrator throttling (excessive sleep time = 0x%x).\n", phTask, sleepTime ) ); // SEC:REVIEWED 2002-03-22 : OK

                        //
                        // The reason we are cancelling is because of throttling. Let the task know about it!
                        //
                        phTask->SetCancelledState ( TRUE ) ;

                        CancelTask ( 0, phTask );
                        UnregisterTask ( phTask );
                    }
                }
            }
        }
    }
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiArbitrator::DoThrottle ( CWmiTask* phTask, ULONG ulSleepTime, ULONG ulMemUsage )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Lets wait for the event....we are expecting to time out this
    // wait, unless we are woken up due to memory usage decrease or
    // cancellation of task has happened
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#ifdef __DEBUG_ARBITRATOR_THROTTLING
    WCHAR   wszTemp[128];
    HRESULT h =StringCchPrintfW( wszTemp, 128, L"Thread 0x%x throttled in arbitrator for 0x%x ms. Task memory usage is 0x%xb\n", GetCurrentThreadId(), ulSleepTime, ulMemUsage ); // SEC:REVIEWED 2002-03-22 : OK
    if (SUCCEEDED(h))
       OutputDebugStringW( wszTemp );
#endif

    DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x throttled in arbitrator for 0x%x ms. Task memory usage is 0x%xb\n", GetCurrentThreadId(), ulSleepTime, ulMemUsage ) ); // SEC:REVIEWED 2002-03-22 : OK

    DWORD dwRes = CCoreQueue :: QueueWaitForSingleObject ( phTask->GetTimerHandle(), ulSleepTime );

    DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x woken up in arbitrator.\n", GetCurrentThreadId() ) );

#ifdef __DEBUG_ARBITRATOR_THROTTLING
    StringCchPrintfW( wszTemp, 128, L"Thread 0x%x woken up in arbitrator.\n", GetCurrentThreadId() );   // SEC:REVIEWED 2002-03-22 : OK
    if (SUCCEEDED(h))
        OutputDebugStringW( wszTemp );
#endif

    if ( dwRes == WAIT_FAILED )
    {
        hRes = WBEM_E_CRITICAL_ERROR;
    }
    if ( phTask->GetTaskStatus ( ) == WMICORE_TASK_STATUS_CANCELLED )
    {
        hRes = WBEM_E_CALL_CANCELLED;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
BOOL CWmiArbitrator::IsTaskArbitrated ( CWmiTask* phTask )
{
    ULONG uTaskType = phTask->GetTaskType ( );
    uTaskType = uTaskType & 0xFF;
    return ( ( uTaskType == WMICORE_TASK_ENUM_INSTANCES ) ||  ( uTaskType == WMICORE_TASK_ENUM_CLASSES ) || ( uTaskType == WMICORE_TASK_EXEC_QUERY ) );
}


//***************************************************************************
//
//***************************************************************************
/*STDMETHODIMP CWmiArbitrator::Shutdown()
{
    return E_NOTIMPL;
}
*/
//***************************************************************************
//
//  Returns the commit charge for the process.  Can be called often,
//  but only checks once every 10 seconds or so.
//
//***************************************************************************
//
static DWORD ProcessCommitCharge()
{

    static DWORD dwLastCall = 0;
    static DWORD dwLatestCommitCharge = 0;
    DWORD dwNow = GetCurrentTime();

    if (dwLastCall == 0)
        dwLastCall = dwNow;

    if (dwNow - dwLastCall < MEM_CHECK_INTERVAL)
        return dwLatestCommitCharge;

    dwLastCall = dwNow;


    MEMORY_BASIC_INFORMATION meminf;

    DWORD dwRes;
    LPBYTE pAddr = 0;

    DWORD dwTotalCommit = 0;

    while(1)
    {
        dwRes = VirtualQuery(pAddr, &meminf, sizeof(meminf));
        if (dwRes == 0)
        {
            break;
        }

        if (meminf.State == MEM_COMMIT)
            dwTotalCommit += DWORD(meminf.RegionSize);
        pAddr += meminf.RegionSize;
    }

    dwLatestCommitCharge = dwTotalCommit;
    return dwTotalCommit;

}


/*
    * =====================================================================================================
    |
    | HRESULT CWmiArbitrator::UnregisterTaskForEntryThrottling ( CWmiTask* pTask )
    | ----------------------------------------------------------------------------
    |
    | Used to indicate that a task is still active and part of the arbitrator task list _but_ should not be
    | included in the entry point throttling. This is usefull if you have a task that has finished (i.e.
    | WBEM_STATUS_COMPLETE on the inbound sink), but client is actively retrieving information from the task.
    |
    |
    * =====================================================================================================
*/

HRESULT CWmiArbitrator::UnregisterTaskForEntryThrottling ( CWmiTask* pTask )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;

    //
     // Make sure we have a valid task
    //
    if ( pTask == NULL )
    {
        return WBEM_E_FAILED ;
    }
    
    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec cs ( &m_csTask ) ; // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( pTask->IsAccountedForThrottling ( ) == TRUE )
    {
        pTask->SetAccountedForThrottling ( FALSE ) ;
        m_uTotalThrottledTasks-- ;
    }

    return hRes ;
}



/*
    * =====================================================================================================
    |
    | HRESULT CWmiArbitrator::RegisterTaskForEntryThrottling ( CWmiTask* pTask )
    | --------------------------------------------------------------------------
    |
    | Used to indicate that a task is still active and part of the arbitrator task list _and should_ be
    | included in the entry point throttling.
    |
    |
    * =====================================================================================================
*/

HRESULT CWmiArbitrator::RegisterTaskForEntryThrottling ( CWmiTask* pTask )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;

    //
     // Make sure we have a valid task
    //
    if ( pTask == NULL )
    {
        return WBEM_E_FAILED ;
    }
    
    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec cs ( &m_csTask ) ; // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( pTask->IsAccountedForThrottling ( ) == FALSE )
    {
        pTask->SetAccountedForThrottling ( TRUE ) ;
        m_uTotalThrottledTasks++ ;
    }

    return hRes ;
}



/*
    * =====================================================================================================
    |
    | HRESULT CWmiArbitrator::ClearCounters ( ULONG lFlags, CWmiTask* phTask )
    | ------------------------------------------------------------------------
    |
    | Clears the TotalMemoryUsage and Floating Low (available memory). This is
    | used when the system reaches a state where there are 0 tasks in the queue
    | in which case we clear the counters to be on the safe side.
    |
    * =====================================================================================================
*/

HRESULT CWmiArbitrator::ClearCounters ( ULONG lFlags )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;

    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec cs ( &m_csArbitration ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    //
    // This is as good as any time to check if we need
    // to update the memory counters
    //
    UpdateMemoryCounters ( ) ;

    //
    // Should we in fact clear the counters at this point?
    //
    if ( ( s_Finalizer_ObjectCount == 0 ) && m_aTasks.Size ( ) == 0 )
    {
        //
        // Now we go ahead and clear the counters
        //
        m_uTotalMemoryUsage = 0 ;
        m_lFloatingLow = m_uSystemHigh ;
    }

    return hRes ;
}




/*
    * =====================================================================================================
    |
    | HRESULT CWmiArbitrator::UpdateMemoryCounters ( )
    | ------------------------------------------------
    | Updates the arbitrator memory configuration (such as max memory usage) by
    | calculating the
    |
    * =====================================================================================================
*/

HRESULT CWmiArbitrator::UpdateMemoryCounters ( BOOL bForceUpdate )
{
    HRESULT hResult = WBEM_S_NO_ERROR ;

    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec cs ( &m_csArbitration ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    //
    // Check to see if we need to update, has the timestamp expired?
    // Or is the force update flag specified?
    //
    if ( NeedToUpdateMemoryCounters ( ) || bForceUpdate == TRUE )
    {
        ULONG ulOldSystemHigh = m_uSystemHigh ;
        m_uSystemHigh = GetWMIAvailableMemory ( m_fSystemHighFactor ) ;
        
        //
        // Ensure this isnt the first time we're being called
        //
        if ( m_lFloatingLow != (LONG) ulOldSystemHigh )
        {
            m_lFloatingLow += ( m_uSystemHigh - ulOldSystemHigh ) ;            
        }
        else
        {
            m_lFloatingLow = m_uSystemHigh ;
        }

        m_lMultiplier = ( ARB_DEFAULT_MAX_SLEEP_TIME / (double) m_uSystemHigh ) ;
    }
    return hResult ;
}



/*
    * =====================================================================================================
    |
    | BOOL CWmiArbitrator::NeedToUpdateMemoryCounters ( )
    | ---------------------------------------------------
    | Returns TRUE if memory counters need to be updates, FALSE otherwise.
    | The decision is based on a timer interval defined by:
    |
    | MEM_CHECK_INTERVAL              3000            //  3 seconds
    |
    |
    |
    * =====================================================================================================
*/

BOOL CWmiArbitrator::NeedToUpdateMemoryCounters ( )
{
    BOOL bNeedToUpdate = FALSE ;

    ULONG ulNewMemoryTimer = GetTickCount ( ) ;
    ULONG ulTmpTimer = 0 ;
    BOOL bRollOver = FALSE ;

    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec cs ( &m_csArbitration ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( ulNewMemoryTimer < m_lMemoryTimer )
    {
        //
        // Do we have a roll over situation?
        //
        ulTmpTimer = ulNewMemoryTimer ;
        ulNewMemoryTimer = ulNewMemoryTimer + m_lMemoryTimer ;
        bRollOver = TRUE ;
    }
    
    if ( ( ( ulNewMemoryTimer - m_lMemoryTimer ) > MEM_CHECK_INTERVAL ) )
    {
        if ( bRollOver )
        {
            m_lMemoryTimer = ulTmpTimer ;
        }
        else
        {
            m_lMemoryTimer = ulNewMemoryTimer ;
        }

        bNeedToUpdate = TRUE ;
    }
    
    return bNeedToUpdate ;
}

/*
    * =====================================================================================================
    |
    | ULONG CWmiArbitrator::GetWMIAvailableMemory ( )
    | -----------------------------------------------
    | Returns the amount of memory available to WMI. This is calculated according
    | to:
    |        MemoryFactor * ( AvailablePhysicalMemory + AvailablePagingSpace )
    |
    | where MemoryFactor is determined at startup by reading the
    | ArbSystemHighMaxLimitFactor registry key.
    |
    * =====================================================================================================
*/

__int64  CWmiArbitrator::GetWMIAvailableMemory ( DOUBLE ulFactor )
{

    //
    // Get system wide memory status
    //
    MEMORYSTATUSEX memStatus;
    memStatus.dwLength = sizeof ( MEMORYSTATUSEX );
    __int64 ulMem = 0;

    if ( !GlobalMemoryStatusEx ( &memStatus ) )
    {
        //
        // We need to set the memory to an absolut minimum.
        // We get this from the ConfigMgr since we use this
        // in other places as well
        //
        ulMem = ConfigMgr::GetMinimumMemoryRequirements ( ) ;
    }
    else
    {
        //
        // Use MemoryFactor * ( AvailablePhysicalMemory + AvailablePagingSpace + current mem consumtion )
        // to figure out how much memory we can use. We need to figure in our current memory consumption,
        // or else we run double calculate.
        //
        ulMem = ( ulFactor * ( memStatus.ullAvailPhys + memStatus.ullAvailPageFile + m_uTotalMemoryUsage ) ) ;
    }

    return ulMem ;
}


/*
    * =====================================================================================================
    |
    | BOOL CWmiArbitrator::AcceptsNewTasks ( )
    | ----------------------------------------
    | Returns TRUE if the arbitrator is currently accepting new tasks, otherwise
    | FALSE. This is determined by checking if WMIs memory consumption is within
    | a certain percentage of total memory available. The factor is defined in
    |
    | ARB_DEFAULT_SYSTEM_REQUEST_FACTOR        0.9
    |
    | By default this value is 90%
    |
    * =====================================================================================================
*/

BOOL CWmiArbitrator::AcceptsNewTasks( CCoreExecReq* pReq )
{
    
    if (pReq && PriorityFreeMemRequests == pReq->GetPriority())
        return TRUE;

    BOOL bAcceptsNewTasks = TRUE ;

    //
    // Lets check if we need to update memory counters
    //
    UpdateMemoryCounters ( ) ;
    
    CInCritSec cs ( &m_csArbitration ); // SEC:REVIEWED 2002-03-22 : Assumes entry
    
    if ( m_uTotalMemoryUsage > ( ARB_DEFAULT_SYSTEM_REQUEST_FACTOR * m_uSystemHigh ) )
    {
        bAcceptsNewTasks = FALSE ;
    }

    return bAcceptsNewTasks ;
}


//***************************************************************************
//
//***************************************************************************

typedef LONG (WINAPI *PFN_GetObjectCount)();

static PFN_GetObjectCount pObjCountFunc = 0;

DWORD CWmiArbitrator::MaybeDumpInfoGetWait()
{
    Registry r(WBEM_REG_WINMGMT);
    LPTSTR pPath = 0;
    if (r.GetStr(__TEXT("Task Log File"), &pPath))
        return 0xffffffff;
    CVectorDeleteMe<WCHAR> dm(pPath);
    FILE *f = _wfopen(pPath, L"wt");
    if (!f)
    {
        return 0xffffffff;
    }
    CfcloseMe fcm(f);
    {                
        // dump the tasks
        extern LONG g_nSinkCount, g_nStdSinkCount, g_nSynchronousSinkCount, g_nProviderSinkCount, g_lCoreThreads;

        CInCritSec cs(&m_csTask); // SEC:REVIEWED 2002-03-22 : Assumes entry

        fprintf(f, "---Global sinks active---\n");                            // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "   Total            = %d\n", g_nSinkCount);               // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "   StdSink          = %d\n", g_nStdSinkCount);            // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "   SynchSink        = %d\n", g_nSynchronousSinkCount);    // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "   ProviderSinks    = %d\n", g_nProviderSinkCount);       // SEC:REVIEWED 2002-03-22 : OK

        CProviderSink::Dump(f);

        fprintf(f, "---Core Objects---\n");   // SEC:REVIEWED 2002-03-22 : OK

        if (pObjCountFunc)
        {
            fprintf(f, "   Total objects/qualifier sets = %d\n", pObjCountFunc());  // SEC:REVIEWED 2002-03-22 : OK
        }

        CAsyncServiceQueue* pQueue = ConfigMgr::GetAsyncSvcQueue();
        if (pQueue)
        {
            fprintf(f, "   Total queue threads = %d\n", g_lCoreThreads + pQueue->GetEmergThreadCount ( ) );  // SEC:REVIEWED 2002-03-22 : OK
            fprintf(f, "   Total queue emergency threads = %d\n", pQueue->GetEmergThreadCount ( ) );         // SEC:REVIEWED 2002-03-22 : OK
            fprintf(f, "   Peak queue thread count = %d\n", pQueue->GetPeakThreadCount ( ) );                // SEC:REVIEWED 2002-03-22 : OK
            fprintf(f, "   Peak queue emergency thread count = %d\n", pQueue->GetPeakEmergThreadCount ( ) ); // SEC:REVIEWED 2002-03-22 : OK
            pQueue->Release();
        }

        fprintf(f, "---Begin Task List---\n");                       // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "Total active tasks = %u\n", m_aTasks.Size());    // SEC:REVIEWED 2002-03-22 : OK

        CCoreServices::DumpCounters(f);

        fprintf(f, "Total sleep time = %u\n", m_uTotalSleepTime );      // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "Total memory usage = %u\n", m_uTotalMemoryUsage );  // SEC:REVIEWED 2002-03-22 : OK

        CWmiFinalizer::Dump(f);

        for (int i = 0; i < m_aTasks.Size(); i++)
        {
            CWmiTask *pTask = (CWmiTask *) m_aTasks[i];
            pTask->Dump(f);
        }

        fprintf(f, "---End Task List---\n");    // SEC:REVIEWED 2002-03-22 : OK
    }
    {
        // Dump the namespaces

        CInCritSec cs(&m_csNamespace); // SEC:REVIEWED 2002-03-22 : OK, this is debug code
        fprintf(f, "---Begin Namespace List---\n");                                   // SEC:REVIEWED 2002-03-22 : OK
        fprintf(f, "Total Namespaces = %u\n", m_aNamespaces.Size());                  // SEC:REVIEWED 2002-03-22 : OK

        for (int i = 0; i < m_aNamespaces.Size(); i++)
        {
            CWbemNamespace *pNS = (CWbemNamespace *) m_aNamespaces[i];
            pNS->Dump(f);
        }

        fprintf(f, "---End Namespace List---\n");  // SEC:REVIEWED 2002-03-22 : OK
    }
    return 10000;
}

//***************************************************************************
//
//***************************************************************************
//
void WINAPI CWmiArbitrator::DiagnosticThread()
{
    DWORD dwDelay = MaybeDumpInfoGetWait();

    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);  // SEC:REVIEWED 2002-03-22 : OK
    if(hEvent == NULL)
        return;
    CCloseMe cm(hEvent);

    HKEY hKey;
    long lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\MICROSOFT\\WBEM\\CIMOM",
                    0, KEY_NOTIFY, &hKey);
    if(lRet != ERROR_SUCCESS)
        return;
    CRegCloseMe ck(hKey);

    lRet = RegNotifyChangeKeyValue(hKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET,
                    hEvent, TRUE);
    if(lRet != ERROR_SUCCESS)
        return;

    HMODULE hLib = LoadLibrary(L"fastprox.dll");                    // SEC:REVIEWED 2002-03-22 : Use full path to prevent problems
    if (hLib)
    {
        FARPROC p = GetProcAddress(hLib, "_GetObjectCount@0");
        if (p)
        {
            pObjCountFunc = (PFN_GetObjectCount) p;
        }
    }

    HANDLE hEvents[2];
    hEvents[0] = m_hTerminateEvent;
    hEvents[1] = hEvent;
    for (;;)
    {
        DWORD dwObj = WbemWaitForMultipleObjects(2, hEvents, dwDelay);
        switch (dwObj)
        {
            case 0:     // bail out for terminate event
                return;
            case 1:     // registry key changed
                dwDelay = MaybeDumpInfoGetWait();
                lRet = RegNotifyChangeKeyValue(hKey, FALSE, REG_NOTIFY_CHANGE_LAST_SET,
                                hEvent, TRUE);
                if(lRet != ERROR_SUCCESS)
                    return;
                break;
            case WAIT_TIMEOUT:
                dwDelay = MaybeDumpInfoGetWait();
                break;
            default:
                return;
        }
    }

    FreeLibrary(hLib);  // no real path to this, but it looks cool, huh?
}

//***************************************************************************
//
//  CWmiArbitrator::MapProviderToTask
//
//  As providers are invoked for tasks, they are added to the provider
//  list in the primary task. This allows us to quickly cancel all the providers
//  doing work for a particular task.
//
//***************************************************************************
//
HRESULT CWmiArbitrator::MapProviderToTask(
    ULONG uFlags,
    IWbemContext *pCtx,
    IWbemServices *pProv,
    CProviderSink *pProviderSink
    )
{
    HRESULT hRes;

    if (pCtx == 0 || pProviderSink == 0 || pProv == 0)
        return WBEM_E_INVALID_PARAMETER;

    CWbemRequest* pReq = CWbemQueue::GetCurrentRequest() ;
    if (pReq == NULL)
        return WBEM_E_FAILED;

    CWmiTask *pTask = (CWmiTask *) pReq->m_phTask;
    if (pTask == 0)
        return WBEM_S_NO_ERROR; // An internal request with no user task ID

    // If here, we have a task that will hold the provider.
    // ====================================================

    STaskProvider *pTP = new STaskProvider;
    if (pTP == 0)
        return WBEM_E_OUT_OF_MEMORY;

    pProv->AddRef();
    pTP->m_pProv = pProv;
    pProviderSink->LocalAddRef();
    pTP->m_pProvSink = pProviderSink;

    // Clean up the task provider if the add fails.
    hRes = pTask->AddTaskProv(pTP);

    if ( FAILED( hRes ) )
    {
        delete pTP;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
DWORD WINAPI CWmiArbitrator::_DiagnosticThread(CWmiArbitrator *pArb)
{
    pArb->DiagnosticThread();
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
static DWORD WINAPI TaskDiagnosticThread(CWmiArbitrator *pArb)
{
    static BOOL bThread = FALSE;

    // Check if the diagnostic thread is enabled
    /*if ( ConfigMgr::GetEnableArbitratorDiagnosticThread() && !bThread )
    {
        bThread = TRUE;
        DWORD dwId;

        HANDLE hThread = CreateThread(
            0,                     // Security
            0,
            LPTHREAD_START_ROUTINE(CWmiArbitrator::_DiagnosticThread),          // Thread proc address
            pArb,                   // Thread parm
            0,                     // Flags
            &dwId
            );

        if (hThread == NULL)
            return 0;
        CloseHandle(hThread);
        return dwId;
    }*/

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmifinalizer.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WmiFinalizer2

Abstract:
    Implementation of the finalizer.  The finalizer if the class which
    delivers the resultant objects back to the client.  It could do
    that sychronously or asynchronously.


History:

    paulall        27-Mar-2000        Created.
    marioh        20-Aug-2000        Batching capabilities added
    marioh        17-Oct-2000        Major updates completed


--*/

#include <flexarry.h>
#include <wbemcore.h>

#ifndef __FINALIZER__
#define __FINALIZER__

#define DEFAULT_BATCH_TRANSMIT_BYTES        0x40000         // 128K, Max batching size to deliver on one indicate call
#define MAX_SINGLE_OBJECT_SIZE                0x200000        // Max single object size
#define ABANDON_PROXY_THRESHOLD                60000            // Max proxy timeout [60secs]
#define MAX_BUFFER_SIZE_BEFORE_SLOWDOWN        0x400000        // Max size of queue before slowdown of inbound flow

#define    LOWER_AUTH_LEVEL_NOTSET                0xFFFFFFFF

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Finalizer constructor exceptions
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class CWmiFinalizerEnumerator;
class CWmiFinalizerInboundSink;
class CWmiFinalizerEnumeratorSink;
class CWmiFinalizerCallResult;
class CWmiFinalizer ;


class CWmiFinalizerObj
{
public:
    IWbemClassObject *m_pObj;
    enum ObjectType {
        unknown,
        object,
        status,
        shutdown,
        set
    } m_objectType;
    
    BSTR            m_bStr;

    HRESULT            m_hRes;
    HRESULT            m_hArb ;

    void*            m_pvObj;
    _IWmiFinalizer* m_pFin ;
    
    IID                m_iid;
    ULONG            m_uSize;
    ULONG            m_lFlags;
    

    CWmiFinalizerObj(ObjectType objType) : m_pObj(NULL), m_objectType(objType), m_lFlags(0), m_bStr(NULL), m_hRes(0), m_pvObj(0), m_uSize(0), m_pFin ( NULL ), m_hArb ( WBEM_S_ARB_NOTHROTTLING ) {}
    CWmiFinalizerObj(IWbemClassObject *pObj, _IWmiFinalizer* pFin ) ;
    CWmiFinalizerObj(ULONG lFlags, REFIID riid, void *pvObj) ;

    CWmiFinalizerObj(ULONG lFlags, HRESULT hRes, BSTR bStr, IWbemClassObject *pObj) ;
    CWmiFinalizerObj(CWmiFinalizerObj& obj);

    virtual ~CWmiFinalizerObj();
};


struct InsertableEvent 
{
    LIST_ENTRY m_Entry;
    CWmiFinalizerEnumerator * pEnum;
    DWORD ThreadId;
};

class CWmiFinalizer : public _IWmiFinalizer,
                  public _IWmiArbitratee,
                  public IWbemShutdown
{
private:
    LONG                m_lRefCount;                        // External/client refcount
    LONG                m_lInternalRefCount;                // Internal refcount
public:
    enum QueueStatus {
        NoError,
        RequestReleased,
        CallCancelled,
        QuotaViolation,
        QueueFailure
    };
private:
    
    QueueStatus         m_hStatus;                            // Status once thread is woken up from PullObjects
    BOOL                m_bSetStatusEnqueued;                // We've recieved and enqueued the setstatus (COMPLETE)
    BOOL                m_bSetStatusWithError;                // SetStatus called with error
    BOOL                m_bTaskInitialized ;                // Has SetTaskHandle been called?
    BOOL                m_bClonedFinalizer ;                // Is this a cloned finalizer?
    BOOL                m_bSetStatusDelivered ;                // Has the setstatus been delivered?
    
    ULONG                m_ulOperationType;                    // Sync/Semisync/Async
    ULONG                m_ulSemisyncWakeupCall;                // For semisync operations, once number of objects on the queue reaches this, wake up client

    IWbemClassObject**    m_apAsyncDeliveryBuffer;            // Used during async deliveries for batching objects together
    ULONG                m_ulAsyncDeliveryCount;                // Used during async deliveries for the number of objects to deliver in one batch
    ULONG                m_ulAsyncDeliverySize;                // Async deliver size
    LONG                m_lCurrentlyDelivering;                // Are we in the process of already delivering the batch
    LONG                m_lCurrentlyCancelling;                // Special case for cancellations

    enum {
        forwarding_type_none = 0,
        forwarding_type_fast = 1,                            //Use pass through mechanism
        forwarding_type_decoupled = 2                        //Pass off to another thread for delivery
    }                     m_uForwardingType;
    
    enum {
        FinalizerBatch_StatusMsg  = 0,
        FinalizerBatch_BufferOverFlow = 1,
        FinalizerBatch_NoError      = 2
    }                     m_enumBatchStatus;


    enum {
        PauseInboundDelivery = 0,
        ResumeInboundDelivery = 1,
    };

    enum {
        Operation_Type_Async = 0,
        Operation_Type_Semisync = 1,
        Operation_Type_Sync = 2
    };


    _IWmiCoreHandle        *m_phTask;                            // Task associated with this finalizer
    _IWmiArbitrator        *m_pArbitrator;                        // Access to arbitrator to help keep control of system

    IID                     m_iidDestSink;                        // Client destination sink with async deliveries [IID]
    IWbemObjectSink        *m_pDestSink;                        // Client destination sink with async deliveries

    CFlexArray             m_inboundSinks;                    // Array of inbound sinks [not sure we need safe array since we only support one inbound sink]
    CFlexArray             m_objects;                            // Object queue. All objects are inserted into this array [except async fasttrack]
    CFlexArray             m_enumerators ;                    // All enumerators associated with this finalizer (cloning)

    HRESULT                 m_hresFinalResult;                    // Final result of operation
    CWmiFinalizerCallResult *m_pCallResult;                    // CallResult
    bool                 m_bSetStatusCalled;                // Has anyone called setstatus yet?

    CCritSec     m_destCS;                                    // Protects the destination sink
    CCritSec     m_arbitratorCS;                            // Protects the arbitrator

    bool                 m_bRestartable;                    // Is the enumerator restartable
    bool                 m_bSetStatusConsumed;                // Have we finished the operation?

    LONG                 m_lMemoryConsumption ;                // Control for checking memory consumption
    ULONG                 m_ulStatus;                        // Status used to determine what woke a client from PullObjects
    ULONG                 m_uCurObjectPosition;                // Keeps a current object position in object queue for restartable purposes
    HANDLE                 m_hResultReceived;
    HANDLE                 m_hCancelEvent;                    // Threads that are waiting on objects will wake up in case of cancelled operation
    HANDLE                 m_hWaitForSetStatus ;
    ULONG                 m_ulQueueSize;                        // Total current object queue size

    LONG                 m_bCancelledCall;                    // Has the call been cancelled?
    BOOL                 m_bNaughtyClient;                    // Did we stop delivering due to client being naughty?
    
protected:
    
    static DWORD WINAPI ThreadBootstrap ( PVOID pvContext );

    static VOID WINAPI ProxyThreshold ( PVOID pvContext, BOOLEAN bTimerOrWait );

    HRESULT    BootstrapDeliveryThread ( );
    
    VOID ProxyThresholdImp ( );
    
    ULONG AsyncDeliveryProcessor();

    HRESULT TriggerShutdown();

    HRESULT ShutdownFinalizer();

    HRESULT DeliverPushObject(bool bDoPassthrough);

    HRESULT QueueOperation(CWmiFinalizerObj *pObj);

    HRESULT DequeueObject(CWmiFinalizerObj **ppObj, CWmiFinalizerEnumerator* pEnum );

    HRESULT    BuildTransmitBuffer ( );

    HRESULT DeliverSingleObjFromQueue ( );
    
    HRESULT DeliverBatch ( );

    HRESULT CancelCall();
    HRESULT CancelCall( int Line ){m_LineCancelCall = Line; return CancelCall(); };

    VOID    ZeroAsyncDeliveryBuffer ( );

public:
    CWmiFinalizer(CCoreServices *pSrvs);
    ~CWmiFinalizer();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

    void CallBackRelease () ;

    STDMETHOD(Configure)(
        /*[in]*/ ULONG uConfigID,
        /*[in]*/ ULONG uValue
        );
        // Allows decoupled & fast-track configuration with no thread switches

    STDMETHOD(SetTaskHandle)(
        /*[in]*/ _IWmiCoreHandle *phTask
        );
        // Task handle has user-specific stuff.  Finalizer just
        // passes this through to _IWmiArbitrator::CheckTask

    STDMETHOD(SetDestinationSink)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in], iid_is(riid)]*/ LPVOID pSink
        );
        // For async operations

    STDMETHOD(SetSelfDestructCallback)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ IWbemObjectSink *pSink
        );
        // The callback called during final Release(); Set() is called with the task handle, followed by SetStatus()
        //

    STDMETHOD(GetStatus)(
        /*[out]*/ ULONG* pFlags
        );

    STDMETHOD(NewInboundSink)(
        /*[in]*/  ULONG uFlags,
        /*[out]*/ IWbemObjectSink **pSink
        );

    STDMETHOD(Merge)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in]*/ LPVOID pObj
        );
        // Allows merging another Finalizer, _IWmiCache, etc.
        // For sorting, we will create a sorted _IWmiCache and merge it in later when
        // the sort is completed.

    // For setting, getting objects

    STDMETHOD(SetResultObject)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in]*/ LPVOID pObj
        );

    STDMETHOD(GetResultObject)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ LPVOID *pObj
        );
        // Support _IWmiObject, IWbemClassObject, etc.
        // IEnumWbemClassObject
        // _IWmiCache

    // For status-only operations

    STDMETHOD(SetOperationResult)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ HRESULT hRes
        );

    STDMETHOD(GetOperationResult)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ ULONG uTimeout,
        /*[out]*/ HRESULT *phRes
        );

    //Set status is called from the inbound sink to notify us of the status.
    //We will queue up the request and pass it on to the client if necessary
    HRESULT SetStatus(
        /*[in]*/ long lFlags,
        /*[in]*/ HRESULT hResult,
        /*[in]*/ BSTR strParam,
        /*[in]*/ IWbemClassObject* pObjParam
        );
    
    STDMETHOD(CancelTask) (
        /*[in]*/ ULONG uFlags
        );

    STDMETHOD(DumpDebugInfo) (
        /*[in]*/ ULONG uFlags,
        /*[in]*/ const BSTR fHandle
        );

    STDMETHOD(Shutdown)(
        /*[in]*/ LONG uReason,
        /*[in]*/ ULONG uMaxMilliseconds,
        /*[in]*/ IWbemContext *pCtx);


    //When the sink goes away, in the destructor, it will call back to unregister
    //itself.  That way we know when they are all done.  If they are all gone
    //we can send the status back to the client and we are all done!

    HRESULT GetFinalResult      ( ) { return m_hresFinalResult ; }     
    HRESULT CancelWaitHandle    ( );
    HRESULT    SetClientCancellationHandle ( HANDLE ) ;
    HRESULT NotifyClientOfCancelledCall ( ) ;
    BOOL    IsValidDestinationSink  ( ) ;
    HRESULT ReleaseDestinationSink ( ) ;

    HRESULT ReportMemoryUsage ( ULONG, LONG ) ;
    HRESULT CancelTaskInternal    ( );
    HRESULT Reset                ( );                                            // If there is an EnumClassObject calling Reset, it calls back into us...
    HRESULT SetSinkToIdentity    ( IWbemObjectSink* );                            // Waits until the timeout for a new object to arrive, or a shutdown state
    HRESULT WaitForCompletion    ( ULONG uTimeout );                                // Wait for the operition to complete.
    HRESULT    NextAsync            ( CWmiFinalizerEnumerator* pEnum );
    HRESULT Skip                ( long lTimeout, ULONG nCount, CWmiFinalizerEnumerator* pEnum );
    HRESULT PullObjects            ( long lTimeout, ULONG uCount, IWbemClassObject** apObjects, ULONG* puReturned, CWmiFinalizerEnumerator* pEnum, BOOL bAddToObjQueue=TRUE, BOOL bSetErrorObj=TRUE );
    HRESULT Set                    ( long lFlags, REFIID riid, void *pComObject );    
    HRESULT    Indicate            ( long lObjectCount, IWbemClassObject** apObjArray );
    HRESULT UnregisterInboundSink( CWmiFinalizerInboundSink *pSink );
    HRESULT GetNextObject        ( CWmiFinalizerObj **ppObj );
    HRESULT ZapWriteOnlyProps    ( IWbemClassObject *pObj );
    BOOL    HasWriteOnlyProps   ( IWbemClassObject* pObj );


    HRESULT DoSetStatusCancel   ( IWbemObjectSink * pSink, HRESULT lParam );
    HRESULT DoSetStatus            ( IWbemObjectSink * psink, long lFlags, HRESULT lParam, BSTR strParam,
                                  IWbemClassObject* pObjParam, BOOL bAllowMultipleCalls = FALSE );
    HRESULT DoIndicate            ( IWbemObjectSink * psink, int nBatchSize, IWbemClassObject **pBatch );
    HRESULT FinalizerLowerAuthLevel ( IWbemObjectSink * psink, DWORD* pdwLastAuthnLevel );
    
    IWbemObjectSink* ReturnProtectedDestinationSink ( );
    
    bool    GetSetStatusConsumed ( )                { return m_bSetStatusConsumed; }
    bool    IsRestartable ( void )                    { return m_bRestartable; }
    LONG    GetInternalStatus ( )                    { return m_hStatus; }
    void    SetInternalStatus ( QueueStatus lStatus )        { m_hStatus = lStatus; }
    ULONG   GetObjectQueueSize ( )                    { return m_objects.Size(); }
    LONG    IsCallCancelled ( )                        { return m_bCancelledCall; }
    VOID    UpdateStatus ( ULONG ulFlags )            { m_ulStatus |= ulFlags; }

    VOID    SetSemisyncWakeupCall ( ULONG ulNum )    { m_ulSemisyncWakeupCall = ulNum; }
    ULONG   GetSemisyncWakeupCall ( )                { return m_ulSemisyncWakeupCall; }

    HRESULT NotifyAllEnumeratorsOfCompletion ( ) ;
    HRESULT UnregisterEnumerator ( CWmiFinalizerEnumerator* ) ;

    // Other public:
    static void Dump(FILE* f);

    CCritSec     m_cs;                                        // Protects the object queue
    int          m_LineCancelCall;

};

//*****************************************************************************
//****                                                                     ****
//****                Private WmiFinalizer classes...                      ****
//****                                                                     ****
//*****************************************************************************
class CWmiFinalizerInboundSink : public IWbemObjectSink
{
private:
    LONG          m_lRefCount;
    LONG          m_lInternalRefCount;
    CWmiFinalizer * m_pFinalizer;
    bool          m_bSetStatusCalled;
    LIST_ENTRY    m_Entry;
       
public:
    CWmiFinalizerInboundSink(CWmiFinalizer *pFinalizer);
    ~CWmiFinalizerInboundSink();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

    void CallBackRelease () ;

    STDMETHOD(Indicate)(
        /*[in]*/ long lObjectCount,
        /*[in, size_is(lObjectCount)]*/
            IWbemClassObject** apObjArray
        );


    STDMETHOD(SetStatus)(
        /*[in]*/ long lFlags,
        /*[in]*/ HRESULT hResult,
        /*[in]*/ BSTR strParam,
        /*[in]*/ IWbemClassObject* pObjParam
        );

    STDMETHOD(Set)(
        /*[in]*/ long lFlags,
        /*[in]*/ REFIID riid,
        /*[in, iid_is(riid)]*/ void *pComObject
        );
};

class CWmiFinalizerEnumerator : public IEnumWbemClassObject, IWbemFetchSmartEnum
{
private:
    LONG    m_lRefCount;
    LONG    m_lInternalRefCount;
    ULONG    m_ulCount;
    HANDLE    m_hSignalCompletion;

    CWmiFinalizer*            m_pFinalizer;
    IServerSecurity*        m_pSec;
    IWbemObjectSink*        m_pDestSink;
    _IWbemEnumMarshaling*    m_pEnumMarshal;

    CCritSec    m_clientLock;

    CIdentitySecurity m_Security;
    LIST_ENTRY    m_Entry;    
    LIST_ENTRY    m_HeadNextAsync;    
    
protected:
    // ============================
    // SMART ENUM!!!!!!!!!!!!!
    // ============================
    class XSmartEnum : public IWbemWCOSmartEnum
    {
      private:
        CWmiFinalizerEnumerator*    m_pOuter;

      public:

        XSmartEnum( CWmiFinalizerEnumerator* pOuter ) : m_pOuter( pOuter ) {};
        ~XSmartEnum(){};

        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG, AddRef)(THIS);
        STDMETHOD_(ULONG, Release)(THIS);

        // IWbemWCOSmartEnum Methods
        STDMETHOD(Next)( REFGUID proxyGUID, LONG lTimeout,
            ULONG uCount, ULONG* puReturned, ULONG* pdwBuffSize,
            BYTE** pBuffer);
    } m_XSmartEnum;

    friend XSmartEnum;


public:
    CWmiFinalizerEnumerator(CWmiFinalizer *pFinalizer);
    ~CWmiFinalizerEnumerator();

    void Add_NextAsync(InsertableEvent * pInsert);
    void Remove_NextAsync(InsertableEvent * pInsert);

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

    static DWORD WINAPI ThreadBootstrapNextAsync ( PVOID pvContext );
    void             CallBackRelease();
    HRESULT             _NextAsync();
    HRESULT             SetCompletionSignalEvent(){ if ( m_hSignalCompletion ) SetEvent (m_hSignalCompletion); return WBEM_S_NO_ERROR; }
    IWbemObjectSink* GetDestSink(){ return m_pDestSink; }
    VOID             NULLDestSink(){ m_pDestSink = NULL; }
    HRESULT             ReleaseFinalizer(){ if ( m_pFinalizer ) m_pFinalizer->Release(); return WBEM_S_NO_ERROR; }

    // ============================
    // IEnumWbemClassObject methods
    // ============================
    STDMETHOD(Reset)();

    STDMETHOD(Next)(
        /*[in]*/  long lTimeout,
        /*[in]*/  ULONG uCount,
        /*[out, size_is(uCount), length_is(*puReturned)]*/ IWbemClassObject** apObjects,
        /*[out]*/ ULONG* puReturned
        );

    STDMETHOD(NextAsync)(
        /*[in]*/  ULONG uCount,
        /*[in]*/  IWbemObjectSink* pSink
        );

    STDMETHOD(Clone)(
        /*[out]*/ IEnumWbemClassObject** ppEnum
        );

    STDMETHOD(Skip)(
        /*[in]*/ long lTimeout,
        /*[in]*/ ULONG nCount
        );


    // ===========================
    // IWbemFetchSmartEnum methods
    // ===========================
    STDMETHOD (GetSmartEnum) (
        /*[out]*/ IWbemWCOSmartEnum** ppSmartEnum
    );    

    BOOL HasSmartEnum(){ return (NULL != m_pEnumMarshal); };

    ULONG    m_uCurObjectPosition ;
    HANDLE    m_hWaitOnResultSet ;
    ULONG    m_ulSemisyncWakeupCall;
    BOOL    m_bSetStatusConsumed ;
};


class CWmiFinalizerCallResult : IWbemCallResult
{
private:
    LONG               m_lInternalRefCount;
    LONG               m_lRefCount;

    CWmiFinalizer     *m_pFinalizer;
    long               m_lFlags;
    HRESULT               m_hResult;
    BSTR               m_strParam;
    IWbemClassObject  *m_pObj;
    IWbemClassObject  *m_pErrorObj;
    IWbemServices      *m_pServices;
    bool               m_bGotObject;
    bool               m_bGotServices;
    CIdentitySecurity m_Security;
    LIST_ENTRY    m_Entry;    

public:
    CWmiFinalizerCallResult(CWmiFinalizer *pFinalizer);
    ~CWmiFinalizerCallResult();

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    STDMETHOD_(ULONG, InternalAddRef)(THIS);
    STDMETHOD_(ULONG, InternalRelease)(THIS);

    STDMETHOD(GetResultObject)(
        /*[in]*/  long lTimeout,
        /*[out]*/ IWbemClassObject** ppResultObject
        );

    STDMETHOD(GetResultString)(
        /*[in]*/  long lTimeout,
        /*[out]*/ BSTR* pstrResultString
        );

    STDMETHOD(GetResultServices)(
        /*[in]*/  long lTimeout,
        /*[out]*/ IWbemServices** ppServices
        );

    STDMETHOD(GetCallStatus)(
        /*[in]*/  long lTimeout,
        /*[out]*/ long* plStatus
        );

    STDMETHOD(GetResult)(
        /*[in]*/ long lTimeout,
        /*[in]*/ long lFlags,
        /*[in]*/ REFIID riid,
        /*[out, iid_is(riid)]*/ void **ppvResult
        );

    HRESULT SetStatus(
        /*[in]*/ long lFlags,
        /*[in]*/ HRESULT hResult,
        /*[in]*/ BSTR strParam,
        /*[in]*/ IWbemClassObject* pObjParam
        );


    void SetErrorInfo();


};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmimerger.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WMIMERGER.CPP

Abstract:

    Implements the _IWmiMerger interface

History:

    sanjes    16-Nov-00  Created.

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"
#include <scopeguard.h>
static    long    g_lNumMergers = 0L;

//***************************************************************************
//
//***************************************************************************
//
CWmiMerger::CWmiMerger( CWbemNamespace* pNameSpace )
:    m_lRefCount( 0 ),
    m_pTargetSink( NULL ),
    m_pTask( NULL ),
    m_pNamespace( pNameSpace ),
    m_wsTargetClassName(),
    m_dwProviderDeliveryPing( 0L ),
    m_pArbitrator( NULL ),
    m_lNumArbThrottled( 0L ),
    m_lDebugMemUsed( 0L ),
    m_hOperationRes( WBEM_S_NO_ERROR ),
    m_cs(),
    m_dwMaxLevel( 0 ),
    m_pRequestMgr( NULL ),
    m_dwMinReqLevel( 0xFFFFFFFF ),
    m_bMergerThrottlingEnabled( true )
{
    if ( NULL != m_pNamespace )
    {
        m_pNamespace->AddRef();
    }

    InterlockedIncrement( &g_lNumMergers );
}

//***************************************************************************
//
//  CWmiMerger::~CWmiMerger
//
//  Notifies the ESS of namespace closure and frees up all the class providers.
//
//***************************************************************************

CWmiMerger::~CWmiMerger()
{
    _DBG_ASSERT( 0L == m_lNumArbThrottled );
    _DBG_ASSERT( 0L == m_lDebugMemUsed );
    
    if ( NULL != m_pNamespace )
    {
        m_pNamespace->Release();
    }

    if ( NULL != m_pArbitrator )
    {
        m_pArbitrator->Release();
    }

    if ( NULL != m_pTask )
    {
        m_pTask->Release();
    }

    if ( NULL != m_pRequestMgr )
    {
        delete m_pRequestMgr;
        m_pRequestMgr = NULL;
    }

    InterlockedDecrement( &g_lNumMergers );

}

//***************************************************************************
//
//  CWmiMerger::QueryInterface
//
//  Exports _IWmiMerger interface.
//
//***************************************************************************

STDMETHODIMP CWmiMerger::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    if ( riid == IID__IWmiArbitratee )
    {
        *ppvObj = (_IWmiArbitratee*) this;
    }
    else if ( riid == IID__IWmiArbitratedQuery )
    {
        *ppvObj = (_IWmiArbitratedQuery*) this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG CWmiMerger::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CWmiMerger::Release()
{
    long lNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 != lNewCount)
        return lNewCount;
    delete this;
    return 0;
}

// Sets initial parameters for merger.  Establishes the target class and sink for the
// query associated with the merger
STDMETHODIMP CWmiMerger::Initialize( _IWmiArbitrator* pArbitrator, _IWmiCoreHandle* pTask, LPCWSTR pwszTargetClass,
                                    IWbemObjectSink* pTargetSink, CMergerSink** ppFinalSink )
{
    if ( NULL == pwszTargetClass || NULL == pTargetSink )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Cannot initialize twice
    if ( NULL != m_pTargetSink )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    HRESULT    hr = WBEM_S_NO_ERROR;

    try
    {
        m_wsTargetClassName = pwszTargetClass; // throws

        // Create the final target sink
        hr = CreateMergingSink( eMergerFinalSink, pTargetSink, 
                                NULL, (CMergerSink**) &m_pTargetSink );

        if ( SUCCEEDED( hr ) )
        {
            *ppFinalSink = m_pTargetSink;
            m_pTargetSink->AddRef();

            m_pArbitrator = pArbitrator;
            m_pArbitrator->AddRef();

            // AddRef the Task here
            m_pTask = pTask;

            // Only register for arbitration if we have a task handle
            if ( NULL != pTask )
            {
                m_pTask->AddRef();
                hr = m_pArbitrator->RegisterArbitratee( 0L, m_pTask, this );
            }
            
        }
    }
    catch ( CX_Exception & )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    return hr;
}

// Called to request a delivery sink for a class in the query chain.  The returned
// sink is determined by the specified flags as well as settings on the parent class
STDMETHODIMP CWmiMerger::RegisterSinkForClass( LPCWSTR pwszClass, _IWmiObject* pClass, 
                                               IWbemContext* pContext,
                                               BOOL fHasChildren, BOOL fHasInstances, 
                                               BOOL fDerivedFromTarget,
                                               bool bStatic, CMergerSink* pDestSink, 
                                               CMergerSink** ppOwnSink, CMergerSink** ppChildSink )
{
    try
    {
		LPCWSTR    pwszParentClass = NULL;

		DWORD    dwSize = NULL;
		BOOL    fIsNull = NULL;

		// Get the derivation information.  The number of antecedents determines our
		// level in the hierarchy (we're 0 based)
		HRESULT    hr;
		DWORD    dwLevel = 0L;
		_variant_t vSuperClass;

		hr = GetLevelAndSuperClass( pClass, &dwLevel, vSuperClass );
		if (FAILED(hr)) return hr;

		BSTR wsSuperClass = V_BSTR(&vSuperClass); // it can be NULL if no SuperClass

		CCheckedInCritSec    ics( &m_cs );  
		
		// We're dead - take no positive adjustments
		if (FAILED (m_hOperationRes))  return m_hOperationRes;

		wmilib::auto_ptr<CWmiMergerRecord> pRecord;
		pRecord.reset(new CWmiMergerRecord( this, fHasInstances, fHasChildren,
		                                    pwszClass, pDestSink, dwLevel, bStatic )); // throw

		if ( NULL == pRecord.get() ) return WBEM_E_OUT_OF_MEMORY;

		// Now attach aninternal merger if we have both instances and children
		if ( fHasInstances && fHasChildren )
		{
		    // We shouldn't have a NULL task here if this is not a static class.
		    // Note that the only case this appears to happen is when ESS calls
		    // into us on internal APIs and uses requests on its own queues and
		    // not the main Core Queue.

		    _DBG_ASSERT( NULL != m_pTask || ( NULL == m_pTask && bStatic ) );
		    // throws
		    hr = pRecord->AttachInternalMerger( (CWbemClass*) pClass, m_pNamespace, pContext, fDerivedFromTarget, bStatic );
		}

		// Check that we're still okay
		if (FAILED(hr)) return hr;


		// Find the record for the superclass if there is one (unless the array is
		// empty of course).
		if ( wsSuperClass && wsSuperClass[0] && m_MergerRecord.GetSize() > 0 )
		{
		    // There MUST be a record, or something is quite not okay.
		    CWmiMergerRecord*    pSuperClassRecord = m_MergerRecord.Find( wsSuperClass );

		    _DBG_ASSERT( NULL != pSuperClassRecord );

		    // Now add the new record to the child array for the superclass record
		    // This will allow us to quickly determine the classes we need to obtain
		    // submit requests for if the parent class is throttled.

		    if ( NULL == pSuperClassRecord ) return WBEM_E_FAILED;

		    hr = pSuperClassRecord->AddChild(pRecord.get());
		}

		if (FAILED(hr)) return hr;

		// Make sure the add is successful
		if ( m_MergerRecord.Insert( pRecord.get() ) < 0 ) return WBEM_E_OUT_OF_MEMORY;


		#ifdef __DEBUG_MERGER_THROTTLING
		// Verify the sort order for now
		m_MergerRecord.Verify();
		#endif


		*ppOwnSink = pRecord->GetOwnSink();
		*ppChildSink = pRecord->GetChildSink();
		pRecord.release(); // array took ownership

		// Store the maximum level in the hierarchy
		if ( dwLevel > m_dwMaxLevel )
		{
		    m_dwMaxLevel = dwLevel;
		}

		if ( !bStatic && dwLevel < m_dwMinReqLevel )
		{
		    m_dwMinReqLevel = dwLevel;
		}

		return hr;
   	}
    catch(CX_Exception & )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }   
}

// Called to request a delivery sink for child classes in the query chain.  This is especially
// important when instances are merged under the covers.
STDMETHODIMP CWmiMerger::GetChildSink( LPCWSTR pwszClass, CBasicObjectSink** ppSink )
{
    HRESULT    hr = WBEM_S_NO_ERROR;
    CInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    // Search for a parent class's child sink
    for ( int x = 0; SUCCEEDED( hr ) && x < m_MergerRecord.GetSize(); x++ )
    {
        if ( m_MergerRecord[x]->IsClass( pwszClass ) )
        {
            *ppSink = m_MergerRecord[x]->GetChildSink();
            break;
        }
    }

    // We should never get a failure
    _DBG_ASSERT( x < m_MergerRecord.GetSize() );

    if ( x >= m_MergerRecord.GetSize() )
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}

// Can be used to hold off indicates - if we're merging instances from multiple providers, we need
// to ensure that we don't get lopsided in the number of objects we've got queued up for merging.
STDMETHODIMP CWmiMerger::Throttle( void )
{
    // We're dead - take no positive adjustments
    if ( FAILED ( m_hOperationRes ) )
    {
        return m_hOperationRes;
    }

    // Check for NULL m_pTask
    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( NULL != m_pTask )
    {
        hr = m_pArbitrator->Throttle( 0L, m_pTask );
    }

    return hr;
}

// Merger will hold information regarding the total number of objects it has queued up waiting
// for merging and the amount of memory consumed by those objects.
STDMETHODIMP CWmiMerger::GetQueuedObjectInfo( DWORD* pdwNumQueuedObjects, DWORD* pdwQueuedObjectMemSize )
{
    return WBEM_E_NOT_AVAILABLE;
}

// If this is called, all underlying sinks will be cancelled in order to prevent accepting additional
// objects.  This will also automatically free up resources consumed by queued objects.
STDMETHODIMP CWmiMerger::Cancel( void )
{
    return Cancel( WBEM_E_CALL_CANCELLED );
}

// Helper function to control sink creation. The merger is responsible for deletion of
// all internally created sinks.  So this function ensures that the sinks are added into
// the array that will destroy them.
HRESULT CWmiMerger::CreateMergingSink( MergerSinkType eType, IWbemObjectSink* pDestSink, CInternalMerger* pMerger, CMergerSink** ppSink )
{
    

    if ( eType == eMergerFinalSink )
    {
        *ppSink = new CMergerTargetSink( this, pDestSink );
        if ( NULL == *ppSink ) return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        HRESULT  hr;
        hr = CInternalMerger::CreateMergingSink( eType, pMerger, this, ppSink );
        if (FAILED(hr)) return hr;
    }


    // If we have a sink, we should now add it to the
    // Sink array, the MergerSinks array will do the operator delete call,
    // but the objects will have a special callback on the last release
    
    if ( m_MergerSinks.Add( *ppSink ) < 0 )
    {
        delete *ppSink;
        *ppSink = NULL;
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    return WBEM_S_NO_ERROR;
}

// Iterates the array of MergerRecords and cancels each of them.
HRESULT CWmiMerger::Cancel( HRESULT hRes )
{
#ifdef __DEBUG_MERGER_THROTTLING
     DbgPrintfA(0,"CANCEL CALLED:  Merger %p Cancelled with hRes: 0x%x on Thread 0x%x\n",this, hRes, GetCurrentThreadId() ); 
#endif

    // We shouldn't be called with a success code
    _DBG_ASSERT( FAILED( hRes ) );

    HRESULT    hr = WBEM_S_NO_ERROR;

    // If we're here and this is non-NULL, tell the Arbitrator to tank us.
    if ( NULL != m_pTask )
    {
        m_pArbitrator->CancelTask( 0L, m_pTask );
    }

    CCheckedInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( WBEM_S_NO_ERROR == m_hOperationRes ) // if it is the first time 
    {
        m_hOperationRes = hRes;
    }

    // Search for a parent class's child sink
    for ( int x = 0; SUCCEEDED( hr ) && x < m_MergerRecord.GetSize(); x++ )
    {
        m_MergerRecord[x]->Cancel( hRes );
    }

    // Copy into a temporary variable, clear the member, exit the critsec
    // THEN call delete.  Requests can have multiple releases, which could call
    // back in here and cause all sorts of problems if we're inside a critsec.
    CWmiMergerRequestMgr*    pReqMgr = m_pRequestMgr;
    m_pRequestMgr = NULL;

    ics.Leave();

    // Tank any and all outstanding requests
    if ( NULL != pReqMgr )
    {
        delete pReqMgr;
    }

    return hr;
}

// Final Shutdown.  Called when the target sink is released.  At this point, we should
// unregister ourselves from the world
HRESULT CWmiMerger::Shutdown( void )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    CCheckedInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    _IWmiCoreHandle*    pTask = m_pTask;

    // Done with this, NULL it out - we release and unregister outside the critical section
    if ( NULL != m_pTask )
    {
        m_pTask = NULL;
    }

    ics.Leave();

    if ( NULL != pTask )
    {
        hr = m_pArbitrator->UnRegisterArbitratee( 0L, pTask, this );
        pTask->Release();
    }

    
    return hr;
}

// Pas-thru to arbitrator
HRESULT CWmiMerger::ReportMemoryUsage( long lAdjustment )
{
    // Task can be NULL
    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( NULL != m_pTask )
    {
        hr = m_pArbitrator->ReportMemoryUsage( 0L, lAdjustment, m_pTask );
    }

    // SUCCESS, WBEM_E_ARB_CANCEL or WBEM_E_ARB_THROTTLE means that we need to
    // account for the memory
    if ( ( SUCCEEDED( hr ) || hr == WBEM_E_ARB_CANCEL || hr == WBEM_E_ARB_THROTTLE ) )
    {
        InterlockedExchangeAdd( &m_lDebugMemUsed, lAdjustment );
    }

    return hr;
}

/* _IWmiArbitratee methods. */

STDMETHODIMP CWmiMerger::SetOperationResult( ULONG uFlags, HRESULT hRes )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( FAILED( hRes ) )
    {
        hr = Cancel( hRes );    
    }

    return hr;
}

// Why are we here?
STDMETHODIMP CWmiMerger::SetTaskHandle( _IWmiCoreHandle* pTask )
{
    _DBG_ASSERT( 0 );
    HRESULT    hr = WBEM_S_NO_ERROR;

    return hr;
}

// Noop for now
STDMETHODIMP CWmiMerger::DumpDebugInfo( ULONG uFlags, const BSTR strFile )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    return hr;
}

// Returns SUCCESS for now
STDMETHODIMP CWmiMerger::IsMerger( void )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CWmiMerger::GetLevelAndSuperClass( _IWmiObject* pObj, DWORD* pdwLevel,
	                                       _variant_t & vSuperClass )
{
    // Get the derivation information.  The number of antecedents determines our
    // level in the hierarchy (we're 0 based)
    DWORD    dwTemp = 0L;

    HRESULT    hr = pObj->GetDerivation( 0L, 0L, pdwLevel, &dwTemp, NULL );

    if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL != hr )
    {
        return hr;
    }

    hr = pObj->Get( L"__SUPERCLASS", 0L, &vSuperClass, NULL, NULL );

    if ( SUCCEEDED( hr ))
    {
        if ( VT_BSTR == V_VT(&vSuperClass)) return S_OK;
        if ( VT_NULL == V_VT(&vSuperClass)) { V_BSTR(&vSuperClass) = NULL; return S_OK; };
        throw CX_Exception();
    }
    return hr;
}

HRESULT CWmiMerger::RegisterArbitratedInstRequest( CWbemObject* pClassDef, long lFlags, 
	                                               IWbemContext* pCtx,
                                                   CBasicObjectSink* pSink, 
                                                   BOOL bComplexQuery, 
                                                   CWbemNamespace* pNs )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    // Allocate a new request then place it in the arbitrator.
    try
    {
        wmilib::auto_ptr<CMergerDynReq_DynAux_GetInstances> pReq;
        pReq.reset(new CMergerDynReq_DynAux_GetInstances(pNs, pClassDef, 
        	                                             lFlags, pCtx, pSink));

        if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;

        // Make sure a context exists under the cover
        if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;


        CCheckedInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

        if (FAILED(m_hOperationRes)) return m_hOperationRes;

        // Allocate a request manager if we need one
        if ( NULL == m_pRequestMgr )
        {
            m_pRequestMgr = new CWmiMergerRequestMgr(this);
            if (NULL == m_pRequestMgr) return WBEM_E_OUT_OF_MEMORY;
        }

        // We need the record to find out what level we need to add
        // the request to
        CWmiMergerRecord* pRecord = m_MergerRecord.Find( pReq->GetName() );
        _DBG_ASSERT( NULL != pRecord );

        if ( NULL == pRecord ) return WBEM_E_FAILED;

        // Set the task for the request - we'll just use the existing one
        m_pTask->AddRef();
        pReq->m_phTask = m_pTask;

        hr = m_pRequestMgr->AddRequest( pReq.get(), pRecord->GetLevel() );
        // Cleanup the request if anything went wrong
        if ( FAILED( hr ) ) return hr;
        pReq.release();
        
    }
    catch(CX_Exception &)
    {
        ExceptionCounter c;    
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT 
CWmiMerger::RegisterArbitratedQueryRequest( CWbemObject* pClassDef, long lFlags, 
                                            LPCWSTR Query,LPCWSTR QueryFormat, 
                                            IWbemContext* pCtx, 
                                            CBasicObjectSink* pSink, 
                                            CWbemNamespace* pNs )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    // Allocate a new request then place it in the arbitrator.
    try
    {
        wmilib::auto_ptr<CMergerDynReq_DynAux_ExecQueryAsync> pReq;
        pReq.reset(new CMergerDynReq_DynAux_ExecQueryAsync(pNs, pClassDef, lFlags, 
        	                                               Query, QueryFormat,
                                                           pCtx, pSink ));

        if (NULL == pReq.get()) return WBEM_E_OUT_OF_MEMORY;

        // Make sure a context was properly allocated
        if (NULL == pReq->GetContext()) return WBEM_E_OUT_OF_MEMORY;

         // Make sure the request is functional
        if (FAILED(hr = pReq->Initialize())) return hr;


        CInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

        if (FAILED(m_hOperationRes)) return m_hOperationRes;

        // Allocate a request manager if we need one
        if ( NULL == m_pRequestMgr )
        {
            m_pRequestMgr = new CWmiMergerRequestMgr( this );
            if ( NULL == m_pRequestMgr ) return WBEM_E_OUT_OF_MEMORY;
        }

        // We need the record to find out what level we need to add
        // the request to
        CWmiMergerRecord* pRecord = m_MergerRecord.Find( pReq->GetName() );
        _DBG_ASSERT( NULL != pRecord );
        // Couldn't find the record
        if ( NULL == pRecord ) return WBEM_E_FAILED;

        // Set the task for the request - we'll just use the existing one
        m_pTask->AddRef();
        pReq->m_phTask = m_pTask;

        hr = m_pRequestMgr->AddRequest( pReq.get(), pRecord->GetLevel() );
        if (FAILED(hr)) return hr;
        pReq.release();
    }
    catch(CX_Exception &)
    {
        ExceptionCounter c;    
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CWmiMerger::RegisterArbitratedStaticRequest( CWbemObject* pClassDef, long lFlags,
                        IWbemContext* pCtx, CBasicObjectSink* pSink, CWbemNamespace* pNs,
                        QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    // Allocate a new request then place it in the arbitrator.
    try
    {
        wmilib::auto_ptr<CMergerDynReq_Static_GetInstances>    pReq;
        pReq.reset(new CMergerDynReq_Static_GetInstances(
                                                    pNs, pClassDef, lFlags, pCtx, pSink,
                                                    pParsedQuery ));
        if ( NULL == pReq.get() ) return WBEM_E_OUT_OF_MEMORY;

        // Make sure a context was properly allocated
        if ( NULL == pReq->GetContext() ) return WBEM_E_OUT_OF_MEMORY;

        CInCritSec    ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

        if ( FAILED( m_hOperationRes ) ) return m_hOperationRes;

        // Allocate a request manager if we need one
        if ( NULL == m_pRequestMgr )
        {
            m_pRequestMgr = new CWmiMergerRequestMgr( this );
            if ( NULL == m_pRequestMgr ) return WBEM_E_OUT_OF_MEMORY;
        }

        // We need the record to find out what level we need to add
        // the request to
        CWmiMergerRecord* pRecord = m_MergerRecord.Find( pReq->GetName() );
        _DBG_ASSERT( NULL != pRecord );

        // Couldn't find the record
        if ( NULL == pRecord ) return WBEM_E_FAILED; 

        // Set the task for the request - we'll just use the existing one
        m_pTask->AddRef();
        pReq->m_phTask = m_pTask;

        hr = m_pRequestMgr->AddRequest( pReq.get(), pRecord->GetLevel() );
        if (FAILED(hr)) return hr;
        pReq.release();

    }
    catch(CX_Exception &)
    {
        ExceptionCounter c;    
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

//
// Executes the parent request.  In this case, we simply ask the request manager for the
// next top level request and execute that request.  We do this in a loop until something
// goes wrong.
//

	
HRESULT CWmiMerger::Exec_MergerParentRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink )
{
    HRESULT    hr = WBEM_S_NO_ERROR;
    IWbemClassObject * pErr = NULL;
    CSetStatusOnMe setOnMe(pSink,hr,pErr);    

    CCheckedInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    // While we have requests to execute, we should get each next logical one
    while ( SUCCEEDED(hr ) && NULL != m_pRequestMgr && m_pRequestMgr->GetNumRequests() > 0 )
    {
        if ( FAILED( m_hOperationRes ) ) { hr = m_hOperationRes; break; }

        // Obtain the next topmost parent record if we have to
        if ( NULL == pParentRecord )
        {
            WString    wsClassName; // throw
            hr = m_pRequestMgr->GetTopmostParentReqName( wsClassName );

            if ( SUCCEEDED( hr ) )
            {
                pParentRecord = m_MergerRecord.Find( wsClassName );

                // If there's a request, there better be a record
                _DBG_ASSERT( NULL != pParentRecord );

                if ( NULL == pParentRecord )
                {
                    hr = WBEM_E_FAILED;
                }

            }    // IF Got Topmost Parent Request

        }    // IF NULL == pParentRecord

        if ( FAILED( hr ) ) break;

        // This will remove the request from its array and return it
        // to us - we need to delete it
        wmilib::auto_ptr<CMergerReq> pReq;
        hr = m_pRequestMgr->RemoveRequest( pParentRecord->GetLevel(),
                                        pParentRecord->GetName(), pReq );
        if (FAILED(hr)) break;
        
        hr = pParentRecord->SetExecutionContext( pReq->GetContext() );      
        if (FAILED(hr)) break;

        
        // Clearly, we should do this outside the critsec
        ics.Leave();

#ifdef __DEBUG_MERGER_THROTTLING
        DbgPrintfA(0,"BEGIN: Merger 0x%x querying instances of parent class: %S, Level %d on Thread 0x%x\n", (DWORD_PTR) this, pParentRecord->GetName(), pParentRecord->GetLevel(), GetCurrentThreadId() );
#endif

        // This will delete the request when it is done with it
        hr = CCoreQueue::ExecSubRequest( pReq.get() );

        if ( SUCCEEDED(hr) ) pReq.release(); // queue took ownership

#ifdef __DEBUG_MERGER_THROTTLING
        DbgPrintfA(0,"END: Merger 0x%x querying instances of parent class: %S, Level %d on Thread 0x%x\n", (DWORD_PTR) this, pParentRecord->GetName(), pParentRecord->GetLevel(), GetCurrentThreadId() );// SEC:REVIEWED 2002-03-22 : OK
#endif

        ics.Enter();

        // We're done with this record, so we need to get the next top level
        // record.
        pParentRecord = NULL;
    }
    // SetStatus called by the guard
    return hr;
}

void CWmiMerger::CleanChildRequests(CWmiMergerRecord* pParentRecord, int cleanFrom)
{
	CCheckedInCritSec ics(&m_cs);
	
	if (NULL == m_pRequestMgr) return;
	// we want to see if there are un-executed requests laying around

	int localClean = cleanFrom;
	while(true)
	{
		CWmiMergerRecord* pChildRecord = pParentRecord->GetChildRecord( localClean++ );
		if ( NULL == pChildRecord ){ break; }
	
		// This will remove the request from its array and return it
		// to us - we need to delete it
		wmilib::auto_ptr<CMergerReq> pReq;
		m_pRequestMgr->RemoveRequest( pChildRecord->GetLevel(),
										pChildRecord->GetName(), pReq );
		if (pReq.get() != 0) 
		{
			ERRORTRACE((LOG_WBEMCORE,"deleting un-executed requests for class %S\n",pReq->GetName()));
		}
	}
}

//
// Executes the child request.  In this case, we enumerate the child classes of the parent
// record, and execute the corresponding requests.  We do so in a loop until we either
// finish or something goes wrong.
//

HRESULT CWmiMerger::Exec_MergerChildRequest( CWmiMergerRecord* pParentRecord, 
                                             CBasicObjectSink* pSink )
{
    HRESULT    hr = WBEM_S_NO_ERROR;
    IWbemClassObject * pErr = NULL;
    CSetStatusOnMe setOnMe(pSink,hr,pErr);
	int cleanFrom = 0; 
	ScopeGuard CleanChildReq = MakeObjGuard(*this, CWmiMerger::CleanChildRequests, pParentRecord, ByRef(cleanFrom));
    bool    bLast = false;
	

    CCheckedInCritSec    ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    // While we have child requests to execute, we should get each one
    for (int x = 0; SUCCEEDED( hr ) && NULL != m_pRequestMgr && !bLast; x++ )
    {
        // m_pRequestMgr will be NULL if we were cancelled, in which
        // case m_hOperationRes will be a failure
        if (FAILED(m_hOperationRes)){ hr = m_hOperationRes; break; };
        
        CWmiMergerRecord* pChildRecord = pParentRecord->GetChildRecord( x );
        if ( NULL == pChildRecord ){ bLast = true; break; }

        // This will remove the request from its array and return it
        // to us - we need to delete it
        wmilib::auto_ptr<CMergerReq> pReq;
		
        hr = m_pRequestMgr->RemoveRequest( pChildRecord->GetLevel(),
                                        pChildRecord->GetName(), pReq );

		if ( WBEM_E_NOT_FOUND == hr )
        {
            // If we don't find the request we're looking for, another thread
            // already processed it.  We should, however, still look for child
            // requests to process before we go away.
            hr = WBEM_S_NO_ERROR;
            continue;
        }
		cleanFrom = x+1;

        if ( FAILED( hr ) ) break;

        hr = pChildRecord->SetExecutionContext(pReq->GetContext());
        if (FAILED(hr)) break;

        // Clearly, we should do this outside the critsec
        ics.Leave();

#ifdef __DEBUG_MERGER_THROTTLING
        DbgPrintfA(0,"BEGIN: Merger 0x%x querying instances of child class: %S, Level %d for parent class: %S on Thread 0x%x\n", (DWORD_PTR) this, pChildRecord->GetName(), pChildRecord->GetLevel(), pParentRecord->GetName(), GetCurrentThreadId() );
#endif

        // This will delete the request when it is done with it
        hr = CCoreQueue::ExecSubRequest( pReq.get() );
        if ( SUCCEEDED(hr) ) pReq.release(); // queue took ownership

#ifdef __DEBUG_MERGER_THROTTLING
        DbgPrintfA(0,"END: Merger 0x%x querying instances of child class: %S, Level %d for parent class: %S on Thread 0x%x\n",  (DWORD_PTR) this, pChildRecord->GetName(), pChildRecord->GetLevel(), pParentRecord->GetName(), GetCurrentThreadId() );
#endif

        ics.Enter();
    }    // FOR enum child requests

    // SetStatus invoked by the guard	
    return hr;
}

// Schedules the parent class request
HRESULT CWmiMerger::ScheduleMergerParentRequest( IWbemContext* pCtx )
{
    // Check if query arbitration is enabled
    if ( !ConfigMgr::GetEnableQueryArbitration() )
    {
        return WBEM_S_NO_ERROR;
    }

    CCheckedInCritSec    ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    HRESULT hr = WBEM_S_NO_ERROR;

    do
    {

        if (FAILED( m_hOperationRes )){ hr = m_hOperationRes; break; }
        
        if ( NULL == m_pRequestMgr )
        {
            break; // The request manager will be non-NULL 
                   // only if we had to add a request.
        }
            

#ifdef __DEBUG_MERGER_THROTTLING
            m_pRequestMgr->DumpRequestHierarchy();
#endif

        // Make sure we've got at least one request
        if ( 0 == m_pRequestMgr->GetNumRequests() ) break;
                
        // If there isn't a task, we've got a BIG problem.
        _DBG_ASSERT( NULL != m_pTask );
        if ( NULL == m_pTask ) 
        {
            hr = WBEM_E_FAILED; break;
        }
            
        // If we have a single static request in the merger, we'll
        // execute it now.  Otherwise, we'll do normal processing.
        // Note that we *could* theoretically do this for single
        // dynamic requests as well
        if ( IsSingleStaticRequest() )
        {
            // We MUST leave the critical section here, since the parent request
            // could get cancelled or we may end up sleeping and we don't want
            // to own the critical section in that time.
            ics.Leave();
            hr = Exec_MergerParentRequest( NULL, m_pTargetSink );
        }
        else
        {
            // If we've never retrieved the number of processors, do so
            // now.
            static g_dwNumProcessors = 8L;

			/*
            if ( 0L == g_dwNumProcessors )
            {
                SYSTEM_INFO    sysInfo;
                ZeroMemory( &sysInfo, sizeof( sysInfo ) );   // SEC:REVIEWED 2002-03-22 : OK
                GetSystemInfo( &sysInfo );

                _DBG_ASSERT( sysInfo.dwNumberOfProcessors > 0L );

                // Ensure we're always at least 1
                g_dwNumProcessors = ( 0L == sysInfo.dwNumberOfProcessors ?
                                        1L : sysInfo.dwNumberOfProcessors );
            }
			*/

            // We will generate a number of parent requests based on the minimum
            // of the number of requests and the number of actual processors.

            DWORD dwNumToSchedule = min( m_pRequestMgr->GetNumRequests(), g_dwNumProcessors );

            for ( DWORD    dwCtr = 0L; SUCCEEDED( hr ) && dwCtr < dwNumToSchedule; dwCtr++ )
            {
                // Parent request will search for the next available request
                wmilib::auto_ptr<CMergerParentReq>    pReq;
                pReq.reset(new CMergerParentReq(this,NULL,m_pNamespace,m_pTargetSink,pCtx));

                if ( NULL == pReq.get() ) {
                    hr = WBEM_E_OUT_OF_MEMORY; break;
                }

                if ( NULL == pReq->GetContext() ){
                    hr = WBEM_E_OUT_OF_MEMORY; break;
                }
                
                // Set the task for the request - we'll just use the existing one
                m_pTask->AddRef();
                pReq->m_phTask = m_pTask;
                
                // This may sleep, so exit the critsec before calling into this
                ics.Leave();

                hr = ConfigMgr::EnqueueRequest( pReq.get() );
                if ( SUCCEEDED(hr) ) pReq.release(); // queue took ownership
                
                // reenter the critsec
                ics.Enter();
            }    // For schedule requests

        }    // IF !SingleStaticRequest
    }while(0);

    // If we have to cancel, do so OUTSIDE of the critsec
    ics.Leave();

    if ( FAILED( hr ) )
    {
        Cancel( hr );
    }

    return hr;
}

// Schedules a child class request
HRESULT CWmiMerger::ScheduleMergerChildRequest( CWmiMergerRecord* pParentRecord )
{
    // Check if query arbitration is enabled
    if (!ConfigMgr::GetEnableQueryArbitration()) return WBEM_S_NO_ERROR;

    CCheckedInCritSec    ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    HRESULT hr = WBEM_S_NO_ERROR;

    // We must be in a success state and not have previously scheduled a child
    // request.

    do 
    {
		if (FAILED(m_hOperationRes))
		{
		    hr = m_hOperationRes; break;
		}
		if (pParentRecord->ScheduledChildRequest()) 
		{
		   break;  // if already scheduled, bail out, with success
		}

		// If there isn't a task, we've got a BIG problem.
		_DBG_ASSERT( NULL != m_pTask );
		if ( NULL == m_pTask ) 
		{
		    hr = WBEM_E_FAILED; break;
		}

		wmilib::auto_ptr<CMergerChildReq> pReq;
		pReq.reset(new CMergerChildReq (this,pParentRecord,
			                            m_pNamespace,m_pTargetSink,
			                            pParentRecord->GetExecutionContext()));

		if (NULL == pReq.get())
		{
		    hr = WBEM_E_OUT_OF_MEMORY; break;       
		}
		if ( NULL == pReq->GetContext())
		{
		    hr = WBEM_E_OUT_OF_MEMORY; break;
		}
		// Set the task for the request - we'll just use the existing one
		m_pTask->AddRef();
		pReq->m_phTask = m_pTask;

		// This may sleep, so exit the critsec before calling into this
		ics.Leave();
		hr = ConfigMgr::EnqueueRequest( pReq.get() );
		ics.Enter();
		if (SUCCEEDED(hr))
		{
		    // We've basically scheduled one at this point
    		pParentRecord->SetScheduledChildRequest();
		    pReq.release();
		}
    }while(0);

    // If we have to cancel, do so OUTSIDE of the critsec
    ics.Leave();

    if (FAILED(hr)) Cancel(hr);

    return hr;
}

// Returns whether or not we have a single static class request in the merger
// or not
BOOL CWmiMerger::IsSingleStaticRequest( void )
{
    CCheckedInCritSec    ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    BOOL    fRet = FALSE;

    if ( NULL != m_pRequestMgr )
    {
        // Ask if we've got a single request
        fRet = m_pRequestMgr->HasSingleStaticRequest();
    }    // IF NULL != m_pRequestMgr

    return fRet;
}

//
//    CWmiMergerRecord
//    
//    Support class for CWmiMerger - encapsulates sub-sink functionality for the CWmiMerger
//    class.  The merger calls the records which actually know whether or not they sit on
//    top of sinks or actual mergers.
//

CWmiMergerRecord::CWmiMergerRecord( CWmiMerger* pMerger, BOOL fHasInstances,
                BOOL fHasChildren, LPCWSTR pwszClass, CMergerSink* pDestSink, DWORD dwLevel,
                bool bStatic )
:    m_pMerger( pMerger ),
    m_fHasInstances( fHasInstances ),
    m_fHasChildren( fHasChildren ),
    m_dwLevel( dwLevel ),
    m_wsClass( pwszClass ), // throw
    m_pDestSink( pDestSink ),
    m_pInternalMerger( NULL ),
    m_ChildArray(),
    m_bScheduledChildRequest( false ),
    m_pExecutionContext( NULL ),
    m_bStatic( bStatic )
{
    // No Addrefing internal sinks, since they really AddRef the entire merger
    // and we don't want to create Circular Dependencies
}

CWmiMergerRecord::~CWmiMergerRecord()
{
    if ( NULL != m_pInternalMerger )
    {
        delete m_pInternalMerger;
    }

    if ( NULL != m_pExecutionContext )
    {
        m_pExecutionContext->Release();
    }
}

HRESULT CWmiMergerRecord::AttachInternalMerger( CWbemClass* pClass, CWbemNamespace* pNamespace,
                                                IWbemContext* pCtx, BOOL fDerivedFromTarget,
                                                bool bStatic )
{
    if ( NULL != m_pInternalMerger )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    HRESULT    hr = WBEM_S_NO_ERROR;

    // m_pDestSink is not addrefed by the MergerRecord
    m_pInternalMerger = new CInternalMerger( this, m_pDestSink, pClass, pNamespace, pCtx );

    if ( NULL == m_pInternalMerger ) return WBEM_E_OUT_OF_MEMORY;

    hr = m_pInternalMerger->Initialize();

    if ( FAILED( hr ) )
    {
        delete m_pInternalMerger;
        m_pInternalMerger = NULL;
    }
    else
    {
        m_pInternalMerger->SetIsDerivedFromTarget( fDerivedFromTarget );
    }

    return hr;
}

CMergerSink* CWmiMergerRecord::GetChildSink( void )
{
    CMergerSink*    pSink = NULL;

    if ( NULL != m_pInternalMerger )
    {
        pSink = m_pInternalMerger->GetChildSink();
    }
    else if ( m_fHasChildren )
    {
        m_pDestSink->AddRef();  // addref-it before giving-it out, but not ref for itself
        pSink = m_pDestSink;
    }

    return pSink;
}

CMergerSink* CWmiMergerRecord::GetOwnSink( void )
{
    CMergerSink*    pSink = NULL;

    if ( NULL != m_pInternalMerger )
    {
        pSink = m_pInternalMerger->GetOwnSink();
    }
    else if ( !m_fHasChildren )
    {
        m_pDestSink->AddRef();
        pSink = m_pDestSink; // addref-it before giving-it out, but not ref for itself
    }

    return pSink;
}

CMergerSink* CWmiMergerRecord::GetDestSink( void )
{
    if ( NULL != m_pDestSink )
    {
        m_pDestSink->AddRef();
    }
    // addref-it before giving-it out, but not ref for itself
    CMergerSink*    pSink = m_pDestSink;

    return pSink;
}

void CWmiMergerRecord::Cancel( HRESULT hRes )
{
    if ( NULL != m_pInternalMerger )
    {
        m_pInternalMerger->Cancel( hRes );
    }

}

HRESULT CWmiMergerRecord::AddChild( CWmiMergerRecord* pRecord )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( m_ChildArray.Add( pRecord ) < 0 )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

CWmiMergerRecord* CWmiMergerRecord::GetChildRecord( int nIndex )
{
    // Check if the index is a valid record, then return it
    if ( nIndex < m_ChildArray.GetSize() )
    {
        return m_ChildArray[nIndex];
    }

    return NULL;
}

HRESULT CWmiMergerRecord::SetExecutionContext( IWbemContext* pContext )
{
    // We can only do this once

    _DBG_ASSERT( NULL == m_pExecutionContext );

    if ( NULL != m_pExecutionContext )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    if (pContext)
    {
         pContext->AddRef();
        m_pExecutionContext = pContext;
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmiarbitrator.h ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    WmiArbitrator.h

Abstract:
    Implementation of the arbitrator.  The arbitrator is the class which
    watches over everything to make sure it is not using too many resources.
    Big brother is watching over you :-)


History:
    paulall     09-Apr-00       Created.
    raymcc      08-Aug-00       Made it actually do something useful

--*/


class CWmiArbitrator : public _IWmiArbitrator
{
private:
    LONG                m_lRefCount;

    ULONG               m_uTotalTasks;
    ULONG               m_uTotalPrimaryTasks;
	ULONG				m_uTotalThrottledTasks;

    __int64             m_lFloatingLow;                         // Currently available memory (within WMI high)
    __int64             m_uSystemHigh;                          // Maximum memory usable by WMI
    ULONG               m_lMaxSleepTime;                        // Max sleep time in ms for any task
    __int64             m_uTotalMemoryUsage;                    // Total memory consumed by all tasks
    ULONG               m_uTotalSleepTime;                      // Total sleep time for overall system

    DOUBLE              m_lMultiplier;
    DOUBLE              m_lMultiplierTasks;
	
    DOUBLE              m_dThreshold1;
    LONG                m_lThreshold1Mult;

    DOUBLE              m_dThreshold2;
    LONG                m_lThreshold2Mult;

    DOUBLE              m_dThreshold3;
    LONG                m_lThreshold3Mult;

	LONG				m_lUncheckedCount;
	
    CFlexArray          m_aTasks;
    CFlexArray          m_aNamespaces;

    CCritSec            m_csNamespace;
    CCritSec            m_csArbitration;
    CCritSec            m_csTask;

    HANDLE              m_hTerminateEvent;
    BOOL				m_bSetupRunning;

	ULONG				m_lMemoryTimer ;
    DOUBLE				m_fSystemHighFactor;
    BOOL                m_bShutdown;
    LIST_ENTRY          m_NameSpaceList;

protected:
    static CWmiArbitrator *m_pArb;

    CWmiArbitrator();
    ~CWmiArbitrator();

    void WINAPI DiagnosticThread();
    DWORD MaybeDumpInfoGetWait();
	BOOL NeedToUpdateMemoryCounters ( ) ;


public:
    static DWORD WINAPI _DiagnosticThread(CWmiArbitrator *);

    static HRESULT Initialize( OUT _IWmiArbitrator ** ppArb);
    static HRESULT Shutdown(BOOL bIsSystemShutdown);
    static _IWmiArbitrator *GetUnrefedArbitrator() { return m_pArb; }
    static _IWmiArbitrator *GetRefedArbitrator() { if (m_pArb) m_pArb->AddRef(); return m_pArb; }

    BOOL IsTaskInList(CWmiTask *);  // test code
    BOOL IsTaskArbitrated ( CWmiTask* phTask ) ;
	HRESULT UnregisterTaskForEntryThrottling ( CWmiTask* pTask ) ;
	HRESULT RegisterTaskForEntryThrottling ( CWmiTask* pTask ) ;

    HRESULT DoThrottle ( CWmiTask* phTask, ULONG ulSleepTime, ULONG ulMemUsage );

	LONG	DecUncheckedCount ( ) { InterlockedDecrement ( &m_lUncheckedCount ); return m_lUncheckedCount; }
	LONG	IncUncheckedCount ( ) { InterlockedIncrement ( &m_lUncheckedCount ); return m_lUncheckedCount; }

	__int64	GetWMIAvailableMemory ( DOUBLE ) ;
	BOOL	AcceptsNewTasks( CCoreExecReq* pReq );
	HRESULT UpdateMemoryCounters( BOOL = FALSE ) ;

    HRESULT InitializeRegistryData ( );
    HRESULT UpdateCounters     ( LONG lDelta, CWmiTask* phTask );
    HRESULT Arbitrate          ( ULONG uFlags, LONG lDelta, CWmiTask* phTask );
	HRESULT ClearCounters      ( ULONG lFlags ) ;

    HRESULT MapProviderToTask(
        ULONG uFlags,
        IWbemContext *pCtx,
        IWbemServices *pProv,
        CProviderSink *pSink
        );

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // Arbitrator-specific.
    // ====================

    STDMETHOD(RegisterTask)(
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(UnregisterTask)(
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(RegisterUser)(
        /*[in]*/ _IWmiCoreHandle *phUser
        );

    STDMETHOD(UnregisterUser)(
        /*[in]*/ _IWmiCoreHandle *phUser
        );

    STDMETHOD(pCancelTasksBySink)(
        ULONG uFlags,
        REFIID riid,
        LPVOID pSink,
        GUID & PrimaryId);

    STDMETHOD(CancelTasksBySink)(
        ULONG uFlags,
        REFIID riid,
        LPVOID pSink
        );

    STDMETHOD(CheckTask)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(TaskStateChange)(
        /*[in]*/ ULONG uNewState,               // Duplicate of the state in the task handle itself
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(CheckThread)(
        /*[in]*/ ULONG uFlags
        );

    STDMETHOD(CheckUser)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiUserHandle *phUser
        );

    STDMETHOD(CheckUser)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phUser
        );

    STDMETHOD(CancelTask)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTtask
        );

    STDMETHOD(RegisterThreadForTask)(
        /*[in]*/_IWmiCoreHandle *phTask
        );
    STDMETHOD(UnregisterThreadForTask)(
        /*[in]*/_IWmiCoreHandle *phTask
        );

    STDMETHOD(Maintenance)();

    STDMETHOD(RegisterFinalizer)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiFinalizer *pFinal
        );


    STDMETHOD(RegisterNamespace)(
            /* [in] */ _IWmiCoreHandle *phNamespace);

    STDMETHOD(UnregisterNamespace)(
            /* [in] */ _IWmiCoreHandle *phNamespace);

    STDMETHOD(ReportMemoryUsage)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ LONG  lDelta,
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(Throttle)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask
        );

    STDMETHOD(RegisterArbitratee)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
        );

    STDMETHOD(UnRegisterArbitratee)(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ _IWmiCoreHandle *phTask,
        /*[in]*/ _IWmiArbitratee *pArbitratee
        );


//    STDMETHOD(Shutdown)( void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmimerger.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    WMIMERGER.H

Abstract:

    Implements _IWmiMerger

History:

	16-Nov-00   sanjes    Created.

--*/

#ifndef _WMIMERGER_H_
#define _WMIMERGER_H_

#include "internalmerger.h"
#include "mergerreq.h"

// forward class definitions
class CWmiMerger;

//
//	Support class for CWmiMerger.
//
//	Basically, CWmiMerger holds onto many instances of CWmiMergerRecord
//

class CWmiMergerRecord
{
private:
	BOOL				m_fHasInstances;
	BOOL				m_fHasChildren;
	DWORD				m_dwLevel;
	WString				m_wsClass;
	CWmiMerger*			m_pMerger;
	CInternalMerger*	m_pInternalMerger;
	CMergerSink*		m_pDestSink;
	CPointerArray<CWmiMergerRecord>	m_ChildArray;
	bool				m_bScheduledChildRequest;
	IWbemContext*		m_pExecutionContext;
	bool				m_bStatic;


public:
	CWmiMergerRecord( CWmiMerger* pMerger, BOOL fHasInstances, BOOL fHasChildren,
					LPCWSTR pwszClass, CMergerSink* pDestSink, DWORD dwLevel,
					bool bStatic );
	~CWmiMergerRecord();

	CMergerSink*		GetChildSink( void );
	CMergerSink*		GetOwnSink( void );
	CMergerSink*		GetDestSink( void );
	LPCWSTR				GetClass( void ) { return m_wsClass; }
	LPCWSTR				GetName( void ) { return GetClass(); }
	BOOL				IsClass( LPCWSTR pwszClass ) { return m_wsClass.EqualNoCase( pwszClass ); }
	DWORD				GetLevel( void ) { return m_dwLevel; }
	bool				IsStatic( void ) { return m_bStatic; }

	HRESULT AttachInternalMerger( CWbemClass* pClass, CWbemNamespace* pNamespace, IWbemContext* pCtx,
									BOOL fDerivedFromTarget, bool bStatic );

	HRESULT AddChild( CWmiMergerRecord* pRecord );

	CWmiMerger*	GetWmiMerger( void )	{ return m_pMerger; }

	// If we have an internal merger, we tell it to cancel
	void Cancel( HRESULT hRes );

	bool ScheduledChildRequest( void )	{ return m_bScheduledChildRequest; }
	void SetScheduledChildRequest( void )	{ m_bScheduledChildRequest = true; }

	CWmiMergerRecord* GetChildRecord( int nIndex );

	HRESULT SetExecutionContext( IWbemContext* pContext );

	IWbemContext* GetExecutionContext( void )	{ return m_pExecutionContext; }

	// We can only cancel child sinks if we have an internal merger.
	//void CancelChildSink( void ) { if ( NULL != m_pInternalMerger ) m_pInternalMerger->CancelChildSink(); }

	void SetIsStatic( bool b )	{ m_bStatic = b; }


};

// Allows us to locate values quickly by name
template<class TMember>
class CSortedUniquePointerArray :
        public CUniquePointerArray<TMember>
{
public:
	int Insert( TMember* pNewElement );
	TMember* Find( LPCWSTR pwszName, int* pnIndex = NULL );
	int RemoveAtNoDelete( int nIndex );
	BOOL Verify( void );
};

template <class TMember>
int CSortedUniquePointerArray<TMember>::Insert( TMember* pNewElement )
{
    int   nLowIndex = 0,
          nHighIndex = m_Array.Size();

    // Binary search of the ids to find an index at which to insert
    // If we find our element, this is a failure.

	while ( nLowIndex < nHighIndex )
	{
		int   nMid = (nLowIndex + nHighIndex) / 2;

		int nTest = _wcsicmp( ((TMember*) m_Array[nMid])->GetName(), pNewElement->GetName() );

		if ( nTest < 0 )
		{
			nLowIndex = nMid + 1;
		}
		else if ( nTest > 0 )
		{
			nHighIndex = nMid;
		}
		else
		{
			_DBG_ASSERT( 0 );
			// Index already exists
			return -1;
		}
	}   // WHILE looking for index

	// Found the location, if it's at the end, check if we need to do an insert or add
	// We insert if the element at the end is > the element we want to insert
	BOOL	bInsert = true;

	if ( nLowIndex == GetSize() - 1 )
	{
		bInsert = ( _wcsicmp( ((TMember*) m_Array[nLowIndex])->GetName(), pNewElement->GetName() ) > 0 );
	}

    // Stick it in (careful to add to the end if the selected index is the end
	// and the current element is not greater than the new one).

	if ( bInsert )
	{
		return InsertAt( nLowIndex, pNewElement );
	}

	return Add( pNewElement );

}

template <class TMember>
TMember* CSortedUniquePointerArray<TMember>::Find( LPCWSTR pwszName, int* pnIndex )
{

    int   nLowIndex = 0,
          nHighIndex = m_Array.Size();

    // Binary search of the values to find a the requested name.
    while ( nLowIndex < nHighIndex )
    {
        int   nMid = (nLowIndex + nHighIndex) / 2;

		int nTest = _wcsicmp( ((TMember*) m_Array[nMid])->GetName(), pwszName );

        if ( nTest < 0 )
        {
            nLowIndex = nMid + 1;
        }
        else if ( nTest > 0 )
        {
            nHighIndex = nMid;
        }
        else
        {
            // Found it
			if ( NULL != pnIndex )
			{
				*pnIndex = nMid;
			}

            return (TMember*) m_Array[nMid];
        }
    }   // WHILE looking for index

    // Didn't find it
    return NULL;

}

// Removes the element, but does not auto-delete it
template <class TMember>
int CSortedUniquePointerArray<TMember>::RemoveAtNoDelete( int nIndex )
{
	if ( nIndex >= m_Array.Size() )
	{
		return -1;
	}

	m_Array.RemoveAt( nIndex );

	return nIndex;
}

template <class TMember>
BOOL CSortedUniquePointerArray<TMember>::Verify( void )
{
	BOOL	fReturn = TRUE;

	for ( int x = 0; fReturn && x < GetSize() - 1; x++ )
	{
		// Should be in ascending order
		LPCWSTR pwszFirst = GetAt( x )->GetName();
		LPCWSTR pwszSecond = GetAt( x+1 )->GetName();

		fReturn = ( _wcsicmp( GetAt( x )->GetName(), GetAt( x+1 )->GetName() ) < 0 );
		_DBG_ASSERT( fReturn );

		if ( !fReturn )
		{
			CSortedUniquePointerArray<TMember> tempArray;

			for ( int y = 0; y < GetSize(); y++ )
			{
				tempArray.Insert( GetAt( y ) );
			}
		}
	}
	
	return fReturn;
}

//******************************************************************************
//******************************************************************************
//
//  class CWmiMerger
//
//  This class implements the WMI Merger.
//
//******************************************************************************

class CWmiMerger : public _IWmiArbitratee, public _IWmiArbitratedQuery
{
private:
	long		m_lRefCount;
	WString		m_wsTargetClassName;
	CMergerTargetSink*	m_pTargetSink;
	_IWmiCoreHandle*	m_pTask;
	_IWmiArbitrator*	m_pArbitrator;
	CWbemNamespace*		m_pNamespace;
	DWORD		m_dwProviderDeliveryPing;
	DWORD		m_dwMaxLevel;
	DWORD		m_dwMinReqLevel;
	CSortedUniquePointerArray<CWmiMergerRecord>	m_MergerRecord;
	//
	// the sinks of the merger are wired objects
	// thy have a refcount a-la-COM, but they are destructed by the 
	// Manager of the m_MergerSinks Array
	//
	CUniquePointerArray<CMergerSink>		m_MergerSinks;
	long		m_lNumArbThrottled;
	HRESULT		m_hOperationRes;
	bool		m_bMergerThrottlingEnabled;
	CCritSec	m_cs;

	long		m_lDebugMemUsed;

	CWmiMergerRequestMgr* m_pRequestMgr;

    void CleanChildRequests(CWmiMergerRecord* pParentRecord, int startingWith);

public:
    // No access
    CWmiMerger( CWbemNamespace* pNamespace );
   ~CWmiMerger();

protected:

	HRESULT GetLevelAndSuperClass( _IWmiObject* pObj, DWORD* pdwLevel, 
		                           _variant_t & vSuperClass );

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	/* _IWmiArbitratee methods */
	STDMETHOD(SetOperationResult)( ULONG uFlags, HRESULT hRes );
	STDMETHOD(SetTaskHandle)( _IWmiCoreHandle* pTask );
	STDMETHOD(DumpDebugInfo)( ULONG uFlags, const BSTR strFile );

	/* _IWmiArbitratedQuery methods */
	STDMETHOD(IsMerger)( void );

	// Sets initial parameters for merger.  Establishes the target class and sink for the
	// query associated with the merger
	STDMETHOD(Initialize)( _IWmiArbitrator* pArbitrator, _IWmiCoreHandle* pTask, LPCWSTR pwszTargetClass, IWbemObjectSink* pTargetSink, CMergerSink** ppFinalSink );

	// Called to request a delivery sink for a class in the query chain.  The returned
	// sink is determined by the specified flags as well as settings on the parent class
	STDMETHOD(RegisterSinkForClass)( LPCWSTR pwszClass, _IWmiObject* pClass, IWbemContext* pContext,
									BOOL fHasChildren, BOOL fHasInstances, BOOL fDerivedFromTarget,
									bool bStatic, CMergerSink* pDestSink, CMergerSink** ppOwnSink, CMergerSink** ppChildSink );

	// Called to request a delivery sink for child classes in the query chain.  This is especially
	// important when instances are merged under the covers.
	STDMETHOD(GetChildSink)( LPCWSTR pwszClass, CBasicObjectSink** ppSink );

	// Can be used to holdoff indicates - if we're merging instances from multiple providers, we need
	// to ensure that we don't get lopsided in the number of objects we've got queued up for merging.
	STDMETHOD(Throttle)( void );

	// Merger will hold information regarding the total number of objects it has queued up waiting
	// for merging and the amount of memory consumed by those objects.
	STDMETHOD(GetQueuedObjectInfo)( DWORD* pdwNumQueuedObjects, DWORD* pdwQueuedObjectMemSize );

	// If this is called, all underlying sinks will be cancelled in order to prevent accepting additional
	// objects.  This will also automatically free up resources consumed by queued objects.
	STDMETHOD(Cancel)( void );

	// Helper function for creating our sinks - this will add the sink to our array of
	// sinks which will get destroyed when we are released
	HRESULT CreateMergingSink( MergerSinkType eType, IWbemObjectSink* pDestSink, CInternalMerger* pMerger, CMergerSink** ppSink );

	// If this is called, all underlying sinks will be cancelled in order to prevent accepting additional
	// objects.  This will also automatically free up resources consumed by queued objects.
	HRESULT Cancel( HRESULT hRes );

	// Final Shutdown.  Called when the target sink is released.  At this point, we should
	// unregister ourselves from the world
	HRESULT Shutdown( void );

	// Registers arbitrated requests
	HRESULT RegisterArbitratedInstRequest( CWbemObject* pClassDef, long lFlags, IWbemContext* pCtx,
				CBasicObjectSink* pSink, BOOL bComplexQuery, CWbemNamespace* pNs );

	HRESULT RegisterArbitratedQueryRequest( CWbemObject* pClassDef, long lFlags, LPCWSTR Query,
				LPCWSTR QueryFormat, IWbemContext* pCtx, CBasicObjectSink* pSink,
				CWbemNamespace* pNs );

	HRESULT RegisterArbitratedStaticRequest( CWbemObject* pClassDef, long lFlags, 
				IWbemContext* pCtx, CBasicObjectSink* pSink, CWbemNamespace* pNs,
				QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery );

	// Executes a Merger Parent Request - Cycles through parent object requests and executes
	// them as appropriate
	HRESULT Exec_MergerParentRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink );

	// Executes a Merger Child Request - Cycles through child classes of the given parent
	// class, and executes the appropriate requests
	HRESULT Exec_MergerChildRequest( CWmiMergerRecord* pParentRecord, CBasicObjectSink* pSink );

	// Schedules a Merger Parent Request if one is necessary
	HRESULT ScheduleMergerParentRequest( IWbemContext* pCtx );

	// Schedules a Merger Child Request
	HRESULT ScheduleMergerChildRequest( CWmiMergerRecord* pParentRecord );

	// Enables/Disables merger throttling in all records (on by default)
	void EnableMergerThrottling( bool b ) { m_bMergerThrottlingEnabled = b; }

	// Returns whether or not we have a single static request in the merger
	BOOL IsSingleStaticRequest( void );

	bool MergerThrottlingEnabled( void ) { return m_bMergerThrottlingEnabled; }

	_IWmiCoreHandle*	GetTask( void )	{ return m_pTask; }

	// Help us track that *something* is going on
	// We are intentionally not wrapping thread safety around these guys, since assigning and
	// retrieving the value is an atomic operation and realistically, if any contention occurs
	// setting the values, they should all, more or less reflect the same tick (remember, they're
	// all jumping in at the same time, so this shouldn't really be a problem.
	void PingDelivery( DWORD dwLastPing )	{ m_dwProviderDeliveryPing = dwLastPing; }
	DWORD GetLastDeliveryTime( void ) { return m_dwProviderDeliveryPing; }

    HRESULT ReportMemoryUsage( long lAdjustment );

	// Helper functions for tracking the number of threads potentially being throttled by
	// the arbitrator
	long IncrementArbitratorThrottling( void ) { return InterlockedIncrement( &m_lNumArbThrottled ); }
	long DecrementArbitratorThrottling( void ) { return InterlockedDecrement( &m_lNumArbThrottled ); }
	long NumArbitratorThrottling( void ) { return m_lNumArbThrottled ; }

};


#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmifinalizer.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    WmiFinalizer2

Abstract:


History:

    paulall        27-Mar-2000        Created.
    marioh        20-Oct-2000        Major updates completed

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiFinalizer.h"
#include "coresvc.h"
#include "coreq.h"
#include <wbemcore.h>
#include <wmiarbitrator.h>

#include <autoptr.h>
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Batching related registry data
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define    REGKEY_CIMOM        "Software\\Microsoft\\Wbem\\CIMOM"
#define REGVALUE_BATCHSIZE    "FinalizerBatchSize"

ULONG g_ulMaxBatchSize = 0;


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Client callback related registry data
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define REGVALUE_CLIENTCALLBACKTIMEOUT    "ClientCallbackTimeout"

ULONG g_ulClientCallbackTimeout = 0;


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Queue threshold related registry data
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define REGVALUE_QUEUETHRESHOLD            "FinalizerQueueThreshold"
#define DEFAULT_QUEUETHRESHOLD            2

ULONG g_ulFinalizerQueueThreshold = 0;



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Static declarations and initialization
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LONG s_Finalizer_ObjectCount = 0 ;                                            // Global finalizer count
LONG s_FinalizerCallResult_ObjectCount = 0 ;                                // Global CallbackEesult count
LONG s_FinalizerEnum_ObjectCount = 0 ;                                        // Global Enumerator count
LONG s_FinalizerEnumSink_ObjectCount = 0 ;                                    // Global Enumerator sink count
LONG s_FinalizerInBoundSink_ObjectCount = 0 ;                                // Global InboundSink count


#define RET_FNLZR_ASSERT(msg, hres)  return hres
#define FNLZR_ASSERT(msg, hres)

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//                                                    CWMIFINALIZER
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::CWmiFinalizer()
//
// Peforms initialization of the finalizer.
//
// Exceptions thrown:
//    
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CWmiFinalizer::CWmiFinalizer(CCoreServices *pSrvs)

    :    m_lRefCount(0),
        m_lInternalRefCount(0),
        m_phTask(NULL),
        m_pArbitrator(NULL),
        m_pDestSink(NULL),
        m_uForwardingType(forwarding_type_none),
        m_hresFinalResult(-1),
        m_bRestartable(false),
        m_uCurObjectPosition(0),
        m_bSetStatusCalled(false),
        m_bSetStatusConsumed(false),
        m_ulQueueSize (0),
        m_bCancelledCall (FALSE),
        m_bNaughtyClient (FALSE),
        m_ulStatus (WMI_FNLZR_STATE_NO_INPUT),
        m_hCancelEvent (NULL),
        m_hStatus (NoError),
        m_ulOperationType (0),
        m_ulSemisyncWakeupCall (0),
        m_ulAsyncDeliveryCount (0),
        m_apAsyncDeliveryBuffer (NULL),
        m_lCurrentlyDelivering (FALSE),
        m_lCurrentlyCancelling (FALSE),
        m_enumBatchStatus (FinalizerBatch_NoError),
        m_bSetStatusEnqueued ( FALSE ),
        m_bSetStatusWithError ( FALSE ),
        m_lMemoryConsumption ( 0 ),
        m_bTaskInitialized ( FALSE ) ,
        m_bClonedFinalizer ( FALSE ) ,
        m_hWaitForSetStatus ( NULL ) ,
        m_bSetStatusDelivered ( FALSE ),
        m_LineCancelCall(0)
{
    // validate CoreServices pointer
    if (NULL == pSrvs) throw CX_MemoryException();
    
    // Create m_hResultReceived handle
    HANDLE hTmpResRecved = CreateEvent(NULL, TRUE, FALSE, NULL);
    if ( NULL == hTmpResRecved ) throw CX_MemoryException();
    OnDeleteIf<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmResRecved(hTmpResRecved );

    // Create m_hCancelEvent handle
    HANDLE hTmpCancelEvent = CreateEvent(NULL, FALSE, FALSE, NULL); 
    if (NULL == hTmpCancelEvent) throw CX_MemoryException();
    OnDeleteIf<HANDLE,BOOL(*)(HANDLE),CloseHandle> cmCancelEvent (hTmpCancelEvent);    

    // Create new callresult
    m_pCallResult = new CWmiFinalizerCallResult(this);
    if (NULL == m_pCallResult) throw CX_MemoryException();

    m_pCallResult->InternalAddRef();    

    cmResRecved.dismiss();
    m_hResultReceived = hTmpResRecved;

    cmCancelEvent.dismiss();
    m_hCancelEvent = hTmpCancelEvent;
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Get arbitrator
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    m_pArbitrator = CWmiArbitrator::GetRefedArbitrator();
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check what the batch size is supposed to be through registry.
    // If not found, use default size defined in DEFAULT_BATCH_TRANSMIT_BYTES
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( !g_ulMaxBatchSize )
    {
        g_ulMaxBatchSize = DEFAULT_BATCH_TRANSMIT_BYTES;

        Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, TEXT(REGKEY_CIMOM));
        if ( batchSize.GetLastError() == ERROR_SUCCESS )
        {
            DWORD dwTmp;
            batchSize.GetDWORD ( TEXT(REGVALUE_BATCHSIZE), &dwTmp );
            if ( batchSize.GetLastError() == ERROR_SUCCESS )
                g_ulMaxBatchSize = (LONG) dwTmp;
        }
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check what the timeout for client callbacks is supposed to be through registry.
    // If not found, use default size defined in ABANDON_PROXY_THRESHOLD
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( !g_ulClientCallbackTimeout )
    {
        g_ulClientCallbackTimeout = ABANDON_PROXY_THRESHOLD;

        Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, TEXT(REGKEY_CIMOM));
        if ( batchSize.GetLastError() == ERROR_SUCCESS )
        {
            DWORD dwTmp;
            batchSize.GetDWORD ( TEXT(REGVALUE_CLIENTCALLBACKTIMEOUT), &dwTmp );
            if ( batchSize.GetLastError() == ERROR_SUCCESS )
                g_ulClientCallbackTimeout = (LONG) dwTmp;
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check what the timeout for client callbacks is supposed to be through registry.
    // If not found, use default size defined in ABANDON_PROXY_THRESHOLD
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( !g_ulFinalizerQueueThreshold )
    {
        g_ulFinalizerQueueThreshold = DEFAULT_QUEUETHRESHOLD;

        Registry batchSize (HKEY_LOCAL_MACHINE, KEY_QUERY_VALUE, TEXT(REGKEY_CIMOM));
        if ( batchSize.GetLastError() == ERROR_SUCCESS )
        {
            DWORD dwTmp;
            batchSize.GetDWORD ( TEXT(REGVALUE_QUEUETHRESHOLD), &dwTmp );
            if ( batchSize.GetLastError() == ERROR_SUCCESS )
                g_ulFinalizerQueueThreshold = (LONG) dwTmp;
        }
    }

    InterlockedIncrement ( & s_Finalizer_ObjectCount ) ;

}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::~CWmiFinalizer()
//
// Destructor. Decrements global finalizer object count
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CWmiFinalizer::~CWmiFinalizer()
{
    InterlockedDecrement ( & s_Finalizer_ObjectCount ) ;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Unregister with arbitrator
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (m_pArbitrator)
    {
        m_pArbitrator->UnRegisterArbitratee (0, m_phTask, this);
    }

    if ( m_phTask )
    {
        m_phTask->Release ( );
        m_phTask = NULL ;
    }

    if (m_pArbitrator)
    {
        m_pArbitrator->Release();
        m_pArbitrator = NULL ;
    }

}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::CallBackRelease ()
//
//  Called when the external ref count (client ref count) goes to zero.
//  Performs following clean up tasks
//    
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void CWmiFinalizer::CallBackRelease ()
{
    {
        CInCritSec cs(&m_cs);

        // Release the arbitrator and all inbound sinks
        for (LONG i = 0; i < m_objects.Size(); i++)
        {
            CWmiFinalizerObj *pObj = (CWmiFinalizerObj*)m_objects[i];
            delete pObj;
        }
        m_objects.Empty ( ) ;
    }

    for (int i = 0; i < m_inboundSinks.Size(); i++)
    {
        ((CWmiFinalizerInboundSink*)m_inboundSinks[i])->InternalRelease();
    }
    m_inboundSinks.Empty();
    

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Release the destination sink
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ReleaseDestinationSink();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // If the call hasnt been cancelled already, go ahead and
    // do so now
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (!m_bCancelledCall)
        CancelTaskInternal();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Close all handles
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( m_hResultReceived )
    {
        SetEvent ( m_hResultReceived ) ;
        CloseHandle ( m_hResultReceived);
        m_hResultReceived = NULL ;
    }

    if ( m_hCancelEvent )
    {
        SetEvent ( m_hCancelEvent );
        CloseHandle ( m_hCancelEvent );
        m_hCancelEvent = NULL ;
    }

    // Release callresult and enumerator
    m_pCallResult->InternalRelease();
    m_pCallResult = NULL ;
    
    //
    // Release all enumerators associated with this finalizer
    //
    {
        CInCritSec cs ( &m_cs ) ;           // SEC:REVIEWED 2002-03-22 : Assumes entry
        for ( i = 0; i < m_enumerators.Size(); i++ )
        {
            ((CWmiFinalizerEnumerator*)m_enumerators[i])->InternalRelease ( ) ;
        }
        m_enumerators.Empty ( ) ;
    }

    NotifyClientOfCancelledCall ( ) ;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::CancelTaskInternal()
//
// Calls the arbitrator and unregisters the task
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
HRESULT CWmiFinalizer::CancelTaskInternal ( )
{
    CInCritSec lock(&m_arbitratorCS);   // SEC:REVIEWED 2002-03-22 : Assumes entry
    HRESULT hRes = WBEM_E_FAILED;

    if (m_phTask && m_pArbitrator)
    {
         hRes = m_pArbitrator->UnregisterTask(m_phTask); 
    }
    return hRes;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
//
// Std implementation of QI
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (ppvObj == 0)
        return ERROR_INVALID_PARAMETER;

    // SEC:REVIEWED 2002-03-22 : Ideally, we should have EH around all
    // derefs of ppvObj, in case the memory is invalid.

    if (IID_IUnknown==riid )
    {
        *ppvObj = (_IWmiFinalizer*)this;
    }
    else if (IID__IWmiFinalizer == riid)
    {
        *ppvObj = (_IWmiFinalizer*)this;
    }
    else if (IID__IWmiArbitratee == riid)
    {
     *ppvObj = (_IWmiArbitratee*)this;
    }
    else if (IID_IWbemShutdown == riid)
    {
     *ppvObj = (IWbemShutdown*)this;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)(* ppvObj))->AddRef();         // SEC:REVIEWED 2002-03-22 : Needs EH
    return NOERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::AddRef()
//
// Std implementation of AddRef.
// Also does internal addref
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::AddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
    if ( uNewCount == 1 )
    {
        InternalAddRef () ;
    }

    return uNewCount;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::Release()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
    {
        CallBackRelease () ;

        InternalRelease () ;
    }

    return uNewCount;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// CWmiFinalizer::InternalAddRef()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::InternalAddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
    return uNewCount;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ULONG CWmiFinalizer::InternalRelease()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG CWmiFinalizer::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
    if (0 == uNewCount)
    {
        delete this ;
    }

    return uNewCount;
}


/*
    * =====================================================================================================
    |
    | HRESULT CWmiFinalizer::ReportMemoryUsage ( ULONG lFlags, LONG lDelta )
    | ----------------------------------------------------------------------
    |
    | Common point to report memory consumption to the arbitrator.
    |
    | Uses m_phTask when calling arbitrator.
    |
    |
    |
    * =====================================================================================================
*/

HRESULT CWmiFinalizer::ReleaseDestinationSink ( )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    {
        CInCritSec lock(&m_destCS);          // SEC:REVIEWED 2002-03-22 : Assumes entry
        if (m_pDestSink)
        {
            m_pDestSink->Release();           // SEC:REVIEWED 2002-03-22 : Needs EH in case user sink is garbage
            m_pDestSink = 0;
        }
    }
    NotifyClientOfCancelledCall ( ) ;
    return hRes ;
}


/*
    * =====================================================================================================
    |
    | HRESULT CWmiFinalizer::ReportMemoryUsage ( ULONG lFlags, LONG lDelta )
    | ----------------------------------------------------------------------
    |
    | Common point to report memory consumption to the arbitrator.
    |
    | Uses m_phTask when calling arbitrator.
    |
    |
    |
    * =====================================================================================================
*/
HRESULT CWmiFinalizer::ReportMemoryUsage ( ULONG lFlags, LONG lDelta )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    if (m_pArbitrator) 
        hRes = m_pArbitrator->ReportMemoryUsage ( lFlags, lDelta, m_phTask ) ;
    //
    // Atomic update of MemoryConsumption
    //
    InterlockedExchangeAdd ( &m_lMemoryConsumption, lDelta ) ;

    return hRes ;
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// CWmiFinalizer::Configure
// ------------------------
//
// Allows decoupled & fast-track configuration with no thread switches.
// Also will be used to configure cache operations and the likes.
//
// Parameters
// ----------
// uConfigID    - One of the values defined in WMI_FNLZR_CFG_TYPE
// pConfigVal    - Additional information needed

// Return codes
// ------------
// WBEM_E_INVALID_OPERATION - try to do the same thing more than once, or
//                                trying to change something already set up
// WBEM_E_INVALID_PARAMETER - Configuration parameter we do not know about
//                                was passed in
// WBEM_NO_ERROR             - Everything went well
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::Configure(
    /*[in]*/ ULONG uConfigID,
    /*[in]*/ ULONG uValue
    )
{
    switch (uConfigID)
    {

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Do they want us to fast track?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        case WMI_FNLZR_FLAG_FAST_TRACK:
        {
            if (m_uForwardingType != forwarding_type_none)
                RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Configure called more than once!"), WBEM_E_INVALID_OPERATION);
            m_uForwardingType = forwarding_type_fast;
            break;
        }
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Do they want us to decouple?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        case WMI_FNLZR_FLAG_DECOUPLED:
        {
            if (m_uForwardingType != forwarding_type_none)
                RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Configure called more than once!"), WBEM_E_INVALID_OPERATION);
            m_uForwardingType = forwarding_type_decoupled;
            DWORD dwThreadId = 0;
            break;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Do they want us to do anything else? If so, assert
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        default:
            RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Configure - invalid parameter uConfigID"), WBEM_E_INVALID_PARAMETER);
    }
    
    return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// CWmiFinalizer::SetTaskHandle
// ----------------------------
//
// Task handle has user-specific stuff.  Finalizer just
// passes this through to _IWmiArbitrator::CheckTask.  It should only ever
// be called once
//
// Parameters
// ----------
// phTask    - Pointer to the task handle

// Return codes
// ------------
// WBEM_E_INVALID_OPERATION - try to do the same call more than once
// WBEM_E_INVALID_PARAMETER - Passed in parameter is invalid
// WBEM_NO_ERROR            - Everything went well
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::SetTaskHandle(
    _IWmiCoreHandle *phTask
    )
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Parameter validation
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (m_phTask != NULL)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetTaskHandle - already have m_phTask"),  WBEM_E_INVALID_OPERATION);
    if (phTask == NULL)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetTaskHandle - phTask == NULL"),  WBEM_E_INVALID_PARAMETER);

    m_bTaskInitialized = TRUE ;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Assign the task and AddRef it
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
        CInCritSec lock(&m_arbitratorCS);     // SEC:REVIEWED 2002-03-22 : Assumes entry
        m_phTask = phTask;
        m_phTask->AddRef();
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Register the finalizer with the arbitrator
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
        CInCritSec lock(&m_arbitratorCS);     // SEC:REVIEWED 2002-03-22 : Assumes entry
        if (m_pArbitrator)
        {
            m_pArbitrator->RegisterArbitratee(0, m_phTask, this);
        }
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // From the task, we can now see exactly what type of operation we are doing.
    // Get the operation type (SYNC/SEMISYNC/ASYNC) to avoid having to get it every time
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CWmiTask *pTsk = (CWmiTask *) m_phTask;
    ULONG ulTaskType = pTsk->GetTaskType();
    if ( (ulTaskType & WMICORE_TASK_TYPE_SYNC) )
    {
        m_ulOperationType = Operation_Type_Sync;
    }
    else if ( (ulTaskType & WMICORE_TASK_TYPE_SEMISYNC) )
    {
        m_ulOperationType = Operation_Type_Semisync;
    }
    else if ( (ulTaskType & WMICORE_TASK_TYPE_ASYNC) )
    {
        m_ulOperationType = Operation_Type_Async;
    }
    else
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetTaskHandle - Invalid operation type"),  WBEM_E_FAILED );
        
    return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// CWmiFinalizer::SetDestinationSink
// ---------------------------------
//
// For async operations, therefore if the forwarding type is not set to
// decoupled, this will fail.  If there are any items outstanding,
// this will also trigger them to be started
//
// Parameters
// ----------
// uFlags    -  unused
//
// pSink    - pointer to the created destination sink
//
// Return codes
// ------------
// WBEM_E_INVALID_OPERATION - try to do the same call more than once
// WBEM_E_INVALID_PARAMETER - Passed in parameter is invalid
// WBEM_NO_ERROR            - Everything went well
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

STDMETHODIMP CWmiFinalizer::SetDestinationSink(
        /*[in]*/ ULONG uFlags,
        /*[in]*/ REFIID riid,
        /*[in], iid_is(riid)]*/ LPVOID pVoid
    )
{

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Parameter validation
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (m_pDestSink != NULL)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - m_pDestSink != NULL"), WBEM_E_INVALID_OPERATION);
    if ((pVoid == NULL) || (uFlags != 0))
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - ((pSink == NULL) || (uFlags != 0))"), WBEM_E_INVALID_PARAMETER);
    if (m_uForwardingType == forwarding_type_none)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - m_uForwardingType == forwarding_type_none"), WBEM_E_INVALID_OPERATION);

    if ((riid != IID_IWbemObjectSink) )
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetDestinationSink - iid must be IID_IWbemObjectSink"), WBEM_E_INVALID_PARAMETER);

    HRESULT hr;
    IWbemObjectSink * pSink = (IWbemObjectSink *)pVoid;
    IWbemObjectSink * pSinkToStore = NULL;

   m_iidDestSink = IID_IWbemObjectSink;
   pSinkToStore = pSink;
   
    // Set the destination sink, AddRef it and set the impersonation level
    // to identity
    {
        CInCritSec lock(&m_destCS);    // SEC:REVIEWED 2002-03-22 : Assumes entry
        m_pDestSink = pSinkToStore;
        m_pDestSink->AddRef();          // SEC:REVIEWED 2002-03-22 : Needs EH in case sink is garbage
        SetSinkToIdentity (m_pDestSink);
    }

    return WBEM_NO_ERROR;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// The callback called during final Release(); Set() is called with the
// task handle, followed by SetStatus()
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::SetSelfDestructCallback(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ IWbemObjectSink *pSink
    )
{
    return E_NOTIMPL;
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// STDMETHODIMP CWmiFinalizer::GetStatus(
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STDMETHODIMP CWmiFinalizer::GetStatus(
    ULONG *pFlags
    )
{
    *pFlags = m_ulStatus;
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
// CWmiFinalizer::NewInboundSink
// -----------------------------
//
// Returns a sink to the caller.  This sink is used to indicate result sets
// back to the client.
//
// Parameters
// ----------
// uFlags    - Additional flags.  Currently 0 is only valid value.
// pSink    - Pointer to variable which will get the returned inbound sink.
//                It is this sink that allows the caller to send result sets.
//
// Return codes
// ------------
// WBEM_E_OUT_OF_MEMORY        - Failed to create the finaliser sink because of an
//                                out of memory situation
// WBEM_E_INVALID_PARAMETER    - Invalid parameters passed to method
// WBEM_NO_ERROR            - Everything completed successfully
//***************************************************************************
STDMETHODIMP CWmiFinalizer::NewInboundSink(
    /*[in]*/  ULONG uFlags,
    /*[out]*/ IWbemObjectSink **pSink
    )
{
    if ((pSink == NULL) || (uFlags != 0))
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::NewInboundSink - ((pSink == NULL) || (uFlags != 0))!"), WBEM_E_INVALID_PARAMETER);

    if (m_inboundSinks.Size())
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::NewInboundSink - Multiple inbound sinks not yet implemented!!"), E_NOTIMPL);

    CWmiFinalizerInboundSink *pNewSink = new CWmiFinalizerInboundSink(this);
    if (pNewSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pNewSink->AddRef(); // Required to return a positive ref count on a new object    // SEC:REVIEWED 2002-03-22 : OK

    CInCritSec autoLock(&m_cs);     // SEC:REVIEWED 2002-03-22 : Assumes entry

    int nRet = m_inboundSinks.Add(pNewSink);
    if (nRet != CFlexArray::no_error)
    {
        pNewSink->Release();
        return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pNewSink->InternalAddRef();
    }

    *pSink = pNewSink;     // SEC:REVIEWED 2002-03-22 : Should be in EH if case memory is not valid
    
    return WBEM_NO_ERROR;
}

//***************************************************************************
//
// Allows merging another Finalizer, _IWmiCache, etc.
// For sorting, we will create a sorted _IWmiCache and merge it in later when
// the sort is completed.
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::Merge(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ REFIID riid,
    /*[in]*/ LPVOID pObj
    )
{
    RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Merge - Not implemented!"), E_NOTIMPL);
}

// For setting, getting objects

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::SetResultObject(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ REFIID riid,
    /*[in]*/ LPVOID pObj
    )
{
    //No one is calling this!  All objects are getting in through a call to Indicate,
    //or Set, which are both just forwards from the InboundSink we pass out.
    RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::Merge - Not implemented!"), E_NOTIMPL);
}


//***************************************************************************
//
// Support _IWmiObject, IWbemClassObject, etc.
// IEnumWbemClassObject
// _IWmiCache
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::GetResultObject(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ LPVOID *ppObj
    )
{
    // uFlags can be non-zero iff the requested interface is an enumerator
    if (uFlags != 0 && riid != IID_IEnumWbemClassObject)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - uFlags != 0, non enum interface!"), WBEM_E_INVALID_PARAMETER);


    if (riid == IID_IEnumWbemClassObject)
    {

        //If forward-only is set we should not let the result set be restartable.
        if (!(uFlags & WBEM_FLAG_FORWARD_ONLY))
            m_bRestartable = true;

        //m_uDeliveryType = delivery_type_pull;
        CWmiFinalizerEnumerator* pEnum = NULL ;
        try
        {
            //
            // I'm using the uFlags as a means of passing the current object position
            //
            pEnum = new CWmiFinalizerEnumerator(this);
        }
        catch (...) // status_no_memory
        {
            ExceptionCounter c;        
        }
        if (pEnum == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        else
            pEnum->InternalAddRef();


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Make sure nasty client does not crash us
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
        {
            *ppObj = pEnum;
        }
        catch (...) // ppObj is an untrusted param
        {
            ExceptionCounter c;        
            pEnum->InternalRelease();
            return WBEM_E_INVALID_PARAMETER;
        }

        {
            CInCritSec lock( &m_cs ) ;     // SEC:REVIEWED 2002-03-22 : Assumes entry

            //
            // Lets add the enumerator to the list of enumerators
            // associated with this finalizer.
            //
            int nRet = m_enumerators.Add ( pEnum ) ;
            if ( nRet != CFlexArray::no_error )
            {
                pEnum->InternalRelease ( ) ;
                return WBEM_E_OUT_OF_MEMORY;
            }        
        }

        pEnum->AddRef();
        return WBEM_NO_ERROR;
    }

    //Get the next object we have cached.
    if ((riid == IID_IWbemClassObject) || (riid == IID__IWmiObject))
    {
        if (m_pDestSink != NULL)
        {
            RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - Cannot get an object when there is a destination sink!"), WBEM_E_INVALID_OPERATION);
        }
        if (m_bSetStatusConsumed)
            return WBEM_E_NOT_FOUND;

        CWmiFinalizerObj *pFinalizerObj = NULL;
        bool bFinished = false;
        HRESULT hRes = WBEM_E_NOT_FOUND;
        while (!bFinished)
        {
            hRes = GetNextObject(&pFinalizerObj);
            if (FAILED(hRes))
                return hRes;

            else if (hRes == WBEM_S_FALSE)
                return WBEM_E_NOT_FOUND;

            if (pFinalizerObj->m_objectType == CWmiFinalizerObj::object)
            {
                if (ppObj)
                {
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // Make sure nasty client does not crash us
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    try
                    {
                        *ppObj = pFinalizerObj->m_pObj;
                    }
                    catch (...) // untrusted param
                    {
                        ExceptionCounter c;                    
                        return WBEM_E_INVALID_PARAMETER;
                    }

                    if (pFinalizerObj->m_pObj)
                        pFinalizerObj->m_pObj->AddRef();
                }
                bFinished = true;
            }
            else if ((pFinalizerObj->m_objectType == CWmiFinalizerObj::status) && (pFinalizerObj->m_lFlags == WBEM_STATUS_COMPLETE))
            {
                m_bSetStatusConsumed = true;
                hRes = WBEM_E_NOT_FOUND;
                bFinished = true;
            }
            else if (pFinalizerObj->m_objectType == CWmiFinalizerObj::status)
            {
                //This is a non-completion status message!  We most certainly have not finished yet!
            }
            delete pFinalizerObj;
        }

        return hRes;
    }

    if ((riid == IID_IWbemCallResult) )
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Make sure nasty client does not crash us
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
        {
            m_pCallResult->AddRef();
            *ppObj = m_pCallResult;
        }
        catch (...) // untrusted param
        {
            ExceptionCounter c;        
            m_pCallResult->Release ();
            return WBEM_E_INVALID_PARAMETER;
        }
    
        return WBEM_S_NO_ERROR;
    }

    RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetResultObject - Unknown object IID requested!"), WBEM_E_INVALID_PARAMETER);
}

// For status-only operations

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::SetOperationResult(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ HRESULT hRes
    )
{
    if (uFlags != 0)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::SetOperationResult - uFlags != 0!"), WBEM_E_INVALID_PARAMETER);

    if ( m_hresFinalResult != -1 )
    {
        if ( hRes != WBEM_E_CALL_CANCELLED )
        {
            return WBEM_S_NO_ERROR ;
        }
    }

    if ( hRes == WBEM_E_CALL_CANCELLED_CLIENT )
    {
        m_hresFinalResult = hRes = WBEM_E_CALL_CANCELLED ;
    }
    else if ( hRes != WBEM_E_CALL_CANCELLED )
    {
        m_hresFinalResult = hRes ;
    }

    HRESULT hResCancel = WBEM_NO_ERROR ;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Special case for cancellations. Iff its an async operation. Otherwise,
    // we might mess up for sync/semi sync
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( ( hRes == WBEM_E_CALL_CANCELLED ) && ( m_ulOperationType == Operation_Type_Async ) )
    {
        hResCancel = CancelCall(__LINE__);
    }

    SetEvent(m_hResultReceived);

    return hResCancel ;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizer::GetOperationResult(
    /*[in]*/ ULONG uFlags,
    /*[in]*/ ULONG uTimeout,
    /*[out]*/ HRESULT *phRes
    )
{
    if (uFlags != 0)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::GetOperationResult - uFlags != 0!"), WBEM_E_INVALID_PARAMETER);

    HRESULT hr = WaitForCompletion(uTimeout);

    if (hr == WBEM_S_NO_ERROR)
    {
        *phRes = m_hresFinalResult;      // SEC:REVIEWED 2002-03-22 : Needs EH
        if ( FAILED ( m_hresFinalResult ) )
        {
            m_pCallResult->SetErrorInfo ( );    // SEC:REVIEWED 2002-03-22 : Needs EH
        }    
        
        CancelTaskInternal();
        m_hStatus = NoError;
    }
    
    return hr;
}

//***************************************************************************
// STDMETHODIMP CWmiFinalizer::CancelTask(
//***************************************************************************
STDMETHODIMP CWmiFinalizer::CancelTask(
    /*[in]*/ ULONG uFlags
    )
{
    if (uFlags != 0)
        RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::CancelTask - uFlags != 0!"), WBEM_E_INVALID_PARAMETER);

    return CancelTaskInternal ( );
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::WaitForCompletion(ULONG uTimeout)
{
    DWORD dwRet =  CCoreQueue :: QueueWaitForSingleObject(m_hResultReceived, uTimeout);
    if (dwRet == WAIT_OBJECT_0)
    {
        return WBEM_S_NO_ERROR;
    }
    else if ((dwRet == WAIT_FAILED) ||
             (dwRet == WAIT_ABANDONED))
    {
        return WBEM_E_FAILED;
    }
    else
    {
        return WBEM_S_TIMEDOUT;
    }
}

//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::Reset(
    )
{
    if (m_bRestartable)
    {
        /*m_uCurObjectPosition = 0;
        m_bSetStatusConsumed = false;*/
        return WBEM_NO_ERROR;
    }
    else
        return WBEM_E_INVALID_OPERATION;
}

//***************************************************************************
//
//***************************************************************************

IWbemObjectSink* CWmiFinalizer::ReturnProtectedDestinationSink ( )
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Do we have a valid object sink?
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IWbemObjectSink* pTmp = NULL;
    {
        CInCritSec lock(&m_destCS);     // SEC:REVIEWED 2002-03-22 : Assumes entry
        if ( m_pDestSink==NULL )
        {
            return NULL;
        }
        else
        {
            pTmp = m_pDestSink;
            pTmp->AddRef();    // SEC:REVIEWED 2002-03-22 : Needs EH in case sink is garbage
        }
    }
    return pTmp;
}


//***************************************************************************
//
//***************************************************************************
DWORD WINAPI CWmiFinalizer::ThreadBootstrap( PVOID pParam )
{
//    char buff[100];
//    sprintf(buff, "thread this pointer = 0x%p\n", pParam);
//    OutputDebugString(buff);
    return ((CWmiFinalizer*)pParam)->AsyncDeliveryProcessor();
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::BootstrapDeliveryThread  ( )
{
    BOOL bRes;
    HRESULT hRes = WBEM_S_NO_ERROR;
    
    AddRef();                                                                                    // Need to AddRef Finalizer for the delivery thread
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Native Win2k thread dispatching
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    bRes = QueueUserWorkItem ( ThreadBootstrap, this, WT_EXECUTEDEFAULT );
    if ( !bRes )
    {
        Release ();
        hRes = WBEM_E_FAILED;
    }
    
    return hRes;
}




//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizer::AsyncDeliveryProcessor()
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    BOOL    bKeepDelivering = TRUE;


    m_enumBatchStatus = FinalizerBatch_NoError;

    RevertToSelf ( );   // SEC:REVIEWED 2002-03-22 : Needs check

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // First we tell the arbitrator about the delivery thread
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
        CInCritSec lock(&m_arbitratorCS);    // SEC:REVIEWED 2002-03-22 : Assumes entry
        if (m_pArbitrator)
        {
            hRes = m_pArbitrator->RegisterThreadForTask(m_phTask);
            if (hRes == WBEM_E_QUOTA_VIOLATION)
            {
                //TODO: WHAT HAPPENS HERE?
            }
        }
    }

    
    while ( bKeepDelivering )
    {

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // First off, have we been cancelled?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( m_bCancelledCall )
        {
            DeliverSingleObjFromQueue ( );
            bKeepDelivering = FALSE;
            continue;
        }


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Next, we build the transmit buffer
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        hRes = BuildTransmitBuffer         ( );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // BuildTransmitBuffer will return WBEM_S_FALSE if the batch immediately hit a
        // status message.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( hRes != WBEM_E_FAILED )
        {
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Next, deliver the batch of objects
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            DeliverBatch ( );
        }


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we have a status message to deliver do so now
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( m_enumBatchStatus == FinalizerBatch_StatusMsg )
        {
            DeliverSingleObjFromQueue ( );
        }
            

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we have a status complete message we should keep building the batch and
        // delivering until done
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( m_bSetStatusEnqueued && m_objects.Size() )
            continue;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // We could have another batch to deliver by now. Check
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else if ( m_ulQueueSize < g_ulMaxBatchSize )
            bKeepDelivering = FALSE;

        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Make sure we're properly synchronized with the inbound threads
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        CInCritSec cs(&m_cs);     // SEC:REVIEWED 2002-03-22 : Assumes entry
        {
            if ( !m_bSetStatusEnqueued )
            {
                bKeepDelivering = FALSE;
                m_lCurrentlyDelivering = FALSE;
            }
            else
            {
                bKeepDelivering = TRUE;
            }
        }
    }

    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Tell the arbitrator that the thread is done
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {
        CInCritSec lock(&m_arbitratorCS);   // SEC:REVIEWED 2002-03-22 : Assumes entry
        if (m_pArbitrator)
        {
            m_pArbitrator->UnregisterThreadForTask(m_phTask);                        // Since thread is going away, tell arbitrator about this
        }
    }

    Release();
    return 0;
}




//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::GetNextObject(CWmiFinalizerObj **ppObj)
{
    if (m_uCurObjectPosition >= (ULONG)m_objects.Size())
        return WBEM_S_FALSE;

    CInCritSec cs(&m_cs);   // SEC:REVIEWED 2002-03-22 : Assumes entry

    CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[m_uCurObjectPosition];

    if (m_bRestartable)
    {
        //We have to hold on to results, so increment cursor position...
        m_uCurObjectPosition++;

        *ppObj = new CWmiFinalizerObj(*pStorageObject);     // SEC:REVIEWED 2002-03-22 : Needs EH and NULL test

        if (*ppObj == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        //ReportMemoryUsage ( 0, (*ppObj)->m_uSize ) ;
    }
    else
    {
        //We are not restartable, therefore we need to release everything...
        m_objects.RemoveAt(0);
        *ppObj = pStorageObject;     // SEC:REVIEWED 2002-03-22 : Needs EH and NULL test

        //ADDBACK: ReportMemoryUsage ( 0, -((*ppObj)->m_uSize) ) ;
//        printf("Returning object 0x%p from object list\n", pStorageObject);
    }


    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::UnregisterInboundSink(CWmiFinalizerInboundSink *pSink)
{
    // Use m_cs lock for this
    CInCritSec lock(&m_cs);     // SEC:REVIEWED 2002-03-22 : Assumes entry
    
    for (int i = 0; i != m_inboundSinks.Size(); i++)
    {
        if (m_inboundSinks[i] == pSink)
        {
            pSink->InternalRelease () ;          // SEC:REVIEWED 2002-03-22 : Could use an EH for safety

            m_inboundSinks.RemoveAt(i);

            if (m_inboundSinks.Size() == 0)
                TriggerShutdown();

            return WBEM_NO_ERROR;
        }
    }

    RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::UnregisterInboundSink - Unregistering Inbound Sink that we could not find!"), WBEM_E_NOT_FOUND);
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::Indicate(
    /*[in]*/ long lObjectCount,
    /*[in, size_is(lObjectCount)]*/
        IWbemClassObject** apObjArray
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    
    if ( m_bCancelledCall )
    {
        return WBEM_E_CALL_CANCELLED;
    }

    {
        CInCritSec lock(&m_arbitratorCS);     // SEC:REVIEWED 2002-03-22 : Assumes entry
        if ( m_bSetStatusCalled )
        {
            return WBEM_E_INVALID_OPERATION;
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // First check the array for NULL objects. Return INVALID_OBJECT if
    // array contains a NULL object
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for (long x = 0; x != lObjectCount; x++)
    {
        if ( apObjArray[x] == NULL )            // SEC:REVIEWED 2002-03-22 : Needs EH
            return WBEM_E_INVALID_OBJECT;
    }

    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Are we fast tracking and async request?
    // ESS brutally tells us to deliver on the
    // same thread and do no batching
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( (m_uForwardingType == forwarding_type_fast) && (m_ulOperationType == Operation_Type_Async))
    {
        IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
        if ( !pTmp )
        {
            return WBEM_E_FAILED;
        }
        CReleaseMe myReleaseMe(pTmp);
    
        hRes = DoIndicate ( pTmp, lObjectCount, apObjArray );    // SEC:REVIEWED 2002-03-22 : Needs EH in case <apObjArray> is garbage

        // Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED from Indicate
        // We also want to cancel the call if the client is taking way too long to return
        if ( FAILED (hRes) || m_bCancelledCall == TRUE || m_bNaughtyClient == TRUE )
        {
            if ( hRes == WBEM_E_CALL_CANCELLED || m_bCancelledCall )
            {
                DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 );
            }
            else
            {
                DoSetStatusCancel ( pTmp, hRes );
            }
            	
            hRes = WBEM_E_CALL_CANCELLED;

            myReleaseMe.release ( ) ;

            ReleaseDestinationSink ( ) ;
            CancelCall(__LINE__);
        }
    }    
    else
    {
        for (long lIndex = 0; lIndex != lObjectCount; lIndex++)
        {
            if ( apObjArray[lIndex] )     // SEC:REVIEWED 2002-03-22 : Needs EH
            {
                CWmiFinalizerObj *pFinalizerObj = new CWmiFinalizerObj(apObjArray[lIndex], this); // SEC:REVIEWED 2002-03-22 : Needs EH
                if (pFinalizerObj == NULL) return WBEM_E_OUT_OF_MEMORY;

                HRESULT hr = QueueOperation(pFinalizerObj);
                if (FAILED(hr))  return hr; // queue will always destroy pFinalizerObj
            }
        }
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::Set(
    /*[in]*/ long lFlags,
    /*[in]*/ REFIID riid,
    /*[in, iid_is(riid)]*/ void *pComObject
    )
{
    CWmiFinalizerObj *pFinalizerObj = new CWmiFinalizerObj(lFlags, riid, pComObject); // SEC:REVIEWED 2002-03-22 : Needs EH
    if (pFinalizerObj == NULL) return WBEM_E_OUT_OF_MEMORY;
    return QueueOperation(pFinalizerObj);
}

//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::SetStatus(
    /*[in]*/ long lFlags,
    /*[in]*/ HRESULT hResult,
    /*[in]*/ BSTR strParam,
    /*[in]*/ IWbemClassObject* pObjParam
    )
{

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // If the operation has been cancelled, we should not accept another call
    // WBEM_E_CALL_CANCELLED
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     if ( m_bCancelledCall )
    {
        return WBEM_E_CALL_CANCELLED;
    }    

    {
        CInCritSec lock(&m_arbitratorCS);                                         // SEC:REVIEWED 2002-03-22 : Assumes entry
        if ( m_bSetStatusCalled && ( lFlags == WBEM_STATUS_COMPLETE ) )
        {
            return WBEM_E_INVALID_OPERATION;
        }
        else if ( lFlags == WBEM_STATUS_COMPLETE )
        {
            m_bSetStatusCalled = true ;
        }
    }
    
    //If this is a final call, we need to record it.
    if (lFlags == WBEM_STATUS_COMPLETE )
    {
        m_pCallResult->SetStatus(lFlags, hResult, strParam, pObjParam);
    }
    
    // Special case for cancellations
    if ( hResult == WBEM_E_CALL_CANCELLED )
    {
        HRESULT hr = CancelCall(__LINE__);
        SetEvent(m_hResultReceived);
        return hr;
    }

    HRESULT ourhres = WBEM_E_FAILED;
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Once again, we have to special case ESS
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( (m_uForwardingType == forwarding_type_fast) && 
         (m_ulOperationType == Operation_Type_Async)    )
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Do we have a valid object sink?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        IWbemObjectSink* pTmp = ReturnProtectedDestinationSink();
        CReleaseMe myReleaseMe(pTmp);
        
        if ( pTmp )
        {
            ourhres = DoSetStatus ( pTmp, lFlags, hResult, strParam, pObjParam );
            if (lFlags == WBEM_STATUS_COMPLETE || 
            	FAILED ( ourhres ) || 
            	m_bCancelledCall == TRUE || 
            	m_bNaughtyClient == TRUE )
            {
                NotifyAllEnumeratorsOfCompletion ( ) ;
                SetOperationResult(0, hResult);
                {
                    CInCritSec lock(&m_destCS);    // SEC:REVIEWED 2002-03-22 : Assumes entry
                    if ( m_pDestSink )
                    {
                        ReleaseDestinationSink ( ) ;
                        m_bSetStatusConsumed = true;
                        UpdateStatus ( WMI_FNLZR_STATE_CLIENT_COMPLETE );
                    }
                }
                CancelTaskInternal ( );                    
                if ( FAILED ( ourhres ) || m_bCancelledCall == TRUE || m_bNaughtyClient == TRUE )
                {
                    ourhres = WBEM_E_CALL_CANCELLED ;
                }
            }
        }
    }
    else
    {
        //Send the request to the user...
        // ObjectType::status
        CWmiFinalizerObj *pObj = new CWmiFinalizerObj(lFlags, hResult, strParam, pObjParam);  // SEC:REVIEWED 2002-03-22 : Needs EH
        if (pObj == NULL)
        {
            IWbemObjectSink* pTmp = ReturnProtectedDestinationSink();
            CReleaseMe myReleaseMe(pTmp);
            if ( pTmp )
            {
                DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 ) ;
            }
            SetOperationResult(0,WBEM_E_OUT_OF_MEMORY);
            m_hStatus = QueueFailure;
            NotifyAllEnumeratorsOfCompletion();
            return WBEM_E_OUT_OF_MEMORY;
        }

        ourhres = QueueOperation(pObj);

        if (lFlags == WBEM_STATUS_COMPLETE)
        {
            SetOperationResult(0, hResult);
            //QueueFailure is set internally in the QueueOperation
            NotifyAllEnumeratorsOfCompletion ( ) ;

            //
            // Lock the task
            //
            CWmiTask* pTask = NULL ;
            {
                CInCritSec lock(&m_arbitratorCS);   // SEC:REVIEWED 2002-03-22 : Assumes entry
                if ( m_phTask )
                {
                    pTask = (CWmiTask*) m_phTask ;
                    pTask->AddRef ( ) ;
                }
            }
            CReleaseMe _r ( pTask ) ;
            if ( pTask )
            {
                pTask->SetTaskResult ( hResult ) ;
            }
            ((CWmiArbitrator*) m_pArbitrator)->UnregisterTaskForEntryThrottling ( (CWmiTask*) m_phTask ) ;

        }
    }

    return ourhres;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::QueueOperation(CWmiFinalizerObj *pObj)
{
    LONG lDelta = 0;
    HRESULT hRes = WBEM_S_NO_ERROR;

    CCheckedInCritSec cs ( &m_cs ) ;                 // SEC:REVIEWED 2002-03-22 : Assumes entry
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Update total object size
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (pObj->m_objectType == CWmiFinalizerObj::object)        
    {
        CWbemObject* pObjTmp = (CWbemObject*) pObj -> m_pObj;
        m_ulQueueSize += pObjTmp -> GetBlockLength();
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // If we get a WBEM_E_CALL_CANCELLED status message, prioritize
    // the handling of this. Needed for fast shutdown.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( (pObj->m_objectType == CWmiFinalizerObj::status) && FAILED (pObj->m_hRes) )
    {
        m_bSetStatusWithError = TRUE ;
        if (CFlexArray::no_error != m_objects.InsertAt ( 0, pObj ))
        {
            delete pObj;
            m_hStatus = QueueFailure;            
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        // Normal Add object to queue
        if (CFlexArray::no_error != m_objects.Add(pObj)) 
        {
            delete pObj;
            m_hStatus = QueueFailure;            
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // First we check with the arbitrator what it tells us about
    // current limits. Make sure we call ReportMemoryUsage since
    // we're only interested in what it would potentially have done.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    HRESULT hArb = WBEM_S_ARB_NOTHROTTLING;
    lDelta = pObj->m_uSize;
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Are we decoupled, if so we need to analyze the current batch
    // and make decisions on delivery. Need to once again special case ESS.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( m_uForwardingType == forwarding_type_decoupled || 
    	 ( m_uForwardingType == forwarding_type_fast && 
    	   m_ulOperationType == Operation_Type_Async ) )
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // What did the arbitrator tell us about our situation?
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( pObj->m_hArb != WBEM_S_ARB_NOTHROTTLING )
        {
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Arbitrator told us that we either were about to be
            // cancelled or throttled. Flush our delivery buffers
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if ( m_lCurrentlyDelivering == FALSE || m_lCurrentlyCancelling == TRUE )
            {
                m_lCurrentlyDelivering = TRUE;
                BootstrapDeliveryThread( ); // Kick of the delivery thread since we're decoupled
            }

            cs.Leave ( ) ;
            hArb = m_pArbitrator->Throttle ( 0, m_phTask );
            if ( hArb == WBEM_E_ARB_CANCEL )
            {
                CancelCall( __LINE__);
            }
        }
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we are decoupled and get a Status message we should deliver
        // the batch and set the status
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else if ( (pObj->m_objectType == CWmiFinalizerObj::status) )
        {
            if ( pObj->m_lFlags == WBEM_STATUS_COMPLETE )
            {
                m_bSetStatusEnqueued = TRUE;
            }
            
            if ( m_lCurrentlyDelivering == FALSE || m_lCurrentlyCancelling == TRUE )
            {
                m_lCurrentlyDelivering = TRUE;
                BootstrapDeliveryThread  ( );                                    // Kick of the delivery thread since we're decoupled
            }
        }


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Delivery needs to be decoupled
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else if ( (m_ulQueueSize > g_ulMaxBatchSize) )
        {
            if ( m_lCurrentlyDelivering == FALSE )
            {
                m_lCurrentlyDelivering = TRUE;
                BootstrapDeliveryThread  ( );                                    // Kick of the delivery thread since we're decoupled
            }
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Otherwise, we wake up any potential clients waiting in
    // PullObjects
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    else if ( m_uForwardingType == forwarding_type_fast )
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // We dont want to wake up the client unless we have the
        // number of objects he/she requested OR a setstatus has
        // come through [CWmiFinalizer::SetStatus]
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( (pObj->m_objectType == CWmiFinalizerObj::object) )
        {
            for ( int i = 0; i < m_enumerators.Size ( ); i++ )
            {
                CWmiFinalizerEnumerator* pEnum = (CWmiFinalizerEnumerator*) m_enumerators[i] ;
                if ( ( pEnum->m_ulSemisyncWakeupCall != 0 ) && ( m_objects.Size() >= ( pEnum->m_ulSemisyncWakeupCall + pEnum->m_uCurObjectPosition ) ) )
                {
                    SetEvent ( pEnum->m_hWaitOnResultSet );
                    pEnum->m_ulSemisyncWakeupCall = 0;
                }
            }
        }
        else if ( (pObj->m_objectType == CWmiFinalizerObj::status) )
        {
            NotifyAllEnumeratorsOfCompletion ( ) ;
        }
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Now, lets throttle this thread since we have no control
        // of outbound flow
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        cs.Leave ( ) ;
        HRESULT hArb = m_pArbitrator->Throttle ( 0, m_phTask );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If the arbitrator returned CANCEL, we operation has been
        // cancelled and we need to stop:
        // 1. Threads potentially waiting in the enumerator
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( hArb == WBEM_E_ARB_CANCEL )
        {
            cs.Leave ( ) ;
            CancelTaskInternal ( );
            cs.Enter ( ) ;

            m_hStatus = QuotaViolation;
            NotifyAllEnumeratorsOfCompletion ( ) ;
            hRes = WBEM_E_QUOTA_VIOLATION;
        }
    }
    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::TriggerShutdown()
{
    if (m_uForwardingType == forwarding_type_decoupled)
    {
        //We need to queue up a shutdown request to the thread...
        CWmiFinalizerObj *pObj = new CWmiFinalizerObj(CWmiFinalizerObj::shutdown); // SEC:REVIEWED 2002-03-22 : Needs EH
        if (pObj == NULL) return WBEM_E_OUT_OF_MEMORY;

        return QueueOperation(pObj);
    }
    else
        ShutdownFinalizer();

    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::ShutdownFinalizer()
{
    return WBEM_NO_ERROR;
}



//****************************************************************************
// BuildTransmitBuffer ( )
// ~~~~~~~~~~~~~~~~~~~~~~~
//
// Works in two phases.
//
// 1. Quickly scans the object queue to get a count of the number of objects
// 2. Actually dequeueus the objects and builds the buffer
//            
//****************************************************************************
HRESULT CWmiFinalizer::BuildTransmitBuffer (  )
{
    HRESULT hRes = WBEM_NO_ERROR;
    ULONG   nBatchSize  = 0;
    ULONG    nBatchBytes = 0;
    ULONG    nTempAdd    = 0;
    m_ulAsyncDeliveryCount = 0;


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Lock the object queue while building the transmit buffer
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CInCritSec cs(&m_cs);   // SEC:REVIEWED 2002-03-22 : Assumes entry

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // PHASE 1
    // -------
    // Quickly scan through the object queue to get an object count
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    bool bBuildingBuffer = true;
    while ( bBuildingBuffer && nTempAdd < m_objects.Size() )
    {

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // First, we peek at the object. Dont want to dequeue anything that is not
        // deliverable in this batch
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        CWmiFinalizerObj *pFinObj;
        pFinObj = (CWmiFinalizerObj*) m_objects[m_uCurObjectPosition + nTempAdd];
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we get a NULL pointer back we should stop the batch count
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( pFinObj == NULL )
        {
            bBuildingBuffer = false;
            m_enumBatchStatus = FinalizerBatch_NoError;
            break;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Anything else BUT an object will break the batch count
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( pFinObj->m_objectType != CWmiFinalizerObj::object )
        {
            m_enumBatchStatus = FinalizerBatch_StatusMsg;
            break;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we have a NULL IWbemClassObject we should stop the batch count.
        // Actaully we should yell very loudly!
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        CWbemObject* pObj = (CWbemObject*) pFinObj->m_pObj;
        if ( pObj==NULL )
            RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::BuildTransmitBuffer: Queue contains NULL object!"), WBEM_E_INVALID_OPERATION);


        ULONG ulLen = pFinObj->m_uSize;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        // Check to see if we have reached the max batch size yet.
        // If so, we should break otherwise, update totals and continue
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // paulall - added check in case there is no object in queue and the current object
        //           is greater than the max size...
        if ((nBatchBytes != 0) && ((nBatchBytes+ulLen) > g_ulMaxBatchSize ))
        {
            m_enumBatchStatus = FinalizerBatch_BufferOverFlow;
            bBuildingBuffer = false;
            break;
        }

    
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        // No overflow, update the object count
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
        nBatchSize++;
        nBatchBytes+=ulLen;

        nTempAdd++;
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // PHASE 2
    // -------
    // Build the actual transmit buffer
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ULONG OldSize = m_ulAsyncDeliverySize;
    ULONG OldCount = m_ulAsyncDeliveryCount;
    
    m_ulQueueSize -= nBatchBytes;
    m_ulAsyncDeliverySize = nBatchBytes;
    m_ulAsyncDeliveryCount = nBatchSize;


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // If we have a batch to build, lets do it
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( m_ulAsyncDeliveryCount > 0 )
    {
        m_apAsyncDeliveryBuffer = new IWbemClassObject* [ m_ulAsyncDeliveryCount ];
        if ( m_apAsyncDeliveryBuffer )
        {
            memset(m_apAsyncDeliveryBuffer,0,sizeof(IWbemClassObject*)*m_ulAsyncDeliveryCount);
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Now, loop through the object queue and store the IWbemClassObject ptr
            // in the batch
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        
            for ( ULONG x = 0; x < m_ulAsyncDeliveryCount; x++ )
            {
                CWmiFinalizerObj *pObjTmp = 0;
                hRes = DequeueObject(&pObjTmp, NULL);
                if (FAILED(hRes) )
                {
                    RET_FNLZR_ASSERT(__TEXT("CWmiFinalizer::BuildTransmitBuffer, failed to dequeue object [heap corruption]!"), WBEM_E_FAILED);
                }
                
                m_apAsyncDeliveryBuffer [ x ] = pObjTmp->m_pObj;
                m_apAsyncDeliveryBuffer [ x ] -> AddRef();
                delete pObjTmp;
            }
        }
        else
        {
            m_ulQueueSize += nBatchBytes;
            m_ulAsyncDeliverySize = OldSize;
            m_ulAsyncDeliveryCount = OldCount;            
            hRes = WBEM_E_OUT_OF_MEMORY;
        }
    }
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Otherwise, we only got a status message.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    else
        hRes = WBEM_E_FAILED;
    
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::DeliverSingleObjFromQueue ( )
{
    
    HRESULT hRes = WBEM_S_NO_ERROR;
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Ensure destination sink is protected [stress bug]
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IWbemObjectSink* pTmp = ReturnProtectedDestinationSink();
    if ( !pTmp )
    {
        CancelCall (__LINE__);
        return WBEM_E_CALL_CANCELLED;
    }
    CReleaseMe myReleaseMe(pTmp);
    

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Retrieve the object from the object queue
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CWmiFinalizerObj* pObj = NULL;
    hRes = DequeueObject ( &pObj, NULL );
    if ( FAILED(hRes) || !pObj )
        hRes = WBEM_E_FAILED;

    else
    {
        if (pObj->m_objectType == CWmiFinalizerObj::object)
        {
            HANDLE hTimer;
            BOOL bStatus = CreateTimerQueueTimer ( &hTimer, NULL, ProxyThreshold, (PVOID) this, g_ulClientCallbackTimeout, 0,    WT_EXECUTEONLYONCE|WT_EXECUTEINTIMERTHREAD );
            if ( !bStatus )
            {
                DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
                delete pObj;
                return CancelCall(__LINE__);
            }
        
            
            if ( HasWriteOnlyProps (pObj->m_pObj) )
                ZapWriteOnlyProps (pObj->m_pObj);
            
            CWbemObject* pWbemObj = (CWbemObject*) pObj->m_pObj;
            m_ulQueueSize-=pWbemObj->GetBlockLength();

        
            IWbemClassObject * pObj_ = pObj->m_pObj;

            hRes = DoIndicate(pTmp, 1, &pObj_);

            
            // Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED from Indicate
            // We also want to cancel the call if the client is taking way too long to return
            if ( FAILED (hRes) || m_bCancelledCall == TRUE )
            {
                DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 );
                
                DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );    
                delete pObj;
                return CancelCall(__LINE__);
            }

            else
                DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );
        }
        else if (pObj->m_objectType == CWmiFinalizerObj::status)
        {
            // ATTGORA: What about the handle? When do we close it?
            HANDLE hTimer;
            BOOL bStatus = CreateTimerQueueTimer ( &hTimer, NULL, ProxyThreshold, (PVOID) this, g_ulClientCallbackTimeout, 0, WT_EXECUTEONLYONCE|WT_EXECUTEINTIMERTHREAD );
            if ( !bStatus )
            {
                DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
                delete pObj;
                return CancelCall(__LINE__);
            }


            hRes = DoSetStatus(pTmp, pObj->m_lFlags, pObj->m_hRes, pObj->m_bStr, pObj->m_pObj);

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED
            // from Indicate We also want to cancel the call if the client is taking way
            // too long to return
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if ( FAILED (hRes) || m_bCancelledCall == TRUE )
            {
                hRes = CancelCall(__LINE__);
            }
            
            DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );
            
            if (pObj->m_lFlags == WBEM_STATUS_COMPLETE)
            {

                {
                    CInCritSec lock(&m_destCS);   // SEC:REVIEWED 2002-03-22 : Assumes entry
                    if (m_pDestSink)
                    {
                            ReleaseDestinationSink ( ) ;
                            m_bSetStatusConsumed = true;
                            UpdateStatus ( WMI_FNLZR_STATE_CLIENT_COMPLETE );
                    }
                }
                CancelTaskInternal();
            }
        }

        delete pObj;
    }

    return hRes;
}




//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::DeliverBatch ( )
{
    HRESULT hRes = WBEM_NO_ERROR;
    

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Ensure destination sink is protected [stress bug]
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
    if ( !pTmp )
    {
        ZeroAsyncDeliveryBuffer ( );
        CancelCall(__LINE__);
        return WBEM_E_CALL_CANCELLED;
    }
    CReleaseMe myReleaseMe(pTmp);


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Create a timer queue in case we need to time out the call to the client
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    HANDLE hTimer;
    BOOL bStatus = CreateTimerQueueTimer ( &hTimer, NULL, ProxyThreshold, (PVOID) this, g_ulClientCallbackTimeout, 0, WT_EXECUTEONLYONCE|WT_EXECUTEINTIMERTHREAD );
    if ( !bStatus )
    {
        DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
        ZeroAsyncDeliveryBuffer ( );
        return CancelCall(__LINE__);            
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // If we have sensitive data, zap it.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for (int i = 0; i < m_ulAsyncDeliveryCount; i++)
    {
        if ( HasWriteOnlyProps (m_apAsyncDeliveryBuffer[i]) )
            ZapWriteOnlyProps (m_apAsyncDeliveryBuffer[i]);
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // DoIndicate to the client
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    hRes = DoIndicate ( pTmp, m_ulAsyncDeliveryCount, m_apAsyncDeliveryBuffer );

    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Client can also tell us to cancel a call by returning WBEM_E_CALL_CANCELLED
    // from Indicate We also want to cancel the call if the client is taking way
    // too long to return
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( FAILED (hRes) || m_bCancelledCall == TRUE )
    {
        DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 );
        hRes = CancelCall(__LINE__);
        InterlockedCompareExchange ( &m_lCurrentlyCancelling, TRUE, m_lCurrentlyCancelling);
    }
    
    

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Make sure timer queue is deleted
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    DeleteTimerQueueTimer (NULL, hTimer, INVALID_HANDLE_VALUE );
    

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Clean up the async delivery buffer
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ZeroAsyncDeliveryBuffer ( );
    
    return hRes;
}



/*
    * =====================================================================================================
    |
    | BOOL CWmiFinalizer::IsValidDestinationSink  ( )
    | -----------------------------------------------
    |
    | Returns TRUE if we have a valid destination sink, FALSE otherwise.
    |
    |
    * =====================================================================================================
*/

BOOL CWmiFinalizer::IsValidDestinationSink  ( )
{
    BOOL bIsValidDestinationSink = FALSE ;

    CInCritSec lock(&m_destCS);     // SEC:REVIEWED 2002-03-22 : Assumes entry
    
    if ( m_pDestSink  != NULL )
    {
        bIsValidDestinationSink = TRUE ;
    }

    return bIsValidDestinationSink  ;
}



/*
    * =====================================================================================================
    |
    | HRESULT CWmiFinalizer::NotifyClientOfCancelledCall ( )
    | ------------------------------------------------------
    |
    | If Client issued a CancelAsync call he/she is potentially waiting to be woken up once the delivery
    | of WBEM_E_CALL_CANCELLED is completed.
    |
    |
    * =====================================================================================================
*/

HRESULT CWmiFinalizer::NotifyClientOfCancelledCall ( )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    CInCritSec lock(&m_arbitratorCS);    // SEC:REVIEWED 2002-03-22 : Assumes entry
    if ( m_hWaitForSetStatus  )    
    {
        SetEvent ( m_hWaitForSetStatus ) ;
        m_hWaitForSetStatus = NULL ;
    }
    
    return hRes ;
}



/*
    * =====================================================================================================
    |
    | HRESULT CWmiFinalizer::CancelWaitHandle ( )
    | -------------------------------------------
    |
    | Cancels the handle the client may be waiting for in a CancelAsynCall. Clients _will_ wait for a final
    | SetStatus to be called before waking up.
    |
    |
    * =====================================================================================================
*/

HRESULT CWmiFinalizer::CancelWaitHandle ( )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    CInCritSec lock(&m_arbitratorCS);   // SEC:REVIEWED 2002-03-22 : Assumes entry
    if ( m_hWaitForSetStatus  )    
    {
        m_hWaitForSetStatus = NULL ;
    }
    
    return hRes ;
}


/*
    * =====================================================================================================
    |
    | HRESULT CWmiFinalizer::SetClientCancellationHandle ( HANDLE hCancelEvent )
    | --------------------------------------------------------------------------
    |
    | Sets the handle that the client is waiting for in case of a CancelAsyncCall.
    |
    * =====================================================================================================
*/

HRESULT CWmiFinalizer::SetClientCancellationHandle ( HANDLE hCancelEvent )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;

    CInCritSec lock(&m_arbitratorCS);    // SEC:REVIEWED 2002-03-22 : Assumes entry
    if ( m_hWaitForSetStatus == NULL )
    {
        m_hWaitForSetStatus = hCancelEvent ;    
    }

    return hRes ;
}




//***************************************************************************
// ATTGORA: Do we really need to tell a client that 'setstatus' or 'indicates'
// us for cancellation that we are cancelling?
//***************************************************************************
HRESULT CWmiFinalizer::CancelCall()
{
    CAutoSignal CancelCallSignal (m_hCancelEvent);
    
    HRESULT hRes;
    if ( InterlockedCompareExchange ( &m_bCancelledCall, 1, 0 ) == 0 )
    {
        hRes = WBEM_NO_ERROR;
        m_bCancelledCall = TRUE;


        //
        // Indicate the cancellation to the client, iff we are not cancelling
        // due to a naughty client (i.e a client that didnt return from
        // the indicate or setstatus call in a reasonable amount of time
        //
        if ( !m_bNaughtyClient )
        {
            //
            // Ensure destination sink is protected [stress bug]
            //
            IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
            if ( !pTmp )
            {
                    m_hStatus = CallCancelled;                    
                    NotifyAllEnumeratorsOfCompletion ( ) ;
                    CancelTaskInternal ( ) ;
                    return WBEM_NO_ERROR;
            }
            CReleaseMe myReleaseMe(pTmp);

            //
            // This is an async operation. Need to call setstatus on delivery thread
            // Hack: What we do is forcfully insert the setstatus message at the beginning
            // of the object queue. Two scenarios:
            //  1. If the async delivery thread is waiting, it will be woken up
            //  2. If the async delivery thread is delivering, the next object delivered
            //       will be the status msg.
            //
            CWmiFinalizerObj *pObj = new CWmiFinalizerObj(0, WBEM_E_CALL_CANCELLED, NULL, NULL);  // SEC:REVIEWED 2002-03-22 : Needs EH
            if (pObj == NULL)
            {
                DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY,0,0);
                SetOperationResult(0,WBEM_E_OUT_OF_MEMORY);
    	        m_hStatus = QueueFailure;
        	    NotifyAllEnumeratorsOfCompletion();                
                return WBEM_E_OUT_OF_MEMORY;
            }

            QueueOperation ( pObj );
            m_bSetStatusCalled = true;        
        }
        else
        {
            //
            // We have a client that is not being cooperative (not returning within 60s). BAD
            // BAD CLIENT!
            //
            // Try to push a SetStatus (WBEM_E_CALL_CANCELLED) through. Maybe they're not intentially
            // trying to be bad, perhaps they're just incompentent and not reading the docs !
            //
            IWbemObjectSink* pTmp = ReturnProtectedDestinationSink  ( );
            if ( !pTmp )
            {
                    m_hStatus = CallCancelled;                    
                    NotifyAllEnumeratorsOfCompletion ( ) ;
                    return WBEM_NO_ERROR;
            }
            CReleaseMe myReleaseMe(pTmp);

            //
            // This is the absolutely last attempt to notify the client that something
            // is going wrong. We dont care about the result of this operation since
            // we cant do anything about a failure anyway! More than likey, if this call
            // doesnt return the client has messed up again and we're done.
            //
            DoSetStatus ( pTmp, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0 ) ;
        }

        //
        // If we dont have a destination sink, who cares? Do some cleanup.
        // Tell the arbitrator to do some system wide clean up. This HAS TO
        // finish before we continue cleaning up, otherwise we could be destroying
        // sinks that are still considered active
        //
        hRes = CancelTaskInternal();
    }
    else
        hRes = WBEM_E_CALL_CANCELLED;

    m_hStatus = CallCancelled;    
    NotifyAllEnumeratorsOfCompletion ( ) ;
    return hRes;
}




//***************************************************************************
//
//***************************************************************************
VOID WINAPI CWmiFinalizer::ProxyThreshold ( PVOID pvContext, BOOLEAN bTimerOrWait )
{
    ((CWmiFinalizer*)pvContext)->ProxyThresholdImp();
}



//***************************************************************************
//
//***************************************************************************
VOID CWmiFinalizer::ProxyThresholdImp ( )
{
    RevertToSelf ( ) ;   // SEC:REVIEWED 2002-03-22 : Needs check

    UpdateStatus ( WMI_FNLZR_STATE_CLIENT_DEAD );
    ERRORTRACE((LOG_WBEMCORE, "Client did not return from a SetStatus or Indicate call within %d ms\n",g_ulClientCallbackTimeout));
    m_bNaughtyClient  = TRUE;
    CancelCall(__LINE__);
}


//***************************************************************************
//
//***************************************************************************


HRESULT CWmiFinalizer::PullObjects(
    long lTimeout,
    ULONG uCount,
    IWbemClassObject** apObjects,
    ULONG* puReturned,
    CWmiFinalizerEnumerator* pEnum,
    BOOL bAddToObjQueue,
    BOOL bSetErrorObj
    )
{
    HRESULT hr = WBEM_NO_ERROR;
    BOOL bTimeOutExpired = FALSE;

    if (pEnum == 0)
        return WBEM_E_INVALID_PARAMETER;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Has SetStatus already been consumed?
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (pEnum->m_bSetStatusConsumed)
    {
        try
        {
            *puReturned = 0;
        }
        catch (...) // untrusted param
        {
            ExceptionCounter c;        
            return WBEM_E_INVALID_PARAMETER;
        }

        return WBEM_S_FALSE;
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Now we want to loop until we recieved the number of
    // objects requested
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ULONG index = 0;
    while (index != uCount)
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Dequeue the object
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        CWmiFinalizerObj *pObj = NULL;
        hr = DequeueObject(&pObj, pEnum);
        if (hr == WBEM_S_FALSE )
        {
            if ( !bTimeOutExpired )
            {
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // If Dequeue returned FALSE it means
                // that there are no objects. We should
                // wait for them, unless we have been
                // told to cancel or we have been
                // released
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                if ( m_hStatus == CallCancelled )
                {
                    hr = WBEM_E_CALL_CANCELLED;
                    break ;
                }
                else if ( m_hStatus == RequestReleased )
                {
                    hr = WBEM_E_FAILED;
                    break;
                }
                else if ( m_hStatus == QuotaViolation )
                {
                    hr = WBEM_E_QUOTA_VIOLATION;
                    break;
                }
                else if (QueueFailure == m_hStatus)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                //Wait for another object to come in...
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                DWORD dwRet = CCoreQueue::QueueWaitForSingleObject(pEnum->m_hWaitOnResultSet, lTimeout);
                if (dwRet == WAIT_TIMEOUT)
                {
                    bTimeOutExpired = TRUE;
                    continue;
                }
                else if ( m_hStatus == CallCancelled )
                {
                    hr = WBEM_E_CALL_CANCELLED;
                    break ;
                }
                else if ( m_hStatus == RequestReleased )
                {
                    hr = WBEM_E_FAILED;
                    break;
                }
                else if ( m_hStatus == QuotaViolation )
                {
                    hr = WBEM_E_QUOTA_VIOLATION;
                    break;
                }
                else if (QueueFailure == m_hStatus)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }                
                else
                    continue;
            }
            else
            {
                hr = WBEM_S_TIMEDOUT;
                break;
            }
        }
        if (FAILED(hr))
            break;

        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we recieved a status complete message, simply break out of
        // the loop
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ((pObj->m_objectType == CWmiFinalizerObj::status) && (pObj->m_lFlags == WBEM_STATUS_COMPLETE))
        {
            // Fix for: 175856, 143550
            if ( bSetErrorObj && FAILED (pObj->m_hRes) && pObj->m_pObj )
            {
                m_pCallResult->SetErrorInfo ( );     // SEC:REVIEWED 2002-03-22 : Needs EH
            }

            
            hr = pObj->m_hRes;
            if (SUCCEEDED ( hr ) )
                hr = WBEM_S_FALSE;
            pEnum->m_bSetStatusConsumed = true;
            
            delete pObj;
            break;
        }


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If its a status message
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else if (pObj->m_objectType == CWmiFinalizerObj::status  )
        {
            delete pObj;
            continue;
        }


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If its an object we enqueue it if requested
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        else if (pObj->m_objectType == CWmiFinalizerObj::object)
        {
            if ( bAddToObjQueue )
            {
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                // Make sure we dont trip on nasty client supplied buffers
                // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                try
                {
                    apObjects[index] = pObj->m_pObj;
                    if (apObjects[index])
                    {
                        pObj->m_pObj->AddRef();
                    }
                }
                catch (...) // untrusted args
                {
                    ExceptionCounter c;                
                    hr = WBEM_E_INVALID_PARAMETER;
                    delete pObj;
                    break;
                }
            }
            delete pObj;
        }
        else
        {
            if ( pObj )
            {
                delete pObj;
            }
        }
        index ++;
    }

    if (SUCCEEDED(hr))
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Make sure we dont trip on nasty client supplied buffers
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
        {
            *puReturned = index;
        }
        catch (...) // untrusted args
        {
            ExceptionCounter c;
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // need to release all the objects already in the array otherwise they will be leaked...
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if ( bAddToObjQueue )
            {
                for (DWORD i = 0; i != index; i++)
                {
                    if (apObjects[i])
                        apObjects[i]->Release();
                }
            }
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // If we fail, clean up the obj array
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    else
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // need to release all the objects already in the array otherwise they will be leaked...
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( bAddToObjQueue )
        {
            for (DWORD i = 0; i != index; i++)
            {
                if (apObjects[i])
                    apObjects[i]->Release();   // SEC:REVIEWED 2002-03-22 : Needs EH
            }
        }
    }

    return hr;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::DequeueObject( CWmiFinalizerObj **ppObj, CWmiFinalizerEnumerator* pEnum )
{
    CInCritSec cs(&m_cs);   // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( pEnum != NULL )
    {
        if (pEnum->m_uCurObjectPosition >= (ULONG)m_objects.Size())
            return WBEM_S_FALSE;

        ULONG lIndex = pEnum->m_uCurObjectPosition ;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If this is a semisync call we should decrement the wake up call
        // flag
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( m_ulOperationType == Operation_Type_Semisync && pEnum->m_ulSemisyncWakeupCall != 0 )
        {
            pEnum->m_ulSemisyncWakeupCall--;
        }

        if ( m_bSetStatusWithError && m_bRestartable )
        {
            lIndex = 0 ;
        }

        
        CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[lIndex];

        if (m_bRestartable)
        {
            //We have to hold on to results, so increment cursor position...
            pEnum->m_uCurObjectPosition++;

            *ppObj = new CWmiFinalizerObj(*pStorageObject);  // SEC:REVIEWED 2002-03-22 : Needs EH
            if (*ppObj == NULL)                              // SEC:REVIEWED 2002-03-22 : Needs EH
                return WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            //We are not restartable, therefore we need to release everything...
            CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[0];
            m_objects.RemoveAt(0);
            *ppObj = pStorageObject;
        }
    }
    else
    {
        if ( m_uCurObjectPosition >= (ULONG)m_objects.Size() )
            return WBEM_S_FALSE;


        CWmiFinalizerObj *pStorageObject = (CWmiFinalizerObj*)m_objects[0];

        m_objects.RemoveAt(0);
        *ppObj = pStorageObject;  // SEC:REVIEWED 2002-03-22 : Needs EH
    }
    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::Skip(
    /*[in]*/ long lTimeout,
    /*[in]*/ ULONG nCount,
    /*[in]*/ CWmiFinalizerEnumerator* pEnum
    )
{
    ULONG uReturned = 0;
    return PullObjects(lTimeout, nCount, NULL, &uReturned, pEnum, FALSE);
}



//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::NextAsync ( CWmiFinalizerEnumerator* pEnum )
{
    BOOL bRes;

    if (pEnum == 0)
        return WBEM_E_FAILED;

    wmilib::auto_ptr<InsertableEvent> pInsert( new InsertableEvent);
    if (NULL == pInsert.get()) return WBEM_E_OUT_OF_MEMORY;

    pInsert->pEnum = pEnum;
    pInsert->ThreadId = 0;    
    pEnum->Add_NextAsync(pInsert.get());    
    
    bRes = QueueUserWorkItem ( pEnum->ThreadBootstrapNextAsync, pInsert.get(), WT_EXECUTEDEFAULT );
    if ( !bRes )
    {
        pEnum->Remove_NextAsync(pInsert.release()); // let the Remove function to delete the LIST_ENTRY
        pEnum->SetCompletionSignalEvent();
        return WBEM_E_FAILED;
    }

    pInsert.release(); // the WorkItem took possession at this point
    
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::SetSinkToIdentity ( IWbemObjectSink* pSink )
{
    HRESULT sc;

    // SEC:REVIEWED 2002-03-22 : Assumes valid pSink.  Needs EH in case it is garbage.

    IClientSecurity * pFromSec = NULL;
    sc = pSink->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);
    if(sc == S_OK)
    {
        OLECHAR * pPrincipal = NULL;
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
        sc = pFromSec->QueryBlanket(pSink, &dwAuthnSvc, &dwAuthzSvc,
                                            &pPrincipal,
                                            &dwAuthnLevel, &dwImpLevel,
                                            NULL, &dwCapabilities);
        if ( sc==S_OK )
        {
            sc = pFromSec->SetBlanket(pSink, dwAuthnSvc, dwAuthzSvc,
                                                pPrincipal,
                                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
						RPC_C_IMP_LEVEL_IDENTIFY,    // We always call back on System and IDENTITY IMP LEVEL!!!
                                                NULL, dwCapabilities);
            if(pPrincipal)
                CoTaskMemFree(pPrincipal);

        }

        pFromSec->Release();
    }
    return sc;
}



//***************************************************************************
//
//  ZapWriteOnlyProps
//
//  Removes write-only properties from an object.
//  Precondition: Object has been tested for presence of "HasWriteOnlyProps"
//  on the object itself.
//
//***************************************************************************
HRESULT CWmiFinalizer::ZapWriteOnlyProps(IWbemClassObject *pObj)
{
    if (pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_NULL;

    SAFEARRAY *pNames = 0;
    pObj->GetNames(L"WriteOnly", WBEM_FLAG_ONLY_IF_TRUE, 0, &pNames);    // SEC:REVIEWED 2002-03-22 : Assumes success
    LONG lUpper;
    SafeArrayGetUBound(pNames, 1, &lUpper);

    for (long i = 0; i <= lUpper; i++)
    {
        BSTR strName = 0;
        SafeArrayGetElement(pNames, &i, &strName);
        pObj->Put(strName, 0, &v, 0);
        SysFreeString (strName);
    }
    SafeArrayDestroy(pNames);
    VariantClear (&v);

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  HasWriteOnlyProps
//
//  Returns TRUE if object contains any Write only props, otherwise FALSE
//
//***************************************************************************
BOOL CWmiFinalizer::HasWriteOnlyProps ( IWbemClassObject* pObj )
{
    BOOL bRes;
    if (pObj == 0) return FALSE;

    IWbemQualifierSet *pQSet = 0;
    HRESULT hRes = pObj->GetQualifierSet(&pQSet);
    if (FAILED(hRes))
        return FALSE;

    hRes = pQSet->Get(L"HasWriteOnlyProps", 0, 0, 0);
    if (SUCCEEDED(hRes))
        bRes = TRUE;
    else
        bRes = FALSE;

    pQSet->Release();
    return bRes;
}

//***************************************************************************
//
//  DoSetStatus
//
//  Using LowerAuthLevel
//
//***************************************************************************
HRESULT CWmiFinalizer::DoSetStatusCancel(IWbemObjectSink * pSink, HRESULT realError )
{
	IWbemClassObject * objParam;
	
    try
    {
        CErrorObject Error(0);
        Error.SetStatusCode(realError);
        objParam = Error.GetObject();
    }
    catch ( CX_Exception & )
    {
    }
    HRESULT hr = DoSetStatus(pSink, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, objParam);
    if (objParam) objParam->Release();
    return hr;
}


//***************************************************************************
//
//  DoSetStatus
//
//  Using LowerAuthLevel
//
//***************************************************************************
HRESULT CWmiFinalizer::DoSetStatus(IWbemObjectSink * psink, long lFlags, HRESULT lParam, BSTR strParam,
                    IWbemClassObject* pObjParam, BOOL bAllowMultipleCalls )
{
    HRESULT hres = WBEM_E_FAILED;

    //
    // In the case of NextAsync we will in fact allow multiple calls to DoSetStatus
    //
    if ( ( bAllowMultipleCalls == FALSE ) && ( lFlags == WBEM_STATUS_COMPLETE ) )
    {
        //
        // If a setstatus has already been delivered, fail this operation
        // This is a must since we support the CancelAsynCall in which case
        // there is potential for 2 setstatus msg to be enqueued.
        //
        {
            CCheckedInCritSec cs ( &m_cs ) ;    // SEC:REVIEWED 2002-03-22 : Assumes entry
        
            if ( m_bSetStatusDelivered == TRUE )
            {
                //
                // If a SetStatus has already been delivered (in non-error cases, i.e. not via client cancellation)
                // we still may want to try and wake up the client since they may have tried to enter a cancellation
                // wait state.
                //
                cs.Leave ( ) ;
                NotifyClientOfCancelledCall ( ) ;
                return hres ;
            }
            else
            {
                //
                // We assume that the delivery will be successfull. If its not, we dont
                // want to try again anyway.
                //
                m_bSetStatusDelivered = TRUE ;
            }
        }
    }

    
    DWORD    dwLastAuthnLevel = LOWER_AUTH_LEVEL_NOTSET;
    // put this a loop, but use the counter to make sure there is always an exit.
    for(int i = 0; i < 10; i ++)
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Make sure bad client sink does not trip us
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
        {
            hres = psink->SetStatus(lFlags, lParam, strParam, pObjParam);
        }
        catch (...) // untrusted sink
        {
            ExceptionCounter c;        
            hres = WBEM_E_INVALID_PARAMETER;
            break;
        }

        if(!FAILED(hres))
        {
            break ;        // all done, normal exit
        }

        if ( hres != E_ACCESSDENIED && 
        	HRESULT_CODE(hres) != RPC_S_SERVER_TOO_BUSY &&			// When the target is Win9x and 
        	HRESULT_CODE(hres) != RPC_S_UNKNOWN_AUTHN_SERVICE)	// the level is above connect
        															// DFS patch not applied
            break;

        hres = FinalizerLowerAuthLevel(psink, &dwLastAuthnLevel);
        if(FAILED(hres))
            break;
    }
    if ( FAILED (hres) )
    {
        ERRORTRACE((LOG_WBEMCORE, "Could not SetStatus to remote client, hres =%X\n",hres));
    }

    if ( lParam == WBEM_E_CALL_CANCELLED )
    {
        NotifyClientOfCancelledCall ( ) ;
    }

    if ( lFlags == WBEM_STATUS_COMPLETE && bAllowMultipleCalls == FALSE )
    {
        NotifyClientOfCancelledCall ( ) ;
        CancelTaskInternal ( ) ;
    }

    return hres;
}



//***************************************************************************
//
//  DoSetIndicate
//
//  Using LowerAuthLevel
//
//***************************************************************************
HRESULT CWmiFinalizer::DoIndicate(IWbemObjectSink * psink, int nBatchSize, IWbemClassObject **pBatch)
{
    HRESULT hres = WBEM_E_FAILED;
    DWORD    dwLastAuthnLevel = LOWER_AUTH_LEVEL_NOTSET;

    // put this a loop, but use the counter to make sure there is always an exit.
    for(int i = 0; i < 10; i ++)
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Make sure bad client sink does not trip us
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
        {
            hres = psink->Indicate(nBatchSize, pBatch);
        }
        catch (...) // untrusted sink
        {
            ExceptionCounter c;        
            hres = WBEM_E_INVALID_PARAMETER;
            break;
        }
        if(!FAILED(hres))
        {
            return hres;        // all done, normal exit
        }

        if ( hres != E_ACCESSDENIED &&
        	HRESULT_CODE(hres) != RPC_S_SERVER_TOO_BUSY &&			// When the target is Win9x and 
        	HRESULT_CODE(hres) != RPC_S_UNKNOWN_AUTHN_SERVICE)	// the level is above connect
            break;
                
        hres = FinalizerLowerAuthLevel(psink, &dwLastAuthnLevel);
        if(FAILED(hres))
            break;
    }
    ERRORTRACE((LOG_WBEMCORE, "Could not Indicate to remote client, hres %X\n",hres));
    return hres;
}


//***************************************************************************
//
//  LowerAuth.
//
//  Using LowerAuthLevel
//
//***************************************************************************

HRESULT CWmiFinalizer::FinalizerLowerAuthLevel(IWbemObjectSink * psink, DWORD* pdwLastAuthnLevel )
{
    IClientSecurity * pFromSec = NULL;
    SCODE sc;

    try
    {
       sc = psink->QueryInterface(IID_IClientSecurity, (void **) &pFromSec);  // SEC:REVIEWED 2002-03-22 : Assumes entry
    }
    catch(...)
    {
       sc = WBEM_E_INVALID_PARAMETER;
    }

    if(sc == S_OK)
    {
        OLECHAR * pPrincipal = NULL;
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCapabilities;
        sc = pFromSec->QueryBlanket(psink, &dwAuthnSvc, &dwAuthzSvc,
                                            &pPrincipal,
                                            &dwAuthnLevel, &dwImpLevel,
                                            NULL, &dwCapabilities);

        // If we have never retrieved the authentication level before, then we
        // should record what it currently is
        if ( LOWER_AUTH_LEVEL_NOTSET == *pdwLastAuthnLevel )
        {
            *pdwLastAuthnLevel = dwAuthnLevel;
        }

        if (FAILED(sc))
            return sc;
        if(*pdwLastAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
            return WBEM_E_FAILED;
         (*pdwLastAuthnLevel)--;      // normal case is to try one lower

        sc = pFromSec->SetBlanket(psink, dwAuthnSvc, dwAuthzSvc,
                                            pPrincipal,
                                            *pdwLastAuthnLevel, RPC_C_IMP_LEVEL_IDENTIFY,    // We always call back on System and IDENTITY IMP LEVEL!!!
                                            NULL, dwCapabilities);
        if(pPrincipal)
            CoTaskMemFree(pPrincipal);
        pFromSec->Release();

    }
    return sc;
}



//***************************************************************************
//
//  ZeroAsyncDeliveryBuffer
//
//  Clears out the async delivery buffer
//
//***************************************************************************
VOID CWmiFinalizer::ZeroAsyncDeliveryBuffer ( )
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Delete the object array
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for ( ULONG i = 0; i < m_ulAsyncDeliveryCount; i++ )
    {
        m_apAsyncDeliveryBuffer[i]->Release();          // SEC:REVIEWED 2002-03-22 : Needs check for NULLness or EH
    }
    delete [] m_apAsyncDeliveryBuffer;
    m_ulAsyncDeliveryCount = 0;
    m_ulAsyncDeliverySize = 0;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizer::DumpDebugInfo (
        /*[in]*/ ULONG uFlags,
        /*[in]*/ const BSTR strFile
        )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizer::Shutdown(
        /*[in]*/ LONG uReason,
        /*[in]*/ ULONG uMaxMilliseconds,
        /*[in]*/ IWbemContext *pCtx)
{
    wmilib::auto_buffer<IUnknown *> ppEnums;
    DWORD Len;
    {
        CInCritSec lock( &m_cs ) ;    // SEC:REVIEWED 2002-03-22 : Assumes entry

        Len = m_enumerators.Size();
        ppEnums.reset(new IUnknown * [Len]);
        if (NULL == ppEnums.get()) return WBEM_E_OUT_OF_MEMORY;
        for (DWORD i = 0;i<Len;i++)
        {
            ppEnums[i] = (IUnknown *)m_enumerators[i];
            ppEnums[i]->AddRef();
        }
    }

    for (DWORD i = 0;i<Len;i++)
    {
        IUnknown * p = ppEnums[i];
    
        IWbemWCOSmartEnum * pSmartEnum = NULL;
        if (SUCCEEDED(p->QueryInterface(IID_IWbemWCOSmartEnum,(void **)&pSmartEnum)))
        {
            CoDisconnectObject(pSmartEnum,0);
            pSmartEnum->Release();
        }
        IWbemFetchSmartEnum * pFetch = NULL;
        if (SUCCEEDED(p->QueryInterface(IID_IWbemFetchSmartEnum,(void **)&pFetch)))
        {
            CWmiFinalizerEnumerator * pEnum = (CWmiFinalizerEnumerator *)(void *)p;    
            if (pEnum->HasSmartEnum() && SUCCEEDED(pFetch->GetSmartEnum(&pSmartEnum)))
            {
                CoDisconnectObject(pSmartEnum,0);
                pSmartEnum->Release();
            }
            pFetch->Release();
        }    
           CoDisconnectObject(p,0);    
           p->Release();
    }
    return S_OK;
}



/*
    * ==================================================================================================
    |
    | HRESULT CWmiFinalizer::NotifyAllEnumeratorsOfCompletion ( )
    | -----------------------------------------------------------
    |
    |
    |
    * ==================================================================================================
*/
HRESULT CWmiFinalizer::NotifyAllEnumeratorsOfCompletion ( )
{
    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec _cs ( &m_cs );    // SEC:REVIEWED 2002-03-22 : Assumes entry
    
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    for ( int i = 0; i < m_enumerators.Size ( ); i++ )
    {
        CWmiFinalizerEnumerator* pEnum = (CWmiFinalizerEnumerator*) m_enumerators[i] ;
        if ( pEnum )
        {
            SetEvent ( pEnum->m_hWaitOnResultSet );
        }
    }

    return hRes ;
}


/*
    * ==================================================================================================
    |
    | HRESULT CWmiFinalizer::UnregisterEnumerator ( CWmiFinalizerEnumerator* pEnum )
    | ------------------------------------------------------------------------------
    |
    |
    |
    * ==================================================================================================
*/
HRESULT CWmiFinalizer::UnregisterEnumerator ( CWmiFinalizerEnumerator* pEnum )
{
    //
    // Cocked, Locked, and ready to Rock
    //
    CInCritSec _cs ( &m_cs );   // SEC:REVIEWED 2002-03-22 : Assumes entry
    
    HRESULT hRes = WBEM_S_NO_ERROR ;
    
    for ( int i = 0; i < m_enumerators.Size ( ); i++ )
    {
        CWmiFinalizerEnumerator* pEnumerator = (CWmiFinalizerEnumerator*) m_enumerators[i] ;
        if ( pEnum == pEnumerator )
        {
            pEnumerator->InternalRelease ( ) ;
            m_enumerators.RemoveAt ( i ) ;
            break ;
        }
    }
    return hRes ;
}


//***************************************************************************
//
//***************************************************************************
void CWmiFinalizer::Dump(FILE* f)
{
    fprintf(f, "--Finalizer Stats---\n");   // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "  s_Finalizer_ObjectCount             = %d\n", s_Finalizer_ObjectCount);  // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "  s_FinalizerCallResult_ObjectCount   = %d\n", s_FinalizerCallResult_ObjectCount);        // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "  s_FinalizerEnum_ObjectCount         = %d\n", s_FinalizerEnum_ObjectCount);              // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "  s_FinalizerEnumSink_ObjectCount     = %d\n", s_FinalizerEnumSink_ObjectCount);          // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "  s_FinalizerInBoundSink_ObjectCount  = %d\n\n", s_FinalizerInBoundSink_ObjectCount);     // SEC:REVIEWED 2002-03-22 : OK
}


// ==========================================================================
// ==========================================================================
//                    CWmiFinalizerInboundSink
// ==========================================================================
// ==========================================================================




//***************************************************************************
//
//***************************************************************************
CWmiFinalizerInboundSink::CWmiFinalizerInboundSink(CWmiFinalizer *pFinalizer)
: m_lRefCount(0), m_lInternalRefCount (0),m_pFinalizer(pFinalizer), m_bSetStatusCalled(false)
{
    InterlockedIncrement ( & s_FinalizerInBoundSink_ObjectCount ) ;

    m_pFinalizer->AddRef();
    gClientCounter.AddClientPtr(&m_Entry);    
}

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerInboundSink::~CWmiFinalizerInboundSink()
{
    InterlockedDecrement ( & s_FinalizerInBoundSink_ObjectCount ) ;
    gClientCounter.RemoveClientPtr(&m_Entry);    
}

//***************************************************************************
//
//***************************************************************************

void CWmiFinalizerInboundSink::CallBackRelease ()
{
    if (!m_bSetStatusCalled)
    {
        //FNLZR_ASSERT(__TEXT("CWmiFinalizerInboundSink::~CWmiFinalizerInboundSink - Released sink without calling SetStatus!  Sending WBEM_E_FAILED to client!"), WBEM_E_INVALID_OPERATION);
        m_pFinalizer->SetStatus(0, WBEM_E_UNEXPECTED, NULL, NULL);
        ERRORTRACE((LOG_WBEMCORE, "Finalizer: Sink released without SetStatus being called\n"));
    }
    m_pFinalizer->UnregisterInboundSink(this);
    m_pFinalizer->Release();
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
     // SEC:REVIEWED 2002-03-22 : Should we wrap this in EH?  <ppvObj> may point to garbage or be NULL
    *ppvObj = 0;

    if ((IID_IUnknown==riid) || (IID_IWbemObjectSink == riid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::AddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lRefCount);    
    if ( uNewCount == 1 )
    {
        InternalAddRef () ;
    }    

//    printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
//    printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    if (0 == uNewCount)
    {
        CallBackRelease () ;

        InternalRelease () ;
    }

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************

ULONG CWmiFinalizerInboundSink::InternalAddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
//    printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    return uNewCount;
}


//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerInboundSink::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
//    printf("CWmiFinalizerInboundSink::Release: 0x%p", this);
    if (0 == uNewCount)
    {
        delete this ;
    }

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::Indicate(
    /*[in]*/ long lObjectCount,
    /*[in, size_is(lObjectCount)]*/
        IWbemClassObject** apObjArray
    )
{
    // If someone is trying to indicate NULL objects, reject and return WBEM_E_INVALID_PARAMETER
    if ( apObjArray == NULL )
        return WBEM_E_INVALID_PARAMETER;
    
    // Update status variable to show that indicate has been called at least once
    m_pFinalizer->UpdateStatus ( WMI_FNLZR_STATE_ACTIVE );
    
    // Special case: Call has been cancelled.
    if ( m_pFinalizer->IsCallCancelled() )
        return WBEM_E_CALL_CANCELLED;

    return m_pFinalizer->Indicate(lObjectCount, apObjArray);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::SetStatus(
    /*[in]*/ long lFlags,
    /*[in]*/ HRESULT hResult,
    /*[in]*/ BSTR strParam,
    /*[in]*/ IWbemClassObject* pObjParam
    )
{
    // Update status variable to show that SetStatus has been called but not yet delivered
    // to client
    m_pFinalizer->UpdateStatus ( WMI_FNLZR_STATE_CORE_COMPLETE );
    
    // Special case: Call has been cancelled.
    if ( m_pFinalizer->IsCallCancelled() )
        return WBEM_E_CALL_CANCELLED;

    if (lFlags == WBEM_STATUS_COMPLETE)
    {
        m_bSetStatusCalled = true;
    }
    return m_pFinalizer->SetStatus(lFlags, hResult, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerInboundSink::Set(
    /*[in]*/ long lFlags,
    /*[in]*/ REFIID riid,
    /*[in, iid_is(riid)]*/ void *pComObject
    )
{
#ifdef DBG
    DebugBreak();
#endif 
    return WBEM_E_NOT_SUPPORTED;
}






//***************************************************************************
//
//***************************************************************************
CWmiFinalizerEnumerator::CWmiFinalizerEnumerator(CWmiFinalizer *pFinalizer )
:
    m_lRefCount(0),
    m_lInternalRefCount(0),
    m_pFinalizer(pFinalizer),
    m_ulCount(0),
    m_pDestSink (NULL),
    m_hSignalCompletion (NULL),
    m_pSec (NULL),
    m_XSmartEnum( this ),
    m_pEnumMarshal (NULL)
{
    //
    // Cloning fix. We need to keep the state of the enumerator.
    // This means keeping individual wait event as well as object
    // position
    //
    m_hWaitOnResultSet = CreateEvent(NULL, FALSE, FALSE, NULL);  
    if (NULL == m_hWaitOnResultSet) throw CX_MemoryException();
    
    m_uCurObjectPosition = 0 ;
    m_ulSemisyncWakeupCall = 0 ;
    m_bSetStatusConsumed = FALSE ;

    InterlockedIncrement ( &s_FinalizerEnum_ObjectCount ) ;    

    m_pFinalizer->AddRef();
    InitializeListHead(&m_HeadNextAsync);    
    gClientCounter.AddClientPtr(&m_Entry);
}

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerEnumerator::~CWmiFinalizerEnumerator()
{
    InterlockedDecrement ( & s_FinalizerEnum_ObjectCount ) ;
    
    if ( m_hSignalCompletion )
    {
        CloseHandle (m_hSignalCompletion);
        m_hSignalCompletion = NULL;
    }
        
    CloseHandle ( m_hWaitOnResultSet ) ;
    m_hWaitOnResultSet = NULL ;

    IUnknown * pUnk = (IUnknown *)InterlockedCompareExchangePointer((PVOID *)&m_pEnumMarshal,0,m_pEnumMarshal);
    if (pUnk) pUnk->Release();
    
    gClientCounter.RemoveClientPtr(&m_Entry);    
}

void CWmiFinalizerEnumerator::CallBackRelease ()
{
    m_pFinalizer->SetInternalStatus ( CWmiFinalizer::QueueStatus::RequestReleased );
    m_pFinalizer->CancelTaskInternal();
    m_pFinalizer->UnregisterEnumerator ( this ) ;

    SetEvent ( m_hWaitOnResultSet ); // in case Cancel did not do it

    m_clientLock.Enter();
    while (!IsListEmpty(&m_HeadNextAsync))
    {
        m_clientLock.Leave();        
        Sleep(100);
        m_clientLock.Enter();
    }
    m_clientLock.Leave();    

    m_pFinalizer->Release();
    m_pFinalizer = NULL;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::AddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
    if ( uNewCount == 1 )
    {
        InternalAddRef () ;
    }

//    printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
//    printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    if (0 == uNewCount)
    {
        _DBG_ASSERT(2 == m_lInternalRefCount);
        CallBackRelease () ;
        InternalRelease () ;
    }

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::InternalAddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
//    printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerEnumerator::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
//    printf("CWmiFinalizerCallResult::Release: 0x%p", this);
    if (0 == uNewCount)
    {
        delete this ;
    }

    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (NULL == ppvObj) return E_POINTER;
    
   
      // Added support for IID_IWbemFetchSmartEnum
      if ((IID_IUnknown==riid) || (IID_IEnumWbemClassObject==riid) )
      {
          *ppvObj = this;
          AddRef();
          return NOERROR;
      }
      else if ( IID_IWbemFetchSmartEnum == riid )
        {
         *ppvObj = (IWbemFetchSmartEnum*) this;
         AddRef();
         return NOERROR;
      }
      {
         *ppvObj = 0;
        return E_NOINTERFACE;
      }
}


void CWmiFinalizerEnumerator::Add_NextAsync(InsertableEvent * pInsert)
{
    CInCritSec ics(&m_clientLock);
    InsertTailList(&m_HeadNextAsync,&pInsert->m_Entry);
}

void CWmiFinalizerEnumerator::Remove_NextAsync(InsertableEvent * pInsert)
{
    CInCritSec ics(&m_clientLock);
    RemoveEntryList(&pInsert->m_Entry);
    delete pInsert;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Reset()
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    BOOL bDidIWait = FALSE;

    if (InterlockedCompareExchangePointer(&m_hSignalCompletion,m_hSignalCompletion,0))
    {
            CCoreQueue::QueueWaitForSingleObject(m_hSignalCompletion, INFINITE);        
            bDidIWait = TRUE;        
    }
        
    CInCritSec cs(&m_clientLock);   // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( m_pFinalizer->IsRestartable ( ) )
    {
        m_uCurObjectPosition = 0;
        m_bSetStatusConsumed = false;
        if (bDidIWait) SetCompletionSignalEvent();
        return WBEM_NO_ERROR;
    }
    else
    {
        if (bDidIWait) SetCompletionSignalEvent();
        return WBEM_E_INVALID_OPERATION;
    }
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Next(
    /*[in]*/  long lTimeout,
    /*[in]*/  ULONG uCount,
    /*[out, size_is(uCount), length_is(*puReturned)]*/ IWbemClassObject** apObjects,
    /*[out]*/ ULONG* puReturned
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    CInCritSec cs(&m_clientLock);    // SEC:REVIEWED 2002-03-22 : Assumes entry
    if ( ( puReturned == NULL ) || ( apObjects == NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }
    if ( uCount == 0 )
    {
        return WBEM_S_NO_ERROR;
    }

    *puReturned = 0 ;
    m_ulSemisyncWakeupCall = uCount ;
    return m_pFinalizer->PullObjects(lTimeout, uCount, apObjects, puReturned, this );
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::NextAsync(
    /*[in]*/  ULONG uCount,
    /*[in]*/  IWbemObjectSink* pSink
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    // If delivery sink is NULL
    if ( pSink == NULL )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }

    // If requested count is 0
    if ( uCount == 0 )
    {
        return WBEM_S_FALSE;
    }

    HRESULT hRes;

    if ( m_hSignalCompletion == NULL )
    {
        HANDLE hTmpEvent = CreateEvent ( NULL, FALSE, TRUE, NULL );
        if (NULL == hTmpEvent) return WBEM_E_FAILED;
        if (InterlockedCompareExchangePointer(&m_hSignalCompletion,hTmpEvent,NULL))
        {
            CloseHandle(hTmpEvent);
        }
    }

    if ( m_pFinalizer->GetInternalStatus() != m_pFinalizer->NoError )
        return WBEM_E_FAILED;

    CCoreQueue::QueueWaitForSingleObject(m_hSignalCompletion, INFINITE);
    
    if ( m_pFinalizer->GetInternalStatus() != m_pFinalizer->NoError )
    {
        // Dont forget to wake up any other threads waiting!
        SetCompletionSignalEvent();
        return WBEM_E_FAILED;
    }

    if ( m_bSetStatusConsumed )
    {
        m_pFinalizer->SetSinkToIdentity ( pSink );
        m_pFinalizer->DoSetStatus ( pSink, WBEM_STATUS_COMPLETE, m_pFinalizer->GetFinalResult ( ), 0, 0 );
        SetCompletionSignalEvent();
        return WBEM_S_FALSE ;
    }

    // If we are already done.
    m_pDestSink = pSink;
    m_pDestSink->AddRef();   // SEC:REVIEWED 2002-03-22 : Needs EH in case sink is garbage
    m_ulCount = uCount;
    m_pFinalizer->SetSinkToIdentity ( m_pDestSink );

    return m_pFinalizer->NextAsync (this);
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiFinalizerEnumerator::_NextAsync ( )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    DWORD dwRet;

    RevertToSelf ( );   // SEC:REVIEWED 2002-03-22 : Needs check
    
    // Grab the client lock. All remainding ::NextAsync calls will be queued up
    CInCritSec cs(&m_clientLock);     // SEC:REVIEWED 2002-03-22 : Assumes entry
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Is the operation complete? If so, we should notify the sink
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if ( m_bSetStatusConsumed )
    {
        HRESULT hFinalRes;
        m_pFinalizer->GetOperationResult ( 0, INFINITE, &hFinalRes );
        m_pFinalizer->DoSetStatus ( m_pDestSink, WBEM_STATUS_COMPLETE, hFinalRes, 0, 0 );
        hRes = WBEM_S_FALSE;
    }
    
    else
    {
        // NOTE [marioh] : This is no longer needed since we've decided to go with the Win2k solution
        // for the time being.
        // If we fail to impersonate, we dont continue!!!!
        //CAutoRevert AutoRevert (m_pFinalizer);
        //if ( AutoRevert.IsImpersonated() == FALSE )
        //    return WBEM_E_CRITICAL_ERROR;


        IWbemClassObject **pArray = new IWbemClassObject *[m_ulCount];
        if (pArray == NULL)
        {
            m_pFinalizer->DoSetStatus ( m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_E_OUT_OF_MEMORY, 0, 0 );
        }

        else
        {
            ULONG uReturned = 0;
            
            m_pFinalizer->SetSemisyncWakeupCall (m_ulCount);
            HRESULT hr = m_pFinalizer->PullObjects(INFINITE, m_ulCount, pArray, &uReturned, this, TRUE, FALSE );
            if ( FAILED (hr) )
            {
                if ( hr == WBEM_E_CALL_CANCELLED )
                {
                    m_pFinalizer->DoSetStatus (m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, 0, 0);
                }
            }

            if (SUCCEEDED(hr) && uReturned)
            {
                for (int i=0; i!=uReturned; i++)
                {
                    if ( m_pFinalizer->HasWriteOnlyProps (pArray[i]) )
                        m_pFinalizer->ZapWriteOnlyProps (pArray[i]);
                }
                
                hr = m_pFinalizer->DoIndicate(m_pDestSink, uReturned, pArray);

	            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	            // Cleanup the array 
	            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	            for (ULONG i = 0; i != uReturned; i++)
	            {
	                pArray[i]->Release();
	            }
            }
            delete [] pArray;

                
            if ( SUCCEEDED (hr) )
            {
                // If number of requested objects == number of objects delivered, SetStatus (WBEM_S_NO_ERROR)
                if ( uReturned == m_ulCount )
                {
                    m_pFinalizer->DoSetStatus (m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, 0, 0, TRUE );

                }
                // If less objects are delivered, SetStatus (WBEM_S_FALSE)
                else
                {
                    m_pFinalizer->DoSetStatus (m_pDestSink, WBEM_STATUS_COMPLETE, WBEM_S_FALSE, 0, 0, TRUE );
                }
            }
            else
            {
                m_pFinalizer->DoSetStatusCancel (m_pDestSink, hr );
            }
        }

    }    

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
DWORD WINAPI CWmiFinalizerEnumerator::ThreadBootstrapNextAsync ( PVOID pParam )
{
    HRESULT hRes;
    InsertableEvent * pInsert;
    CWmiFinalizerEnumerator* pEnum;    

    pInsert = (InsertableEvent *)pParam;
    pInsert->ThreadId = GetCurrentThreadId();
    pEnum = pInsert->pEnum;        
    
    try
    {
        hRes = pEnum->_NextAsync();
    }
    catch (...)
    {
        ExceptionCounter c;
    };

    pEnum->GetDestSink()->Release();
    pEnum->NULLDestSink();    
    pEnum->SetCompletionSignalEvent ();

    pEnum->Remove_NextAsync(pInsert);

    return hRes;
}



//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Clone(
    /*[out]*/ IEnumWbemClassObject** ppEnum
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    CInCritSec cs(&m_clientLock);       // SEC:REVIEWED 2002-03-22 : Assumes entry
    if ( ppEnum == NULL )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }

    // If the enumerator is not restartable, it is forward only, and hence cannot
    // be cloned.

    if ( !m_pFinalizer->IsRestartable() )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    HRESULT hRes = S_OK ;    

    //
    // Get the enumerator
    //
    hRes = m_pFinalizer->GetResultObject ( m_uCurObjectPosition, IID_IEnumWbemClassObject, (void**)ppEnum ) ;

       //
    // Keep state information
    //
    if ( SUCCEEDED ( hRes ) )
    {
        ((CWmiFinalizerEnumerator*)(*ppEnum))->m_uCurObjectPosition = m_uCurObjectPosition ;
        ((CWmiFinalizerEnumerator*)(*ppEnum))->m_bSetStatusConsumed = m_bSetStatusConsumed ;
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::Skip(
    /*[in]*/ long lTimeout,
    /*[in]*/ ULONG nCount
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if ( (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    CInCritSec cs(&m_clientLock);    // SEC:REVIEWED 2002-03-22 : Assumes entry
    m_ulSemisyncWakeupCall = nCount ;
    return m_pFinalizer->Skip(lTimeout, nCount, this ) ;
}






//***************************************************************************
// IWbemFetchSmartEnum
//    GetSmartEnum
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::GetSmartEnum ( IWbemWCOSmartEnum** ppSmartEnum )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;
    
    HRESULT hRes;    

    if (NULL == m_pEnumMarshal)
    {
        _IWbemEnumMarshaling * pEnum = NULL;
        if (FAILED(hRes = CoCreateInstance ( CLSID__WbemEnumMarshaling, 
                                                               NULL, CLSCTX_INPROC_SERVER, IID__IWbemEnumMarshaling, 
                                                                (void**) &pEnum )))
        {
            return hRes;
        }
        if (InterlockedCompareExchangePointer((PVOID *)&m_pEnumMarshal,pEnum,0))
        {
              pEnum->Release(); // we've been beaten
        }
    }
    return m_XSmartEnum.QueryInterface( IID_IWbemWCOSmartEnum, (void**) ppSmartEnum );
}


//***************************************************************************
// SmartEnum
//    QI
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::XSmartEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if ( IID_IUnknown==riid || IID_IWbemWCOSmartEnum == riid)
    {
        *ppvObj = (IWbemWCOSmartEnum*)this;
        AddRef();
        return NOERROR;
    }
    else
    {
        return m_pOuter->QueryInterface( riid, ppvObj );
    }
}


//***************************************************************************
// SmartEnum
//    Addref
//***************************************************************************
ULONG CWmiFinalizerEnumerator::XSmartEnum::AddRef( void )
{
    return m_pOuter->AddRef();
}


//***************************************************************************
// SmartEnum
//    Release
//***************************************************************************
ULONG CWmiFinalizerEnumerator::XSmartEnum::Release( void )
{
    return m_pOuter->Release();
}


//***************************************************************************
// SmartEnum
//    Release
//***************************************************************************
STDMETHODIMP CWmiFinalizerEnumerator::XSmartEnum:: Next( REFGUID proxyGUID, long lTimeout, ULONG uCount,
                ULONG* puReturned, ULONG* pdwBuffSize, BYTE** pBuffer)
{
    if(!m_pOuter->m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    HRESULT hRes = WBEM_S_NO_ERROR;    

    IWbemClassObject** apObj = new IWbemClassObject* [uCount];
    if ( !apObj )
        hRes = WBEM_E_OUT_OF_MEMORY;

    else
    {
        // Call next on real enumerator
        hRes = m_pOuter->Next ( lTimeout, uCount, apObj, puReturned );
        if ( SUCCEEDED (hRes) )
        {
            if ( *puReturned > 0 )
            {
                HRESULT hResMarshal = m_pOuter->m_pEnumMarshal->GetMarshalPacket ( proxyGUID, *puReturned, apObj, pdwBuffSize, pBuffer );
                if ( FAILED (hResMarshal) )
                    hRes = hResMarshal;
            }
            else
            {
                *pdwBuffSize = 0;
                *pBuffer = NULL;
            }

            for ( ULONG ulIn=0; ulIn < *puReturned; ulIn++ )
            {
                try
                {
                    apObj[ulIn]->Release();
                }
                catch(...)
                {
                }
            }
        }
        delete [] apObj;
    }
    return hRes;
}




// ===================================================================================================================================================
// ===================================================================================================================================================

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerCallResult::CWmiFinalizerCallResult (

    CWmiFinalizer *pFinalizer

) :    m_lInternalRefCount(0),
    m_pFinalizer(pFinalizer),
    m_lFlags(-1),
    m_hResult(0),
    m_strParam(0),
    m_pObj(0),
    m_pServices(0),
    m_bGotObject(false),
    m_bGotServices(false),
    m_pErrorObj(NULL),
    m_lRefCount(0)
{
    InterlockedIncrement ( & s_FinalizerCallResult_ObjectCount );
    
    gClientCounter.AddClientPtr(&m_Entry);    
}

//***************************************************************************
//
//***************************************************************************
CWmiFinalizerCallResult::~CWmiFinalizerCallResult()
{
    InterlockedDecrement ( & s_FinalizerCallResult_ObjectCount ) ;

    if (m_pObj)
        m_pObj->Release();

    SysFreeString(m_strParam);

    if (m_pServices)
        m_pServices->Release();

    if (m_pErrorObj)
        m_pErrorObj->Release();
    
    gClientCounter.RemoveClientPtr(&m_Entry);    
}

//***************************************************************************
//
//***************************************************************************
STDMETHODIMP CWmiFinalizerCallResult::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if ((IID_IUnknown==riid) || (IID_IWbemCallResult == riid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::AddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lRefCount);
    if (uNewCount == 1)
        m_pFinalizer->AddRef () ;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (uNewCount == 0)
    {
        m_pFinalizer->CancelTaskInternal();
        m_pFinalizer->Release () ;
    }
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::InternalAddRef()
{
    ULONG uNewCount = InterlockedIncrement(&m_lInternalRefCount);
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
ULONG CWmiFinalizerCallResult::InternalRelease()
{
    ULONG uNewCount = InterlockedDecrement(&m_lInternalRefCount);
    if (0 == uNewCount)
    {
        delete this ;
    }

    return uNewCount;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResultObject(
    /*[in]*/  long lTimeout,
    /*[out]*/ IWbemClassObject** ppResultObject
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if ( ( ppResultObject==NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }

    if (!m_bGotObject)
    {
        HRESULT hrResult = WBEM_S_NO_ERROR ;
        HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
        if (FAILED(hr))
        {
            return WBEM_E_FAILED ;
        }
        else if (hr == WBEM_S_TIMEDOUT)
        {
            return WBEM_S_TIMEDOUT;
        }
        else if ( FAILED ( hrResult ) )
        {
            return hrResult ;
        }


        if (FAILED(hrResult))
            SetErrorInfo();

        {
            CWmiFinalizerObj *pFinalizerObj=NULL;
            bool bFinished = false;
            HRESULT hRes = WBEM_E_NOT_FOUND;
            while (!bFinished)
            {
                hRes = m_pFinalizer->GetNextObject(&pFinalizerObj);
                if (FAILED(hRes))
                {
                    return WBEM_E_FAILED ;
                }
                else if (hRes == WBEM_S_FALSE)
                {
                    return WBEM_S_TIMEDOUT;
                }
                

                if (pFinalizerObj->m_objectType == CWmiFinalizerObj::object)
                {
                    m_bGotObject = true;
                    m_pObj = pFinalizerObj->m_pObj;

                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    // Catch any nasty attempts to crash WinMgmt through bad
                    // pointers.
                    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    try
                    {
                        *ppResultObject = pFinalizerObj->m_pObj;
                    }
                    catch (...)
                    {
                        ExceptionCounter c;
                        delete pFinalizerObj;
                        return WBEM_E_INVALID_PARAMETER;
                    }

                    if ( pFinalizerObj->m_pObj )
                    {
                        //Need 2 add-refs, one because we hold on to it, the other because we pass it back to the user!
                        pFinalizerObj->m_pObj->AddRef();
                        pFinalizerObj->m_pObj->AddRef();
                    }
                    bFinished = true;
                    hrResult = WBEM_S_NO_ERROR ;
                }
                else if ((pFinalizerObj->m_objectType == CWmiFinalizerObj::status) && (pFinalizerObj->m_lFlags == WBEM_STATUS_COMPLETE))
                {
                    hrResult = pFinalizerObj->m_hRes;
                    bFinished = true;
                }
                else if (pFinalizerObj->m_objectType == CWmiFinalizerObj::status)
                {
                    //We have a non-completion status object...
                }

                delete pFinalizerObj;
            }
        }
        return hrResult;
    }
    else
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Catch any nasty attempts to crash WinMgmt through bad
        // pointers.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        try
        {    
             m_pObj->AddRef();
            *ppResultObject = m_pObj;            
        }
        catch (...)
        {
            ExceptionCounter c;        
            m_pObj->Release ();
            return WBEM_E_INVALID_PARAMETER;
        }
        return WBEM_S_NO_ERROR;
    }
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResultString(
    /*[in]*/  long lTimeout,
    /*[out]*/ BSTR* pstrResultString
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if ( ( pstrResultString==NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }

    
    HRESULT hrResult;
    HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
    if (hr != WBEM_S_NO_ERROR)
        return hr;
    
    if (FAILED(hrResult))
        SetErrorInfo();

    //
    // BUGBUG duplicated code SysAllocString takes NULL
    //
    if(m_strParam)
    {
        try
        {        
            *pstrResultString = SysAllocString(m_strParam);
        }
        catch (...)
        {
            ExceptionCounter c;        
            return WBEM_E_INVALID_PARAMETER;
        }

        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        try
        {
            *pstrResultString = NULL;
        }
        catch (...)
        {
            ExceptionCounter c;        
            return WBEM_E_INVALID_PARAMETER;
        }
        if ( SUCCEEDED (hrResult) )
        {
            hr = WBEM_E_INVALID_OPERATION;
        }
        else
        {
            hr = hrResult;
        }
    }
    return hr;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResultServices(
    /*[in]*/  long lTimeout,
    /*[out]*/ IWbemServices** ppServices
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if ( ( ppServices==NULL ) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }

    if (!m_bGotServices)
    {
        HRESULT hrResult;
        HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
        if (hr != WBEM_S_NO_ERROR)
            return hr;

        if (FAILED(hrResult))
            SetErrorInfo();

        if (SUCCEEDED(hrResult))
        {
            CWmiFinalizerObj *pFinalizerObj=NULL;
            HRESULT hRes = m_pFinalizer->GetNextObject(&pFinalizerObj);
            if (FAILED(hRes))
                return hRes;
            if ( hRes==WBEM_S_FALSE )
                return WBEM_E_NOT_FOUND;

            m_bGotServices = true;
            m_pServices = (IWbemServices*)pFinalizerObj->m_pvObj;

            if (ppServices)
            {
                try
                {
                    *ppServices = (IWbemServices*)pFinalizerObj->m_pvObj;
                }
                catch (...)
                {
                    ExceptionCounter c;                
                    delete pFinalizerObj;
                    return WBEM_E_INVALID_PARAMETER;
                }
                if ( pFinalizerObj->m_pvObj )
                {
                    //Need 2 add-refs, one because we hold on to it, the other because we pass it back to the user!
                    ((IWbemServices*)pFinalizerObj->m_pvObj)->AddRef();
                    ((IWbemServices*)pFinalizerObj->m_pvObj)->AddRef();
                }
            }
            delete pFinalizerObj;
        }
        return hrResult;
    }
    else
    {
        try
        {
            *ppServices = m_pServices;
        }
        catch (...)
        {
            ExceptionCounter c;        
            return WBEM_E_INVALID_PARAMETER;
        }
        return WBEM_NO_ERROR;
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetCallStatus(
    /*[in]*/  long lTimeout,
    /*[out]*/ long* plStatus
    )
{
    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    if ( (plStatus == NULL) || (lTimeout < 0 && lTimeout != WBEM_INFINITE) )
        return WBEM_E_INVALID_PARAMETER;

    
    HRESULT hrResult;
    HRESULT hr = m_pFinalizer->GetOperationResult(0, lTimeout, &hrResult);
    if (hr != WBEM_S_NO_ERROR)
    {
        return hr;
    }
    
    try
    {
        *plStatus = hrResult;
    }
    catch (...)
    {
        ExceptionCounter c;    
        return WBEM_E_INVALID_PARAMETER;
    }

    if(FAILED(hrResult))
    {
        SetErrorInfo();
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::GetResult(
    /*[in]*/ long lTimeout,
    /*[in]*/ long lFlags,
    /*[in]*/ REFIID riid,
    /*[out, iid_is(riid)]*/ void **ppvResult
    )
{
#ifdef DBG
    DebugBreak();
#endif
    return WBEM_E_NOT_SUPPORTED;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CWmiFinalizerCallResult::SetStatus(
    /*[in]*/ long lFlags,
    /*[in]*/ HRESULT hResult,
    /*[in]*/ BSTR strParam,
    /*[in]*/ IWbemClassObject* pObjParam
    )
{
    if (m_lFlags != -1)
    {
        SysFreeString(m_strParam);
        m_strParam = 0;
    }
    if (strParam)
    {
        m_strParam = SysAllocString(strParam);
        if (m_strParam == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    m_lFlags = lFlags;
    m_hResult = hResult;
    
    if ( m_pErrorObj )
    {
        m_pErrorObj->Release ( );
    }
    m_pErrorObj = pObjParam;

    if (m_pErrorObj)
    {
        m_pErrorObj->AddRef();
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************

void CWmiFinalizerCallResult::SetErrorInfo()
{
    if(m_pErrorObj)
    {
        IErrorInfo* pInfo = NULL;
        m_pErrorObj->QueryInterface(IID_IErrorInfo, (void**)&pInfo);
        ::SetErrorInfo(0, pInfo);
        pInfo->Release();
    }
}


//***************************************************************************
//                            CWmiFinalizerObj Methods
//***************************************************************************


/*
    * ==================================================================================================
    |
    | CWmiFinalizerObj::CWmiFinalizerObj(IWbemClassObject *pObj, _IWmiFinalizer* pFin )
    | ---------------------------------------------------------------------------------
    |
    |
    |
    |
    * ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj(IWbemClassObject *pObj, _IWmiFinalizer* pFin ) : m_pObj(pObj),
                                                                                    m_objectType(object),
                                                                                    m_lFlags(0),
                                                                                    m_bStr(0),
                                                                                    m_hRes(0) ,
                                                                                    m_pvObj(0),
                                                                                    m_pFin ( pFin ),
                                                                                    m_hArb ( WBEM_S_ARB_NOTHROTTLING )
{
     if (m_pObj)
    {
        m_pObj->AddRef();
        CWbemObject* pObjTmp = (CWbemObject*) pObj;
        if ( pObjTmp )
        { 
            m_uSize = pObjTmp -> GetBlockLength();
            if ( m_pFin )
            {
                m_hArb = ((CWmiFinalizer*)m_pFin)->ReportMemoryUsage ( 0, m_uSize ) ;
            }
        }
        else
        {
            m_uSize = 0;
        }

    }
}



/*
    * ==================================================================================================
    |
    | CWmiFinalizerObj::CWmiFinalizerObj (CWmiFinalizerObj& obj)
    | ----------------------------------------------------------
    |
    | Copyconstructor for CWmiFinalizerObj. This is ONLY used on restartable enumerators.
    | Since we keep the objects in the queue when someone grabs an object on a restartable
    | enumerator we dont account for this memory to avoid misreporting memory due to
    | destruction of finalizer.
    |
    |
    * ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj (CWmiFinalizerObj& obj)
{
    m_pvObj = obj.m_pvObj;
    m_iid = obj.m_iid;
    m_uSize = obj.m_uSize;
    m_pFin = NULL ;
    m_hArb = obj.m_hArb ;
    
    if (m_pvObj)
    {
        if (m_iid == IID_IUnknown)
        {
            ((IUnknown*)m_pvObj)->AddRef();
        }
        else if (m_iid == IID_IWbemClassObject)
        {
            ((IWbemClassObject*)m_pvObj)->AddRef();
        }
        else if (m_iid == IID__IWmiObject)
        {
            ((_IWmiObject*)m_pvObj)->AddRef();
        }
        else if (m_iid == IID_IWbemServices)
        {
            ((IWbemServices*)m_pvObj)->AddRef();
        }
        /*
        else if (m_iid == IID_IWbemServicesEx)
        {
            ((IWbemServicesEx*)m_pvObj)->AddRef();
        }
        */
    }
    m_pObj = obj.m_pObj;
    m_objectType = obj.m_objectType;
    m_lFlags = obj.m_lFlags;
    if (obj.m_bStr)
        m_bStr = SysAllocString(obj.m_bStr);
    else
        m_bStr = NULL;
    m_hRes = obj.m_hRes;

    if (m_pObj)
        m_pObj->AddRef();

}


/*
    * ==================================================================================================
    |
    | CWmiFinalizerObj(ULONG lFlags, REFIID riid, void *pvObj)
    | --------------------------------------------------------
    |
    |
    |
    * ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj(ULONG lFlags, REFIID riid, void *pvObj) :     m_pObj(0),
                                                                                m_objectType(set),
                                                                                m_lFlags(lFlags),
                                                                                m_bStr(0),
                                                                                m_hRes(0),
                                                                                m_pvObj(pvObj),
                                                                                m_iid(riid),
                                                                                m_pFin ( NULL ),
                                                                                m_hArb ( WBEM_S_ARB_NOTHROTTLING )
{
    m_uSize = 0;
    if (m_iid == IID_IUnknown)
    {
        ((IUnknown*)m_pvObj)->AddRef();
    }
    else if (m_iid == IID_IWbemClassObject)
    {
        ((IWbemClassObject*)m_pvObj)->AddRef();
    }
    else if (m_iid == IID__IWmiObject)
    {
        ((_IWmiObject*)m_pvObj)->AddRef();
    }
    else if (m_iid == IID_IWbemServices)
    {
        ((IWbemServices*)m_pvObj)->AddRef();
    }
    /*
    else if (m_iid == IID_IWbemServicesEx)
    {
        ((IWbemServicesEx*)m_pvObj)->AddRef();
    }
    */
    else
    {
        memset(&m_iid, 0, sizeof(IID));   // SEC:REVIEWED 2002-03-22 : OK
        m_pvObj = 0;
        m_objectType = unknown;
    }
}


/*
    * ==================================================================================================
    |
    | CWmiFinalizerObj(ULONG lFlags, HRESULT hRes, BSTR bStr, IWbemClassObject *pObj)
    | -------------------------------------------------------------------------------
    |
    |
    |
    * ==================================================================================================
*/

CWmiFinalizerObj::CWmiFinalizerObj(ULONG lFlags, 
                                                      HRESULT hRes, 
                                                      BSTR bStr, 
                                                      IWbemClassObject *pObj): 
    m_pObj(pObj),
    m_objectType(status),
    m_lFlags(lFlags),
    m_hRes(hRes),
    m_pvObj(0),
    m_pFin ( NULL ) ,
    m_hArb ( WBEM_S_ARB_NOTHROTTLING )
{
    m_uSize = 0;
    if (bStr)
        m_bStr = SysAllocString(bStr);
    else
        m_bStr = NULL;

    if (m_pObj)
        m_pObj->AddRef();
}




/*
    * ==================================================================================================
    |
    | CWmiFinalizerObj::~CWmiFinalizerObj ( )
    | ---------------------------------------
    |
    |
    * ==================================================================================================
*/

CWmiFinalizerObj::~CWmiFinalizerObj ( )
{
    if (m_bStr)
    {
        SysFreeString(m_bStr);
    }

    if (m_pObj)
    {
        m_pObj->Release();
        m_pObj = NULL ;
    }

    if (m_pvObj)
    {
        if (m_iid == IID_IUnknown)
        {
            ((IUnknown*)m_pvObj)->Release();
        }
        else if (m_iid == IID_IWbemClassObject)
        {
            ((IWbemClassObject*)m_pvObj)->Release();
        }
        else if (m_iid == IID__IWmiObject)
        {
            ((_IWmiObject*)m_pvObj)->Release();
        }
        else if (m_iid == IID_IWbemServices)
        {
            ((IWbemServices*)m_pvObj)->Release();
        }
        m_pvObj = NULL ;
    }

    if ( m_pFin )
    {
        ((CWmiFinalizer*)m_pFin)->ReportMemoryUsage ( 0, -m_uSize ) ;
        m_pFin = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmitask.cpp ===
//***************************************************************************
//
//  WMITASK.CPP
//
//  raymcc  23-Apr-00       First oversimplified draft for Whistler
//  raymcc  18-Mar-02       Security review.
//
//***************************************************************************
#include "precomp.h"

#include <windows.h>
#include <comdef.h>
#include <stdio.h>
#include <wbemcore.h>
#include <wmiarbitrator.h>
#include <wmifinalizer.h>
#include <context.h>


static ULONG g_uNextTaskId = 1;
static LONG  g_uTaskCount = 0;
extern ULONG g_ulClientCallbackTimeout ;


//***************************************************************************
//
//***************************************************************************

CStaticCritSec CWmiTask::m_TaskCs;

CWmiTask* CWmiTask::CreateTask ( )
{
    try 
    {    
        return new CWmiTask(); //throws
    }
    catch( CX_Exception &)
    {
        return NULL;
    }
}

//***************************************************************************
//
//***************************************************************************

CWmiTask::CWmiTask ( )
{
    m_hResult = WBEM_E_CALL_CANCELLED ;
    m_uRefCount = 1;
    m_uTaskType = 0;
    m_uTaskStatus = 0;
    m_uStartTime = 0;
    m_uTaskId = InterlockedIncrement((LONG *) &g_uNextTaskId);
    m_pNs = 0;
    m_pAsyncClientSink = 0;
    m_pReqSink = 0;
    m_uMemoryUsage = 0;
    m_uTotalSleepTime = 0;
    m_uCancelState = FALSE;
    m_uLastSleepTime = 0;
    m_hTimer = NULL;
    m_pMainCtx = 0;
    m_hCompletion = NULL ;
    m_bAccountedForThrottling = FALSE ;
    m_bCancelledDueToThrottling = FALSE ;
    m_pReqDoNotUse = NULL;
    m_pReqCancelNotSink = NULL;
    m_pStatusSink = new CStatusSink;
    if (NULL == m_pStatusSink) throw CX_MemoryException();
    InterlockedIncrement((LONG *)&g_uTaskCount);
}

//***************************************************************************
//
//  CWmiTask::~CWmiTask
//
//***************************************************************************
//
CWmiTask::~CWmiTask()
{    
    if (m_pNs)  m_pNs->Release ( ) ;
    if (m_pAsyncClientSink) m_pAsyncClientSink->Release ( ) ;
    if (m_pReqSink)  m_pReqSink->Release ( ) ;
    if (m_pMainCtx) m_pMainCtx->Release ( ) ;

    CCheckedInCritSec _cs ( &m_csTask ); 
    
    // Release all provider/sink bindings.
    for (int i = 0; i < m_aTaskProviders.Size(); i++)
    {
        STaskProvider *pTP = (STaskProvider *) m_aTaskProviders[i];
        delete pTP;
    }

    // Release all Arbitratees
    ReleaseArbitratees ( ) ;

    if ( m_hTimer ) CloseHandle ( m_hTimer );
    if (m_hCompletion)  CloseHandle ( m_hCompletion ) ;

    if (m_pStatusSink) m_pStatusSink->Release();

    delete m_pReqCancelNotSink;

    InterlockedDecrement((LONG *)&g_uTaskCount);    
}



/*
    * =============================================================================
    |
    | HRESULT CWmiTask::SignalCancellation ( )
    | ----------------------------------------
    |
    | Signals the task to be cancelled
    |
    |
    * =============================================================================
*/

HRESULT CWmiTask::SignalCancellation ( )
{
    CInCritSec _cs ( &m_csTask ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    if ( ( m_uTaskStatus != WMICORE_TASK_STATUS_CANCELLED ) && ( m_hTimer != NULL ) )
    {
        SetEvent ( m_hTimer ) ;  // SEC:REVIEWED 2002-03-22 : Needs err check
    }

    return WBEM_S_NO_ERROR; 
}

/*
    * =============================================================================
    |
    | HRESULT CWmiTask::SetTaskResult ( HRESULT hRes )
    | -------------------------------------------------
    |
    | Sets the task result
    |
    |
    * =============================================================================
*/

HRESULT CWmiTask::SetTaskResult ( HRESULT hResult )
{
    m_hResult = hResult ;
    return WBEM_S_NO_ERROR;
}


/*
    * =============================================================================
    |
    | HRESULT CWmiTask::UpdateMemoryUsage ( LONG lDelta )
    | ---------------------------------------------------
    |
    | Updates the task memory usage
    |
    |
    * =============================================================================
*/

HRESULT CWmiTask::UpdateMemoryUsage ( LONG lDelta )
{
    CInCritSec _cs ( &m_csTask );       // SEC:REVIEWED 2002-03-22 : Assumes entry

    m_uMemoryUsage += lDelta ;

    return WBEM_S_NO_ERROR;
}



/*
    * =============================================================================
    |
    | HRESULT CWmiTask::UpdateTotalSleepTime ( ULONG uSleepTime )
    | -----------------------------------------------------------
    |
    | Updates the tasks sleep time
    |
    |
    * =============================================================================
*/

HRESULT CWmiTask::UpdateTotalSleepTime ( ULONG uSleepTime )
{
    CInCritSec _cs ( &m_csTask );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    m_uTotalSleepTime += uSleepTime ;
    return WBEM_S_NO_ERROR;
}



/*
    * =============================================================================
    |
    | HRESULT CWmiTask::ReleaseArbitratees ( )
    | ----------------------------------------
    |
    | Releases all the arbitratees (Finalizer, Merger currently)
    |
    |
    |
    |
    |
    * =============================================================================
*/

HRESULT CWmiTask::ReleaseArbitratees ( BOOL bIsShutdown)
{
    HRESULT hRes = WBEM_S_NO_ERROR ;

    CInCritSec _cs ( &m_csTask );      // SEC:REVIEWED 2002-03-22 : Assumes entry

    for (ULONG i = 0; i < m_aArbitratees.Size(); i++)
    {
        BOOL bLastNeeded = TRUE;
        _IWmiArbitratee *pArbee = NULL ;
        pArbee = (_IWmiArbitratee*) m_aArbitratees[i];
        if ( pArbee )
        {
            if (bIsShutdown)
            {
                IWbemShutdown * pShutdown = NULL;
                if (SUCCEEDED(pArbee->QueryInterface(IID_IWbemShutdown,(void **)&pShutdown)))
                {
                    pShutdown->Shutdown(0,0,NULL);
                    long lRet =  pShutdown->Release();
                    //
                    // Please understand the code in CWmiFinalizer::ShutDown for this trick
                    //
                    if (0 == lRet) bLastNeeded = FALSE;
                }
            }
            if (bLastNeeded)
                pArbee->Release();
        }
    }
    m_aArbitratees.Empty();
    
    return hRes ;
}



//***************************************************************************
//
//***************************************************************************
HRESULT CWmiTask::SetRequestSink(CStdSink *pReqSink)
{
    if (pReqSink == 0)
        return WBEM_E_INVALID_PARAMETER;
    if (m_pReqSink != 0)
        return WBEM_E_INVALID_OPERATION;

    CInCritSec _cs ( &m_csTask );      // SEC:REVIEWED 2002-03-22 : Assumes entry
    pReqSink->AddRef ( ) ;
    m_pReqSink = pReqSink;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiTask::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// *
ULONG CWmiTask::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiTask::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    if (NULL == ppvObj) return E_POINTER;
    
    if (IID_IUnknown==riid || IID__IWmiCoreHandle==riid)
    {
        *ppvObj = (_IWmiCoreHandle *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }
}


//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiTask::GetHandleType(
    ULONG *puType
    )
{
    *puType = WMI_HANDLE_TASK;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// *
HRESULT CWmiTask::Initialize(
    IN CWbemNamespace *pNs,
    IN ULONG uTaskType,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pAsyncClientSinkCopy,
    IN CAsyncReq *pReq
    )
{
    HRESULT hRes;

    if (pNs == 0 || pCtx == 0)
        return WBEM_E_INVALID_PARAMETER;

    m_hCompletion = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (NULL == m_hCompletion) return WBEM_E_OUT_OF_MEMORY;

    //
    // this is just a pointer copy for the debugger
    // it MAY point to the request that originated us, or it MAY not
    // the lifetime of the request is generally less than the lifetime of the CWmiTask
    // 
    m_pReqDoNotUse = pReq; 

    m_pNs = pNs;
    m_pNs->AddRef();

    m_uTaskType = uTaskType;
    if (CORE_TASK_TYPE(m_uTaskType) == WMICORE_TASK_EXEC_NOTIFICATION_QUERY)
    {
        wmilib::auto_ptr<CAsyncReq_RemoveNotifySink> pReq( new CAsyncReq_RemoveNotifySink(m_pReqSink, NULL));
        if (NULL == pReq.get()  || NULL == pReq->GetContext())
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        m_pReqCancelNotSink = pReq.release();
    }
    
    m_uStartTime = GetCurrentTime();

    // See if the task is primary or not.
    // ==================================
    if (pCtx)
    {
        CWbemContext *pContext = (CWbemContext *) pCtx;

        GUID ParentId = GUID_NULL;
        pContext->GetParentId(&ParentId);

        if (ParentId != GUID_NULL)
        {
            m_uTaskType |= WMICORE_TASK_TYPE_DEPENDENT;
        }
        else
            m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;

        m_pMainCtx = (CWbemContext *) pCtx;
        m_pMainCtx->AddRef();
    }
    else
    {
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // If we dont have a context check to see if the namespace is an ESS or Provider
        // initialized namespace, if so, set the task type to dependent.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if ( pNs->GetIsESS ( ) || pNs->GetIsProvider ( ) )
        {
            m_uTaskType |= WMICORE_TASK_TYPE_DEPENDENT;
        }
        else
        {
            m_uTaskType |= WMICORE_TASK_TYPE_PRIMARY;
        }
    }


    if ((uTaskType & WMICORE_TASK_TYPE_ASYNC) && pAsyncClientSinkCopy)
    {
        m_pAsyncClientSink = pAsyncClientSinkCopy;
        m_pAsyncClientSink->AddRef();
    }
    else
        m_pAsyncClientSink = 0;


    // Register this task with Arbitrator.
    // ====================================

    _IWmiArbitrator *pArb = CWmiArbitrator::GetUnrefedArbitrator();
    if (!pArb)
        return WBEM_E_CRITICAL_ERROR;

    hRes = pArb->RegisterTask(this);
    if (FAILED(hRes))
        return hRes;

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
/*
HRESULT CWmiTask::SetFinalizer(_IWmiFinalizer *pFnz)
{
    if (pFnz == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (m_pWorkingFnz)
        return WBEM_E_INVALID_OPERATION;

    m_pWorkingFnz = pFnz;
    m_pWorkingFnz->AddRef();

    return WBEM_S_NO_ERROR;
}
*/


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::GetFinalizer(_IWmiFinalizer **ppFnz)
{

    CInCritSec    ics( &m_csTask ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    for ( int x = 0; x < m_aArbitratees.Size(); x++ )
    {
        _IWmiArbitratee*    pArbitratee = (_IWmiArbitratee*) m_aArbitratees[x];

        if (pArbitratee && SUCCEEDED( pArbitratee->QueryInterface( IID__IWmiFinalizer, (void**) ppFnz ) ) )
        {
            break;
        }
    }

    return ( x < m_aArbitratees.Size() ? WBEM_S_NO_ERROR : WBEM_E_NOT_FOUND );
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::AddArbitratee( ULONG uFlags, _IWmiArbitratee* pArbitratee )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (pArbitratee == 0)
        return WBEM_E_INVALID_PARAMETER;

    CInCritSec _cs ( &m_csTask );

    if (m_uTaskStatus == WMICORE_TASK_STATUS_CANCELLED) return WBEM_S_NO_ERROR;

    if (CFlexArray::no_error != m_aArbitrateesStorage.InsertAt(m_aArbitratees.Size(),NULL)) return WBEM_E_OUT_OF_MEMORY;
    if (CFlexArray::no_error != m_aArbitratees.Add (pArbitratee)) return WBEM_E_OUT_OF_MEMORY;
    pArbitratee->AddRef();

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::RemoveArbitratee( ULONG uFlags, _IWmiArbitratee* pArbitratee )
{
    HRESULT hRes = WBEM_E_FAILED;

    if (pArbitratee == 0)
        return WBEM_E_INVALID_PARAMETER;

    CInCritSec _cs ( &m_csTask ); // SEC:REVIEWED 2002-03-22 : assumes entry
    for (int i = 0; i < m_aArbitratees.Size(); i++)
    {
        _IWmiArbitratee *pArbee = (_IWmiArbitratee*) m_aArbitratees[i];

        if (pArbee == pArbitratee)
        {
            m_aArbitratees[i] = 0;
            pArbee->Release();
            hRes = WBEM_S_NO_ERROR;
            break;
        }
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::GetArbitratedQuery( ULONG uFlags, _IWmiArbitratedQuery** ppArbitratedQuery )
{
    HRESULT hRes = E_NOINTERFACE;

    if (ppArbitratedQuery == 0)
        return WBEM_E_INVALID_PARAMETER;

    {
        CInCritSec _cs ( &m_csTask ); //#SEC:Assumes entry

        for ( int x = 0; FAILED( hRes ) && x < m_aArbitratees.Size(); x++ )
        {
            _IWmiArbitratee* pArb = (_IWmiArbitratee*) m_aArbitratees[x];

            if (pArb)
            {
                hRes = pArb->QueryInterface( IID__IWmiArbitratedQuery, (void**) ppArbitratedQuery );
            }
        }

    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiTask::GetPrimaryTask ( _IWmiCoreHandle** pPTask )
{
    if ( pPTask == NULL ) return WBEM_E_INVALID_PARAMETER;
    *pPTask = (_IWmiCoreHandle*) this;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::Cancel( HRESULT hResParam )
{
    {
        CCheckedInCritSec _cs(&m_csTask); 
        if (m_uTaskStatus == WMICORE_TASK_STATUS_CANCELLED)
        {
            return WBEM_S_NO_ERROR; // Prevent reentrancy
        }
        m_uTaskStatus = WMICORE_TASK_STATUS_CANCELLED;
    }

    BOOL bCancelledViaEss = FALSE ;
    OnDeleteObj<BOOL,
    	        CWmiTask,
    	        HRESULT(CWmiTask::*)(BOOL),
    	        &CWmiTask::ReleaseArbitratees> RelArbitratees(this,WBEM_E_SHUTTING_DOWN == hResParam);    

    // We'll want one of these in order to track statuses from all plausible locations if
    // we are performing a client originated cancel
    CStatusSink*    pStatusSink = NULL;    
    if (hResParam == WMIARB_CALL_CANCELLED_CLIENT)
    {
        //
        // transfer ownership of the StatusSink to the stack
        // initial refcount is 1, so we are OK
        //
        pStatusSink = m_pStatusSink;
        m_pStatusSink = NULL;
    }

    // Auto Release
    CReleaseMe    rmStatusSink( pStatusSink );


    // Change this to an async scheduled request
    // ==========================================

    if (CORE_TASK_TYPE(m_uTaskType) == WMICORE_TASK_EXEC_NOTIFICATION_QUERY)
    {
        wmilib::auto_ptr<CAsyncReq_RemoveNotifySink> pReq(m_pReqCancelNotSink);
        m_pReqCancelNotSink = NULL; // transfer ownership
        pReq->SetSink(m_pReqSink);        
        pReq->SetStatusSink(pStatusSink);
        
        // If we have a status sink, then we should wait until the operation
        // completes before continuing so we can get the proper status from the
        // sink.
        HRESULT hResInner;
        if (pStatusSink) // cancelled by the originating client
        {
            hResInner = ConfigMgr::EnqueueRequestAndWait(pReq.get()); 
        }
        else
        {
            hResInner = ConfigMgr::EnqueueRequest(pReq.get());
        }
        if (FAILED(hResInner)) return hResInner;
        pReq.release();
        bCancelledViaEss = TRUE ;
    }

    // If here, a normal task.  Loop through any providers and stop them.
    // ==================================================================


    int SizeIter = 0;
    // This could change while we're accessing, so do this in a critsec
    {
        CInCritSec    ics( &m_csTask ); 
        _DBG_ASSERT(m_aTaskProvStorage.Size() >= m_aTaskProviders.Size());

        SizeIter = m_aTaskProviders.Size();
        for (int i = 0; i < SizeIter; i++)
            m_aTaskProvStorage[i] = m_aTaskProviders[i];
    }

    // Cancel what we've got
    // there cannot be 2 threads using m_aTaskProvStorage in the cancel call
    // m_uTaskStatus guards this code and the Add code
    
    for (int i = 0; i < SizeIter; i++)
    {
        STaskProvider *pTP = (STaskProvider *) m_aTaskProvStorage[i];
        if (pTP) pTP->Cancel(pStatusSink);
    }


    CStdSink* pTempSink = NULL;
    {
        CInCritSec _cs ( &m_csTask ); 
        if (m_pReqSink)
        {
            pTempSink = m_pReqSink;
            m_pReqSink = 0;
        }
    }

    if ( pTempSink )
    {
        pTempSink->Cancel();
        pTempSink->Release();
    }

    _DBG_ASSERT(m_hCompletion);

    //
    // Loop through all arbitratees and set the operation result to cancelled
    //
    HRESULT hRes = WBEM_S_NO_ERROR;
    if (!bCancelledViaEss)
    {
        _IWmiFinalizer* pFinalizer = NULL ;

        if ( hResParam == WMIARB_CALL_CANCELLED_CLIENT )
        {
            //
            // We need the finalizer to set the client wakeup event
            //
            hRes = GetFinalizer ( &pFinalizer ) ;
            if ( FAILED (hRes) )
            {
                hRes = WBEM_E_FAILED ;
            }
            else
            {
                ((CWmiFinalizer*)pFinalizer)->SetClientCancellationHandle ( m_hCompletion ) ;
            }
        }
        CReleaseMe FinalizerRelease(pFinalizer);

        //
        // only enter wait state if we successfully created and set the client wait event
        //
        if (SUCCEEDED(hRes))
        {
            if ( hResParam == WMIARB_CALL_CANCELLED_CLIENT || 
            	 hResParam == WMIARB_CALL_CANCELLED_THROTTLING )
            {
                SetArbitrateesOperationResult(0,WBEM_E_CALL_CANCELLED_CLIENT);
            }
            else
            {
                SetArbitrateesOperationResult(0,m_hResult);
            }
            
            if (hResParam == WMIARB_CALL_CANCELLED_CLIENT )
            {
                if (((CWmiFinalizer*)pFinalizer)->IsValidDestinationSink())
                {
                    DWORD dwRet = CCoreQueue::QueueWaitForSingleObject(m_hCompletion,g_ulClientCallbackTimeout);
                    if (dwRet == WAIT_TIMEOUT)
                    {
                        hRes = WBEM_S_TIMEDOUT;
                    }
                }
                
                ((CWmiFinalizer*)pFinalizer)->CancelWaitHandle();
        
                if (m_hCompletion)
                {
                    CloseHandle(m_hCompletion);
                    m_hCompletion = NULL ;
                }
            }
        }
    }
    

    //
    // We're done, get the final status from the status sink if we have one.
    //
    if ( NULL != pStatusSink )
    {
        hRes = pStatusSink->GetLastStatus();
    }

    return hRes ;
}


//***************************************************************************
//
//***************************************************************************
//
BOOL CWmiTask::IsESSNamespace ( )
{
    if (m_pNs) 
        return m_pNs->GetIsESS ( );
    
    return false;
}



//***************************************************************************
//
//***************************************************************************
//
BOOL CWmiTask::IsProviderNamespace ( )
{
    BOOL bRet = FALSE;

    if ( m_pNs )
    {
        bRet = m_pNs->GetIsProvider ( );
    }

    return bRet;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::AddTaskProv(STaskProvider *p)
{
    CInCritSec    ics( &m_csTask ); // SEC:REVIEWED 2002-03-22 : assumes entry

    // There is a race condition in which the task could get cancelled just as we
    // are executing. In this case, the task status will indicate that it has been
    // cancelled, so we should not add it to the task providers list.

    if (m_uTaskStatus == WMICORE_TASK_STATUS_CANCELLED)
        return WBEM_E_CALL_CANCELLED; // Prevent reentrancy

    if (CFlexArray::no_error != m_aTaskProvStorage.InsertAt(m_aTaskProviders.Size()+1,NULL)) return WBEM_E_OUT_OF_MEMORY;
    if (CFlexArray::no_error != m_aTaskProviders.Add(p)) return WBEM_E_OUT_OF_MEMORY;
    
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::HasMatchingSink(void *Test, IN REFIID riid)
{
    if (LPVOID(m_pAsyncClientSink) == LPVOID(Test))
        return WBEM_S_NO_ERROR;
    return WBEM_E_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::CreateTimerEvent ( )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    CCheckedInCritSec _cs ( &m_csTask ); // SEC:REVIEWED 2002-03-22 : assumes entry
    if ( !m_hTimer )
    {
        m_hTimer = CreateEvent ( NULL, TRUE, FALSE, NULL ); // SEC:REVIEWED 2002-03-22 : ok, unnamed
        if ( !m_hTimer )
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
HRESULT CWmiTask::SetArbitrateesOperationResult ( ULONG lFlags, HRESULT hResult )
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Set the operation result of all Arbitratees
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    int Index = 0;

    //
    // this function is only called by the Cancel call
    // We knwon that the Cance call is called only ONCE
    // and the code for adding to the array uses the same guard of the Cancel() method
    //
    
    {
        CInCritSec _cs ( &m_csTask ); 
        
        _DBG_ASSERT(m_aArbitrateesStorage.Size() >= m_aArbitratees.Size());
        
        for (int i = 0; i < m_aArbitratees.Size(); i++)
        {
            _IWmiArbitratee *pArbee = (_IWmiArbitratee*) m_aArbitratees[i];

            if ( pArbee )
            {
                m_aArbitrateesStorage[Index++] = pArbee;
                pArbee->AddRef();
            }
        }
    }

    for (int i = 0; i < Index; i++)
    {
        _IWmiArbitratee *pArbee = (_IWmiArbitratee*) m_aArbitrateesStorage[i];
         pArbee->SetOperationResult(lFlags, hResult );
         pArbee->Release();         
         m_aArbitrateesStorage[i] = NULL;
    }
    
    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CWmiTask::Dump(FILE* f)
{
    fprintf(f, "---Task = 0x%p----------------------------\n", this);  // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "    Refcount        = %d\n", m_uRefCount);           // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "    TaskStatus      = %u\n ", m_uTaskStatus);        // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "    Task ID         = %u\n", m_uTaskId);             // SEC:REVIEWED 2002-03-22 : OK

    // Task status
    char *p = "<none>";
    switch(m_uTaskStatus)
    {
        case WMICORE_TASK_STATUS_NEW: p = "WMICORE_TASK_STATUS_NEW"; break;
        case WMICORE_TASK_STATUS_CANCELLED: p = "WMICORE_TASK_STATUS_CANCELLED"; break;
    };

    fprintf(f, " %s\n", p);   // SEC:REVIEWED 2002-03-22 : OK

    // Task type
    p = "<none>";
    switch(m_uTaskType & 0xFF)
    {
        case WMICORE_TASK_NULL: p = "WMICORE_TASK_NULL"; break;
        case WMICORE_TASK_GET_OBJECT: p = "WMICORE_TASK_GET_OBJECT"; break;
        case WMICORE_TASK_GET_INSTANCE: p = "WMICORE_TASK_GET_INSTANCE"; break;
        case WMICORE_TASK_PUT_INSTANCE: p = "WMICORE_TASK_PUT_INSTANCE"; break;
        case WMICORE_TASK_DELETE_INSTANCE: p = "WMICORE_TASK_DELETE_INSTANCE"; break;
        case WMICORE_TASK_ENUM_INSTANCES:  p = "WMICORE_TASK_ENUM_INSTANCES"; break;
        case WMICORE_TASK_GET_CLASS:    p = "WMICORE_TASK_GET_CLASS"; break;
        case WMICORE_TASK_PUT_CLASS:    p = "WMICORE_TASK_PUT_CLASS"; break;
        case WMICORE_TASK_DELETE_CLASS: p = "WMICORE_TASK_DELETE_CLASS"; break;
        case WMICORE_TASK_ENUM_CLASSES: p = "WMICORE_TASK_ENUM_CLASSES"; break;
        case WMICORE_TASK_EXEC_QUERY:   p = "WMICORE_TASK_EXEC_QUERY"; break;
        case WMICORE_TASK_EXEC_METHOD:  p = "WMICORE_TASK_EXEC_METHOD"; break;
        case WMICORE_TASK_OPEN:         p = "WMICORE_TASK_OPEN"; break;
        case WMICORE_TASK_OPEN_SCOPE:   p = "WMICORE_TASK_OPEN_SCOPE"; break;
        case WMICORE_TASK_OPEN_NAMESPACE: p = "WMICORE_TASK_OPEN_NAMESPACE"; break;
        case WMICORE_TASK_EXEC_NOTIFICATION_QUERY: p = "WMICORE_TASK_EXEC_NOTIFICATION_QUERY"; break;
    }

    fprintf(f, "    TaskType = [0x%X] %s ", m_uTaskType, p);    // SEC:REVIEWED 2002-03-22 : OK

    if (m_uTaskType & WMICORE_TASK_TYPE_SYNC)
        fprintf(f,  " WMICORE_TASK_TYPE_SYNC");           // SEC:REVIEWED 2002-03-22 : OK

    if (m_uTaskType & WMICORE_TASK_TYPE_SEMISYNC)
        fprintf(f, " WMICORE_TASK_TYPE_SEMISYNC");        // SEC:REVIEWED 2002-03-22 : OK

    if (m_uTaskType & WMICORE_TASK_TYPE_ASYNC)
        fprintf(f, " WMICORE_TASK_TYPE_ASYNC");           // SEC:REVIEWED 2002-03-22 : OK

    if (m_uTaskType & WMICORE_TASK_TYPE_PRIMARY)
        fprintf(f, " WMICORE_TASK_TYPE_PRIMARY");         // SEC:REVIEWED 2002-03-22 : OK

    if (m_uTaskType & WMICORE_TASK_TYPE_DEPENDENT)
        fprintf(f, " WMICORE_TASK_TYPE_DEPENDENT");       // SEC:REVIEWED 2002-03-22 : OK

    fprintf(f, "\n");   // SEC:REVIEWED 2002-03-22 : OK

    fprintf(f, "    AsyncClientSink = 0x%p\n", m_pAsyncClientSink);    // SEC:REVIEWED 2002-03-22 : OK

    CCheckedInCritSec    ics( &m_csTask );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    for (int i = 0; i < m_aTaskProviders.Size(); i++)
    {
        STaskProvider *pTP = (STaskProvider *) m_aTaskProviders[i];
        fprintf(f, "    Task Provider [0x%p] Prov=0x%p Sink=0x%p\n", this, pTP->m_pProv, pTP->m_pProvSink);   // SEC:REVIEWED 2002-03-22 : OK
    }
    
    ics.Leave();

    DWORD dwAge = GetCurrentTime() - m_uStartTime;

    fprintf(f, "    CWbemNamespace = 0x%p\n", m_pNs);                                  // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "    Task age = %d milliseconds\n", dwAge);                             // SEC:REVIEWED 2002-03-22 : OK
    fprintf(f, "    Task last sleep time = %d ms\n", m_uLastSleepTime );               // SEC:REVIEWED 2002-03-22 : OK

    fprintf(f, "\n");   // SEC:REVIEWED 2002-03-22 : OK
    return 0;
}


//***************************************************************************
//
//***************************************************************************
//
STaskProvider::~STaskProvider()
{
    if (m_pProvSink)
        m_pProvSink->LocalRelease();
    ReleaseIfNotNULL(m_pProv);
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT STaskProvider::Cancel( CStatusSink* pStatusSink )
{
    HRESULT hRes = WBEM_S_NO_ERROR ;
    IWbemServices   *pTmpProv = 0;
    CProviderSink   *pTmpProvSink = 0;

    {
        CInCritSec ics(&CWmiTask::m_TaskCs);
        if (m_pProv != 0)
        {
            pTmpProv = m_pProv;
            m_pProv = 0;
        }
        if (m_pProvSink != 0)
        {
            pTmpProvSink = m_pProvSink;
            m_pProvSink = 0;
        }
    }

    if (pTmpProvSink)
    {
        pTmpProvSink->Cancel();
    }

    if (pTmpProv)
    {
        hRes = ExecCancelOnNewRequest ( pTmpProv, pTmpProvSink, pStatusSink ) ;
    }

    ReleaseIfNotNULL(pTmpProv);
    ReleaseIfNotNULL(pTmpProvSink);

    return hRes ;
}

// //////////////////////////////////////////////////////////////////////////////////////////
//
// Used when issuing CancelAsyncCall to providers associtated with the task.
// Rather than calling CancelAsynCall directly on the provider, we create a brand
// new request and execute it on a different thread. We do this to avoid hangs, since
// PSS is waiting the Indicate/SetStatus call to return before servicing the CancelCallAsync.
//
// //////////////////////////////////////////////////////////////////////////////////////////
HRESULT STaskProvider::ExecCancelOnNewRequest ( IWbemServices* pProv, CProviderSink* pSink, CStatusSink* pStatusSink )
{
    // Sanity check on params
    if ( pSink == NULL ) return WBEM_E_INVALID_PARAMETER ;

    // Create new request
    wmilib::auto_ptr<CAsyncReq_CancelProvAsyncCall> 
        pReq(new CAsyncReq_CancelProvAsyncCall ( pProv, pSink, pStatusSink ));

    if ( NULL == pReq.get()  || NULL == pReq->GetContext())
    {
        return WBEM_E_OUT_OF_MEMORY ;
    }

    // Enqueue the request
    
    // If we have a status sink, then we should wait until the operation
    // completes before continuing so we can get the proper status from the
    // sink.
    HRESULT hRes;
    if ( NULL != pStatusSink )
    {
        hRes = ConfigMgr::EnqueueRequestAndWait(pReq.get());
    }
    else
    {
        hRes = ConfigMgr::EnqueueRequest(pReq.get());
    }
    if (FAILED(hRes)) return hRes;
    pReq.release();
    
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\wmitask.h ===
//***************************************************************************
//
//  TASK.H
//
//  raymcc  23-Apr-00       First oversimplified draft for Whistler
//  raymcc  18-Mar-02       Security review
//
//***************************************************************************

#ifndef _WMITASK_H_
#define _WMITASK_H_

#define CORE_TASK_TYPE(x)   (x & 0xFF)
#include <context.h>

// forward
class CAsyncReq;
class CProviderSink;
class CStatusSink;

struct STaskProvider
{
    IWbemServices   *m_pProv;
    CProviderSink   *m_pProvSink;
    STaskProvider() { m_pProv = 0; m_pProvSink = 0; }
   ~STaskProvider();

    HRESULT Cancel( CStatusSink* pStatusSink );
    HRESULT ExecCancelOnNewRequest ( IWbemServices* pProv, CProviderSink* pSink, CStatusSink* pStatusSink ) ;
};


class CWmiTask : public _IWmiCoreHandle
{
    friend struct STaskProvider;

private:
    ULONG               m_uRefCount;
    ULONG               m_uTaskType;
    ULONG               m_uTaskStatus;
    ULONG               m_uTaskId;
    HRESULT                m_hResult ;
    BOOL                m_bAccountedForThrottling ;
    BOOL                m_bCancelledDueToThrottling ;
    CFlexArray          m_aTaskProviders;    // Array of STaskProvider structs
    IWbemObjectSink * m_pAsyncClientSink; // Used for cross-ref purposes only
    CStdSink *              m_pReqSink;         // The CStdSink pointer for each request
    LONG                      m_uMemoryUsage;
    ULONG                    m_uTotalSleepTime;
    ULONG                    m_uCancelState;
    ULONG                    m_uLastSleepTime;
    HANDLE             m_hCompletion ;
    HANDLE              m_hTimer;
    CWbemContext*     m_pMainCtx;
    CFlexArray             m_aArbitratees;
    CCritSec            m_csTask;
    CWbemNamespace  *m_pNs;
    DWORD            m_uStartTime;
    CStatusSink *   m_pStatusSink;
    CAsyncReq_RemoveNotifySink * m_pReqCancelNotSink;
    CFlexArray     m_aTaskProvStorage;
    CFlexArray     m_aArbitrateesStorage;
    CAsyncReq *    m_pReqDoNotUse; // this is just a pointer copy for the debugger


    CWmiTask( );
   ~CWmiTask();
   
    CWmiTask(const CWmiTask &Src){};
    CWmiTask & operator=(const CWmiTask &Src){};

    static CStaticCritSec m_TaskCs;

public:

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface( IN REFIID riid, OUT LPVOID *ppvObj);
    CWbemContext *GetCtx() { return m_pMainCtx; }

    HRESULT STDMETHODCALLTYPE GetHandleType(ULONG *puType);

    static CWmiTask *CreateTask( ) ;

    ULONG GetTaskType() { return m_uTaskType; }

    ULONG GetTaskStatus() { return m_uTaskStatus; }
    HANDLE GetTimerHandle() { return m_hTimer; }
    
    void  RemoveTaskStatusBit(ULONG uMask) { m_uTaskStatus &= !uMask; }

    VOID    SetCancelledState ( BOOL bState )    { m_bCancelledDueToThrottling = bState ; }
    BOOL    GetCancelledState ( ) { return m_bCancelledDueToThrottling ; }

    HRESULT    SignalCancellation ( ) ;
    HRESULT ReleaseArbitratees (BOOL bIsShutdown = FALSE ) ;
    HRESULT SetTaskResult ( HRESULT hRes ) ;
    HRESULT AddTaskProv(STaskProvider *);
    BOOL    IsESSNamespace ( );
    BOOL     IsProviderNamespace ( );

    HRESULT GetFinalizer( _IWmiFinalizer **ppFnz );
    BOOL    IsAccountedForThrottling ( )                    { return m_bAccountedForThrottling ; }
    VOID    SetAccountedForThrottling ( BOOL bSet )            { m_bAccountedForThrottling = bSet ; }

    HRESULT HasMatchingSink(void *Test, IN REFIID riid);
    HRESULT Cancel( HRESULT hRes = WBEM_E_CALL_CANCELLED );
    HRESULT GetPrimaryTask ( _IWmiCoreHandle** pPTask );

    HRESULT AddArbitratee(ULONG uFlags, _IWmiArbitratee* pArbitratee);
    HRESULT RemoveArbitratee(ULONG uFlags, _IWmiArbitratee* pArbitratee);

    HRESULT GetArbitratedQuery( ULONG uFlags, _IWmiArbitratedQuery** ppArbitratedQuery );

    HRESULT GetMemoryUsage    ( ULONG* uMemUsage ){ *uMemUsage = m_uMemoryUsage; return WBEM_S_NO_ERROR; } // SEC:REVIEWED 2002-03-22 : Needs ptr check
    HRESULT UpdateMemoryUsage ( LONG lDelta ) ;

    HRESULT GetTotalSleepTime ( ULONG* uSleepTime ){ *uSleepTime = m_uTotalSleepTime; return WBEM_S_NO_ERROR; }  // SEC:REVIEWED 2002-03-22 : Needs ptr check
    HRESULT UpdateTotalSleepTime ( ULONG uSleepTime ) ;

    HRESULT GetCancelState ( ULONG* uCancelState ){ *uCancelState = m_uCancelState;  return WBEM_S_NO_ERROR; } // SEC:REVIEWED 2002-03-22 : Needs ptr check
    HRESULT SetCancelState ( ULONG uCancelState ){ m_uCancelState = uCancelState;   return WBEM_S_NO_ERROR; }

    HRESULT SetLastSleepTime ( ULONG uSleep ){ m_uLastSleepTime = uSleep; return WBEM_S_NO_ERROR; }

    HRESULT CreateTimerEvent ( );

    HRESULT SetArbitrateesOperationResult ( ULONG, HRESULT );

       HRESULT Initialize(
        IN CWbemNamespace *pNs,
        IN ULONG uTaskType,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pClientSinkCopy,
        IN CAsyncReq *pReq);

    HRESULT AssertProviderRef(IWbemServices *pProv);
    HRESULT RetractProviderRef(IWbemServices *pProv);

    ULONG GetTaskId() { return m_uTaskId; }

    HRESULT Dump(FILE* f);  // Debug only
    HRESULT SetRequestSink(CStdSink *pSnk);

    CWbemNamespace* GetNamespace ( ) { return m_pNs; }
};

typedef CWmiTask *PCWmiTask;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\main.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiCache.h"
#include "WmiFinalizer.h"
#include <arrtempl.h>
#include <cominit.h>

extern bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass);
extern bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey);
extern bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue);
extern bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance);
extern void TestCache();
extern void TestFinalizer();
extern void TestArbitrator();

void __cdecl main(void)
{
//	TestCache();
	TestFinalizer();
}



bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass)
{
	_IWmiObject*	pObj= NULL;
	HRESULT hr = CoCreateInstance( CLSID_WbemClassObject, NULL, CLSCTX_INPROC_SERVER, IID__IWmiObject, (void**) &pObj );

	VARIANT var;
	VariantInit(&var);
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = SysAllocString(wszClassName);

	pObj->Put(L"__class", 0, &var, CIM_STRING);

	VariantClear(&var);

	*ppClass = pObj;
	return true;
}

bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey)
{
	VARIANT var;
	VariantInit(&var);
	V_VT(&var) = VT_NULL;
	pClass->Put(wszProperty, 0, &var, CIM_STRING);

	if (bKey)
	{
		V_VT(&var) = VT_BOOL;
		V_BOOL(&var) = TRUE;
		IWbemQualifierSet *pQualifierSet = 0;
		pClass->GetPropertyQualifierSet(L"key", &pQualifierSet);
		pQualifierSet->Put(L"key", &var, 0);
		pQualifierSet->Release();
	}

	VariantClear(&var);
	return true;
}

bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue)
{
	VARIANT var;
	VariantInit(&var);
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = SysAllocString(wszPropertyValue);

	pInstance->Put(wszProperty, 0, &var, CIM_STRING);


	VariantClear(&var);
	return true;
}

bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance)
{
	_IWmiObject *pInstance = NULL;
	IWbemClassObject *pInst2 = NULL;
	pClass->SpawnInstance(0, &pInst2);
	pInst2->QueryInterface(IID__IWmiObject, (void**)&pInstance);
	pInst2->Release();

	SetInstanceProperty(pInstance, L"key", wszKey);

	*ppInstance = pInstance;

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\testcache.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiCache.h"
#include "WmiFinalizer.h"
#include <arrtempl.h>
#include <cominit.h>

extern bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass);
extern bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey);
extern bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue);
extern bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance);
extern void TestCache();
extern void TestFinalizer();
extern void TestArbitrator();

#define ITER_COUNT 10000
void TestCache()
{

    InitializeCom();

	CWmiCache *pCache = new CWmiCache;

	_IWmiObject *pClass = NULL;
	CreateClass(L"Class1", &pClass);
	AddClassProperty(pClass, L"key", true);
	pClass->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");
	if (FAILED(pCache->AddObject(0, pClass)))
		MessageBox(NULL, "Class1", "Failed to add class", MB_OK);

	_IWmiObject *pInstance = NULL;

	int i;

	for (i = 0; i < ITER_COUNT; i++)
	{
		wchar_t buff[100];
		char buff2[100];
		swprintf(buff, L"Instance %d", i);
		sprintf(buff2, "Instance %d", i);
		CreateInstance(pClass, buff, &pInstance);
		pInstance->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");
		if (FAILED(pCache->AddObject(0, pInstance)))
			MessageBox(NULL, buff2, "Failed to add object", MB_OK);
		pInstance->Release();
	}

	pClass->Release();
	

	pClass = NULL;
	if (FAILED(pCache->GetByPath(NULL, L"\\\\MyMachine\\root\\foo\\boo\\goo:Class1", &pClass)))
		MessageBox(NULL, "\\\\MyMachine\\root\\foo\\boo\\goo:Class1", "Failed to add object", MB_OK);
	if (pClass)
		pClass->Release();

	pInstance = NULL;
	for (i = 0; i < ITER_COUNT; i++)
	{
		wchar_t buff[150];
		char buff2[100];
		swprintf(buff, L"\\\\MyMachine\\root\\foo\\boo\\goo:Class1.key=\"Instance %d\"", i);
		sprintf(buff2,  "\\\\MyMachine\\root\\foo\\boo\\goo:Class1.key=\"Instance %d\"", i);
		if (FAILED(pCache->GetByPath(NULL, buff, &pInstance)))
			MessageBox(NULL, buff2, "Failed to GetByPath", MB_OK);
		if (pInstance)
			pInstance->Release();
	}


	pCache->BeginEnum(0, NULL);
	_IWmiObject *pObj = NULL;
	ULONG uRet = 0;
	i = 0;
	while (SUCCEEDED(pCache->Next(1, &pObj, &uRet)) && (uRet == 1))
	{
		if (pObj)
			pObj->Release();
		pObj = NULL;
		i++;	
	}
	if (i != (ITER_COUNT + 1))
		MessageBox(NULL, "Not enough items in cache when iterating through whole list!", "Count Error", MB_OK);

	delete pCache;

	CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\pcatest\testfinalizer.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "wbemint.h"
#include "wbemcli.h"
#include "WmiFinalizer.h"
#include "WmiArbitrator.h"
#include <cominit.h>


extern bool CreateClass(const wchar_t *wszClassName, _IWmiObject **ppClass);
extern bool AddClassProperty(_IWmiObject *pClass, const wchar_t *wszProperty, bool bKey);
extern bool SetInstanceProperty(_IWmiObject *pInstance, const wchar_t *wszProperty, const wchar_t *wszPropertyValue);
extern bool CreateInstance(_IWmiObject *pClass, const wchar_t *wszKey, _IWmiObject **ppInstance);
extern void TestCache();
extern void TestFinalizer();
extern void TestArbitrator();

void TestASync();
void TestEnumerator();

void TestFinalizer()
{
	InitializeCom();

	TestASync();
	TestEnumerator();

	CoUninitialize();
}


class CDestSink : public IWbemObjectSinkEx
{
private:
	LONG m_lRefCount;
	HANDLE m_hEvent;

public:
	CDestSink() : m_lRefCount(0) { m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);}
	~CDestSink() {CloseHandle(m_hEvent);}

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD (Indicate)(
        long lObjectCount,
        IWbemClassObject** apObjArray
        )
	{
		while (lObjectCount)
		{
			apObjArray[lObjectCount-1]->Release();

			lObjectCount--;
		}

		return WBEM_NO_ERROR;
	}


    STDMETHOD( SetStatus)(
        long lFlags,
        HRESULT hResult,
        BSTR strParam,
        IWbemClassObject* pObjParam
        )
	{
		SetEvent(m_hEvent);
		return WBEM_NO_ERROR;
	}

    STDMETHOD( Set)(
        long lFlags,
        REFIID riid,
        void *pComObject
        )
	{
		return WBEM_NO_ERROR;
	}

	void WaitForCompletion()
	{
		WaitForSingleObject(m_hEvent, INFINITE);
	}

};

STDMETHODIMP CDestSink::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink==riid)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;

}

ULONG CDestSink::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG CDestSink::Release()
{
    ULONG uNewCount = InterlockedDecrement(&m_lRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}


void TestASync()
{
	CWmiFinalizer *pFinalizer = new CWmiFinalizer;
	pFinalizer->AddRef();

	CDestSink *pDestSink = new CDestSink;
//	pDestSink->AddRef();

	pFinalizer->Configure(WMI_FNLZR_FLAG_DECOUPLED, NULL);

	pFinalizer->SetDestinationSink(0, IID_IWbemObjectSinkEx, (void*)pDestSink);

	_IWmiObject *pClass = NULL;
	CreateClass(L"Class1", &pClass);
	AddClassProperty(pClass, L"key", true);
	pClass->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");

	
	IWbemObjectSinkEx *pSink = NULL;
	pFinalizer->NewInboundSink(0, &pSink);
	pSink->AddRef();

	IWbemClassObject *pObj = pClass;


	for (int i = 0; i < 100000; i++)
	{
		IWbemClassObject *pObj1;

		pObj->Clone(&pObj1);
//		printf("Indicating pointer 0x%p\n", pObj1);
		pSink->Indicate(1, &pObj1);
		pObj1->Release();
	}

	pSink->SetStatus(0,WBEM_NO_ERROR,L"Boo",pObj);

	pSink->Release();

	pClass->Release();

	Sleep(10000);

	//Finalizer is self destructing!
//	pFinalizer->Release();

}




















void TestEnumerator()
{
	CWmiFinalizer *pFinalizer = new CWmiFinalizer;
	pFinalizer->AddRef();

//	pFinalizer->Configure(WMI_FNLZR_FLAG_FAST_TRACK, NULL);
	pFinalizer->Configure(WMI_FNLZR_FLAG_DECOUPLED, NULL);

	IEnumWbemClassObject *pEnum= NULL;
	pFinalizer->GetResultObject(0, IID_IEnumWbemClassObject, (void**)&pEnum);
	pEnum->AddRef();

	_IWmiObject *pClass = NULL;
	CreateClass(L"Class1", &pClass);
	AddClassProperty(pClass, L"key", true);
	pClass->SetDecoration(L"MyMachine", L"root\\foo\\boo\\goo");

	IWbemObjectSinkEx *pSink = NULL;
	pFinalizer->NewInboundSink(0, &pSink);

	IWbemClassObject *pObj = pClass;

	for (int i = 0; i < 10000; i++)
	{
		IWbemClassObject *pObj1;

		pObj->Clone(&pObj1);
		printf("Indicating object 0x%p into sink\n", pObj1);
		pSink->Indicate(1, &pObj1);
		pObj1->Release();
	}

	printf("Calling SetStatus with object of 0x%p\n", pObj);
	pSink->SetStatus(0,WBEM_NO_ERROR,L"Boo",pObj);
	pSink->Release();

	pClass->Release();


	IWbemClassObject *pEnumedObj = 0;
	do
	{
		ULONG nNum;
		HRESULT hRes = pEnum->Next(INFINITE, 1, &pEnumedObj, &nNum);

		if (hRes == WBEM_S_FALSE)
		{
			printf("Enumerator has no more items to return.\n");
			break;
		}
		if (SUCCEEDED(hRes))
		{
			printf("Enumerator returned 0x%p\n", pEnumedObj);
			pEnumedObj->Release();
		}
		else
			break;

	} while (1);


	pEnum->Release();

	pFinalizer->Release();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\aggreg.h ===
//******************************************************************************
//
//  AGGREG.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#ifndef __WBEM_AGGREGATOR__H_
#define __WBEM_AGGREGATOR__H_

#include <stdio.h>
#include <wbemcomn.h>
#include "tss.h"
#include "binding.h"
#include <evaltree.h>
#include "postpone.h"

class CEventAggregator : public COwnedEventSink
{
protected:
    long m_lNumProperties; // immutable
    CPropertyName* m_aProperties; // immutable
    double m_fTolerance; // immutable

    CEssNamespace* m_pNamespace; // immutable
    CEvalTree* m_pHavingTree; // immutable

    CCritSec m_cs;
    static IWbemClassObject* mstatic_pClass;

    class CBucket
    {
    protected:
        IWbemEvent* m_pRepresentative;
        DWORD m_dwCount;
        CVarVector* m_pvvData;
    public:
        CBucket(IWbemEvent* pEvent, CVarVector* pvvData);
        ~CBucket();

        BOOL CompareTo(CVarVector& vv);
        HRESULT AddEvent(IWbemEvent* pEvent);
        HRESULT MakeAggregateEvent(IWbemEvent** ppAggEvent) NOCS;
        CBucket* Clone();
    };

    class CBucketInstruction : public CTimerInstruction
    {
        long m_lRefCount;
        CEventAggregator* m_pAggregator;
        CBucket* m_pBucket;
        CWbemInterval m_Interval;

    public:
        CBucketInstruction(CEventAggregator* pAggregator, CBucket* pBucket,
                            double fMsTimeout);
        ~CBucketInstruction();
        INTERNAL CEventAggregator* GetAggregator() {return m_pAggregator;}

        void AddRef();
        void Release();
        int GetInstructionType();
    
        CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
            OUT long* plFiringCount) const;
        CWbemTime GetFirstFiringTime() const;
        HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
    };

    class CAggregatorInstructionTest : public CInstructionTest
    {
        CEventAggregator* m_pAgg;
    public:
        CAggregatorInstructionTest(CEventAggregator* pAgg) : m_pAgg(pAgg){}

        BOOL operator()(CTimerInstruction* pToTest);
    };

    friend CBucket;
    friend CBucketInstruction;

    CUniquePointerArray<CBucket> m_apBuckets; // changes

public:
    CEventAggregator(CEssNamespace* pNamespace, CAbstractEventSink* pDest);

    ~CEventAggregator();

    HRESULT Deactivate(bool bFire);

    HRESULT SetQueryExpression(CContextMetaData* pMeta, 
                                QL_LEVEL_1_RPN_EXPRESSION* pExpr);

    HRESULT CopyStateTo(CEventAggregator* pOther);
    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext);

    CEventFilter* GetEventFilter() {return m_pOwner->GetEventFilter();}
public:
    static HRESULT Initialize(IWbemServices* pNamespace);
    static HRESULT Shutdown();

protected:
    HRESULT DispatchBucket(CBucket* pBucket);
    HRESULT ComputeAggregationVector(IN IWbemEvent* pEvent,
                                     OUT CVarVector& vv);
    HRESULT Process(IWbemEvent* pEvent);
    HRESULT AddEventToBucket(IWbemEvent* pEvent, 
            ACQUIRE CVarVector* pvv, CBucket** ppCreatedBucket);
    HRESULT PostponeFireAllBuckets();
    HRESULT FireEvent(IWbemClassObject* pAggEvent, bool bRightNow);
    HRESULT PostponeDispatchFirstBucket();
    HRESULT PostponeIndicate(CAbstractEventSink* pDest, IWbemEvent* pEvent);
};

class CPostponedIndicate : public CPostponedRequest
{
protected:
    CAbstractEventSink* m_pDest;
    IWbemEvent* m_pEvent;
public:
    CPostponedIndicate(CAbstractEventSink* pDest, IWbemEvent* pEvent)
        : m_pDest(pDest), m_pEvent(pEvent)
    {
        if(m_pDest)
            m_pDest->AddRef();
        if(m_pEvent)
            m_pEvent->AddRef();
    }
    ~CPostponedIndicate()
    {
        if(m_pDest)
            m_pDest->Release();
        if(m_pEvent)
            m_pEvent->Release();
    }

    HRESULT Execute(CEssNamespace* pNamespace)
    {
        // BUGBUG: context
        if(m_pDest)
            return m_pDest->Indicate(1, &m_pEvent, NULL);
        else
            return WBEM_E_OUT_OF_MEMORY;
    }
};

        
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\aggreg.cpp ===
//******************************************************************************
//
//  AGGREG.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include "ess.h"
#include "aggreg.h"

IWbemClassObject* CEventAggregator::mstatic_pClass = NULL;

CEventAggregator::CEventAggregator(CEssNamespace* pNamespace, 
                                    CAbstractEventSink* pDest)
        : COwnedEventSink(pDest), m_aProperties(NULL), m_pNamespace(pNamespace),
            m_lNumProperties(0), m_pHavingTree(NULL)
{
}

CEventAggregator::~CEventAggregator()
{
    delete [] m_aProperties;
    delete m_pHavingTree;
}

HRESULT CEventAggregator::SetQueryExpression(CContextMetaData* pMeta, 
                                              QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Check that, if aggregation is required, tolerance is specified
    // ==============================================================

    if(!pExpr->bAggregated)
    {
        return WBEM_E_CRITICAL_ERROR; // internal error
    }

    if(pExpr->bAggregated && pExpr->AggregationTolerance.m_bExact)
    {
        ERRORTRACE((LOG_ESS, "Event aggregation query specified GROUP BY, but "
            "not GROUP WITHIN.  This query is invalid and will not be acted "
            "upon\n"));
        return WBEM_E_MISSING_GROUP_WITHIN;
    }

    m_fTolerance = pExpr->AggregationTolerance.m_fTolerance;
    if(m_fTolerance < 0)
        return WBEM_E_INVALID_PARAMETER;

    // Check that all properties are valid
    // ===================================

    if(pExpr->bAggregateAll)
    {
        ERRORTRACE((LOG_ESS, "Aggregating based on all properties of an event "
            "is not supported\n"));
        return WBEM_E_MISSING_AGGREGATION_LIST;
    }

    // Get the class
    // =============

    _IWmiObject* pClass = NULL;
    pMeta->GetClass(pExpr->bsClassName, &pClass);
    if(pClass == NULL)
    {
        return WBEM_E_INVALID_CLASS;
    }
    CReleaseMe rm1(pClass);

    // Allocate the array to hold property names
    // =========================================

    delete [] m_aProperties;
    m_lNumProperties = pExpr->nNumAggregatedProperties;
    m_aProperties = new CPropertyName[m_lNumProperties];
    if(m_aProperties == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    int i;
    for(i = 0; i < pExpr->nNumAggregatedProperties; i++)
    {
        CPropertyName& PropName = pExpr->pAggregatedPropertyNames[i];

        // Check existence
        // ===============

        CIMTYPE ct;
        if(FAILED(pClass->Get((LPWSTR)PropName.GetStringAt(0), 0, NULL, 
                                &ct, NULL)))
        {
            ERRORTRACE((LOG_ESS, "Invalid aggregation property %S --- not a "
                "member of class %S\n", (LPWSTR)PropName.GetStringAt(0),
                pExpr->bsClassName));
                
            return WBEM_E_INVALID_PROPERTY;
        }
  
        if(PropName.GetNumElements() > 1 && ct != CIM_OBJECT)
        {
            return WBEM_E_PROPERTY_NOT_AN_OBJECT;
        }
        if(PropName.GetNumElements() == 1 && ct == CIM_OBJECT)
        {
            return WBEM_E_AGGREGATING_BY_OBJECT;
        }
        m_aProperties[i] = PropName;
    }
            
    // Initialize post-evaluator with the data from the HAVING clause
    // ==============================================================

    QL_LEVEL_1_RPN_EXPRESSION* pHavingExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
    if(pHavingExpr == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pHavingExpr->SetClassName(L"__AggregateEvent");
    
    for(i = 0; i < pExpr->nNumHavingTokens; i++)
    {
        pHavingExpr->AddToken(pExpr->pArrayOfHavingTokens[i]);
    }

    delete m_pHavingTree;
    m_pHavingTree = new CEvalTree;
    if(m_pHavingTree == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    
    hres = m_pHavingTree->CreateFromQuery(pMeta, pHavingExpr, 0);
    delete pHavingExpr;

    return hres;
}

HRESULT CEventAggregator::Initialize(IWbemServices* pNamespace)
{
    return pNamespace->GetObject( CWbemBSTR( L"__AggregateEvent" ), 
                                  0, 
                                  GetCurrentEssContext(),
                                  &mstatic_pClass, NULL );
}

HRESULT CEventAggregator::Shutdown()
{
    if(mstatic_pClass)
        mstatic_pClass->Release();
    mstatic_pClass = NULL;

    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::Indicate(long lNumEvents, IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hresGlobal = S_OK;

    //
    // Note: we are going to lose the event's security context, but that is OK,
    // since the security check has already been done.
    //

    for(long i = 0; i < lNumEvents; i++)
    {
        HRESULT hres = Process(apEvents[i]);
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

HRESULT CEventAggregator::Process(IWbemEvent* pEvent)
{
    // Compute the event's aggregation vector
    // ======================================

    CVarVector* pvv = _new CVarVector;
    if(pvv == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = ComputeAggregationVector(pEvent, *pvv);
    if(FAILED(hres))
    {
        delete pvv;
        return hres;
    }

    // Add event to the right bucket, creating one if needed.
    // THIS CALL ACQUIRES pvv!!!
    // ======================================================

    CBucket* pCreatedBucket = NULL;
    hres = AddEventToBucket(pEvent, pvv, &pCreatedBucket);
    if(FAILED(hres))
    {
        return hres;
    }

    if(pCreatedBucket)
    {
        // Create a timer instruction to empty this bucket
        // ===============================================
        
        CBucketInstruction* pInst = 
            _new CBucketInstruction(this, pCreatedBucket, m_fTolerance);
        if(pInst == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        pInst->AddRef();
        hres = m_pNamespace->GetTimerGenerator().Set(pInst, 
                                                        CWbemTime::GetZero());
        pInst->Release();
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Failed to schedule aggregation instruction %p"
                "\n", pInst));
            return hres;
        }
    }
    
    return S_OK;
}

HRESULT CEventAggregator::AddEventToBucket(IWbemEvent* pEvent, 
            ACQUIRE CVarVector* pvv, CBucket** ppCreatedBucket)
{
    // Search for a matching bucket
    // ============================

    CInCritSec ics(&m_cs);

    BOOL bFound = FALSE;
    for(int i = 0; i < m_apBuckets.GetSize(); i++)
    {
        CBucket* pBucket = m_apBuckets[i];
        if(pBucket->CompareTo(*pvv))
        {
            HRESULT hres = pBucket->AddEvent(pEvent);
            delete pvv;
            *ppCreatedBucket = NULL;
            return hres;
        }
    }

    // Need a _new bucket
    // ==================

    CBucket* pBucket = _new CBucket(pEvent, pvv); // takes over pvv
    if(pBucket == NULL)
    {
        delete pvv; 
        return WBEM_E_OUT_OF_MEMORY;
    }

    if(m_apBuckets.Add(pBucket) < 0)
    {
        delete pBucket;
        return WBEM_E_OUT_OF_MEMORY;
    }
    *ppCreatedBucket = pBucket;
    return S_OK;
}

HRESULT CEventAggregator::ComputeAggregationVector(
                                        IN IWbemEvent* pEvent,
                                        OUT CVarVector& vv)
{
    HRESULT hres;
    
    IWbemPropertySource* pPropSource = NULL;
    if(FAILED(pEvent->QueryInterface(IID_IWbemPropertySource, 
        (void**)&pPropSource)))
    {
        return E_NOINTERFACE;
    }

    CReleaseMe rm1(pPropSource);

    // Go through all the properties and add their values to the array
    // ===============================================================

    for(int i = 0; i < m_lNumProperties; i++)
    {
        CPropertyName& PropName = m_aProperties[i];
        
        // Get the value
        // =============

        VARIANT v;
        VariantInit(&v);
        hres = pPropSource->GetPropertyValue(&PropName, 0, NULL, &v);
        if(FAILED(hres))
            return hres;
    
        // Add it to the array
        // ===================

        CVar* pVar = _new CVar;
        if(pVar == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        pVar->SetVariant(&v);
        VariantClear(&v);
        
        if(vv.Add(pVar) < 0)  // ACQUIRES pVar
        {
            delete pVar;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::PostponeDispatchFirstBucket()
{
    HRESULT hres;

    //
    // Construct the aggregate event while locked
    //

    IWbemEvent* pAggEvent = NULL;
    {
        CInCritSec ics(&m_cs);

        if(m_apBuckets.GetSize() == 0)
            return WBEM_S_FALSE;

        hres = m_apBuckets[0]->MakeAggregateEvent(&pAggEvent);
        if(FAILED(hres))
            return hres;

        m_apBuckets.RemoveAt(0);
    }

    CReleaseMe rm1(pAggEvent);
    return FireEvent(pAggEvent, false);
}

HRESULT CEventAggregator::DispatchBucket(CBucket* pBucket)
{
    // Search for the bucket
    // =====================
    
    IWbemEvent* pAggEvent = NULL;
    {
        CInCritSec ics(&m_cs);
    
        BOOL bFound = FALSE;
        for(int i = 0; i < m_apBuckets.GetSize(); i++)
        {
            if(m_apBuckets[i] == pBucket)
            {
                // Found it. Construct its event
                // =============================
    
                HRESULT hres = pBucket->MakeAggregateEvent(&pAggEvent);
            
                if(FAILED(hres))
                {
                    ERRORTRACE((LOG_ESS, "Could not create an aggregate event: "
                                    "%X\n", hres));
                    return hres;
                }

                // Delete the bucket
                // =================

                m_apBuckets.RemoveAt(i);
                break;
            }
        }
    }

    if(pAggEvent == NULL)
    {
        // No bucket!
        // ==========

        return WBEM_E_CRITICAL_ERROR; // internal error
    }

    CReleaseMe rm1(pAggEvent);

    //
    // We can fire this event directly on this thread, as it is ours
    //

    return FireEvent(pAggEvent, true);
}

HRESULT CEventAggregator::FireEvent(IWbemClassObject* pAggEvent,
                                    bool bRightNow)
{
    // Constructed aggregate. Decorate it
    // ==================================

    HRESULT hrDec = m_pNamespace->DecorateObject(pAggEvent);
    if (FAILED(hrDec))
    	return hrDec;
    
    // Check HAVING query
    // ==================

    BOOL bResult;
    CSortedArray aTrues;
    IWbemObjectAccess* pAccess;
    pAggEvent->QueryInterface(IID_IWbemObjectAccess, (void**)&pAccess);
    if(FAILED(m_pHavingTree->Evaluate(pAccess, aTrues)))
    {
        bResult = FALSE;
    }
    else
    {
        bResult = (aTrues.Size() > 0);
    }
    pAccess->Release();

    if(bResult)
    {
        // Get destination pointer, protecting from Deactivation
        // =====================================================

        CAbstractEventSink* pDest = NULL;
        {
            CInCritSec ics(&m_cs);
            pDest = m_pOwner;
            if(pDest)
                pDest->AddRef();
        }

        if(pDest)
        {
            if(bRightNow)
                pDest->Indicate(1, &pAggEvent, NULL);
            else
                PostponeIndicate(pDest, pAggEvent);

            pDest->Release();
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::PostponeIndicate(CAbstractEventSink* pDest,
                                            IWbemEvent* pEvent)
{
    CPostponedList* pList = GetCurrentPostponedEventList();
    if(pList == NULL)
        return pDest->Indicate(1, &pEvent, NULL);

    CPostponedIndicate* pReq = new CPostponedIndicate(pDest, pEvent);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    return pList->AddRequest( m_pNamespace, pReq );
}

    
HRESULT CEventAggregator::Deactivate(bool bFire)
{
    HRESULT hres;

    //
    // First remove all timer instructions that may still be scheduled.
    // Timer instructions have a ref-count on us (and therefore our owner),
    // so we may not disconnect until we are done
    //

    CAggregatorInstructionTest Test(this);
    CTimerGenerator& Generator = m_pNamespace->GetTimerGenerator();
    hres = Generator.Remove(&Test);

    //
    // If requested, fire all buckets, albeit not right now
    //

    if(bFire)
        PostponeFireAllBuckets();
        
    Disconnect();
    return hres;
}

HRESULT CEventAggregator::PostponeFireAllBuckets()
{
    HRESULT hres;
    while((hres = PostponeDispatchFirstBucket()) != S_FALSE);

    if(FAILED(hres))
        return hres;
    else
        return WBEM_S_NO_ERROR;
}
        
    
HRESULT CEventAggregator::CopyStateTo(CEventAggregator* pDest)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apBuckets.GetSize(); i++)
    {
        CBucket* pNewBucket = m_apBuckets[i]->Clone();
        if(pNewBucket == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(pDest->m_apBuckets.Add(pNewBucket) < 0)
        {
            delete pNewBucket;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return S_OK;
}
        





CEventAggregator::CBucket::CBucket(IWbemEvent* pEvent, 
                                   CVarVector* pvvData)
    : m_pvvData(pvvData), m_dwCount(1), m_pRepresentative(NULL)
{
    pEvent->Clone(&m_pRepresentative);
}

CEventAggregator::CBucket::~CBucket() 
{
    delete m_pvvData;
    if(m_pRepresentative)
        m_pRepresentative->Release();
}

BOOL CEventAggregator::CBucket::CompareTo(CVarVector& vv)
{
    return m_pvvData->CompareTo(vv, TRUE);
}

HRESULT CEventAggregator::CBucket::AddEvent(IWbemEvent* pEvent)
{
    // Just increment the number of events in the bucket
    // =================================================

    m_dwCount++;
    return WBEM_S_NO_ERROR;
}

HRESULT CEventAggregator::CBucket::MakeAggregateEvent(
                                      IWbemClassObject** ppAggregateEvent) NOCS
{
    HRESULT hres;

    // Create an instance of the aggregate event class
    // ===============================================

    if(mstatic_pClass == NULL)
        return WBEM_E_SHUTTING_DOWN;

    IWbemClassObject* pAgg;
    hres = mstatic_pClass->SpawnInstance(0, &pAgg);
    if(FAILED(hres)) return hres;

    // Fill in the number of events in the bucket
    // ==========================================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_I4;
    V_I4(&v) = (long)m_dwCount;

    hres = pAgg->Put(L"NumberOfEvents", 0, &v, NULL);
    if(FAILED(hres)) 
    {
        pAgg->Release();
        return hres;
    }

    // Fill in the representative
    // ==========================

    V_VT(&v) = VT_EMBEDDED_OBJECT;
    V_EMBEDDED_OBJECT(&v) = m_pRepresentative;

    hres = pAgg->Put(L"Representative", 0, &v, NULL);
    if(FAILED(hres)) 
    {
        pAgg->Release();
        return hres;
    }

    *ppAggregateEvent = pAgg;
    return WBEM_S_NO_ERROR;
}

CEventAggregator::CBucket* CEventAggregator::CBucket::Clone()
{
    CVarVector* pNewVv = new CVarVector(*m_pvvData);
    if(pNewVv == NULL)
        return NULL;
    CBucket* pNewBucket = new CBucket(m_pRepresentative, pNewVv);
    if(pNewBucket == NULL)
    {
        delete pNewVv;
        return NULL;
    }
    pNewBucket->m_dwCount = m_dwCount;
    return pNewBucket;
}











CEventAggregator::CBucketInstruction::CBucketInstruction(
            CEventAggregator* pAggregator, CBucket* pBucket, double fSTimeout)
    : m_pAggregator(pAggregator), m_pBucket(pBucket), m_lRefCount(0)
{
    m_Interval.SetMilliseconds(fSTimeout * 1000);
    m_pAggregator->AddRef();
}

CEventAggregator::CBucketInstruction::~CBucketInstruction()
{
    m_pAggregator->Release();
}

void CEventAggregator::CBucketInstruction::AddRef()
{
    InterlockedIncrement(&m_lRefCount);
}

void CEventAggregator::CBucketInstruction::Release()
{
    if(InterlockedDecrement(&m_lRefCount) == 0)
        delete this;
}

int CEventAggregator::CBucketInstruction::GetInstructionType()
{
    return INSTTYPE_AGGREGATION;
}

CWbemTime CEventAggregator::CBucketInstruction::GetNextFiringTime(
        CWbemTime LastFiringTime, OUT long* plFiringCount) const
{
    // Only fires once.
    // ================

    return CWbemTime::GetInfinity();
}

CWbemTime CEventAggregator::CBucketInstruction::GetFirstFiringTime() const
{
    // In "interval" ms from now
    // =========================

    return CWbemTime::GetCurrentTime() + m_Interval;
}

HRESULT CEventAggregator::CBucketInstruction::Fire(long lNumTimes, 
                                                   CWbemTime NextFiringTime)
{
    m_pAggregator->DispatchBucket(m_pBucket);
    return WBEM_S_NO_ERROR;
}

BOOL CEventAggregator::CAggregatorInstructionTest::
operator()(
        CTimerInstruction* pToTest)
{
    if(pToTest->GetInstructionType() == INSTTYPE_AGGREGATION)
    {
        CBucketInstruction* pInst = (CBucketInstruction*)pToTest;
        return (pInst->GetAggregator() == m_pAgg);
    }
    else return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\binding.cpp ===
//******************************************************************************
//
//  BINDING.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <pragmas.h>
#include <ess.h>
#include <permbind.h>
#include <cominit.h>
#include <callsec.h>
#include <wmimsg.h>
#include <vector>
#include "Quota.h"

#define MIN_TIMEOUT_BETWEEN_TOKEN_ATTEMPTS 60000

//*****************************************************************************
//
//  Syncronization model:
//
//  1. Bindings themselves are immutable and do not require protection. 
//  2. Releasing a binding (removing from table) can release the other end-point
//      and generally cannot be done in a CS.
//
//*************************** Event Consumer **********************************

long g_lNumConsumers = 0;
long g_lNumBindings = 0;
long g_lNumFilters = 0;

CEventConsumer::CEventConsumer( CEssNamespace* pNamespace )
: CQueueingEventSink(pNamespace), m_pOwnerSid(NULL)
{
    InterlockedIncrement( &g_lNumConsumers );
}

CEventConsumer::~CEventConsumer()
{
    InterlockedDecrement( &g_lNumConsumers );
    delete [] m_pOwnerSid;
}

HRESULT CEventConsumer::EnsureReferences(CEventFilter* pFilter, 
                                            CBinding* pBinding)
{
    CBinding* pOldBinding = NULL;
    {
        CInCritSec ics(&m_cs);
    
        for(int i = 0; i < m_apBindings.GetSize(); i++)
        {
            if(m_apBindings[i]->GetFilter() == pFilter)
            {
                // Replace the binding
                // ===================
    
                m_apBindings.SetAt(i, pBinding, &pOldBinding);
                break;
            }
        }

        if(pOldBinding == NULL)
        {
            // Add it to the list
            // ==================
    
            if(m_apBindings.Add(pBinding) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    if(pOldBinding)
    {
        // Found
        // =====

        pOldBinding->Release();
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

HRESULT CEventConsumer::EnsureNotReferences(CEventFilter* pFilter)
{
    CBinding* pOldBinding = NULL;

    {
        CInCritSec ics(&m_cs);
    
        for(int i = 0; i < m_apBindings.GetSize(); i++)
        {
            if(m_apBindings[i]->GetFilter() == pFilter)
            {
                // Remove the binding
                // ==================
    
                m_apBindings.RemoveAt(i, &pOldBinding);
                break;
            }
        }
    }

    if(pOldBinding)
    {
        pOldBinding->Release();
        return S_OK;
    }
    else
    {
        // Not found
        // =========
    
        return S_FALSE;
    }
}

HRESULT CEventConsumer::Unbind()
{
    // Unbind the binding array from the consumer
    // ==========================================

    CBinding** apBindings = NULL;
    int nNumBindings = 0;

    {
        CInCritSec ics(&m_cs);
        nNumBindings = m_apBindings.GetSize();
        apBindings = m_apBindings.UnbindPtr();

        if ( NULL == apBindings )
        {
            return WBEM_S_FALSE;
        }
    }
    
    // Instruct all the filters that are bound to us to unbind
    // =======================================================

    HRESULT hres = S_OK;

    for(int i = 0; i < nNumBindings; i++)
    {
        HRESULT hr = apBindings[i]->GetFilter()->EnsureNotReferences(this);
        if( FAILED( hr ) ) 
        {
            hres = hr;
        }
        apBindings[i]->Release();
    }

    delete [] apBindings;

    return hres;
}

HRESULT CEventConsumer::ConsumeFromBinding(CBinding* pBinding, 
                                long lNumEvents, IWbemEvent** apEvents,
                                CEventContext* pContext)
{
    DWORD dwQoS = pBinding->GetQoS();

    if( dwQoS == WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        // Synchronous delivery --- call the ultimate client
        // =================================================

        IUnknown* pOldSec = NULL;
        HRESULT hr;
        
        if(!pBinding->IsSecure())
        {
            hr = CoSwitchCallContext(NULL, &pOldSec);
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }

        HRESULT hres = ActuallyDeliver( lNumEvents, 
                                        apEvents, 
                                        pBinding->IsSecure(), 
                                        pContext );

        if(!pBinding->IsSecure())
        {
            IUnknown* pGarb = NULL;

            hr = CoSwitchCallContext(pOldSec, &pGarb);
            if ( FAILED( hr ) && SUCCEEDED ( hres ) )
            {
                return hr;
            }
        }

        return hres;
    }

    // Asynchronous delivery --- delegate to queueing sink
    // ===================================================
    
    return CQueueingEventSink::SecureIndicate( lNumEvents, 
                                               apEvents,
                                               pBinding->IsSecure(), 
                                               pBinding->ShouldSlowDown(),
                                               dwQoS,
                                               pContext );
}

HRESULT CEventConsumer::GetAssociatedFilters(
                            CRefedPointerSmallArray<CEventFilter>& apFilters)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apBindings.GetSize(); i++)
    {
        if(apFilters.Add(m_apBindings[i]->GetFilter()) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventConsumer::ReportEventDrop(IWbemEvent* pEvent)
{
    // Log a message
    // =============

    ERRORTRACE((LOG_ESS, "Dropping event destined for event consumer %S in "
            "namespace %S\n", (LPCWSTR)(WString)GetKey(), 
                                m_pNamespace->GetName()));

    if(pEvent->InheritsFrom(EVENT_DROP_CLASS) == S_OK)
    {
        ERRORTRACE((LOG_ESS, "Unable to deliver an event indicating inability "
            "to deliver another event to event consumer %S in namespace %S.\n"
            "Not raising an error event to avoid an infinite loop!\n", 
            (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName()));

        return S_FALSE;
    }
    return S_OK;
}
    
//*************************** Event Filter **********************************

CEventFilter::CEventFilter(CEssNamespace* pNamespace) 
    : m_pNamespace(pNamespace), m_eState(e_Inactive), 
        m_ForwardingSink(this), m_ClassChangeSink(this), 
        m_eValidity(e_TemporarilyInvalid), m_pOwnerSid(NULL),
        m_bSingleAsync(false), m_lSecurityChecksRemaining(0),
        m_lSubjectToSDSCount(0), m_hresPollingError(S_OK),
        m_hresFilterError(WBEM_E_CRITICAL_ERROR), m_bCheckSDs(true),
        m_bHasBeenValid(false), m_dwLastTokenAttempt(0), m_pToken(NULL),
        m_bReconstructOnHit(false), m_hresTokenError(WBEM_E_CRITICAL_ERROR)
 {
    InterlockedIncrement( &g_lNumFilters );

    m_pNamespace->AddRef();
}

CEventFilter::~CEventFilter()
{
    InterlockedDecrement( &g_lNumFilters );

    delete [] m_pOwnerSid;

    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pToken)
        m_pToken->Release();
}

HRESULT CEventFilter::EnsureReferences(CEventConsumer* pConsumer, 
                                        CBinding* pBinding)
{
    CBinding* pOldBinding = NULL;

    {
        CInUpdate iu(this);

        // Actually change the bindings
        // ============================

        {
            CInCritSec ics(&m_cs);
        
            for(int i = 0; i < m_apBindings.GetSize(); i++)
            {
                if(m_apBindings[i]->GetConsumer() == pConsumer)
                {
                    // Replace the binding
                    // ===================
        
                    // binding cannot change synchronicity --- in such cases,
                    // it is first removed, and then re-added.  Therefore,
                    // no m_bSingleAsync adjustment is needed

                    m_apBindings.SetAt(i, pBinding, &pOldBinding);
                    break;
                }
            }

            if(pOldBinding == NULL)
            {
                // Add it to the list
                // ==================
        
                if(m_apBindings.Add(pBinding) < 0)
                    return WBEM_E_OUT_OF_MEMORY;

                AdjustSingleAsync();
            }
        }

        // Activate if needed
        // ==================

        AdjustActivation();
    }

    if(pOldBinding)
    {
        // Found
        // =====

        pOldBinding->Release();
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

HRESULT CEventFilter::EnsureNotReferences(CEventConsumer* pConsumer)
{
    CBinding* pOldBinding = NULL;

    {
        CInUpdate iu(this);

        // Make the actual change
        // ======================

        {
            CInCritSec ics(&m_cs);
        
            for(int i = 0; i < m_apBindings.GetSize(); i++)
            {
                if(m_apBindings[i]->GetConsumer() == pConsumer)
                {
                    // Remove the binding
                    // ==================
        
                    m_apBindings.RemoveAt(i, &pOldBinding);

                    AdjustSingleAsync();

                    break;
                }
            } // for
        } // m_cs

        // Deactivate the filter if necessary
        // ==================================

        AdjustActivation();
    } // update

    if(pOldBinding)
    {
        pOldBinding->Release();
        return S_OK;
    }
    else
    {
        // Not found
        // =========
    
        return S_FALSE;
    }
}

HRESULT CEventFilter::Unbind(bool bShuttingDown)
{
    // Unbind the binding array from the filter
    // ========================================
    
    std::vector< CWbemPtr < CBinding >,wbem_allocator< CWbemPtr<CBinding> > > apBindings;
    int nNumBindings = 0;

    {
        CInUpdate iu(this);

        {
            CInCritSec ics(&m_cs);
            nNumBindings = m_apBindings.GetSize();
            apBindings.insert(apBindings.begin(),nNumBindings,CWbemPtr<CBinding>()); // may throw

            CBinding ** ppBindTmp = m_apBindings.UnbindPtr(); //needed to set size to zero
            CVectorDeleteMe<CBinding *> dm(ppBindTmp);
            if ( NULL ==  ppBindTmp)
            {
                return WBEM_S_FALSE;
            }

            for (int Idx=0;Idx<nNumBindings;Idx++)
            {
            	apBindings[Idx].Attach(ppBindTmp[Idx]); // does not AddRef
            }

            m_bSingleAsync = false;
        }

        if(!bShuttingDown)
            AdjustActivation(); // throws
    }

    // Instruct all the consumers that are bound to us to unbind
    // =========================================================

    HRESULT hres = S_OK;

    for(int i = 0; i < nNumBindings; i++)
    {            
        HRESULT hr = apBindings[i]->GetConsumer()->EnsureNotReferences(this);
        if ( FAILED( hr ) ) 
        {
            hres = hr;
        }

        apBindings[i].Release();    // performs the "final" release
    }

    return hres;
}
    
void CEventFilter::SetInactive()
{
    m_eState = e_Inactive;
}

BOOL CEventFilter::IsActive()
{
    return (m_eState == e_Active);
}

HRESULT CEventFilter::GetFilterError()
{
    return m_hresFilterError;
}

HRESULT CEventFilter::GetEventNamespace(LPWSTR* pwszNamespace)
{
    *pwszNamespace = NULL;
    return S_OK;
}

// assumes in m_cs
void CEventFilter::AdjustSingleAsync()
{
    if(m_apBindings.GetSize() > 1)
        m_bSingleAsync = false;
    else if(m_apBindings.GetSize() == 0)
        m_bSingleAsync = false;
    else if(m_apBindings[0]->IsSynch())
        m_bSingleAsync = false;
    else
        m_bSingleAsync = true;
}

bool CEventFilter::IsBound()
{
     return (m_apBindings.GetSize() != 0);
}

// Requires: in m_csChangeBindings
HRESULT CEventFilter::AdjustActivation()
{
    // Invalid filters cannot be activated or deactivated
    // ==================================================

    if(m_eValidity == e_PermanentlyInvalid)
        return S_FALSE;

    HRESULT hres = S_FALSE;
    if(!IsBound() )
    {
        //
        // Even if this filter is not active, it may be subscribed for
        // activation events if it is temporarily invalid (and that's the only
        // reason it is not active). 
        //
        
        m_pNamespace->UnregisterFilterFromAllClassChanges(this);
    
        if(m_eState == e_Active)
        {
            hres = m_pNamespace->DeactivateFilter(this);
            if(FAILED(hres)) return hres;
            m_eState = e_Inactive;
        }
        return WBEM_S_NO_ERROR;
    }
    else if(m_eState == e_Inactive && IsBound() )
    {
        //
        // Even though this filter is not active, it may be subscribed for
        // activation events if it is temporarily invalid (and that's the only
        // reason it is not active). 
        //
        
        m_pNamespace->UnregisterFilterFromAllClassChanges(this);
    
        hres = m_pNamespace->ActivateFilter(this);
        if(FAILED(hres)) return hres;
        m_eState = e_Active;

        return WBEM_S_NO_ERROR;
    }
    else
    {
        return S_FALSE;
    }
}
        
void CEventFilter::MarkAsPermanentlyInvalid(HRESULT hres)
{
    m_eValidity = e_PermanentlyInvalid;
    m_hresFilterError = hres;
}

void CEventFilter::MarkAsTemporarilyInvalid(HRESULT hres)
{
    m_eValidity = e_TemporarilyInvalid;
    m_hresFilterError = hres;
}

void CEventFilter::MarkAsValid()
{
    m_eValidity = e_Valid;
    m_bHasBeenValid = true;
    m_hresFilterError = WBEM_S_NO_ERROR;
}

void CEventFilter::MarkReconstructOnHit(bool bReconstruct)
{
    //
    // Reconstruction is not really needed, since dummer nodes are used for 
    // this
    //

    m_bReconstructOnHit = bReconstruct;
}

HRESULT CEventFilter::CheckEventAccessToFilter( IServerSecurity* pProvCtx )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    const PSECURITY_DESCRIPTOR pEventAccessSD = GetEventAccessSD();

    if ( pEventAccessSD == NULL )
    {
        //
        // filter allows all events 
        //
        return WBEM_S_NO_ERROR;
    }

    //
    // check that the event provider's calling context has access to filter 
    // 

    if ( pProvCtx != NULL )
    {
        hr = pProvCtx->ImpersonateClient();

        if ( SUCCEEDED(hr) )
        {
            HANDLE hToken;

            if ( OpenThreadToken( GetCurrentThread(), 
                                  TOKEN_QUERY,
                                  TRUE,
                                  &hToken ) )
            {
                GENERIC_MAPPING map;
                ZeroMemory( &map, sizeof(GENERIC_MAPPING) );

                PRIVILEGE_SET ps;
                DWORD dwPrivLength = sizeof(ps);
                
                BOOL bStatus;
                DWORD dwGranted;
      
                if ( ::AccessCheck( PSECURITY_DESCRIPTOR(pEventAccessSD), 
                                    hToken,
                                    WBEM_RIGHT_PUBLISH,
                                    &map, 
                                    &ps,
                                    &dwPrivLength, 
                                    &dwGranted, 
                                    &bStatus ) )
                {
                    hr = bStatus ? WBEM_S_NO_ERROR : WBEM_E_ACCESS_DENIED;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                }

                CloseHandle( hToken );
            }
            else
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }

            pProvCtx->RevertToSelf();       
        }
    }

    return hr;
}


HRESULT CEventFilter::CheckFilterAccessToEvent( PSECURITY_DESCRIPTOR pEventSD )
{
    HRESULT hr;
    
    if ( pEventSD == NULL )
    {
        //
        // event provider allows all filters access 
        //
        return WBEM_S_NO_ERROR;
    }

    if( !m_bCheckSDs )
    {
        //
        // This filter was unconditionally allowed by all its event providers!
        //
        return WBEM_S_NO_ERROR;
    }

    //
    // Get the token for this filter
    //

    if( m_pToken == NULL && FAILED(m_hresTokenError) )
    {
        //
        // Check how long it's been since we last attempted to get the token --
        // don't want to do that too often.
        //

        if(m_dwLastTokenAttempt == 0 || 
            m_dwLastTokenAttempt < 
                GetTickCount() - MIN_TIMEOUT_BETWEEN_TOKEN_ATTEMPTS )
        {
            //
            // Get the filter to find a token, however it does that
            //
            m_hresTokenError = ObtainToken( &m_pToken );
            
            if( FAILED(m_hresTokenError) )
            {
                m_dwLastTokenAttempt = GetTickCount();
            }
        }
    }

    if ( m_hresTokenError == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( m_pToken != NULL );

        //
        // Check security for real
        //
        
        DWORD dwGranted;
        hr = m_pToken->AccessCheck( WBEM_RIGHT_SUBSCRIBE, 
                                    (const BYTE*)pEventSD, 
                                    &dwGranted );
        if( SUCCEEDED(hr) )
        {
            if(dwGranted & WBEM_RIGHT_SUBSCRIBE)
            {
                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                hr = WBEM_E_ACCESS_DENIED;
            }
        }
    }
    else 
    {
        hr = m_hresTokenError;
    }

    return hr;
}

HRESULT CEventFilter::AccessCheck( CEventContext* pContext, IWbemEvent* pEvent)
{
    HRESULT hr;

    // 
    // With polling, there will be a null context. we don't do an access 
    // check in that case.
    // 

    if ( pContext == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    PSECURITY_DESCRIPTOR pEventSD = (PSECURITY_DESCRIPTOR)pContext->GetSD();

    //
    // check that the filter allows access to the event provider and owner.
    // owner and provider can be different when the provider is signaling 
    // events on behalf of some other identity.
    // 
    
    CWbemPtr<IServerSecurity> pProvCtx = NULL;
    
    CoGetCallContext( IID_IServerSecurity, (void**)&pProvCtx );

    //
    // NOTE: With cross namespace events, the two parts of the access check 
    // are split up between the namespaces.  The FilterAccessToEvent is 
    // performed in the event's namespace with the temp subscription's
    // AccessCheck.  This is possible because the owner sid is propagated 
    // over with the temp subscription.  The EventAccessToFilter is performed
    // in the subscription namespace.  This is possible because the call 
    // context and the SD of the event ( containing the event owner sid ) 
    // is propagated with the event.  Both functions are called in 
    // both namespaces, but the unnecessary calls turn out to be no-ops.
    // 

    hr = CheckEventAccessToFilter( pProvCtx );

    if ( SUCCEEDED(hr) )
    {
        //
        // check that the event provider allows access to the filter.
        //

        hr = CheckFilterAccessToEvent( pEventSD );
    }

    return hr;
}

HRESULT CEventFilter::Deliver( long lNumEvents, 
                               IWbemEvent** apEvents,
                               CEventContext* pContext )
{
    int i;

    if( m_lSecurityChecksRemaining > 0 )
    {
        return WBEM_S_FALSE;
    }

    CBinding* pBinding = NULL;
    {
        CInCritSec ics(&m_cs);

        if(m_bSingleAsync)
        {
            //
            // Thought we could deliver (call Indicate on the binding) right 
            // here, since single async ensures that no delivery will occur on
            // this thread.  But no --- an error may be raised, and that event
            // will be delivered on this thread, so we must exit the critsec 
            // before calling
            // 
    
            pBinding = m_apBindings[0];
            pBinding->AddRef();
        }
    }

    if( pBinding )
    {
        CReleaseMe rm1(pBinding);
        return pBinding->Indicate( lNumEvents, apEvents, pContext );
    }

    // Make referenced copies of all the bindings to deliver over
    // ==========================================================

    // CANNOT USE SCOPING DUE TO CTempArray --- it uses _alloca

    m_cs.Enter();
    CTempArray<CBinding*> apBindings;
    int nSize = m_apBindings.GetSize();
    if(!INIT_TEMP_ARRAY(apBindings, nSize))
    {
        m_cs.Leave();
        return WBEM_E_OUT_OF_MEMORY;
    }

    {
        for(i = 0; i < nSize; i++)
        {
            CBinding* pBindingInner = m_apBindings[i];
            pBindingInner->AddRef();
            apBindings[i] = pBindingInner;
        }
    }
    
    m_cs.Leave();

    // Deliver and release the bindings
    // ================================

    HRESULT hresGlobal = S_OK;
    for(i = 0; i < nSize; i++)
    {
        CBinding* pBindingInner = apBindings[i];
        HRESULT hres = pBindingInner->Indicate( lNumEvents, apEvents, pContext ); 
        pBindingInner->Release();
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

HRESULT CEventFilter::LockForUpdate()
{
    // Don't need to do anything since the namespace is locked!
/*
    m_csChangeBindings.Enter();
    AddRef();
*/
    return S_OK;
}

HRESULT CEventFilter::UnlockForUpdate()
{
/*
    m_csChangeBindings.Leave();
    Release();
*/
    return S_OK;
}

HRESULT CEventFilter::CEventForwardingSink::Indicate(long lNumEvents, 
                                                        IWbemEvent** apEvents,
                                                        CEventContext* pContext)
{
    return m_pOwner->Deliver(lNumEvents, apEvents, pContext);
}

void CEventFilter::IncrementRemainingSecurityChecks()
{
    InterlockedIncrement(&m_lSecurityChecksRemaining);
    InterlockedIncrement(&m_lSubjectToSDSCount);
}

void CEventFilter::DecrementRemainingSecurityChecks(HRESULT hresProvider)
{
    //
    // The provider could have said;
    //      S_OK: this subscription is fine, send all events through or
    //      S_SUBJECT_TO_SDS: check event security descriptors before sending
    // So, if all the providers gave us a blank check, we won't check security
    // descriptors, but if any did, we will check them all.
    //

    if(hresProvider  != WBEM_S_SUBJECT_TO_SDS)
    {
        if(hresProvider != WBEM_S_NO_ERROR)
        {
            ERRORTRACE((LOG_ESS, "Invalid return code from provider security test: "
                        "0x%X\n", hresProvider));
            return;
        }
        
        InterlockedDecrement(&m_lSubjectToSDSCount);
    }
    

    InterlockedDecrement(&m_lSecurityChecksRemaining);

    if ( 0 == m_lSubjectToSDSCount && 0 == m_lSecurityChecksRemaining )
    {
        m_bCheckSDs = false;
    }
    else
    {
        InterlockedExchange( &m_lSubjectToSDSCount, 0 );
    }
}

HRESULT CEventFilter::SetActualClassChangeSink( IWbemObjectSink* pSink, 
                                                IWbemObjectSink** ppOldSink )
{
    HRESULT hr;

    if ( m_pActualClassChangeSink != NULL )
    {
        m_pActualClassChangeSink->AddRef();
        *ppOldSink = m_pActualClassChangeSink;
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        *ppOldSink = NULL;
        hr = WBEM_S_FALSE;
    }

    m_pActualClassChangeSink = pSink;
    
    return hr;
}

HRESULT CEventFilter::Reactivate()
{
    HRESULT hres;

    // 
    // This is called when a class or something like that changes from
    // from underneath us.
    // What we need to do is lock the namespace, deactivate this filter, then
    // activate it again
    //

    CInUpdate iu(m_pNamespace);

    DEBUGTRACE((LOG_ESS, "Attempting to reactivate filter '%S' in namespace "
                            "'%S'\n",  (LPCWSTR)(WString)GetKey(), 
                                m_pNamespace->GetName()));

    // Invalid filters cannot be activated or deactivated
    // ==================================================

    if(m_eValidity == e_PermanentlyInvalid)
    {
        DEBUGTRACE((LOG_ESS, "Not reactivate filter '%S' in namespace "
                            "'%S': permanently invalid\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName()));
        return S_FALSE;
    }

    if(m_eState == e_Active)
    {
        DEBUGTRACE((LOG_ESS, "Deactivating filter '%S' in namespace "
                            "'%S' prior to reactivation\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName()));
        hres = m_pNamespace->DeactivateFilter(this);
        if(FAILED(hres)) 
        {
            ERRORTRACE((LOG_ESS, "Deactivating filter '%S' in namespace "
                            "'%S' prior to reactivation failed: 0x%X\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName(),
                        hres));
            return hres;
        }
        m_eState = e_Inactive;
    }

    hres = AdjustActivation();

    DEBUGTRACE((LOG_ESS, "Reactivating filter '%S' in namespace "
                            "'%S' returned 0x%X\n",  
                        (LPCWSTR)(WString)GetKey(), m_pNamespace->GetName(),
                        hres));
    return hres;
}

STDMETHODIMP CEventFilter::CClassChangeSink::Indicate( long lNumEvents,
                                                       IWbemEvent** apEvents )
{
    HRESULT hr;

    hr = m_pOuter->Reactivate();

    if ( SUCCEEDED(hr) )
    {
        hr = m_pOuter->m_pNamespace->FirePostponedOperations();
    }
    else
    {
        m_pOuter->m_pNamespace->FirePostponedOperations();
    }

    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Error encountered when reactivating filter '%S' "
                    "due to a class change.  Namespace is '%S', HRES=0x%x\n",
                    (LPCWSTR)(WString)m_pOuter->GetKey(), 
                    m_pOuter->m_pNamespace->GetName(),
                    hr ));
    }

    return hr;
}
 
//***************************** Binding ***************************************

CBinding::CBinding()
 : m_pConsumer(NULL), m_pFilter(NULL), m_dwQoS( WMIMSG_FLAG_QOS_EXPRESS ),
   m_bSlowDown(false), m_bSecure(false), m_bDisabledForSecurity(false)
{
    InterlockedIncrement( &g_lNumBindings );
}

CBinding::CBinding(ADDREF CEventConsumer* pConsumer, 
                        ADDREF CEventFilter* pFilter)
    : m_pConsumer(NULL), m_pFilter(NULL), m_dwQoS( WMIMSG_FLAG_QOS_EXPRESS ),
        m_bSlowDown(false), m_bSecure(false)
{
    InterlockedIncrement( &g_lNumBindings );

    SetEndpoints(pConsumer, pFilter, NULL);
}

HRESULT CBinding::SetEndpoints(ADDREF CEventConsumer* pConsumer, 
                            ADDREF CEventFilter* pFilter,
                            READONLY PSID pBinderSid)
{
    m_pConsumer = pConsumer;
    m_pConsumer->AddRef();
    m_pFilter = pFilter;
    m_pFilter->AddRef();

    // Make sure that the owner of this binding is the same as the
    // owners of the endpoints
    // ==================================================================

    if(pBinderSid && (!EqualSid(pBinderSid, pConsumer->GetOwner()) ||
       !EqualSid(pBinderSid, pFilter->GetOwner())))
    {
        DisableForSecurity();
    }

    return WBEM_S_NO_ERROR;
}
    
void CBinding::DisableForSecurity()
{
    ERRORTRACE((LOG_ESS, "An event binding is disabled because its creator is "
        "not the same security principal as the creators of the endpoints.  "
        "The binding and the endpoints must be created by the same user!\n"));

    m_bDisabledForSecurity = true;
}

CBinding::~CBinding()
{
    InterlockedDecrement( &g_lNumBindings );

    if(m_pConsumer)
        m_pConsumer->Release();
    if(m_pFilter)
        m_pFilter->Release();
}

DWORD CBinding::GetQoS() NOCS
{
    return m_dwQoS;
}

bool CBinding::IsSynch() NOCS
{
    return m_dwQoS == WMIMSG_FLAG_QOS_SYNCHRONOUS;
}

bool CBinding::IsSecure() NOCS
{
    return m_bSecure;
}

bool CBinding::ShouldSlowDown() NOCS
{
    return m_bSlowDown;
}

HRESULT CBinding::Indicate(long lNumEvents, IWbemEvent** apEvents,
                                CEventContext* pContext)
{
    // Check if this binding is active
    // ===============================

    if(m_bDisabledForSecurity)
        return WBEM_S_FALSE;

    // It is: deliver
    // ==============

    return m_pConsumer->ConsumeFromBinding(this, lNumEvents, apEvents, 
                                            pContext);
}

//************************* Consumer watch instruction ************************

CWbemInterval CConsumerWatchInstruction::mstatic_Interval;
CConsumerWatchInstruction::CConsumerWatchInstruction(CBindingTable* pTable)
    : CBasicUnloadInstruction(mstatic_Interval), 
        m_pTableRef(pTable->m_pTableRef)
{
    if(m_pTableRef)
        m_pTableRef->AddRef();
}

CConsumerWatchInstruction::~CConsumerWatchInstruction()
{
    if(m_pTableRef)
        m_pTableRef->Release();
}

void CConsumerWatchInstruction::staticInitialize(IWbemServices* pRoot)
{
    mstatic_Interval = CBasicUnloadInstruction::staticRead(pRoot, GetCurrentEssContext(), 
                                            L"__EventSinkCacheControl=@");
}

HRESULT CConsumerWatchInstruction::Fire(long, CWbemTime)
{
    if(!m_bTerminate)
    {
        CEssThreadObject Obj(NULL);
        SetConstructedEssThreadObject(&Obj);
    
        CEssNamespace* pNamespace = NULL;

        if(m_pTableRef)
        {
            m_pTableRef->GetNamespace(&pNamespace);
            m_pTableRef->UnloadUnusedConsumers(m_Interval);
        }

        Terminate();

        if( pNamespace )
        {
            pNamespace->FirePostponedOperations();
            pNamespace->Release();
        }

        ClearCurrentEssThreadObject();
    }
    return WBEM_S_NO_ERROR; // no point worrying the timer
}

//*************************** Binding Table ************************************

class CConsumersToRelease
{
    CEventConsumer** m_apConsumers;
    int m_nNumConsumers;

public:
    CConsumersToRelease(CEventConsumer** apConsumers, int nNumConsumers) 
        : m_apConsumers(apConsumers), m_nNumConsumers(nNumConsumers)
    {
    }
    ~CConsumersToRelease()
    {
        for(int i = 0; i < m_nNumConsumers; i++)
        {
            m_apConsumers[i]->Shutdown();
            m_apConsumers[i]->Release();
        }
        delete [] m_apConsumers;
    }

    static DWORD Delete(void* p)
    {
        delete (CConsumersToRelease*)p;
        return 0;
    }
};

CBindingTable::CBindingTable(CEssNamespace* pNamespace) 
    : m_pNamespace(pNamespace), m_pInstruction(NULL), 
        m_bUnloadInstruction(FALSE), m_lNumPermConsumers(0), 
        m_pTableRef(NULL)
{
    m_pTableRef = new CBindingTableRef(this);
    if(m_pTableRef)
        m_pTableRef->AddRef();
}


void CBindingTable::Clear( bool bSkipClean )
{
    //
    // Ensure that no more unloading instructions can make it in
    //

    if(m_pTableRef)
    {
        m_pTableRef->Disconnect();
        m_pTableRef->Release();
        m_pTableRef = NULL;
    }

    // Unbind filter and consumer arrays from the table
    // ================================================

    CEventFilter** apFilters;
    int nNumFilters;
    CEventConsumer** apConsumers;
    int nNumConsumers;

    {
        CInCritSec ics(&m_cs);
        nNumFilters = m_apFilters.GetSize();
        apFilters = m_apFilters.UnbindPtr();
        nNumConsumers = m_apConsumers.GetSize();
        apConsumers = m_apConsumers.UnbindPtr();
    }

    int i;

    // Unbind and release all filters
    // ==============================

    if ( apFilters )
    {
        for(i = 0; i < nNumFilters; i++)
        {
            if (!apFilters[i]->IsInternal())
            {
                g_quotas.DecrementQuotaIndex(
                    apFilters[i]->GetOwner() ? ESSQ_PERM_SUBSCRIPTIONS :
                                               ESSQ_TEMP_SUBSCRIPTIONS,
                    apFilters[i],
                    1 );
            }

            apFilters[i]->Unbind(bSkipClean); // shutting down
            apFilters[i]->Release();
        }
        delete [] apFilters;
    }

    //
    // unbind all consumers, but postpone their release. 
    // 

    if ( apConsumers )
    {
        for(i = 0; i < nNumConsumers; i++)
        {
            apConsumers[i]->Unbind(); // shutting down
        }

        //
        // Release all consumers (unbound by virtue of filter unbinding), but do
        // so on a separate thread
        //

        CConsumersToRelease* pToRelease = 
            new CConsumersToRelease(apConsumers, nNumConsumers);
        DWORD dwId;
        HANDLE hThread = CreateThread(NULL, 0, 
            (LPTHREAD_START_ROUTINE)CConsumersToRelease::Delete, pToRelease, 0, 
            &dwId);
        if(hThread == NULL)
        {
            ERRORTRACE((LOG_ESS, "Unable to launch consumer deleting thread: %d\n", 
                  GetLastError()));
        }
        else
        {
            DWORD dwRes = WaitForSingleObject(hThread, INFINITE ); 

            _DBG_ASSERT( WAIT_OBJECT_0 == dwRes );
            CloseHandle(hThread);
        }
    }
}


HRESULT CBindingTable::AddEventFilter(CEventFilter* pFilter)
{
    HRESULT hr;

    if (pFilter->IsInternal() ||
        SUCCEEDED(hr = g_quotas.IncrementQuotaIndex(
        pFilter->GetOwner() ? ESSQ_PERM_SUBSCRIPTIONS : ESSQ_TEMP_SUBSCRIPTIONS,
        pFilter,
        1)))
    {
        CInCritSec ics(&m_cs);

        if (m_apFilters.Add(pFilter) >= 0)
            hr = S_OK;
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CBindingTable::AddEventConsumer(CEventConsumer* pConsumer)
{
    CInCritSec ics(&m_cs);
    if(m_apConsumers.Add(pConsumer) < 0)
        return WBEM_E_OUT_OF_MEMORY;
    
    if(pConsumer->IsPermanent())
    {
        if(m_lNumPermConsumers++ == 0)
            m_pNamespace->SetActive();
    }

    return S_OK;
}

HRESULT CBindingTable::FindEventFilter(LPCWSTR wszKey, 
                                        RELEASE_ME CEventFilter** ppFilter)
{
    CInCritSec ics(&m_cs);

    if(m_apFilters.Find(wszKey, ppFilter))
        return S_OK;
    else
        return WBEM_E_NOT_FOUND;
}
    
HRESULT CBindingTable::FindEventConsumer(LPCWSTR wszKey, 
                                        RELEASE_ME CEventConsumer** ppConsumer)
{
    CInCritSec ics(&m_cs);

    if(m_apConsumers.Find(wszKey, ppConsumer))
        return S_OK;
    else
        return WBEM_E_NOT_FOUND;
}

HRESULT CBindingTable::RemoveEventFilter(LPCWSTR wszKey)
{
    // Find it and remove it from the table
    // ====================================

    CEventFilter* pFilter = NULL;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);

        if(!m_apFilters.Remove(wszKey, &pFilter))
            return WBEM_E_NOT_FOUND;
    }
        
    if(pFilter == NULL)
        return WBEM_E_CRITICAL_ERROR;

    // Remove 1 from our quota count.
    if (!pFilter->IsInternal())
    {
        g_quotas.DecrementQuotaIndex(
            pFilter->GetOwner() ? ESSQ_PERM_SUBSCRIPTIONS : ESSQ_TEMP_SUBSCRIPTIONS,
            pFilter,
            1);
    }

    // Unbind it, thus deactivating
    // ============================

    hres = pFilter->Unbind();
    pFilter->Release();


    return hres;
}

void CBindingTable::MarkRemoval(CEventConsumer* pConsumer)
{
    if(pConsumer && pConsumer->IsPermanent())
    {
        if(--m_lNumPermConsumers == 0)
            m_pNamespace->SetInactive();
    }
}

HRESULT CBindingTable::RemoveEventConsumer(LPCWSTR wszKey)
{
    // Find it and remove it from the table
    // ====================================

    CEventConsumer* pConsumer = NULL;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);

        if(!m_apConsumers.Remove(wszKey, &pConsumer))
            return WBEM_E_NOT_FOUND;
        
        MarkRemoval(pConsumer);
    }
        
    if(pConsumer == NULL)
        return WBEM_E_CRITICAL_ERROR;
    hres = pConsumer->Unbind();
    pConsumer->Release();
    return hres;
}

HRESULT CBindingTable::Bind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey, 
                CBinding* pBinding, PSID pBinderSid)
{
    // Find them both and get ref-counted pointers
    // ===========================================

    CEventFilter* pFilter;
    CEventConsumer* pConsumer;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);
    
        hres = FindEventFilter(wszFilterKey, &pFilter);
        if(FAILED(hres)) return hres;
    
        hres = FindEventConsumer(wszConsumerKey, &pConsumer);
        if(FAILED(hres)) 
        {
            pFilter->Release();
            return hres;
        }
    }

    // Fully construct the binding --- will check security
    // ===================================================

    hres = pBinding->SetEndpoints(pConsumer, pFilter, pBinderSid);
    if(FAILED(hres))
        return hres;

    // Make them reference each other
    // ==============================

    HRESULT hresGlobal = S_OK;
    hres = pFilter->EnsureReferences(pConsumer, pBinding);
    if(FAILED(hres)) 
        hresGlobal = hres;
    hres = pConsumer->EnsureReferences(pFilter, pBinding);
    if(FAILED(hres)) 
        hresGlobal = hres;

    // Cleanup
    // =======

    pConsumer->Release();
    pFilter->Release();

    return hresGlobal;
}

HRESULT CBindingTable::Unbind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey)
{
    // Find them both and get ref-counted pointers
    // ===========================================

    CEventFilter* pFilter;
    CEventConsumer* pConsumer;
    HRESULT hres;

    {
        CInCritSec ics(&m_cs);
    
        hres = FindEventFilter(wszFilterKey, &pFilter);
        if(FAILED(hres)) return hres;
    
        hres = FindEventConsumer(wszConsumerKey, &pConsumer);
        if(FAILED(hres)) 
        {
            pFilter->Release();
            return hres;
        }
    }

    // Remove respective references
    // ============================

    HRESULT hresGlobal = S_OK;
    hres = pFilter->EnsureNotReferences(pConsumer);
    if(FAILED(hres))
        hresGlobal = hres;
    pConsumer->EnsureNotReferences(pFilter);
    if(FAILED(hres))
        hresGlobal = hres;

    pFilter->Release();
    pConsumer->Release();
    return hresGlobal;
}
    
BOOL CBindingTable::DoesHavePermanentConsumers()
{
    return (m_lNumPermConsumers != 0);
}

HRESULT CBindingTable::ResetProviderRecords(LPCWSTR wszProviderRef)
{
    // Make a copy of the list of consumers, AddRefed
    // ==============================================

    CRefedPointerArray<CEventConsumer> apConsumers;
    if(!GetConsumers(apConsumers))
        return WBEM_E_OUT_OF_MEMORY;

    // Go through all the consumers and see if they reference this record
    // ==================================================================

    for(int i = 0; i < apConsumers.GetSize(); i++)
    {
        apConsumers[i]->ResetProviderRecord(wszProviderRef);
    }
    return S_OK;
}
    
//*******************************************************************************
//
//  EnsureConsumerWatchInstruction / UnloadUnusedConsumers synchronization
//
//  Usage:
//
//  ECWI is called when a consumer is loaded.  It is called after the consumer 
//      record has been updated. Post-condition: UnloadUnusedConsumers must be 
//      called at least once after this function starts executing.
//
//  UUC is called by the CConsumerWatchTimerInstruction::Fire on timer.  The 
//      instruction then self-destructs. Post-condition: idle consumers 
//      unloaded; if any are still active, another UUC will occur in the future;
//      If none are active for a while, no UUC will occur in the future, 
//      until ECWI is called.
//
//  Primitives: 
//
//  CS m_cs: atomic, data access
//
//  BOOL m_bUnloadInstruction: Can only be accessed in m_cs.  Semantics:
//      TRUE if an instruction is either scheduled or will be scheduled 
//      shortly; this putative instruction, when fired, is guaranteed to 
//      examine any consumer in the table at the time of he check.
//
//  Algorithm:
//
//  ECWI checks m_bUnloadInstructiion (in m_cs) and if TRUE does nothing, as the
//      m_bUnloadInstruction == TRUE guarantee above assures that UUC will be
//      called.  If it is FALSE, ECWI sets it to TRUE, then schedules an 
//      instruction (outside of m_cs).  The setting of m_bUnloadInstruction to
//      TRUE is correct, since an instruction will be scheduled shortly.  Thus,
//      ECWI post-condition is satisfied, assuming primitive semantics above.
//
//  UUC, in m_cs, sets m_bUnloadInstriction to FALSE and makes a copy of the 
//      consumer list.  Outside of m_cs, it iterates over the copy and unloads
//      consumers as required. Then, if any are active, it calls ECWI. This 
//      guarantees that another UUC will be called.  If a consumer was active
//      before the entry into m_cs, we call ECWI. If a consumer became active
//      after we entered into m_cs, it will call ECWI after we have reset 
//      m_bUnloadInstruction, causing another instruction to be scheduled. This
//      proves our post-condition assuming primitive semantics above.
//
//  Proof of primitives:
//
//  m_bUnloadInstruction becomes TRUE only in ECWI. When it does, ECWI is
//  guaranteed to schedule a new instruction, causing a call to UUC. So, the
//  semantics holds in the beginning.  It can become invalid if UUC fires and is
//  not rescheduled. But UUC resets m_bUnloadInstruction to FALSE, thus making 
//  semantics valid vacuously. 
//
//  Now, we need to show that any consumer in the table at the time when
//  m_bUnloadInstruction == TRUE will be examined by the scheduled UUC. Well,
//  the latest scheduled (or about to be scheduled) UUC, cannot have exited 
//  its m_cs stint yet, for otherwise m_bUnloadInstruction would be FALSE. 
//  Therefore, it hasn't entered it yet, and therefore hasn't made a copy yet.
//
//******************************************************************************

HRESULT CBindingTable::EnsureConsumerWatchInstruction()
{
    // Check if it is already there
    // ============================

    BOOL bMustSchedule = FALSE;
    {
        CInCritSec ics(&m_cs);

        if(!m_bUnloadInstruction)
        {
            // Not there.  Mark as there, preventing others from scheduling 
            // more. 
            // ============================================================

            m_bUnloadInstruction = TRUE;
            bMustSchedule = TRUE;
        }
    }

    if(bMustSchedule)
    {
        CConsumerWatchInstruction* pInst = new CConsumerWatchInstruction(this);
        if(pInst == NULL)
        {
            CInCritSec ics(&m_cs);
            m_bUnloadInstruction = FALSE;
            return WBEM_E_OUT_OF_MEMORY;
        }
        pInst->AddRef();
    
        // Set it in the generator
        // =======================
    
        HRESULT hres = m_pNamespace->GetTimerGenerator().Set(pInst);
        if(FAILED(hres))
        {
            CInCritSec ics(&m_cs);
            m_bUnloadInstruction = FALSE;
            return hres;
        }
        
        pInst->Release();

        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

HRESULT CBindingTable::UnloadUnusedConsumers(CWbemInterval Interval)
{
    // Mark unload instruction as empty and copy consumer records
    // ==========================================================

    CRefedPointerArray<CEventConsumer> apConsumers;

    {
        CInCritSec ics(&m_cs);
        m_bUnloadInstruction = FALSE;
        if(!GetConsumers(apConsumers))
            return WBEM_E_OUT_OF_MEMORY;
    }

    // Go through the consumers and unload them if needed
    // ==================================================

    BOOL bUnloaded = FALSE;
    BOOL bActive = FALSE;

    for(int i = 0; i < apConsumers.GetSize(); i++)
    {
        if(apConsumers[i]->UnloadIfUnusedFor(Interval))
            bUnloaded = TRUE;
        else if(!apConsumers[i]->IsFullyUnloaded())
            bActive = TRUE;
    }

    // Schedule DLL unloading if any COM objects were unloaded
    // =======================================================

    if(bUnloaded)
        m_pNamespace->GetTimerGenerator().ScheduleFreeUnusedLibraries();

    // Schedule the new instruction if needed
    // ======================================

    if(bActive)
        return EnsureConsumerWatchInstruction();

    return S_OK;
}

BOOL CBindingTable::GetConsumers(
        CRefedPointerArray<CEventConsumer>& apConsumers)
{
    CInCritSec ics(&m_cs);
    TConsumerIterator it;
    for(it = m_apConsumers.Begin(); it != m_apConsumers.End(); it++)
    {
        if(apConsumers.Add(*it) < 0)
            return FALSE;
    }

    return TRUE;
}


BOOL CBindingTable::GetEventFilters( CRefedPointerArray< CEventFilter > & apEventFilters )
{
    CInCritSec ics( &m_cs );

    TFilterIterator it;

    for( it = m_apFilters.Begin( ); it != m_apFilters.End( ); ++it )
    {
        if( apEventFilters.Add( *it ) < 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
}


HRESULT CBindingTable::RemoveConsumersStartingWith(LPCWSTR wszPrefix)
{
    CRefedPointerArray<CEventConsumer> apToRelease;
    int nLen = wcslen(wszPrefix);

    {
        CInCritSec ics(&m_cs);

        TConsumerIterator it = m_apConsumers.Begin();
        while(it != m_apConsumers.End())
        {
            if(!wcsncmp((WString)(*it)->GetKey(), wszPrefix, nLen))
            {
                // Found it --- move to the "to be released" list
                // ==============================================

                CEventConsumer* pConsumer;
                it = m_apConsumers.Remove(it, &pConsumer);
            
                MarkRemoval(pConsumer);
                apToRelease.Add(pConsumer);
                pConsumer->Release();
            }
            else
            {
                it++;
            }
        }
    }

    // Unbind all the consumers we have left.  Release will happen on destruct
    // =======================================================================

    for(int i = 0; i < apToRelease.GetSize(); i++)
    {
        apToRelease[i]->Unbind();
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CBindingTable::RemoveConsumerWithFilters(LPCWSTR wszConsumerKey)
{
    HRESULT hres;

    CRefedPointerSmallArray<CEventFilter> apFilters;

    {
        CInCritSec ics(&m_cs);

        // Find the consumer in question
        // =============================

        CEventConsumer* pConsumer = NULL;
        hres = FindEventConsumer(wszConsumerKey, &pConsumer);
        if(FAILED(hres))
            return hres;

        CReleaseMe rm1(pConsumer);

        // Make addrefed copies of all its associated filters
        // ==================================================

        hres = pConsumer->GetAssociatedFilters(apFilters);
        if(FAILED(hres))
            return hres;
    }
    
    // Remove the consumer
    // ===================

    RemoveEventConsumer(wszConsumerKey);

    // Remove every one of its filters
    // ===============================

    for(int i = 0; i < apFilters.GetSize(); i++)
    {
        RemoveEventFilter((WString)apFilters[i]->GetKey());
    }
    
    return S_OK;
}
        
HRESULT CBindingTable::ReactivateAllFilters()
{
    // Retrieve a copy of all the filters
    // ==================================

    CRefedPointerArray<CEventFilter> apFilters;

    {
        CInCritSec ics(&m_cs);
        TFilterIterator it;
        for(it = m_apFilters.Begin(); it != m_apFilters.End(); it++)
        {
            if(apFilters.Add(*it) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // Reactivate them all
    // ===================
    
    for(int i = 0; i < apFilters.GetSize(); i++)
    {
        CEventFilter* pFilter = apFilters[i];
        pFilter->SetInactive();
        pFilter->AdjustActivation();
    }

    return WBEM_S_NO_ERROR;
}


void CBindingTable::Park()
{
    // 
    // Tell each filter to "park" itself
    //

    CInCritSec ics(&m_cs);

    TFilterIterator it;
    for(it = m_apFilters.Begin(); it != m_apFilters.End(); it++)
    {
        (*it)->Park();
    }
}


void CBindingTable::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d consumers (%d permanent), %d filters\n", 
        m_apConsumers.GetSize(), m_lNumPermConsumers, 
        m_apFilters.GetSize());
}

CBindingTableRef::~CBindingTableRef()
{
}

CBindingTableRef::CBindingTableRef(CBindingTable* pTable)
    : m_pTable(pTable), m_lRef(0)
{
}

void CBindingTableRef::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CBindingTableRef::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}
    
void CBindingTableRef::Disconnect()
{
    CInCritSec ics(&m_cs);
    m_pTable = NULL;
}

HRESULT CBindingTableRef::UnloadUnusedConsumers(CWbemInterval Interval)
{
    CInCritSec ics(&m_cs);

    if(m_pTable)
        return m_pTable->UnloadUnusedConsumers(Interval);
    else
        return WBEM_S_FALSE;
}
    
HRESULT CBindingTableRef::GetNamespace(RELEASE_ME CEssNamespace** ppNamespace)
{
    CInCritSec ics(&m_cs);
    if(m_pTable)
    {
        *ppNamespace = m_pTable->m_pNamespace;
        if(*ppNamespace)
            (*ppNamespace)->AddRef();
    }
    else
    {
        *ppNamespace = NULL;
    }
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\clscache.h ===
//******************************************************************************
//
//  CLSCACHE.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_CLASS_CACHE__H_
#define __WMI_ESS_CLASS_CACHE__H_

#include <parmdefs.h>
#include <wbemcomn.h>
#include <wbemint.h>
#include <map>
#include <wstlallc.h>

class CEssNamespace;

class CEssClassCache
{
protected:
    typedef std::map<WString,_IWmiObject*, WSiless, wbem_allocator<_IWmiObject*> > TClassMap;
    typedef TClassMap::iterator TIterator;

    TClassMap m_mapClasses;
    CEssNamespace* m_pNamespace;
    CCritSec m_cs;

public:
    CEssClassCache(CEssNamespace* pNamespace) : m_pNamespace(pNamespace){}
    ~CEssClassCache();

    HRESULT GetClass( LPCWSTR wszClassName, IWbemContext* pContext,
                      _IWmiObject** ppClass );
    HRESULT Clear();
};
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\binding.h ===
//******************************************************************************
//
//  BINDING.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_BINDING__H_
#define __WMI_ESS_BINDING__H_

#include <wbemcomn.h>
#include "evtools.h"
#include "evsink.h"
#include <unload.h>
#include <wbemstr.h>
#include <sortarr.h>
#include <ql.h>
#include "qsink.h"

class CEventConsumer;
class CEventFilter;
class CEssNamespace;

//******************************************************************************
//
//  Immutable after initialization
//
//******************************************************************************

class CBinding : public CEventSink
{
protected:
    long m_lRef;
    CEventConsumer* m_pConsumer; // immutable after init
    CEventFilter* m_pFilter; // immutable after init

    DWORD m_dwQoS; // immutable after init
    bool m_bSecure;  // immutable after init
    bool m_bSlowDown; // immutable after init
    bool m_bDisabledForSecurity; 

public:
    CBinding();
    CBinding(ADDREF CEventConsumer* pConsumer, ADDREF CEventFilter* pFilter);
    virtual ~CBinding();

    HRESULT SetEndpoints(ADDREF CEventConsumer* pConsumer, 
                        ADDREF CEventFilter* pFilter,
                        PSID pBinderSid);
    void DisableForSecurity();
    INTERNAL CEventConsumer* GetConsumer() NOCS {return m_pConsumer;}
    INTERNAL CEventFilter* GetFilter() NOCS {return m_pFilter;}
    DWORD GetQoS() NOCS;
    bool IsSynch() NOCS;
    bool IsSecure() NOCS;
    bool ShouldSlowDown() NOCS;

    HRESULT Indicate( long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext);
};

class CEventConsumer : public CQueueingEventSink
{
protected:
    CRefedPointerSmallArray<CBinding> m_apBindings;
    CInternalString m_isKey;
    PBYTE m_pOwnerSid;

public:
    
    CEventConsumer(CEssNamespace* pNamespace);

    virtual ~CEventConsumer();

    inline const CInternalString& GetKey() const {return m_isKey;}
    inline const PSID GetOwner() {return m_pOwnerSid;}

    virtual BOOL IsPermanent() const {return FALSE;}
    virtual BOOL UnloadIfUnusedFor(CWbemInterval Interval) {return FALSE;}
    virtual BOOL IsFullyUnloaded() {return TRUE;}
    virtual HRESULT ResetProviderRecord(LPCWSTR wszProviderRef) 
        {return S_FALSE;}
    virtual HRESULT Shutdown(bool bQuiet = false) {return S_OK;}
    virtual HRESULT Validate(IWbemClassObject* pLogicalConsumer) {return S_OK;}

    HRESULT EnsureReferences(CEventFilter* pFilter, CBinding* pBinding);
    HRESULT EnsureNotReferences(CEventFilter* pFilter);
    HRESULT Unbind();

    HRESULT ConsumeFromBinding(CBinding* pBinding, 
                                long lNumEvents, IWbemEvent** apEvents,
                                CEventContext* pContext);
    HRESULT GetAssociatedFilters(
                CRefedPointerSmallArray<CEventFilter>& apFilters);

    virtual HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure, CEventContext* pContext) = 0;
    virtual HRESULT ReportEventDrop(IWbemEvent* pEvent);
};

//*****************************************************************************
//
//  m_cs controls access to data members.  No critical sections may be acquired
//          while holding m_cs.
//
//  m_csChangeBindings controls activation/deactivation requests on this filter.
//      As long as an activation/deactivation request is proceeding, no other
//      such request can get underway.  This ensures that the activation state
//      state of the filter always matches the state of its bindings.  At the
//      same time, the filter can filter events while such a request executes, 
//      since m_cs is not held.  Only m_cs can be acquired while holding
//      m_csActivation
//
//*****************************************************************************

class CEventFilter : public CEventSink, public CUpdateLockable
{
protected:
    CEssNamespace* m_pNamespace; // immutable after init
    CRefedPointerSmallArray<CBinding> m_apBindings; // changes
    CCritSec m_cs;
    // CCritSec m_csChangeBindings; // don't need since the namespace is locked
    bool m_bSingleAsync;
    CInternalString m_isKey;
    PBYTE m_pOwnerSid;
    long m_lSecurityChecksRemaining;
    long m_lSubjectToSDSCount;
    bool m_bCheckSDs;
    HRESULT m_hresFilterError;
    bool m_bHasBeenValid;
    IWbemToken* m_pToken;
    HRESULT m_hresTokenError;
    DWORD m_dwLastTokenAttempt;
    bool m_bReconstructOnHit;
    HRESULT m_hresPollingError;

    enum 
    {
        e_Inactive, e_Active
    } m_eState; //changes

    enum
    {
        e_Unknown, e_PermanentlyInvalid, e_TemporarilyInvalid, e_Valid
    } m_eValidity;

    friend class CEventForwardingSink;

    class CEventForwardingSink : public CAbstractEventSink
    {
    protected:
        CEventFilter* m_pOwner;
    
    public:
        CEventForwardingSink(CEventFilter* pOwner) : m_pOwner(pOwner){}

        ULONG STDMETHODCALLTYPE AddRef() {return m_pOwner->AddRef();}
        ULONG STDMETHODCALLTYPE Release() {return m_pOwner->Release();}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    } m_ForwardingSink; // immutable

    class CClassChangeSink : public CEmbeddedObjectSink<CEventFilter>
    {
    public:
        CClassChangeSink(CEventFilter* pOwner) : 
            CEmbeddedObjectSink<CEventFilter>(pOwner){}
        STDMETHOD(Indicate)(long lNumEvents, IWbemEvent** apEvents);
    } m_ClassChangeSink; // immutable

    CWbemPtr<IWbemObjectSink> m_pActualClassChangeSink; 

    friend CEventForwardingSink;

public:

    CEventFilter(CEssNamespace* pEssNamespace);
    virtual ~CEventFilter();

    virtual bool IsInternal() { return false; }

    //**************
    // Acquire CSs
    //**************

    HRESULT EnsureReferences(CEventConsumer* pConsumer, CBinding* pBinding);
    HRESULT EnsureNotReferences(CEventConsumer* pConsumer);
    HRESULT Unbind(bool bShuttingDown = false);
    bool IsBound();

    virtual BOOL DoesNeedType(int nType) const = 0;
    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                CEventContext* pContext) = 0;

    virtual HRESULT LockForUpdate();
    virtual HRESULT UnlockForUpdate();

    //*******************
    // Do not acquire CSs
    //*******************

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp) = 0;
    virtual HRESULT GetEventNamespace(DELETE_ME LPWSTR* pwszNamespace);
    virtual DWORD GetForceFlags() {return 0;}
    virtual bool DoesAllowInvalid() 
        {return ((GetForceFlags() & WBEM_FLAG_STRONG_VALIDATION) == 0);}
    bool HasBeenValid() {return m_bHasBeenValid;}

    inline const CInternalString& GetKey() {return m_isKey;}
    inline const PSID GetOwner() { return m_pOwnerSid; }

    virtual CAbstractEventSink* GetNonFilteringSink() = 0;
    virtual HRESULT GetReady(LPCWSTR wszQuery, 
                            QL_LEVEL_1_RPN_EXPRESSION* pExp) = 0;
    virtual HRESULT GetReadyToFilter() = 0;
    virtual BOOL IsPermanent() = 0;
    virtual HRESULT SetThreadSecurity( IUnknown** ppNewContext ) = 0;
    virtual HRESULT ObtainToken(IWbemToken** ppToken) = 0;
    virtual void Park(){}
    virtual const PSECURITY_DESCRIPTOR GetEventAccessSD() { return NULL; }
    void MarkAsPermanentlyInvalid(HRESULT hres);
    void MarkAsTemporarilyInvalid(HRESULT hres);
    void MarkAsValid();
    void SetInactive();
    BOOL IsActive();
    HRESULT GetFilterError();
    void MarkReconstructOnHit(bool bReconstruct = true);
    void SetPollingError(HRESULT hres) {m_hresPollingError = hres;}
    HRESULT GetPollingError() {return m_hresPollingError;}

    void IncrementRemainingSecurityChecks();
    void DecrementRemainingSecurityChecks(HRESULT hresProvider);

    INTERNAL IWbemObjectSink* GetClassChangeSink() {return &m_ClassChangeSink;}
    
    // 
    // this so the caller can wrap the class change sink however they want and
    // store the resultant sink with the filter object.
    //
    HRESULT SetActualClassChangeSink( IWbemObjectSink* pSink, 
                                      IWbemObjectSink** ppOldSink );

    HRESULT Reactivate();

protected:
    HRESULT Deliver(long lNumEvents, IWbemEvent** apEvents,
                    CEventContext* pContext);
    HRESULT AdjustActivation();
    void AdjustSingleAsync();
    BOOL DoesNeedDeactivation();
    HRESULT AccessCheck( CEventContext* pEventContext, IWbemEvent* pEvent );

    HRESULT CheckEventAccessToFilter( IServerSecurity* pProvCtx );
    HRESULT CheckFilterAccessToEvent( PSECURITY_DESCRIPTOR pEventSD );

    friend class CBindingTable;
};



class CConsumerWatchInstruction : public CBasicUnloadInstruction
{
protected:
    class CBindingTableRef* m_pTableRef;
    static CWbemInterval mstatic_Interval;

public:
    CConsumerWatchInstruction(CBindingTable* pTable);
    ~CConsumerWatchInstruction();
    HRESULT Fire(long, CWbemTime);
    static void staticInitialize(IWbemServices* pRoot);
};

//******************************************************************************
//
// This class is a comparer (as required by the sorted array template) that
// compares an object with CInternalString* GetKey() method (e.g. filter or 
// consumer) to another such object or an LPCWSTR
//
//******************************************************************************

template<class TObject>
class CInternalStringComparer
{
public:
    int Compare(TObject* p1, TObject* p2) const
    {
        return p1->GetKey().Compare(p2->GetKey());
    }
    int Compare(const CInternalString& isKey, TObject* p) const
    {
        return - p->GetKey().Compare(isKey);
    }
    int Compare(LPCWSTR wszKey, TObject* p) const
    {
        return - p->GetKey().Compare(wszKey);
    }
    int Compare(const CInternalString& isKey1, 
                const CInternalString& isKey2) const
    {
        return isKey1.Compare(isKey2);
    }
    const CInternalString& Extract(TObject* p) const
    {
        return p->GetKey();
    }
};

template<class TObject>
class CSortedRefedKeyedPointerArray : 
    public CRefedPointerSortedTree<CInternalString, TObject, 
                                    CInternalStringComparer<TObject> >
{
    typedef CRefedPointerSortedTree<CInternalString, TObject, 
                                  CInternalStringComparer<TObject> > TParent;
public:
    inline bool Find(LPCWSTR wszKey, TObject** ppObj)
    {
        CInternalString is(wszKey);
        if (is.IsEmpty())
            return false;
        return TParent::Find(is, ppObj);
    }
    inline bool Remove(LPCWSTR wszKey, TObject** ppObj)
    {
        CInternalString is(wszKey);
        if (is.IsEmpty())
            return false;        
        return TParent::Remove(is, ppObj);
    }
    inline typename TParent::TIterator Remove(typename TParent::TIterator it, TObject** ppObj)
    {
        return TParent::Remove(it, ppObj);
    }
};

/*
template<class TObject>
class CSortedRefedKeyedPointerArray : 
    public CRefedPointerSortedArray<LPCWSTR, TObject, 
                                    CInternalStringComparer<TObject> >
{
};
*/
        
class CBindingTableRef
{
protected:
    long m_lRef;
    CBindingTable* m_pTable;
    CCritSec m_cs;


protected:
    virtual ~CBindingTableRef();

public:
    CBindingTableRef(CBindingTable* pTable);
    void AddRef();
    void Release();
    void Disconnect();
    HRESULT UnloadUnusedConsumers(CWbemInterval Interval);
    HRESULT GetNamespace(RELEASE_ME CEssNamespace** ppNamespace);
};

class CBindingTable
{
protected:
    CEssNamespace* m_pNamespace;
    CCritSec m_cs;

    CSortedRefedKeyedPointerArray<CEventFilter> m_apFilters;
    typedef CSortedRefedKeyedPointerArray<CEventFilter>::TIterator 
                TFilterIterator;
    CSortedRefedKeyedPointerArray<CEventConsumer> m_apConsumers;
    typedef CSortedRefedKeyedPointerArray<CEventConsumer>::TIterator 
                TConsumerIterator;

    long m_lNumPermConsumers;
    CConsumerWatchInstruction* m_pInstruction;
    BOOL m_bUnloadInstruction;
    CBindingTableRef* m_pTableRef;
    
public:

    //****************************************************
    // all members should be assumed to acquire random CSs
    //****************************************************

    CBindingTable(CEssNamespace* pNamespace);
    void Clear( bool bSkipClean );
    ~CBindingTable() { Clear(true); }

    HRESULT AddEventFilter(CEventFilter* pFilter);
    HRESULT AddEventConsumer(CEventConsumer* pConsumer);

    HRESULT FindEventFilter(LPCWSTR wszKey, RELEASE_ME CEventFilter** ppFilter);
    HRESULT FindEventConsumer(LPCWSTR wszKey, 
                                        RELEASE_ME CEventConsumer** ppConsumer);

    HRESULT RemoveEventFilter(LPCWSTR wszKey);
    HRESULT RemoveEventConsumer(LPCWSTR wszKey);

    HRESULT Bind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey, 
                    CBinding* pBinding, PSID pBinderSid);
    HRESULT Unbind(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey);
    
    BOOL DoesHavePermanentConsumers();
    HRESULT ListActiveNamespaces(CWStringArray& wsNamespaces);
    HRESULT ResetProviderRecords(LPCWSTR wszProvider);
    HRESULT RemoveConsumerWithFilters(LPCWSTR wszConsumerKey);
    HRESULT ReactivateAllFilters();
    HRESULT RemoveConsumersStartingWith(LPCWSTR wszPrefix);
    
    HRESULT EnsureConsumerWatchInstruction();
    void Park();
    void DumpStatistics(FILE* f, long lFlags);

    BOOL GetEventFilters( CRefedPointerArray< CEventFilter > & apEventFilters );

protected:
    void MarkRemoval(CEventConsumer* pConsumer);

    HRESULT UnloadUnusedConsumers(CWbemInterval Interval);

    BOOL GetConsumers(CRefedPointerArray<CEventConsumer>& apConsumers);
    friend CConsumerWatchInstruction;
    friend CBindingTableRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\clscache.cpp ===
//******************************************************************************
//
//  CLSCACHE.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <nsrep.h>

CEssClassCache::~CEssClassCache()
{
    Clear();
}

HRESULT CEssClassCache::GetClass( LPCWSTR wszClassName, 
                                  IWbemContext* pContext,
                                  _IWmiObject** ppClass )
{
    HRESULT hres;

    // Search the map
    // ==============

    {
        CInCritSec ics(&m_cs);
        TIterator it = m_mapClasses.find((LPWSTR)wszClassName);
        if(it != m_mapClasses.end())
        {
            *ppClass = it->second;
            (*ppClass)->AddRef();
            return S_OK;
        }
    }

    // Not found --- retrieve
    // ======================

    _IWmiObject* pClass = NULL;
    hres = m_pNamespace->GetClassFromCore(wszClassName, &pClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pClass);

    // Cache it if needed
    // ==================

    {
        CInCritSec ics(&m_cs);
        if(m_mapClasses.find((LPWSTR)wszClassName) == m_mapClasses.end())
        {
            try
            {
                m_mapClasses[wszClassName] = pClass;
                pClass->AddRef();                
            }
            catch(CX_MemoryException &)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
            
    *ppClass = pClass;
    pClass->AddRef();
    return WBEM_S_NO_ERROR;
}

HRESULT CEssClassCache::Clear()
{
    CInCritSec ics(&m_cs);

    for(TIterator it = m_mapClasses.begin(); it != m_mapClasses.end(); it++)
    {        
        it->second->Release();
    }

    m_mapClasses.clear();
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\consprov.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  CONPROV.H
//
//  This file defines the classes for event consumer provider caching.
//
//  Classes defined:
//
//      CConsumerProviderRecord  --- a single consumer provider record
//      CConsumerProviderCache  --- a collection of records.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#ifndef __CONSUMER_PROVIDER_CACHE
#define __CONSUMER_PROVIDER_CACHE

#include <arrtempl.h>
#include <wbemidl.h>
#include <parmdefs.h>
#include <unload.h>

class CEssNamespace;
class CConsumerProviderRecord
{
private:
    long m_lRef;
    CEssNamespace* m_pNamespace;
    
    IWbemClassObject* m_pLogicalProvider;
    LPWSTR m_wszMachineName;
    LPWSTR m_wszProviderName;
    LPWSTR m_wszProviderRef;
    CLSID m_clsid;

    IWbemEventConsumerProvider* m_pConsumerProvider;
    IWbemEventConsumerProviderEx* m_pConsumerProviderEx;
    IWbemUnboundObjectSink* m_pSink;

    BOOL m_bResolved;
    CWbemTime m_LastAccess;
    CCritSec m_cs;
    BOOL m_bAnonymous;

    CConsumerProviderRecord(CEssNamespace* pNamespace);
    HRESULT Initialize(IWbemClassObject* pLogicalProvider, 
                            LPCWSTR wszProviderRef,
                            LPCWSTR wszProviderName,
                            LPCWSTR wszMachineName);
    void Enter() {EnterCriticalSection(&m_cs);}
    void Leave() {LeaveCriticalSection(&m_cs);}

    friend class CConsumerProviderCache;
protected:
    HRESULT ResolveAndCache(IWbemUnboundObjectSink** ppSink,
                           IWbemEventConsumerProvider** ppConsumerProvider,
                           IWbemEventConsumerProviderEx** ppConsumerProviderEx);
    HRESULT Resolve(IWbemUnboundObjectSink** ppSink,
                           IWbemEventConsumerProvider** ppConsumerProvider,
                           IWbemEventConsumerProviderEx** ppConsumerProviderEx);

public:
    ~CConsumerProviderRecord();

    HRESULT GetGlobalObjectSink(OUT IWbemUnboundObjectSink** ppSink,
                                IN IWbemClassObject *pLogicalConsumer);
    HRESULT FindConsumer(IN IWbemClassObject* pLogicalConsumer,
                         OUT IWbemUnboundObjectSink** ppSink);
    HRESULT ValidateConsumer(IWbemClassObject* pLogicalConsumer);
    void Invalidate();
    CWbemTime GetLastAccess() {return m_LastAccess;}
    void Touch() {m_LastAccess = CWbemTime::GetCurrentTime();}
    BOOL IsActive() {return m_bResolved;}

    LPCWSTR GetMachineName() {return m_wszMachineName;}
    REFCLSID GetCLSID() {return m_clsid;}
    LPCWSTR GetProviderName() {return m_wszProviderName;}
    LPCWSTR GetProviderRef() {return m_wszProviderRef;}

    void FireNCSinkEvent(DWORD dwIndex, IWbemClassObject *pLogicalConsumer);

    long AddRef();
    long Release();
};

class CEssNamespace;
class CConsumerProviderCache
{
public:
    friend class CConsumerProviderRecord;
    friend class CConsumerProviderWatchInstruction;

    CConsumerProviderCache(CEssNamespace* pNamespace) 
        : m_pNamespace(pNamespace), m_pInstruction(NULL){}
    ~CConsumerProviderCache();

    RELEASE_ME CConsumerProviderRecord* GetRecord(
                IN IWbemClassObject* pLogicalConsumer);

    HRESULT RemoveConsumerProvider(LPCWSTR wszProvider);
    static SYSFREE_ME BSTR GetProviderRefFromRecord(IWbemClassObject* pReg);
    HRESULT GetConsumerProviderRegFromProviderReg(
                    IWbemClassObject* pProv, IWbemClassObject** ppConsProv);
    void DumpStatistics(FILE* f, long lFlags);
    void Clear();
protected:
    HRESULT UnloadUnusedProviders(CWbemInterval Interval);
    void EnsureUnloadInstruction();
    BOOL DoesContain(IWbemClassObject* pProvReg, IWbemClassObject* pConsumer);

protected:
    CRefedPointerArray<CConsumerProviderRecord> m_apRecords;

    CEssNamespace* m_pNamespace;
    CCritSec m_cs;
    class CConsumerProviderWatchInstruction* m_pInstruction;
    friend CConsumerProviderWatchInstruction;
    friend class CProviderRegistrationSink;
};
        
class CConsumerProviderWatchInstruction : public CBasicUnloadInstruction
{
protected:
    CConsumerProviderCache* m_pCache;

    static CWbemInterval mstatic_Interval;

public:
    CConsumerProviderWatchInstruction(CConsumerProviderCache* pCache);
    virtual ~CConsumerProviderWatchInstruction() {}

    HRESULT Fire(long, CWbemTime);

    static void staticInitialize(IWbemServices* pRoot);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\corefind.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  FINDTRIG.H
//
//  This file defines the classes for an event filter search engine.  
//
//  Classes defined:
//
//      CEventFilterEnumerator      An enumerator of event filters
//      CArrayEventFilterEnumerator Array-based enumerator of event filters
//      CSearchHint                 Information passed from one search to next
//      CEventFilterSearchEngine    Search engine class.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#ifndef __FIND_FILTER__H_
#define __FIND_FILTER__H_

#include "binding.h"
#include "arrtempl.h"
#include "essutils.h"

class CCoreEventProvider : 
        public CUnkBase<IWbemEventProvider, &IID_IWbemEventProvider>
{
protected:
    STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);

protected:
    CEssSharedLock m_Lock;
    CEssNamespace* m_pNamespace;
    IWbemEventSink* m_pSink;

public:
    CCoreEventProvider(CLifeControl* pControl = NULL);
    ~CCoreEventProvider();
    HRESULT SetNamespace(CEssNamespace* pNamespace);
    HRESULT Shutdown();

    HRESULT Fire(CEventRepresentation& Event, CEventContext* pContext);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\consprov.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  CONPROV.CPP
//
//  This file implements the classes for event consumer provider caching.
//
//  Classes implemented:
//
//      CConsumerProviderRecord  --- a single consumer provider record
//      CConsumerProviderCache  --- a collection of records.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include "ess.h"
#include "consprov.h"
#include <genutils.h>
#include <cominit.h>
#include "NCEvents.h"

CConsumerProviderRecord::CConsumerProviderRecord(CEssNamespace* pNamespace)
        : m_pLogicalProvider(NULL), m_pConsumerProvider(NULL),
        m_pSink(NULL), m_bResolved(FALSE), m_pNamespace(pNamespace),
        m_lRef(0), m_wszMachineName(NULL), m_wszProviderName(NULL), 
        m_wszProviderRef(NULL), m_bAnonymous(FALSE)
{
    m_pNamespace->AddRef();
}



HRESULT CConsumerProviderRecord::Initialize(
                                    IWbemClassObject* pLogicalProvider,
                                    LPCWSTR wszProviderRef,
                                    LPCWSTR wszProviderName,
                                    LPCWSTR wszMachineName)
{
    m_LastAccess = CWbemTime::GetCurrentTime();

    m_pLogicalProvider = pLogicalProvider;
    m_pLogicalProvider->AddRef();

    if(wszMachineName)
        m_wszMachineName = CloneWstr(wszMachineName);

    m_wszProviderName = CloneWstr(wszProviderName);
    m_wszProviderRef = CloneWstr(wszProviderRef);

    if(m_wszProviderName == NULL || m_wszProviderRef == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Extract the CLSID
    // =================

    VARIANT vClassId;
    VariantInit(&vClassId);
    CClearMe cm(&vClassId);

    HRESULT hres = pLogicalProvider->Get(CONSPROV_CLSID_PROPNAME, 0, &vClassId, 
                        NULL, NULL);

    if(FAILED(hres) || V_VT(&vClassId) != VT_BSTR) 
    {
        ERRORTRACE((LOG_ESS, "Class ID is missing from consumer "
            "provider record!!\n"));
        return hres;
    }

    if(FAILED(CLSIDFromString(V_BSTR(&vClassId), &m_clsid)))
    {
        ERRORTRACE((LOG_ESS, "INVALID Class ID in consumer "
            "provider record!!\n"));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    return WBEM_S_NO_ERROR;
}

CConsumerProviderRecord::~CConsumerProviderRecord()
{
    _DBG_ASSERT( m_pNamespace != NULL );

    if(m_pLogicalProvider)
        m_pLogicalProvider->Release();
    if(m_pSink)
        m_pNamespace->PostponeRelease(m_pSink);
    if(m_pConsumerProvider)
        m_pNamespace->PostponeRelease(m_pConsumerProvider);
    
    if(m_pSink || m_pConsumerProvider)
    {
        //
        // Report the MSFT_WmiConsumerProviderUnloaded event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiConsumerProviderUnloaded], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_pNamespace->GetName(),
            m_wszProviderName,
            m_wszMachineName);
    }
    
    if(m_pNamespace)
        m_pNamespace->Release();
    delete [] m_wszMachineName;
    delete [] m_wszProviderName;
    delete [] m_wszProviderRef;
}

long CConsumerProviderRecord::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

long CConsumerProviderRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

void CConsumerProviderRecord::Invalidate()
{
    IWbemUnboundObjectSink* pSink;
    IWbemEventConsumerProvider* pConsumerProvider;

    {
        CInCritSec ics(&m_cs);

        pSink = m_pSink;
        m_pSink = NULL;

        pConsumerProvider = m_pConsumerProvider;
        m_pConsumerProvider = NULL;

        m_bResolved = FALSE;
    }
        
    _DBG_ASSERT( m_pNamespace != NULL );

    if (pSink)
        m_pNamespace->PostponeRelease(pSink);
    
    if (pConsumerProvider)
        m_pNamespace->PostponeRelease(pConsumerProvider);

    if (pConsumerProvider || pSink)
    {
        //
        // Report the MSFT_WmiConsumerProviderUnloaded event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiConsumerProviderUnloaded], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_pNamespace->GetName(),
            m_wszProviderName,
            m_wszMachineName);
    }    
}

HRESULT CConsumerProviderRecord::ValidateConsumer(
                                    IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    // Check if consumer provider is cached
    // ====================================

    IWbemEventConsumerProvider* pConsumerProvider = NULL;
    IWbemEventConsumerProviderEx* pConsumerProviderEx = NULL;

    BOOL bResolved = FALSE;
    
    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();

        if(m_bResolved)
        {
            if(m_pConsumerProviderEx)
            {
                pConsumerProviderEx = m_pConsumerProviderEx;
                pConsumerProviderEx->AddRef();
            }
            else
            {
                pConsumerProvider = m_pConsumerProvider;
                if(pConsumerProvider)
                    pConsumerProvider->AddRef();
            }

            bResolved = TRUE;
        }
    }

    // Resolve if not cached
    // =====================

    if(!bResolved)
    {
        IWbemUnboundObjectSink* pGlobalSink;

        hres = ResolveAndCache(&pGlobalSink, &pConsumerProvider, 
                                &pConsumerProviderEx);
        if(FAILED(hres)) return hres;

        if(pGlobalSink)
            pGlobalSink->Release();
    }

    CReleaseMe rm1(pConsumerProvider);
    CReleaseMe rm2(pConsumerProviderEx);

    if(pConsumerProvider == NULL && pConsumerProviderEx)
    {
        //
        // Clearly, this consumer does not support validation
        //

        return WBEM_S_FALSE;
    }

    try
    {
        if(pConsumerProviderEx)
        {
            hres = pConsumerProviderEx->ValidateSubscription(pLogicalConsumer);
        }
        else
        {
            //
            // Old-type provider --- we can still achieve validation by calling
            // FindConsumer --- it might reject this consumer at that time
            //

            IWbemUnboundObjectSink* pSink = NULL;
            hres = pConsumerProvider->FindConsumer(pLogicalConsumer, &pSink);
            if(SUCCEEDED(hres) && pSink)
                pSink->Release();
        }
    }
    catch(...)
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider %S in namespace %S "
            "threw an exception in ValidateConsumer/FindConsumer\n", 
                m_wszProviderName, m_pNamespace->GetName()));
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    return hres;
}
    

HRESULT CConsumerProviderRecord::GetGlobalObjectSink(
                OUT IWbemUnboundObjectSink** ppSink, 
                IN IWbemClassObject *pLogicalProvider)
{
    *ppSink = NULL;

    // Check of a cached version is available
    // ======================================

    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();

        if(m_bResolved)
        {
            // It is --- return it
            // ===================

            *ppSink = m_pSink;
            if(m_pSink)
                m_pSink->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // No cached version --- retrieve it
    // =================================

    IWbemUnboundObjectSink* pSink;
    IWbemEventConsumerProvider* pConsumerProvider;
    IWbemEventConsumerProviderEx* pConsumerProviderEx;

    HRESULT hres = ResolveAndCache(&pSink, &pConsumerProvider, 
                                    &pConsumerProviderEx);
    if(FAILED(hres))
        return hres;

    if(pConsumerProvider)
        pConsumerProvider->Release();
    if(pConsumerProviderEx)
        pConsumerProviderEx->Release();
    
    *ppSink = pSink;

    if (*ppSink != NULL)
    {
        //
        // Report the MSFT_WmiConsumerProviderSinkLoaded event.
        //
        FireNCSinkEvent(
            MSFT_WmiConsumerProviderSinkLoaded,
            pLogicalProvider);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CConsumerProviderRecord::ResolveAndCache(
                            IWbemUnboundObjectSink** ppSink,
                            IWbemEventConsumerProvider** ppConsumerProvider,
                            IWbemEventConsumerProviderEx** ppConsumerProviderEx)
{
    // Resolve it first
    // ================

    HRESULT hres = Resolve(ppSink, ppConsumerProvider, ppConsumerProviderEx);
    if(FAILED(hres))
        return hres;

    // Cache if needed
    // ===============

    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();
        
        if(m_bResolved)
        {
            // Already cached.  Release ours. 
            // ==============================

            if(*ppSink)
                (*ppSink)->Release();
            if(*ppConsumerProvider)
                (*ppConsumerProvider)->Release();
            if(*ppConsumerProviderEx)
                (*ppConsumerProviderEx)->Release();

            // Use the cached one
            // ==================

            *ppSink = m_pSink;
            if(m_pSink)
                m_pSink->AddRef();

            *ppConsumerProvider = m_pConsumerProvider;
            if(m_pConsumerProvider)
                m_pConsumerProvider->AddRef();

            *ppConsumerProviderEx = m_pConsumerProviderEx;
            if(m_pConsumerProviderEx)
                m_pConsumerProviderEx->AddRef();
        }
        else
        {
            // Cache it
            // ========

            m_pSink = *ppSink;
            if(m_pSink)
                m_pSink->AddRef();

            m_pConsumerProvider = *ppConsumerProvider;
            if(m_pConsumerProvider)
                m_pConsumerProvider->AddRef();

            m_pConsumerProviderEx = *ppConsumerProviderEx;
            if(m_pConsumerProviderEx)
                m_pConsumerProviderEx->AddRef();
    
            m_bResolved = TRUE;
        }
    }

    return S_OK;
}

void CConsumerProviderRecord::FireNCSinkEvent(
    DWORD dwIndex, 
    IWbemClassObject *pLogicalConsumer)
{
    if (IS_NCEVENT_ACTIVE(dwIndex))
    {
        // Get the path of the logical consumer.
        VARIANT vPath;
        BSTR    strLogicalConsumerPath;
            
        VariantInit(&vPath);

        if (pLogicalConsumer && 
            SUCCEEDED(pLogicalConsumer->Get(L"__PATH", 0, &vPath, NULL, NULL)))
            strLogicalConsumerPath = V_BSTR(&vPath);
        else
            strLogicalConsumerPath = NULL;

        //
        // Report the event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[dwIndex], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_pNamespace->GetName(),
            m_wszProviderName,
            m_wszMachineName,
            strLogicalConsumerPath);
            
        VariantClear(&vPath);
    }
}

HRESULT CConsumerProviderRecord::FindConsumer(
                IN IWbemClassObject* pLogicalConsumer,
                OUT IWbemUnboundObjectSink** ppSink)
{
    HRESULT hres;

    // Check if consumer provider is cached
    // ====================================

    IWbemEventConsumerProvider* pConsumerProvider = NULL;
    BOOL bResolved = FALSE;
    
    {
        CInCritSec ics(&m_cs);
        m_LastAccess = CWbemTime::GetCurrentTime();

        if(m_bResolved)
        {
            pConsumerProvider = m_pConsumerProvider;
            if(pConsumerProvider)
                pConsumerProvider->AddRef();

            bResolved = TRUE;
        }
    }

    // Resolve if not cached
    // =====================

    if(!bResolved)
    {
        IWbemUnboundObjectSink* pGlobalSink;
        IWbemEventConsumerProviderEx* pConsumerProviderEx = NULL;

        hres = ResolveAndCache(&pGlobalSink, &pConsumerProvider, 
                                    &pConsumerProviderEx);
        if(FAILED(hres)) return hres;

        if(pGlobalSink)
            pGlobalSink->Release();
        if(pConsumerProviderEx)
            pConsumerProviderEx->Release();
    }

    if(pConsumerProvider == NULL)
        return E_NOINTERFACE;

    try
    {
        hres = pConsumerProvider->FindConsumer(pLogicalConsumer, ppSink);
    }
    catch(...)
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider %S in namespace %S "
            "threw an exception in FindConsumer\n", 
                m_wszProviderName, m_pNamespace->GetName()));
        hres = WBEM_E_PROVIDER_FAILURE;
    }

    if(SUCCEEDED(hres) && ppSink != NULL)
    {
        if(*ppSink == NULL)
        {
            ERRORTRACE((LOG_ESS, "Event consumer provider %S in namespace %S "
                "returned success from IWbemEventConsumerProvider::FindConsumer"
                " call while returning a NULL sink.  This behavior is invalid! "
                " Consumers will not receive events.\n", 
                m_wszProviderName, m_pNamespace->GetName()));
            return E_NOINTERFACE;
        }

        //
        // Report the MSFT_WmiConsumerProviderSinkLoaded event.
        //
        FireNCSinkEvent(
            MSFT_WmiConsumerProviderSinkLoaded,
            pLogicalConsumer);


        // Configure proxy settings
        // ========================

        if(m_bAnonymous)
        {
            hres = SetInterfaceSecurity(*ppSink, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
        }
        else
        {
            hres = WbemSetDynamicCloaking(*ppSink, RPC_C_AUTHN_LEVEL_CONNECT,
                        RPC_C_IMP_LEVEL_IDENTIFY);
        }
        if(FAILED(hres))
            return hres;
        else
            hres = WBEM_S_NO_ERROR;

    }
    pConsumerProvider->Release();

    return hres;
}

HRESULT CConsumerProviderRecord::Resolve(
                            IWbemUnboundObjectSink** ppSink,
                            IWbemEventConsumerProvider** ppConsumerProvider,
                            IWbemEventConsumerProviderEx** ppConsumerProviderEx)
{
    HRESULT hres;

    // Prepare for CoCreateInstance(Ex)
    // ================================

    COSERVERINFO* pServerInfo = NULL;
    DWORD dwClsCtx;
    if(m_wszMachineName)
    {
        pServerInfo = _new COSERVERINFO;
        if(pServerInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pServerInfo->pwszName = m_wszMachineName;
        pServerInfo->pAuthInfo = NULL;
        pServerInfo->dwReserved1 = 0;
        pServerInfo->dwReserved2 = 0;
        dwClsCtx = CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER;
    }
    else
    {
        dwClsCtx = CLSCTX_ALL;
    }

    CDeleteMe<COSERVERINFO> dm(pServerInfo);
    
    IUnknown* pProtoSink = NULL;
    if(m_wszMachineName)
    {
        //
        // Remote activation --- do everything ourselves
        //

        IClassFactory* pFactory;
        hres = WbemCoGetClassObject(m_clsid, dwClsCtx, pServerInfo,
                                IID_IClassFactory, (void**)&pFactory);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, 
                "Failed to get a class factory for CLSID on server %S.  "
                        "Return code %X\n",
                (pServerInfo?pServerInfo->pwszName:L"(local)"), hres));
            return hres;
        }
        CReleaseMe rm0(pFactory);
    
        if(pFactory == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL Class Factory received from event consumer "
                "%S.  Consumer needs to have its code examined\n", 
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }
                
        // Get the instance
        // ================
    
        hres = pFactory->CreateInstance(NULL, IID_IUnknown, (void**)&pProtoSink);
        if(FAILED(hres)) 
        {
            //
            // Try again at lower security
            //
            
            SetInterfaceSecurity(pFactory, NULL, NULL, NULL,
                            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
            hres = pFactory->CreateInstance(NULL, IID_IUnknown, (void**)&pProtoSink);
            if(SUCCEEDED(hres))
                m_bAnonymous = TRUE;
        }
        if(FAILED(hres)) 
        {
            ERRORTRACE((LOG_ESS, 
                "Failed to create an instance from a class factory for %S. "
                " Return code: %X\n", m_wszProviderName, hres));
            return hres;
        }
        if(pProtoSink == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
                "%S factory.  Consumer needs to have its code examined\n", 
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }
    }
    else // not REMOTE_SERVER
    {
        //
        // Use PSS
        //

        hres = m_pNamespace->LoadConsumerProvider(m_wszProviderName, 
                                    &pProtoSink);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "ESS unable to load consumer provider %S from "
                            "provider subsystem: 0x%X\n", 
                        (LPCWSTR)m_wszProviderName, hres));
            return hres;
        }
    }

    CReleaseMe rm1(pProtoSink);

    if(m_bAnonymous)
        SetInterfaceSecurity(pProtoSink, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
        

    // Query for the interfaces
    // ========================

    *ppSink = NULL;
    hres = pProtoSink->QueryInterface(IID_IWbemUnboundObjectSink, 
                            (void**)ppSink);
    if(FAILED(hres))
    {
        DEBUGTRACE((LOG_ESS, 
            "Consumer provider %S does not support "
                    "IWbemUnboundObjectSink: error code %X\n", 
                        m_wszProviderName, hres));
    }
    else
    {
        if(*ppSink == NULL)
        {
            ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
                "%S QueryInterface. Consumer needs to have its code examined\n",
                m_wszProviderName));
    
            return WBEM_E_PROVIDER_LOAD_FAILURE;
        }

        // Configure proxy settings
        // ========================

        if(m_bAnonymous)
        {
            hres = SetInterfaceSecurity(*ppSink, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
        }
        else
        {
            hres = WbemSetDynamicCloaking(*ppSink, RPC_C_AUTHN_LEVEL_CONNECT,
                        RPC_C_IMP_LEVEL_IDENTIFY);
        }
        if(FAILED(hres))
            return hres;
    }

    *ppConsumerProvider = NULL;
    hres = pProtoSink->QueryInterface(IID_IWbemEventConsumerProvider, 
                            (void**)ppConsumerProvider);
    if(FAILED(hres))
    {
    }
    else if(*ppConsumerProvider == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
            "%S QueryInterface.  Consumer needs to have its code examined\n", 
            m_wszProviderName));

        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }
    else
    {
        if(m_bAnonymous)
            SetInterfaceSecurity(*ppConsumerProvider, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
    }

    *ppConsumerProviderEx = NULL;
    hres = pProtoSink->QueryInterface(IID_IWbemEventConsumerProviderEx, 
                            (void**)ppConsumerProviderEx);
    if(FAILED(hres))
    {
    }
    else if(*ppConsumerProviderEx == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL object received from event consumer "
            "%S QueryInterface.  Consumer needs to have its code examined\n", 
            m_wszProviderName));

        return WBEM_E_PROVIDER_LOAD_FAILURE;
    }
    else
    {
        if(m_bAnonymous)
            SetInterfaceSecurity(*ppConsumerProviderEx, NULL, NULL, NULL,
                        RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_ANONYMOUS);
    }

   
    // Inform the cache that unloading may be required
    // ===============================================

    m_pNamespace->GetConsumerProviderCache().EnsureUnloadInstruction();

    //
    // Report the MSFT_WmiConsumerProviderLoaded event.
    //
    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiConsumerProviderLoaded], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        m_pNamespace->GetName(),
        m_wszProviderName,
        m_wszMachineName);

    return S_OK;
}
    


CConsumerProviderCache::~CConsumerProviderCache()
{
    if(m_pInstruction)
    {
        m_pInstruction->Terminate();
        m_pInstruction->Release();
    }
}

BOOL CConsumerProviderCache::DoesContain(IWbemClassObject* pProvReg, 
                                            IWbemClassObject* pConsumerReg)
{
    HRESULT hres;

    // Get its class list
    // ==================

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pProvReg->Get(L"ConsumerClassNames", 0, &v, NULL, NULL);

    if(SUCCEEDED(hres) && V_VT(&v) == (VT_BSTR | VT_ARRAY))
    {
        SAFEARRAY* psa = V_ARRAY(&v);
        long lLBound, lUBound;
        BSTR* astrData;
        SafeArrayGetLBound(psa, 1, &lLBound);
        SafeArrayGetUBound(psa, 1, &lUBound);
        SafeArrayAccessData(psa, (void**)&astrData);
        CUnaccessMe um(psa);
        
        for(int i = 0; i <= lUBound - lLBound; i++)
        {
            if(pConsumerReg->InheritsFrom(astrData[i]) == S_OK)
                return TRUE;
        }
    }

    return FALSE;
}
            
//
// Need a class for dynamic enumeration of consumer provider registrations
//

class CProviderRegistrationSink : public CObjectSink
{
protected:
    CConsumerProviderCache* m_pCache;
    IWbemClassObject* m_pLogicalConsumer;
    IWbemClassObject** m_ppReg;
public:
    CProviderRegistrationSink(CConsumerProviderCache* pCache, 
        IWbemClassObject* pLogicalConsumer, IWbemClassObject** ppReg) : 
            m_pCache(pCache), m_pLogicalConsumer(pLogicalConsumer),
            m_ppReg(ppReg)
    {
        AddRef();
        // same thread --- no need to AddRef paramters
    }
    ~CProviderRegistrationSink(){}
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        for(long i = 0; i < lNumObjects; i++)
        {
            //
            // Check if this one is ours
            //

            if(m_pCache->DoesContain(apObjects[i], m_pLogicalConsumer))
            {
                *m_ppReg = apObjects[i];
                (*m_ppReg)->AddRef();
                return WBEM_E_CALL_CANCELLED;
            }
        }
        return WBEM_S_NO_ERROR;
    }
};


INTERNAL CConsumerProviderRecord*
CConsumerProviderCache::GetRecord(IN IWbemClassObject* pLogicalConsumer)
{
    CInCritSec ics(&m_cs);
    HRESULT hres;

    //
    // Enumerate all the registrations into a sink that will check if this
    // one is the right one
    //


    IWbemClassObject* pReg = NULL;
    CProviderRegistrationSink Sink(this, pLogicalConsumer, &pReg);

    hres = m_pNamespace->CreateInstanceEnum(
        CONSUMER_PROVIDER_REGISTRATION_CLASS, 0, &Sink);

    if(pReg == NULL)
    {
        // Not found
        return NULL;
    }
    
    CReleaseMe rm1(pReg);

    // Get the Win32Provider record
    // ============================

    VARIANT vPath;
    hres = pReg->Get(CONSPROV_PROVIDER_REF_PROPNAME, 0, &vPath, NULL, NULL);
    if(FAILED(hres) || V_VT(&vPath) != VT_BSTR)
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider registration is invalid: "
                                "Provider property is missing\n"));
        return NULL;
    }

    INTERNAL BSTR strProviderRef = V_BSTR(&vPath);
    CClearMe cm2(&vPath);

    _IWmiObject* pProv = NULL;
    hres = m_pNamespace->GetInstance(V_BSTR(&vPath), &pProv);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Invalid event consumer provider registration: "
                                "dangling provider reference %S\n", 
                                    V_BSTR(&vPath)));
        return NULL;
    }

    CReleaseMe rm(pProv);

    // Get the name of the provider
    // ============================

    VARIANT vProvName;
    VariantInit(&vProvName);
    CClearMe cm3(&vProvName);

    hres = pProv->Get(PROVIDER_NAME_PROPNAME, 0, &vProvName, NULL, NULL);
    if(FAILED(hres) || V_VT(&vProvName) != VT_BSTR)
    {
        ERRORTRACE((LOG_ESS, "Event provider registration without a name at "
                        "%S\n", V_BSTR(&vPath)));
        return NULL;
    }
    INTERNAL BSTR strProviderName = V_BSTR(&vProvName);

    // Get the machine name 
    // ====================

    VARIANT vMachine;
    VariantInit(&vMachine);
    CClearMe cm4(&vMachine);

    hres = pLogicalConsumer->Get(CONSUMER_MACHINE_NAME_PROPNAME, 0, &vMachine, 
                                    NULL, NULL);
    if(FAILED(hres)) return NULL;

    INTERNAL BSTR strMachineName = NULL;
    if(V_VT(&vMachine) != VT_NULL)
        strMachineName = V_BSTR(&vMachine);

    // Search for the record
    // =====================

    BOOL bFound = FALSE;
    CConsumerProviderRecord* pRecord;
    for(int i = 0; i < m_apRecords.GetSize(); i++)
    {
        pRecord = m_apRecords[i];

        if(wbem_wcsicmp(pRecord->GetProviderName(), strProviderName))
            continue;
        if(pRecord->GetMachineName() && strMachineName)
        {
            if(wbem_wcsicmp(pRecord->GetMachineName(), strMachineName))
                continue;
        }
        else
        {
            if(pRecord->GetMachineName() != strMachineName)
                continue;
        }

        bFound = TRUE;
        break;
    }

    if(!bFound)
    {
        pRecord = new CConsumerProviderRecord(m_pNamespace);
        if(pRecord == NULL)
            return NULL;
        hres = pRecord->Initialize(pProv, strProviderRef, strProviderName, 
                                    strMachineName);
        if(m_apRecords.Add(pRecord) < 0)
        {
            delete pRecord;
            return NULL;
        }
    }

    pRecord->AddRef();
    return pRecord;
}

void CConsumerProviderCache::EnsureUnloadInstruction()
{
    CInCritSec ics(&m_cs);

    if(m_pInstruction == NULL)
    {
        m_pInstruction = new CConsumerProviderWatchInstruction(this);
        if(m_pInstruction)
        {
            m_pInstruction->AddRef();
            m_pNamespace->GetTimerGenerator().Set(m_pInstruction);
        }
    }
}

    
HRESULT CConsumerProviderCache::UnloadUnusedProviders(CWbemInterval Interval)
{
    CRefedPointerArray<CConsumerProviderRecord> apToInvalidate;
    BOOL bUnloaded = FALSE;

    {
        CInCritSec ics(&m_cs);
    
        BOOL bActiveLeft = FALSE;
        for(int i = 0; i < m_apRecords.GetSize(); i++)
        {
            CConsumerProviderRecord* pRecord = m_apRecords[i];
        
            // Prevent the record from being used while its fate is determined
            // ===============================================================
    
            if(pRecord->IsActive())
            {
                if(CWbemTime::GetCurrentTime() - pRecord->GetLastAccess() > 
                        Interval)
                {
                    apToInvalidate.Add(pRecord);
                    DEBUGTRACE((LOG_ESS, "Unloading consumer provider %S on "
                        "%S\n", pRecord->GetProviderName(), 
                                pRecord->GetMachineName()));
                    bUnloaded = TRUE;
                }
                else
                    bActiveLeft = TRUE;
            }
        }

        if(m_pInstruction && !bActiveLeft)
        {
            m_pInstruction->Terminate();
            m_pInstruction->Release();
            m_pInstruction = NULL;
        }
    }
    
    // Actually unload
    // ===============

    for(int i = 0; i < apToInvalidate.GetSize(); i++)
    {
        apToInvalidate[i]->Invalidate();
    }

    if(bUnloaded)
        m_pNamespace->GetTimerGenerator().ScheduleFreeUnusedLibraries();
    return WBEM_S_NO_ERROR;
}

HRESULT CConsumerProviderCache::RemoveConsumerProvider(LPCWSTR wszProviderRef)
{
    CInCritSec ics(&m_cs);
    for(int i = 0; i < m_apRecords.GetSize(); i++)
    {
        CConsumerProviderRecord* pRecord = m_apRecords[i];
    
        if(!wbem_wcsicmp(pRecord->GetProviderRef(), wszProviderRef))
        {
            // Matches --- remove
            // ==================

            DEBUGTRACE((LOG_ESS, "Removing consumer provider record: %S in %S"
                "\n", m_pNamespace->GetName(), wszProviderRef));

            m_apRecords.RemoveAt(i);
            i--;
        }
    }

    return WBEM_S_NO_ERROR;
}

// static
SYSFREE_ME BSTR CConsumerProviderCache::GetProviderRefFromRecord(
                        IWbemClassObject* pReg)
{
    VARIANT v;
    VariantInit(&v);
    if(FAILED(pReg->Get(CONSPROV_PROVIDER_REF_PROPNAME, 0, &v, NULL, NULL)) || 
            V_VT(&v) != VT_BSTR)
    {
        VariantClear(&v);
        return NULL;
    }
    else
    {
        // Variant intentionally not cleared
        return V_BSTR(&v);
    }
}

class CSingleElementSink : public CObjectSink
{
protected:
    IWbemClassObject** m_ppObj;
public:
    CSingleElementSink(IWbemClassObject** ppObj) : m_ppObj(ppObj)
    {
        AddRef();
    }

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        if(lNumObjects > 0)
        {
            *m_ppObj = apObjects[0];
            apObjects[0]->AddRef();
        }
        return S_OK;
    }
};



HRESULT CConsumerProviderCache::GetConsumerProviderRegFromProviderReg(
                        IWbemClassObject* pProv, 
                        IWbemClassObject** ppConsProv)
{
    HRESULT hres;

    // Get the path
    // ============

    VARIANT vPath;
    VariantInit(&vPath);
    if(FAILED(pProv->Get(L"__RELPATH", 0, &vPath, NULL, NULL)) || 
             V_VT(&vPath) != VT_BSTR)
    {
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }
    
    WString wsPath = WString(V_BSTR(&vPath)).EscapeQuotes();
    VariantClear(&vPath);

    // Construct the query
    // ===================

    DWORD cLen = wsPath.Length()*2 + 100;
    BSTR strQuery = SysAllocStringLen( NULL, cLen ); 

    if ( NULL == strQuery )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CSysFreeMe sfm(strQuery);

    StringCchPrintfW(
             strQuery, 
             cLen,
             L"select * from " CONSUMER_PROVIDER_REGISTRATION_CLASS L" where "
             L"Provider = \"%s\"",  (LPWSTR)wsPath);
    
    // Issue the query
    // ===============

    *ppConsProv = NULL;
    CSingleElementSink Sink(ppConsProv);
    hres = m_pNamespace->ExecQuery(strQuery, 0, &Sink);
    if(FAILED(hres))
        return hres;
    else if(*ppConsProv == NULL)
        return WBEM_E_NOT_FOUND;
    else 
        return WBEM_S_NO_ERROR;
}
    
void CConsumerProviderCache::Clear()
{
    CInCritSec ics(&m_cs);

    m_apRecords.RemoveAll();
    if(m_pInstruction)
    {
        m_pInstruction->Terminate();
        m_pInstruction->Release();
        m_pInstruction = NULL;
    }
}

    
void CConsumerProviderCache::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d consumer provider records\n", m_apRecords.GetSize());
}

// static 
CWbemInterval CConsumerProviderWatchInstruction::mstatic_Interval;
void CConsumerProviderWatchInstruction::staticInitialize(IWbemServices* pRoot)
{
    mstatic_Interval = 
            CBasicUnloadInstruction::staticRead(pRoot, GetCurrentEssContext(),
                                L"__EventConsumerProviderCacheControl=@");
}

CConsumerProviderWatchInstruction::CConsumerProviderWatchInstruction(
                                                CConsumerProviderCache* pCache)
    : CBasicUnloadInstruction(mstatic_Interval), m_pCache(pCache)
{}

HRESULT CConsumerProviderWatchInstruction::Fire(long, CWbemTime)
{
    if(!m_bTerminate)
    {
        CEssThreadObject Obj(NULL);
        SetConstructedEssThreadObject(&Obj);
    
        m_pCache->UnloadUnusedProviders(m_Interval);

        m_pCache->m_pNamespace->FirePostponedOperations();
        ClearCurrentEssThreadObject();
        return WBEM_S_NO_ERROR;
    }
    else
        return WBEM_S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\corefind.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  COREFIND.CPP
//
//  This file implements classes needed to search for event filters matching an
//  event.
//
//  See corefind.h for documentation.
//
//  History:
//
//  11/27/96    a-levn      Inefficient version compiles.
//  4/13/00     levn        Efficient version works.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "corefind.h"

CCoreEventProvider::CCoreEventProvider(CLifeControl* pControl) 
    : TUnkBase(pControl), m_pNamespace(NULL), m_pSink(NULL)
{
}

CCoreEventProvider::~CCoreEventProvider()
{
    Shutdown();
}

HRESULT CCoreEventProvider::Shutdown()
{
    if ( m_pNamespace )
    {
        CInEssSharedLock( &m_Lock, TRUE );

        if ( m_pSink != NULL )
        {
            m_pSink->Release();
            m_pSink = NULL;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CCoreEventProvider::SetNamespace( CEssNamespace* pNamespace )
{
    _DBG_ASSERT( m_pNamespace == NULL );

    //
    // don't hold reference, else there would be a circular ref.
    // We are guaranteed that as long as the we're alive the namespace will
    // be alive.
    // 
    
    if ( m_Lock.Initialize() )
    {
        m_pNamespace = pNamespace;
	    return S_OK;
    }
    
    return WBEM_E_OUT_OF_MEMORY;
}

STDMETHODIMP CCoreEventProvider::ProvideEvents( IWbemObjectSink* pSink, 
                                                long lFlags )
{
    CInEssSharedLock isl( &m_Lock, TRUE );

    _DBG_ASSERT( m_pSink == NULL );

    HRESULT hres;
    hres = pSink->QueryInterface(IID_IWbemEventSink, (void**)&m_pSink);
    if(FAILED(hres))
        return hres;
    
    return S_OK;
}

HRESULT CCoreEventProvider::Fire( CEventRepresentation& Event, 
                                  CEventContext* pContext )
{
    //
    // it is important to hold the shared lock the entire time because 
    // we must ensure that we're not going to use the sink after shutdown 
    // is called. 
    // 

    CInEssSharedLock isl( &m_Lock, FALSE );

    //
    // Check if the sink is active
    //

    if ( m_pSink == NULL || m_pSink->IsActive() != WBEM_S_NO_ERROR )
    {
        return WBEM_S_FALSE;
    }

    //
    // Convert to real event
    // 

    IWbemClassObject* pEvent;
    HRESULT hres = Event.MakeWbemObject(m_pNamespace, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pEvent);

    if ( pContext != NULL && pContext->GetSD() != NULL )
    {
        hres = SetSD( pEvent, pContext->GetSD() );
        if ( FAILED(hres) )
            return hres;
    }

    //
    // Fire it
    //

    hres = m_pSink->Indicate(1, (IWbemClassObject**)&pEvent);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\delivrec.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __DELIVREC_H__
#define __DELIVREC_H__

#include <wmimsg.h>
#include <wbemcli.h>
#include <arrtempl.h>
#include <comutl.h>
#include <winntsec.h>
#include <callsec.h>
#include <unk.h>
#include "evsink.h"

class CQueueingEventSink;
class CEssNamespace;


/*************************************************************************
  CDeliveryRecord
**************************************************************************/

class CDeliveryRecord : public CUnk // for ref counting
{
private:

    DWORD m_dwSize;
    CRefedPointerArray<IWbemClassObject> m_Events;
    CWbemPtr<IWbemCallSecurity> m_pCallSec;
    CEssNamespace * m_pNamespace;

    //
    // later we'll have a consumer id here.
    //

    HRESULT AdjustTotalSize( IWbemClassObject* pObj );
    void* GetInterface( REFIID ) { return NULL; }

public:

    CDeliveryRecord() : m_dwSize(0), m_pNamespace( NULL ) { }
    virtual ~CDeliveryRecord();
    
    void AddToCache( CEssNamespace * pNamespace, DWORD dwTotalSize, DWORD * pdwSleep );

    IWbemClassObject** GetEvents() { return m_Events.GetArrayPtr(); }
    IWbemCallSecurity* GetCallSecurity() { return m_pCallSec; }

    ULONG GetNumEvents() { return m_Events.GetSize(); }
    ULONG GetTotalBytes() { return m_dwSize; }

    void Clear() { m_Events.RemoveAll(); m_dwSize = 0; }

    HRESULT Initialize( IWbemClassObject** apEvents, 
                        ULONG cEvents,
                        IWbemCallSecurity* pCallSec = NULL );
    
    virtual HRESULT PreDeliverAction( ITransaction* ppTxn ) = 0;
    virtual HRESULT PostDeliverAction( ITransaction* pTxn, HRESULT hres ) = 0;
};

/*************************************************************************
  CExpressDeliveryRecord
**************************************************************************/

class CExpressDeliveryRecord : public CDeliveryRecord
{
    static CReuseMemoryManager mstatic_Manager;

public:

    HRESULT PreDeliverAction( ITransaction* ppTxn );
    HRESULT PostDeliverAction( ITransaction* pTxn, HRESULT hres );

    void* operator new(size_t nSize);
    void operator delete(void* p);
};

#endif // __DELIVREC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\delivrec.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <wbemint.h>
#include "delivrec.h"
#include "qsink.h"
#include "nsrep.h"

/*************************************************************************
  CDeliveryRecord
**************************************************************************/

CDeliveryRecord::~CDeliveryRecord()
{ 
    if ( m_pNamespace )
    {
        m_pNamespace->RemoveFromCache( m_dwSize );
    }

    Clear(); 
}

void CDeliveryRecord::AddToCache( CEssNamespace * pNamespace, DWORD dwTotalSize, DWORD * pdwSleep )
{
    _DBG_ASSERT( pNamespace );

    if ( NULL == m_pNamespace )
    {
        m_pNamespace = pNamespace;
    }

    m_pNamespace->AddToCache( m_dwSize, dwTotalSize, pdwSleep );
}


HRESULT CDeliveryRecord::Initialize( IWbemClassObject** apEvents, 
                                     ULONG cEvents,
                                     IWbemCallSecurity* pCallSec )
{
    HRESULT hr;

    Clear();

    m_pCallSec = pCallSec;

    for( ULONG i=0; i < cEvents; i++ )
    {
        //
        // TODO : should clone the object here later. 
        // 

        if ( m_Events.Add( apEvents[i] ) < 0 )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AdjustTotalSize( apEvents[i] );

        if ( FAILED(hr) )
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CDeliveryRecord::AdjustTotalSize( IWbemClassObject* pObj )
{
    HRESULT hr;

    CWbemPtr<_IWmiObject> pEventInt;
    
    hr = pObj->QueryInterface( IID__IWmiObject, (void**)&pEventInt );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    DWORD dwSize;
    
    hr = pEventInt->GetObjectMemory( NULL, 0, &dwSize );
    
    if ( FAILED(hr) && hr != WBEM_E_BUFFER_TOO_SMALL )
    {
        return hr;
    }
    
    m_dwSize += dwSize;

    return WBEM_S_NO_ERROR;
}

/*************************************************************************
  CExpressDeliveryRecord
**************************************************************************/

HRESULT CExpressDeliveryRecord::PreDeliverAction( ITransaction* pTxn )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CExpressDeliveryRecord::PostDeliverAction( ITransaction* pTxn, 
                                                   HRESULT hres )
{
    return WBEM_S_NO_ERROR;
}

CReuseMemoryManager CExpressDeliveryRecord::mstatic_Manager(sizeof CExpressDeliveryRecord);

void *CExpressDeliveryRecord::operator new(size_t nBlock)
{
    return mstatic_Manager.Allocate();
}
void CExpressDeliveryRecord::operator delete(void* p)
{
    mstatic_Manager.Free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\equeue.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EQUEUE.H
//
//  This file defines the classes for a queue of events which have matched 
//  some of the filters and will have to be dispatched.
//
//  Classes defined:
//
//      CEventQueue
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================

#ifndef __EVENT_QUEUE__H_
#define __EVENT_QUEUE__H_

#include "binding.h"
#include <wbemcomn.h>
#include <execq.h>

class CEss;

//*****************************************************************************
//
//  class CEventQueue
//
//  This class stores a queue of events that need to be dispatched to 
//  consumers. It also handles the actual dispatcher functionality: when an
//  instance of this class is created (and there expected to be only one), a 
//  new thread is created which will wake up when new requests are added to the
//  queue and process them.
//
//*****************************************************************************

class CEventQueue : public CExecQueue
{
protected:
    class CDeliverRequest : public CExecRequest
    {
    private: 
        CQueueingEventSink* m_pConsumer;
    public:
        CDeliverRequest(CQueueingEventSink* pConsumer);
        ~CDeliverRequest();
        HRESULT Execute();
    };

    CEss* m_pEss;

protected:
    virtual void ThreadMain(CThreadRecord* pRecord);
    HRESULT InitializeThread();
    void UninitializeThread();

public:
    CEventQueue(STORE CEss* pEss);

    HRESULT EnqueueDeliver(CQueueingEventSink* pConsumer);
    void DumpStatistics(FILE* f, long lFlags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\equeue.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EQUEUE.CPP
//
//  This file implements the classes for a queue of events which have matched
//  some of the filters and will have to be dispatched.
//
//  See equeue.h for documentation
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "equeue.h"
#include <cominit.h>
#include "NCEvents.h"

CEventQueue::CDeliverRequest::CDeliverRequest(CQueueingEventSink* pConsumer)
    : m_pConsumer(pConsumer)
{
    m_pConsumer->AddRef();
}

CEventQueue::CDeliverRequest::~CDeliverRequest()
{
    m_pConsumer->Release();
}

HRESULT CEventQueue::CDeliverRequest::Execute()
{
    return m_pConsumer->DeliverAll();
}


//*****************************************************************************
//************************ CEventQueue ****************************************
//*****************************************************************************

CEventQueue::CEventQueue(CEss* pEss) : m_pEss(pEss)
{
    SetThreadLimits(100, 100, -1);
}

HRESULT CEventQueue::InitializeThread()
{
    HRESULT hr;
    if (FAILED(hr = CExecQueue::InitializeThread())) return hr;
    //
    // Report the MSFT_WmiThreadPoolThreadCreated event.
    //

    FIRE_NCEVENT( g_hNCEvents[MSFT_WmiThreadPoolThreadCreated], 
                  WMI_SENDCOMMIT_SET_NOT_REQUIRED,
                  GetCurrentThreadId());
    return S_OK;
}

void CEventQueue::UninitializeThread()
{
    //
    // Report the MSFT_WmiThreadPoolThreadDeleted event.
    //

    FIRE_NCEVENT( g_hNCEvents[MSFT_WmiThreadPoolThreadDeleted], 
                  WMI_SENDCOMMIT_SET_NOT_REQUIRED,
                  GetCurrentThreadId() );
    
    CExecQueue::UninitializeThread();
}

void CEventQueue::ThreadMain(CThreadRecord* pRecord)
{    
    try
    {
        CExecQueue::ThreadMain(pRecord);
    }
    catch(...)
    {
        // Exit this thread gracefully
        // ===========================

        ShutdownThread(pRecord);
    }
}
        

HRESULT CEventQueue::EnqueueDeliver(CQueueingEventSink* pConsumer)
{
    // Create a new request
    // ====================
    HRESULT hr;
    CDeliverRequest* pRequest = new CDeliverRequest(pConsumer);
    if(pRequest == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if FAILED(hr = CExecQueue::Enqueue(pRequest))
    {
        delete pRequest;
    }
    return hr;
}

void CEventQueue::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d requests (%d threads) on the main queue\n", m_lNumRequests,
        m_lNumThreads);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\ess.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESS.H
//
//  Implements the class that contains all the fuctionality of the ESS by 
//  virtue of containing all the necessary components.
//
//  Classes defined:
//
//      CEss
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//  1/6/97      a-levn      Updated to initialize TSS.
//
//=============================================================================
#ifndef __ESS__H_
#define __ESS__H_

#include "pragmas.h"
#include "nsrep.h"
#include "equeue.h"
#include "wbemtss.h"
#include "sleeper.h"
#include <evtlog.h>
#include <wmimsg.h>
#include <wstlallc.h>

//*****************************************************************************
//
//  class CEss
//
//  This class is the central "collection point" for the ESS. It contains the
//  list of namespace objects and some shared components.
//
//*****************************************************************************

class CInitActiveNamespacesRequest;
class CInitNamespaceRequest;  

class CEss
{
protected:
    typedef std::map<WString, CEssNamespace*, WSiless, 
                        wbem_allocator<CEssNamespace*> > TNamespaceMap;

    typedef TNamespaceMap::iterator TNamespaceIterator;

    TNamespaceMap m_mapNamespaces;
    CWinMgmtTimerGenerator m_TimerGenerator;
    CEventQueue m_Queue;
    IWbemLocator* m_pLocator;
    _IWmiCoreServices* m_pCoreServices;
    _IWmiProvSS* m_pProvSS;
    _IWmiProvSSSink* m_pProvSSSink;
    LPWSTR m_wszServerName; 

    IWbemDecorator* m_pDecorator;

    long m_lObjectCount;
    long m_lNumActiveNamespaces;

    CEventLog m_EventLog;
    CRegistryMinMaxLimitControl m_LimitControl;
    IWbemTokenCache* m_pTokenCache;
    HANDLE m_hReadyEvent;

    BOOL  m_bLastCallForCoreCalled;
    
    CCritSec m_cs;

    //
    // the number of namespaces that were active on startup by are still 
    // initializating. 
    //
    long m_lOutstandingActiveNamespaceInit;

    //
    // we use a background thread to perform recovery of guaranteed 
    // event deliveries.  
    // 
    HANDLE m_hRecoveryThread;
    HRESULT InitiateRecovery(); 
    static ULONG WINAPI PerformRecovery( void* pCtx );
    
    HANDLE m_hExitBootPhaseTimer;
    static void CALLBACK ExitBootPhaseCallback( LPVOID, BOOLEAN );
    void ExecuteDeferredNSInitRequests();

    //
    // If we are in the boot phase, then we will queue up the ns init events
    // until we're out of the boot phase.
    //
    CPointerArray<CExecRequest> m_aDeferredNSInitRequests;

    BOOL m_bMSMQDisabled;

public:
    CEss();
    ~CEss();

    void TriggerDeferredInitialization();

    HRESULT Initialize( LPCWSTR wszServer,
                        long lFlags,
                        _IWmiCoreServices* pCoreServices,
                        IWbemDecorator* pDecorator );

    HRESULT Shutdown(BOOL bIsSystemShutdown);
    HRESULT LastCallForCore(LONG lSystemShutDown);

    HRESULT GetNamespaceObject( LPCWSTR wszNamespace,
                                BOOL bEnsureActivation,
                                RELEASE_ME CEssNamespace** ppNamespace );

    HRESULT GetNamespacePointer( LPCWSTR wszNamespace,
                                 BOOL bRepositoryOnly,
                                 RELEASE_ME IWbemServices** ppNamespace );

    HRESULT Decorate(IWbemClassObject* pObject, LPCWSTR wszNamespace);
    HRESULT GetProviderFactory(LPCWSTR wszNamespace, IWbemServices* pNamespace,
                                _IWmiProviderFactory** ppFactory);

    HRESULT ReloadProvider( long lFlags, 
                            LPCWSTR wszNamespace, 
                            LPCWSTR wszName );

    HRESULT PurgeNamespace(LPCWSTR wszNamespace);

    HRESULT ProcessEvent(READ_ONLY CEventRepresentation& Event, long lFlags);
    HRESULT ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event );
    HRESULT VerifyInternalEvent(READ_ONLY CEventRepresentation& Event);

    HRESULT RegisterNotificationSink(WBEM_CWSTR wszNamespace, 
                            WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, 
                            long lFlags, IWbemContext* pContext, 
                            IWbemObjectSink* pSink);
    HRESULT RemoveNotificationSink(IWbemObjectSink* pSink);

    CWinMgmtTimerGenerator& GetTimerGenerator() {return m_TimerGenerator;}
    CEventLog& GetEventLog() {return m_EventLog;}

    void IncrementObjectCount();
    void DecrementObjectCount();

    HRESULT SetNamespaceActive(LPCWSTR wszNamespace);
    HRESULT SetNamespaceInactive(LPCWSTR wszNamespace);
    HRESULT SaveActiveNamespaceList();
    HRESULT RequestStartOnBoot(BOOL bStart = TRUE);
    HRESULT InitializeTimerGenerator(LPCWSTR wszNamespace, 
                    IWbemServices* pNamespace);

    static HRESULT DecorateObject(IWbemClassObject* pObj, LPCWSTR wszNamespace);

    HRESULT EnqueueDeliver(CQueueingEventSink* pDest);
    HRESULT Enqueue(CExecRequest* pReq);

    HRESULT AddSleepCharge(DWORD dwSleep);
    HRESULT AddCache();
    HRESULT RemoveCache();
    HRESULT AddToCache(DWORD dwAdd, DWORD dwMemberTotal, 
                        DWORD* pdwSleep = NULL);
    HRESULT RemoveFromCache(DWORD dwRemove);
    HRESULT GetToken(PSID pSid, IWbemToken** ppToken);

    HRESULT CreatePersistentQueue( LPCWSTR wszQueueName, DWORD dwQos );
    HRESULT DestroyPersistentQueue( LPCWSTR wszQueueName );

    void DumpStatistics(FILE* f, long lFlags);

    //
    // each namespace that is active on startup notifies us when it has 
    // finished initialization. 
    //
    void NotifyActiveNamespaceInitComplete();

protected:

    typedef CPointerArray<CInitActiveNamespacesRequest> InitActiveNsRequestList;

    HRESULT PrepareNamespaceInitRequest( 
                                      LPCWSTR wszNamespace,
                                      CInitActiveNamespacesRequest* pRequest );

    HRESULT PrepareNamespaceInitRequests( IWbemServices* pRoot,
                                          BOOL bRediscover,
                                          InitActiveNsRequestList& aRequests);
   
    HRESULT RecursivePrepareNamespaceInitRequests(
                                       LPCWSTR wszNamespace,
                                       IWbemServices* pNamespace, 
                                       CInitActiveNamespacesRequest* pRequest);

    HRESULT ScheduleNamespaceInitialize( CExecRequest* pReq );

    HRESULT LoadActiveNamespaces( IWbemServices* pRoot, BOOL bRediscover );

    HRESULT CreateNamespaceObject( LPCWSTR wszNormName, 
                                   CEssNamespace** ppNamespace );

    HRESULT LoadNamespaceObject( LPCWSTR wszNamespace, 
                                 BOOL bKnownEmpty,
                                 RELEASE_ME CEssNamespace** ppNamespace );
    inline HRESULT GetQueueManager( IWmiMessageQueueManager** ppQueueMgr );
 
    friend class CInObjectCount;
};

class CInObjectCount
{
protected:
    CEss* m_pEss;
public:
    CInObjectCount(CEss* pEss) : m_pEss(pEss)
    {
        m_pEss->IncrementObjectCount();
    }
    ~CInObjectCount()
    {
        m_pEss->DecrementObjectCount();
    }
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\ess.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESS.CPP
//
//  Implements the class that contains all the fuctionality of the ESS by 
//  virtue of containing all the necessary components.
//
//  See ess.h for documentation
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//  1/6/97      a-levn      Updated to initialize TSS.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include <wmimsg.h>
#include "ess.h"
#include "persistcfg.h"
#include "WinMgmtR.h"
#include "GenUtils.h" // For SetObjectAccess
#include "NCEvents.h"
#include "Quota.h"

#define BOOT_PHASE_MS 60*2*1000

#define WBEM_REG_ESS_ACTIVE_NAMESPACES __TEXT("List of event-active namespaces")
#define WBEM_ESS_OPEN_FOR_BUSINESS_EVENT_NAME L"WBEM_ESS_OPEN_FOR_BUSINESS"

// The use of this pointer to initialize parent class is valid in this context
#pragma warning(disable : 4355) 

//
// this guid is used to identify the MSMQ queues that are used for guaranteed
// delivery.  A type guid is a property of an MSMQ queue, so one can tell 
// by looking at an MSMQ queue if its an ess one or not. 
//
// {555471B4-0BE3-4e42-A98B-347AF72898FA}
//
const CLSID g_guidQueueType =  
{ 0x555471b4, 0xbe3, 0x4e42, {0xa9, 0x8b, 0x34, 0x7a, 0xf7, 0x28, 0x98, 0xfa}};

#pragma warning(push)

// not all control paths return due to infinite loop
#pragma warning(disable:4715)  

DWORD DumpThread(CEss* pEss)
{
    while(1)
    {
        FILE* f = fopen("c:\\stat.log", "a");
        if(f == NULL)
            return 1;
        pEss->DumpStatistics(f, 0);
        fclose(f);
        Sleep(10000);
    }
    return 0;
}
#pragma warning(pop)

DWORD RegDeleteSubKeysW( HKEY hkey )
{
    FILETIME ft;
    DWORD dwIndex=0;
    LONG lRes = ERROR_SUCCESS;
    LONG lResReturn = lRes;
    DWORD dwBuffSize = 256;
    DWORD cName = dwBuffSize;
    LPWSTR wszName = new WCHAR[dwBuffSize];

    if ( wszName == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CWStringArray awsKeysToDelete;

    //
    // enumerate through all subkeys and make recursive call.
    // 

    while( lRes == ERROR_SUCCESS && 
          ( lRes=RegEnumKeyExW( hkey, dwIndex, wszName, &cName, NULL,
                                NULL, NULL, &ft ) ) != ERROR_NO_MORE_ITEMS )
    {
        if ( lRes == ERROR_SUCCESS )
        {
            HKEY hkeySub;

            //
            // open key and make recursive call.
            // 
            
            lRes = RegOpenKeyExW( hkey, 
                                  wszName, 
                                  0, 
                                  KEY_ALL_ACCESS, 
                                  &hkeySub );
            
            if ( lRes == ERROR_SUCCESS )
            {
                lRes = RegDeleteSubKeysW( hkeySub );
                RegCloseKey( hkeySub );
            }

            //
            // defer deletion of key until we're done enumerating.
            // 

            try 
            {
                awsKeysToDelete.Add( wszName );
            }
            catch( CX_MemoryException )
            {
                lRes = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // we want to try to keep going if we fail.
            //
            
            if ( lRes != ERROR_SUCCESS )
            {
                lResReturn = lRes;
                lRes = ERROR_SUCCESS;
            }

            dwIndex++;                
        }
        else if ( lRes == ERROR_MORE_DATA )
        {
            dwBuffSize += 256;
            delete [] wszName;
            wszName = new WCHAR[dwBuffSize];
            
            if ( wszName == NULL )
            {
                lRes = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
            	  lRes = ERROR_SUCCESS;
            }
        }

        cName = dwBuffSize;
    }

    delete [] wszName;

    for( int i=0; i < awsKeysToDelete.Size(); i++ )
    {
        lRes = RegDeleteKeyW( hkey, awsKeysToDelete[i] );

        if ( lRes != ERROR_SUCCESS )
        {
            lResReturn = lRes;
        }
    }
     
    return lResReturn;
}

/****************************************************************************
  CProviderReloadRequest
*****************************************************************************/

class CProviderReloadRequest : public CExecRequest
{
protected:
    CEss* m_pEss;
    long m_lFlags;
    CWbemPtr<IWbemContext> m_pContext;
    WString m_wsNamespace;
    WString m_wsProvider;

public:

    CProviderReloadRequest( CEss* pEss,
                            long lFlags,
                            IWbemContext* pContext,
                            LPCWSTR wszNamespace,
                            LPCWSTR wszProvider )
    : m_pEss( pEss ), m_lFlags( lFlags ), m_pContext( pContext ), 
      m_wsNamespace(wszNamespace),  m_wsProvider( wszProvider ) {}

    HRESULT Execute();
};

HRESULT CProviderReloadRequest::Execute()
{
    HRESULT hr;

    _DBG_ASSERT( GetCurrentEssThreadObject() == NULL );

    SetCurrentEssThreadObject( m_pContext );
    
    if ( GetCurrentEssThreadObject() != NULL )
    {
        hr = m_pEss->ReloadProvider( m_lFlags, 
                                     m_wsNamespace,
                                     m_wsProvider );

        delete GetCurrentEssThreadObject();
        ClearCurrentEssThreadObject();
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}
    
/****************************************************************************
  CEssProvSSSink
*****************************************************************************/
 
class CEssProvSSSink : public CUnkBase<_IWmiProvSSSink, &IID__IWmiProvSSSink >
{
    CEss* m_pEss;

public:

    CEssProvSSSink( CEss* pEss ) : m_pEss( pEss ),
     CUnkBase< _IWmiProvSSSink, &IID__IWmiProvSSSink >( NULL ) { }

    STDMETHOD(Synchronize)( long lFlags,
                       IWbemContext* pContext, 
                       LPCWSTR wszNamespace, 
                       LPCWSTR wszProvider );
};

STDMETHODIMP CEssProvSSSink::Synchronize( long lFlags,
                                     IWbemContext* pContext,
                                     LPCWSTR wszNamespace,
                                     LPCWSTR wszProvider )
{
    HRESULT hr;
    
    CProviderReloadRequest* pReq;

    try
    {    
        pReq = new CProviderReloadRequest( m_pEss,
                                           lFlags,
                                           pContext,
                                           wszNamespace,
                                           wszProvider );
    }
    catch( CX_MemoryException )
    {
        pReq = NULL;  
    }

    if ( pReq != NULL )
    {
        hr = m_pEss->Enqueue( pReq );
        
        if ( FAILED(hr) )
        {
            delete pReq;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    
    return hr;
}

/***************************************************************************
  CNamespaceInitRequest - Used to execute a single namespace initialize.  It 
  can be set to perform various stages of Namespace initialization.  
****************************************************************************/
class CNamespaceInitRequest : public CExecRequest
{
protected:
    BOOL m_bActiveOnStart;
    CWbemPtr<CEssNamespace> m_pNamespace;
    CWbemPtr<IWbemContext> m_pContext;

public:

    CNamespaceInitRequest( CEssNamespace* pNamespace, BOOL bActiveOnStart )
    : m_pNamespace(pNamespace), m_bActiveOnStart( bActiveOnStart )
    {
        m_pContext = GetCurrentEssContext();
    }

    HRESULT Execute()
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        _DBG_ASSERT( GetCurrentEssThreadObject() == NULL );

        SetCurrentEssThreadObject( m_pContext );

        if ( GetCurrentEssThreadObject() != NULL )
        {
            //
            // if this namespace was active on boot, then it has already had
            // its Initialize() called.
            //

            if ( !m_bActiveOnStart ) 
            {
                hr = m_pNamespace->Initialize();
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_pNamespace->CompleteInitialization();
            }

            m_pNamespace->MarkAsInitialized( hr );
        
            delete GetCurrentEssThreadObject();
            ClearCurrentEssThreadObject();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        //
        // if we're initializing because the namespace was active on 
        // startup then notify ess that we're done because its waiting 
        // for all active namespaces to finish initializing.
        // 

        if ( m_bActiveOnStart )
        {
            m_pNamespace->GetEss()->NotifyActiveNamespaceInitComplete();
        }

        if(FAILED(hr))
        {
            ERRORTRACE((LOG_ESS, "ESS failed to initialize a namespace "
                    "'%S'. Error code 0x%X\n", m_pNamespace->GetName(), hr));
        }
        
        return hr;
    }
};

/**************************************************************************
  CInitActiveNamespacesRequest - Used to initialize 1 or more active event 
  namespaces.  An active event namespace is one that was active on the last 
  shutdown.  The reason for initialization of multiple namespaces together is
  that the Stage1 Initialization of dependent active namespaces must complete
  before the Stage2 Initialization of any one of them.  This is so all 
  inter-namespace subscriptions can be put in place before event providers 
  are activated in any one of them.  Enforcing that all stage1 initialization 
  of dependent active namespaces does not cause a problem of all namespaces 
  being doomed by one faulty class provider in any single namespace because 
  stage1 init is guaranteed not to access any providers.  All stage2 init of 
  dependent active namespace, which may access providers, is performed 
  asynchronously. 
****************************************************************************/

class CInitActiveNamespacesRequest : public CExecRequest
{
protected:

    CEss* m_pEss;
    CRefedPointerArray<CEssNamespace> m_apNamespaces;
    CWbemPtr<IWbemContext> m_pContext;
    
public:
 
    CInitActiveNamespacesRequest( CEss* pEss ) : m_pEss(pEss) 
    { 
        m_pContext = GetCurrentEssContext();
    }

    int GetNumNamespaces() { return m_apNamespaces.GetSize(); }

    void Reset()
    {
        m_apNamespaces.RemoveAll();
    }

    HRESULT Add( CEssNamespace* pNamespace )
    {
        if ( m_apNamespaces.Add( pNamespace ) < 0 ) 
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        return WBEM_S_NO_ERROR;
    }

    HRESULT Execute()
    {
        HRESULT hr;
        HRESULT hrGlobal = WBEM_S_NO_ERROR;

        _DBG_ASSERT( GetCurrentEssThreadObject() == NULL );

        SetCurrentEssThreadObject( m_pContext );

        if ( GetCurrentEssThreadObject() == NULL )
        {
            for( int i=0; i < m_apNamespaces.GetSize(); i++ )
            {
                m_pEss->NotifyActiveNamespaceInitComplete();
            }

            return WBEM_E_OUT_OF_MEMORY;
        }

        for( int i=0; i < m_apNamespaces.GetSize(); i++ )
        {
            hr = m_apNamespaces[i]->Initialize();

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS, "ESS failed to initialize active "
                            "namespace '%S'. Error code 0x%x\n", 
                             m_apNamespaces[i]->GetName(), hr ));
                
                m_apNamespaces[i]->MarkAsInitialized(hr);
                m_apNamespaces.SetAt(i, NULL);
                m_pEss->NotifyActiveNamespaceInitComplete();
                hrGlobal = hr;
            }
        }

        for( int i=0; i < m_apNamespaces.GetSize(); i++ )
        {
            if ( m_apNamespaces[i] == NULL )
            {
                continue;
            }

            CNamespaceInitRequest* pReq;
            pReq = new CNamespaceInitRequest( m_apNamespaces[i], TRUE );

            if ( pReq != NULL )
            {
                hr = m_pEss->Enqueue( pReq );
                if (FAILED(hr))
                {
                    delete pReq;
                }
            }
            else
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS, "ESS failed to issue request for "
                            "completion of init for namespace '%S'. HR=0x%x\n",
                             m_apNamespaces[i]->GetName(), hr ));

                m_apNamespaces[i]->MarkAsInitialized( hr );
                m_pEss->NotifyActiveNamespaceInitComplete();
                hrGlobal = hr;
            }
        }

        _DBG_ASSERT( GetCurrentEssContext() == m_pContext ); 
        delete GetCurrentEssThreadObject();
        ClearCurrentEssThreadObject();

        return hrGlobal;
    }
};
    

inline LPWSTR NormalizeNamespaceString( LPCWSTR wszName )
{
    int cLen = wcslen( wszName ) + 5; // 5 is for '\\.\' + '\0'

    LPWSTR wszNormName = new WCHAR[cLen]; 

    if ( wszNormName == NULL )
    {
        return NULL;
    }

    if ( wcsncmp( wszName, L"\\\\", 2 ) == 0 || 
         wcsncmp( wszName, L"//", 2 ) == 0 )
    {
        StringCchCopyW( wszNormName, cLen, wszName );
    }
    else 
    {
        StringCchCopyW( wszNormName, cLen, L"\\\\.\\" );
        StringCchCatW( wszNormName, cLen, wszName );
    }

    //
    // also convert all backwards slashes to forward slashes so that the 
    // normalized name can serve as both a valid wmi namespace string and as 
    // a valid persistent string ( wrt msmq and registry keys ).
    //

    WCHAR* pch = wszNormName;
    while( *pch != '\0' )
    {
        if ( *pch == '\\' )
        {
            *pch = '/';
        }
        pch++;
    }       

    return wszNormName;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
CEss::CEss() : m_pLocator(NULL), m_pCoreServices(NULL), m_Queue(this), 
    m_TimerGenerator(this), m_hExitBootPhaseTimer(NULL),
    m_wszServerName(NULL), m_lObjectCount(0), m_lNumActiveNamespaces(0),
    m_hReadyEvent(NULL), m_pProvSS(NULL),  m_bLastCallForCoreCalled(FALSE),
    m_pProvSSSink(NULL), m_pTokenCache(NULL), m_pDecorator(NULL),
    m_hRecoveryThread(NULL), m_lOutstandingActiveNamespaceInit(0), 
    m_bMSMQDisabled(FALSE),
    m_LimitControl(LOG_ESS, L"events held for consumers", 
               L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
               L"Low Threshold On Events (B)",
               L"High Threshold On Events (B)",
               L"Max Wait On Events (ms)")
{
    // Set the defaults for the limit control and read it from the registry
    // ====================================================================

    m_LimitControl.SetMin(10000000);
    m_LimitControl.SetMax(20000000);
    m_LimitControl.SetSleepAtMax(2000);
    m_LimitControl.Reread();

    InitNCEvents();
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEss::LastCallForCore(LONG lIsSystemShutdown)
{

    m_bLastCallForCoreCalled = TRUE;
    
    // Shut down the timer generator (needs persistence)
    // =================================================
    m_TimerGenerator.SaveAndRemove(lIsSystemShutdown);

    return WBEM_S_NO_ERROR;
}

HRESULT CEss::Shutdown(BOOL bIsSystemShutdown)
{ 
    HRESULT hres;

    _DBG_ASSERT(m_bLastCallForCoreCalled);

    if ( m_hReadyEvent != NULL )
    {
        //
        // we must reset the ready event before parking the namespace.
        // this way providers can maybe tell why they are being shutdown.
        //
        ResetEvent( m_hReadyEvent );
    }

    // Get persistent storage up-to-date
    // =================================

    std::vector< CWbemPtr<CEssNamespace>, 
        wbem_allocator< CWbemPtr<CEssNamespace> > > Namespaces;

    {
        CInCritSec ics(&m_cs);

        m_TimerGenerator.SaveAndRemove((LONG)FALSE);

        TNamespaceIterator it;
        for( it = m_mapNamespaces.begin();it != m_mapNamespaces.end(); it++ )
            Namespaces.push_back( it->second );
    }    

    for( int i=0; i < Namespaces.size(); i++ )
    {
        try {
            Namespaces[i]->Park();
        } catch (CX_Exception &){};
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEss::RequestStartOnBoot(BOOL bStart)
{
    CPersistentConfig per;
    per.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, bStart);
    SaveActiveNamespaceList();
    
    return WBEM_S_NO_ERROR;
}

CEss::~CEss() 
{
    if( GetCurrentEssThreadObject() == NULL )
    {
        SetCurrentEssThreadObject(NULL);
    }

    m_EventLog.Close();
    
    if(m_pTokenCache)
    {
        m_pTokenCache->Shutdown();
    }

    //
    // make sure that recovery has finished. 
    //
    if ( m_hRecoveryThread != NULL )
    {
        WaitForSingleObject( m_hRecoveryThread, INFINITE );
        CloseHandle( m_hRecoveryThread );
        m_hRecoveryThread = NULL;
    }

    //
    // Shutdown the quotas. This must be done before we cleanup the 
    // namespaces because it uses the root namespace for registering
    // for quota change events.
    //
    g_quotas.Shutdown();

    m_TimerGenerator.Shutdown();

    // Clear the namespace map
    // =======================

    BOOL bLeft = TRUE;
    do
    {
        // Retrieve the next namespace object and remove it from the map
        // =============================================================

        CEssNamespace* pNamespace = NULL;
        {
            CInCritSec ics(&m_cs);

            TNamespaceIterator it = m_mapNamespaces.begin();
            if(it != m_mapNamespaces.end())
            {
                pNamespace = it->second;
                m_mapNamespaces.erase(it);
            }
        }

        // Shut it down if retrieved
        // =========================

        if(pNamespace)
        {
            pNamespace->Shutdown();
            pNamespace->Release();
        }

        // Check if any are left
        // =====================
        {
            CInCritSec ics(&m_cs);
            bLeft = !m_mapNamespaces.empty();
        }

    } while(bLeft);

    //
    // make sure we remove the callback timer so that we're sure that no 
    // callbacks occur after we destruct.  Make sure that we're not holding 
    // the critsec at this point because their could be a deadlock, since 
    // the callback could be executing right now and be waiting for the 
    // critsec.  We would then deadlock when calling DeleteTimerQueueTimer()
    //

    if ( m_hExitBootPhaseTimer != NULL )
    {
        DeleteTimerQueueTimer( NULL,
                              m_hExitBootPhaseTimer, 
                              INVALID_HANDLE_VALUE );
    }

    m_Queue.Shutdown();

    delete GetCurrentEssThreadObject();
    ClearCurrentEssThreadObject();

    if ( m_pProvSS != NULL && m_pProvSSSink != NULL )
    {
        m_pProvSS->UnRegisterNotificationSink( 0, NULL, m_pProvSSSink );
    }

    CEventRepresentation::Shutdown();
    CEventAggregator::Shutdown();
    if(m_pLocator) 
        m_pLocator->Release();
    if(m_pCoreServices) 
        m_pCoreServices->Release();
    if(m_pProvSS)
        m_pProvSS->Release();
    if(m_pProvSSSink)
        m_pProvSSSink->Release();
    if(m_pDecorator) 
        m_pDecorator->Release();

    delete [] m_wszServerName;
    m_pTokenCache->Release();
    
    CEssThreadObject::ClearSpecialContext();

    for( int i=0; i < m_aDeferredNSInitRequests.GetSize(); i++ )
        delete m_aDeferredNSInitRequests[i];

    DeinitNCEvents();

    m_Queue.Shutdown();

    if ( m_hReadyEvent != NULL )
    {
        CloseHandle( m_hReadyEvent );
    }
}

HRESULT CEss::SetNamespaceActive(LPCWSTR wszNamespace)
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace;

    DEBUGTRACE((LOG_ESS,"Namespace %S is becoming Active\n", wszNamespace));

    //
    // If this is the first active namespace, request that WinMgmt load us the
    // next time around
    //

    if(m_lNumActiveNamespaces++ == 0)
    {
        RequestStartOnBoot(TRUE);
    }

    //
    // open ess key. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );
    //
    // open or create namespace key.
    // 

    if ( lRes == ERROR_SUCCESS )
    {
        lRes = RegCreateKeyExW( hkeyEss,
                                wszNamespace,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyNamespace,
                                NULL );

        if ( lRes == ERROR_SUCCESS )
        {
            RegCloseKey( hkeyNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    if ( lRes != ERROR_SUCCESS )
    {
        ERRORTRACE((LOG_ESS,"Error adding active namespace key %S to "
                    "registry. Res=%d\n", wszNamespace, lRes ));
    }
        
    return HRESULT_FROM_WIN32( lRes );
}

HRESULT CEss::SetNamespaceInactive(LPCWSTR wszNamespace)
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace;
    
    DEBUGTRACE((LOG_ESS,"Namespace %S is becoming Inactive\n", wszNamespace));

    //
    // If this is the last active namespace, request that WinMgmt not load us 
    // the next time around
    //

    if(--m_lNumActiveNamespaces == 0)
    {
        RequestStartOnBoot(FALSE);
    }

    //
    // open ess key. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );

    //
    // delete namespace key
    // 

    if ( lRes == ERROR_SUCCESS )
    {
        lRes = RegOpenKeyExW( hkeyEss,
                              wszNamespace,
                              0,
                              KEY_ALL_ACCESS,
                              &hkeyNamespace );
        
        if ( lRes == ERROR_SUCCESS )
        {
            lRes = RegDeleteSubKeysW( hkeyNamespace );
            RegCloseKey( hkeyNamespace );
        }

        if ( lRes == ERROR_SUCCESS )
        {
            lRes = RegDeleteKeyW( hkeyEss, wszNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    if ( lRes != ERROR_SUCCESS )
    {
        ERRORTRACE((LOG_ESS,"Error removing active namespace key %S from "
                    "registry. Res=%d\n", wszNamespace, lRes ));
    }

    return HRESULT_FROM_WIN32(lRes);
}

HRESULT CEss::SaveActiveNamespaceList()
{
    CWStringArray wsNamespaces;

    //
    // Iterate through the namespaces
    //

    DWORD dwTotalLen = 0;
    {
        CInCritSec ics(&m_cs);

        for(TNamespaceIterator it = m_mapNamespaces.begin();
            it != m_mapNamespaces.end(); it++)
        {
            if(it->second->IsNeededOnStartup())
            {
                LPCWSTR wszName = it->second->GetName();
                if(wsNamespaces.Add(wszName) < 0)
                    return WBEM_E_OUT_OF_MEMORY;
                dwTotalLen += wcslen(wszName) + 1;
            }
        }
    }

    dwTotalLen += 1;

    //
    // Allocate a buffer for all of these strings and copy them all in, 
    // separated by NULLs.
    //

    WCHAR* awcBuffer = new WCHAR[dwTotalLen];
    if(awcBuffer == NULL)
    return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(awcBuffer);

    WCHAR* pwcCurrent = awcBuffer;

    for(int i = 0; i < wsNamespaces.Size(); i++)
    {
        LPCWSTR wszName = wsNamespaces[i];
        StringCchCopyW( pwcCurrent, 
                        dwTotalLen - (pwcCurrent-awcBuffer), 
                        wszName ); 
        pwcCurrent += wcslen(wszName)+1;
    }
    *pwcCurrent = NULL;

    //
    // Store this string in the registry
    //

    Registry r(WBEM_REG_WINMGMT);
    int nRes = r.SetBinary(WBEM_REG_ESS_ACTIVE_NAMESPACES, (byte*)awcBuffer, 
                           dwTotalLen * sizeof(WCHAR));
    if(nRes != Registry::no_error)
        return WBEM_E_FAILED;
    
    //
    // Return S_FALSE if no namespaces are active
    //

    if(wsNamespaces.Size() > 0)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CEss::Initialize( LPCWSTR wszServerName, 
                          long lFlags,
                          _IWmiCoreServices* pCoreServices,
                          IWbemDecorator* pDecorator )
{
    HRESULT hres;

    try
    {
    
    m_EventLog.Open();
    
    hres = CoCreateInstance(CLSID_WbemTokenCache, NULL, CLSCTX_INPROC_SERVER, 
                IID_IWbemTokenCache, (void**)&m_pTokenCache);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Cannot create a token cache: 0x%x\n", hres));
        return hres;
    }

    m_wszServerName = _new WCHAR[wcslen(wszServerName)+1];
    if(m_wszServerName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW( m_wszServerName, wcslen(wszServerName)+1, wszServerName );

    m_pCoreServices = pCoreServices;
    m_pCoreServices->AddRef();

    //
    // Get provider subsystem and register our callback with it.
    //

    hres = m_pCoreServices->GetProviderSubsystem(0, &m_pProvSS);
    
    if( SUCCEEDED(hres) )
    {
        m_pProvSSSink = new CEssProvSSSink( this );

        if ( m_pProvSSSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        m_pProvSSSink->AddRef();

        hres = m_pProvSS->RegisterNotificationSink( 0, NULL, m_pProvSSSink ); 

        if ( FAILED(hres) )
        {
            ERRORTRACE((LOG_ESS, "Failed to register notification sink "
                        "with provider subsystem: 0x%X\n",hres));
        }
    }
    else
    {
        ERRORTRACE((LOG_ESS, "No provider subsystem: 0x%X\n", hres));
    }

    // Store the "decorator"
    // =====================

    m_pDecorator = pDecorator;
    m_pDecorator->AddRef();

    CInObjectCount ioc(this);

    // Connect to the default namespace
    // ================================

    IWbemServices* pRoot;
    hres = m_pCoreServices->GetServices(L"root", NULL,NULL,
                        WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_ESS, 
                        IID_IWbemServices, (void**)&pRoot);
    if(FAILED(hres)) return hres;
    CReleaseMe rm1(pRoot);

    // Pre-load event classes
    // ======================

    hres = CEventRepresentation::Initialize(pRoot, pDecorator);
    if(FAILED(hres)) return hres;

    // Initialize aggregator
    // =====================

    CEventAggregator::Initialize(pRoot);

    // Initialize timer instructions
    // =============================

    CConsumerProviderWatchInstruction::staticInitialize(pRoot);
    CEventProviderWatchInstruction::staticInitialize(pRoot);
    CConsumerWatchInstruction::staticInitialize(pRoot);


    // 
    // construct an event announcing to the world that ESS is open for business
    //

    //
    // Construct a security descriptor
    //

    CNtSecurityDescriptor SD;

    SID_IDENTIFIER_AUTHORITY idNtAuthority = SECURITY_NT_AUTHORITY;
    PSID pRawSid = NULL;

    if(!AllocateAndInitializeSid(&idNtAuthority, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CNtSid SidAdmins(pRawSid);
    FreeSid(pRawSid);
    pRawSid = NULL;

    SID_IDENTIFIER_AUTHORITY idWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    if(!AllocateAndInitializeSid( &idWorldAuthority, 1,
        SECURITY_WORLD_RID, 
        0, 0,0,0,0,0,0,&pRawSid))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CNtSid SidEveryone(pRawSid);
    FreeSid(pRawSid);

    CNtAce AceAdmins(EVENT_ALL_ACCESS, ACCESS_ALLOWED_ACE_TYPE, 0, SidAdmins);
    CNtAce AceOthers(SYNCHRONIZE, ACCESS_ALLOWED_ACE_TYPE, 0, SidEveryone);

    CNtAcl Acl;
    if(!Acl.AddAce(&AceAdmins))
        return WBEM_E_OUT_OF_MEMORY;

    if(!Acl.AddAce(&AceOthers))
        return WBEM_E_OUT_OF_MEMORY;

    if(!SD.SetDacl(&Acl))
        return WBEM_E_OUT_OF_MEMORY;
        
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof sa;
    sa.lpSecurityDescriptor = SD.GetPtr();
    sa.bInheritHandle = FALSE;
    
    m_hReadyEvent = CreateEventW( &sa, 
                                  TRUE, 
                                  FALSE, 
                                  WBEM_ESS_OPEN_FOR_BUSINESS_EVENT_NAME );

    if( m_hReadyEvent == NULL )
    {
        ERRORTRACE((LOG_ESS, "Unable to create 'ready' event: 0x%X\n", 
                    GetLastError()));
        return WBEM_E_CRITICAL_ERROR;
    }

    // Pre-load default namespace
    // ==========================

    LoadActiveNamespaces(pRoot, lFlags == WMIESS_INIT_REPOSITORY_RECOVERED );
    CTemporaryHeap::Compact();
    
#ifdef __DUMP_STATISTICS
#pragma message("Statistics dump in effect")
    DWORD dw;
    CloseHandle(CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DumpThread,
        this, 0, &dw));
#endif

    //
    // Initialize the quotas.
    //

    g_quotas.Init(this);

    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}
    
void CEss::NotifyActiveNamespaceInitComplete()
{
    _DBG_ASSERT( m_lOutstandingActiveNamespaceInit > 0 );

    if ( InterlockedDecrement( &m_lOutstandingActiveNamespaceInit ) == 0 )
    {
        if ( SetEvent( m_hReadyEvent ) )
        {
            DEBUGTRACE((LOG_ESS,"ESS is now open for business.\n"));
        }
        else
        {
            ERRORTRACE((LOG_ESS,"ESS could not set ready event. res=%d\n",
                        GetLastError() ));
        }
    }
}
            
HRESULT CEss::CreateNamespaceObject( LPCWSTR wszNormName,
                                     CEssNamespace** ppNamespace )
{
    HRESULT hr;
    *ppNamespace = NULL;

    CWbemPtr<CEssNamespace> pNamespace = NULL;

    try
    {
        pNamespace = new CEssNamespace(this);
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if( pNamespace == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pNamespace->PreInitialize( wszNormName );

    if ( FAILED(hr) )
    {
        return hr;
    }

    try
    {
        m_mapNamespaces[wszNormName] = pNamespace;   
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pNamespace->AddRef(); // for the map

    pNamespace->AddRef();
    *ppNamespace = pNamespace;

    return WBEM_S_NO_ERROR;
}


HRESULT CEss::GetNamespaceObject( LPCWSTR wszName, 
                                  BOOL bEnsureActivation,
                                  CEssNamespace** ppNamespace)
{
    HRESULT hres;
    *ppNamespace = NULL;
 
    CWbemPtr<CEssNamespace> pNamespace;

    //
    // need to normalize namespace name
    // 

    LPWSTR wszNormName = NormalizeNamespaceString( wszName );

    if ( wszNormName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> dmwszNormName( wszNormName );

    {
        CInCritSec ics(&m_cs);    

        //
        // Search the map
        //
        TNamespaceIterator it;
        try
        {
            it = m_mapNamespaces.find(wszNormName);
        } 
        catch (CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        };
        
        if(it != m_mapNamespaces.end())
        {
            // Found it
            // ========
            
            pNamespace = it->second;    
        }
        else
        {
            // Not found --- create a new one
            // ==============================
            
            hres = CreateNamespaceObject( wszNormName, &pNamespace );
            
            if ( FAILED(hres) )
            {
                return hres;
            }
        }
    }

    //
    // ensure that initialization is pending if necessary
    // 

    if ( bEnsureActivation && pNamespace->MarkAsInitPendingIfQuiet() )
    {
        //
        // kick off initialization for this namespace on another thread.
        // 

        CNamespaceInitRequest* pReq;
        pReq = new CNamespaceInitRequest( pNamespace, FALSE );

        if ( pReq == NULL )
        {
            pNamespace->MarkAsInitialized( WBEM_E_OUT_OF_MEMORY );
            return WBEM_E_OUT_OF_MEMORY;
        }

        hres = ScheduleNamespaceInitialize( pReq );

        if ( FAILED(hres) )
        {
            delete pReq;
            pNamespace->MarkAsInitialized( WBEM_E_OUT_OF_MEMORY );
            return hres;
        }
    }

    pNamespace->AddRef();
    *ppNamespace = pNamespace;

    return WBEM_S_NO_ERROR;
}

//
// Creates a namespace object for the specified namespace and adds it 
// to the request object.
// 
HRESULT CEss::PrepareNamespaceInitRequest( LPCWSTR wszNamespace, 
                                    CInitActiveNamespacesRequest* pRequest )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DEBUGTRACE((LOG_ESS,
                "Preparing a namespace init request for active namespace %S\n",
                wszNamespace ));

    CWbemPtr<CEssNamespace> pNamespace;

    LPWSTR wszNormName = NormalizeNamespaceString( wszNamespace );

    if ( wszNormName != NULL )
    {
        hr = CreateNamespaceObject( wszNormName, &pNamespace );

        if ( SUCCEEDED(hr) )
        {
            hr = pRequest->Add( pNamespace );

            //
            // make sure to tell the namespace that init is pending. 
            //

            BOOL bIsPending = pNamespace->MarkAsInitPendingIfQuiet();

            _DBG_ASSERT( bIsPending );
        }

        delete [] wszNormName;
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred when preparing active "
                    "namespace %S for initialization \n", hr, wszNamespace ));
    }

    return hr;
}

//
// This method prepares a request object that will initialize the specified 
// namespace and all descendent namespaces as if they were all active dependant
// namespaces.  This is useful when the Active namespace information could not 
// be obtained from the last shutdown. 
//
HRESULT CEss::RecursivePrepareNamespaceInitRequests(
                                       LPCWSTR wszNamespace,
                                       IWbemServices* pSvc, 
                                       CInitActiveNamespacesRequest* pRequest )
{
    HRESULT hr;

    hr = PrepareNamespaceInitRequest( wszNamespace, pRequest );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Enumerate all child namespaces and make recursive call for each
    //

    CWbemPtr<IEnumWbemClassObject> penumChildren;

    hr = pSvc->CreateInstanceEnum( CWbemBSTR( L"__NAMESPACE" ), 
                                   0, 
                                   GetCurrentEssContext(), 
                                   &penumChildren ); 
    if( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred enumerating child "
            "namespaces of namespace %S. Some child namespaces may not be "
            "active\n", hr, wszNamespace ));

        //
        // don't treat this as error, since this namespace was created and 
        // added to the request.  Just no more work to do here. 
        //

        return WBEM_S_NO_ERROR;
    }

    DWORD dwRead;
    IWbemClassObject* pChildObj;

    while((hr=penumChildren->Next(INFINITE, 1, &pChildObj, &dwRead)) == S_OK)
    {
        VARIANT vName;
        VariantInit(&vName);
        CClearMe cm1(&vName);
        
        hr = pChildObj->Get( L"Name", 0, &vName, NULL, NULL );
        pChildObj->Release();
        
        if( FAILED(hr) )
        {
            return hr;
        }
        
        if ( V_VT(&vName) != VT_BSTR )
        {
            return WBEM_E_CRITICAL_ERROR;
        }

        //
        // form the full name of the namespace
        // 
        
        WString wsFullName;

        try
        {
            wsFullName = wszNamespace;
            wsFullName += L"\\";
            wsFullName += V_BSTR(&vName);
        }
        catch( CX_MemoryException )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // get the svc ptr for the namespace. Must be repository only. 
        //

        CWbemPtr<IWbemServices> pChildSvc;
        long lFlags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_ESS;

        hr = m_pCoreServices->GetServices( wsFullName,NULL,NULL,
                                           lFlags,
                                           IID_IWbemServices, 
                                           (void**)&pChildSvc );
        if ( SUCCEEDED(hr) )
        {
            //
            // make the recursive call.
            // 
            
            RecursivePrepareNamespaceInitRequests( wsFullName, 
                                                   pChildSvc, 
                                                   pRequest );
        }
        else
        {
            ERRORTRACE((LOG_ESS, 
                        "Failed to open child namespace %S in %S: 0x%x\n",
                        V_BSTR(&vName), wszNamespace, hr));
        }
    }

    return WBEM_S_NO_ERROR;
}

//
// This method prepares namespace init requests for active namespaces.  It 
// uses persisted information to determine the active namespaces.  Each 
// ActiveNamespaceInit request may contain multiple namespaces.  This allows 
// dependent namespaces to be initialized together.  For now, all active 
// namespaces are treated as inter-dependent - so only one request will be 
// added to the list.  If there is no persisted information about active 
// namespaces, then all existing namespaces are treated as active dependent 
// ones.
//
HRESULT CEss::PrepareNamespaceInitRequests( IWbemServices* pRoot,
                                            BOOL bRediscover,
                                            InitActiveNsRequestList& aRequests)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInitActiveNamespacesRequest* pReq;
    
    pReq = new CInitActiveNamespacesRequest(this);
    
    if ( pReq == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Get the list of active namespaces from the registry
    // 
    
    LONG lRes;
    DWORD dwDisp;
    HKEY hkeyEss, hkeyNamespace;

    lRes = RegCreateKeyExW( HKEY_LOCAL_MACHINE, 
                            WBEM_REG_ESS,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkeyEss,
                            &dwDisp );

    if ( lRes == ERROR_SUCCESS )
    {
        if ( !bRediscover )
        {
            FILETIME ft;
            DWORD dwIndex = 0;
            DWORD dwBuffSize = 256;
            LPWSTR wszName = new WCHAR[dwBuffSize];
            DWORD cName = dwBuffSize;

            if ( wszName == NULL )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            while( SUCCEEDED(hr) && (lRes=RegEnumKeyExW( hkeyEss, dwIndex, 
                                                         wszName, &cName, NULL,
                                                         NULL, NULL, &ft ) )
                  != ERROR_NO_MORE_ITEMS )
            {
                if ( lRes == ERROR_SUCCESS )
                {
                    hr = PrepareNamespaceInitRequest( wszName, pReq );
                    dwIndex++;                
                }
                else if ( lRes == ERROR_MORE_DATA )
                {
                    dwBuffSize += 256;
                    delete [] wszName;
                    wszName = new WCHAR[dwBuffSize];
                    
                    if ( wszName == NULL )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( lRes ); 
                }

                cName = dwBuffSize;
            }

            delete [] wszName;
    
            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"Failed enumerating active namespaces. "
                          "Treating all namespaces as active. HR=0x%x\n", hr));

                //
                // reset our registry data.  We'll rediscover it again. 
                //
                RegDeleteSubKeysW( hkeyEss );

                //
                // Also need to reset request object to clear any requests 
                // that were added on this enumeration.
                // 
                pReq->Reset();
            }
        }
        else
        {
            //
            // reset our registry data.  We'll rediscover it again.
            //
            RegDeleteSubKeysW( hkeyEss );

            hr = WBEM_S_FALSE;
        }

        RegCloseKey( hkeyEss );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( lRes ); 
    }

    //
    // If there was any problem or we just created the key for the 
    // first time or we are simply told to rediscover, then we have to recurse 
    // namespaces and discover.
    // 

    if ( hr != WBEM_S_NO_ERROR || dwDisp != REG_OPENED_EXISTING_KEY )
    {
        DEBUGTRACE((LOG_ESS,"ESS Treating all namespaces as active during "
                    "Initialize\n"));

        //
        // recurse namespaces from root
        //

        RecursivePrepareNamespaceInitRequests( L"root", pRoot, pReq );
    }

    if ( aRequests.Add( pReq ) < 0 )
    {
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

//
// This method schedules all active namespaces for initialization.
//
HRESULT CEss::LoadActiveNamespaces( IWbemServices* pRoot, BOOL bRediscover )
{
    HRESULT hr;

    InitActiveNsRequestList aRequests;

    hr = PrepareNamespaceInitRequests( pRoot, bRediscover, aRequests );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // hold an active namespace init count while we schedule requests.
    // this will keep ess from transitioning to ready until it has 
    // scheduled all requests.
    //

    m_lOutstandingActiveNamespaceInit = 1;

    for( int i=0; i < aRequests.GetSize(); i++ )
    {
        int cNamespaces = aRequests[i]->GetNumNamespaces();

        if ( cNamespaces > 0 )
        {
            InterlockedExchangeAdd( &m_lOutstandingActiveNamespaceInit, 
                                    cNamespaces ); 
        }

        hr = ScheduleNamespaceInitialize( aRequests[i] );

        if ( FAILED(hr) )
        {
            InterlockedExchangeAdd( &m_lOutstandingActiveNamespaceInit,
                                    0-cNamespaces );
            delete aRequests[i];
        }
    }

    NotifyActiveNamespaceInitComplete();

	if (bRediscover)
	{
	    CPersistentConfig cfg;
	    cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_TO_BE_INITIALIZED,0);
	}

    return WBEM_S_NO_ERROR;
}

//
// This method schedules a namespace init request.  It handles deferring 
// initialization if the machine is currently booting.  If the request 
// is known to only initialize inactive namespaces, then we do not defer
// initialization even in the boot phase.  This is so we don't cause events 
// in inactive namespaces to be queued up while we're waiting for the deferred
// initialization to complete.  
//
HRESULT CEss::ScheduleNamespaceInitialize( CExecRequest* pRequest )
{
    DWORD dwTickCount = GetTickCount();

    if ( dwTickCount >= BOOT_PHASE_MS )
    {
        HRESULT hres = Enqueue(pRequest);
    
        if( FAILED(hres) )
        {
            return hres;
        }

        return WBEM_S_NO_ERROR;
    }

    if ( m_hExitBootPhaseTimer == NULL )
    {
        //
        // cause a timer to be fired that will activate the thread queue
        // after we're out of the boot phase.
        //
        
        if ( !CreateTimerQueueTimer( &m_hExitBootPhaseTimer,
                                    NULL,
                                    ExitBootPhaseCallback,
                                    this,
                                    BOOT_PHASE_MS-dwTickCount,
                                    0,
                                    WT_EXECUTEINTIMERTHREAD ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if ( m_aDeferredNSInitRequests.Add( pRequest ) < 0 )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_FALSE;
}

void CALLBACK CEss::ExitBootPhaseCallback( LPVOID pvThis, BOOLEAN )
{
    DEBUGTRACE((LOG_ESS, "Exiting Boot Phase.\n" ));
    ((CEss*)pvThis)->ExecuteDeferredNSInitRequests();
}

void CEss::ExecuteDeferredNSInitRequests()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );

    for( int i=0; i < m_aDeferredNSInitRequests.GetSize(); i++ )
    {
        hr = Enqueue( m_aDeferredNSInitRequests[i] );
        
        if ( FAILED(hr) )
        {
            ERRORTRACE((LOG_ESS, "Critical Error. Could not enqueue "
                        "deferred namespace init requests\n"));
            delete m_aDeferredNSInitRequests[i];
        }
    }

    m_aDeferredNSInitRequests.RemoveAll();
}

void CEss::TriggerDeferredInitialization()
{
    if ( GetTickCount() >= BOOT_PHASE_MS )
    {
        //
        // avoid calling execute() if possible since it grabs an ess wide cs.
        // 
        return;
    }

    DEBUGTRACE((LOG_ESS, "Triggering ESS Namespace Requests "
                         "during Boot phase\n" ));

    ExecuteDeferredNSInitRequests();
}
    
HRESULT CEss::GetNamespacePointer( LPCWSTR wszNamespace,
                                   BOOL bRepositoryOnly,
                                   RELEASE_ME IWbemServices** ppNamespace )
{
    HRESULT hres;

    if( m_pLocator == NULL )
    {
        if( m_pCoreServices != NULL )
        {
            long lFlags = WMICORE_CLIENT_TYPE_ESS;
            
            if ( bRepositoryOnly ) 
            {
                lFlags |= WMICORE_FLAG_REPOSITORY;
            }
            
            hres = m_pCoreServices->GetServices( wszNamespace, NULL,NULL,
                                                 lFlags, 
                                                 IID_IWbemServices, 
                                                 (void**)ppNamespace );
        }
        else
        {
            hres = WBEM_E_CRITICAL_ERROR;
        }
    }
    else
    {   
        BSTR strNamespace = SysAllocString(wszNamespace);

        if ( NULL == strNamespace )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hres = m_pLocator->ConnectServer( strNamespace, NULL, NULL, 0, 0, NULL,
                                          NULL, ppNamespace);
        SysFreeString(strNamespace);

        if ( SUCCEEDED(hres) )
        {
            hres = WBEM_S_FALSE;
        }
    }

    return hres;
}

HRESULT CEss::ReloadProvider( long lFlags, 
                              LPCWSTR wszNamespace, 
                              LPCWSTR wszProvider )
{
    HRESULT hr;

    try
    {
        CInObjectCount ioc(this);

        CWbemPtr<CEssNamespace> pNamespace;
        hr = GetNamespaceObject( wszNamespace, FALSE, &pNamespace);
        
        if ( SUCCEEDED(hr) )
        {
            DEBUGTRACE((LOG_ESS,"Reloading Provider %S in namespace %S at "
                        "request of external subsystem\n ",
                        wszProvider, wszNamespace ));

            hr = pNamespace->ReloadProvider( lFlags, wszProvider );
        }
    }
    catch( CX_MemoryException )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
        
    return hr;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEss::ProcessEvent(READ_ONLY CEventRepresentation& Event, long lFlags)
{
    HRESULT hres;
 
    try
    {
        CInObjectCount ioc(this);

        // Find the right namespace object
        // ===============================

        CEssNamespace* pNamespace = NULL;
        hres = GetNamespaceObject(Event.wsz1, FALSE, &pNamespace);
        if(FAILED(hres))
            return hres;
        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        // Get it to process the event
        // ===========================
        
        return pNamespace->ProcessEvent(Event, lFlags);
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}


HRESULT CEss::ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event )
{
    HRESULT hres;
 
    try
    {
        CInObjectCount ioc(this);

        //
        // Find the right namespace object
        // 

        CEssNamespace* pNamespace = NULL;

        hres = GetNamespaceObject(Event.wsz1, FALSE, &pNamespace);

        if( FAILED( hres ) )
        {
            return hres;
        }

        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        //
        // Get it to process the event
        // 
        
        return pNamespace->ProcessQueryObjectSinkEvent( Event );
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}


HRESULT CEss::VerifyInternalEvent(READ_ONLY CEventRepresentation& Event)
{
    HRESULT hres;

    try
    {
        CInObjectCount ioc(this);

        // Find the right namespace object
        // ===============================

        CEssNamespace* pNamespace = NULL;
        hres = GetNamespaceObject(Event.wsz1, FALSE, &pNamespace);
        if(FAILED(hres))
            return hres;
        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        // Get it to process the event
        // ===========================
        
        return pNamespace->ValidateSystemEvent(Event);
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CEss::RegisterNotificationSink( WBEM_CWSTR wszNamespace, 
                                        WBEM_CWSTR wszQueryLanguage, 
                                        WBEM_CWSTR wszQuery, 
                                        long lFlags, 
                                        IWbemContext* pContext, 
                                        IWbemObjectSink* pSink )
{
    HRESULT hres;

    try
    {
        if(wbem_wcsicmp(wszQueryLanguage, L"WQL"))
            return WBEM_E_INVALID_QUERY_TYPE;

        CInObjectCount ioc(this);

        // Find the right namespace object
        // ===============================

        CEssNamespace* pNamespace = NULL;
        hres = GetNamespaceObject(wszNamespace, FALSE, &pNamespace);
        if(FAILED(hres))
            return hres;
        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        // Get the object to do it
        // =======================

        HRESULT hr;
        
        hr = pNamespace->RegisterNotificationSink( wszQueryLanguage, 
                                                   wszQuery,
                                                   lFlags, 
                                                   WMIMSG_FLAG_QOS_EXPRESS, 
                                                   pContext, 
                                                   pSink );

        return hr;

    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CEss::RemoveNotificationSink(IWbemObjectSink* pSink)
{
    HRESULT hres;
    try
    {
        CInObjectCount ioc(this);
        
        // Create a list of AddRefed namespace objects that we can use
        // ===========================================================

        CRefedPointerArray<CEssNamespace> apNamespaces;

        {
            CInCritSec ics(&m_cs);

            for(TNamespaceIterator it = m_mapNamespaces.begin();
                it != m_mapNamespaces.end();
                it++)
            {
                if(apNamespaces.Add(it->second) < 0)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        // Get all of them to remove this sink
        // ===================================
        
        HRESULT hresGlobal = WBEM_E_NOT_FOUND;
        
        for(int i = 0; i < apNamespaces.GetSize(); i++)
        {
            hres = apNamespaces[i]->RemoveNotificationSink(pSink);
            if(FAILED(hres))
            {
                if(hres != WBEM_E_NOT_FOUND)
                {
                    // Actual error --- take note
                    // ==========================
                    
                    hresGlobal = hres;
                }
            }
            else
            {
                // Found some
                // ==========
                
                if(hresGlobal == WBEM_E_NOT_FOUND)
                    hresGlobal = WBEM_S_NO_ERROR;
            }
        }
        
        return hresGlobal;
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CEss::PurgeNamespace(LPCWSTR wszNamespace)
{
    LPWSTR wszNormName = NormalizeNamespaceString( wszNamespace );

    if ( wszNormName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> dmwszNormName( wszNormName );
 
    CEssNamespace* pNamespace = NULL;
    {
        CInCritSec ics(&m_cs);

        // Purge it from the timer generator
        // =================================

        m_TimerGenerator.Remove(wszNormName);

        // Find it in the map
        // ==================

        TNamespaceIterator it;
        try
        {
            it = m_mapNamespaces.find(wszNormName);
        } 
        catch (CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        };
        
        if(it == m_mapNamespaces.end())
            return WBEM_S_FALSE;

        // Keep it for later
        // =================

        pNamespace = it->second;

        // Remove it from the map
        // ======================

        m_mapNamespaces.erase(it);
    }

    // Wait for initialization to complete
    // ===================================

    pNamespace->Shutdown();
    pNamespace->Release();    
    return WBEM_S_NO_ERROR;
}

HRESULT CEss::DecorateObject(IWbemClassObject* pObj, LPCWSTR wszNamespace)
{
    return CEventRepresentation::mstatic_pDecorator->DecorateObject(pObj, 
                                                      (LPWSTR)wszNamespace);
}

HRESULT CEss::AddSleepCharge(DWORD dwSleep)
{
    if(dwSleep)
        Sleep(dwSleep);
    return S_OK;
}

HRESULT CEss::AddCache()
{
    return m_LimitControl.AddMember();
}

HRESULT CEss::RemoveCache()
{
    return m_LimitControl.RemoveMember();
}

HRESULT CEss::AddToCache(DWORD dwAdd, DWORD dwMemberTotal, DWORD* pdwSleep)
{
    DWORD dwSleep;
    HRESULT hres = m_LimitControl.Add(dwAdd, dwMemberTotal, &dwSleep);

    if(SUCCEEDED(hres))
    {
        if(pdwSleep)
            *pdwSleep = dwSleep;
        else
            AddSleepCharge(dwSleep);
    }
    return hres;
}

HRESULT CEss::RemoveFromCache(DWORD dwRemove)
{
    return m_LimitControl.Remove(dwRemove);
}


void CEss::IncrementObjectCount()
{
    InterlockedIncrement(&m_lObjectCount);
}

void CEss::DecrementObjectCount()
{
    if(InterlockedDecrement(&m_lObjectCount) == 0)
    {
        // No need to purge the cache --- David knows I am ready to unload
    }
}

HRESULT CEss::InitializeTimerGenerator(LPCWSTR wszNamespace, 
                    IWbemServices* pNamespace)
{
    return GetTimerGenerator().LoadTimerEventQueue(wszNamespace, pNamespace);
}

HRESULT CEss::EnqueueDeliver(CQueueingEventSink* pDest)
{
    return m_Queue.EnqueueDeliver(pDest);
}

HRESULT CEss::Enqueue(CExecRequest* pReq)
{
    return m_Queue.Enqueue(pReq);
}

HRESULT CEss::GetToken(PSID pSid, IWbemToken** ppToken)
{
    return m_pTokenCache->GetToken((BYTE*)pSid, ppToken);
}

void CEss::DumpStatistics(FILE* f, long lFlags)
{
    CInCritSec ics(&m_cs);

    time_t t;
    time(&t);
    struct tm* ptm = localtime(&t);
    fprintf(f, "Statistics at %s", asctime(ptm));
    time(&t);
    ptm = localtime(&t);
    fprintf(f, "Commence at %s", asctime(ptm));

    for(TNamespaceIterator it = m_mapNamespaces.begin();
            it != m_mapNamespaces.end(); it++)
    {
        it->second->DumpStatistics(f, lFlags);
    }

    time(&t);
    ptm = localtime(&t);
    fprintf(f, "Done at %s\n", asctime(ptm));
}

HRESULT CEss::GetProviderFactory( LPCWSTR wszNamespaceName,
                                  IWbemServices* pNamespace,
                                  RELEASE_ME _IWmiProviderFactory** ppFactory )
{
    HRESULT hres;

    *ppFactory = NULL;

    if ( m_pProvSS == NULL )
    {
        ERRORTRACE((LOG_ESS, "Trying to get Provider Factory, but "
                    "No provider subsystem!!\n"));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Get IWbemServicesEx, just for Steve
    //

    IWbemServices* pEx;
    hres = pNamespace->QueryInterface(IID_IWbemServices, (void**)&pEx);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "No Ex interface: 0x%X\n", hres));
        return hres;
    }
    CReleaseMe rm1(pEx);
        
    //
    // Get Provider factory
    //

    hres = m_pProvSS->Create( pEx, 
                              0, 
                              GetCurrentEssContext(), 
                              wszNamespaceName,
                              IID__IWmiProviderFactory, 
                              (void**)ppFactory );
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "No provider factory: 0x%X\n", hres));
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\essmain.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESSMAIN.CPP
//
//  Defines COM DLL entry points and CFactory implementation.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include <wbemidl.h>
#include <wbemcomn.h>
#include "esssink.h"
#include <commain.h>
#include <clsfac.h>


class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemEventSubsystem, 
                        _new CClassFactory<CEssObjectSink>(GetLifeControl()), 
                        __TEXT("Event Subsystem"),
                        TRUE);
        AddClassInfo(CLSID_WmiESS, 
                        _new CClassFactory<CEssObjectSink>(GetLifeControl()), 
                        __TEXT("New Event Subsystem"),
                        TRUE);

        return S_OK;
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\esssink.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESSSINK.CPP
//
//  This files implements the class that implements IWbemObjectSink for the ESS.
//
//  See esssink.h for documentation.
//
//  History:
//
//  11/27/96    a-levn      Compiles
//
//=============================================================================

#include "precomp.h"
#include <wincrypt.h>
#include <stdio.h>
#include "ess.h"
#include "esssink.h"

#define IN_ESS_OPERATION \
    CInEssSharedLock isl( &m_pObject->m_Lock, FALSE ); \
    if ( m_pObject->m_pEss == NULL ) \
        return WBEM_E_INVALID_OPERATION; \
    if ( m_pObject->m_bShutdown ) \
        return WBEM_E_SHUTTING_DOWN;

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
CEssObjectSink::CEssObjectSink(CLifeControl* pControl, IUnknown* pOuter)
 : CUnk(pControl, pOuter), m_XESS(this), m_XNewESS(this), m_XShutdown(this),
   m_XHook(this), m_bShutdown(FALSE), m_pEss(NULL), m_pCoreServices(NULL),
   m_pIFactory(NULL)
{
    ZeroMemory( m_achSecretBytes, SECRET_SIZE );
}

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
CEssObjectSink::~CEssObjectSink()
{
    if( m_pCoreServices )
    {
        m_pCoreServices->Release();
    }

    if ( m_pIFactory )
    {
        m_pIFactory->Release();
    }
}

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
void* CEssObjectSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventSubsystem_m4)
        return &m_XESS;
    else if(riid == IID_IWbemShutdown)
        return &m_XShutdown;
    else if(riid == IID__IWmiESS)
        return &m_XNewESS;
    else if(riid == IID__IWmiCoreWriteHook)
        return &m_XHook;
    
    return NULL;
}

HRESULT CEssObjectSink::SetSecret( IWbemContext* pCtx )
{
    VARIANT vSecret;
    VariantInit( &vSecret );
    CClearMe cm( &vSecret );

    V_ARRAY(&vSecret) = SafeArrayCreateVector( VT_UI1, 0, SECRET_SIZE );
    if ( V_ARRAY(&vSecret) == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    V_VT(&vSecret) = VT_ARRAY | VT_UI1;

    PBYTE pData;
    HRESULT hr = SafeArrayAccessData( V_ARRAY(&vSecret), (void**)&pData );
    if ( FAILED(hr) )
        return WBEM_E_OUT_OF_MEMORY;
    CUnaccessMe um( V_ARRAY(&vSecret) );

    memcpy( pData, m_achSecretBytes, SECRET_SIZE );

    return pCtx->SetValue( L"__SecretEssBytes", 0, &vSecret );
}

HRESULT CEssObjectSink::VerifySecret( IWbemContext* pCtx )
{
    VARIANT vSecret;
    VariantInit(&vSecret);
    HRESULT hr = pCtx->GetValue( L"__SecretEssBytes", 0, &vSecret );
    if ( FAILED(hr) )
        return hr;
    CClearMe cm(&vSecret);

    if ( V_VT(&vSecret) != (VT_ARRAY | VT_UI1) )
        return WBEM_E_ACCESS_DENIED;

    long lUBound;
    hr = SafeArrayGetUBound( V_ARRAY(&vSecret), 1, &lUBound );
    if ( FAILED(hr) )
        return WBEM_E_CRITICAL_ERROR;

    if ( lUBound + 1 < SECRET_SIZE )
        return WBEM_E_ACCESS_DENIED;

    PBYTE pData;
    hr = SafeArrayAccessData( V_ARRAY(&vSecret), (void**)&pData );
    if ( FAILED(hr) )
        return WBEM_E_OUT_OF_MEMORY;
    CUnaccessMe um( V_ARRAY(&vSecret) );

    if ( memcmp( pData, m_achSecretBytes, SECRET_SIZE ) != 0 )
        return WBEM_E_ACCESS_DENIED;

    return WBEM_S_NO_ERROR;
}

HRESULT CEssObjectSink::PrepareCurrentEssThreadObject( IWbemContext* pContext )
{
    CWbemPtr<IWbemContext>  pNewContext = NULL;
    VARIANT                 vValue;
    HRESULT                 hr;

    if ( pContext )
    {
        hr = pContext->Clone( &pNewContext );
        if ( SUCCEEDED( hr ) )
        {
            hr = pNewContext->GetValue( L"__ReentranceTestProp", 0, &vValue );
            
            if ( WBEM_E_NOT_FOUND == hr )
            {
                V_VT(&vValue) = VT_BOOL;
                V_BOOL(&vValue) = VARIANT_FALSE;
                hr = pNewContext->SetValue( L"__ReentranceTestProp", 
                                            0, 
                                            &vValue );
                if ( SUCCEEDED(hr) )
                {
                    hr = SetSecret( pNewContext );
                }
            }
            else if ( FAILED( hr ) )
            {
                return hr;
            }
            else
            {
                hr = VerifySecret( pNewContext );

                if ( SUCCEEDED(hr) )
                {
                    V_VT(&vValue) = VT_BOOL;
                    V_BOOL(&vValue) = VARIANT_TRUE;
                    
                    hr = pNewContext->SetValue( L"__ReentranceTestProp", 
                                                0, 
                                                &vValue );
                }
            }
        }
    }
    else
    {    
        _DBG_ASSERT( m_pIFactory );

        hr = m_pIFactory->CreateInstance( NULL,
                                          IID_IWbemContext,
                                          ( void** )&pNewContext );
        
        if ( SUCCEEDED( hr ) )
        {
            V_VT(&vValue) = VT_BOOL;
            V_BOOL(&vValue) = VARIANT_FALSE;
            hr = pNewContext->SetValue( L"__ReentranceTestProp", 0, &vValue ); 
        }

        if ( SUCCEEDED(hr) )
        {
            hr = SetSecret( pNewContext );
        }
    }

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    SetCurrentEssThreadObject( pNewContext ); 
    if ( NULL == GetCurrentEssThreadObject( ) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
STDMETHODIMP CEssObjectSink::XESS::ProcessInternalEvent(long lSendType, 
        LPCWSTR str1, LPCWSTR str2, 
        LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
        _IWmiObject** apObjects, IWbemContext* pContext)
{
    IN_ESS_OPERATION

    CEventRepresentation Event;
    Event.type = lSendType;
    Event.dw1 = dw1;
    Event.dw2 = dw2;
    Event.wsz1 = (LPWSTR)str1;
    Event.wsz2 = (LPWSTR)str2;
    Event.wsz3 = (LPWSTR)str3;
    Event.nObjects = (int)dwObjectCount;
    Event.apObjects = (IWbemClassObject**)apObjects;

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    HRESULT hres = m_pObject->PrepareCurrentEssThreadObject(pContext);
    if ( FAILED( hres ) )
    {
        return hres;
    }

    //
    // we must remove the client's security context from the thread because
    // it is really winmgmt raising these events, not the client.
    // 

    IUnknown *pGarb, *pCtx = NULL;

    hres = CoSwitchCallContext( NULL, &pCtx );
    if ( SUCCEEDED( hres ) )
    {
        // Do the actual processing
        // ========================

        hres = m_pObject->m_pEss->ProcessEvent(Event, (long)dw2);

        // Restore the context
        // ===================

        HRESULT hr = CoSwitchCallContext( pCtx, &pGarb );
        if ( SUCCEEDED( hres ) )
        {
            hres = hr;
        }
    }
    
    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }
    
    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::VerifyInternalEvent(long lSendType, 
        LPCWSTR str1, LPCWSTR str2, 
        LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
        _IWmiObject** apObjects, IWbemContext* pContext)
{
    IN_ESS_OPERATION

    CEventRepresentation Event;
    Event.type = lSendType;
    Event.dw1 = dw1;
    Event.dw2 = dw2;
    Event.wsz1 = (LPWSTR)str1;
    Event.wsz2 = (LPWSTR)str2;
    Event.wsz3 = (LPWSTR)str3;
    Event.nObjects = (int)dwObjectCount;
    Event.apObjects = (IWbemClassObject**)apObjects;

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(pContext);

    if ( GetCurrentEssThreadObject() == NULL )
    {
        SetConstructedEssThreadObject(pOldThreadObject);
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Do the actual processing
    // ========================

    HRESULT hres = m_pObject->m_pEss->VerifyInternalEvent(Event);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }
    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::RegisterNotificationSink(
            LPCWSTR wszNamespace, 
            LPCWSTR wszQueryLanguage, LPCWSTR wszQuery, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink)
{
    IN_ESS_OPERATION

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    HRESULT hres = m_pObject->PrepareCurrentEssThreadObject(pContext);
    if ( FAILED( hres ) )
    {
        SetConstructedEssThreadObject( pOldThreadObject );
        return hres;
    }

    // Do the actual processing
    // ========================

    hres = m_pObject->m_pEss->RegisterNotificationSink(wszNamespace, 
        wszQueryLanguage, wszQuery, lFlags, pContext, pSink);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }

    // Return
    // ======

    if(FAILED(hres))
    {
        pSink->SetStatus(0, hres, NULL, NULL);
    }
    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::RemoveNotificationSink(
                                                      IWbemObjectSink* pSink)
{
    IN_ESS_OPERATION

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(NULL);
    if ( GetCurrentEssThreadObject() == NULL )
    {
        SetConstructedEssThreadObject(pOldThreadObject);
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Do the actual processing
    // ========================

    HRESULT hres = m_pObject->m_pEss->RemoveNotificationSink(pSink);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }

    return hres;
}

    
STDMETHODIMP CEssObjectSink::XESS::GetNamespaceSink(LPCWSTR wszNamespace, 
            IWbemObjectSink** ppSink)
{
    IN_ESS_OPERATION

    CEssNamespaceSink* pSink = _new CEssNamespaceSink(m_pObject->m_pEss,
                                                        m_pObject->m_pControl);
    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(wszNamespace);
    if(FAILED(hres))
    {
        delete pSink;
        return hres;
    }

    return pSink->QueryInterface(IID_IWbemObjectSink, (void**)ppSink);
}

STDMETHODIMP CEssObjectSink::XNewESS::Initialize( long lFlags, 
                                                  IWbemContext* pCtx,
                                                  _IWmiCoreServices* pServices)
{
    //
    // This function is not multi-thread safe by design. We do not support 
    // concurrent operations while in this function.  The expectation is that 
    // the user will call this method and THEN introduce the object into
    // an environment where it can be called concurrently. 
    //

    //
    // This object will not support being called after a failed initialization.
    // The user must deallocate the object and then allocate a new one.
    // 

    HRESULT hres;

    hres = CoGetClassObject( CLSID_WbemContext,
                           CLSCTX_INPROC_SERVER,
                           NULL,
                           IID_IClassFactory,
                           ( void** )&m_pObject->m_pIFactory );
    if ( FAILED( hres ) )
    {
        return hres;
    }
    
    if ( m_pObject->m_pEss != NULL )
    {
        return WBEM_S_FALSE;
    }

    if ( m_pObject->m_bShutdown )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    if ( !m_pObject->m_Lock.Initialize() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // set shutdown to true in case we exit prematurely. This will prevent 
    // any future calls to this function after a failed init.
    // 
    m_pObject->m_bShutdown = TRUE;

    //
    // Get current machine name --- core is not giving it to us anymore
    //

    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    if(!GetComputerNameW(wszComputerName, &dwSize))
    {
        ERRORTRACE((LOG_ESS, "Cannot retrieve computer name: %d\n", 
                GetLastError()));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Get the decorator from core services
    //

    CWbemPtr<IWbemDecorator> pDecor;
    hres = pServices->GetDecorator(0, &pDecor);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Cannot retrieve decorator: 0x%X\n", hres));   
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Hook all core write operations
    //

    m_pObject->m_pCoreServices = pServices;
    m_pObject->m_pCoreServices->AddRef();

    hres = m_pObject->m_pCoreServices->RegisterWriteHook(
                                        WBEM_FLAG_INST_PUT|WBEM_FLAG_INST_DELETE|WBEM_FLAG_DISABLE_WHEN_OWNER_UPDATE, 
                                        &m_pObject->m_XHook);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to hook core write operations: 0x%X\n", 
            hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // generate secret value.  See hdr for info on how this is used.
    // 
    HCRYPTPROV hCryptProv;

    if ( CryptAcquireContext( &hCryptProv,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT ) )
    {
        BOOL bRes = CryptGenRandom( hCryptProv,
                                    SECRET_SIZE,
                                    m_pObject->m_achSecretBytes );
        
        CryptReleaseContext( hCryptProv, 0 );
        
        if ( !bRes )
            return HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Initialize for real
    //

    CEss* pEss = NULL;
    try
    {
        pEss = new CEss();
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( pEss == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // create a context object that will be passed around with all work that
    // is done on behalf of ess init.
    //  

    CWbemPtr<IWbemContext> pContext;

    hres = CoCreateInstance( CLSID_WbemContext, 
                             NULL, 
                             CLSCTX_INPROC_SERVER,
                             IID_IWbemContext,
                             (void**)&pContext );
    
    if ( SUCCEEDED(hres) )
    {
        //
        // set the context to be an init context object.
        //

        VARIANT vInit;
        V_VT(&vInit) = VT_BOOL;
        V_BOOL(&vInit) = VARIANT_TRUE;
        hres = pContext->SetValue( L"__EssInInitialize", 0, &vInit ); 
    }

    if ( SUCCEEDED(hres) )
    {
        //
        // attach the init context to the thread
        // 
        
        hres = m_pObject->PrepareCurrentEssThreadObject(pContext);
    }

    if ( FAILED(hres) )
    {  
        delete pEss;
        ERRORTRACE(( LOG_ESS, "Error creating ess context object during init"
                     "HR=0x%x\n", hres ));
        return hres;
    }

    hres = pEss->Initialize( wszComputerName, lFlags, pServices, pDecor );

    //
    // Restore the context
    //

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;
    ClearCurrentEssThreadObject();

    if ( FAILED(hres) )
    {
        delete pEss;
        return hres;
    }

    m_pObject->m_pEss = pEss;
    m_pObject->m_bShutdown = FALSE;

    return hres;
}
    
STDMETHODIMP CEssObjectSink::XNewESS::ExecNotificationQuery(
            LPCWSTR wszNamespace, LPCWSTR wszQueryText, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink)
{ 
    return m_pObject->m_XESS.RegisterNotificationSink(wszNamespace,
                                L"WQL", wszQueryText, lFlags, pContext, pSink);
}
                
STDMETHODIMP CEssObjectSink::XNewESS::CancelAsyncCall(IWbemObjectSink* pSink)
{
    return m_pObject->m_XESS.RemoveNotificationSink(pSink);
}

STDMETHODIMP CEssObjectSink::XNewESS::QueryObjectSink(LPCWSTR wszNamespace, 
    IWbemObjectSink** ppSink)
{
    return m_pObject->m_XESS.GetNamespaceSink(wszNamespace, ppSink);
}
        
STDMETHODIMP CEssObjectSink::XESS::Initialize(LPCWSTR wszServer,
                                                IWbemLocator* pAdminLocator,
                                                IUnknown* pServices)
{
    //
    // Use the _IWmiESS version.
    //
    return WBEM_E_NOT_SUPPORTED;
}


STDMETHODIMP CEssObjectSink::XShutdown::Shutdown( LONG uReason,
                                                  ULONG uMaxMilliseconds,
                                                  IWbemContext* pCtx )
{

    // uMaxMilliseconds == 0 means system shutdown
    if (0 == uMaxMilliseconds)
        return WBEM_S_NO_ERROR;

    {
        //
        // wait for all current operations to complete. Lock will prevent 
        // any new operations from getting through.
        // 

        CInEssSharedLock isl( &m_pObject->m_Lock, TRUE );
       
        if ( m_pObject->m_bShutdown )
        {
            return WBEM_S_FALSE;
        }

        m_pObject->m_bShutdown = TRUE;
    }

    HRESULT hres;

    //
    // Unhook all core write operations
    //


    
	hres = m_pObject->m_pCoreServices->UnregisterWriteHook(
	                                            &m_pObject->m_XHook);
	if(FAILED(hres))
	{
	    ERRORTRACE((LOG_ESS, "Unable to unhook core write operations: 0x%X\n", 
	        hres));
	}

	SetCurrentEssThreadObject(NULL);
    
        if ( GetCurrentEssThreadObject() == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

    hres = m_pObject->m_pEss->Shutdown((0 == uMaxMilliseconds)?TRUE:FALSE);


    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;
    ClearCurrentEssThreadObject();

    if ( m_pObject->m_pEss != NULL )
    {
        delete m_pObject->m_pEss;
        m_pObject->m_pEss = NULL;
    }

    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::Shutdown()
{
    HRESULT hres;

    {
        //
        // wait for all current operations to complete. Lock will prevent 
        // any new operations from getting through.
        // 

        CInEssSharedLock isl( &m_pObject->m_Lock, TRUE );
       
        if ( m_pObject->m_bShutdown )
        {
            return WBEM_S_FALSE;
        }

        m_pObject->m_bShutdown = TRUE;
    }

    SetCurrentEssThreadObject(NULL);
    if ( GetCurrentEssThreadObject() == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = m_pObject->m_pEss->Shutdown(FALSE); // no system shutdown

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;
    ClearCurrentEssThreadObject();

    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::LastCallForCore(LONG bIsSystemShutdown)
{
    IN_ESS_OPERATION

    return m_pObject->m_pEss->LastCallForCore(bIsSystemShutdown);
}

//*********************** NAMESPACE SINK **************************************

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
CEssNamespaceSink::CEssNamespaceSink(CEss* pEss,
                                     CLifeControl* pControl, IUnknown* pOuter) :
            CUnk(pControl, pOuter), m_XSink(this), 
            m_pEss(pEss)
{
}

HRESULT CEssNamespaceSink::Initialize(LPCWSTR wszNamespace)
{
    m_strNamespace = SysAllocString(wszNamespace);
    if(m_strNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
CEssNamespaceSink::~CEssNamespaceSink()
{
    SysFreeString(m_strNamespace);
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
void* CEssNamespaceSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemObjectSink || riid == IID_IUnknown)
    {
        return &m_XSink;
    }
    return NULL;
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
STDMETHODIMP CEssNamespaceSink::XSink::Indicate(long lObjectCount, 
                                      IWbemClassObject** apObjArray)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    for(int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject* pEvent = apObjArray[i];

        if ( pEvent == NULL )
            return WBEM_E_INVALID_PARAMETER;

        CEventRepresentation Event;
        hres = Event.CreateFromObject(pEvent, m_pObject->m_strNamespace);
        
        if ( FAILED(hres) )
            break;

        hres = m_pObject->m_pEss->ProcessQueryObjectSinkEvent( Event );

        if ( FAILED(hres) )
            break;
    }

    return hres;
}


STDMETHODIMP CEssObjectSink::XHook::PrePut(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pCopy)
{
    HRESULT hres;

    IN_ESS_OPERATION

    //
    // Construct the old CEventRepresentation --- simplest route
    //

    CEventRepresentation Event;

    //
    // Determine whether a class or an instance is being put
    //

    if(pCopy->IsObjectInstance() == S_OK)
        Event.type = e_EventTypeInstanceCreation;
    else
        Event.type = e_EventTypeClassCreation;
    Event.dw1 = 0;
    Event.dw2 = 0;
    Event.wsz1 = (LPWSTR)wszNamespace;
    Event.wsz2 = (LPWSTR)wszClass;
    Event.wsz3 = NULL;
    Event.nObjects = 1;
    Event.apObjects = (IWbemClassObject**)&pCopy;

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(pContext);
    if ( GetCurrentEssThreadObject() == NULL )
    {
        SetConstructedEssThreadObject(pOldThreadObject);
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Do the actual processing
    // ========================

    hres = m_pObject->m_pEss->VerifyInternalEvent(Event);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }
    return hres;
}
    
STDMETHODIMP CEssObjectSink::XHook::PostPut(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pNew, 
                            _IWmiObject* pOld)
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CEssObjectSink::XHook::PreDelete(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass)
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CEssObjectSink::XHook::PostDelete(long lFlags, 
                            HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pOld)
{
    return WBEM_S_NO_ERROR;
}

/****************************************************************************
  CEssInternalOperationSink
*****************************************************************************/

STDMETHODIMP CEssInternalOperationSink::Indicate( long cObjs, 
                                                  IWbemClassObject** ppObjs )
{
    HRESULT hr;

    //
    // if the calling thread already has a thread object, leave it.
    // 

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    if ( pOldThreadObject == NULL )
    {
        //
        // set up a new thread object.
        // 

        SetCurrentEssThreadObject(NULL);

        if ( GetCurrentEssThreadObject() == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    hr = m_pSink->Indicate( cObjs, ppObjs );

    //
    // delete the thread object if necessary 
    // 

    if ( pOldThreadObject == NULL )
    {
        delete GetCurrentEssThreadObject();
        ClearCurrentEssThreadObject();
    }

    return hr;
}

STDMETHODIMP CEssInternalOperationSink::SetStatus( long lFlags, 
                                                   HRESULT hres, 
                                                   BSTR bstr, 
                                                   IWbemClassObject* pObj )
{
    //
    // simply delegate ( for now )
    // 
    return m_pSink->SetStatus( lFlags, hres, bstr, pObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\esssink.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESSSINK.H
//
//  This files defines the class that implements IWbemObjectSink for the ESS.
//
//  Classes defined:
//
//      CEssObjectSink
//
//  History:
//
//  11/27/96    a-levn      Compiles
//
//=============================================================================

#ifndef __ESSSINK__H_
#define __ESSSINK__H_

#include <wbemidl.h>
#include <wbemint.h>
#include <unk.h>
#include <comutl.h>
#include "parmdefs.h"
#include "essutils.h"

//*****************************************************************************
//
//  class CEssObjectSink
//
//  This class implements IWbemObjectSink interface for ESS, including the 
//  automation part. A pointer to this object is given to WinMgmt at startup
//  and it serves as the only communication port into the ESS.
//
//*****************************************************************************

class CEss;
class CEssObjectSink : public CUnk
{
private:
    CEss* m_pEss;
    BOOL m_bShutdown;
    CEssSharedLock m_Lock;
    _IWmiCoreServices* m_pCoreServices;
    IClassFactory *m_pIFactory;

    //
    // Since we rely on wbem context to contain information about reentrant 
    // calls, we need to ensure that an external client cannot fool us.  
    // Since reentrant calls can only be made on behalf of an event provider 
    // and since event providers are local and trusted, we can detect 
    // rogue wbem contexts by checking for the presence of a random value 
    // in the context.  Only a local provider and us would ever know this
    // secret value and since local providers never share the contexts with 
    // other non-trusted parties, we can set the secret value in the context
    // and verify the secret value on reentrant calls.
    // 
    #define SECRET_SIZE 16
    BYTE m_achSecretBytes[SECRET_SIZE];

    HRESULT SetSecret( IWbemContext* pContext );
    HRESULT VerifySecret( IWbemContext* pContext );
    HRESULT PrepareCurrentEssThreadObject( IWbemContext* pContext );
    
protected:
    typedef CImpl<IWbemEventSubsystem_m4, CEssObjectSink> TImplESS;
    class XESS : public TImplESS
    {
    public:
        XESS(CEssObjectSink* pObject) : TImplESS(pObject)
        {}

        STDMETHOD(ProcessInternalEvent)(long lSendType, LPCWSTR str1, LPCWSTR str2, 
            LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
            _IWmiObject** apObjects, IWbemContext* pContext);

        STDMETHOD(VerifyInternalEvent)(long lSendType, LPCWSTR str1, LPCWSTR str2, 
            LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
            _IWmiObject** apObjects, IWbemContext* pContext);

        STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*)
        {return WBEM_S_NO_ERROR;}

        STDMETHOD(RegisterNotificationSink)(LPCWSTR wszNamespace, 
            LPCWSTR wszQueryLanguage, LPCWSTR wszQuery, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink);

        STDMETHOD(RemoveNotificationSink)(IWbemObjectSink* pSink);
    
        STDMETHOD(GetNamespaceSink)(LPCWSTR wszNamespace, 
            IWbemObjectSink** ppSink);
        STDMETHOD(Initialize)(LPCWSTR wszServer, IWbemLocator* pAdminLocator,
                                IUnknown* pServices);
        STDMETHOD(Shutdown)();
        STDMETHOD(LastCallForCore)(LONG lSystemShutDown);
    } m_XESS;
    friend XESS;

    typedef CImpl<_IWmiESS, CEssObjectSink> TImplNewESS;
    class XNewESS : public TImplNewESS
    {
    public:
        XNewESS(CEssObjectSink* pObject) : TImplNewESS(pObject)
        {}

        STDMETHOD(Initialize)(long lFlags, IWbemContext* pCtx, 
                    _IWmiCoreServices* pServices);

        STDMETHOD(ExecNotificationQuery)(LPCWSTR wszNamespace, 
            LPCWSTR wszQueryText, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink);

        STDMETHOD(CancelAsyncCall)(IWbemObjectSink* pSink);
    
        STDMETHOD(QueryObjectSink)(LPCWSTR wszNamespace, 
            IWbemObjectSink** ppSink);
    } m_XNewESS;
    friend XNewESS;

    typedef CImpl<IWbemShutdown, CEssObjectSink> TImplShutdown;

    class XShutdown : public TImplShutdown
    {
    public:
        XShutdown(CEssObjectSink* pObject) : TImplShutdown(pObject)
        {}

        STDMETHOD(Shutdown)( long lFlags,
                             ULONG uMaxMilliseconds, 
                             IWbemContext* pCtx );
    } m_XShutdown;
    friend XShutdown;

    typedef CImpl<_IWmiCoreWriteHook, CEssObjectSink> TImplHook;

    class XHook : public TImplHook
    {
    public:
        XHook(CEssObjectSink* pObject) : TImplHook(pObject)
        {}

        STDMETHOD(PrePut)(long lFlags, long lUserFlags, IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pCopy);
        STDMETHOD(PostPut)(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pNew, 
                            _IWmiObject* pOld);
        STDMETHOD(PreDelete)(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass);
        STDMETHOD(PostDelete)(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pOld);
    } m_XHook;
    friend XHook;

public:
    CEssObjectSink(CLifeControl* pControl, IUnknown* pOuter = NULL);
    ~CEssObjectSink();
    void* GetInterface(REFIID riid);
};

class CEssNamespaceSink : public CUnk
{
    CEss* m_pEss;
    BSTR m_strNamespace;
protected:
    typedef CImpl<IWbemObjectSink, CEssNamespaceSink> TImplSink;
    class XSink : public TImplSink
    {
    public:
        XSink(CEssNamespaceSink* pObject) : TImplSink(pObject){}

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
        STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*)
        {return WBEM_S_NO_ERROR;}
    } m_XSink;
    friend XSink;

public:
    CEssNamespaceSink(CEss* pEss, CLifeControl* pControl, 
                            IUnknown* pOuter = NULL);
    HRESULT Initialize(LPCWSTR wszNamespace);
    ~CEssNamespaceSink();
    void* GetInterface(REFIID riid);
};

/****************************************************************************
  
  CEssInternalOperationSink

  This sink handles the setting up of a new ess thread object and then 
  delegates calls to the specified sink.  The purpose of this is so that 
  internal ess operations can be performed asynchronously.  For example, 
  for class change notifications we register a sink that reactivates the 
  associated filter. In order to actually perform the reactivation, the 
  calling thread must be set up appropriately.  

*****************************************************************************/
 
class CEssInternalOperationSink 
: public CUnkBase< IWbemObjectSink, &IID_IWbemObjectSink >
{
    CWbemPtr<IWbemObjectSink> m_pSink;

public:

    CEssInternalOperationSink( IWbemObjectSink* pSink ) : m_pSink( pSink ) {} 
    STDMETHOD(Indicate)( long cObjects, IWbemClassObject** ppObjs ); 
    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\essutils.cpp ===
//******************************************************************************
//
//  ESSUTILS.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "essutils.h"
#include <tls.h>

CTLS g_tlsContext;

long g_lNumExternalThreadObjects = 0;

INTERNAL CEssThreadObject* GetCurrentEssThreadObject()
{
    CEssThreadObject* pObj = (CEssThreadObject*)g_tlsContext.Get();
    
    if ( pObj != NULL )
    {
        //
        // mark the fact that we are handing the thread object to the 
        // outside world.  We use this later on when checking 
        // thread object leaks.
        //        
        pObj->SetReferencedExternally();
    }

    return pObj;
}

void SetCurrentEssThreadObject(IWbemContext* pContext)
{
    //
    // make sure we're not overwriting an existing internal thread object.
    // if its externally referenced, we really can't tell if this would 
    // be a leak or not.
    //
    CEssThreadObject* pOldObj = (CEssThreadObject*)g_tlsContext.Get();
    _DBG_ASSERT( pOldObj == NULL || pOldObj->IsReferencedExternally() );

    CEssThreadObject* pObj = new CEssThreadObject(pContext);
    g_tlsContext.Set((void*)pObj);
}

void SetConstructedEssThreadObject(CEssThreadObject* pObj)
{
    //
    // make sure we're not overwriting an existing internal thread object.
    // if its externally referenced, we really can't tell if this would 
    // be a leak or not.
    //
    CEssThreadObject* pOldObj = (CEssThreadObject*)g_tlsContext.Get();
    _DBG_ASSERT( pOldObj == NULL || pOldObj->IsReferencedExternally() );

    //
    // since this object was passed in from the outside world, then 
    // mark it as externally referenced.
    //
    if ( pObj != NULL )
    {
        pObj->SetReferencedExternally();
    }

    g_tlsContext.Set((void*)pObj);
}

void ClearCurrentEssThreadObject()
{
    //
    // make sure we're not overwriting an existing internal thread object.
    // if its externally referenced, we really can't tell if this would 
    // be a leak or not.
    //
    CEssThreadObject* pObj = (CEssThreadObject*)g_tlsContext.Get();
    _DBG_ASSERT( pObj == NULL || pObj->IsReferencedExternally() );    
    
    g_tlsContext.Set(NULL);
}

INTERNAL IWbemContext* GetCurrentEssContext()
{
    CEssThreadObject* pThreadObj = (CEssThreadObject*)g_tlsContext.Get();
    if(pThreadObj)
        return pThreadObj->m_pContext;
    else
        return NULL;
}

INTERNAL CPostponedList* GetCurrentPostponedList()
{
    CEssThreadObject* pThreadObj = (CEssThreadObject*)g_tlsContext.Get();
    if(pThreadObj)
        return &pThreadObj->m_PostponedList;
    else
        return NULL;
}

INTERNAL CPostponedList* GetCurrentPostponedEventList()
{
    CEssThreadObject* pThreadObj = (CEssThreadObject*)g_tlsContext.Get();
    if(pThreadObj)
        return &pThreadObj->m_PostponedEventList;
    else
        return NULL;
}
    
CEssThreadObject::CEssThreadObject( IWbemContext* pContext )
: m_bReferencedExternally( FALSE )
{
    m_pContext = pContext;
    
    if( m_pContext == NULL )
    {
        m_pContext = GetSpecialContext();
    }

    if ( m_pContext != NULL )
    {
        m_pContext->AddRef();
    }
}

void CEssThreadObject::SetReferencedExternally()
{
    if ( !m_bReferencedExternally )
    {
        g_lNumExternalThreadObjects++;
        m_bReferencedExternally = TRUE;
    }
}

IWbemContext* CEssThreadObject::mstatic_pSpecialContext = NULL;

INTERNAL IWbemContext* CEssThreadObject::GetSpecialContext()
{
    // Create a "special" context object that will make sure that our 
    // calls back into CIMOM are not blocked
    // ==============================================================

    if(mstatic_pSpecialContext == NULL)
    {
        IWbemCausalityAccess* pCause = NULL;
        HRESULT hres = CoCreateInstance(CLSID_WbemContext, NULL, 
            CLSCTX_INPROC_SERVER, IID_IWbemCausalityAccess, 
            (void**)&pCause);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to create special context object: "
                "0x%X.  Danger of deadlock\n", hres));
            return NULL;
        }

        CReleaseMe rm1(pCause);

        hres = pCause->MakeSpecial();
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to make the context special: "
                "0x%X.  Danger of deadlock\n", hres));
            return NULL;
        }

        IWbemContext* pContext = NULL;
        hres = pCause->QueryInterface(IID_IWbemContext, (void**)&pContext);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Internal error: invalid context (0x%X)\n",
                hres));
            return NULL;
        }

        if(mstatic_pSpecialContext == NULL) // tiny window for a one-time leak
            mstatic_pSpecialContext = pContext;
        else
            pContext->Release();
    }
    return mstatic_pSpecialContext;
}

CEssThreadObject::~CEssThreadObject()
{
    if ( m_bReferencedExternally )
    {
        g_lNumExternalThreadObjects--;

        //
        // since ClearCurrentEssThreadObject() can reference the 
        // thread object ( for leak checking ) and because we previously 
        // supported the thread object being deleted before
        // CurrentThreadEssThreadObject(), make sure that we perform the 
        // Clear if the current thread object matches this one.  This only 
        // can happen when the thread object is referenced externally.
        //

        CEssThreadObject* pObj = (CEssThreadObject*)g_tlsContext.Get();

        if ( pObj == this )
        {
            ClearCurrentEssThreadObject();
        }
    }

    _DBG_ASSERT( m_PostponedList.IsEmpty() );

    if ( m_pContext != NULL )
    {
        m_pContext->Release();
    }
}

void /*static*/ CEssThreadObject::ClearSpecialContext()
{
    // Call only when no other work can be taking place, e.g. in DllCanUnloadNow
    // =========================================================================

    if(mstatic_pSpecialContext)
        mstatic_pSpecialContext->Release();
    mstatic_pSpecialContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\essutils.h ===
//******************************************************************************
//
//  ESSUTILS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#ifndef __ESS_UTILS__H_
#define __ESS_UTILS__H_

#include <postpone.h>
#include <wbemutil.h>

struct CEssThreadObject
{
    BOOL m_bReferencedExternally;
    IWbemContext* m_pContext;
    CPostponedList m_PostponedList;
    CPostponedList m_PostponedEventList;

    static IWbemContext* mstatic_pSpecialContext;

protected:
    INTERNAL IWbemContext* GetSpecialContext();
    
public:
    CEssThreadObject(IWbemContext* pContext);
    ~CEssThreadObject();

    BOOL IsReferencedExternally() { return m_bReferencedExternally; }
    void SetReferencedExternally();

    void static ClearSpecialContext();
};

INTERNAL IWbemContext* GetCurrentEssContext();
INTERNAL CEssThreadObject* GetCurrentEssThreadObject();
void SetCurrentEssThreadObject(IWbemContext* pContext);
void SetConstructedEssThreadObject(CEssThreadObject* pObject);
void ClearCurrentEssThreadObject();
INTERNAL CPostponedList* GetCurrentPostponedList();
INTERNAL CPostponedList* GetCurrentPostponedEventList();

#define WBEM_REG_ESS WBEM_REG_WBEM L"\\ESS"

/****************************************************************************
  CEssSharedLock
*****************************************************************************/

class CEssSharedLock
{
    int m_nMode;
    int m_cWaitingExclusive;
    CRITICAL_SECTION m_cs;
    HANDLE m_hOkShared;
    HANDLE m_hOkExclusive;

public:
    
    CEssSharedLock() : m_nMode(0), m_cWaitingExclusive(0), 
                       m_hOkShared(NULL), m_hOkExclusive(NULL) {}

    BOOL Initialize()
    {
        _DBG_ASSERT( m_hOkShared == NULL && m_hOkExclusive == NULL );
        m_hOkShared = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( m_hOkShared != NULL )
        {
            m_hOkExclusive = CreateEvent( NULL, FALSE, FALSE, NULL );    
            if ( m_hOkExclusive != NULL )
            {
                try
                {
                    InitializeCriticalSection( &m_cs );
                }
                catch(...)
                {
                    return FALSE;
                }
            }    
        }
        return m_hOkExclusive != NULL;
    }
    
    ~CEssSharedLock() 
    {
        if ( m_hOkShared != NULL )
        {
            CloseHandle( m_hOkShared );
            if ( m_hOkExclusive != NULL )
            {
                CloseHandle( m_hOkExclusive );
                DeleteCriticalSection( &m_cs );
            }
        }
    }

    void EnterShared()
    {
        _DBG_ASSERT( m_hOkShared != NULL );

        EnterCriticalSection( &m_cs );
        while( m_nMode < 0 || m_cWaitingExclusive > 0 )
        {
            LeaveCriticalSection( &m_cs );
            WaitForSingleObject( m_hOkShared, INFINITE );
            EnterCriticalSection( &m_cs );
        }
        m_nMode++;
        ResetEvent( m_hOkExclusive );
        LeaveCriticalSection( &m_cs );
    }

    void EnterExclusive()
    {
        _DBG_ASSERT( m_hOkExclusive != NULL );

        EnterCriticalSection( &m_cs );
        while( m_nMode != 0 )
        {
            m_cWaitingExclusive++;
            LeaveCriticalSection( &m_cs );
            WaitForSingleObject( m_hOkExclusive, INFINITE );
            EnterCriticalSection( &m_cs );
            m_cWaitingExclusive--;
        }
        m_nMode = -1;
        ResetEvent( m_hOkShared );
        LeaveCriticalSection( &m_cs );
    }

    void Leave()
    {
        _DBG_ASSERT( m_nMode != 0 );
        BOOL bSignalExclusive = FALSE;
        BOOL bSignalShared = FALSE;
        
        EnterCriticalSection( &m_cs );
        if ( m_nMode > 0 )
        {
            if ( --m_nMode == 0 && m_cWaitingExclusive > 0 )
                bSignalExclusive = TRUE;
        }
        else
        {
            _DBG_ASSERT( m_nMode == -1 );
            if ( m_cWaitingExclusive > 0 )
                bSignalExclusive = TRUE;
            else
                bSignalShared = TRUE;
            m_nMode = 0;
        }    
        LeaveCriticalSection( &m_cs );

        if ( bSignalExclusive )
            SetEvent( m_hOkExclusive );
        else if ( bSignalShared )
            SetEvent( m_hOkShared );
    }
};

class CInEssSharedLock
{
    CEssSharedLock* m_pLock;

public:
    CInEssSharedLock( CEssSharedLock* pLock, BOOL bExclusive ) 
    : m_pLock(pLock)
    {
        if ( !bExclusive )
            pLock->EnterShared();
        else
            pLock->EnterExclusive();
    }
    ~CInEssSharedLock()
    {
        m_pLock->Leave();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\eventrep.h ===
//*****************************************************************************
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EVENTREP.H
//
//  This file contains basic definitions and classes for event representation.
//
//  Classes defined:
//
//      CEventRepresentation
//
//  History:
//
//      11/27/96    a-levn      Compiles.
//
//*****************************************************************************

#ifndef __EVENT_REP__H_
#define __EVENT_REP__H_

#include <wbemidl.h>
#include <wbemint.h>
#include "parmdefs.h"
#include <wbemcomn.h>
#include <TimeKeeper.h>


// Class and property names of the schema objects related to event subsystem
// =========================================================================

#define SECURITY_DESCRIPTOR_PROPNAME            L"SECURITY_DESCRIPTOR"

#define EVENT_PROVIDER_REGISTRATION_CLASS       L"__EventProviderRegistration"
#define PROVIDER_CLASS                          L"__Provider"
#define EVENT_FILTER_CLASS                      L"__EventFilter"
#define BASE_STANDARD_FILTER_CLASS              L"__BaseStandardEventFilter"
#define CONSUMER_CLASS                          L"__EventConsumer"
#define BINDING_CLASS                           L"__FilterToConsumerBinding"
#define GENERATOR_CLASS                         L"__EventGenerator"
#define GENERATOR_BINDING_CLASS                 L"__GeneratorToConsumerBinding"
#define TIMER_BASE_CLASS                        L"__TimerInstruction"
#define TIMER_ABSOLUTE_CLASS                    L"__AbsoluteTimerInstruction"
#define TIMER_INTERVAL_CLASS                    L"__IntervalTimerInstruction"
#define WIN32_PROVIDER_CLASS                    L"__Win32Provider"
#define CONSUMER_PROVIDER_REGISTRATION_CLASS \
                                          L"__EventConsumerProviderRegistration"
#define EVENT_DROP_CLASS                        L"__EventDroppedEvent"
#define QUEUE_OVERFLOW_CLASS                    L"__EventQueueOverflowEvent"
#define CONSUMER_FAILURE_CLASS                  L"__ConsumerFailureEvent"
#define QOS_FAILURE_CLASS                  L"__QoSFailureEvent"

#define OWNER_SID_PROPNAME                      L"CreatorSID"

#define FILTER_ROLE_NAME                        L"Filter"
#define CONSUMER_ROLE_NAME                      L"Consumer"
#define BINDING_QOS_PROPNAME                    L"DeliveryQoS"
#define BINDING_SYNCHRONICITY_PROPNAME          L"DeliverSynchronously"
#define BINDING_SECURE_PROPNAME                 L"MaintainSecurityContext"
#define BINDING_SLOWDOWN_PROPNAME               L"SlowDownProviders"
#define TIMER_ID_PROPNAME                       L"TimerID"
#define FILTER_KEY_PROPNAME                     L"Name"
#define FILTER_QUERY_PROPNAME                   L"Query"
#define FILTER_LANGUAGE_PROPNAME                L"QueryLanguage"
#define FILTER_EVENTNAMESPACE_PROPNAME          L"EventNamespace"
#define FILTER_EVENTACCESS_PROPNAME             L"EventAccess"
#define FILTER_GUARDNAMESPACE_PROPNAME          L"ConditionNamespace"
#define FILTER_GUARD_PROPNAME                   L"Condition"
#define FILTER_GUARDLANG_PROPNAME               L"ConditionLanguage"
#define CONSUMER_MACHINE_NAME_PROPNAME          L"MachineName"
#define CONSUMER_MAXQUEUESIZE_PROPNAME          L"MaximumQueueSize"
#define PROVIDER_CLSID_PROPNAME                 L"Clsid"
#define PROVIDER_NAME_PROPNAME                  L"Name"
#define EVPROVREG_PROVIDER_REF_PROPNAME         L"Provider"
#define EVPROVREG_QUERY_LIST_PROPNAME           L"EventQueryList"
#define CONSPROV_PROVIDER_REF_PROPNAME          L"Provider"
#define CONSPROV_CLSID_PROPNAME                 L"CLSID"

#define TARGET_NAMESPACE_PROPNAME               L"TargetNamespace"
#define PREVIOUS_NAMESPACE_PROPNAME             L"PreviousNamespace"
#define TARGET_CLASS_PROPNAME                   L"TargetClass"
#define PREVIOUS_CLASS_PROPNAME                 L"PreviousCLass"
#define TARGET_INSTANCE_PROPNAME                L"TargetInstance"
#define PREVIOUS_INSTANCE_PROPNAME              L"PreviousInstance"
#define EVENT_DROP_EVENT_PROPNAME               L"Event"
#define EVENT_DROP_CONSUMER_PROPNAME            L"IntendedConsumer"
#define CONSUMER_FAILURE_ERROR_PROPNAME         L"ErrorCode"
#define CONSUMER_FAILURE_ERROROBJ_PROPNAME      L"ErrorObject"
#define QOS_FAILURE_ERROR_PROPNAME              L"ErrorCode"
#define QUEUE_OVERFLOW_SIZE_PROPNAME            L"CurrentQueueSize"

#define MONITOR_BASE_EVENT_CLASS                L"__MonitorEvent"
#define MONITOR_DATA_EVENT_CLASS                L"__MonitorDataEvent"
#define ASSERT_EVENT_CLASS                      L"__MonitorAssertEvent"
#define RETRACT_EVENT_CLASS                     L"__MonitorRetractEvent"
#define GOINGUP_EVENT_CLASS                     L"__MonitorUpEvent"
#define GOINGDOWN_EVENT_CLASS                   L"__MonitorDownEvent"
#define MONITORERROR_EVENT_CLASS                L"__MonitorErrorEvent"
#define MONITOR_CLASS                           L"__MonitorInstruction"

#define MONITORNAME_EVENT_PROPNAME              L"MonitorName"
#define MONITOROBJECT_EVENT_PROPNAME            L"RowObject"
#define MONITORCOUNT_EVENT_PROPNAME             L"TotalObjects"
#define MONITORNEW_EVENT_PROPNAME               L"GuaranteedNew"

#define MONITOR_NAME_PROPNAME                   L"Name"
#define MONITOR_QUERY_PROPNAME                  L"Query"
#define MONITOR_QUERYLANG_PROPNAME              L"QueryLanguage"
#define MONITOR_NAMESPACE_PROPNAME              L"TargetNamespace"

#define E_NOTFOUND WBEM_E_NOT_FOUND

typedef IWbemClassObject IWbemEvent;

// Helper functions
// ================

inline DELETE_ME LPWSTR CloneWstr(READ_ONLY LPCWSTR wsz)
{
    LPWSTR wszNew = new WCHAR[wcslen(wsz)+1];
    if(wszNew == NULL)
        return NULL;
    StringCchCopyW( wszNew, wcslen(wsz)+1, wsz );
    return wszNew;
}

// Event types. These are used in IndicateEx calls, as well as internally.
// =======================================================================

typedef enum{
    e_EventTypeInvalid = WBEM_EVENTTYPE_Invalid,
    e_EventTypeExtrinsic = WBEM_EVENTTYPE_Extrinsic,
    e_EventTypeTimer = WBEM_EVENTTYPE_Timer,
    e_EventTypeNamespaceCreation = WBEM_EVENTTYPE_NamespaceCreation,
    e_EventTypeNamespaceDeletion = WBEM_EVENTTYPE_NamespaceDeletion,
    e_EventTypeNamespaceModification = WBEM_EVENTTYPE_NamespaceModification,
    e_EventTypeClassCreation = WBEM_EVENTTYPE_ClassCreation,
    e_EventTypeClassDeletion = WBEM_EVENTTYPE_ClassDeletion,
    e_EventTypeClassModification = WBEM_EVENTTYPE_ClassModification,
    e_EventTypeInstanceCreation = WBEM_EVENTTYPE_InstanceCreation,
    e_EventTypeInstanceDeletion = WBEM_EVENTTYPE_InstanceDeletion,
    e_EventTypeInstanceModification = WBEM_EVENTTYPE_InstanceModification,
    e_EventTypeSystem = WBEM_EVENTTYPE_System
} EEventType;

#define INTRINSIC_EVENTS_MASK (~(1<<e_EventTypeExtrinsic))

#define INSTANCE_EVENTS_MASK ( \
            (1<<e_EventTypeInstanceCreation) | \
            (1<<e_EventTypeInstanceDeletion) | \
            (1<<e_EventTypeInstanceModification))

#define CLASS_EVENTS_MASK ( \
            (1<<e_EventTypeClassCreation) | \
            (1<<e_EventTypeClassDeletion) | \
            (1<<e_EventTypeClassModification))

#define NAMESPACE_EVENTS_MASK ( \
            (1<<e_EventTypeNamespaceCreation) | \
            (1<<e_EventTypeNamespaceDeletion) | \
            (1<<e_EventTypeNamespaceModification))

#define DATA_EVENTS_MASK \
            (INSTANCE_EVENTS_MASK | CLASS_EVENTS_MASK | NAMESPACE_EVENTS_MASK)

//*****************************************************************************
//
//  class CEventRepresentation
//
//  This class represents an event that ESS receives. It has public datafields
//  corresponding to the parameters of the IndicateEx call and that is 
//  precisely what is stored in it. 
//
//  This class has two types of existence: allocated and not allocated. Non
//  allocated state is the default. In it, CEventRepresentation string fields 
//  contain pointers to data that does not 'belong' to this class, and is not
//  deleted in the destructor.
//
//  The other, allocated, state is entered when a new copy of this object is
//  created using MakePermanentCopy(). In this state, all string fields contain
//  allocated data which is deleted on destruct.
//
//  CEventRepresentation also contains a table mapping event types into event 
//  class names and event filter class names.
//
//  Finally, CEventRepresentation is derived from CPropertySource and provides
//  property values (taken from the first included IWbemClassObject) to the
//  SQL1 query evaluator.
//
//*****************************************************************************
//
//  MakePermanentCopy
//
//  This function produces a new copy of the event, which can survive complete
//  destruction of the original object. All strings are reallocated and all 
//  IWbemClassObjects are Clone'ed. The reason for that is that WinMgmt core may
//  call ESS with temporary (non-OLE) objects, and if ESS needs to keep them 
//  after it returns from the call, it needs to make a complete copy.
//
//  Returns:
//
//      CEventRepresentation*   pointing to the new object, Must be deleted
//                              by the called.
//
//*****************************************************************************
//
//  MakeWbemObject
//
//  This function creates an IWbemClassObject representation of the event for 
//  clients that do not accept NotifyEx calls. The object will be of the class
//  determined by the type of the event and will contain all the properties 
//  appropriate for that class (with values taken from CEventRepresentation
//  properties).
//
//  Parameters:
//
//      IWbemClassObject** ppEventObject     Destination for the newely created
//                                          object. Caller must Release it when
//                                          done.
//  Returns:
//
//      S_OK        on success
//      S_FALSE     if event is extrinsic. When extrinsic events are specified
//                      in IndicateEx, the first object IS the class object for
//                      the event, and so no additional object creation is
//                      necessary for Indicate.
//      
//      Any CoCreateInstance error.
//      Any IWbemClassObject::Put error.
//
//*****************************************************************************
//
//  static GetEventName
//
//  Retreives the name of the event class corresponding to a given 
//  event type.
//
//  Parameters:
//      
//      EEventType type
//
//  Returns:
//
//      LPCWSTR containing the event class name. This pointer is internal and
//                  may NOT be modified or deleted.
//
//*****************************************************************************
//
//  static GetTypeFromName
//
//  Retreives the type of the event given the name of the event class.
//
//  Parameters:
//      
//      LPCWSTR wszEventName    The name of the event class.
//
//  Returns:
//
//      EEventType
//
//*****************************************************************************
//
//  Get
//
//  Retrives the value of a property, as required by CPropertySource class.
//  This implementation uses the first included object (apObjects[0]) to
//  get the values. Access to other objects is not available.
//
//  Parameters:
//
//      LPCWSTR wszPropName     The same name as in IWbemClassObject
//      VARIANT* pValue         Destination for the value. The caller must
//                              initialize and clear this value.
//  Returns:
//
//      S_OK    on success
//      Any IWbemClassObject::Get error code
//
//*****************************************************************************


class CEssNamespace;
class CEss;
class CEventRepresentation
{
private:
    static CTimeKeeper mstatic_TimeKeeper;
    
protected:
    BOOL m_bAllocated;
    IWbemClassObject* m_pCachedObject;
public:
    long type;
    DWORD dw1;
    DWORD dw2;
    LPWSTR wsz1;
    LPWSTR wsz2;
    LPWSTR wsz3;
    int nObjects;
    IWbemClassObject** apObjects;

public:
    CEventRepresentation()
        : m_bAllocated(FALSE), 
          m_pCachedObject(NULL),
          wsz1( NULL ),
          wsz2( NULL ),
          wsz3( NULL ),
          apObjects( NULL )
      {
           // uninitialized for speed
      }
    
    ~CEventRepresentation();

    STDMETHOD_(ULONG, AddRef)() {return 1;}
    STDMETHOD_(ULONG, Release)() {return 1;}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {*ppv = this; return S_OK;}

    STDMETHOD(InheritsFrom)(WBEM_WSTR wszName);


    inline EEventType GetEventType() {return (EEventType)type;}

    DELETE_ME CEventRepresentation* MakePermanentCopy();
    HRESULT MakeWbemObject(CEssNamespace* pNamespace,
                            RELEASE_ME IWbemClassObject** ppEventObj);
    HRESULT CreateFromObject(IWbemClassObject* pEvent, LPWSTR wszNamespace);

    inline BOOL IsInstanceEvent();
    inline BOOL IsClassEvent();

    static HRESULT Initialize(IWbemServices* pNamespace, 
                                IWbemDecorator* pDecorator);
    static HRESULT Shutdown();

    static INTERNAL LPCWSTR GetEventName(EEventType type);
    static DWORD GetTypeMaskFromName(READ_ONLY LPCWSTR wszEventName);
    static EEventType GetTypeFromName(READ_ONLY LPCWSTR wszEventName);
    static INTERNAL IWbemClassObject* GetEventClass(CEssNamespace* pNamespace, 
                                                        EEventType type);
    static INTERNAL IWbemClassObject* GetEventClass(CEss* pNamespace, 
                                                        EEventType type);

protected:

    struct CEventTypeData
    {
        EEventType type;
        LPWSTR wszEventName;
        IWbemClassObject* pEventClass;
    };

    static CEventTypeData staticTypes[];
    static int NumEventTypes();
    static IWbemDecorator* mstatic_pDecorator;

    friend class CEss;
};

#define CLASS_OF(EVENT) (EVENT.wsz2)
#define NAMESPACE_OF(EVENT) (EVENT.wsz1)
#define OBJECT_OF(EVENT) (EVENT.apObjects[0])
#define OTHER_OBJECT_OF(EVENT) (EVENT.apObjects[1])

inline BOOL CEventRepresentation::IsInstanceEvent()
{
    return (type == e_EventTypeInstanceCreation || 
            type == e_EventTypeInstanceModification ||  
            type == e_EventTypeInstanceDeletion);
}

inline BOOL CEventRepresentation::IsClassEvent()
{
    return (type == e_EventTypeClassCreation || 
            type == e_EventTypeClassModification ||  
            type == e_EventTypeClassDeletion);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\eventrep.cpp ===
//*****************************************************************************
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EVENTREP.CPP
//
//  This file implements basic classes for event representation.
//
//  See eventrep.h for documentation.
//
//  History:
//
//      11/27/96    a-levn      Compiles.
//
//*****************************************************************************
#include "precomp.h"
#include <stdio.h>
#include <ess.h>


CTimeKeeper CEventRepresentation::mstatic_TimeKeeper;


CEventRepresentation::CEventTypeData CEventRepresentation::staticTypes[] = 
{
    {e_EventTypeExtrinsic, L"__ExtrinsicEvent", NULL},
    {e_EventTypeNamespaceCreation, L"__NamespaceCreationEvent", NULL},
    {e_EventTypeNamespaceDeletion, L"__NamespaceDeletionEvent", NULL},
    {e_EventTypeNamespaceModification, L"__NamespaceModificationEvent", NULL},
    {e_EventTypeClassCreation, L"__ClassCreationEvent", NULL},
    {e_EventTypeClassDeletion, L"__ClassDeletionEvent", NULL},
    {e_EventTypeClassModification, L"__ClassModificationEvent", NULL},
    {e_EventTypeInstanceCreation, L"__InstanceCreationEvent", NULL},
    {e_EventTypeInstanceDeletion, L"__InstanceDeletionEvent", NULL},
    {e_EventTypeInstanceModification, L"__InstanceModificationEvent", NULL},
    {e_EventTypeTimer, L"__TimerEvent", NULL}
};

IWbemDecorator* CEventRepresentation::mstatic_pDecorator = NULL;

//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************

int CEventRepresentation::NumEventTypes() 
{
    return sizeof(staticTypes) / sizeof CEventTypeData;
}


//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************
HRESULT CEventRepresentation::Initialize(IWbemServices* pNamespace, 
                                         IWbemDecorator* pDecorator)
{
    mstatic_pDecorator = pDecorator;
    pDecorator->AddRef();

    return WBEM_S_NO_ERROR;
}


HRESULT CEventRepresentation::Shutdown()
{
    if(mstatic_pDecorator)
    {
        mstatic_pDecorator->Release();
        mstatic_pDecorator = NULL;
    }

    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(staticTypes[i].pEventClass != NULL)
        {
            staticTypes[i].pEventClass->Release();
            staticTypes[i].pEventClass = NULL;
        }
    }
    return WBEM_S_NO_ERROR;
}
        
//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************
CEventRepresentation::~CEventRepresentation()
{
    if(m_bAllocated)
    {
        // All fields have been allocated, and need to be deleted
        // ======================================================

        delete [] wsz1;
        delete [] wsz2;
        delete [] wsz3;

        for(int i = 0; i < nObjects; i++)
        {
            (apObjects[i])->Release();
        }
        delete [] apObjects;
    }

    if(m_pCachedObject)
        m_pCachedObject->Release();
}


//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************
DELETE_ME CEventRepresentation* CEventRepresentation::MakePermanentCopy()
{
    // Allocate a new event structure and set flags to "allocated"
    // ===========================================================

    CEventRepresentation* pCopy = _new CEventRepresentation;
    if(pCopy == NULL)
        return NULL;

    pCopy->m_bAllocated = TRUE;

    pCopy->type = type;
    pCopy->dw1 = dw1;
    pCopy->dw2 = dw2;

    if(wsz1)
    {
        pCopy->wsz1 = _new WCHAR[wcslen(wsz1)+1];
        if(pCopy->wsz1 == NULL)
        {
            delete pCopy;
            return NULL;
        }
        StringCchCopyW( pCopy->wsz1, wcslen(wsz1)+1, wsz1 );
    }
    else pCopy->wsz1 = NULL;

    if(wsz2)
    {
        pCopy->wsz2 = _new WCHAR[wcslen(wsz2)+1];
        if(pCopy->wsz2 == NULL)
        {
            delete pCopy;
            return NULL;
        }
        StringCchCopyW( pCopy->wsz2, wcslen(wsz2)+1, wsz2 );
    }
    else pCopy->wsz2 = NULL;

    if(wsz3)
    {
        pCopy->wsz3 = _new WCHAR[wcslen(wsz3)+1];
        if(pCopy->wsz3 == NULL)
        {
            delete pCopy;
            return NULL;
        }
        StringCchCopyW(pCopy->wsz3, wcslen(wsz3)+1, wsz3 );
    }
    else pCopy->wsz3 = NULL;

    pCopy->nObjects = nObjects;
    pCopy->apObjects = _new IWbemClassObject*[nObjects];
    if(pCopy->apObjects == NULL)
    {
        delete pCopy;
        return NULL;
    }

    // Make fresh copies of all objects
    // ================================
    // TBD: more effecient solutions may be possible here!

    for(int i = 0; i < nObjects; i++)
    {
        HRESULT hres = apObjects[i]->Clone(pCopy->apObjects + i);
        if(FAILED(hres)) 
        {
            // Abort
            pCopy->nObjects = i; // successfully copied
            delete pCopy;
            return NULL;
        }
    }

    return pCopy;
}


//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
INTERNAL LPCWSTR CEventRepresentation::GetEventName(EEventType type)
{
    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(staticTypes[i].type == type) return staticTypes[i].wszEventName;
    }
    return NULL;
}


//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
INTERNAL IWbemClassObject* CEventRepresentation::GetEventClass(
                            CEssNamespace* pNamespace, EEventType type)
{
    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(staticTypes[i].type == type) 
        {
            if(staticTypes[i].pEventClass == NULL)
            {
                _IWmiObject* pClass = NULL;
                HRESULT hres = pNamespace->GetClass(staticTypes[i].wszEventName,
                                                &pClass);
                if(FAILED(hres))
                    return NULL;

                staticTypes[i].pEventClass = pClass;
            }

            return staticTypes[i].pEventClass;
        }
    }
    return NULL;
}

INTERNAL IWbemClassObject* CEventRepresentation::GetEventClass(CEss* pEss,
                                                        EEventType type)
{
    CEssNamespace* pNamespace = NULL;
    HRESULT hres = pEss->GetNamespaceObject( L"root", FALSE, &pNamespace);
    if(FAILED(hres))
        return NULL;

    IWbemClassObject* pClass = GetEventClass(pNamespace, type);
    pNamespace->Release();
    return pClass;
}
    

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
DWORD CEventRepresentation::GetTypeMaskFromName(READ_ONLY LPCWSTR wszEventName)
{
    if(wszEventName[0] != '_')
        return 1 << e_EventTypeExtrinsic;

    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(!wbem_wcsicmp(staticTypes[i].wszEventName, wszEventName))
            return (1 << staticTypes[i].type);
    }

    if(!wbem_wcsicmp(wszEventName, L"__Event"))
    {
        return 0xFFFFFFFF;
    } 

    if(!wbem_wcsicmp(wszEventName, L"__NamespaceOperationEvent"))
    {
        return (1 << e_EventTypeNamespaceCreation) |
               (1 << e_EventTypeNamespaceDeletion) |
               (1 << e_EventTypeNamespaceModification);
    }
    if(!wbem_wcsicmp(wszEventName, L"__ClassOperationEvent"))
    {
        return (1 << e_EventTypeClassCreation) |
               (1 << e_EventTypeClassDeletion) |
               (1 << e_EventTypeClassModification);
    }
    if(!wbem_wcsicmp(wszEventName, L"__InstanceOperationEvent"))
    {
        return (1 << e_EventTypeInstanceCreation) |
               (1 << e_EventTypeInstanceDeletion) |
               (1 << e_EventTypeInstanceModification);
    }

    if(!wbem_wcsicmp(wszEventName, EVENT_DROP_CLASS) ||
        !wbem_wcsicmp(wszEventName, QUEUE_OVERFLOW_CLASS) ||
        !wbem_wcsicmp(wszEventName, CONSUMER_FAILURE_CLASS))
    {
        return (1 << e_EventTypeSystem);
    }

    return 1 << e_EventTypeExtrinsic;
}


//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
EEventType CEventRepresentation::GetTypeFromName(READ_ONLY LPCWSTR wszEventName)
{
    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(!wbem_wcsicmp(staticTypes[i].wszEventName, wszEventName))
            return staticTypes[i].type;
    }

    return e_EventTypeExtrinsic;
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
HRESULT CEventRepresentation::MakeWbemObject(
                                       CEssNamespace* pNamespace,
                                       RELEASE_ME IWbemClassObject** ppEventObj)
{
    HRESULT hres;

    // Check if we have a cached copy
    // ==============================

    if(m_pCachedObject != NULL)
    {
        *ppEventObj = m_pCachedObject;
        m_pCachedObject->AddRef();
        return S_OK;
    }

    if(type == e_EventTypeExtrinsic || type == e_EventTypeTimer || 
        type == e_EventTypeSystem)
    {
        *ppEventObj = apObjects[0];
        mstatic_TimeKeeper.DecorateObject((_IWmiObject*)apObjects[0]);
        (*ppEventObj)->AddRef();
        
        return S_OK;
    }
    
    // Create an instance
    // ==================

    IWbemClassObject* pClass = GetEventClass(pNamespace, (EEventType)type);
    if(pClass == NULL)
    {
        return WBEM_E_NOT_FOUND;
    }

    IWbemClassObject* pEventObj = NULL;
    if(FAILED(pClass->SpawnInstance(0, &pEventObj)))
    {
        return WBEM_E_FAILED;
    }
    CReleaseMe rm1(pEventObj);

    // Set event-dependent properties
    // ==============================

    VARIANT vFirst, vSecond;
    VariantInit(&vFirst);
    VariantInit(&vSecond);
    CClearMe cm1(&vFirst);
    CClearMe cm2(&vSecond);

    if(nObjects > 0)
    {
        V_VT(&vFirst) = VT_EMBEDDED_OBJECT;
        V_EMBEDDED_OBJECT(&vFirst) = apObjects[0];
        apObjects[0]->AddRef();
    }

    if(nObjects > 1)
    {
        V_VT(&vSecond) = VT_EMBEDDED_OBJECT;
        V_EMBEDDED_OBJECT(&vSecond) = apObjects[1];
        if(apObjects[1])
        {
            apObjects[1]->AddRef();
        }
        else
            V_VT(&vSecond) = VT_NULL; // no previous!
    }
    
    LPCWSTR wszFirstProp = NULL, wszSecondProp = NULL;

    hres = WBEM_E_CRITICAL_ERROR;
    switch(type)
    {
        case e_EventTypeInstanceCreation:
            hres = pEventObj->Put(TARGET_INSTANCE_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeInstanceDeletion:
            hres = pEventObj->Put(TARGET_INSTANCE_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeInstanceModification:
            hres = pEventObj->Put(TARGET_INSTANCE_PROPNAME, 0, &vFirst, 0); 
            if(SUCCEEDED(hres))
                hres = pEventObj->Put(PREVIOUS_INSTANCE_PROPNAME, 0, 
                                                &vSecond, 0); 
            break;

        case e_EventTypeClassCreation:
            hres = pEventObj->Put(TARGET_CLASS_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeClassDeletion:
            hres = pEventObj->Put(TARGET_CLASS_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeClassModification:
            hres = pEventObj->Put(TARGET_CLASS_PROPNAME, 0, &vFirst, 0); 
            if(SUCCEEDED(hres))
                hres = pEventObj->Put(PREVIOUS_CLASS_PROPNAME, 0, &vSecond, 
                                            0); 
            break;

        case e_EventTypeNamespaceCreation:
            hres = pEventObj->Put(TARGET_NAMESPACE_PROPNAME, 0, &vFirst, 0);
            break;
        case e_EventTypeNamespaceDeletion:
            hres = pEventObj->Put(TARGET_NAMESPACE_PROPNAME, 0, &vFirst, 0);
            break;
        case e_EventTypeNamespaceModification:
            hres = pEventObj->Put(TARGET_NAMESPACE_PROPNAME, 0, &vFirst, 0);
            if(SUCCEEDED(hres))
                hres = pEventObj->Put(PREVIOUS_NAMESPACE_PROPNAME, 0, 
                                            &vSecond, 0); 
            break;
    }

    if(FAILED(hres))
        return hres;

    // Decorate it
    // ===========

    if(mstatic_pDecorator)
    {
        hres = mstatic_pDecorator->DecorateObject(pEventObj, wsz1);
        if(FAILED(hres))
            return hres;
    }

    mstatic_TimeKeeper.DecorateObject((_IWmiObject*)pEventObj);

    // Store it in our cache
    // =====================

    m_pCachedObject = pEventObj;
    m_pCachedObject->AddRef();

    *ppEventObj = pEventObj;
    (*ppEventObj)->AddRef();

    return S_OK;
}

HRESULT CEventRepresentation::CreateFromObject(IWbemClassObject* pEvent,
                                                LPWSTR wszNamespace)
{
    HRESULT hres;

    // Get the class of the event
    // ==========================

    VARIANT vClass;
    VariantInit(&vClass);
    if (FAILED(hres = pEvent->Get(L"__CLASS", 0, &vClass, NULL, NULL)))
    	return hres;

    type = GetTypeFromName(V_BSTR(&vClass));
    dw1 = 0;
    dw2 = 0;
    wsz1 = _new WCHAR[wcslen(wszNamespace)+1];
    if (!wsz1)
    	return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW( wsz1, wcslen(wszNamespace)+1, wszNamespace );

    wsz2 = NULL;
    wsz3 = NULL;
    nObjects = 1;
    m_bAllocated = TRUE;

    IWbemClassObject** aEmbedded = new IWbemClassObject*[2];
    if (!aEmbedded)
    	return WBEM_E_OUT_OF_MEMORY;    
    apObjects = (IWbemClassObject**)aEmbedded;
    aEmbedded[0] = pEvent;
    pEvent->AddRef();

    VariantClear(&vClass);

    // If the event is an intrinsic one, get the class of the target object
    // ====================================================================

    VARIANT vEmbed;
    VariantInit(&vEmbed);

#define SET_FIRST_OBJECT \
        { \
            pEvent->Release(); \
            aEmbedded[0] = (IWbemClassObject*)V_EMBEDDED_OBJECT(&vEmbed); \
            aEmbedded[0]->AddRef(); \
            aEmbedded[0]->Get(L"__CLASS", 0, &vClass, NULL, NULL); \
            wsz2 = _new WCHAR[wcslen(V_BSTR(&vClass))+1]; \
            StringCchCopyW( wsz2, wcslen(V_BSTR(&vClass))+1,V_BSTR(&vClass)); \
            VariantClear(&vEmbed); \
            VariantClear(&vClass); \
        }

#define SET_SECOND_OBJECT \
        {  \
            nObjects = 2; \
            aEmbedded[1] = (IWbemClassObject*)V_EMBEDDED_OBJECT(&vEmbed); \
            aEmbedded[1]->AddRef(); \
            VariantClear(&vEmbed); \
        }

    switch(type)
    {
    case e_EventTypeClassModification:
        hres = pEvent->Get(PREVIOUS_CLASS_PROPNAME, 0, &vEmbed, NULL, NULL);
        if(SUCCEEDED(hres))
            SET_SECOND_OBJECT;

    case e_EventTypeClassCreation:
    case e_EventTypeClassDeletion:
        hres = pEvent->Get(TARGET_CLASS_PROPNAME, 0, &vEmbed, NULL, NULL);
        if(SUCCEEDED(hres))
            SET_FIRST_OBJECT
        break;

    case e_EventTypeInstanceModification:
        hres = pEvent->Get(PREVIOUS_INSTANCE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_SECOND_OBJECT;
    case e_EventTypeInstanceCreation:
    case e_EventTypeInstanceDeletion:
        hres = pEvent->Get(TARGET_INSTANCE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_FIRST_OBJECT;
        break;
            
    case e_EventTypeNamespaceModification:
        hres = pEvent->Get(PREVIOUS_NAMESPACE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_SECOND_OBJECT;
    case e_EventTypeNamespaceCreation:
    case e_EventTypeNamespaceDeletion:
        hres = pEvent->Get(TARGET_NAMESPACE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_FIRST_OBJECT;
        break;
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CEventRepresentation::InheritsFrom(WBEM_WSTR wszName)
{
    if(type == e_EventTypeExtrinsic)
        return apObjects[0]->InheritsFrom(wszName);

    LPCWSTR wszEventName = GetEventName((EEventType)type);
    if(wszEventName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(!wbem_wcsicmp(wszName, wszEventName))
        return S_OK;
    if(!wbem_wcsicmp(wszName, L"__IndicationRelated"))
        return S_OK;
    if(!wbem_wcsicmp(wszName, L"__Event"))
        return S_OK;
    if(!wbem_wcsicmp(wszName, L"__NamespaceOperationEvent") && 
            wcsstr(wszEventName, L"Namespace"))
        return S_OK;
    if(!wbem_wcsicmp(wszName, L"__ClassOperationEvent") && 
            wcsstr(wszEventName, L"Class"))
        return S_OK;
    if(!wbem_wcsicmp(wszName, L"__InstanceOperationEvent") && 
            wcsstr(wszEventName, L"Instance"))
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\evsink.cpp ===
//******************************************************************************
//
//  EVSINK.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <genutils.h>
#include <cominit.h>
#include "ess.h"
#include "evsink.h"

//****************************** CONTEXT **********************************//

CEventContext::~CEventContext()
{
    if( m_bOwning )
    {
        delete [] m_pSD;
    }
}

BOOL CEventContext::SetSD( long lSDLength, BYTE* pSD, BOOL bMakeCopy )
{
    BOOL bRes = TRUE;

    if ( m_bOwning )
    {
        delete [] m_pSD;
        m_bOwning = false;
    }

    m_lSDLength = lSDLength;
       
    if ( m_lSDLength > 0 )
    {
        if ( !bMakeCopy )
        {
            m_pSD = pSD;
            m_bOwning = false;
        }
        else
        {
            m_pSD = new BYTE[m_lSDLength];
            
            if ( m_pSD != NULL )
            {
                memcpy( m_pSD, pSD, m_lSDLength );
                m_bOwning = true;
            }
            else
            {
                bRes = FALSE;
            }
        }
    }
    else
    {
        m_pSD = NULL;
    }

    return bRes;
}

CReuseMemoryManager CEventContext::mstatic_Manager(sizeof CEventContext);

void *CEventContext::operator new(size_t nBlock)
{
    return mstatic_Manager.Allocate();
}
void CEventContext::operator delete(void* p)
{
    mstatic_Manager.Free(p);
}

/*
void* CEventContext::operator new(size_t nSize)
{
    return CTemporaryHeap::Alloc(nSize);
}
void CEventContext::operator delete(void* p)
{
    CTemporaryHeap::Free(p, sizeof(CEventContext));
}
*/

//*************************** ABSTRTACT EVENT SINK *************************//

STDMETHODIMP CAbstractEventSink::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink )
    {
        *ppv = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else
        return E_NOINTERFACE;
}

STDMETHODIMP CAbstractEventSink::SetStatus(long, long, BSTR, IWbemClassObject*)
{
    return E_NOTIMPL;
}

HRESULT CAbstractEventSink::Indicate(long lNumEvemts, IWbemEvent** apEvents, 
                    CEventContext* pContext)
{
    return WBEM_E_CRITICAL_ERROR; // if not implemented, but called
}

STDMETHODIMP CAbstractEventSink::Indicate(long lNumEvents, 
                                         IWbemClassObject** apEvents)
{
    //
    // Event is being raised without security --- send it along with an empty
    // context
    //

    return Indicate(lNumEvents, apEvents, NULL);
}
                                        
STDMETHODIMP CAbstractEventSink::IndicateWithSD(long lNumEvents, 
                                         IUnknown** apEvents,
                                         long lSDLength, BYTE* pSD)
{
    HRESULT hres;

    //
    // Event is being raised with security -- send it along with that SD in the
    // context
    //

    CEventContext Context;
    Context.SetSD( lSDLength, pSD, FALSE );
    
    //
    // Allocate a stack buffer to cast the pointers
    //

    CTempArray<IWbemClassObject*> apCast;

    if(!INIT_TEMP_ARRAY(apCast, lNumEvents))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    for(int i = 0; i < lNumEvents; i++)
    {
        hres = apEvents[i]->QueryInterface( IID_IWbemClassObject, 
                                            (void**)&apCast[i] );
        if ( FAILED(hres) )
        {
            return hres;
        }
    }

    return Indicate(lNumEvents, apCast, &Context);
}

//*************************** OBJECT SINK *************************//

STDMETHODIMP CObjectSink::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    // Hack to idenitfy ourselves to the core as a trusted component
    else if(riid == CLSID_WbemLocator)
    return S_OK;
    else
    return E_NOINTERFACE;
}

STDMETHODIMP CObjectSink::SetStatus(long, long, BSTR, IWbemClassObject*)
{
    return E_NOTIMPL;
}

ULONG STDMETHODCALLTYPE CObjectSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CObjectSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    delete this;
    return lRef;
}

//*************************** EVENT SINK *************************//

ULONG STDMETHODCALLTYPE CEventSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CEventSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    delete this;
    return lRef;
}

//*************************** OWNED EVENT SINK *************************//

COwnedEventSink::COwnedEventSink(CAbstractEventSink* pOwner) 
: m_pOwner(pOwner), m_lRef(0), m_bReleasing(false)
{
}

ULONG STDMETHODCALLTYPE COwnedEventSink::AddRef()
{
    CInCritSec ics(&m_cs);

    // 
    // Increment our ref count, as well as that of our putative owner
    //

    m_lRef++;
    if(m_pOwner)
    m_pOwner->AddRef();
    return m_lRef;
}

ULONG STDMETHODCALLTYPE COwnedEventSink::Release()
{
    bool bDelete = false;
    {
        CInCritSec ics(&m_cs);

        m_bReleasing = true;
        
        m_lRef--;

        // 
        // Propagate release to our owner.  This may cause Disconnect to be 
        // called, but it will know not to self-destruct because of 
        // m_bReleasing
        // 

        if(m_pOwner)
        m_pOwner->Release();    

        // 
        // Determine whether self-destruct is called for
        //
        
        if(m_lRef == 0 && m_pOwner == NULL)
        {    
            bDelete = true;
        }

        m_bReleasing = false;
    }

    if(bDelete)
    delete this;

    return 1;
}

void COwnedEventSink::Disconnect()
{
    bool bDelete = false;

    {
        CInCritSec ics(&m_cs);
        
        if(m_pOwner == NULL)
        return;
        
        // 
        // Release all the ref-counts that the owner has received through us
        //
        
        for(int i = 0; i < m_lRef; i++)
        m_pOwner->Release();
        
        //
        // Forget about the owner.  Once we have been released by externals, 
        // we go away
        //
        
        m_pOwner = NULL;

        // 
        // Check if we are already fully released by externals
        //

        if(m_lRef == 0 && !m_bReleasing)
        bDelete = true;
    }

    if(bDelete)
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\evsink.h ===
//******************************************************************************
//
//  EVSINK.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_SINKS__H_
#define __WMI_ESS_SINKS__H_

#include "eventrep.h"
#include <sync.h>
#include <unk.h>
#include <newnew.h>
#include <comutl.h>

class CEventContext
{
protected:
    long m_lSDLength;
    BYTE* m_pSD; 
    bool m_bOwning;

    static CReuseMemoryManager mstatic_Manager;

    CEventContext( const CEventContext& rOther );
    CEventContext& operator= ( const CEventContext& rOther );

public:
    CEventContext() : m_lSDLength(0), m_pSD(NULL), m_bOwning(false) {}
    ~CEventContext();

    BOOL SetSD( long lSDLength, BYTE* pSD, BOOL bMakeCopy );
    const SECURITY_DESCRIPTOR* GetSD() const    
        {return (SECURITY_DESCRIPTOR*)m_pSD;}
    long GetSDLength() const {return m_lSDLength;}

    void* operator new(size_t nSize);
    void operator delete(void* p);
};    
    
class CEssNamespace;
class CEventFilter;
class CAbstractEventSink : public IWbemObjectSink
{
public:
    CAbstractEventSink(){}
    virtual ~CAbstractEventSink(){}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);
    STDMETHOD(Indicate)(long lNumEvents, IWbemEvent** apEvents);
    STDMETHOD(IndicateWithSD)(long lNumEvents, IUnknown** apEvents,
                                long lSDLength, BYTE* pSD);

    virtual HRESULT Indicate(long lNumEvemts, IWbemEvent** apEvents, 
                                CEventContext* pContext) = 0;
    virtual INTERNAL CEventFilter* GetEventFilter() {return NULL;}
};

class CEventSink : public CAbstractEventSink
{
protected:
    long m_lRef;

public:
    CEventSink() : m_lRef(0){}
    virtual ~CEventSink(){}
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext) = 0;

    virtual INTERNAL CEventFilter* GetEventFilter() {return NULL;}
};

class CObjectSink : public IWbemObjectSink
{
protected:
    long m_lRef;

public:
    CObjectSink() : m_lRef(0){}
    virtual ~CObjectSink(){}
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD(Indicate)(long lNumEvents, IWbemEvent** apEvents) = 0;
    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);
};

template <class TOuter, class TBase>
class CEmbeddedSink : public TBase
{
protected:
    TOuter* m_pOuter;

public:
    CEmbeddedSink(TOuter* pOuter) : m_pOuter(pOuter){}
    virtual ~CEmbeddedSink(){}
    ULONG STDMETHODCALLTYPE AddRef() {return m_pOuter->AddRef();}
    ULONG STDMETHODCALLTYPE Release() {return m_pOuter->Release();}

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        {
            *ppv = (IWbemObjectSink*)this;
            AddRef();
            return S_OK;
        }
        // Hack to idenitfy ourselves to the core as a trusted component
        else if(riid == CLSID_WbemLocator)
            return S_OK;
        else
            return E_NOINTERFACE;
    }
    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*)
    {
        return E_NOTIMPL;
    }
};

template <class TOuter>
class CEmbeddedObjectSink : public CEmbeddedSink<TOuter, IWbemObjectSink>
{
public:
    CEmbeddedObjectSink(TOuter* pOuter) 
        : CEmbeddedSink<TOuter, IWbemObjectSink>(pOuter)
    {}
};

template <class TOuter>
class CEmbeddedEventSink : public CEmbeddedSink<TOuter, CAbstractEventSink>
{
public:
    CEmbeddedEventSink(TOuter* pOuter) 
        : CEmbeddedSink<TOuter, CAbstractEventSink>(pOuter)
    {}
};
    
class COwnedEventSink : public CAbstractEventSink
{
protected:
    CAbstractEventSink* m_pOwner;
    CCritSec m_cs;
    long m_lRef;
    bool m_bReleasing;

public:
    COwnedEventSink(CAbstractEventSink* pOwner);
    ~COwnedEventSink(){}

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    void Disconnect();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\evtools.cpp ===
//******************************************************************************
//
//  EVTOOLS.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <evtools.h>
#include <cominit.h>

//*****************************************************************************
//
//  Implementation:
//
//  This class contains a queue of event handles.  The top() one is always 
//  signalled --- it corresponds to the turn that is currently allowed to
//  execute.  Handles are added to the queue in GetInLine.  Handles are removed
//  from the queue in EndTurn, at which time the next handle in line is
//  signalled.  
//
//  m_pCurrentTurn contains the pointer to the turn that has returned from from
//  WaitForTurn, but not from EndTurn.  Note, that m_pCurrentTurn may be empty
//  even if a turn is scheduled to execute --- there is a gap between the time
//  when a turn's handle is signalled, and its WaitForTurn succeeds. 
//
//  However, it is guranteed that by the time a legitimate call to EndTurn is 
//  made, m_pCurrentTurn contains the pointer to the turn in question, at which
//  time it is reset to NULL.
//
//  An additional optimization is that if the same thread calls GetInLine
//  multiple times concurrently, we simply 
//
//*****************************************************************************

CExecLine::CExecLine() : m_pCurrentTurn(NULL), m_pLastIssuedTurn(NULL), 
                        m_dwLastIssuedTurnThreadId(0)
{
}

CExecLine::~CExecLine()
{
    // No need to do anything --- handles are closed by tokens
    // =======================================================
}

CExecLine::CTurn* CExecLine::GetInLine()
{
    CInCritSec ics(&m_cs);

    //
    // First, check if this thread was the guy who got the last turn
    // 

    if(m_pLastIssuedTurn && m_dwLastIssuedTurnThreadId == GetCurrentThreadId())
    {
        // 
        // It is us --- just reuse that turn and be done with it
        //

        m_pLastIssuedTurn->AddRef();
        return m_pLastIssuedTurn; 
    }
    
    //
    // Allocate a new turn
    // 

    CTurn* pTurn = new CTurn;
    if(pTurn == NULL)
        return NULL;

    if(!pTurn->Init())
    {
        ERRORTRACE((LOG_ESS, "Unable to initialize turn: %d\n", 
                GetLastError()));
        delete pTurn;
        return NULL;
    }

    //
    // Add its event to the queue
    // 
    
    try
    {
        m_qTurns.push_back(pTurn);
    }
    catch( CX_MemoryException )
    {
        return NULL;
    }

    //
    // Check if we are currently executing
    //

    if(m_qTurns.size() == 1)
    {
        //
        // Release first in line
        //

        if(!ReleaseFirst())
        {
            //
            // Something went horribly wrong
            // 

            ERRORTRACE((LOG_ESS, "Unable to release first turn: %d\n", 
                GetLastError()));

            m_qTurns.pop_front();
            delete pTurn;
            return NULL;
        }
    }

    //
    // Mark ourselves as the last issued turn
    //

    m_pLastIssuedTurn = pTurn;
    m_dwLastIssuedTurnThreadId = GetCurrentThreadId();
    return pTurn;
}

// assumes in m_cs and m_qTurns is not empty
BOOL CExecLine::ReleaseFirst()
{
    return SetEvent(m_qTurns.front()->GetEvent());
}


DWORD CExecLine::WaitForTurn(CTurn* pTurn, DWORD dwTimeout)
{
    // Wait for the turn event to be signaled
    // ======================================

    DWORD dwRes = WbemWaitForSingleObject(pTurn->GetEvent(), dwTimeout);

    {
        CInCritSec ics(&m_cs);

        if(dwRes == WAIT_OBJECT_0)
        {
            // Got it --- record this turn as executing
            // ========================================
            
            m_pCurrentTurn = pTurn;
        }
    }
        
    return dwRes;
}

BOOL CExecLine::EndTurn(CTurn* pTurn)
{
    CInCritSec ics(&m_cs);

    // Check that this is the running turn
    // ===================================

    if(pTurn != m_pCurrentTurn)
        return FALSE;

    m_pCurrentTurn = NULL;

    // Delete the turn object
    // ======================

    if(pTurn->Release() > 0)
    {
        //
        // This is not the last incarnation of this turn.  No further action is
        // required, as the same thread will call Wait and End again
        //

        return TRUE;
    }

    //
    // Remove the last issued turn if this is it
    //

    if(m_pLastIssuedTurn == pTurn)
    {
        m_pLastIssuedTurn = NULL;
        m_dwLastIssuedTurnThreadId = 0;
    }

    //
    // Pop its handle off the queue
    // 

    m_qTurns.pop_front();
    
    //
    // Signal the next one
    //

    if(!m_qTurns.empty())
        return ReleaseFirst();
    else
        return TRUE;
}

BOOL CExecLine::DiscardTurn(ACQUIRE CTurn* pTurn)
{
    CInCritSec ics(&m_cs);

    if(pTurn->Release() > 0)
    {
        // 
        // This is not the last incarnation of this turn. No further action is
        // required
        //

        return TRUE;
    }
    else
    {
        // if pTurn is going away, we'd better make sure that we don't try to reuse it...
        // HMH 4/12/99, RAID 48420
        if (pTurn == m_pLastIssuedTurn)
            m_pLastIssuedTurn = NULL;
    }
    

    //
    // Search for it in the queue
    // 

    BOOL bFound = FALSE;
    for(TTurnIterator it = m_qTurns.begin(); it != m_qTurns.end();)
    {
        if((*it) == pTurn)
        {
            //
            // erase it and continue
            //

            it = m_qTurns.erase(it);
            bFound = TRUE;
            break;
        }
        else
            it++;
    }

    if(!bFound)
        return FALSE;

    if(it == m_qTurns.begin() && it != m_qTurns.end())
    {
        //
        // Discarded turn was actually active --- signal the next one
        //

        ReleaseFirst();
    }

    return TRUE;
}

CExecLine::CTurn::CTurn() : m_hEvent(NULL), m_lRef(1)
{
}

BOOL CExecLine::CTurn::Init()
{
    m_dwOwningThreadId = GetCurrentThreadId();
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    return (m_hEvent != NULL);
}
    
long CExecLine::CTurn::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

long CExecLine::CTurn::Release()
{
    long l = InterlockedDecrement(&m_lRef);
    if(l == 0)
        delete this;
    return l;
}

CExecLine::CTurn::~CTurn()
{
    if(m_hEvent)
        CloseHandle(m_hEvent);
}

void* CExecLine::CTurn::operator new(size_t nSize)
{
    return CTemporaryHeap::Alloc(nSize);
}
void CExecLine::CTurn::operator delete(void* p)
{
    CTemporaryHeap::Free(p, sizeof(CExecLine::CTurn));
}




INTERNAL const SECURITY_DESCRIPTOR* GetSD( IWbemEvent* pEvent,ULONG* pcEvent )
{
    static long mstatic_lSdHandle = -1;
    HRESULT hres;

    //
    // Get the SD from the event
    //

    _IWmiObject* pEventEx = NULL;
    pEvent->QueryInterface(IID__IWmiObject, (void**)&pEventEx);
    CReleaseMe rm1(pEventEx);

    if(mstatic_lSdHandle == -1)
    {
        pEventEx->GetPropertyHandleEx(SECURITY_DESCRIPTOR_PROPNAME, 0, NULL,
                                &mstatic_lSdHandle);
    }

    const SECURITY_DESCRIPTOR* pSD = NULL;

    hres = pEventEx->GetArrayPropAddrByHandle(mstatic_lSdHandle, 0, pcEvent,
            (void**)&pSD);
    if(FAILED(hres) || pSD == NULL)
        return NULL;
    else
        return pSD;
}
    
HRESULT SetSD(IWbemEvent* pEvent, const SECURITY_DESCRIPTOR* pSD)
{
    HRESULT hres;

    VARIANT vSd;
    VariantInit(&vSd);
    CClearMe cm1(&vSd);

    long lLength = GetSecurityDescriptorLength((SECURITY_DESCRIPTOR*)pSD);

    V_VT(&vSd) = VT_ARRAY | VT_UI1;
    SAFEARRAYBOUND sab;
    sab.cElements = lLength;
    sab.lLbound = 0;
    V_ARRAY(&vSd) = SafeArrayCreate(VT_UI1, 1, &sab);
    if(V_ARRAY(&vSd) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    BYTE* abSd = NULL;
    hres = SafeArrayAccessData(V_ARRAY(&vSd), (void**)&abSd);
    if(FAILED(hres))
        return WBEM_E_OUT_OF_MEMORY;

    CUnaccessMe uam(V_ARRAY(&vSd));
    memcpy(abSd, pSD, lLength);

    // Put it into the consumer
    // ========================

    hres = pEvent->Put(SECURITY_DESCRIPTOR_PROPNAME, 0, &vSd, 0);
    return hres;
}



CTempMemoryManager CTemporaryHeap::mstatic_Manager;

/*
CTemporaryHeap::CHeapHandle CTemporaryHeap::mstatic_HeapHandle;

CTemporaryHeap::CHeapHandle::CHeapHandle()
{
    m_hHeap = HeapCreate(0, 0, 0);
}

CTemporaryHeap::CHeapHandle::~CHeapHandle()
{
    HeapDestroy(m_hHeap);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\evtools.h ===
//******************************************************************************
//
//  EVTOOLS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TOOLS__H_
#define __WMI_ESS_TOOLS__H_

#include <sync.h>
#include <deque>
#include <malloc.h>
#include <newnew.h>
#include <eventrep.h>
#include <wstlallc.h>

class CUpdateLockable
{
public:
    virtual HRESULT LockForUpdate() = 0;
    virtual HRESULT UnlockForUpdate() = 0;
};

class CInUpdate
{
protected:
    CUpdateLockable* m_p;
public:
    CInUpdate(CUpdateLockable* p) : m_p(p)
    {
        p->LockForUpdate();
    }
    ~CInUpdate()
    {
        m_p->UnlockForUpdate();
    }
};

template<class TLockable>
class CInLock
{
protected:
    TLockable* m_p;
public:
    CInLock(TLockable* p) : m_p(p)
    {
        //
        // Do not return until the lock is held!
        //

        while(FAILED(m_p->Lock())) Sleep(1000);
    }
    ~CInLock()
    {
        m_p->Unlock();
    }
};

class CExecLine
{
public:
    class CTurn;

    CExecLine();
    virtual ~CExecLine();

    CTurn* GetInLine();
    DWORD WaitForTurn(CTurn* pTurn, DWORD dwTimeout = INFINITE);
    BOOL EndTurn(ACQUIRE CTurn* pTurn);
    BOOL DiscardTurn(ACQUIRE CTurn* pTurn);

public:
    class CTurn
    {
    public:
    protected:
        long m_lRef;
        HANDLE m_hEvent;
        DWORD m_dwOwningThreadId; 

    protected:
        CTurn();
        ~CTurn();
        long AddRef();
        long Release();
        BOOL Init();

        INTERNAL HANDLE GetEvent() {return m_hEvent;}
        void* operator new(size_t nSize);
        void operator delete(void* p);
        
        friend CExecLine;
    };

    class CInTurn
    {
    protected:
        CExecLine* m_pLine;
        CTurn* m_pTurn;

    public:
        CInTurn(CExecLine* pLine, CTurn* pTurn) : m_pLine(pLine), m_pTurn(pTurn)
        {
            m_pLine->WaitForTurn(m_pTurn);
        }
        ~CInTurn()
        {
            m_pLine->EndTurn(m_pTurn);
        }
    };


protected:
    CCritSec m_cs;
    std::deque<CTurn*,wbem_allocator<CTurn*> > m_qTurns;
    typedef std::deque<CTurn*,wbem_allocator<CTurn*> >::iterator TTurnIterator;
    CTurn* m_pCurrentTurn;
    CTurn* m_pLastIssuedTurn;
    DWORD m_dwLastIssuedTurnThreadId;

protected:
    BOOL ReleaseFirst();
};

/*
class CTemporaryHeap
{
public:
    class CHeapHandle
    {
    protected:
        HANDLE m_hHeap;
    
    public:
        CHeapHandle();
        ~CHeapHandle();

        HANDLE GetHandle() {return m_hHeap;}
        void* Alloc(int nSize) {return HeapAlloc(m_hHeap, 0, nSize);}
        void Free(void* p) {HeapFree(m_hHeap, 0, p);}
        void Compact() {HeapCompact(m_hHeap, 0);}
    };
protected:

    static CHeapHandle mstatic_HeapHandle;

public:
    static void* Alloc(int nSize) {return mstatic_HeapHandle.Alloc(nSize);}
    static void Free(void* p) {mstatic_HeapHandle.Free(p);}
    static void Compact() {mstatic_HeapHandle.Compact();}
};
*/

class CTemporaryHeap
{
protected:

    static CTempMemoryManager mstatic_Manager;

public:
    static void* Alloc(int nSize) {return mstatic_Manager.Allocate(nSize);}
    static void Free(void* p, int nSize) {mstatic_Manager.Free(p, nSize);}
    static void Compact() {}
};

INTERNAL const SECURITY_DESCRIPTOR* GetSD(IWbemEvent* pEvent, ULONG* pcEvent);
HRESULT SetSD(IWbemEvent* pEvent, const SECURITY_DESCRIPTOR* pSD);
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\filter.cpp ===
//******************************************************************************
//
//  FILTER.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "filter.h"

CGenericFilter::CGenericFilter(CEssNamespace* pNamespace) 
    : CEventFilter(pNamespace), m_pTree(NULL), m_pAggregator(NULL),
        m_pProjector(NULL), m_NonFilteringSink(this)
{
}

//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
HRESULT CGenericFilter::Create(LPCWSTR wszLanguage, LPCWSTR wszQuery)
{
    if(wbem_wcsicmp(wszLanguage, L"WQL"))
    {
        ERRORTRACE((LOG_ESS, "Unable to construct event filter with unknown "
            "query language '%S'.  The filter is not active\n", wszLanguage));
        return WBEM_E_INVALID_QUERY_TYPE;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CGenericFilter::Prepare(CContextMetaData* pMeta, 
                                QL_LEVEL_1_RPN_EXPRESSION** ppExp)
{
    HRESULT hres;

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    if(*ppExp == NULL)
    {
        // Get the query text
        // ==================
    
        LPWSTR wszQuery, wszQueryLanguage;
        BOOL bExact;

        hres = GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, &pExp);
        if(FAILED(hres))
            return hres;
    
        if(!bExact)
            return WBEM_E_NOT_SUPPORTED;

        if(wbem_wcsicmp(wszQueryLanguage, L"WQL"))
            return WBEM_E_INVALID_QUERY_TYPE;
        delete [] wszQuery;
        delete [] wszQueryLanguage;
    }
    else
    {
        pExp = *ppExp;
    }

    // Figure out what types of events we eat
    // ======================================

    m_dwTypeMask = 
        CEventRepresentation::GetTypeMaskFromName(pExp->bsClassName);
    if(m_dwTypeMask == 0)
    {
        ERRORTRACE((LOG_ESS, "Unable to construct event filter with invalid "
            "class name '%S'.  The filter is not active\n", 
            pExp->bsClassName));
        return WBEM_E_INVALID_CLASS;
    }

    // Perform a cursory validity check
    // ================================

    _IWmiObject* pClass;
    hres = pMeta->GetClass(pExp->bsClassName, &pClass);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to activate event filter with invalid "
            "class name '%S' (error %X).  The filter is not active\n", 
            pExp->bsClassName, hres));
        if(*ppExp == NULL)
            delete pExp;

        if(hres == WBEM_E_NOT_FOUND)
            hres = WBEM_E_INVALID_CLASS;

        return hres;
    }
    CReleaseMe rm1(pClass);

    hres = pClass->InheritsFrom(L"__Event");
    if(hres != WBEM_S_NO_ERROR)
    {
        ERRORTRACE((LOG_ESS, "Unable to activate event filter with invalid "
            "class name '%S' --- it is not an Event Class.  The filter is not "
            "active\n", pExp->bsClassName));
        if(*ppExp == NULL)
            delete pExp;
        return WBEM_E_NOT_EVENT_CLASS;
    }

    *ppExp = pExp;
    
    return WBEM_S_NO_ERROR;
}
    

HRESULT CGenericFilter::GetReadyToFilter()
{
    HRESULT hres;
    CInUpdate iu(this);

    // Create meta data
    // ================

    CEssMetaData* pRawMeta = new CEssMetaData(m_pNamespace);
    if(pRawMeta == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CContextMetaData Meta(pRawMeta, GetCurrentEssContext());

    // Prepare
    // =======

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    hres = Prepare(&Meta, &pExp);
    if(FAILED(hres))
    {
        MarkAsTemporarilyInvalid(hres);
        return hres;
    }

    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm3(pExp);
    
    // Create new evaluator
    // ====================

    CEvalTree* pTree = new CEvalTree;
    if(pTree == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = pTree->CreateFromQuery(&Meta, pExp, 0);
    if(FAILED(hres))
    {
        LPWSTR wszQuery = pExp->GetText();
        ERRORTRACE((LOG_ESS, "Unable to activate event filter with invalid "
            "query '%S' (error %X).  The filter is not active\n", 
            wszQuery, hres));
        delete [] wszQuery;
        delete pTree;
        MarkAsTemporarilyInvalid(hres);
        return hres;
    }

    // Now, replace the originals with the newely created ones. This is done in
    // the inner critical section, blocking event delivery
    // ========================================================================

    CEvalTree* pTreeToDelete = NULL;
    {
        CInCritSec ics(&m_cs);
    
        pTreeToDelete = m_pTree;
        m_pTree = pTree;
    }
    
    // Delete the old versions
    // =======================
        
    delete pTreeToDelete;
    return WBEM_S_NO_ERROR;
}

HRESULT CGenericFilter::GetReady(LPCWSTR wszQuery, 
                                    QL_LEVEL_1_RPN_EXPRESSION* pExp)
{
    HRESULT hres;
    CInUpdate iu(this);

    // Create meta data
    // ================

    CEssMetaData* pRawMeta = new CEssMetaData(m_pNamespace);
    if(pRawMeta == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CContextMetaData Meta(pRawMeta, GetCurrentEssContext());

    // Prepare
    // =======

    hres = Prepare(&Meta, &pExp);
    if(FAILED(hres))
    {
        MarkAsTemporarilyInvalid(hres);
        return hres;
    }

    // Compute the aggregator
    // ======================

    CEventAggregator* pAggreg = NULL;
    if(pExp->bAggregated)
    {
        // Create new aggregator
        // =====================
    
        pAggreg = new CEventAggregator(m_pNamespace, &m_ForwardingSink);
        if(pAggreg == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        hres = pAggreg->SetQueryExpression(&Meta, pExp);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to activate aggregator for filter with"
                " invalid aggregation query (error %X).  The filter is not"
                " active\n", hres));
            delete pAggreg;
            MarkAsTemporarilyInvalid(hres);
            return hres;
        }
    }

    // Compute the projector
    // =====================

    CEventProjectingSink* pProjector = NULL;
    if(!pExp->bStar)
    {
        // Get the class definition
        // ========================

        _IWmiObject* pClass = NULL;
        hres = Meta.GetClass(pExp->bsClassName, &pClass);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Invalid class %S in event filter!\n", 
                pExp->bsClassName));
            delete pAggreg;

            if(hres == WBEM_E_NOT_FOUND)
                hres = WBEM_E_INVALID_CLASS;

            MarkAsTemporarilyInvalid(hres);
            return hres;
        }
        CReleaseMe rm1( pClass );
            
        // Create new projector, pointing it either to the aggregator or, if 
        // not aggregating, our forwarding sink
        // =================================================================

        CAbstractEventSink* pProjDest = NULL;
        if(pAggreg)
            pProjDest = pAggreg;
        else
            pProjDest = &m_ForwardingSink;

        pProjector = new CEventProjectingSink(pProjDest);
        if(pProjector == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        hres = pProjector->Initialize( pClass, pExp );
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to activate projector for filter with"
                " invalid query (error %X).  The filter is not active\n", 
                hres));
            delete pAggreg;
            delete pProjector;
            MarkAsTemporarilyInvalid(hres);
            return hres;
        }
    }

    // Now, replace the originals with the newely created ones. This is done in
    // the inner critical section, blocking event delivery
    // ========================================================================

    CEventAggregator* pAggregToDelete = NULL;
    CEventProjectingSink* pProjectorToDelete = NULL;
    {
        CInCritSec ics(&m_cs);
        
        //
        // TBD: do we want to copy the state (buckets) that were there in the
        // previous aggregator?  Well, if we do that, we should take care of
        // two things:
        // 1) What if the types of the variables have changed (class change)?
        // 2) Preserving the state of the bucket-emptying timer instructions. 
        //      Right now, we are not set up to do that, since those
        //      instructions mention the aggregator by name
        //
        // if(pAggreg && m_pAggregator)
        //     m_pAggregator->CopyStateTo(pAggreg); // no CS

        pAggregToDelete = m_pAggregator;
        m_pAggregator = pAggreg;

        pProjectorToDelete = m_pProjector;
        m_pProjector = pProjector;
    }
    
    // Delete the old versions
    // =======================
    
    if(pAggregToDelete)
        pAggregToDelete->Deactivate(true); // fire what's there
    if(pProjectorToDelete)
        pProjectorToDelete->Disconnect();

    MarkAsValid();
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
CGenericFilter::~CGenericFilter()
{
    if(m_pAggregator)
        m_pAggregator->Deactivate(false);
    if(m_pProjector)
        m_pProjector->Disconnect();

    delete m_pTree;
}

HRESULT CGenericFilter::Indicate(long lNumEvents, IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hres;

    // Parse and ready the tree
    // ========================

    hres = GetReadyToFilter();
    if(FAILED(hres))
        return hres;
    
    // Construct an array into which the matching events will be placed
    // ================================================================

    CTempArray<IWbemEvent*> apMatchingEvents;
    if(!INIT_TEMP_ARRAY(apMatchingEvents, lNumEvents))
        return WBEM_E_OUT_OF_MEMORY;

    long lMatchingCount = 0;

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < lNumEvents; i++)
    {
        hres = TestQuery(apEvents[i]);
        if(FAILED(hres))
        {
            // Hard failure: already logged
            // ============================

            hresGlobal = hres;
        }
        else if(hres == S_OK)
        {
            // Match
            // =====

            apMatchingEvents[lMatchingCount++] = apEvents[i];
        }
    }            

    // Deliver the new array either into the aggregator or the forwarder
    // =================================================================

    if(lMatchingCount > 0)
    {
        hres = NonFilterIndicate(lMatchingCount, apMatchingEvents, pContext);
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
HRESULT CGenericFilter::TestQuery(IWbemEvent* pEvent)
{
    HRESULT hres;
    CInCritSec ics(&m_cs);

    if(m_pTree == NULL)
        return S_FALSE;

    // Get its efficient interface
    // ===========================

    IWbemObjectAccess* pEventAccess = NULL;
    hres = pEvent->QueryInterface(IID_IWbemObjectAccess, (void**)&pEventAccess);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pEventAccess);
    
    // Run it through the evaluator
    // ============================
    
    CSortedArray aTrues;
    hres = m_pTree->Evaluate(pEventAccess, aTrues);
    if(FAILED(hres))
        return hres;

    if(aTrues.Size() > 0)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CGenericFilter::NonFilterIndicate( long lNumEvents, 
                                           IWbemEvent** apEvents,
                                           CEventContext* pContext)
{
    HRESULT hr;

    //
    // Delivery across this filter is subject to the owner of the filter
    // being allowed to see this event, per the SD that may be attached to
    // the context.  It is also subject to the SD on the filter allowing 
    // the event provider and event owner EXECUTE access as well.
    //

    for( int i=0; i < lNumEvents; i++ )
    {
        hr = AccessCheck( pContext, apEvents[i] );

        if ( FAILED(hr) )
        {
            DEBUGTRACE((LOG_ESS, "Rejecting an event targeted at filter "
                        "'%S' in '%S' for security reasons\n",
                        (LPCWSTR)(WString)GetKey(),
                        m_pNamespace->GetName()) );
            
            return WBEM_S_FALSE;
        }
    }

    //
    // Decide which route to take --- can be either an aggregator, or a 
    // projector, or just forward
    //

    CEventAggregator* pAggregator = NULL;
    CEventProjectingSink* pProjector = NULL;
    {
        CInCritSec ics(&m_cs);
        
        // 
        // Look for projector first --- if there, we use it, since aggregator
        // is chained behind it.
        //

        if(m_pProjector)
        {
            pProjector = m_pProjector;
            pProjector->AddRef();
        }
        else if(m_pAggregator)
        {
            pAggregator = m_pAggregator;
            pAggregator->AddRef();
        }
    }

    //
    // Take the route identified by a non-NULL pointer
    //

    if(pProjector)
    {
        CReleaseMe rm(pProjector);
        return pProjector->Indicate( lNumEvents, apEvents, pContext );
    }
    else if(pAggregator)
    {
        CReleaseMe rm(pAggregator);
        return pAggregator->Indicate( lNumEvents, apEvents, pContext );
    }
    else
    {
        return m_ForwardingSink.Indicate( lNumEvents, apEvents, pContext );
    }
}

HRESULT CGenericFilter::CNonFilteringSink::Indicate( long lNumEvents, 
                                                     IWbemEvent** apEvents,
                                                     CEventContext* pContext )
{
    return m_pOwner->NonFilterIndicate(lNumEvents, apEvents, pContext);
}

//******************************************************************************
//
//******************************************************************************

INTERNAL CEventFilter* CEventProjectingSink::GetEventFilter() 
{
    CInCritSec ics(&m_cs);

    if(m_pOwner)
        return m_pOwner->GetEventFilter();
    else 
        return NULL;
}

HRESULT CEventProjectingSink::Initialize( _IWmiObject* pClassDef, 
                                            QL_LEVEL_1_RPN_EXPRESSION* pExp)
{
    HRESULT hres;
    int i;

    // Extract the properties selected by the user.
    // ============================================

    CWStringArray awsPropList;
    for (i = 0; i < pExp->nNumberOfProperties; i++)
    {
        CPropertyName& PropName = pExp->pRequestedPropertyNames[i];
        hres = AddProperty(pClassDef, awsPropList, PropName);
        if(FAILED(hres))
            return hres;
    }

    // Do the same for all the aggregation properties
    // ==============================================

    for (i = 0; i < pExp->nNumAggregatedProperties; i++)
    {
        CPropertyName& PropName = pExp->pAggregatedPropertyNames[i];
        hres = AddProperty(pClassDef, awsPropList, PropName);
        if(FAILED(hres))
            return hres;
    }

    return pClassDef->GetClassSubset( awsPropList.Size(),
                                      awsPropList.GetArrayPtr(),
                                      &m_pLimitedClass );
}

HRESULT CEventProjectingSink::AddProperty(  IWbemClassObject* pClassDef,
                                            CWStringArray& awsPropList,
                                            CPropertyName& PropName)
{
    LPWSTR wszPrimaryName = PropName.m_aElements[0].Element.m_wszPropertyName;

    // Check for complexity
    // ====================

    if(PropName.GetNumElements() > 1)
    {
        // Complex --- make sure the property is an object
        // ===============================================

        CIMTYPE ct;
        if(FAILED(pClassDef->Get( wszPrimaryName, 0, NULL, &ct, NULL)) ||
            ct != CIM_OBJECT)
        {
            return WBEM_E_PROPERTY_NOT_AN_OBJECT;
        }
    }

    awsPropList.Add(wszPrimaryName);
    return WBEM_S_NO_ERROR;
}

HRESULT CEventProjectingSink::Indicate( long lNumEvents, 
                                        IWbemEvent** apEvents, 
                                        CEventContext* pContext)
{
    HRESULT hres = S_OK;
    CWbemPtr<CAbstractEventSink> pSink;

    // Construct an array into which the matching events will be placed
    // ================================================================

    CTempArray<IWbemEvent*> apProjectedEvents;
    
    if(!INIT_TEMP_ARRAY(apProjectedEvents, lNumEvents))
        return WBEM_E_OUT_OF_MEMORY;
    
    {
        CInCritSec ics(&m_cs);

        if ( m_pOwner == NULL )
        {
            return WBEM_S_FALSE;
        }

        //
        // Retrieve delivery sink while locked
        //

        pSink = m_pOwner;

        for(int i = 0; i < lNumEvents; i++)
        {
            // Project this instance
            // =====================
    
            CWbemPtr<_IWmiObject> pInst;
            hres = apEvents[i]->QueryInterface( IID__IWmiObject, 
                                                (void**)&pInst );
            if ( FAILED(hres) )
            {
                break;
            }

            //
            // we cannot project the instance if it is derived from 
            // the EventDroppedEvent class.  The reason for this is because
            // we can lose class and derivation information during the 
            // projection.  This information is needed later on to determine
            // if we need to raise EventDroppedEvents ( we don't raise 
            // EventDroppedEvents for dropped EventDroppedEvents ).  The 
            // reason why we do this check on the Indicate() and not during  
            // initialization is because the class from the query could be 
            // a base class of EVENT_DROP_CLASS.
            // 

            CWbemPtr<_IWmiObject> pNewInst;

            if ( pInst->InheritsFrom( EVENT_DROP_CLASS ) != WBEM_S_NO_ERROR )
            {  
                hres = m_pLimitedClass->MakeSubsetInst( pInst, &pNewInst );
            }
            else
            {
                hres = S_FALSE;
            }
    
            if( hres != WBEM_S_NO_ERROR )
            {
                // Oh well, just send the original
                // ===============================
    
                pNewInst = pInst;
                hres = S_OK;
            }

            pNewInst->AddRef();
            apProjectedEvents[i] = pNewInst;
        }            
    }

    if ( SUCCEEDED(hres) )
    {
        // Deliver the new array either into the aggregator or the forwarder
        // =================================================================
    
        hres = pSink->Indicate(lNumEvents, apProjectedEvents, pContext);
    }
    
    // Release them
    // ============

    for(int i = 0; i < lNumEvents; i++)
        apProjectedEvents[i]->Release();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\localloc.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\filter.h ===
//******************************************************************************
//
//  FILTER.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_ESS_FILTER__H_
#define __WBEM_ESS_FILTER__H_

#include "binding.h"
#include "aggreg.h"
#include <evaltree.h>


class CEventProjectingSink;
class CGenericFilter : public CEventFilter
{
protected:
    DWORD m_dwTypeMask; // immutable after creatioin
    
    CEvalTree* m_pTree;
    CEventAggregator* m_pAggregator;
    CEventProjectingSink* m_pProjector;

protected:
    HRESULT TestQuery(IWbemEvent* pEvent);

    class CNonFilteringSink : public CAbstractEventSink
    {
    protected:
        CGenericFilter* m_pOwner;
    
    public:
        CNonFilteringSink(CGenericFilter* pOwner) : m_pOwner(pOwner){}

        ULONG STDMETHODCALLTYPE AddRef() {return m_pOwner->AddRef();}
        ULONG STDMETHODCALLTYPE Release() {return m_pOwner->Release();}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents,
                            CEventContext* pContext);
        STDMETHOD(SetStatus)(long a , long b, BSTR c, IWbemClassObject* d)
            { return m_pOwner->SetStatus( a, b, c, d ); } 

        INTERNAL CEventFilter* GetEventFilter() {return m_pOwner;}
    } m_NonFilteringSink; // immutable

    friend CNonFilteringSink;

    HRESULT NonFilterIndicate(long lNumEvents, IWbemEvent** apEvents, 
                CEventContext* pContext);
    HRESULT Prepare(CContextMetaData* pMeta, QL_LEVEL_1_RPN_EXPRESSION** ppExp);
public:
    CGenericFilter(CEssNamespace* pNamespace);
    virtual ~CGenericFilter();

    HRESULT Create(LPCWSTR wszLanguage, LPCWSTR wszQuery);

    BOOL DoesNeedType(int nType) NOCS {return (m_dwTypeMask & (1 << nType));}
    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext);

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp) = 0;

    HRESULT GetReady(LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp);
    HRESULT GetReadyToFilter();

    CAbstractEventSink* GetNonFilteringSink() {return &m_NonFilteringSink;}
};

class CEventProjectingSink : public COwnedEventSink
{
protected:
    CWbemPtr<_IWmiObject> m_pLimitedClass;

public:
    CEventProjectingSink(CAbstractEventSink* pOwner) : 
        COwnedEventSink(pOwner){}
    HRESULT Initialize(_IWmiObject* pClass, QL_LEVEL_1_RPN_EXPRESSION* pExpr);
    ~CEventProjectingSink(){}

    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    INTERNAL CEventFilter* GetEventFilter();

protected:

    HRESULT AddProperty( IWbemClassObject* pClassDef, CWStringArray& awsPropList, 
                            CPropertyName& PropName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\ncevents.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events within ESS.
//
#include "precomp.h"
#include "NCEvents.h"

#define NUM_NC_EVENTS       NCE_InvalidIndex
#define MAX_BUFFER_SIZE     32000
#define SEND_LATENCY        100

static HANDLE g_hConnection;
HANDLE g_hNCEvents[NUM_NC_EVENTS];

LPCWSTR szEventSetup[NUM_NC_EVENTS * 2] =
{
    L"MSFT_WmiRegisterNotificationSink",
    L"Namespace!s! QueryLanguage!s! Query!s! Sink!I64u!",

    L"MSFT_WmiCancelNotificationSink",
    L"Namespace!s! QueryLanguage!s! Query!s! Sink!I64u!",

    L"MSFT_WmiEventProviderLoaded",
    L"Namespace!s! ProviderName!s!",

    L"MSFT_WmiEventProviderUnloaded",
    L"Namespace!s! ProviderName!s!",

    L"MSFT_WmiEventProviderNewQuery",
    L"Namespace!s! ProviderName!s! QueryLanguage!s! "
        L"Query!s! QueryId!u! Result!u!",

    L"MSFT_WmiEventProviderCancelQuery",
    L"Namespace!s! ProviderName!s! QueryId!u! Result!u!",

    L"MSFT_WmiEventProviderAccessCheck",
    L"Namespace!s! ProviderName!s! QueryLanguage!s! "
        L"Query!s! Sid!c[]! Result!u!",

    L"MSFT_WmiConsumerProviderLoaded",
    L"Namespace!s! ProviderName!s! Machine!s!",

    L"MSFT_WmiConsumerProviderUnloaded",
    L"Namespace!s! ProviderName!s! Machine!s!",

    L"MSFT_WmiConsumerProviderSinkLoaded",
    L"Namespace!s! ProviderName!s! Machine!s! Consumer!s!",

    L"MSFT_WmiConsumerProviderSinkUnloaded",
    L"Namespace!s! ProviderName!s! Machine!s! Consumer!s!",

    L"MSFT_WmiThreadPoolThreadCreated",
    L"ThreadId!u!",

    L"MSFT_WmiThreadPoolThreadDeleted",
    L"ThreadId!u!",

    L"MSFT_WmiFilterActivated",
    L"Namespace!s! Name!s! QueryLanguage!s! Query!s!",

    L"MSFT_WmiFilterDeactivated",
    L"Namespace!s! Name!s! QueryLanguage!s! Query!s!",
};

#define WMI_SELF_PROV_NAME   L"WMI Self-Instrumentation Event Provider"

BOOL InitNCEvents()
{
#ifdef USE_NCEVENTS
    BOOL bRet;

    g_hConnection =
        WmiEventSourceConnect(
            L"root\\cimv2",
            WMI_SELF_PROV_NAME,
            TRUE,
            MAX_BUFFER_SIZE,
            SEND_LATENCY,
            NULL,
            NULL);

    if (g_hConnection)
    {
        for (int i = 0; i < NUM_NC_EVENTS; i++)
        {
            g_hNCEvents[i] = 
                WmiCreateObjectWithFormat(
                    g_hConnection,
                    szEventSetup[i * 2],
                    WMI_CREATEOBJ_LOCKABLE,
                    szEventSetup[i * 2 + 1]);

            if (!g_hNCEvents[i])
                break;
        }

        bRet = i == NUM_NC_EVENTS;
    }
    else
        bRet = FALSE;

    return bRet;
#else
    return TRUE;
#endif
}

void DeinitNCEvents()
{
#ifdef USE_NCEVENTS
    for (int i = 0; i < NUM_NC_EVENTS; i++)
    {
        if (g_hNCEvents[i])
            WmiDestroyObject(g_hNCEvents[i]);
    }

    if (g_hConnection)
        WmiEventSourceDisconnect(g_hConnection);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\ncevents.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events within ESS.
//

#pragma once

#include "NCObjAPI.h"

BOOL InitNCEvents();
void DeinitNCEvents();

// Use this index with g_hNCEvents
enum NCE_INDEX
{
    MSFT_WmiRegisterNotificationSink,
    MSFT_WmiCancelNotificationSink,
    MSFT_WmiEventProviderLoaded,
    MSFT_WmiEventProviderUnloaded,
    MSFT_WmiEventProviderNewQuery,
    MSFT_WmiEventProviderCancelQuery,
    MSFT_WmiEventProviderAccessCheck,
    MSFT_WmiConsumerProviderLoaded,
    MSFT_WmiConsumerProviderUnloaded,
    MSFT_WmiConsumerProviderSinkLoaded,
    MSFT_WmiConsumerProviderSinkUnloaded,
    MSFT_WmiThreadPoolThreadCreated,
    MSFT_WmiThreadPoolThreadDeleted,
    MSFT_WmiFilterActivated,
    MSFT_WmiFilterDeactivated,
    
    NCE_InvalidIndex // This should always be the last one.
};

extern HANDLE g_hNCEvents[];

#ifdef USE_NCEVENTS
#define FIRE_NCEVENT                ::WmiSetAndCommitObject
#define IS_NCEVENT_ACTIVE(index)    ::WmiIsObjectActive(g_hNCEvents[index])
#else
#define FIRE_NCEVENT                1 ? (void)0 : ::WmiSetAndCommitObject
#define IS_NCEVENT_ACTIVE(index)    FALSE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\permbind.h ===
//******************************************************************************
//
//  PERMBIND.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_PERM_BINDING__H_
#define __WMI_ESS_PERM_BINDING__H_

#include "binding.h"
#include "fastall.h"

class CPermanentBinding : public CBinding
{
protected:
    static long mstatic_lConsumerHandle;
    static long mstatic_lFilterHandle;
    static long mstatic_lSynchronicityHandle;
    static long mstatic_lQosHandle;
    static long mstatic_lSlowDownHandle;
    static long mstatic_lSecureHandle;
    static long mstatic_lSidHandle;
    static bool mstatic_bHandlesInitialized;
protected:
    static HRESULT InitializeHandles( _IWmiObject* pBindingObj);
public:
    CPermanentBinding()
    {}
    HRESULT Initialize(IWbemClassObject* pBindingObj);
    static HRESULT ComputeKeysFromObject(IWbemClassObject* pBindingObj,
                                BSTR* pstrConsumer, BSTR* pstrFilter);
    static DELETE_ME INTERNAL PSID GetSidFromObject(IWbemClassObject* pObj);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\nsrep.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  NSREP.H
//
//  Represents the ESS functionality for a given namespace
//
//  Classes defined:
//
//      CEssNamespace
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//  1/6/97      a-levn      Updated to initialize TSS.
//
//=============================================================================
#ifndef __NSREP_ESS__H_
#define __NSREP_ESS__H_

#include "pragmas.h"
#include "binding.h"
#include "permfilt.h"
#include "permcons.h"
#include "tempfilt.h"
#include "tempcons.h"
#include "corefind.h"
#include "consprov.h"
#include "provreg.h"
#include "wbemtss.h"
#include "poller.h"
#include "essutils.h"
#include "clscache.h"
#include <map>
#include <set>

#define WMIESS_REPORT(X)

class CEss;
class CEssNamespace : public CUpdateLockable
{
protected:
    CEss* m_pEss;
    long m_lRef;
    PSECURITY_DESCRIPTOR m_pAdminOnlySD;
    DWORD m_cAdminOnlySD;

    //
    // protects level 1 members. These are members that can be used even
    // when level2 members are locked.
    //
    CCritSec m_csLevel1; 
    
    //
    // protects level 2 members. When both a level1 and level2 lock need to 
    // be aquired, the level2 lock MUST be obtained first.  This is a wbem cs
    // because we hold this lock across calls to core ( which can conceivably 
    // take longer than 2 minutes - the deadline for normal critical sections )
    //
    CWbemCriticalSection m_csLevel2;

    //
    // level 1 members 
    // 

    HANDLE m_hInitComplete;

    //
    // If events are signaled when we are in the unitialized state, then 
    // they are temporarily stored here.
    //
    CPointerArray<CEventRepresentation> m_aDeferredEvents;

    LPWSTR m_wszName;
    _IWmiProviderFactory* m_pProviderFactory;
    IWbemServices* m_pCoreSvc;
    IWbemServices* m_pFullSvc;
    IWbemInternalServices* m_pInternalCoreSvc;
    IWbemInternalServices* m_pInternalFullSvc;

    //
    // Level 2 members.
    // 

    BOOL m_bInResync;
    BOOL m_bStage1Complete;
    int m_cActive; 
    CBindingTable m_Bindings;
    CConsumerProviderCache m_ConsumerProviderCache;
    CEventProviderCache m_EventProviderCache;
    CPoller m_Poller;
    CEssClassCache m_ClassCache;
    CCoreEventProvider* m_pCoreEventProvider;

    CNtSid m_sidAdministrators;

    //
    // this structure maps tells us if we need to do anything for a provider
    // when a class changes.
    //
    typedef std::set<WString,WSiless,wbem_allocator<WString> > ProviderSet;
    typedef std::map<WString,ProviderSet,WSiless,wbem_allocator<ProviderSet> >
        ClassToProviderMap;
    ClassToProviderMap m_mapProviderInterestClasses;

    //
    // the state and init members are both level 1 and level2.  They can be 
    // read when the level1 lock is held.  They can only be modified when the
    // level2 and level1 locks are held.   
    //

    HRESULT m_hresInit;
    
    enum { 

        //
        // Initialization is Pending. Can service 
        // events from core in this state (though will be defferred ).
        // it is expected that Initialize() will be called
        // sometime in the near future.  We also can support limited ops 
        // while in this state.  Any operations that deal with event 
        // subsciptions or provider objects can be serviced.  Any ops that 
        // deal with event provider registrations must wait for initialization.
        //
        e_InitializePending, 

        //
        // Quiet - Initialization is not pending.  The namespace is known to
        // be empty of any ess related onjects.  Can service events in this 
        // state, but they are simply discarded.
        //
        e_Quiet, 

        //
        // We have loaded subscription objects.  All ess operations can be 
        // performed.  Events from core now can be processed.
        // 
        e_Initialized,
          
        //
        // Shutdown has been called.  All operations return error.
        //
        e_Shutdown 

    } m_eState; 

protected:
    class CConsumerClassDeletionSink : public CEmbeddedObjectSink<CEssNamespace>
    {
    public:
        CConsumerClassDeletionSink(CEssNamespace* pNamespace) :
            CEmbeddedObjectSink<CEssNamespace>(pNamespace){}

        STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    } m_ClassDeletionSink;
    friend CConsumerClassDeletionSink;

protected:
    inline void LogOp( LPCWSTR wszOp, IWbemClassObject* pObj );

    HRESULT EnsureInitPending();

    HRESULT CheckMonitor(IWbemClassObject* pPrevMonitorObj,
                                IWbemClassObject* pMonitorObj);
    HRESULT CheckEventFilter(IWbemClassObject* pPrevFilterObj,
                                IWbemClassObject* pFilterObj);
    HRESULT CheckEventConsumer(IWbemClassObject* pPrevConsumerObj,
                                IWbemClassObject* pConsumerObj);
    HRESULT CheckBinding(IWbemClassObject* pPrevBindingObj,
                                IWbemClassObject* pBindingObj);
    HRESULT CheckEventProviderRegistration(IWbemClassObject* pReg);
    HRESULT CheckTimerInstruction(IWbemClassObject* pInst);
    HRESULT ActOnSystemEvent(CEventRepresentation& Event, long lFlags);
    HRESULT HandleClassChange(LPCWSTR wszClassName, IWbemClassObject* pClass);
    HRESULT HandleClassCreation(LPCWSTR wszClassName,IWbemClassObject* pClass);
    HRESULT HandleConsumerClassDeletion(LPCWSTR wszClassName);
    HRESULT PrepareForResync();
    HRESULT ReactivateAllFilters();
    HRESULT CommitResync();

    HRESULT ReloadMonitor(ADDREF IWbemClassObject* pEventMonitorObj);
    HRESULT ReloadEventFilter(ADDREF IWbemClassObject* pEventFilterObj);
    HRESULT ReloadEventConsumer(READ_ONLY IWbemClassObject* pConsumerObj,
                                    long lFlags);
    HRESULT ReloadBinding(READ_ONLY IWbemClassObject* pBindingObj);
    HRESULT ReloadTimerInstruction(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT ReloadProvider(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT ReloadEventProviderRegistration(IWbemClassObject* pInstObj);
    HRESULT ReloadConsumerProviderRegistration(IWbemClassObject* pInstObj);

    HRESULT AddMonitor(ADDREF IWbemClassObject* pEventMonitorObj);
    HRESULT AddEventFilter(ADDREF IWbemClassObject* pEventFilterObj,
                            BOOL bInRestart = FALSE);
    HRESULT AddEventConsumer(READ_ONLY IWbemClassObject* pConsumerObj,
                            long lFlags,
                            BOOL bInRestart = FALSE);
    HRESULT AddBinding(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey,
                        READ_ONLY IWbemClassObject* pBindingObj);
    HRESULT AddBinding(IWbemClassObject* pBindingObj);
    HRESULT AddTimerInstruction(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT AddProvider(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT AddEventProviderRegistration(READ_ONLY IWbemClassObject* pInstObj);

    HRESULT RemoveMonitor(IWbemClassObject* pEventMonitorObj);
    HRESULT RemoveEventFilter(IWbemClassObject* pEventFilterObj);
    HRESULT RemoveEventConsumer(IWbemClassObject* pConsumerObj);
    HRESULT RemoveBinding(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey);
    HRESULT RemoveTimerInstruction(IWbemClassObject* pInstObj);
    HRESULT RemoveProvider(IWbemClassObject* pInstObj);
    HRESULT RemoveEventProviderRegistration(IWbemClassObject* pInstObj);
    HRESULT RemoveConsumerProviderRegistration(IWbemClassObject* pInstObj);

    HRESULT AssertBindings(IWbemClassObject* pEndpoint);
    HRESULT DeleteConsumerProvider(IWbemClassObject* pReg);

    HRESULT PerformSubscriptionInitialization();
    HRESULT PerformProviderInitialization();
    
    BOOL IsNeededOnStartup();
    
    HRESULT GetCurrentState(IWbemClassObject* pTemplate, 
                            IWbemClassObject** ppObj);

    HRESULT CheckSecurity(IWbemClassObject* pPrevObj,
                                            IWbemClassObject* pObj);

    HRESULT CheckSidForPrivilege( PSID sid );
    HRESULT EnsureSessionSid(IWbemClassObject* pPrevObj, CNtSid& ActingSid);
    HRESULT CheckOverwriteSecurity( IWbemClassObject* pPrevObj,
                                    CNtSid& ActingSid);
    HRESULT PutSidInObject(IWbemClassObject* pObj, CNtSid& Sid);
    HRESULT IsCallerAdministrator();
    HRESULT AttemptToActivateFilter(READ_ONLY CEventFilter* pFilter);
    HRESULT GetFilterEventNamespace(CEventFilter* pFilter,
                                    RELEASE_ME CEssNamespace** ppNamespace);

    void FireNCFilterEvent(DWORD dwIndex, CEventFilter *pFilter);

    CQueueingEventSink* GetQueueingEventSink( LPCWSTR wszSinkName );

    HRESULT ScheduleFirePostponed();

    ~CEssNamespace();
public:
    CEssNamespace(CEss* pEss);
    ULONG AddRef();
    ULONG Release();

    CEss* GetEss() { return m_pEss; }
    
    //
    // On return, namespace can be used for limited operations.  Events 
    // can be signaled ( though they may be defferred internally ) and 
    // operations dealing with subscriptions can be performed. 
    //
    HRESULT PreInitialize( LPCWSTR wszName );
        
    //
    // Performs initialization but does NOT transition state to Initialized.
    // This is done by calling MarkAsInitialized().  This allows a caller to 
    // atomically perform initalization of multiple namespaces.
    //
    HRESULT Initialize();
    
    //
    // Finishes loading event provider registrations and processes 
    // subcriptions. Transitions to FullyInitialized() state. 
    // 
    HRESULT CompleteInitialization();

    //
    // Transitions state to Initialized. 
    //
    void MarkAsInitialized( HRESULT hres );

    //
    // Transitions state to Initialize Pending if previously in the Quiet 
    // state.  Returns TRUE if transition was made.
    //
    BOOL MarkAsInitPendingIfQuiet();

    //
    // Waits for Initialization to complete. 
    // 
    HRESULT WaitForInitialization();
    
    HRESULT Park();
    HRESULT Shutdown();
    LPCWSTR GetName() {return m_wszName;}
    HRESULT GetNamespacePointer(RELEASE_ME IWbemServices** ppNamespace);
    HRESULT LoadEventProvider(LPCWSTR wszProviderName, 
                                         IWbemEventProvider** ppProv);
    HRESULT LoadConsumerProvider(LPCWSTR wszProviderName, 
                                         IUnknown** ppProv);
    HRESULT DecorateObject(IWbemClassObject* pObject);
    HRESULT ProcessEvent(CEventRepresentation& Event, long lFlags);
    HRESULT ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event );
    HRESULT SignalEvent( CEventRepresentation& Event, 
                         long lFlags, 
                         BOOL bAdminOnly = FALSE );

    HRESULT ValidateSystemEvent(CEventRepresentation& Event);

    void SetActive();
    void SetInactive();
    
    HRESULT ActivateFilter(READ_ONLY CEventFilter* pFilter);
    HRESULT DeactivateFilter(READ_ONLY CEventFilter* pFilter);

    //
    // public versions of register/remove notification sink.  Do NOT use 
    // these versions if calling from within ESS.  The reason is that these 
    // versions wait for initialization and lock the namespace which might 
    // cause deadlocks if called from within ESS.  We also don't want to 
    // generate self instrumentation events for internal calls.
    //
    HRESULT RegisterNotificationSink(
                            WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, 
                            long lFlags, WMIMSG_QOS_FLAG lQosFlags, 
                            IWbemContext* pContext, 
                            IWbemObjectSink* pSink );

    HRESULT RemoveNotificationSink( IWbemObjectSink* pSink );

    HRESULT ReloadProvider( long lFlags, LPCWSTR wszProvider );
    //
    // Internal versions of register/remove notification sink.  They do
    // not lock, wait for initialization, or fire self instrumentation events.
    // If calling these methods from within ess, specify bInternal as TRUE.
    // The pOwnerSid is used when access checks for the subscription should 
    // be performed based on a particular SID.  currently this is only used 
    // for cross-namespace subscriptions.
    //
    HRESULT InternalRegisterNotificationSink(
                            WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, 
                            long lFlags, WMIMSG_QOS_FLAG lQosFlags, 
                            IWbemContext* pContext, IWbemObjectSink* pSink,
                            bool bInternal, PSID pOwnerSid );
    HRESULT InternalRemoveNotificationSink(IWbemObjectSink* pSink);

    CWinMgmtTimerGenerator& GetTimerGenerator();
    CConsumerProviderCache& GetConsumerProviderCache() 
        {return m_ConsumerProviderCache;}

    DWORD GetProvidedEventMask(IWbemClassObject* pClass);

    HRESULT EnsureConsumerWatchInstruction();
    HRESULT InitializeTimerGenerator();
    HRESULT ScheduleDelivery(CQueueingEventSink* pDest);
    HRESULT RaiseErrorEvent(IWbemEvent* pEvent, BOOL bAdminOnly = FALSE );

    void IncrementObjectCount();
    void DecrementObjectCount();
    HRESULT AddSleepCharge(DWORD dwSleep);
    HRESULT AddCache();
    HRESULT RemoveCache();
    HRESULT AddToCache(DWORD dwAdd, DWORD dwMemberTotal, 
                        DWORD* pdwSleep = NULL);
    HRESULT RemoveFromCache(DWORD dwRemove);

    HRESULT LockForUpdate();
    HRESULT UnlockForUpdate();
    bool IsShutdown() { return m_eState == e_Shutdown; }

    HRESULT GetProviderNamespacePointer(IWbemServices** ppServices);
    HRESULT GetClass( LPCWSTR wszClassName, _IWmiObject** ppClass)
        { return m_ClassCache.GetClass(wszClassName, GetCurrentEssContext(), 
                                        ppClass);}
    HRESULT GetClassFromCore(LPCWSTR wszClassName, _IWmiObject** ppClass);
    HRESULT GetInstance(LPCWSTR wszPath, _IWmiObject** ppInstance);
    HRESULT GetDbInstance(LPCWSTR wszDbKey, _IWmiObject** ppInstance);
    HRESULT CreateInstanceEnum(LPCWSTR wszClass, long lFlags, 
                                IWbemObjectSink* pSink);
    HRESULT ExecQuery(LPCWSTR wszQuery, long lFlags, IWbemObjectSink* pSink);
    
    
    CNtSid& GetAdministratorsSid() {return m_sidAdministrators;}
    HRESULT GetToken(PSID pSid, IWbemToken** ppToken);
    
       
    HRESULT RegisterFilterForAllClassChanges(CEventFilter* pFilter,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr);
    HRESULT RegisterSinkForAllClassChanges(IWbemObjectSink* pSink,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr);
    HRESULT RegisterSinkForClassChanges(IWbemObjectSink* pSink,
                                                    LPCWSTR wszClassName);
    HRESULT UnregisterFilterFromAllClassChanges(CEventFilter* pFilter);
    HRESULT UnregisterSinkFromAllClassChanges(IWbemObjectSink* pSink);
    
    HRESULT RegisterProviderForClassChanges( LPCWSTR wszClassName, 
                                             LPCWSTR wszProvName );
    
    HRESULT FirePostponedOperations();
    HRESULT PostponeRelease(IUnknown* pUnk);
    
    static PSID GetSidFromObject(IWbemClassObject* pObj);

    BOOL DoesThreadOwnNamespaceLock();

    void DumpStatistics(FILE* f, long lFlags);
   
    friend class CEss;
    friend class CEssMetaData;
    friend class CFilterEnumSink;
    friend class CConsumerEnumSink;
    friend class CBindingEnumSink;
    friend class CMonitorEnumSink;
    friend class CInResync;
    friend class CAssertBindingsSink;
    friend class CFirePostponed;
};

class CInResync
{
protected:
    CEssNamespace* m_pNamespace;

public:

    CInResync(CEssNamespace* pNamespace) : m_pNamespace(pNamespace)
    {
        m_pNamespace->PrepareForResync();
    }

    void Commit()
    {
        if ( m_pNamespace != NULL )
        {
            m_pNamespace->ReactivateAllFilters();
            m_pNamespace->CommitResync();
            m_pNamespace = NULL;
        }
    }

    ~CInResync()
    {
        try
        {
            Commit();
        }
        catch( ... )
        {
        }       
    }
};

//
// The IWbemMetadata pointers are unmarshaled out when
// an external client calls RegisterProxy with an IWbemFilterProxy that is a COM-Proxy
// since a CStdIdentity wrapping them will be created, we need to keep the DLL alive
//

extern CLifeControl * g_pLifeControl;

class CEssMetaData : public CMetaData
{
protected:
    CEssNamespace* m_pNamespace;
    CLifeControl * m_pControl;
public:
    CEssMetaData(CEssNamespace* pNamespace):
    	m_pControl(g_pLifeControl),
    	m_pNamespace(pNamespace)
    {
        m_pControl->ObjectCreated(this);
    };
    ~CEssMetaData()
    {
        m_pControl->ObjectDestroyed(this);
    };

    virtual HRESULT GetClass( LPCWSTR wszName, 
                              IWbemContext* pContext,
                              _IWmiObject** ppClass );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\permbind.cpp ===
//******************************************************************************
//
//  PERMBIND.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include <permbind.h>
#include <permfilt.h>

long CPermanentBinding::mstatic_lConsumerHandle = 0;
long CPermanentBinding::mstatic_lFilterHandle = 0;
long CPermanentBinding::mstatic_lQosHandle = 0;
long CPermanentBinding::mstatic_lSynchronicityHandle = 0;
long CPermanentBinding::mstatic_lSlowDownHandle = 0;
long CPermanentBinding::mstatic_lSecureHandle = 0;
long CPermanentBinding::mstatic_lSidHandle = 0;
bool CPermanentBinding::mstatic_bHandlesInitialized = false;

// static 
HRESULT CPermanentBinding::InitializeHandles( _IWmiObject* pBindingObj)
{
    if(mstatic_bHandlesInitialized)
        return S_FALSE;

    CIMTYPE ct;
    pBindingObj->GetPropertyHandle(CONSUMER_ROLE_NAME, &ct, 
                                    &mstatic_lConsumerHandle);
    pBindingObj->GetPropertyHandle(FILTER_ROLE_NAME, &ct, 
                                    &mstatic_lFilterHandle);
    pBindingObj->GetPropertyHandle(BINDING_SYNCHRONICITY_PROPNAME, &ct, 
                                    &mstatic_lSynchronicityHandle);
    pBindingObj->GetPropertyHandle(BINDING_QOS_PROPNAME, &ct, 
                                    &mstatic_lQosHandle);
    pBindingObj->GetPropertyHandle(BINDING_SECURE_PROPNAME, &ct, 
                                    &mstatic_lSecureHandle);
    pBindingObj->GetPropertyHandle(BINDING_SLOWDOWN_PROPNAME, &ct, 
                                    &mstatic_lSlowDownHandle);
    pBindingObj->GetPropertyHandleEx(OWNER_SID_PROPNAME, 0, &ct, 
                                          &mstatic_lSidHandle);

    mstatic_bHandlesInitialized = true;
    return S_OK;
}

HRESULT CPermanentBinding::Initialize( IWbemClassObject* pObj )
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pBindingObj;

    hres = pObj->QueryInterface(IID__IWmiObject, (void**)&pBindingObj );
    
    if (FAILED(hres))
        return hres;
    
    hres = InitializeHandles(pBindingObj);
    if(FAILED(hres))
        return hres;

    long lSize;

    //
    // Read the Qos property.
    //

    hres = pBindingObj->ReadPropertyValue( mstatic_lQosHandle, 
                                           sizeof(DWORD), 
                                           &lSize, 
                                           (BYTE*)&m_dwQoS );
    if(FAILED(hres))
        return hres;
    
    if ( hres != WBEM_S_NO_ERROR)
    {
        m_dwQoS = WMIMSG_FLAG_QOS_EXPRESS; // default.
    }
#ifdef __WHISTLER_UNCUT
    if ( m_dwQoS > WMIMSG_FLAG_QOS_XACT )
    {
        ERRORTRACE((LOG_ESS, "Invalid QoS of %d is used in a binding. "
                             "Setting to default.\n", m_dwQoS));

        m_dwQoS = WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( m_dwQoS == WMIMSG_FLAG_QOS_XACT )
    {
        ERRORTRACE((LOG_ESS, "XACT QoS is not a supported qos for binding. "
                             "Downgrading to Guaranteed Delivery.\n"));

        m_dwQoS = WMIMSG_FLAG_QOS_GUARANTEED;
    }
#else
    if ( m_dwQoS > WMIMSG_FLAG_QOS_EXPRESS )
    {
        ERRORTRACE((LOG_ESS, "Invalid QoS of %d is used in a binding.", m_dwQoS));
        return WBEM_E_INVALID_OBJECT;
    }
#endif
 
    //
    // Read the synchronousness property - for backwards compatibility 
    // Always overrides any Qos setting.
    // 

    VARIANT_BOOL bTemp;
    hres = pBindingObj->ReadPropertyValue(mstatic_lSynchronicityHandle, 
        sizeof(VARIANT_BOOL), &lSize, (BYTE*)&bTemp);

    if(FAILED(hres))
        return hres;
    
    if( hres == WBEM_S_NO_ERROR && bTemp == VARIANT_TRUE )
    {
        m_dwQoS = WMIMSG_FLAG_QOS_SYNCHRONOUS;
    }

    // Read security property
    // ======================

    hres = pBindingObj->ReadPropertyValue(mstatic_lSecureHandle, 
        sizeof(VARIANT_BOOL), &lSize, (BYTE*)&bTemp);

    if(FAILED(hres))
        return hres;

    if(hres != WBEM_S_NO_ERROR)
        m_bSecure = FALSE;
    else 
        m_bSecure =  (bTemp != 0);

    // Read "slow down" property
    // =========================

    hres = pBindingObj->ReadPropertyValue(mstatic_lSlowDownHandle, 
        sizeof(VARIANT_BOOL), &lSize, (BYTE*)&bTemp);

    if(FAILED(hres))
        return hres;

    if(hres != WBEM_S_NO_ERROR)
        m_bSlowDown = FALSE;
    else 
        m_bSlowDown =  (bTemp != 0);

    return WBEM_S_NO_ERROR;
}

HRESULT CPermanentBinding::ComputeKeysFromObject( IWbemClassObject* pObj,
                                                  BSTR* pstrConsumer, 
                                                  BSTR* pstrFilter )
{
    HRESULT hres;
    CWbemPtr<_IWmiObject> pBindingObj;

    hres = pObj->QueryInterface(IID__IWmiObject, (void**)&pBindingObj );
    
    if ( hres != S_OK)
    {
        return NULL;
    }
    
    InitializeHandles(pBindingObj);

    // Read filter path
    // ================

    ULONG ulFlags;
    CCompressedString* pcsFilter;

    hres = pBindingObj->GetPropAddrByHandle( mstatic_lFilterHandle,
                                             WMIOBJECT_FLAG_ENCODING_V1,
                                             &ulFlags,
                                             (void**)&pcsFilter );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    BSTR strFilterPath = pcsFilter->CreateBSTRCopy();
    if(strFilterPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strFilterPath);

    // Construct its key
    // =================

    BSTR strFilter = CPermanentFilter::ComputeKeyFromPath(strFilterPath);
    if(strFilter == NULL)
        return WBEM_E_INVALID_OBJECT_PATH;

    // Read consumer path
    // ==================

    CCompressedString* pcsConsumer;

    hres = pBindingObj->GetPropAddrByHandle( mstatic_lConsumerHandle,
                                             WMIOBJECT_FLAG_ENCODING_V1,
                                             &ulFlags,
                                             (void**)&pcsConsumer );
    if( hres != S_OK )
    {
        SysFreeString(strFilter);
        return WBEM_E_INVALID_OBJECT;
    }

    *pstrConsumer = pcsConsumer->CreateBSTRCopy();

    if(*pstrConsumer == NULL)
    {
        SysFreeString(strFilter);
        return WBEM_E_OUT_OF_MEMORY;
    }

    *pstrFilter = strFilter;

    return WBEM_S_NO_ERROR;
}

INTERNAL DELETE_ME PSID 
CPermanentBinding::GetSidFromObject(IWbemClassObject* pObj)
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pBindingObj;

    hres = pObj->QueryInterface(IID__IWmiObject, (void**)&pBindingObj );
    
    if ( hres != S_OK)
    {
        return NULL;
    }

    InitializeHandles(pBindingObj);

    PSID pAddr;
    ULONG ulNumElements;

    hres = pBindingObj->GetArrayPropAddrByHandle( mstatic_lSidHandle,
                                                  0,
                                                  &ulNumElements,
                                                  &pAddr );
    if ( hres != S_OK )
    {
        return NULL;
    }

    //
    // we copy the SID here because the SID that is returned might be 
    // unaligned.  To avoid having the caller deal with these issues, we 
    // just copy the sid into a buffer that is guaranteed to be aligned.
    //

    PBYTE pSid = new BYTE[ulNumElements];
    
    if ( pSid != NULL )
    {
        memcpy( pSid, pAddr, ulNumElements );
    }

    return pSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\nsrep.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  NSREP.CPP
//
//  See nsrep.h for documentation
//
//  History:
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "esssink.h"
#include "permbind.h"
#include "aggreg.h"
#include "persistcfg.h"
#include "WinMgmtR.h"
#include <ql.h>
#include <cominit.h>
#include <genutils.h>
#include "NCEvents.h" // For the non-COM event stuff
#include <tempbind.h>
#include <wbemutil.h>
#include <sddl.h>
#include <helper.h>

long g_lNumNamespaces = 0;
long g_lNumInternalTempSubscriptions = 0;
long g_lNumTempSubscriptions = 0;

#define ENSURE_INITIALIZED \
    hres = EnsureInitPending(); \
    if ( FAILED(hres) ) \
        return hres; \
    hres = WaitForInitialization(); \
    if ( FAILED(hres) ) \
        return hres; \
    CInUpdate iu(this); \
    if ( m_eState == e_Shutdown ) \
        return WBEM_E_SHUTTING_DOWN;

// The use of this pointer to initialize parent class is valid in this context
#pragma warning(disable : 4355) 

class CEnumSink : public CObjectSink
{
protected:
    CEssNamespace* m_pNamespace;
    HANDLE m_hEvent;
    CEssThreadObject* m_pThreadObj;

public:
    CEnumSink(CEssNamespace* pNamespace) 
        : m_pNamespace(pNamespace), 
            m_hEvent(CreateEvent(NULL, FALSE, FALSE, NULL)),
            m_pThreadObj(GetCurrentEssThreadObject())
    {}
    ~CEnumSink(){SetEvent(m_hEvent);}

    void ReleaseAndWait()
    {
        HANDLE h = m_hEvent;
        Release();
        WaitForSingleObject(h, INFINITE);
        CloseHandle(h);
    }
    virtual HRESULT Process(IWbemClassObject* pObj) = 0;
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        SetConstructedEssThreadObject(m_pThreadObj);
        for(int i = 0; i < lNumObjects; i++)
            Process(apObjects[i]);

        return S_OK;
    }
    STDMETHOD(SetStatus)(long, HRESULT, BSTR, IWbemClassObject*)
    {
        return S_OK;
    }
};
    
class CFilterEnumSink : public CEnumSink
{
public:
    CFilterEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddEventFilter(pObj, TRUE);
    }
};

class CConsumerEnumSink : public CEnumSink
{
public:
    CConsumerEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddEventConsumer(pObj, 0, TRUE);
    }
};

class CBindingEnumSink : public CEnumSink
{
public:
    CBindingEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddBinding(pObj);
    }
};


class CPostponedReleaseRequest : public CPostponedRequest
{
protected:
    IUnknown* m_pUnk;
public:
    CPostponedReleaseRequest(IUnknown* pToRelease) : m_pUnk(pToRelease)
    {
        try 
        {
            if(m_pUnk)
                m_pUnk->AddRef();
        }
        catch(...)
        {
        }
    }
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        try
        {
            if(m_pUnk)
                m_pUnk->Release();
        }
        catch(...)
        {
        }
        return WBEM_S_NO_ERROR;
    }
    ~CPostponedReleaseRequest()
    {
        try
        {
            if(m_pUnk)
                m_pUnk->Release();
        }
        catch(...)
        {
        }
    }
};

class CPostponedRegisterNotificationSinkRequest : public CPostponedRequest
{
protected:
   
    WString m_wsQuery;
    WString m_wsQueryLanguage;
    DWORD m_lFlags;
    DWORD m_dwQosFlags;
    CWbemPtr<IWbemObjectSink> m_pSink;
    CWbemPtr<CEssNamespace> m_pNamespace;
    CNtSid m_OwnerSid;

public:

    HRESULT SetRegistration( CEssNamespace* pNamespace,
                             LPCWSTR wszQueryLanguage,
                             LPCWSTR wszQuery,
                             long lFlags,
                             DWORD dwQosFlags,
                             IWbemObjectSink* pSink,
                             PSID pOwnerSid )
    {
        m_pSink = pSink;
        m_lFlags = lFlags;
        m_dwQosFlags = dwQosFlags;
        m_pNamespace = pNamespace;

        try 
        {
            m_wsQuery = wszQuery;
            m_wsQueryLanguage = wszQueryLanguage;
            m_OwnerSid = CNtSid(pOwnerSid);
        }
        catch( CX_MemoryException )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_NO_ERROR;
    }

    HRESULT Execute( CEssNamespace* pNamespace )
    {
        HRESULT hr;

        //
        // we must set up a new thread object and then restore the 
        // old one where we're done.  Reason for this is that we don't 
        // want our call into the other namespace to affect the postponed 
        // list of this one.
        //
        CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();
        SetCurrentEssThreadObject(NULL);

        if ( GetCurrentEssThreadObject() != NULL )
        {
            {
                CInUpdate iu( m_pNamespace );

                if ( !m_pNamespace->IsShutdown() )
                {
                    hr = m_pNamespace->InternalRegisterNotificationSink( 
                        m_wsQueryLanguage,
                        m_wsQuery,
                        m_lFlags,
                        WMIMSG_QOS_FLAG(m_dwQosFlags),
                        NULL,
                        m_pSink, 
                        TRUE,
                        m_OwnerSid.GetPtr() );                    
                }
                else
                {
                    hr = WBEM_E_SHUTTING_DOWN;
                }
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_pNamespace->FirePostponedOperations();
            }
            else
            {
                m_pNamespace->FirePostponedOperations();
            }

            delete GetCurrentEssThreadObject();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        SetConstructedEssThreadObject( pOldThreadObject );

        return hr;
    }
};

class CPostponedRemoveNotificationSinkRequest : public CPostponedRequest
{
protected:
   
    CWbemPtr<IWbemObjectSink> m_pSink;
    CWbemPtr<CEssNamespace> m_pNamespace;

public:

    CPostponedRemoveNotificationSinkRequest( CEssNamespace* pNamespace,
                                             IWbemObjectSink* pSink ) 
     : m_pSink( pSink ), m_pNamespace( pNamespace ) { }
    
    HRESULT Execute( CEssNamespace* pNamespace )
    {
        HRESULT hr;

        //
        // we must set up a new thread object and then restore the 
        // old one where we're done.  Reason for this is that we don't 
        // want our call into the other namespace to affect the postponed 
        // list of this one.
        //
        CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();
        SetCurrentEssThreadObject(NULL);

        if ( GetCurrentEssThreadObject() != NULL )
        {
            {
                CInUpdate iu( m_pNamespace );
                
                if ( !m_pNamespace->IsShutdown() )
                {
                    hr = m_pNamespace->InternalRemoveNotificationSink(m_pSink);
                }
                else
                {
                    hr = WBEM_E_SHUTTING_DOWN;
                }
            }

            if ( SUCCEEDED(hr) )
            {
                hr = m_pNamespace->FirePostponedOperations();
            }
            else
            {
                m_pNamespace->FirePostponedOperations();
            }

            delete GetCurrentEssThreadObject();
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        SetConstructedEssThreadObject( pOldThreadObject );

        return hr;
    }
};


class CFirePostponed : public CExecRequest
{
protected:
    CEssNamespace* m_pNamespace;
    CEssThreadObject* m_pThreadObj;
public:
    CFirePostponed(CEssNamespace* pNamespace, CEssThreadObject* pThreadObj)
        : m_pNamespace(pNamespace), m_pThreadObj(pThreadObj)
    {
        m_pNamespace->AddRef();
    }
    ~CFirePostponed()
    {
        m_pNamespace->Release();
        delete m_pThreadObj;
    }

    HRESULT Execute()
    {
        SetConstructedEssThreadObject(m_pThreadObj);
        m_pNamespace->FirePostponedOperations();
        ClearCurrentEssThreadObject();
        return WBEM_S_NO_ERROR;
    }
};


//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
CEssNamespace::CEssNamespace(CEss* pEss) : 
            m_ClassDeletionSink(this), m_bInResync(FALSE), 
            m_Bindings(this), m_hInitComplete(INVALID_HANDLE_VALUE),
            m_EventProviderCache(this), m_Poller(this), 
            m_ConsumerProviderCache(this), m_hresInit(WBEM_E_CRITICAL_ERROR),
            m_ClassCache(this), m_eState(e_Quiet), m_pCoreEventProvider(NULL),
            m_pEss(pEss), m_wszName(NULL), m_pCoreSvc(NULL), m_pFullSvc(NULL),
            m_lRef(0), m_pInternalCoreSvc(NULL), m_pInternalFullSvc(NULL),
            m_pProviderFactory(NULL), m_bStage1Complete(FALSE),
            m_pAdminOnlySD(NULL), m_cAdminOnlySD(0)
{
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    g_lNumNamespaces++;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        m_sidAdministrators = CNtSid(pRawSid);
        // We're done with this
        FreeSid( pRawSid );
    }
}

ULONG CEssNamespace::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CEssNamespace::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//
// this function is intended to be called in the same control path as
// the one which constructs the namespace object.  Any initialization that 
// cannot be defferred is done here.  
//  
HRESULT CEssNamespace::PreInitialize( LPCWSTR wszName )
{
    HRESULT hres;

    m_wszName = new WCHAR[wcslen(wszName)+1];
    
    if(m_wszName == NULL)
    {
        hres = WBEM_E_OUT_OF_MEMORY;
        return hres;
    }

    StringCchCopyW( m_wszName, wcslen(wszName)+1, wszName );

    //
    // create the event that will be used to signal any threads waiting 
    // for initialization to finish.
    //

    m_hInitComplete = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( NULL == m_hInitComplete )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // create admin only SD for raising core events that are AdminOnly.
    //
    static LPCWSTR wszAdminOnlyString = L"O:BAG:BAD:(A;;0x40;;;BA)";

    if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
        wszAdminOnlyString,
        SDDL_REVISION_1, 
        &m_pAdminOnlySD,
        &m_cAdminOnlySD ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Obtain repository only service. This is used for acessing all
    // static ess objects.
    //

    hres = m_pEss->GetNamespacePointer( m_wszName, TRUE, &m_pCoreSvc );

    if(FAILED(hres))
    {
        return WBEM_E_INVALID_NAMESPACE; // not there anymore!
    }

    hres = m_pCoreSvc->QueryInterface( IID_IWbemInternalServices,
                                       (void**)&m_pInternalCoreSvc );
    if(FAILED(hres))
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Obtain full service.  This is used accessing class objects 
    // ( which may involve accessing class providers. 
    //

    hres = m_pEss->GetNamespacePointer( m_wszName, FALSE, &m_pFullSvc );

    if(FAILED(hres))
    {
        return WBEM_E_INVALID_NAMESPACE; // not there anymore!
    }

    hres = m_pFullSvc->QueryInterface( IID_IWbemInternalServices,
                                       (void**)&m_pInternalFullSvc );
    if(FAILED(hres))
    {
        return WBEM_E_CRITICAL_ERROR;
    }
   
    //
    // Get provider factory
    //

    hres = m_pEss->GetProviderFactory( m_wszName, 
                                       m_pFullSvc, 
                                       &m_pProviderFactory);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "No provider factory in %S: 0x%X\n", 
            m_wszName, hres));
    }

    //
    // we want to ensure that core stays loaded between the PreInitialize()
    // call and the Initialize() call.  This is only ever an issue when the
    // Initialize() call is defferred.  Reason to ensure this is because we
    // must keep core loaded when we have permanent subscriptions.  If we 
    // haven't initialized yet, then we don't know if we have any.  AddRef()  
    // core here and will then decrement in Initialize() to ensure this.
    // 
    IncrementObjectCount();

    //
    // Namespace always starts out in the Quiet state.  Caller must make 
    // a MarkAsInitPendingIfQuiet() call if they are going to schedule 
    // initialization.
    //

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::EnsureInitPending()
{
    {
        CInCritSec ics(&m_csLevel1);

        if ( m_eState != e_Quiet )
        {
            return WBEM_S_FALSE;
        }
    }

    CWbemPtr<CEssNamespace> pNamespace;
    return m_pEss->GetNamespaceObject( m_wszName, TRUE, &pNamespace );
}

BOOL CEssNamespace::MarkAsInitPendingIfQuiet() 
{
    CInCritSec ics( &m_csLevel1 );

    if ( m_eState != e_Quiet )
    {
        return FALSE;
    }

    m_eState = e_InitializePending;
    
    return TRUE;
};

HRESULT CEssNamespace::Initialize()
{
    HRESULT hres;

    DEBUGTRACE((LOG_ESS,"Initializing namespace %S\n", m_wszName ));

    //
    // need to modify level2 members. Grab namespace lock.
    //

    {
        CInUpdate iu(this);

        {
            CInCritSec ics( &m_csLevel1 );

            if ( m_eState == e_Shutdown )
            {
                return WBEM_E_SHUTTING_DOWN;
            }
            
            _DBG_ASSERT( m_eState == e_InitializePending );
        }

        //
        // Load and process subscription objects 
        // 

        hres = PerformSubscriptionInitialization();
    }

    //
    // execute postponed operations outside of namespace lock.
    // if some of them fail to execute, it doesn't mean that the namespace
    // can't be initialized.  just log the error.
    //

    HRESULT hres2 = FirePostponedOperations();

    if ( FAILED(hres2) )
    {
        ERRORTRACE((LOG_ESS,"Failed to execute postponed operations when "
                    "performing initialization in namespace %S. HR=0x%x\n", 
                    m_wszName, hres2));
    } 

    return hres;
}

HRESULT CEssNamespace::CompleteInitialization()
{
    HRESULT hres;

    DEBUGTRACE((LOG_ESS,"Completing Initialization for namespace %S\n",
                m_wszName));

    //
    // need to modify level2 members. Grab namespace lock.
    //

    {
        CInUpdate iu(this);

        //
        // stage 1 of initialization really isn't complete until we grab the 
        // lock to perform stage 2.  
        // 
        m_bStage1Complete = TRUE;

        {
            CInCritSec ics( &m_csLevel1 );

            if ( m_eState == e_Shutdown )
            {
                return WBEM_E_SHUTTING_DOWN;
            }

            _DBG_ASSERT( m_eState == e_InitializePending );
        }

        //
        // load and process all objects that deal with event providers.
        //

        hres = PerformProviderInitialization();
    }


    //
    // execute postponed operations outside of namespace lock.
    // if some of them fail to execute, it doesn't mean that the namespace
    // can't be initialized.  just log the error.
    //

    HRESULT hres2 = FirePostponedOperations();

    if ( FAILED(hres2) )
    {
        ERRORTRACE((LOG_ESS,"Failed to execute postponed operations when "
                    "completing initialization in namespace %S. HR=0x%x\n", 
                    m_wszName, hres2));
    } 

    return hres;
}
    
void CEssNamespace::MarkAsInitialized( HRESULT hres )
{
    //
    // we need to grab the level1 critsec here because we're going to be
    // modifying the state of the namespace and because we're going to be 
    // using the defferred events list. 
    //
    CInCritSec ics( &m_csLevel1 );

    if ( m_eState == e_Shutdown )
    {
        return;
    }

    _DBG_ASSERT( m_eState == e_InitializePending );

    //
    // transition to Initialized.
    // 
    
    if ( SUCCEEDED(hres) && m_pCoreEventProvider != NULL )
    {
        //
        // while holding level1, handle any deferred events
        // 
        
        for( int i=0; i < m_aDeferredEvents.GetSize(); i++ )
        {
            //
            // iterate through 1 by 1 because later we may propagate
            // context for each event here.
            //
            
            HRESULT hr;
            CEventContext Context;
            hr = m_pCoreEventProvider->Fire( *m_aDeferredEvents[i], &Context );
            
            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"Could not fire deferred event in "
                            "namespace '%S'. HR=0x%x\n", m_wszName, hr ));
            }

            delete m_aDeferredEvents[i];
        }

        if (  m_aDeferredEvents.GetSize() > 0 )
        {
            DEBUGTRACE((LOG_ESS,"Fired %d deferred events after init "
                        "complete in namespace '%S'.\n", 
                        m_aDeferredEvents.GetSize(),m_wszName));
        }

        m_aDeferredEvents.RemoveAll();
    }

    //
    // release the ref we were holding to keep core loaded between PreInit()
    // and now.  
    //
    DecrementObjectCount(); 

    m_eState = e_Initialized;
    m_hresInit = hres;
    
    SetEvent( m_hInitComplete );
}

HRESULT CEssNamespace::WaitForInitialization()
{       
    IWbemContext            *pContext = GetCurrentEssContext( );
    VARIANT                 vValue;
    HRESULT                 hres;

    do
    {
        if ( NULL == pContext )
        {
            break;
        }
        
        hres = pContext->GetValue( L"__ReentranceTestProp", 0, &vValue );

        if ( WBEM_E_NOT_FOUND == hres )
        {
            break;
        }
        
        if ( FAILED( hres ) )
        {
            return hres;
        }

        if ( VARIANT_TRUE == V_BOOL( &vValue ) )
        {
            return S_OK;
        }
    }
    while( FALSE );

    //
    // The level1 or level2 locks cannot be held when calling this function.
    // The reason for this is because we may be we waiting on the initialize 
    // event.  
    //
    
    CInCritSec ics(&m_csLevel1);

    if ( m_eState == e_Shutdown )
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    if ( m_eState == e_Initialized )
    {
        return m_hresInit;
    }

    _DBG_ASSERT( m_eState == e_InitializePending );
    _DBG_ASSERT( m_hInitComplete != INVALID_HANDLE_VALUE )

    //
    // wait for initialization to complete.
    //
        
    LeaveCriticalSection( &m_csLevel1 );

    m_pEss->TriggerDeferredInitialization();

    DWORD dwRes = WaitForSingleObject( m_hInitComplete, 20*60*1000 );
    
    EnterCriticalSection( &m_csLevel1 );
    
    if ( dwRes != WAIT_OBJECT_0 )
    {
        return WBEM_E_CRITICAL_ERROR;
    }           

    return m_hresInit;
}

BOOL CEssNamespace::DoesThreadOwnNamespaceLock()
{
    return m_csLevel2.GetLockCount() != -1 &&
           m_csLevel2.GetOwningThreadId() == GetCurrentThreadId();
}

void CEssNamespace::LogOp( LPCWSTR wszOp, IWbemClassObject* pObj )
{
    if ( LoggingLevelEnabled(2) )
    {
        _DBG_ASSERT(pObj!=NULL);
        BSTR bstrText;
        if ( SUCCEEDED(pObj->GetObjectText( 0, &bstrText )) )
        {
            DEBUGTRACE((LOG_ESS,"%S in namespace %S. Object is %S\n",
                        wszOp, m_wszName, bstrText ));
            SysFreeString( bstrText );
        }
    }
}

CQueueingEventSink* CEssNamespace::GetQueueingEventSink( LPCWSTR wszSinkName )
{
    HRESULT hr;

    //
    // TODO: For now there is a 1 to 1 mapping between a sink and a consumer.
    // ( consumer inherits from queueing sink ).  This will not always be 
    // the case.  Here, the sink name is really the standard path to the cons.
    //

    CEventConsumer* pCons;

    hr = m_Bindings.FindEventConsumer( wszSinkName, &pCons );

    if ( FAILED(hr) )
    {
        return NULL;
    }

    return pCons;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
BOOL CEssNamespace::IsNeededOnStartup()
{
    return m_Bindings.DoesHavePermanentConsumers();
}

void CEssNamespace::SetActive()
{
    //
    // Inform ESS of our newely active status so that it can make sure 
    // we are reloaded the next time around
    //
    m_pEss->SetNamespaceActive(m_wszName);
}

void CEssNamespace::SetInactive()
{
    //
    // Inform ESS of our newely inactive status so that it does not have to
    // reload us the next time around
    //
    m_pEss->SetNamespaceInactive(m_wszName);
}

//
// This is a quick and dirty shutdown of the namespace that is used when the 
// process is shutting down.  
// 
HRESULT CEssNamespace::Park()
{
    {
        CInUpdate iu(this);
        m_Bindings.Clear( false );
    }

    FirePostponedOperations();

    return S_OK;
}
   
//
// This is the slow and clean shutdown that is used when the namespace is 
// purged.
//
HRESULT CEssNamespace::Shutdown()
{
    {
        //
        // we want to wait until all update operations have completed, then
        // we'll mark the namespace as shutdown.
        // 
        CInUpdate iu(this);

        //
        // we will also be modifying the level1 members too so need level1
        // lock.
        // 
        CInCritSec ics(&m_csLevel1);
        
        m_eState = e_Shutdown;
    }

    //
    // at this point all new calls into the namespace will be rejected.
    // 
    
    //
    // wake up any threads waiting for Initialization.
    //

    SetEvent( m_hInitComplete );

    InternalRemoveNotificationSink(&m_ClassDeletionSink);
        
    m_EventProviderCache.Shutdown();
    m_Bindings.Clear( false );
    m_Poller.Clear();
    m_ConsumerProviderCache.Clear();

    FirePostponedOperations();

    return WBEM_S_NO_ERROR;
}

CEssNamespace::~CEssNamespace()
{

//
//    Do not call shutdown here.  Shutdown() is an operation that incurrs 
//    postponed operations and triggering them to fire here is not usually
//    expected by the caller.  If the caller wants to call shutdown on their
//    own then they are welcome to do so.    
//
    g_lNumNamespaces--;

    delete [] m_wszName;

    if(m_pCoreSvc)
        m_pCoreSvc->Release();

    if(m_pFullSvc)
        m_pFullSvc->Release();

    if(m_pInternalCoreSvc)
        m_pInternalCoreSvc->Release();

    if(m_pInternalFullSvc)
        m_pInternalFullSvc->Release();

    if(m_pProviderFactory)
        m_pProviderFactory->Release();

    if(m_pCoreEventProvider)
        m_pCoreEventProvider->Release();
    
    if ( m_hInitComplete != INVALID_HANDLE_VALUE )
        CloseHandle( m_hInitComplete );

    for( int i=0; i < m_aDeferredEvents.GetSize(); i++ )
        delete m_aDeferredEvents[i];

    if ( m_pAdminOnlySD != NULL )
        LocalFree( m_pAdminOnlySD );
}

HRESULT CEssNamespace::GetNamespacePointer(
                                RELEASE_ME IWbemServices** ppNamespace)
{
    //
    // This function returns the full svc pointer for use outside this class.
    // We want to ensure that we don't use the full service ptr until we've 
    // completed stage 1 initialization.  Reason is that we don't want to 
    // load class providers until the second stage of initialization.
    //
    _DBG_ASSERT( m_bStage1Complete );

    if(m_pFullSvc == NULL)
        return WBEM_E_CRITICAL_ERROR;

    *ppNamespace = m_pFullSvc;
    (*ppNamespace)->AddRef();

    return S_OK;
}

HRESULT CEssNamespace::ActOnSystemEvent(CEventRepresentation& Event, 
                                        long lFlags)
{
    HRESULT hres;

// This macro will execute its parameter if updates are allowed at this time on
// this thread, and schedule it otherwise (in the case of an event provider 
// calling back
#define PERFORM_IF_ALLOWED(OP) OP
        
    // Check the type
    // ==============

    if(Event.IsInstanceEvent())
    {
        // Instance creation, deletion or modification event. Check class
        // ==============================================================

        if(!wbem_wcsicmp(CLASS_OF(Event), EVENT_FILTER_CLASS))
        {
            return PERFORM_IF_ALLOWED(ReloadEventFilter(OBJECT_OF(Event)));
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), BINDING_CLASS))
        {
            return PERFORM_IF_ALLOWED(ReloadBinding(OBJECT_OF(Event)));
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), 
                              EVENT_PROVIDER_REGISTRATION_CLASS))
        {
            return PERFORM_IF_ALLOWED(
                        ReloadEventProviderRegistration(OBJECT_OF(Event)));
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), 
                              CONSUMER_PROVIDER_REGISTRATION_CLASS))
        {
            return PERFORM_IF_ALLOWED(
                        ReloadConsumerProviderRegistration(OBJECT_OF(Event)));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(PROVIDER_CLASS) == S_OK)
        {
            return PERFORM_IF_ALLOWED(ReloadProvider(OBJECT_OF(Event)));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(CONSUMER_CLASS) == S_OK)
        {
            return PERFORM_IF_ALLOWED(ReloadEventConsumer(OBJECT_OF(Event), 
                                                            lFlags));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(TIMER_BASE_CLASS) == S_OK)
        {
           return PERFORM_IF_ALLOWED(ReloadTimerInstruction(OBJECT_OF(Event)));
        }
        else
        {
            return WBEM_S_FALSE;
        }
    }
    else if(Event.type == e_EventTypeClassDeletion)
    {
        //
        // For now --- only for deletions.  Force-mode modifications are not
        // properly handled at the moment.
        //

        return PERFORM_IF_ALLOWED(
                    HandleClassChange(CLASS_OF(Event), OBJECT_OF(Event)));
    }
    else if(Event.type == e_EventTypeClassCreation)
    {
        return PERFORM_IF_ALLOWED(
                    HandleClassCreation(CLASS_OF(Event), OBJECT_OF(Event)));
    }
    else if(Event.type == e_EventTypeNamespaceDeletion)
    {
        // Construct full namespace name (ours + child)
        // =============================================

        DWORD cLen = wcslen(m_wszName) + wcslen(Event.wsz2) + 2;
        LPWSTR wszFullName = new WCHAR[cLen];
            
        if(wszFullName == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CVectorDeleteMe<WCHAR> vdm( wszFullName );
        
        StringCchPrintfW( wszFullName, cLen, L"%s\\%s", m_wszName, Event.wsz2);

        // Get the main object to purge that namespace
        // ===========================================

        return m_pEss->PurgeNamespace(wszFullName);
    }
    else
    {
        // Not of interest
        // ===============

        return WBEM_S_FALSE;
    }
}

HRESULT CEssNamespace::ValidateSystemEvent(CEventRepresentation& Event)
{
    HRESULT hr;

    // Check the type
    // ==============

    if(Event.IsInstanceEvent())
    {
        IWbemClassObject* pPrevObj = NULL;
        IWbemClassObject* pObj = NULL;
        if(Event.type == e_EventTypeInstanceCreation)
            pObj = OBJECT_OF(Event);
        else if(Event.type == e_EventTypeInstanceDeletion)
            pPrevObj = OBJECT_OF(Event);
        else if(Event.type == e_EventTypeInstanceModification)
        {
            pObj = OBJECT_OF(Event);
            pPrevObj = OTHER_OBJECT_OF(Event);
        }

        // Instance creation, deletion or modification event. Check class
        // ==============================================================

        if(!wbem_wcsicmp(CLASS_OF(Event), EVENT_FILTER_CLASS))
        {
            hr = CheckEventFilter(pPrevObj, pObj);
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), BINDING_CLASS))
        {
            hr = CheckBinding(pPrevObj, pObj);
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), 
                                             EVENT_PROVIDER_REGISTRATION_CLASS))
        {
            hr = CheckEventProviderRegistration(OBJECT_OF(Event));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(CONSUMER_CLASS) == S_OK)
        {
            hr = CheckEventConsumer(pPrevObj, pObj);
        }
        else if(OBJECT_OF(Event)->InheritsFrom(TIMER_BASE_CLASS) == S_OK)
        {
            hr = CheckTimerInstruction(pObj);
        }
        else
        {
            hr = WBEM_S_FALSE;
        }

        //
        // even some of the validation routines use postponed operations.
        //
        FirePostponedOperations();
    }
    else
    {
        // Not of interest
        // ===============

        hr = WBEM_S_FALSE;
    }

    return hr;
}

HRESULT CEssNamespace::CheckEventConsumer(IWbemClassObject* pPrevConsumerObj,
                                            IWbemClassObject* pConsumerObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    hres = CheckSecurity(pPrevConsumerObj, pConsumerObj);
    return hres;
}

PSID CEssNamespace::GetSidFromObject(IWbemClassObject* pObj)
{
    HRESULT hres;

    VARIANT vSid;
    VariantInit(&vSid);
    CClearMe cm1(&vSid);

    hres = pObj->Get(OWNER_SID_PROPNAME, 0, &vSid, NULL, NULL);
    if(FAILED(hres) || V_VT(&vSid) != (VT_UI1 | VT_ARRAY))
    {
        return NULL;
    }

    // Construct an actual PSID from the SAFEARRAY
    // ===========================================

    PSID pOriginal = NULL;

    hres = SafeArrayAccessData(V_ARRAY(&vSid), (void**)&pOriginal);
    if(FAILED(hres))
    {
        return NULL;
    }

    CUnaccessMe uam(V_ARRAY(&vSid));

    long cOriginal;
    if ( FAILED(SafeArrayGetUBound( V_ARRAY(&vSid), 1, &cOriginal ) ))
    {
        return NULL;
    }

    cOriginal++; // SafeArrayGetUBound() is -1 based

    //
    // validate SID.
    // 

    DWORD dwSidLength = GetLengthSid(pOriginal);

    if ( dwSidLength > cOriginal || !IsValidSid(pOriginal) )
    {
        return NULL;
    }

    // Make a copy and return it
    // =========================

    PSID pCopy = (PSID)new BYTE[dwSidLength];
    if(pCopy == NULL)
        return NULL;

    if(!CopySid(dwSidLength, pCopy, pOriginal))
    {
        delete [] (BYTE*)pCopy;
        return NULL;
    }

    return pCopy;
}

HRESULT CEssNamespace::CheckSecurity(IWbemClassObject* pPrevObj,
                                        IWbemClassObject* pObj)
{
    HRESULT hres;

    if(!IsNT())
        return WBEM_S_NO_ERROR;

    // Retrieve the SID of the calling user
    // ====================================

    hres = CoImpersonateClient();
    if(FAILED(hres))
        return hres;

    CNtSid Sid;
    hres = RetrieveSidFromCall(Sid);
    CoRevertToSelf();
    if(FAILED(hres))
        return hres;

    // If modifying an existing object, check override security
    // ========================================================

    if(pPrevObj)
    {
        hres = CheckOverwriteSecurity(pPrevObj, Sid);
        if(FAILED(hres))
            return hres;
    }

    // If creating a new version of an object, ensure Sid correctness
    // ==============================================================

    if(pObj)
    {
        hres = EnsureSessionSid(pObj, Sid);
        if(FAILED(hres))
            return hres;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::CheckSidForPrivilege( PSID sid )
{
    HRESULT hres;

    //
    // we must check that it will be possible to even perform access checks
    // for this SID.  If the SID is a domain account, then we need to see 
    // if this machine even has permission in the domain to enumerate the 
    // groups for this user ( necessary for performing access checks later 
    // on. ) If not, then we should fail now during subscription creation
    // vs later on when performing the access checks.
    //
    IWbemToken* pTok;
    hres = GetToken( sid, &pTok );
    if ( FAILED(hres) )
    {
        if ( hres == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
            return WBEMESS_E_AUTHZ_NOT_PRIVILEGED;
        return hres;
    }
    pTok->Release();

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::EnsureSessionSid(IWbemClassObject* pObj, CNtSid& Sid)
{
    HRESULT hres;
    
    PSID pOldSid = GetSidFromObject(pObj);
    
    if( pOldSid == NULL )
    {
        //
        // No SID --- just put owner SID in there
        //    
        hres = PutSidInObject(pObj, Sid);

        if ( SUCCEEDED(hres) )
            hres = CheckSidForPrivilege( Sid.GetPtr() );

        return hres;
    }

    CVectorDeleteMe<BYTE> vdm((BYTE*)pOldSid);

    //
    // Check for the special case of administrators --- they get to use the
    // Administrators SID instead of their own for off-line operations.
    //
    
    hres = IsCallerAdministrator();
    if(FAILED(hres) && hres != WBEM_E_ACCESS_DENIED)
        return hres;
    
    BOOL bAdmin = hres == WBEM_S_NO_ERROR;

    if ( EqualSid(pOldSid, Sid.GetPtr()) || 
         ( bAdmin && EqualSid(pOldSid, GetAdministratorsSid().GetPtr()) ) )
    {
        //
        // the existing SID is o.k.
        //
        return CheckSidForPrivilege( pOldSid );
    }
    
    if ( !bAdmin )
    {
        CNtSid OldSid(pOldSid);
    
        WCHAR achSid[130], achOldSid[130];
        DWORD cSid = 130, cOldSid = 130;
    
        if ( Sid.GetTextSid( achSid, &cSid ) && 
             OldSid.GetTextSid( achOldSid, &cOldSid ) )
        {
            ERRORTRACE((LOG_ESS, "ERROR : "
                        "User %S has tried to put an incompatible SID "
                        "%S in a subscription instance. "
                        "Using User SID instead.\n", 
                        achSid, achOldSid ));    
        }
    }
    
    //
    // Invalid SID found --- replace with owner SID
    //
    hres = PutSidInObject( pObj, Sid );

    if ( SUCCEEDED(hres) )
        hres = CheckSidForPrivilege( Sid.GetPtr() );

    return hres;
}
            

HRESULT CEssNamespace::PutSidInObject(IWbemClassObject* pObj, CNtSid& Sid)
{
    HRESULT hres;

    //
    // Clear it first
    //

    VARIANT vSid;
    VariantInit(&vSid);
    V_VT(&vSid) = VT_NULL;
    CClearMe cm1(&vSid);

    hres = pObj->Put(OWNER_SID_PROPNAME, 0, &vSid, 0);
    if(FAILED(hres))
        return hres;

    //
    // Construct a safearray for it
    //

    V_VT(&vSid) = VT_ARRAY | VT_UI1;
    SAFEARRAYBOUND sab;
    sab.cElements = Sid.GetSize();
    sab.lLbound = 0;
    V_ARRAY(&vSid) = SafeArrayCreate(VT_UI1, 1, &sab);
    if(V_ARRAY(&vSid) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Copy the SID in there
    // =====================

    BYTE* abSid = NULL;
    hres = SafeArrayAccessData(V_ARRAY(&vSid), (void**)&abSid);
    if(FAILED(hres))
        return WBEM_E_OUT_OF_MEMORY;
    CUnaccessMe uam(V_ARRAY(&vSid));
    if(!CopySid(Sid.GetSize(), (PSID)abSid, Sid.GetPtr()))
        return WBEM_E_OUT_OF_MEMORY;

    // Put it into the consumer
    // ========================

    hres = pObj->Put(OWNER_SID_PROPNAME, 0, &vSid, 0);
    return hres;
}

HRESULT CEssNamespace::CheckOverwriteSecurity(IWbemClassObject* pPrevObj,
                                                CNtSid& ActingSid)
{
    HRESULT hres;

    if(!IsNT())
        return WBEM_S_NO_ERROR;

    // Retrieve owner SID from the old object
    // ======================================

    PSID pOwnerSid = GetSidFromObject(pPrevObj);
    if(pOwnerSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVectorDeleteMe<BYTE> vdm((BYTE*)pOwnerSid);

    // Compare the owner sid with the acting SID.  If same, allow access
    // =================================================================

    if(EqualSid(pOwnerSid, ActingSid.GetPtr()))
        return WBEM_S_NO_ERROR;

    // Not the same --- still hope that the acting SID is an Admin
    // ===========================================================

    hres = IsCallerAdministrator();
    if(FAILED(hres))
        return hres;

    //
    // OK --- an admin can overwrite
    //

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::IsCallerAdministrator()
{
    HRESULT hres;

    hres = CoImpersonateClient();
    if(FAILED(hres)) return hres;
    OnDelete0<HRESULT(*)(void),CoRevertToSelf> RevertMe;

    HANDLE hToken;
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken))
        return WBEM_E_FAILED;
    CCloseMe ccm(hToken);
    
    if(CNtSecurity::IsUserInGroup(hToken, GetAdministratorsSid()))
        return WBEM_S_NO_ERROR;

    return WBEM_E_ACCESS_DENIED;
}

HRESULT CEssNamespace::CheckEventFilter(IWbemClassObject* pOldFilterObj,
                                        IWbemClassObject* pFilterObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    // Check security
    // ==============

    hres = CheckSecurity(pOldFilterObj, pFilterObj);
    if(FAILED(hres))
        return hres;

    // Check everything else
    // =====================

    return CPermanentFilter::CheckValidity(pFilterObj);
}

HRESULT CEssNamespace::ReloadEventFilter(IWbemClassObject* pFilterObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadEventFilter", pFilterObjTemplate );  

    ENSURE_INITIALIZED

    // Start by deleting this event filter from our records, if there
    // ==============================================================

    hres = RemoveEventFilter(pFilterObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this filter in the database
    // ==========================================================

    IWbemClassObject* pFilterObj = NULL;
    hres = GetCurrentState(pFilterObjTemplate, &pFilterObj);
    if(FAILED(hres))
        return hres;

    if(pFilterObj == NULL)
    {
        // The filter has been deleted --- no further action is needed
        // ===========================================================

        return S_OK;
    }

    CReleaseMe rm1(pFilterObj);

    // Now create it if necessary
    // ==========================

    hres = AddEventFilter(pFilterObj);
    if(FAILED(hres))
        return hres;

    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked and the filter deleted from the records,
//  AddEventFilter updates the records to the state of this filter in the
//  database.
// 
//******************************************************************************
HRESULT CEssNamespace::AddEventFilter(IWbemClassObject* pFilterObj,
                                        BOOL bInRestart)
{
    HRESULT hres;

    // Construct the new filter
    // ========================

    CPermanentFilter* pFilter = new CPermanentFilter(this);
    if(pFilter == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pFilter->AddRef();
    CReleaseMe rm2(pFilter);

    // Initialize it
    // =============

    hres = pFilter->Initialize(pFilterObj);
    if(FAILED(hres))
        return hres;

    // Add it to the table
    // ===================

    hres = m_Bindings.AddEventFilter(pFilter);
    if(FAILED(hres))
        return hres;

    if(!bInRestart)
    {
        // Process all the bindings that this filter might have
        // ====================================================
    
        hres = AssertBindings(pFilterObj);
        if(FAILED(hres))
            return hres;
    }

    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked, RemoveEventFilter updates the records 
//  to remove all mention of this filter. Note: this is *not* the function to be
//  called in response to the database instance-deletion event, as the filter 
//  could have been recreated in the interim.
// 
//******************************************************************************
HRESULT CEssNamespace::RemoveEventFilter(IWbemClassObject* pFilterObj)
{
    HRESULT hres;

    // Calculate the key for this filter
    // =================================

    BSTR strKey = CPermanentFilter::ComputeKeyFromObj(pFilterObj);
    if(strKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strKey);

    // Remove it from the table, thus deactivating it
    // ==============================================

    hres = m_Bindings.RemoveEventFilter(strKey);
    if(hres == WBEM_E_NOT_FOUND)
        return S_FALSE;
    return hres;
}

//*****************************************************************************
//
//  Called in response to an instance operation event related to an event 
//  consumer object.
//
//*****************************************************************************
HRESULT CEssNamespace::ReloadEventConsumer(
                        IWbemClassObject* pConsumerObjTemplate,
                        long lFlags)
{
    HRESULT hres;

    LogOp( L"ReloadConsumer", pConsumerObjTemplate );  

    ENSURE_INITIALIZED

    // Start by deleting this event consumer from our records, if there
    // ================================================================

    hres = RemoveEventConsumer(pConsumerObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this Consumer in the database
    // ============================================================

    IWbemClassObject* pConsumerObj = NULL;
    hres = GetCurrentState(pConsumerObjTemplate, &pConsumerObj);
    if(FAILED(hres))
        return hres;

    if(pConsumerObj == NULL)
    {
        // The Consumer has been deleted --- no further action is needed
        // =============================================================

        return S_OK;
    }

    CReleaseMe rm1(pConsumerObj);

    // Now create it if necessary
    // ==========================

    hres = AddEventConsumer(pConsumerObjTemplate, lFlags, FALSE);
    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked and the consumer deleted from the records
//  AddEventConsumer updates the records to the state of this consumer in the
//  database.
// 
//******************************************************************************
HRESULT CEssNamespace::AddEventConsumer(IWbemClassObject* pConsumerObj,
                                        long lFlags,
                                        BOOL bInRestart)
{
    HRESULT hres;

    // Construct the new Consumer
    // ==========================

    CPermanentConsumer* pConsumer = new CPermanentConsumer(this);
    if(pConsumer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pConsumer->AddRef();
    CReleaseMe rm2(pConsumer);

    // Initialize it
    // =============

    hres = pConsumer->Initialize(pConsumerObj);
    if(FAILED(hres))
        return hres;

    //
    // Validate if required
    //

    if(lFlags & WBEM_FLAG_STRONG_VALIDATION)
    {
        hres = pConsumer->Validate(pConsumerObj);
        if(FAILED(hres))
        {
            return hres;
        }
    }
        

    // Add it to the table
    // ===================

    hres = m_Bindings.AddEventConsumer(pConsumer);
    if(FAILED(hres))
        return hres;

    if(!bInRestart)
    {
        // Process all the bindings that this consumer might have
        // ======================================================
    
        hres = AssertBindings(pConsumerObj);
        if(FAILED(hres))
            return hres;
    }

    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked, RemoveEventConsumer updates the records 
//  to remove all mention of this consumer. 
// 
//******************************************************************************
HRESULT CEssNamespace::RemoveEventConsumer(IWbemClassObject* pConsumerObj)
{
    HRESULT hres;

    // Calculate the key for this filter
    // =================================

    BSTR strKey = CPermanentConsumer::ComputeKeyFromObj(this, pConsumerObj);
    if(strKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strKey);

    // Remove it from the table
    // ========================

    hres = m_Bindings.RemoveEventConsumer(strKey);
    if(hres == WBEM_E_NOT_FOUND)
        return S_FALSE;
    return hres;
}

HRESULT CEssNamespace::CheckBinding(IWbemClassObject* pPrevBindingObj, 
                                    IWbemClassObject* pBindingObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    //
    // Check security
    //

    hres = CheckSecurity(pPrevBindingObj, pBindingObj);
    if(FAILED(hres))
        return hres;

    //
    // Construct a fake binding to test correctness
    //

    CPermanentBinding* pBinding = new CPermanentBinding;
    if(pBinding == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pBinding->AddRef();
    CTemplateReleaseMe<CPermanentBinding> trm(pBinding);

    hres = pBinding->Initialize(pBindingObj);
    if(FAILED(hres))
        return hres;

    return S_OK;
}
    
//******************************************************************************
//
//  Called in response to an instance operation event related to a binding
//  instance.
//
//******************************************************************************

HRESULT CEssNamespace::ReloadBinding(IWbemClassObject* pBindingObjTemplate)
{
    HRESULT hres;
    
    LogOp( L"ReloadBinding", pBindingObjTemplate );  

    ENSURE_INITIALIZED

    // Retrieve consumer and provider keys from the binding
    // ====================================================

    BSTR strPrelimConsumerKey = NULL;
    BSTR strFilterKey = NULL;
    hres = CPermanentBinding::ComputeKeysFromObject(pBindingObjTemplate, 
                &strPrelimConsumerKey, &strFilterKey);
    if(FAILED(hres))
        return hres;

    CSysFreeMe sfm1(strPrelimConsumerKey);
    CSysFreeMe sfm2(strFilterKey);

    // Get real paths from these possibly abbreviated ones
    // ===================================================

    BSTR strConsumerKey = NULL;

    hres = m_pInternalCoreSvc->GetNormalizedPath( strPrelimConsumerKey, 
                                                  &strConsumerKey);
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm3(strConsumerKey);
    
    // Start by deleting this binding from our records, if there
    // =========================================================

    hres = RemoveBinding(strFilterKey, strConsumerKey);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    // Determine the current state of this binding in the database
    // ============================================================

    IWbemClassObject* pBindingObj = NULL;
    hres = GetCurrentState(pBindingObjTemplate, &pBindingObj);
    if(FAILED(hres))
        return hres;

    if(pBindingObj == NULL)
    {
        // The Binding has been deleted --- no further action is needed
        // =============================================================

        return S_OK;
    }

    CReleaseMe rm1(pBindingObj);

    // Now create it if necessary
    // ==========================

    hres = AddBinding(strFilterKey, strConsumerKey, pBindingObjTemplate);
    return hres;
}

HRESULT CEssNamespace::AddBinding(IWbemClassObject* pBindingObj)
{
    HRESULT hres;

    // Retrieve consumer and provider keys from the binding
    // ====================================================

    BSTR strPrelimConsumerKey = NULL;
    BSTR strFilterKey = NULL;
    hres = CPermanentBinding::ComputeKeysFromObject(pBindingObj, 
                &strPrelimConsumerKey, &strFilterKey);
    if(FAILED(hres))
        return hres;

    CSysFreeMe sfm1(strPrelimConsumerKey);
    CSysFreeMe sfm2(strFilterKey);

    // Get real paths from these possibly abbreviated ones
    // ===================================================

    BSTR strConsumerKey = NULL;

    hres = m_pInternalCoreSvc->GetNormalizedPath( strPrelimConsumerKey, 
                                                  &strConsumerKey );
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm3(strConsumerKey);

    return AddBinding(strFilterKey, strConsumerKey, pBindingObj);
}


HRESULT CEssNamespace::AddBinding(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey,
                                    IWbemClassObject* pBindingObj)
{
    HRESULT hres;

    // Create a new binding
    // ====================

    CPermanentBinding* pBinding = new CPermanentBinding;
    if(pBinding == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pBinding->AddRef();
    CReleaseMe rm1(pBinding);

    // Initialize it with the information we have
    // ==========================================

    hres = pBinding->Initialize(pBindingObj);
    if(FAILED(hres))
        return hres;

    // Extract its creator's SID
    // ========================

    PSID pSid = CPermanentBinding::GetSidFromObject(pBindingObj);
    
    if ( pSid == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = m_Bindings.Bind( wszFilterKey, wszConsumerKey, pBinding, pSid );
    
    delete [] pSid;

    return hres;
}

HRESULT CEssNamespace::RemoveBinding(LPCWSTR wszFilterKey, 
                                        LPCWSTR wszConsumerKey)
{
    HRESULT hres;
    hres = m_Bindings.Unbind(wszFilterKey, wszConsumerKey);
    if(hres == WBEM_E_NOT_FOUND)
        return S_FALSE;
    return hres;
}


    
//******************************************************************************
//
//  Reads all the bindings referencing a given objects from the database and
//  asserts them.
//
//******************************************************************************
class CAssertBindingsSink : public CObjectSink
{
protected:
    CEssNamespace* m_pNamespace;
public:
    CAssertBindingsSink(CEssNamespace* pNamespace) : m_pNamespace(pNamespace)
    {
        AddRef();
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        for(long i = 0; i < lNumObjects; i++)
        {
            m_pNamespace->AddBinding(apObjects[i]);
        }
        return S_OK;
    }
};


HRESULT CEssNamespace::AssertBindings(IWbemClassObject* pEndpoint)
{
    // Get the relative path of the endpoint
    // =====================================

    VARIANT vRelPath;
    VariantInit(&vRelPath);
    CClearMe cm1(&vRelPath);
    HRESULT hres = pEndpoint->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
    if(FAILED(hres)) 
        return hres;
    if(V_VT(&vRelPath) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    BSTR strRelPath = V_BSTR(&vRelPath);

    // Issue the query
    // ===============

    DWORD cLen = 200 + wcslen(strRelPath);
    BSTR strQuery = SysAllocStringLen(NULL, cLen);
    if(strQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strQuery);

    StringCchPrintfW( strQuery, cLen, L"references of {%s} where "
                L"ResultClass = __FilterToConsumerBinding", strRelPath);

    CAssertBindingsSink Sink(this);
    hres = ExecQuery(strQuery, 0, &Sink);
    return hres;
}

HRESULT CEssNamespace::ReloadTimerInstruction(
                                    IWbemClassObject* pInstObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadTimerInstruction", pInstObjTemplate );  

    ENSURE_INITIALIZED

    hres = RemoveTimerInstruction(pInstObjTemplate);
    if(FAILED(hres))
        return hres;
    
    // Get the current version from the namespace
    // ==========================================

    IWbemClassObject* pInstObj = NULL;
    hres = GetCurrentState(pInstObjTemplate, &pInstObj);
    if(FAILED(hres))
        return hres;

    if(pInstObj == NULL)
    {
        // The instruction has been deleted --- no further action is needed
        // ================================================================

        return S_OK;
    }

    CReleaseMe rm1(pInstObj);

    // Add it to the generator
    // =======================

    hres = AddTimerInstruction(pInstObj);
    if(FAILED(hres))
        return hres;

    return hres;
}

HRESULT CEssNamespace::AddTimerInstruction(IWbemClassObject* pInstObj)
{
    return m_pEss->GetTimerGenerator().
        LoadTimerEventObject(m_wszName, pInstObj);
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEssNamespace::RemoveTimerInstruction(IWbemClassObject* pOldObject)
{
    HRESULT hres;

    VARIANT vID;
    VariantInit(&vID);
    hres = pOldObject->Get(TIMER_ID_PROPNAME, 0, &vID, NULL, NULL);
    if(FAILED(hres)) return hres;

    if ( V_VT(&vID) != VT_BSTR )
    {
    	VariantClear(&vID);
    	return WBEM_E_INVALID_OBJECT;
    }
    
    m_pEss->GetTimerGenerator().Remove(m_wszName, V_BSTR(&vID));
    VariantClear(&vID);
    return S_OK;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************

HRESULT CEssNamespace::SignalEvent( READ_ONLY CEventRepresentation& Event,
                                    long lFlags,
                                    BOOL bAdminOnly )
{
    HRESULT hres;
    
    //
    // we cannot hold any turns in an exec line or hold the namespace lock
    // when calling this function.  This is because this function will 
    // aquire the proxy lock.  
    // 
    CPostponedList* pList;
    
    _DBG_ASSERT( !DoesThreadOwnNamespaceLock() );
    _DBG_ASSERT( !(pList=GetCurrentPostponedList()) || 
                 !pList->IsHoldingTurns() );

    // BUGBUG: need to propagate security context to this function ?

    CWbemPtr<CCoreEventProvider> pCoreEventProvider; 

    {
        //
        // we need to figure out if we need to deffer the event or signal it.
        // we deffer events when we are in the init pending or init state.
        // 

        CInCritSec ics( &m_csLevel1 );

        if ( m_eState == e_Initialized )
        {
            pCoreEventProvider = m_pCoreEventProvider;
        }
        else if ( m_eState == e_InitializePending )
        {
            //
            // Copy and add to defferred list. 
            // 
            
            CEventRepresentation* pEvRep = Event.MakePermanentCopy();
            
            if ( pEvRep == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            
            if ( m_aDeferredEvents.Add( pEvRep ) < 0 )
            {
                delete pEvRep;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    if ( pCoreEventProvider != NULL )
    {
        CEventContext Context;

        if ( bAdminOnly )
            Context.SetSD( m_cAdminOnlySD, PBYTE(m_pAdminOnlySD), FALSE );

        hres = pCoreEventProvider->Fire( Event, &Context );

        if(FAILED(hres))
        {
            return hres;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEssNamespace::ProcessEvent(READ_ONLY CEventRepresentation& Event,
                                    long lFlags)
{
    // Ignore internal operations
    // ==========================

    if(Event.wsz2 != NULL && 
       (!wbem_wcsicmp(Event.wsz2, L"__TimerNextFiring") ||
        !wbem_wcsicmp(Event.wsz2, L"__ListOfEventActiveNamespaces")))
    {
        return WBEM_S_NO_ERROR;
    }

    HRESULT hres, hresReturn = WBEM_S_NO_ERROR;

    // Analyze it for system changes
    // =============================

    hres = ActOnSystemEvent(Event, lFlags);
    
    if(FAILED(hres))
    {
        //
        // Check if this operation needs to be failed if invalid
        //

        if( lFlags & WBEM_FLAG_STRONG_VALIDATION )
        {
            hresReturn = hres;
        }
        else
        {
            ERRORTRACE((LOG_ESS, "Event subsystem was unable to perform the "
                        "necessary operations to accomodate a change to the system "
                        "state.\nThe state of the database may not reflect the state "
                        "of the event subsystem (%X)\n", hres));
        }
    }

    // Fire postponed operations
    // =========================

    hres = FirePostponedOperations();

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS,"Event subsystem was unable to perform the (post) "
                    "necessary operations to accomodate a change to the system state.\n"
                    "The state of the database may not reflect the state of the event "
                    "subsystem (%X)\n", hres));
    }

    // Deliver it to consumers
    // =======================

    hres = SignalEvent( Event, lFlags );

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Event subsystem was unable to deliver a "
                    "repository intrinsic event to some consumers (%X)\n", hres));
    }

    return hresReturn;
}


HRESULT CEssNamespace::ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event )
{
    HRESULT hres;

    hres = EnsureInitPending();
    if ( FAILED(hres) )
        return hres;

    hres = WaitForInitialization();
    if ( FAILED(hres) )
        return hres;

    if ( m_eState == e_Shutdown )
        return WBEM_E_SHUTTING_DOWN;

    CRefedPointerArray< CEventFilter > apEventFilters;
    
    hres = S_FALSE;

    if ( m_Bindings.GetEventFilters( apEventFilters ) )
    {
        if ( apEventFilters.GetSize( ) > 0 )
        {
            //
            // Convert to real event
            // 

            IWbemClassObject* pEvent;

            HRESULT hr = Event.MakeWbemObject( this, &pEvent );

            if( FAILED( hr ) )
            {
                return hr;
            }

            CReleaseMe rm1( pEvent );

            ULONG cEventSD;
            PBYTE pEventSD = (PBYTE)GetSD( pEvent, &cEventSD );
            CEventContext Context;

            if ( pEventSD != NULL )
            {
                if ( FALSE == Context.SetSD( cEventSD, pEventSD, TRUE ) )
                {
                    return WBEM_E_OUT_OF_MEMORY;
                }
                
                if ( !IsValidSecurityDescriptor( 
                            (PSECURITY_DESCRIPTOR)Context.GetSD() ) )
                {
                    return WBEM_E_INVALID_OBJECT;
                }
            }

            //
            // Fire all matching filters
            //
            
            for( int i = 0; i < apEventFilters.GetSize( ); ++i )
            {
                CEventFilter* pEventFilter = apEventFilters[i];
                hr = pEventFilter->Indicate( 1, &pEvent, &Context );

                if ( FAILED( hr ) )
                {
                    return hr;
                }

                //
                // Return S_FALSE if all of the Indicates returns S_FALSE
                //

                if ( S_FALSE != hr )
                {
                    hres = S_OK;
                }
            }
        }
    }
    else
    {
        return E_FAIL;
    }

    return hres;
}



HRESULT CEssNamespace::RegisterNotificationSink( WBEM_CWSTR wszQueryLanguage, 
                                                 WBEM_CWSTR wszQuery, 
                                                 long lFlags, 
                                                 WMIMSG_QOS_FLAG lQosFlags, 
                                                 IWbemContext* pContext, 
                                                 IWbemObjectSink* pSink )
{
    HRESULT hres;

    //
    // Report the MSFT_WmiRegisterNotificationSink event.
    //
    FIRE_NCEVENT( g_hNCEvents[MSFT_WmiRegisterNotificationSink], 
                  WMI_SENDCOMMIT_SET_NOT_REQUIRED,
                 
                  // Data follows...
                  (LPCWSTR) m_wszName,
                  wszQueryLanguage,
                  wszQuery,
                  (DWORD64) pSink);

    DEBUGTRACE((LOG_ESS,"Registering notification sink with query %S in "
                "namespace %S.\n", wszQuery, m_wszName ));

    {
            
        ENSURE_INITIALIZED

        hres = InternalRegisterNotificationSink( wszQueryLanguage, 
                                                 wszQuery,
                                                 lFlags, 
                                                 lQosFlags,
                                                 pContext, 
                                                 pSink,
                                                 FALSE,
                                                 NULL );
    }

    if(FAILED(hres))
    {
        // Clean up and return
        FirePostponedOperations();
        return hres;
    }

    // Filter and consumer are in place --- fire external operations
    // =============================================================

    hres = FirePostponedOperations();

    if(FAILED(hres))
    {
        {
            CInUpdate iu(this);
            if ( m_eState == e_Shutdown )
                return WBEM_E_SHUTTING_DOWN;
            InternalRemoveNotificationSink( pSink );     
        }

        //
        // need to make sure that we fire postponed here too. Remember that 
        // we cannot hold the namespace lock when firing postponed ops.
        //

        FirePostponedOperations();
    }
    else
    {
        InterlockedIncrement(&g_lNumTempSubscriptions);
    }
    
    return hres;
}

HRESULT CEssNamespace::InternalRegisterNotificationSink(
                                                 WBEM_CWSTR wszQueryLanguage, 
                                                 WBEM_CWSTR wszQuery, 
                                                 long lFlags, 
                                                 WMIMSG_QOS_FLAG lQosFlags,
                                                 IWbemContext* pContext, 
                                                 IWbemObjectSink* pSink,
                                                 bool bInternal,
                                                 PSID pOwnerSid )
{
    HRESULT hres;

    if(wbem_wcsicmp(wszQueryLanguage, L"WQL"))
        return WBEM_E_INVALID_QUERY_TYPE;

    LPWSTR wszConsumerKey = NULL;
    CVectorDeleteMe<WCHAR> vdm2(&wszConsumerKey);
    wszConsumerKey = CTempConsumer::ComputeKeyFromSink(pSink);
    if ( NULL == wszConsumerKey )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    bool bInterNamespace = pOwnerSid != NULL;

    LPWSTR wszFilterKey = NULL;
    CVectorDeleteMe<WCHAR> vdm1(&wszFilterKey);

    {    
        // Create a new temporary filter and add it to the binding table
        // =============================================================

        CTempFilter* pFilter = new CTempFilter(this);
        if(pFilter == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        hres = pFilter->Initialize( wszQueryLanguage, 
                                    wszQuery, 
                                    lFlags, 
                                    pOwnerSid,
                                    bInternal,
                                    pContext,
                                    pSink );
        if(FAILED(hres))
        {
            delete pFilter;
            return hres;
        }
        
        hres = m_Bindings.AddEventFilter(pFilter);
        if(FAILED(hres))
        {
            delete pFilter;
            return hres;
        }
        
        wszFilterKey = pFilter->GetKey().CreateLPWSTRCopy();
        if(wszFilterKey == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        // Check if this sink has already been used by looking for it in the
        // binding table
        // =================================================================

        CTempConsumer* pConsumer = NULL;
        if(FAILED(m_Bindings.FindEventConsumer(wszConsumerKey, NULL)))
        {
            // Create a new temporary consumer and add it to the table
            // =======================================================

            pConsumer = _new CTempConsumer(this);
            if(pConsumer == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            hres = pConsumer->Initialize( bInterNamespace, pSink);
            if(FAILED(hres))
                return hres;

            hres = m_Bindings.AddEventConsumer(pConsumer);
            if(FAILED(hres))
            {
                // Undo filter creation
                // ====================

                m_Bindings.RemoveEventFilter(wszFilterKey);
                return hres;
            }
        }
        
        // Bind them together
        // ==================

        CBinding* pBinding = new CTempBinding( lFlags, 
                                               lQosFlags,
                                               bInterNamespace );
        if(pBinding == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pBinding->AddRef();
        CReleaseMe rm1(pBinding);

        // 
        // SPAGETTI WARNING: From this point on, we must flush the postponed
        // operation cache, or we may leak memory.  But not before all the 
        // CReleaseMe calls have fired.
        //

        hres = m_Bindings.Bind(wszFilterKey, wszConsumerKey, pBinding, NULL);
        
        // Check that the filter is active --- otherwise activatioin must have
        // failed.
        // ===================================================================
        if(SUCCEEDED(hres) && !pFilter->IsActive())
            hres = pFilter->GetFilterError();

        if(FAILED(hres))
        {
            //
            // The core will deliver the SetStatus call to the consumer based
            // on the return code from the ESS.  Since we are failing, we should
            // not call SetStatus ourselves.
            //

            if(pConsumer)
            pConsumer->Shutdown(true); // quiet

            m_Bindings.RemoveEventFilter(wszFilterKey);
            m_Bindings.RemoveEventConsumer(wszConsumerKey);
        }
        else
        {
            InterlockedIncrement(&g_lNumInternalTempSubscriptions);    
        }
    }

    return hres;
}

HRESULT CEssNamespace::RemoveNotificationSink( IWbemObjectSink* pSink )
{
    // Fire a MSFT_WmiCancelNotificationSink if necessary.
    if (IS_NCEVENT_ACTIVE(MSFT_WmiCancelNotificationSink))
    {
        LPWSTR wszConsumerKey = CTempConsumer::ComputeKeyFromSink(pSink);
        
        if (wszConsumerKey != NULL)
        {
            CVectorDeleteMe<WCHAR> vdm0(wszConsumerKey);
            CInUpdate iu(this);

            // Find the consumer in question
            CEventConsumer *pConsumer = NULL;

            if (SUCCEEDED(m_Bindings.FindEventConsumer(wszConsumerKey, &pConsumer)))
            {
                CRefedPointerSmallArray<CEventFilter> 
                apFilters;
                CReleaseMe rm1(pConsumer);

                // Make addrefed copies of all its associated filters
                if (SUCCEEDED(pConsumer->GetAssociatedFilters(apFilters))
                    && apFilters.GetSize())
                {
                    int    nFilters = apFilters.GetSize();
                    LPWSTR wszQuery = NULL,
                    wszQueryLanguage = NULL;
                    BOOL   bExact;

                    apFilters[0]->
                    GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, NULL);

                    CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
                    CVectorDeleteMe<WCHAR> vdm2(wszQuery);

                    //
                    // Report the MSFT_WmiRegisterNotificationSink event.
                    //
                    FIRE_NCEVENT(
                                 g_hNCEvents[MSFT_WmiCancelNotificationSink], 
                                 WMI_SENDCOMMIT_SET_NOT_REQUIRED,

                                 // Data follows...
                                 (LPCWSTR) m_wszName,
                                 wszQueryLanguage,
                                 wszQuery,
                                 (DWORD64) pSink);
                }
            }
        }
    }

    HRESULT hres;

    {
        CInUpdate iu( this );

        if ( m_eState == e_Shutdown )
        {
            return WBEM_E_SHUTTING_DOWN;
        }

        hres = InternalRemoveNotificationSink( pSink );
    }

    FirePostponedOperations();

    if ( SUCCEEDED(hres) )
    {
        InterlockedDecrement( &g_lNumTempSubscriptions );
    }

    return hres;
}

HRESULT CEssNamespace::InternalRemoveNotificationSink(IWbemObjectSink* pSink)
{
    HRESULT hres;
    
    LPWSTR wszKey = CTempConsumer::ComputeKeyFromSink(pSink);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm1(wszKey);

    // Find the consumer container
    // ===========================

    hres = m_Bindings.RemoveConsumerWithFilters(wszKey);
    if(FAILED(hres))
        return hres;
    else
        InterlockedDecrement( &g_lNumInternalTempSubscriptions );
    
    return hres;
}


void CEssNamespace::FireNCFilterEvent(DWORD dwIndex, CEventFilter *pFilter)
{
    if (IS_NCEVENT_ACTIVE(dwIndex))
    {
        LPWSTR        wszQuery = NULL;
        LPWSTR        wszQueryLanguage = NULL;
        BOOL          bExact;
        CWbemPtr<CEssNamespace> pNamespace;
        
        GetFilterEventNamespace(pFilter, &pNamespace);

        // I'll assume we should use the current namespace if it's null.
        if (!pNamespace)
            pNamespace = this;

        pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, NULL);

        CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
        CVectorDeleteMe<WCHAR> vdm2(wszQuery);

        //
        // Report the event.
        //
        FIRE_NCEVENT(
                     g_hNCEvents[dwIndex], 
                     WMI_SENDCOMMIT_SET_NOT_REQUIRED,

                     // Data follows...
                     pNamespace ? (LPCWSTR) pNamespace->GetName() : NULL,
                     (LPCWSTR) (WString) pFilter->GetKey(),
                     wszQueryLanguage,
                     wszQuery);
    }
}

//*****************************************************************************
//
//  Called by the filter when it notices that it has consumers. The filter is
//  guaranteed to be either valid or temporarily invalid and not active. It is
//  guaranteed that no more than 1 activation/deactivation can occur on the 
//  same filter at the same time.
//
//*****************************************************************************
HRESULT CEssNamespace::ActivateFilter(READ_ONLY CEventFilter* pFilter)
{
    HRESULT hres, hresAttempt;

    hresAttempt = AttemptToActivateFilter(pFilter);

    if(FAILED(hresAttempt))
    {
        pFilter->MarkAsTemporarilyInvalid(hresAttempt);

        // 
        // We need to log an event about our inability to activate the filter
        // unless we shall report this failure to the caller.  We can only
        // report this to the caller if the filter is being created (not 
        // reactivated), and the caller is not using a force-mode
        //

        if(pFilter->DoesAllowInvalid() || pFilter->HasBeenValid())
        {
            LPWSTR wszQuery = NULL;
            LPWSTR wszQueryLanguage = NULL;
            BOOL bExact;
            
            hres = pFilter->GetCoveringQuery( wszQueryLanguage, 
                                              wszQuery, 
                                              bExact,
                                              NULL);
            if(FAILED(hres))
                return hres;
            
            CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
            CVectorDeleteMe<WCHAR> vdm2(wszQuery);

            //
            // Don't change this one: could be Nova customer dependencies
            //

            m_pEss->GetEventLog().Report( EVENTLOG_ERROR_TYPE, 
                                          WBEM_MC_CANNOT_ACTIVATE_FILTER,
                                          m_wszName, 
                                          wszQuery, 
                                          (CHex)hresAttempt );

            ERRORTRACE((LOG_ESS, "Could not activate filter %S in namespace "
                        "%S. HR=0x%x\n", wszQuery, m_wszName, hresAttempt ));
        }
    }
    else
    {
        //
        // Report the MSFT_WmiFilterActivated event.
        //
        FireNCFilterEvent(MSFT_WmiFilterActivated, pFilter);

        pFilter->MarkAsValid();
    }

    return hresAttempt;
}


//******************************************************************************
//
//  Worker for ActivateFilter --- does all the work but does not mark the filter
//  status
//
//******************************************************************************
HRESULT CEssNamespace::AttemptToActivateFilter(READ_ONLY CEventFilter* pFilter)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //
    // Get the query information from the filter
    // 

    LPWSTR wszQueryLanguage = NULL;
    LPWSTR wszQuery = NULL;
    BOOL bExact;

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;

    hres = pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, &pExp);
    if(FAILED(hres))
    {
        WMIESS_REPORT((WMIESS_CANNOT_GET_FILTER_QUERY, m_wszName, pFilter));
        return hres;
    }

    CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
    CVectorDeleteMe<WCHAR> vdm2(wszQuery);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm1(pExp);

    if(!bExact)
    {
        //
        // We don't support inexact filter, nor do we have any now
        //
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // Check if the events are supposed to come from this namespace or some
    // other one.  Cross-namespace filters are all we are interested in the
    // initialize phase, since we're going to reprocess normal filters
    // after loading provider registrations ( In CompleteInitialization() )
    //

    CEssNamespace* pOtherNamespace = NULL;
    hres = GetFilterEventNamespace(pFilter, &pOtherNamespace);
    if(FAILED(hres))
        return hres;

    if( pOtherNamespace )
    {
        CTemplateReleaseMe<CEssNamespace> rm0(pOtherNamespace);

        if ( m_bInResync )
        {
            //
            // we don't need to do anything in the other namespace during 
            // resync of this one, so no work to do here.  Actually, since 
            // resync doesn't do a deactivate, the registration is still there
            // so be careful of double registration if removing this check.
            //

            return WBEM_S_FALSE;
        }

        DEBUGTRACE((LOG_ESS,"Activating cross-namespace filter %p with query "
                        "%S in namespace %S from namespace %S.\n", pFilter, 
                        wszQuery, pOtherNamespace->GetName(), m_wszName ));

        //
        // Register this notification sink with the other namespace, as 
        // if it were a temporary consumer.  Make the registration 
        // synchronous, as whatever asynchronicity we need will be 
        // provided by the ultimate consumer handling. This needs to be a 
        // postponed operation though, else we could have a deadlock 
        // scenario if at the same time cross namespace subscriptions 
        // were registered in both namespaces.
        //
        
        //
        // BUGBUG: security propagation
        //
        
        CPostponedRegisterNotificationSinkRequest* pReq;

        pReq = new CPostponedRegisterNotificationSinkRequest;

        if ( pReq == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        hres = pReq->SetRegistration( pOtherNamespace,
                                      wszQueryLanguage,
                                      wszQuery, 
                                      pFilter->GetForceFlags(), 
                                      WMIMSG_FLAG_QOS_SYNCHRONOUS,
                                      pFilter->GetNonFilteringSink(),
                                      pFilter->GetOwner() );
        
        if(FAILED(hres))
        {
            return hres;
        }

        CPostponedList* pList = GetCurrentPostponedList();

        _DBG_ASSERT( pList != NULL );

        hres = pList->AddRequest( this, pReq );

        if ( FAILED(hres) )
        {
            return hres;
        }

        return WBEM_S_NO_ERROR;
    }
    else if ( m_bStage1Complete )
    {
        //
        // Filter is being activated in this namespace.  We must avoid 
        // processing filters before we're fully initialized.  This can 
        // happen when one namespace is initializing its cross namespace 
        // subscription to one that is still initializing. We do not process
        // filters before we're initialized because (1) we are not allowed to 
        // access class providers during stage1 init and (2) we're going to 
        // resync everything anyways during stage2 init.  
        //

        DEBUGTRACE((LOG_ESS,"Activating filter %p with query %S "
                    "in namespace %S.\n", pFilter, wszQuery, m_wszName ));

        // Retrieve its non-filtering sink
        // ===============================

        CAbstractEventSink* pNonFilter = pFilter->GetNonFilteringSink();
        if(pNonFilter == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        //
        // Register for class modification events of relevance for this filter
        //

        hres = RegisterFilterForAllClassChanges(pFilter, pExp);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,"Unable to register for class changes related "
                "to filter %S in namespace %S: 0x%x\n", wszQuery, GetName(), 
                hres));
            return hres;
        }

        //
        // Prepare filter for action
        //

        hres = pFilter->GetReady(wszQuery, pExp);
        
        if( SUCCEEDED(hres) )
        { 
            //
            // Register it in the core tables
            //

            hres = m_EventProviderCache.LoadProvidersForQuery(wszQuery, 
                                            pExp, pNonFilter);
            if(SUCCEEDED(hres))
            {
                hres = m_Poller.ActivateFilter(pFilter, wszQuery, pExp);
                if(FAILED(hres))
                {
                    // Need to deactivate providers
                    // ============================

                    m_EventProviderCache.ReleaseProvidersForQuery(
                                                            pNonFilter);
                }
            }
        }    
    }

    if(FAILED(hres))
    {
        //
        // Keep this filter registered for its class change events, as one of 
        // them could make it valid!
        //
    }

    return hres;
}

//*****************************************************************************
//
//  Retrieves the namespace pointer for the event namespace for this filter.
//  If current, returns NULL.  
//
//*****************************************************************************

HRESULT CEssNamespace::GetFilterEventNamespace(CEventFilter* pFilter,
                                         RELEASE_ME CEssNamespace** ppNamespace)
{
    HRESULT hres;

    *ppNamespace = NULL;

    LPWSTR wszNamespace = NULL;
    hres = pFilter->GetEventNamespace(&wszNamespace);
    if(FAILED(hres))
    {
        WMIESS_REPORT((WMIESS_INVALID_FILTER_NAMESPACE, m_wszName, pFilter, 
                        wszNamespace));
        return hres;
    }
    CVectorDeleteMe<WCHAR> vdm0(wszNamespace);

    if(wszNamespace && wbem_wcsicmp(wszNamespace, m_wszName))
    {
        //
        // Different namespace: Find it in the list. 
        //

        hres = m_pEss->GetNamespaceObject( wszNamespace, TRUE, ppNamespace );

        if(FAILED(hres))
        {
            WMIESS_REPORT((WMIESS_CANNOT_OPEN_FILTER_NAMESPACE, m_wszName, 
                            pFilter, wszNamespace));
            return hres;
        }

        //
        // Check if we got back our current namespace --- could happen if the
        // spelling is different, etc
        //

        if(*ppNamespace == this)
        {
            (*ppNamespace)->Release();
            *ppNamespace = NULL;
        }

        return S_OK;
    }
    else
    {
        // Same namespace
        *ppNamespace = NULL;
        return S_OK; 
    }
}

HRESULT CEssNamespace::RegisterFilterForAllClassChanges(CEventFilter* pFilter,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    HRESULT hres;
    
    //
    // Do nothing for class operation filters.  They simply serve as their own
    // "class change" filters
    //
    
    if(!wbem_wcsicmp(pExpr->bsClassName, L"__ClassOperationEvent") ||
        !wbem_wcsicmp(pExpr->bsClassName, L"__ClassCreationEvent") ||
        !wbem_wcsicmp(pExpr->bsClassName, L"__ClassDeletionEvent") ||
        !wbem_wcsicmp(pExpr->bsClassName, L"__ClassModificationEvent"))
    {
        pFilter->MarkReconstructOnHit();
        return WBEM_S_NO_ERROR;
    }

    //
    // get the sink for class change notifications.
    // 

    IWbemObjectSink* pClassChangeSink = pFilter->GetClassChangeSink(); // NOREF
    _DBG_ASSERT( pClassChangeSink != NULL );

    //
    // since the class change sink will be modifying internal namespace 
    // structures, we must wrap with an internal operations sink.  This is so
    // the thread that performs the indicate will be guaranteed to have a 
    // valid thread object associated with it.
    // 

    CWbemPtr<CEssInternalOperationSink> pInternalOpSink;
    pInternalOpSink = new CEssInternalOperationSink( pClassChangeSink );

    if ( pInternalOpSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // store the new sink with the filter because we need it later to unreg
    // 

    CWbemPtr<IWbemObjectSink> pOldInternalOpSink;
    hres = pFilter->SetActualClassChangeSink( pInternalOpSink, 
                                              &pOldInternalOpSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    _DBG_ASSERT( pOldInternalOpSink == NULL );

    return RegisterSinkForAllClassChanges( pInternalOpSink, pExpr );
}

HRESULT CEssNamespace::RegisterSinkForAllClassChanges(IWbemObjectSink* pSink,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    HRESULT hres;

    //
    // First of all, the class we are looking for is of interest
    //

    hres = RegisterSinkForClassChanges(pSink, pExpr->bsClassName);
    if(FAILED(hres))
        return hres;

    //
    // Now, iterate over all the tokens looking for ISAs.  We need those classes
    // too.
    //

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens + i;

        if(pToken->nTokenType == QL1_OP_EXPRESSION && 
            (pToken->nOperator == QL1_OPERATOR_ISA ||
             pToken->nOperator == QL1_OPERATOR_ISNOTA) &&
            V_VT(&pToken->vConstValue) == VT_BSTR)
        {
            hres = RegisterSinkForClassChanges(pSink, 
                                                  V_BSTR(&pToken->vConstValue));
            if(FAILED(hres))
            {
                UnregisterSinkFromAllClassChanges(pSink);
                return hres;
            }
        }
    }

	// Somehow need to keep this filter subscribed to various events until all
	// the classes show up

    return WBEM_S_NO_ERROR;
}
    
HRESULT CEssNamespace::RegisterSinkForClassChanges(IWbemObjectSink* pSink,
                                                    LPCWSTR wszClassName)
{
    //
    // Do not register for changes to system classes --- they do not change!
    //

    if(wszClassName[0] == L'_')
    {
        return WBEM_S_NO_ERROR;
    }

    //
    // Just issue the appropriate query against the namespace.  The filter
    // will know what to do when called
    //

    DWORD cLen = wcslen(wszClassName) + 100;
    LPWSTR wszQuery = new WCHAR[cLen];

    if ( wszQuery == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchPrintfW( wszQuery, 
                      cLen, 
                      L"select * from __ClassOperationEvent where "
                      L"TargetClass isa \"%s\"", wszClassName );

    CVectorDeleteMe<WCHAR> vdm( wszQuery );

    return InternalRegisterNotificationSink(L"WQL", 
            wszQuery, 0, WMIMSG_FLAG_QOS_SYNCHRONOUS, 
            GetCurrentEssContext(), pSink, true, NULL );
}

HRESULT CEssNamespace::RegisterProviderForClassChanges( LPCWSTR wszClassName,
                                                        LPCWSTR wszProvName )
{
    try
    {
        CInCritSec ics(&m_csLevel1);
        m_mapProviderInterestClasses[wszClassName].insert( wszProvName );
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}
                
    
HRESULT CEssNamespace::UnregisterFilterFromAllClassChanges(
                            CEventFilter* pFilter)
{
    HRESULT hres;

    //
    // unbind the filter from the actual class change sink and use it to unreg
    //

    CWbemPtr<IWbemObjectSink> pActualClassChangeSink;

    hres = pFilter->SetActualClassChangeSink( NULL, &pActualClassChangeSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    if ( pActualClassChangeSink != NULL )
    {
        hres = UnregisterSinkFromAllClassChanges( pActualClassChangeSink );
    }

    return hres;
}

HRESULT CEssNamespace::UnregisterSinkFromAllClassChanges(
                            IWbemObjectSink* pSink)
{
    return InternalRemoveNotificationSink(pSink);
}
    

HRESULT CEssNamespace::DeactivateFilter( READ_ONLY CEventFilter* pFilter )
{
    HRESULT hres;

    DEBUGTRACE((LOG_ESS,"Deactivating filter %p\n", pFilter ));

    HRESULT hresGlobal = WBEM_S_NO_ERROR;

    //
    // Check if the events are supposed to come from this namespace or some
    // other one.
    //

    CEssNamespace* pOtherNamespace = NULL;
    hres = GetFilterEventNamespace(pFilter, &pOtherNamespace);
    if(FAILED(hres))
        return hres;

    if( pOtherNamespace )
    {
        CTemplateReleaseMe<CEssNamespace> rm0(pOtherNamespace);

        //
        // Unregister this notification sink with the other namespace, 
        // as if it were a temporary consumer.  This needs to be a 
        // postponed operation though, else we could have a deadlock 
        // scenario if at the same time cross namespace subscriptions 
        // were registered in both namespaces.
        //
        
        CPostponedRemoveNotificationSinkRequest* pReq;

        pReq = new CPostponedRemoveNotificationSinkRequest(
                                              pOtherNamespace, 
                                              pFilter->GetNonFilteringSink() );

        if ( pReq == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        CPostponedList* pList = GetCurrentPostponedList();
        
        _DBG_ASSERT( pList != NULL );
        
        hres = pList->AddRequest( this, pReq );
        
        if ( FAILED(hres) )
        {
            delete pReq;
            return hres;
        }
            
        return WBEM_S_NO_ERROR;
    }
    else
    {
        //
        // Current namespace --- unregister for real
        //

        // Retrieve its non-filtering sink
        // ===============================
    
        CAbstractEventSink* pNonFilter = pFilter->GetNonFilteringSink();
        if(pNonFilter == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        //
        // Report the MSFT_WmiFilterDeactivated event.
        //
        FireNCFilterEvent(MSFT_WmiFilterDeactivated, pFilter);

        //
        // Unregister it from class change notifications
        //

        hres = UnregisterFilterFromAllClassChanges(pFilter);
        if(FAILED(hres))
            hresGlobal = hres;
        
        // Deactivate in providers, poller, and static search
        // ==================================================
    
        hres = m_EventProviderCache.ReleaseProvidersForQuery(pNonFilter);
        if(FAILED(hres))
            hresGlobal = hres;
    
        hres = m_Poller.DeactivateFilter(pFilter);
        if(FAILED(hres))
            hresGlobal = hres;
    
        pFilter->SetInactive();
            
        return hres;
    }
}

HRESULT CEssNamespace::HandleClassCreation( LPCWSTR wszClassName, 
                                            IWbemClassObject* pClass)
{
    // 
    // Check if this is a class that a provider is waiting for.
    //
    
    ProviderSet setProviders;

    {
        CInCritSec ics( &m_csLevel1 );

        ClassToProviderMap::iterator it;
        it = m_mapProviderInterestClasses.find( wszClassName );

        if ( it != m_mapProviderInterestClasses.end() )
        {
            //
            // copy the interested provider list.
            //
            setProviders = it->second;
            
            //
            // remove the entry from the map.
            //
            m_mapProviderInterestClasses.erase( it );
        }
    }

    if ( setProviders.size() > 0 )
    {
        //
        // reload interested providers.
        //

        DEBUGTRACE((LOG_ESS,"Reloading some providers in namespace %S due to "
                    "creation of %S class\n", m_wszName, wszClassName ));

        ProviderSet::iterator itProv;

        for( itProv=setProviders.begin(); itProv!=setProviders.end(); itProv++)
        {
            ReloadProvider( 0, *itProv );
        }
    }

    return S_OK;
}


//*****************************************************************************
//
// Updates internal structures to reflect a change to this class.  Assumes that
// the namespace is already locked.
// Very few errors are reported from this function, since class changes cannot
// be vetoed.
// 
//*****************************************************************************
HRESULT CEssNamespace::HandleClassChange(LPCWSTR wszClassName, 
                                         IWbemClassObject* pClass)
{
    // Check if the class in question is an event consumer class
    // =========================================================
    
    if(pClass->InheritsFrom(CONSUMER_CLASS) == S_OK)
    {
        CInUpdate iu(this);

        if ( IsShutdown() )
            return WBEM_E_SHUTTING_DOWN;
        
        HandleConsumerClassDeletion(wszClassName);
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::HandleConsumerClassDeletion(LPCWSTR wszClassName)
{
    // There are two varieties: non-singleton and singleton
    // ====================================================

    DWORD cLen = wcslen(wszClassName) + 2;
    LPWSTR wszPrefix = new WCHAR[cLen];
    if(wszPrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm( wszPrefix );

    StringCchPrintfW(wszPrefix, cLen, L"%s.", wszClassName);
    m_Bindings.RemoveConsumersStartingWith(wszPrefix);

    StringCchPrintfW(wszPrefix, cLen, L"%s=", wszClassName);
    m_Bindings.RemoveConsumersStartingWith(wszPrefix);

    return WBEM_S_NO_ERROR;
}
    
HRESULT CEssNamespace::ReloadProvider( long lFlags, LPCWSTR wszProvider )
{
    HRESULT hres;

    WString wsRelpath;

    //
    // we only have to do this for event providers.  Check to see if 
    // we know about this try to see if we even have any event providers to reload ...
    // 

    try 
    {
        wsRelpath = L"__Win32Provider.Name='"; 
        wsRelpath += wszProvider;
        wsRelpath += L"'";
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemPtr<_IWmiObject> pObj;
    hres = GetInstance( wsRelpath, &pObj );

    if ( SUCCEEDED(hres) )
    {
        {
            ENSURE_INITIALIZED
            CInResync ir(this);
            
            //
            // note : in case of reloading event provider due to notification
            // from provss, we only need to handle event providers since 
            // consumer providers already have a reloading mechanism.
            //
            m_EventProviderCache.RemoveProvider(pObj);
            hres = AddProvider( pObj );
            ir.Commit();
        }

        if ( SUCCEEDED(hres) )
        {
            hres = FirePostponedOperations();
        }
        else
        {
            FirePostponedOperations();
        }
    }

    return hres;
}

HRESULT CEssNamespace::ReloadProvider(IWbemClassObject* pProvObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadProvider", pProvObjTemplate );  

    ENSURE_INITIALIZED

    CInResync ir(this);

    // Start by deleting this provider from our records, if there
    // ==========================================================

    hres = RemoveProvider(pProvObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this provider in the database
    // ============================================================

    IWbemClassObject* pProvObj = NULL;
    hres = GetCurrentState(pProvObjTemplate, &pProvObj);
    if(FAILED(hres))
        return hres;

    if(pProvObj == NULL)
    {
        // The provider has been deleted --- no further action is needed
        // =============================================================

        return S_OK;
    }

    CReleaseMe rm1(pProvObj);

    // Now create it if necessary
    // ==========================

    hres = AddProvider(pProvObj);
    if(FAILED(hres))
        return hres;

    ir.Commit();
    return hres;
}
    
HRESULT CEssNamespace::ReloadEventProviderRegistration(
                            IWbemClassObject* pProvRegObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadEventProviderRegistration", pProvRegObjTemplate );  

    ENSURE_INITIALIZED

    CInResync ir(this);

    // Start by deleting this provider from our records, if there
    // ==========================================================

    hres = RemoveEventProviderRegistration(pProvRegObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this registration in the database
    // ================================================================

    IWbemClassObject* pProvRegObj = NULL;
    hres = GetCurrentState(pProvRegObjTemplate, &pProvRegObj);
    if(FAILED(hres))
        return hres;

    if(pProvRegObj == NULL)
    {
        // The registration has been deleted --- no further action is needed
        // =================================================================

        return S_OK;
    }

    CReleaseMe rm1(pProvRegObj);

    // Now create it if necessary
    // ==========================

    hres = AddEventProviderRegistration(pProvRegObj);
    if(FAILED(hres))
        return hres;

    ir.Commit();
    return hres;
}
    
HRESULT CEssNamespace::ReloadConsumerProviderRegistration(
                            IWbemClassObject* pProvRegObjTemplate)
{
    CInUpdate iu(this);

    // Reset consumer provider info in all the consumers using this consumer
    // provider.  That's all we need to do --- they will simply pick up the new
    // data on next delivery.  We don't even need to get the current version,
    // since all we need is the key
    // ========================================================================

    return RemoveConsumerProviderRegistration(pProvRegObjTemplate);
}


//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Adds this provider to the records.  Expects ReactivateAllFilters and 
//  CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::AddProvider(READ_ONLY IWbemClassObject* pProv)
{
    HRESULT hres;

    hres = m_EventProviderCache.AddProvider(pProv);
    return hres;
}

HRESULT CEssNamespace::CheckEventProviderRegistration(IWbemClassObject* pReg)
{
    HRESULT hres;
    ENSURE_INITIALIZED
    hres = m_EventProviderCache.CheckProviderRegistration(pReg);
    return hres;
}

HRESULT CEssNamespace::CheckTimerInstruction(IWbemClassObject* pInst)
{
    HRESULT hres;
    ENSURE_INITIALIZED
    hres = GetTimerGenerator().CheckTimerInstruction(pInst);
    return hres;
}

//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Adds this event provider registration to the records.  Expects 
//  ReactivateAllFilters and CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::AddEventProviderRegistration(
                                    IWbemClassObject* pReg)
{
    HRESULT hres;

    hres = m_EventProviderCache.AddProviderRegistration(pReg);
    return hres;
}

//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Removes this provider from the records.  Expects ReactivateAllFilters and 
//  CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::RemoveProvider(READ_ONLY IWbemClassObject* pProv)
{
    HRESULT hres;

    // Handle event consumer providers
    // ===============================

    IWbemClassObject* pConsProvReg;
    hres = m_ConsumerProviderCache.
                GetConsumerProviderRegFromProviderReg(pProv, &pConsProvReg);
    if(SUCCEEDED(hres))
    {
        RemoveConsumerProviderRegistration(pConsProvReg);
        pConsProvReg->Release();
    }

    // Handle event providers
    // ======================

    hres = m_EventProviderCache.RemoveProvider(pProv);
    return hres;
}

//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Adds this event provider registration to the records.  Expects 
//  ReactivateAllFilters and CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::RemoveEventProviderRegistration(
                                    READ_ONLY IWbemClassObject* pReg)
{
    HRESULT hres;

    hres = m_EventProviderCache.RemoveProviderRegistration(pReg);
    return hres;
}

DWORD CEssNamespace::GetProvidedEventMask(IWbemClassObject* pClass)
{
    return m_EventProviderCache.GetProvidedEventMask(pClass);
}


//*****************************************************************************
//
//  This function is called before a major update to the records. Without any 
//  calls to external components, it "deactivates" all the filters, in a sense 
//  that when all of them are "reactivated", the system will arrive in a 
//  consistent state (usage counts, etc).  CommitResync will then perform any
//  necessary activations/deactivations based on the new state
//
//*****************************************************************************

HRESULT CEssNamespace::PrepareForResync()
{
    m_bInResync = TRUE;

    // Ask the poller to "virtually" stop all polling instructions, without
    // actually stopping them physically
    // ====================================================================

    m_Poller.VirtuallyStopPolling();

    // Ask provider cache to "virtually" release all its providers, without
    // actually releasing them physically
    // ====================================================================

    m_EventProviderCache.VirtuallyReleaseProviders();

    // Ask core search to mark all filters so that it would know which ones are
    // gone after the resync
    // ========================================================================

    DEBUGTRACE((LOG_ESS,"Prepared resync in namespace %S\n", m_wszName ));

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::ReactivateAllFilters()
{
    DEBUGTRACE((LOG_ESS,"Reactivating all filters in namespace %S\n",
                 m_wszName ));
    return m_Bindings.ReactivateAllFilters();
}

HRESULT CEssNamespace::CommitResync()
{
    m_bInResync = FALSE;

    // Tell provider cache to perform all the loadings and unloadings it 
    // needs to perform based on the new data
    // =================================================================

    m_EventProviderCache.CommitProviderUsage();

    // Tell the poller to cancel unnecessary instructions
    // ==================================================

    m_Poller.CancelUnnecessaryPolling();

    DEBUGTRACE((LOG_ESS,"Committed resync in namespace %S\n", m_wszName ));

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::RemoveConsumerProviderRegistration(
                            IWbemClassObject* pReg)
{
    // Get the name of the consumer provider being deleteed
    // ====================================================

    BSTR strProvRef = CConsumerProviderCache::GetProviderRefFromRecord(pReg);
    if(strProvRef == NULL)
    {
        ERRORTRACE((LOG_ESS, "Invalid consumer provider record is being deleted"
                                "\n"));
        return WBEM_S_FALSE;
    }
    CSysFreeMe sfm1(strProvRef);

    // Reset it in all the consumers
    // =============================

    m_Bindings.ResetProviderRecords(strProvRef);

    // Remove it from the cache
    // ========================

    m_ConsumerProviderCache.RemoveConsumerProvider(strProvRef);

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::ScheduleDelivery(CQueueingEventSink* pDest)
{
    return m_pEss->EnqueueDeliver(pDest);
}

HRESULT CEssNamespace::DecorateObject(IWbemClassObject* pObj)
{
    return m_pEss->DecorateObject(pObj, m_wszName);
}

HRESULT CEssNamespace::EnsureConsumerWatchInstruction()
{
    return m_Bindings.EnsureConsumerWatchInstruction();
}

HRESULT CEssNamespace::AddSleepCharge(DWORD dwSleep)
{
    return m_pEss->AddSleepCharge(dwSleep);
}

HRESULT CEssNamespace::AddCache()
{
    return m_pEss->AddCache();
}

HRESULT CEssNamespace::RemoveCache()
{
    return m_pEss->RemoveCache();
}

HRESULT CEssNamespace::AddToCache(DWORD dwAdd, DWORD dwMemberTotal, 
                                    DWORD* pdwSleep)
{
    return m_pEss->AddToCache(dwAdd, dwMemberTotal, pdwSleep);
}

HRESULT CEssNamespace::RemoveFromCache(DWORD dwRemove)
{
    return m_pEss->RemoveFromCache(dwRemove);
}

HRESULT CEssNamespace::PerformSubscriptionInitialization()
{
    HRESULT hres;
    DWORD dwRead;

    //
    // must use repository only svc ptr here, else we can deadlock when 
    // class providers try to call back in. 
    // 

    // Enumerator all EventFilters
    // ===========================

    CFilterEnumSink* pFilterSink = new CFilterEnumSink(this);

    if ( NULL == pFilterSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pFilterSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum( EVENT_FILTER_CLASS, 0,
                                                    pFilterSink);
    pFilterSink->ReleaseAndWait();

    // Enumerator all consumers
    // ========================

    CConsumerEnumSink* pConsumerSink = new CConsumerEnumSink(this);

    if ( NULL == pConsumerSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pConsumerSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum( CONSUMER_CLASS, 0,
                                                    pConsumerSink);
    pConsumerSink->ReleaseAndWait();

    // Enumerator all bindings
    // =======================

    CBindingEnumSink* pBindingSink = new CBindingEnumSink(this);

    if ( NULL == pBindingSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pBindingSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum( BINDING_CLASS, 0,
                                                    pBindingSink);
    pBindingSink->ReleaseAndWait();

    return WBEM_S_NO_ERROR;
}


HRESULT CEssNamespace::PerformProviderInitialization()
{
    HRESULT hres;
    DWORD dwRead;

    //
    // make sure that we resync all subscriptions after we've processed 
    // provider objs
    // 

    CInResync ir( this );

    //
    // Enumerate all the providers
    // 

    IEnumWbemClassObject* penumProvs;

    hres = m_pCoreSvc->CreateInstanceEnum( CWbemBSTR( PROVIDER_CLASS ), 
                                           WBEM_FLAG_DEEP, 
                                           GetCurrentEssContext(), 
                                           &penumProvs );
   
    if ( SUCCEEDED(hres) )
    {
        CReleaseMe rm1(penumProvs);
    
        // Add them all to ESS
        // ===================
    
        IWbemClassObject* pProvObj;
        while((hres=penumProvs->Next(INFINITE, 1, &pProvObj, &dwRead)) == S_OK)
        {
            hres = AddProvider(pProvObj);
            pProvObj->Release();

            if(FAILED(hres))
            {
                // Already logged.
            }
        }
    }

    if ( FAILED(hres) )
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred enumerating event providers "
            "in namespace %S. Some event providers may not be active\n", hres,
            m_wszName));
    }

    //
    // Enumerate all the provider registrations
    // 

    IEnumWbemClassObject* penumRegs;
    hres = m_pCoreSvc->CreateInstanceEnum( CWbemBSTR( EVENT_PROVIDER_REGISTRATION_CLASS ), 
                                           WBEM_FLAG_DEEP, 
                                           GetCurrentEssContext(), 
                                           &penumRegs);
    if ( SUCCEEDED(hres) )
    {
        CReleaseMe rm2(penumRegs);
    
        // Add them all to ESS
        // ===================
    
        IWbemClassObject* pRegObj;
        while((hres = penumRegs->Next(INFINITE, 1, &pRegObj, &dwRead)) == S_OK)
        {
            hres = AddEventProviderRegistration(pRegObj);
            pRegObj->Release();
            if(FAILED(hres))
            {
                // Already logged
            }
        }
    }

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred enumerating event providers "
            "registrations in namespace %S. "
            "Some event providers may not be active\n", hres, m_wszName));
    }

    //
    // Create and initialize the core provider. 
    //
    
    CWbemPtr<CCoreEventProvider> pCoreEventProvider = new CCoreEventProvider;
    
    if ( pCoreEventProvider != NULL )
    {
        hres = pCoreEventProvider->SetNamespace(this);

        if ( SUCCEEDED(hres) )
        {
            LPCWSTR awszQuery[5] = 
            {
                L"select * from __InstanceOperationEvent",
                L"select * from __ClassOperationEvent",
                L"select * from __NamespaceOperationEvent",
                L"select * from __SystemEvent",
                L"select * from __TimerEvent"
            };

            hres = m_EventProviderCache.AddSystemProvider(pCoreEventProvider,
                                                          L"$Core", 
                                                          5, 
                                                          awszQuery );
        }
    }
    else
    {
        hres = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED(hres) )
    {
        pCoreEventProvider->AddRef();
        m_pCoreEventProvider = pCoreEventProvider;
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Core event provider cannot initialize due "
                    "to critical errors. HR=0x%x\n", hres));
    }

    // Initialize timer generator
    // ==========================

    hres = InitializeTimerGenerator();

    if(FAILED(hres)) 
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred initializing the timer "
            "in namespace %S. Some timer instructions may not be active\n", 
            hres, m_wszName));
    }

    ir.Commit();

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::InitializeTimerGenerator()
{
    return m_pEss->InitializeTimerGenerator( m_wszName, m_pCoreSvc );
}


HRESULT CEssNamespace::ScheduleFirePostponed()
{
    //
    // Save and detach the current thread object --- we need to pass it to the
    // other thread, as well as make sure than nobody else fires our postponed
    // operations!
    //

    CEssThreadObject* pThreadObj = GetCurrentEssThreadObject();
    ClearCurrentEssThreadObject();
    SetCurrentEssThreadObject(NULL);

    if ( GetCurrentEssThreadObject() == NULL )
    {
    	SetConstructedEssThreadObject( pThreadObj );
    	return WBEM_E_OUT_OF_MEMORY;
    }

    CFirePostponed* pReq = new CFirePostponed(this, pThreadObj);
    if(pReq == NULL)
    {
    	 SetConstructedEssThreadObject( pThreadObj );
        return WBEM_E_OUT_OF_MEMORY;
    }
    HRESULT hr = m_pEss->Enqueue(pReq);
    if (FAILED(hr)) delete pReq;
    return hr;
}


HRESULT CEssNamespace::FirePostponedOperations()
{
    IWbemContext            *pContext = GetCurrentEssContext( );
    VARIANT                 vValue;
    HRESULT                 hr;

    do
    {
        if ( NULL == pContext )
        {
            break;
        }
        
        hr = pContext->GetValue( L"__ReentranceTestProp", 0, &vValue );

        if ( WBEM_E_NOT_FOUND == hr )
        {
            break;
        }
        
        if ( FAILED( hr ) )
        {
            return hr;
        }

        if ( VARIANT_TRUE == V_BOOL( &vValue ) )
        {
            //
            // Reentrance
            //
            hr = pContext->DeleteValue( L"__ReentranceTestProp", 0 );
            if ( FAILED( hr ) )
            {
                return hr;
            }
            
            ScheduleFirePostponed( );
            return S_OK;
        }
    }
    while( FALSE );
    
    HRESULT hrReturn = WBEM_S_NO_ERROR;

    //
    // Update lock cannot be held when calling this function and there 
    // are operations to execute.
    //

    _DBG_ASSERT( !DoesThreadOwnNamespaceLock() );

    //
    // execute both primary and event postponed ops until empty.
    //

    CPostponedList* pList = GetCurrentPostponedList();
    CPostponedList* pEventList = GetCurrentPostponedEventList();

    do
    {    
        //
        // execute the primary postponed ops.
        // 

        if( pList != NULL )
        {
            hr = pList->Execute(this, CPostponedList::e_ReturnOneError);
        
            if ( SUCCEEDED(hrReturn) )
            {
                hrReturn = hr;
            }
        }

        //
        // now execute postponed events 
        //
        
        if ( pEventList != NULL )
        {
            hr = pEventList->Execute(this, CPostponedList::e_ReturnOneError);

            if ( SUCCEEDED(hrReturn) )
            {
                hrReturn = hr;
            }
        }
    }
    while( pList != NULL && !pList->IsEmpty() );

    return hrReturn;
}

HRESULT CEssNamespace::PostponeRelease(IUnknown* pUnk)
{
    CPostponedList* pList = GetCurrentPostponedList();
    if(pList == NULL)
    {
        //
        // Just execute it
        //

        pUnk->Release();
        return WBEM_S_NO_ERROR;
    }
    CPostponedReleaseRequest* pReq = new CPostponedReleaseRequest(pUnk);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // this is a namespace agnostic postponed request, so specify null.
    // 
    return pList->AddRequest( NULL, pReq );
}

HRESULT CEssNamespace::GetProviderNamespacePointer(IWbemServices** ppServices)
{
    IWbemServices* pServices = NULL;
    HRESULT hres = m_pEss->GetNamespacePointer(m_wszName, FALSE, &pServices);
    if(FAILED(hres))
        return hres;

    *ppServices = pServices;
    return WBEM_S_NO_ERROR;
}

void CEssNamespace::IncrementObjectCount()
{
    m_pEss->IncrementObjectCount();
}
void CEssNamespace::DecrementObjectCount()
{
    m_pEss->DecrementObjectCount();
}

HRESULT CEssNamespace::LockForUpdate()
{
    m_csLevel2.Enter();
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::UnlockForUpdate()
{
    m_ClassCache.Clear();
    m_csLevel2.Leave();
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::GetCurrentState( IWbemClassObject* pTemplate, 
                                        IWbemClassObject** ppObj)
{
    HRESULT hres;
    *ppObj = NULL;

    // Retrieve the path
    // =================

    VARIANT vPath;
    hres = pTemplate->Get(L"__RELPATH", 0, &vPath, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&vPath);
    if(V_VT(&vPath) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    // Get it from the namespace
    // =========================

    _IWmiObject* pObj;
    hres = GetInstance( V_BSTR(&vPath), &pObj );

    if( hres == WBEM_E_NOT_FOUND )
        return WBEM_S_FALSE;

    *ppObj = pObj;
    return hres;
}

CWinMgmtTimerGenerator& CEssNamespace::GetTimerGenerator()
{
    return m_pEss->GetTimerGenerator();
}
    
HRESULT CEssNamespace::RaiseErrorEvent(IWbemEvent* pEvent, BOOL bAdminOnly )
{
    CEventRepresentation Event;
    Event.type = e_EventTypeSystem;
    Event.nObjects = 1;
    Event.apObjects = &pEvent;

    HRESULT hres;
    
    hres = SignalEvent( Event, 0, bAdminOnly );
        
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Event subsystem was unable to deliver an "
                    "error event to some consumers (%X)\n", hres));
    }

    return S_OK;
}

HRESULT CEssNamespace::GetClassFromCore( LPCWSTR wszClassName, 
                                         _IWmiObject** ppClass )
{
    HRESULT hres;
    CWbemPtr<IWbemClassObject> pClass;
    *ppClass = NULL;

    //
    // want to ensure that we don't use the full service ptr until we've 
    // completed stage 1 initialization.  Reason is that we don't want to 
    // load class providers until the second stage of initialization.
    //
    _DBG_ASSERT( m_bStage1Complete );

    //
    // must use full service because will need to support dynamic classes.
    // 

    hres = m_pInternalFullSvc->InternalGetClass( wszClassName, &pClass );

    if ( FAILED(hres) )
    {
        return hres;
    }

    return pClass->QueryInterface( IID__IWmiObject, (void**)ppClass );
}
    
HRESULT CEssNamespace::GetInstance( LPCWSTR wszPath, 
                                    _IWmiObject** ppInstance )
{
    HRESULT hres;
    CWbemPtr<IWbemClassObject> pInstance;
    *ppInstance = NULL;

    hres = m_pInternalCoreSvc->InternalGetInstance( wszPath, &pInstance );

    if ( FAILED(hres) )
    {
        return hres;
    }

    return pInstance->QueryInterface( IID__IWmiObject, (void**)ppInstance );
}

HRESULT CEssNamespace::GetDbInstance( LPCWSTR wszDbKey, 
                                      _IWmiObject** ppInstance)
{
    HRESULT hres;
    CWbemPtr<IWbemClassObject> pInstance;
    *ppInstance = NULL;

    hres = m_pInternalCoreSvc->GetDbInstance( wszDbKey, &pInstance );

    if ( FAILED(hres) )
    {
        return hres;
    }

    return pInstance->QueryInterface( IID__IWmiObject, (void**)ppInstance );
}

HRESULT CEssNamespace::CreateInstanceEnum(LPCWSTR wszClass, long lFlags, 
                            IWbemObjectSink* pSink)
{
    return m_pInternalCoreSvc->InternalCreateInstanceEnum(wszClass, lFlags, pSink);
}

HRESULT CEssNamespace::ExecQuery(LPCWSTR wszQuery, long lFlags, 
                                        IWbemObjectSink* pSink)
{
    return m_pInternalCoreSvc->InternalExecQuery(L"WQL", wszQuery, lFlags, pSink);
}

HRESULT CEssNamespace::GetToken(PSID pSid, IWbemToken** ppToken)
{
    return m_pEss->GetToken(pSid, ppToken);
}
    

void CEssNamespace::DumpStatistics(FILE* f, long lFlags)
{
    CInUpdate iu(this);

    fprintf(f, "------- Namespace '%S' ----------\n", m_wszName);

    m_Bindings.DumpStatistics(f, lFlags);
    m_ConsumerProviderCache.DumpStatistics(f, lFlags);
    m_EventProviderCache.DumpStatistics(f, lFlags);
    m_Poller.DumpStatistics(f, lFlags);
}


HRESULT CEssMetaData::GetClass( LPCWSTR wszName, IWbemContext* pContext,
                                _IWmiObject** ppClass)
{
    return m_pNamespace->m_ClassCache.GetClass(wszName, pContext, ppClass);
}

STDMETHODIMP CEssNamespace::CConsumerClassDeletionSink::Indicate(
                                    long lNumObjects, 
                                    IWbemClassObject** apObjects)
{
    HRESULT hres;

    for(long i = 0; i < lNumObjects; i++)
    {
        _IWmiObject* pEvent = NULL;
        apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pEvent);
        CReleaseMe rm1(pEvent);

        //
        // Get the class name of the class being deleted
        //

        VARIANT vObj;
        hres = pEvent->Get(L"TargetClass", 0, &vObj, NULL, NULL);
        if(SUCCEEDED(hres))
        {
            CClearMe cm1(&vObj);
            IWbemClassObject* pClass;
            V_UNKNOWN(&vObj)->QueryInterface(IID_IWbemClassObject, 
                                                (void**)&pClass);
            CReleaseMe rm2(pClass);

            VARIANT vClass;
            hres = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
            if(SUCCEEDED(hres))
            {
                CClearMe cm(&vClass);
                m_pOuter->HandleConsumerClassDeletion(V_BSTR(&vClass));
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::LoadEventProvider(LPCWSTR wszProviderName, 
                                         IWbemEventProvider** ppProv)
{
    HRESULT hres;
    *ppProv = NULL;
    
    //
    // Get provider pointer from the provider subsystem
    //

    if(m_pProviderFactory == NULL)
        return WBEM_E_CRITICAL_ERROR;

	WmiInternalContext t_InternalContext ;
	ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

    hres = m_pProviderFactory->GetProvider(

	t_InternalContext ,
        0,                  // lFlags
        GetCurrentEssContext(),
        0,
        NULL,
        NULL,
        0,   
        wszProviderName,
        IID_IWbemEventProvider,
        (LPVOID *) ppProv
        );

    return hres;
}

HRESULT CEssNamespace::LoadConsumerProvider(LPCWSTR wszProviderName, 
                                         IUnknown** ppProv)
{
    HRESULT hres;
    *ppProv = NULL;
    
    //
    // Get provider pointer from the provider subsystem
    //

    if(m_pProviderFactory == NULL)
        return WBEM_E_CRITICAL_ERROR;

	WmiInternalContext t_InternalContext ;
	ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

    hres = m_pProviderFactory->GetProvider(
	
	t_InternalContext ,
        0,                  // lFlags
        GetCurrentEssContext(),
        0,
        NULL,
        NULL,
        0,   
        wszProviderName,
        IID_IUnknown,
        (LPVOID *) ppProv
        );

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\permcons.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  STDCONS.H
//
//  This file defines the class for permanent event consumer.
//
//  Classes defined:
//
//      CPermanentConsumer
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================

#ifndef __PERM_EVENT_CONSUMER__H_
#define __PERM_EVENT_CONSUMER__H_

#include "binding.h"
#include "consprov.h"
#include "fastall.h"

class CPermanentConsumer : public CEventConsumer
{
protected:
    IWbemUnboundObjectSink* m_pCachedSink;
    DWORD m_dwLastDelivery;
    IWbemClassObject* m_pLogicalConsumer;
    
    static long mstatic_lMaxQueueSizeHandle;
    static long mstatic_lSidHandle;
    static bool mstatic_bHandlesInitialized;
    static HRESULT InitializeHandles( _IWmiObject* pObject);
protected:
    HRESULT RetrieveProviderRecord(
                        RELEASE_ME CConsumerProviderRecord** ppRecord,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer = NULL);
    HRESULT RetrieveSink(RELEASE_ME IWbemUnboundObjectSink** ppSink,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer);
    HRESULT ObtainSink(RELEASE_ME IWbemUnboundObjectSink** ppSink,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer);
    HRESULT ClearCache();
    HRESULT Indicate(IWbemUnboundObjectSink* pSink,
                                    IWbemClassObject* pLogicalConsumer, 
                                    long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure);

    HRESULT ConstructErrorEvent(LPCWSTR wszEventClass,
                                IWbemEvent* pEvent, IWbemEvent** ppErrorEvent);
    HRESULT ReportConsumerFailure(IWbemEvent* pEvent, HRESULT hresError,
                                    _IWmiObject* pErrorObj);
    HRESULT ReportQosFailure(IWbemEvent* pEvent, HRESULT hresError);
    HRESULT ReportConsumerFailure(long lNumEvents,
                                IWbemEvent** apEvents,  HRESULT hresError);

    HRESULT Redeliver(long lNumEvents, IWbemEvent** apEvents, BOOL bSecure);

    void FireSinkUnloadedEvent();

public:
    CPermanentConsumer(CEssNamespace* pNamespace);
    HRESULT Initialize(READ_ONLY IWbemClassObject* pActualConsumer);
    virtual ~CPermanentConsumer();

    BOOL UnloadIfUnusedFor(CWbemInterval Interval);
    BOOL IsFullyUnloaded();
    BOOL IsPermanent() const {return TRUE;}
    HRESULT ResetProviderRecord(LPCWSTR wszProvider);
    static SYSFREE_ME BSTR ComputeKeyFromObj(CEssNamespace* pNamespace,
                                             IWbemClassObject* pConsumerObj);

    virtual HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure, CEventContext* pContext);
    HRESULT ReportQueueOverflow(IWbemEvent* pEvent, DWORD dwQueueSize);
    HRESULT Validate(IWbemClassObject* pLogicalConsumer);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\permfilt.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  PERMFILT.CPP
//
//  This file implements the classes for standard event filters.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include <sddl.h>
#include <stdio.h>
#include "pragmas.h"
#include "permfilt.h"
#include "ess.h"
#include <genutils.h>

long CPermanentFilter::mstatic_lNameHandle = 0;
long CPermanentFilter::mstatic_lLanguageHandle = 0;
long CPermanentFilter::mstatic_lQueryHandle = 0;
long CPermanentFilter::mstatic_lEventNamespaceHandle = 0;
long CPermanentFilter::mstatic_lEventAccessHandle = 0;
long CPermanentFilter::mstatic_lSidHandle = 0;
bool CPermanentFilter::mstatic_bHandlesInitialized = false;

//static 
HRESULT CPermanentFilter::InitializeHandles( _IWmiObject* pObject )
{
    if(mstatic_bHandlesInitialized)
        return S_FALSE;

    CIMTYPE ct;
    pObject->GetPropertyHandle(FILTER_KEY_PROPNAME, &ct, 
                                    &mstatic_lNameHandle);
    pObject->GetPropertyHandle(FILTER_LANGUAGE_PROPNAME, &ct, 
                                    &mstatic_lLanguageHandle);
    pObject->GetPropertyHandle(FILTER_QUERY_PROPNAME, &ct, 
                                    &mstatic_lQueryHandle);
    pObject->GetPropertyHandle(FILTER_EVENTNAMESPACE_PROPNAME, &ct, 
                                    &mstatic_lEventNamespaceHandle);
    pObject->GetPropertyHandleEx(FILTER_EVENTACCESS_PROPNAME, 0, &ct, 
                                  &mstatic_lEventAccessHandle );
    pObject->GetPropertyHandleEx(OWNER_SID_PROPNAME, 0, &ct, 
                                  &mstatic_lSidHandle);
    mstatic_bHandlesInitialized = true;
    return S_OK;
}
//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
CPermanentFilter::CPermanentFilter(CEssNamespace* pNamespace)     
    : CGenericFilter(pNamespace), m_pEventAccessRelativeSD(NULL), 
    m_pcsQuery(NULL)
{
}

CPermanentFilter::~CPermanentFilter()
{
    if ( m_pEventAccessRelativeSD != NULL )
    {
        LocalFree( m_pEventAccessRelativeSD );
    }

    if( m_pcsQuery != NULL )
    {
        CTemporaryHeap::Free(m_pcsQuery, m_pcsQuery->GetLength());
    }
}

HRESULT CPermanentFilter::Initialize( IWbemClassObject* pObj )
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pFilterObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pFilterObj );

    if ( FAILED(hres) )
    {
        return hres;
    }

    InitializeHandles( pFilterObj );

    // Check class
    // ===========

    if(pFilterObj->InheritsFrom(L"__EventFilter") != S_OK)
        return WBEM_E_INVALID_OBJECT;

    // Determine the query language
    // ============================

    ULONG ulFlags;
    CCompressedString* pcsLanguage;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lLanguageHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsLanguage );
    if( hres != S_OK || pcsLanguage == NULL)
    {
        ERRORTRACE((LOG_ESS, "Event filter with invalid query language is "
                    "rejected\n"));
        return WBEM_E_INVALID_OBJECT;
    }

    if( pcsLanguage->CompareNoCase("WQL") != 0 )
    {
        ERRORTRACE((LOG_ESS, "Event filter with invalid query language '%S' is "
                    "rejected\n", pcsLanguage->CreateWStringCopy()));
        return WBEM_E_INVALID_QUERY_TYPE;
    }

    // Get the query
    // =============

    CCompressedString* pcsQuery;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lQueryHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsQuery );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    LPWSTR wszQuery = pcsQuery->CreateWStringCopy().UnbindPtr();
    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm1(wszQuery);

    // Store it temporarily (until Park is called)
    // ===========================================

    // Figure out how much space we need
    // =================================

    int nSpace = pcsQuery->GetLength();

    // Allocate this string on the temporary heap
    // ==========================================

    m_pcsQuery = (CCompressedString*)CTemporaryHeap::Alloc(nSpace);
    if(m_pcsQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Copy the contents
    // =================

    memcpy((void*)m_pcsQuery, pcsQuery, nSpace);

    //
    // Get the event namespace
    //

    if(mstatic_lEventNamespaceHandle) // to protect against old repositories
    {
        CCompressedString* pcsEventNamespace;
        
        hres = pFilterObj->GetPropAddrByHandle( mstatic_lEventNamespaceHandle,
                                                WMIOBJECT_FLAG_ENCODING_V1,
                                                &ulFlags,
                                                (void**)&pcsEventNamespace );
        if( FAILED(hres) )
        {
            return hres;
        }
        else if ( hres == S_OK ) // o.k if event namespace is null.
        {   
            if( !(m_isEventNamespace = pcsEventNamespace))
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
        
    //
    // Record the name of this filter
    //

    CCompressedString* pcsKey;
    
    hres = pFilterObj->GetPropAddrByHandle( mstatic_lNameHandle,
                                           WMIOBJECT_FLAG_ENCODING_V1,
                                           &ulFlags,
                                           (void**)&pcsKey );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    if(!(m_isKey = pcsKey))
        return WBEM_E_OUT_OF_MEMORY;

    // Get the SID
    // ===========

    PSID pSid;
    ULONG ulNumElements;
    
    hres = pFilterObj->GetArrayPropAddrByHandle( mstatic_lSidHandle,
                                                 0,
                                                 &ulNumElements,
                                                 &pSid );
    if ( hres != S_OK ) 
    {
        return WBEM_E_INVALID_OBJECT;
    }

    m_pOwnerSid = new BYTE[ulNumElements];

    if ( m_pOwnerSid == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memcpy( m_pOwnerSid, pSid, ulNumElements );

    //
    // Get the event access SD
    //

    if( mstatic_lEventAccessHandle ) // to protect against old repositories
    {
        CCompressedString* pcsEventAccess;
        
        hres = pFilterObj->GetPropAddrByHandle( mstatic_lEventAccessHandle,
                                                WMIOBJECT_FLAG_ENCODING_V1,
                                                &ulFlags,
                                                (void**)&pcsEventAccess );
        if( FAILED(hres) )
        {
            return hres;
        }
        else if ( hres == S_OK ) // o.k if event access is null.
        {
            WString wsEventAccess;

            try
            {
                wsEventAccess = pcsEventAccess->CreateWStringCopy();
            }
            catch( CX_MemoryException )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            ULONG cEventAccessRelativeSD;

            if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
                                   wsEventAccess, 
                                   SDDL_REVISION_1, 
                                   &m_pEventAccessRelativeSD, 
                                   &cEventAccessRelativeSD ) )
            {
                WString wsKey = m_isKey;
                try { wsKey = m_isKey; } catch( CX_MemoryException ) {}
                ERRORTRACE((LOG_ESS, "Filter '%S' contained invalid SDDL "
                            "string for event access SD.\n", wsKey )); 
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            //
            // convert the self-relative SD to an absolute SD so we can 
            // set the owner and group fields ( required by AccessCheck ) 
            //

            if ( !InitializeSecurityDescriptor( &m_EventAccessAbsoluteSD, 
                                                SECURITY_DESCRIPTOR_REVISION ))
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            PACL pAcl;            
            BOOL bAclPresent, bAclDefaulted;

            if ( !GetSecurityDescriptorDacl( m_pEventAccessRelativeSD,
                                             &bAclPresent,
                                             &pAcl,
                                             &bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
                                       
            if ( !SetSecurityDescriptorDacl( &m_EventAccessAbsoluteSD, 
                                             bAclPresent,
                                             pAcl,
                                             bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( !GetSecurityDescriptorSacl( m_pEventAccessRelativeSD,
                                             &bAclPresent,
                                             &pAcl,
                                             &bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
                                       
            if ( !SetSecurityDescriptorSacl( &m_EventAccessAbsoluteSD, 
                                             bAclPresent,
                                             pAcl,
                                             bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            //
            // always need to set the owner and group sids. We do this for 
            // two reasons (1) we want to override the user putting in anything
            // they want for these fields, and (2) we want to ensure that 
            // these fields are set because AccessCheck() requires it.
            //

            if ( !SetSecurityDescriptorOwner( &m_EventAccessAbsoluteSD,
                                              m_pOwnerSid,
                                              TRUE ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( !SetSecurityDescriptorGroup( &m_EventAccessAbsoluteSD,
                                              m_pOwnerSid,
                                              TRUE ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
        }
    }

    // Initialize the generic filter accordingly
    // =========================================

    hres = CGenericFilter::Create(L"WQL", wszQuery);
    if(FAILED(hres))
        return hres;
    return WBEM_S_NO_ERROR;
}

const PSECURITY_DESCRIPTOR CPermanentFilter::GetEventAccessSD()
{
    if ( m_pEventAccessRelativeSD != NULL )
    {
        return &m_EventAccessAbsoluteSD;
    }
    return NULL;
}

HRESULT CPermanentFilter::GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                QL_LEVEL_1_RPN_EXPRESSION** ppExp)
{
    HRESULT hres;

    if(m_pcsQuery == NULL)
    {
        hres = RetrieveQuery(wszQuery);
    }
    else
    {
        wszQuery = m_pcsQuery->CreateWStringCopy().UnbindPtr();
        if(wszQuery == NULL)
            hres = WBEM_E_OUT_OF_MEMORY;
        else
            hres = WBEM_S_NO_ERROR;
    }

    if(FAILED(hres))
        return hres;

    if(ppExp)
    {
        // Parse it
        // ========
    
        CTextLexSource src(wszQuery);
        QL1_Parser parser(&src);
        int nRes = parser.Parse(ppExp);
        if (nRes)
        {
            ERRORTRACE((LOG_ESS, "Unable to construct event filter with "
                "unparsable "
                "query '%S'.  The filter is not active\n", wszQuery));
            return WBEM_E_UNPARSABLE_QUERY;
        }
    }

    bExact = TRUE;
    wszQueryLanguage = CloneWstr(L"WQL");

    return WBEM_S_NO_ERROR;
}

HRESULT CPermanentFilter::RetrieveQuery(DELETE_ME LPWSTR& wszQuery)
{
    HRESULT hres;

    //
    // Construct db path
    //

    DWORD cLen = m_isKey.GetLength() + 100;
    BSTR strPath = SysAllocStringLen(NULL, cLen );
    if(strPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strPath);

    StringCchPrintfW( strPath, 
                      cLen,
                      L"__EventFilter=\"%s\"", 
                      (LPCWSTR)(WString)m_isKey );

    //
    // Retrieve the object
    //

    _IWmiObject* pFilterObj;
    hres = m_pNamespace->GetDbInstance(strPath, &pFilterObj);
    if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

    CReleaseMe rm(pFilterObj);

    InitializeHandles(pFilterObj);

    // Extract its properties
    // ======================

    ULONG ulFlags;
    CCompressedString* pcsQuery;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lQueryHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsQuery );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    wszQuery = pcsQuery->CreateWStringCopy().UnbindPtr();

    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
    
HRESULT CPermanentFilter::GetEventNamespace(
                                        DELETE_ME LPWSTR* pwszNamespace)
{
	if(m_isEventNamespace.IsEmpty())
		*pwszNamespace = NULL;
	else
	{
		*pwszNamespace = m_isEventNamespace.CreateLPWSTRCopy();
		if(*pwszNamespace == NULL)
			return WBEM_E_OUT_OF_MEMORY;
	}
    return S_OK;
}
    
SYSFREE_ME BSTR 
CPermanentFilter::ComputeKeyFromObj( IWbemClassObject* pObj )
{
    HRESULT hres;
    
    CWbemPtr<_IWmiObject> pFilterObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pFilterObj );

    if ( FAILED(hres) )
    {
        return NULL;
    }

    InitializeHandles(pFilterObj);

    ULONG ulFlags;
    CCompressedString* pcsKey;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lNameHandle, 
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsKey );
    if( hres != S_OK )
    {
        return NULL;
    }

    return pcsKey->CreateBSTRCopy();
}

SYSFREE_ME BSTR CPermanentFilter::ComputeKeyFromPath(
                                    LPCWSTR wszPath)
{
    // Find the first quote
    // ====================

    WCHAR* pwcFirstQuote = wcschr(wszPath, L'"');
    if(pwcFirstQuote == NULL)
        return NULL;

    // Find the next quote
    // ===================

    WCHAR* pwcLastQuote = wcschr(pwcFirstQuote+1, L'"');
    if(pwcLastQuote == NULL)
        return NULL;

    return SysAllocStringLen(pwcFirstQuote+1, pwcLastQuote - pwcFirstQuote - 1);
}


HRESULT CPermanentFilter::CheckValidity( IWbemClassObject* pObj )
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pFilterObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pFilterObj );

    if ( FAILED(hres) )
    {
        return hres;
    }

    InitializeHandles(pFilterObj);

    //
    // Check class
    //

    if(pFilterObj->InheritsFrom(L"__EventFilter") != S_OK)
        return WBEM_E_INVALID_OBJECT;

    //
    // Check the query language
    //

    ULONG ulFlags;
    CCompressedString* pcsLanguage;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lLanguageHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsLanguage );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_QUERY_TYPE;
    }

    if(pcsLanguage->CompareNoCase("WQL") != 0)
        return WBEM_E_INVALID_QUERY_TYPE;

    //
    // Get the query
    //

    CCompressedString* pcsQuery;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lQueryHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsQuery );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    LPWSTR wszQuery = pcsQuery->CreateWStringCopy().UnbindPtr();
    
    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    
    CVectorDeleteMe<WCHAR> vdm(wszQuery);

    //
    // Make sure it is parsable
    //
    
    CTextLexSource src(wszQuery);
    QL1_Parser parser(&src);
    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    int nRes = parser.Parse(&pExp);
    if (nRes)
        return WBEM_E_UNPARSABLE_QUERY;
    delete pExp;

    return WBEM_S_NO_ERROR;
}

HRESULT CPermanentFilter::ObtainToken(IWbemToken** ppToken)
{
    // 
    // Get us a token from the token cache
    //

    return m_pNamespace->GetToken(GetOwner(), ppToken);
}

void CPermanentFilter::Park()
{
    if(m_pcsQuery)
        CTemporaryHeap::Free(m_pcsQuery, m_pcsQuery->GetLength());
    m_pcsQuery = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\permcons.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  STDCONS.CPP
//
//  This file implements the class for standard event consumer.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include "permcons.h"
#include "ess.h"
#include <wbemidl.h>
#include "wbemutil.h"
#include <cominit.h>
#include <genutils.h>
#include "NCEvents.h"


#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_ERROR_SERVER_UNAVAILABLE	1722L
#define HRESULT_ERROR_CALL_FAILED_DNE		1727L

long CPermanentConsumer::mstatic_lMaxQueueSizeHandle = 0;
long CPermanentConsumer::mstatic_lSidHandle = 0;
bool CPermanentConsumer::mstatic_bHandlesInitialized = false;

// static 
HRESULT CPermanentConsumer::InitializeHandles( _IWmiObject* pObject)
{
    if(mstatic_bHandlesInitialized)
        return S_FALSE;

    CIMTYPE ct;
    pObject->GetPropertyHandle(CONSUMER_MAXQUEUESIZE_PROPNAME, &ct, 
                                    &mstatic_lMaxQueueSizeHandle);
    pObject->GetPropertyHandleEx(OWNER_SID_PROPNAME, 0, &ct, 
                                    &mstatic_lSidHandle);

    mstatic_bHandlesInitialized = true;
    return S_OK;
}

//******************************************************************************
//  public
//
//  See stdcons.h for documentation
//
//******************************************************************************
CPermanentConsumer::CPermanentConsumer(CEssNamespace* pNamespace)
 : CEventConsumer(pNamespace), m_pCachedSink(NULL), m_pLogicalConsumer(NULL),
        m_dwLastDelivery(GetTickCount())
{
    pNamespace->IncrementObjectCount();
}

HRESULT CPermanentConsumer::Initialize(IWbemClassObject* pObj)
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pActualConsumer;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pActualConsumer );

    if ( FAILED(hres) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    InitializeHandles(pActualConsumer);

    // Get the "database key" --- unique identifier
    // ============================================

    BSTR strStandardPath;
    hres = pActualConsumer->GetNormalizedPath( 0, &strStandardPath );
    if(FAILED(hres))
        return hres;

    CSysFreeMe sfm1(strStandardPath);
    if(!(m_isKey = strStandardPath))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // set the queueing sink name to the consumer name.  
    // TODO : this is temporary and will go away when the consumer no longer
    // inherits from queueing sink.
    //

    hres = SetName( strStandardPath );

    if ( FAILED(hres) )
    {
        return hres;
    }

    // Get the maximum queue size, if specified
    // ========================================

    DWORD dwMaxQueueSize;
    hres = pActualConsumer->ReadDWORD(mstatic_lMaxQueueSizeHandle, 
                                        &dwMaxQueueSize);
    if(hres == S_OK)
        SetMaxQueueSize(dwMaxQueueSize);

    // Get the SID
    // ===========

    if(IsNT())
    {
        PSID pSid;
        ULONG ulNumElements;

        hres = pActualConsumer->GetArrayPropAddrByHandle( mstatic_lSidHandle,
                                                          0,
                                                          &ulNumElements,
                                                          &pSid );
        if ( hres != S_OK )
        {
            return WBEM_E_INVALID_OBJECT;
        }
        
        m_pOwnerSid = new BYTE[ulNumElements];

        if ( m_pOwnerSid == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy( m_pOwnerSid, pSid, ulNumElements );
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See stdcons.h for documentation
//
//******************************************************************************
CPermanentConsumer::~CPermanentConsumer()
{
    if(m_pCachedSink) 
    {
        FireSinkUnloadedEvent();

        m_pCachedSink->Release();
    }

    if(m_pNamespace)
        m_pNamespace->DecrementObjectCount();
    if(m_pLogicalConsumer)
        m_pLogicalConsumer->Release();
}

HRESULT CPermanentConsumer::RetrieveProviderRecord(
                        RELEASE_ME CConsumerProviderRecord** ppRecord,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer)
{
    HRESULT hres;

    // Retrieve our logical consumer instance
    // ======================================

    _IWmiObject* pLogicalConsumer = NULL;
    WString wsKey = m_isKey;
    hres = m_pNamespace->GetDbInstance((LPCWSTR)wsKey, &pLogicalConsumer);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pLogicalConsumer);

    *ppRecord = m_pNamespace->GetConsumerProviderCache().GetRecord(
                    pLogicalConsumer);
    if(*ppRecord == NULL)
    {
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }
    else
    {
        if(pLogicalConsumer && ppLogicalConsumer)
        {
            *ppLogicalConsumer = pLogicalConsumer;
            (*ppLogicalConsumer)->AddRef();
        }
    }

    return WBEM_S_NO_ERROR;
}
        
//******************************************************************************
//
//  RetrieveConsumer
//
//  Have consumer provider produce a sink for this logical consumer
//
//******************************************************************************
HRESULT CPermanentConsumer::RetrieveSink(
                        RELEASE_ME IWbemUnboundObjectSink** ppSink, 
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer)
{
    // Check if one is cached
    // ======================

    {
        CInCritSec ics(&m_cs);
        if(m_pCachedSink)
        {
            *ppSink = m_pCachedSink;
            (*ppSink)->AddRef();
            *ppLogicalConsumer = m_pLogicalConsumer;
            if(*ppLogicalConsumer)
                (*ppLogicalConsumer)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // Not cached. Retrieve one
    // ========================

    HRESULT hres = ObtainSink(ppSink, ppLogicalConsumer);
    if(FAILED(hres))
        return hres;

    m_pNamespace->EnsureConsumerWatchInstruction();

    // Cache it, if needed
    // ===================

    {
        CInCritSec ics(&m_cs);

        if(m_pCachedSink)
        {
            if(m_pCachedSink != (*ppSink))
            {
                // Drop ours, and use the one that's there
                // =======================================
    
                (*ppSink)->Release();
                *ppSink = m_pCachedSink;
                (*ppSink)->AddRef();
            }
        
            if(m_pLogicalConsumer != *ppLogicalConsumer)
            {
                if(*ppLogicalConsumer)
                    (*ppLogicalConsumer)->Release();
                *ppLogicalConsumer = m_pLogicalConsumer;
                if(*ppLogicalConsumer)
                    (*ppLogicalConsumer)->AddRef();
            }
                
            return WBEM_S_NO_ERROR;
        }
        else
        {
            // Cache it
            // ========

            m_pCachedSink = *ppSink;
            m_pCachedSink->AddRef();

            m_pLogicalConsumer = *ppLogicalConsumer;
            if(m_pLogicalConsumer)
                m_pLogicalConsumer->AddRef();
        }
    }
    
    return WBEM_S_NO_ERROR;
}
        
HRESULT CPermanentConsumer::ObtainSink(
                        RELEASE_ME IWbemUnboundObjectSink** ppSink,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer)
{
    *ppSink = NULL;

    CConsumerProviderRecord* pRecord = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;

    HRESULT hres = RetrieveProviderRecord(&pRecord, &pLogicalConsumer);
    if(FAILED(hres))
        return hres;

    CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);
    CReleaseMe rm2(pLogicalConsumer);

    // Check for global sink shortcut
    // ==============================

    hres = pRecord->GetGlobalObjectSink(ppSink, pLogicalConsumer);
    if(FAILED(hres)) return hres;


    if(*ppSink != NULL)
    {
        // That's it --- this consumer provider provides itself!
        // =====================================================

        *ppLogicalConsumer = pLogicalConsumer;
        if(pLogicalConsumer)
            pLogicalConsumer->AddRef();
        return S_OK;
    }

    hres = pRecord->FindConsumer(pLogicalConsumer, ppSink);
    if(FAILED(hres)) 
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider is unable to instantiate "
            "event consumer %S: error code 0x%X\n", 
                (LPCWSTR)(WString)m_isKey, hres));
        return hres;
    }
    else
    {
        if(hres == WBEM_S_FALSE)
        {
            // Consumer provider says: don't need logical consumer!
            // ====================================================

            *ppLogicalConsumer = NULL;
        }
        else
        {
            *ppLogicalConsumer = pLogicalConsumer;
            (*ppLogicalConsumer)->AddRef();
        }
    }
    return hres;
}

//******************************************************************************
//  
//  ClearCache
//
//  Releases cached event consumer pointers.
//
//******************************************************************************
HRESULT CPermanentConsumer::ClearCache()
{
    //
    // First, clear consumer provider record
    //

    CConsumerProviderRecord* pRecord = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;
    HRESULT hres = RetrieveProviderRecord(&pRecord, &pLogicalConsumer);
    if(SUCCEEDED(hres))
    {
        pLogicalConsumer->Release();
        pRecord->Invalidate();
        pRecord->Release();
    }
        
    // 
    // Need to PostponeRelease outside of the critical section, since
    // it will not actually postpone if done on a delivery thread
    //

    IWbemUnboundObjectSink* pSink = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pCachedSink)
        {
            FireSinkUnloadedEvent();

            pSink = m_pCachedSink;
            m_pCachedSink = NULL;
        }

        if(m_pLogicalConsumer)
        {
            m_pLogicalConsumer->Release();
            m_pLogicalConsumer = NULL;
        }
    }

    _DBG_ASSERT( m_pNamespace != NULL );

    if(pSink)
        m_pNamespace->PostponeRelease(pSink);

    return S_OK;
}

HRESULT CPermanentConsumer::Indicate(IWbemUnboundObjectSink* pSink,
                                    IWbemClassObject* pLogicalConsumer, 
                                    long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure)
{
    HRESULT hres;

    try
    {
        hres = pSink->IndicateToConsumer(pLogicalConsumer, lNumEvents, 
                                            apEvents);
    }
    catch(...)
    {
        ERRORTRACE((LOG_ESS, "Event consumer threw an exception!\n"));
        hres = WBEM_E_PROVIDER_FAILURE;
    }
   
    return hres;
}
    

    
//******************************************************************************
//  public
//
//  See stdcons.h for documentation
//
//******************************************************************************
HRESULT CPermanentConsumer::ActuallyDeliver(long lNumEvents, 
                                IWbemEvent** apEvents, BOOL bSecure, 
                                CEventContext* pContext)
{
    HRESULT hres;

    // Mark "last-delivery" time
    // =========================

    m_dwLastDelivery = GetTickCount();

    // Retrieve the sink to deliver the event into
    // ===========================================

    IWbemUnboundObjectSink* pSink = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;
    hres = RetrieveSink(&pSink, &pLogicalConsumer);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed the first attempt to retrieve the sink to "
            "deliver an event to event consumer %S with error code %X.\n"
            "WMI will reload and retry.\n", 
                (LPCWSTR)(WString)m_isKey, hres));

        return Redeliver(lNumEvents, apEvents, bSecure);
    }

    CReleaseMe rm1(pSink);
    CReleaseMe rm2(pLogicalConsumer);

    // Try to deliver (m_pLogicalConsumer is immutable, so no cs is needed)
    // ====================================================================

    hres = Indicate(pSink, pLogicalConsumer, lNumEvents, apEvents, bSecure);
    if(FAILED(hres))
    {
        // decide whether it's an RPC error code
		DWORD shiftedRPCFacCode = FACILITY_RPC << 16;

		if ( ( ( hres & 0x7FF0000 ) == shiftedRPCFacCode ) || 
             ( HRESULT_ERROR_FUNC(hres) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || 
             ( HRESULT_ERROR_FUNC(hres) == HRESULT_ERROR_CALL_FAILED_DNE ) || 
             ( hres == RPC_E_DISCONNECTED ) )
		{			
			ERRORTRACE((LOG_ESS, "Failed the first attempt to deliver an event to "
				"event consumer %S with error code 0x%X.\n"
				"WMI will reload and retry.\n", 
					(LPCWSTR)(WString)m_isKey, hres));

			return Redeliver(lNumEvents, apEvents, bSecure);
		}
		else
		{
            ReportConsumerFailure(lNumEvents, apEvents, hres);

            ERRORTRACE((LOG_ESS, "Failed to deliver an event to "
				"event consumer %S with error code 0x%X. Dropping event.\n",
				(LPCWSTR)(WString)m_isKey, hres));

			return hres;
		}
    }
    return hres;
}

HRESULT CPermanentConsumer::Redeliver(long lNumEvents, 
                                IWbemEvent** apEvents, BOOL bSecure)
{
    HRESULT hres;

    // Clear everything
    // ================

    ClearCache();

    // Re-retrieve the sink
    // ====================

    IWbemUnboundObjectSink* pSink = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;

    hres = RetrieveSink(&pSink, &pLogicalConsumer);
    if(SUCCEEDED(hres))
    {
        CReleaseMe rm1(pSink);
        CReleaseMe rm2(pLogicalConsumer);
    
        // Re-deliver
        // ==========
    
        hres = Indicate(pSink, pLogicalConsumer, lNumEvents, apEvents, bSecure);
    }

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, 
            "Failed the second attempt to deliver an event to "
            "event consumer %S with error code %X.\n"
            "This event is dropped for this consumer.\n", 
            (LPCWSTR)(WString)m_isKey, hres));

        ReportConsumerFailure(lNumEvents, apEvents, hres);
    }

    return hres;
}

BOOL CPermanentConsumer::IsFullyUnloaded()
{
    return (m_pCachedSink == NULL);
}

HRESULT CPermanentConsumer::Validate(IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    //
    // Retrieve our consumer provider record
    //

    CConsumerProviderRecord* pRecord = NULL;
    hres = RetrieveProviderRecord(&pRecord);
    if(FAILED(hres))
        return hres;

    CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);
    
    //  
    // Get it to validate our logical consumer
    //

    hres = pRecord->ValidateConsumer(pLogicalConsumer);
    return hres;
}

    
    

BOOL CPermanentConsumer::UnloadIfUnusedFor(CWbemInterval Interval)
{
    CInCritSec ics(&m_cs);

    if(m_pCachedSink && 
        GetTickCount() - m_dwLastDelivery > Interval.GetMilliseconds())
    {
        FireSinkUnloadedEvent();

        _DBG_ASSERT( m_pNamespace != NULL );
        m_pNamespace->PostponeRelease(m_pCachedSink);
        m_pCachedSink = NULL;
        
        if(m_pLogicalConsumer)
            m_pLogicalConsumer->Release();
        m_pLogicalConsumer = NULL;

        DEBUGTRACE((LOG_ESS, "Unloading event consumer sink %S\n", 
                   (LPCWSTR)(WString)m_isKey));
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

HRESULT CPermanentConsumer::ResetProviderRecord(LPCWSTR wszProviderRef)
{
    HRESULT hres;

    // Check if anything is even cached
    // ================================

    {
        CInCritSec ics(&m_cs);
        if(m_pCachedSink == NULL)
            return WBEM_S_FALSE;
    }

    // Locate our consumer provider record
    // ===================================

    CConsumerProviderRecord* pRecord = NULL;
    hres = RetrieveProviderRecord(&pRecord);
    if(FAILED(hres))
        return hres;
    CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);

    if(!wbem_wcsicmp(pRecord->GetProviderRef(), wszProviderRef))
    {
        ClearCache();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_S_FALSE;
    }
}

SYSFREE_ME BSTR CPermanentConsumer::ComputeKeyFromObj(
                                        CEssNamespace* pNamespace,
                                        IWbemClassObject* pObj)
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pConsumerObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pConsumerObj );

    if ( FAILED(hres) )
    {
        return NULL;
    }

    BSTR strStandardPath = NULL;

    hres = pConsumerObj->GetNormalizedPath( 0, &strStandardPath );
    if(FAILED(hres))
        return NULL;

    return strStandardPath;
}

HRESULT CPermanentConsumer::ReportQueueOverflow(IWbemEvent* pEvent, 
                                                    DWORD dwQueueSize)
{
    HRESULT hres;

    if(CEventConsumer::ReportEventDrop(pEvent) != S_OK)
        return S_FALSE;

    // Construct event instance
    // ========================

    IWbemEvent* pErrorEvent = NULL;
    hres = ConstructErrorEvent(QUEUE_OVERFLOW_CLASS, pEvent, &pErrorEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pErrorEvent);

    // Fill in the queue size
    // ======================

    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = dwQueueSize;

    hres = pErrorEvent->Put(QUEUE_OVERFLOW_SIZE_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    // Raise it
    // ========

    hres = m_pNamespace->RaiseErrorEvent(pErrorEvent,TRUE);
    return hres;
}

HRESULT CPermanentConsumer::ReportConsumerFailure(long lNumEvents,
                                IWbemEvent** apEvents,  HRESULT hresError)
{
    HRESULT hres;

    //
    // Compute the error object to use
    //

    _IWmiObject* pErrorObj = NULL;

    //
    // Get it from the thread
    //

    IErrorInfo* pErrorInfo = NULL;
    hres = GetErrorInfo(0, &pErrorInfo);
    if(hres != S_OK)
    {
        pErrorInfo = NULL;
    }
    else
    {
        hres = pErrorInfo->QueryInterface(IID__IWmiObject, (void**)&pErrorObj);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Non-WMI error object found returned by event "
                "consumer.  Error object ignored\n"));
            pErrorObj = NULL;
        }
    }

    CReleaseMe rm1(pErrorObj);

    for(long l = 0; l < lNumEvents; l++)
    {
        ReportConsumerFailure(apEvents[l], hresError, pErrorObj);
    }

    return S_OK;
}

HRESULT CPermanentConsumer::ReportConsumerFailure(IWbemEvent* pEvent, 
                                                    HRESULT hresError,
                                                    _IWmiObject* pErrorObj)
{
    HRESULT hres;

    if(CEventConsumer::ReportEventDrop(pEvent) != S_OK)
        return S_FALSE;

    //
    // Construct event instance
    //

    IWbemEvent* pErrorEvent = NULL;
    hres = ConstructErrorEvent(CONSUMER_FAILURE_CLASS, pEvent, &pErrorEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pErrorEvent);

    //
    // Fill in the error code
    //

    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = hresError;

    hres = pErrorEvent->Put(CONSUMER_FAILURE_ERROR_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    if(pErrorObj)
    {
        //
        // Fill in the error object
        //
    
        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = pErrorObj;
    
        hres = pErrorEvent->Put(CONSUMER_FAILURE_ERROROBJ_PROPNAME, 0, &v, 0);
        if(FAILED(hres))
        {
            //
            // That's OK, sometimes error objects are not supported
            //
        }
    }

    // Raise it
    // ========

    hres = m_pNamespace->RaiseErrorEvent(pErrorEvent,TRUE);
    return hres;
}

HRESULT CPermanentConsumer::ReportQosFailure( IWbemEvent* pEvent, 
                                              HRESULT hresError )
{
    HRESULT hres;

    if(CEventConsumer::ReportEventDrop(pEvent) != S_OK)
        return S_FALSE;

    // Construct event instance
    // ========================

    IWbemEvent* pErrorEvent = NULL;
    hres = ConstructErrorEvent(QOS_FAILURE_CLASS, pEvent, &pErrorEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pErrorEvent);

    // Fill in the error code
    // ======================

    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = hresError;

    hres = pErrorEvent->Put(QOS_FAILURE_ERROR_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    // Raise it
    // ========

    hres = m_pNamespace->RaiseErrorEvent(pErrorEvent,TRUE);
    return hres;
}
    

HRESULT CPermanentConsumer::ConstructErrorEvent(LPCWSTR wszEventClass,
                                IWbemEvent* pEvent, IWbemEvent** ppErrorEvent)
{
    HRESULT hres;

    _IWmiObject* pClass = NULL;
    hres = m_pNamespace->GetClass(wszEventClass, &pClass);
    if(FAILED(hres)) 
        return hres;
    CReleaseMe rm2(pClass);

    IWbemClassObject* pErrorEvent = NULL;
    hres = pClass->SpawnInstance(0, &pErrorEvent);
    if(FAILED(hres)) 
        return hres;
    CReleaseMe rm3(pErrorEvent);

    VARIANT v;
    VariantInit(&v);
    
    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = pEvent;

    hres = pErrorEvent->Put(EVENT_DROP_EVENT_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    BSTR strTemp = SysAllocString((WString)m_isKey);

    if ( NULL == strTemp )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = strTemp;
        
    hres = pErrorEvent->Put(EVENT_DROP_CONSUMER_PROPNAME, 0, &v, 0);
    VariantClear(&v);
    if(FAILED(hres))
        return hres;
    
    *ppErrorEvent = pErrorEvent;
    pErrorEvent->AddRef();
    return S_OK;
}

void CPermanentConsumer::FireSinkUnloadedEvent()
{
    CConsumerProviderRecord *pRecord = NULL;
    IWbemClassObject        *pLogicalConsumer = NULL;

    if (SUCCEEDED(RetrieveProviderRecord(&pRecord, &pLogicalConsumer)))
    {
        CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);
        CReleaseMe rm2(pLogicalConsumer);
        
        //
        // Report the MSFT_WmiConsumerProviderSinkUnloaded event.
        //
        pRecord->FireNCSinkEvent(
            MSFT_WmiConsumerProviderSinkUnloaded,
            pLogicalConsumer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\permfilt.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  STDTRIG.H
//
//  This files defines the classes for event filters corresponding to standard
//  event filters the users will create
//
//  Classes defined:
//
//      CBuiltinEventFilter         Base class for standard filters
//
//  History:
//
//  11/27/96    a-levn      Compiles
//
//=============================================================================

#ifndef __BUILTIN_FILTER__H_
#define __BUILTIN_FILTER__H_

#include "eventrep.h"
#include "binding.h"
#include "aggreg.h"
#include "filter.h"

class CEssNamespace;
class CPermanentFilter : public CGenericFilter
{
protected:
    CCompressedString* m_pcsQuery;
    CInternalString m_isEventNamespace;

    PSECURITY_DESCRIPTOR m_pEventAccessRelativeSD;
    SECURITY_DESCRIPTOR m_EventAccessAbsoluteSD;

    static long mstatic_lNameHandle;
    static long mstatic_lLanguageHandle;
    static long mstatic_lQueryHandle;
    static long mstatic_lEventNamespaceHandle;
    static long mstatic_lEventAccessHandle;
    static long mstatic_lSidHandle;
    static bool mstatic_bHandlesInitialized;

    static HRESULT InitializeHandles(_IWmiObject* pObject);
protected:
    static SYSFREE_ME BSTR GetBSTR(READ_ONLY IWbemClassObject* pObject, 
        READ_ONLY LPWSTR wszName);
    HRESULT RetrieveQuery(DELETE_ME LPWSTR& wszQuery);

public:
    CPermanentFilter(CEssNamespace* pNamespace);
    HRESULT Initialize(IWbemClassObject* pFilterObj);

    virtual ~CPermanentFilter();

    BOOL IsPermanent() {return TRUE;}
    virtual HRESULT SetThreadSecurity( IUnknown** ppNewCtx ) 
        { *ppNewCtx = NULL; return S_OK; }
    HRESULT ObtainToken(IWbemToken** ppToken);

    virtual const PSECURITY_DESCRIPTOR GetEventAccessSD();

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp);
    virtual DWORD GetForceFlags() {return 0;}
    virtual HRESULT GetEventNamespace(DELETE_ME LPWSTR* pwszNamespace);
    static SYSFREE_ME BSTR ComputeKeyFromObj(IWbemClassObject* pFilterObj);
    static SYSFREE_ME BSTR ComputeKeyFromPath(LPCWSTR wszPath);
    static HRESULT CheckValidity( IWbemClassObject* pFilterObj);

    void Park();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\poller.cpp ===
//******************************************************************************
//
//  POLLER.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include <cominit.h>
#include <callsec.h>
#include "Quota.h"
#include <comdef.h>
#include <GroupsForUser.h>

long g_lNumPollingCachedObjects = 0;
long g_lNumPollingInstructions = 0;

// {2ECF39D0-2B26-11d2-AEC8-00C04FB68820}
const GUID IID_IWbemCallSecurity = {
0x2ecf39d0, 0x2b26, 0x11d2, {0xae, 0xc8, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20}};


void CBasePollingInstruction::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CBasePollingInstruction::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0) 
    {
        if(DeleteTimer())
        {
            delete this;
        }
        else
        {
            //
            // Deep trouble --- cannot delete timer, so it will execute again.
            // This means I must leak this instruction (to prevent a crash)
            //
        }
    }
}

CBasePollingInstruction::CBasePollingInstruction(CEssNamespace* pNamespace)
    : m_pNamespace(pNamespace), m_strLanguage(NULL), m_strQuery(NULL),
        m_pSecurity(NULL), m_lRef(0), m_bUsedQuota(false),
        m_bCancelled(false), m_hTimer(NULL)
{
    pNamespace->AddRef();
}

CBasePollingInstruction::~CBasePollingInstruction()
{
    Destroy();
}

void CBasePollingInstruction::Destroy()
{
    //
    // The timer is guaranteed to have been deleted by the Release
    //

    _DBG_ASSERT(m_hTimer == NULL);

    if(m_pNamespace)
        m_pNamespace->Release();

    SysFreeString(m_strLanguage);
    SysFreeString(m_strQuery);

    if (m_bUsedQuota)
    {
        if (m_pSecurity)
            m_pSecurity->ImpersonateClient();

        g_quotas.DecrementQuotaIndex(
            ESSQ_POLLING_INSTRUCTIONS,
            NULL,
            1);

        if (m_pSecurity)
            m_pSecurity->RevertToSelf();
    }

    if(m_pSecurity)
        m_pSecurity->Release();
}

bool CBasePollingInstruction::DeleteTimer()
{
    HANDLE hTimer = NULL;

    {
        CInCritSec ics(&m_cs);
        
        hTimer = m_hTimer;
        m_bCancelled = true;
    }

    if(hTimer)
    {
        if(!DeleteTimerQueueTimer(NULL, hTimer, INVALID_HANDLE_VALUE))
        {
            return false;
        }
        m_hTimer = NULL; // no need for cs --- it's cancelled!
    }

    return true;
}

CWbemTime CBasePollingInstruction::GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const
{
    *plFiringCount = 1;

    CWbemTime Next = LastFiringTime + m_Interval;
    if(Next < CWbemTime::GetCurrentTime())
    {
        // We missed a poll. No problem --- reschedule for later
        // =====================================================

        return CWbemTime::GetCurrentTime() + m_Interval;
    }
    else
    {
        return Next;
    }
}

CWbemTime CBasePollingInstruction::GetFirstFiringTime() const
{
    // The first time is a random function of the interval
    // ===================================================

    double dblFrac = (double)rand() / RAND_MAX;
    return CWbemTime::GetCurrentTime() + m_Interval * dblFrac;
}

HRESULT CBasePollingInstruction::Initialize(LPCWSTR wszLanguage, 
                                        LPCWSTR wszQuery, DWORD dwMsInterval,
                                        bool bAffectsQuota)
{
    m_strLanguage = SysAllocString(wszLanguage);
    m_strQuery = SysAllocString(wszQuery);
    if(m_strLanguage == NULL || m_strQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_Interval.SetMilliseconds(dwMsInterval);
    
    //
    // Retrieve the current security object.  Even though it is ours, we cannot
    // keep it, since it is shared by other threads
    //
    
    HRESULT hres = WBEM_S_NO_ERROR;

    m_pSecurity = CWbemCallSecurity::MakeInternalCopyOfThread();

    if (bAffectsQuota)
    {
        if ( m_pSecurity )
        {
            hres = m_pSecurity->ImpersonateClient();


            if ( FAILED(hres) )
            {
                ERRORTRACE((LOG_ESS, "Polling instruction for query %S failed "
                            "to impersonate client during initialization.\n",
                             wszQuery ));
                return hres;
            }
        }

        hres = 
            g_quotas.IncrementQuotaIndex(
                ESSQ_POLLING_INSTRUCTIONS,
                NULL,
                1);

        if (m_pSecurity)
            m_pSecurity->RevertToSelf();

        if (SUCCEEDED(hres))
            m_bUsedQuota = true;
    }

    return hres;
}

void CBasePollingInstruction::staticTimerCallback(void* pParam, BOOLEAN)
{
    CBasePollingInstruction* pInst = (CBasePollingInstruction*)pParam;

    try
    {
        pInst->ExecQuery();
    }
    catch( CX_MemoryException )
    {
    }

    // 
    // Reschedule the timer, if needed
    //

    {
        CInCritSec ics(&pInst->m_cs);

        //
        // First, check if the instruction has been cancelled
        //

        if(pInst->m_bCancelled)
            return;

        //
        // Delete ourselves
        //

        _DBG_ASSERT(pInst->m_hTimer != NULL);

        DeleteTimerQueueTimer(NULL, pInst->m_hTimer, NULL);

        CreateTimerQueueTimer(&pInst->m_hTimer, NULL, 
                                (WAITORTIMERCALLBACK)&staticTimerCallback, 
                                pParam,
                                pInst->m_Interval.GetMilliseconds(),
                                0, 
                                WT_EXECUTELONGFUNCTION);
    }
}
    
HRESULT CBasePollingInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    return ExecQuery();
}

void CBasePollingInstruction::Cancel()
{
    m_bCancelled = true;
}


HRESULT CBasePollingInstruction::ExecQuery()
{
    HRESULT hres;

    // Impersonate
    // ===========

    if(m_pSecurity)
    {
        hres = m_pSecurity->ImpersonateClient();
        if(FAILED(hres) && (hres != E_NOTIMPL))
        {
            ERRORTRACE((LOG_ESS, "Impersonation failed with error code %X for "
                "polling query %S.  Will retry at next polling interval\n",
                hres, m_strQuery));
            return hres;
        }
    }

    // Execute the query synchrnously (TBD: async would be better)
    // ==============================

    IWbemServices* pServices = NULL;
    hres = m_pNamespace->GetNamespacePointer(&pServices);

    if(FAILED(hres))
    	{
	if(m_pSecurity) m_pSecurity->RevertToSelf();
        return hres;
    	}
    CReleaseMe rm1(pServices);
    
    DEBUGTRACE((LOG_ESS, "Executing polling query '%S' in namespace '%S'\n",
                m_strQuery, m_pNamespace->GetName()));

    IEnumWbemClassObject* pEnum;
    hres = pServices->ExecQuery(m_strLanguage, m_strQuery, 
                        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY |
                        WBEM_FLAG_KEEP_SHAPE, 
                                            GetCurrentEssContext(), &pEnum);
	
    if(m_pSecurity)
        m_pSecurity->RevertToSelf();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Polling query %S failed with error code %X.  "
            "Will retry at next polling interval\n", m_strQuery, hres));
        return hres;
    }
    CReleaseMe rm2(pEnum);

    // Get the results into an array
    // =============================

    IWbemClassObject* aBuffer[100];
    DWORD dwNumRet;
    while(1)
    {
        hres = pEnum->Next(1000, 100, aBuffer, &dwNumRet);
        if(FAILED(hres))
            break;

        bool bDone = false;
        if(hres == WBEM_S_FALSE)
            bDone = true;

        //
        // Check if this query has been cancelled
        //

        if(m_bCancelled)
        {
            DEBUGTRACE((LOG_ESS, "Aborting polling query '%S' because its "
                "subscription is cancelled\n", m_strQuery));
            return WBEM_E_CALL_CANCELLED;
        }

        for(DWORD dw = 0; dw < dwNumRet; dw++)
        {
            _IWmiObject* pObj = NULL;
            aBuffer[dw]->QueryInterface(IID__IWmiObject, (void**)&pObj);
            CReleaseMe rm(pObj);

            hres = ProcessObject(pObj);
            
            if(FAILED(hres))
                break;
        }

        for( dw=0; dw < dwNumRet; dw++ )
        {
            aBuffer[dw]->Release();
        }

        if(dw < dwNumRet || FAILED(hres))
            break;

        if(bDone)
            break;
    }

    ProcessQueryDone(hres, NULL);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Polling query '%S' failed with error code 0x%X.  "
            "Will retry at next polling interval\n", m_strQuery, hres));
        return hres;
    }
    else
    {
        DEBUGTRACE((LOG_ESS, "Polling query '%S' done\n", m_strQuery));
    }

    return WBEM_S_NO_ERROR;
}
    
BOOL CBasePollingInstruction::CompareTo(CBasePollingInstruction* pOther)
{
    if(wcscmp(pOther->m_strLanguage, m_strLanguage)) return FALSE;
    if(wcscmp(pOther->m_strQuery, m_strQuery)) return FALSE;
    if(pOther->m_Interval.GetMilliseconds() != m_Interval.GetMilliseconds())
        return FALSE;

    return TRUE;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************

CPollingInstruction::CCachedObject::CCachedObject(_IWmiObject* pObject)
    : m_pObject(pObject), m_strPath(NULL)
{
    g_lNumPollingCachedObjects++;
    
    // Extract the path
    // ================

    VARIANT v;
    VariantInit(&v);
    if (SUCCEEDED(pObject->Get(L"__RELPATH", 0, &v, NULL, NULL)) && (V_VT(&v) == VT_BSTR))
        m_strPath = V_BSTR(&v);

    // Variant intentionally not cleared
    pObject->AddRef();
}

CPollingInstruction::CCachedObject::~CCachedObject()
{
    g_lNumPollingCachedObjects--;

    if(m_pObject)
        m_pObject->Release();
    if(NULL != m_strPath)
        SysFreeString(m_strPath);
}

int __cdecl CPollingInstruction::CCachedObject::compare(const void* pelem1, 
                                                        const void* pelem2)
{
    CCachedObject* p1 = *(CCachedObject**)pelem1;
    CCachedObject* p2 = *(CCachedObject**)pelem2;

    if((p1->m_strPath != NULL) && (p2->m_strPath != NULL))
      return wbem_wcsicmp(p1->m_strPath, p2->m_strPath);
    else if(p1->m_strPath == p2->m_strPath)
      return 0;
    else 
      return 1;
}

CPollingInstruction::CPollingInstruction(CEssNamespace* pNamespace)
: CBasePollingInstruction(pNamespace), m_papCurrentObjects(NULL),
  m_dwEventMask(0), m_pDest(NULL),  m_papPrevObjects(NULL), m_pUser(NULL)
{
    g_lNumPollingInstructions++;
}

CPollingInstruction::~CPollingInstruction()
{
    g_lNumPollingInstructions--;

    SubtractMemory(m_papCurrentObjects);
    delete m_papCurrentObjects;

    ResetPrevious();

    if(m_pDest)
        m_pDest->Release();

    if(m_pUser)
        g_quotas.FreeUser(m_pUser);
}

// This class represents a postponed request to execute a query
class CPostponedQuery : public CPostponedRequest
{
protected:
    CPollingInstruction* m_pInst;

public:
    CPostponedQuery(CPollingInstruction* pInst) : m_pInst(pInst)
    {
        m_pInst->AddRef();
    }
    ~CPostponedQuery()
    {
        m_pInst->Release();
    }
    
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        return m_pInst->FirstExecute();
    }
};

HRESULT CPollingInstruction::FirstExecute()
{
    //
    // Check if our filter has any hope
    //

    if(FAILED(m_pDest->GetPollingError()))
    {
        DEBUGTRACE((LOG_ESS, "Polling query '%S' will not be attempted as \n"
            "another polling query related to the same subscription has failed "
            "to start with error code 0x%X, deactivating subscription\n", 
            m_strQuery, m_pDest->GetPollingError()));
        return m_pDest->GetPollingError();
    }

    if(m_bCancelled)
    {
        DEBUGTRACE((LOG_ESS, "Aborting polling query '%S' because its "
            "subscription is cancelled\n", m_strQuery));
        return WBEM_E_CALL_CANCELLED;
    }

    // note that if this function fails, then it will be destroyed when 
    // the postponed query releases it reference.  If this function succeedes
    // then tss will hold onto a reference and keep it alive.
    //

    m_papCurrentObjects = _new CCachedArray;
    
    if( m_papCurrentObjects == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hres = ExecQuery();

    if ( FAILED(hres) )
    {
        ERRORTRACE((LOG_ESS, "Polling query '%S' failed on the first try with "
            "error code 0x%X.\nDeactivating subscription\n", m_strQuery, hres));
        m_pDest->SetPollingError(hres);
        return hres;
    }

    //
    // add this instruction to the scheduler
    //
   
    if(!CreateTimerQueueTimer(&m_hTimer, NULL, 
                                (WAITORTIMERCALLBACK)&staticTimerCallback, 
                                (void*)(CBasePollingInstruction*)this,
                                m_Interval.GetMilliseconds(), 
                                0, 
                                WT_EXECUTELONGFUNCTION))
    {
        long lRes = GetLastError();
        ERRORTRACE((LOG_ESS, "ESS is unable to schedule a timer instruction "
            "with the system (error code %d).  This operation will be "
            "aborted.\n", lRes));
    
        return WBEM_E_FAILED;
    }
        
    return WBEM_S_NO_ERROR;
}

HRESULT CPollingInstruction::Initialize(LPCWSTR wszLanguage, LPCWSTR wszQuery, 
                        DWORD dwMsInterval, DWORD dwEventMask, 
                        CEventFilter* pDest)
{
    HRESULT hres;

    hres = CBasePollingInstruction::Initialize(wszLanguage, wszQuery, 
                                                dwMsInterval);
    if(FAILED(hres))
        return hres;

    m_dwEventMask = dwEventMask;

    m_pDest = pDest;
    pDest->AddRef();

    hres = g_quotas.FindUser(pDest, &m_pUser);
    if(FAILED(hres))
        return hres;
    
    return WBEM_S_NO_ERROR;
}

HRESULT CPollingInstruction::ProcessObject(_IWmiObject* pObj)
{
    HRESULT hres;

    //
    // Make sure that the current object list exists
    //

    if(m_papCurrentObjects == NULL)
    {
        m_papCurrentObjects = new CCachedArray;
        if(m_papCurrentObjects == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Check if this query has been cancelled
    //

    if(m_bCancelled)
    {
        DEBUGTRACE((LOG_ESS, "Aborting polling query '%S' because its "
            "subscription is cancelled\n", m_strQuery));
        return WBEM_E_CALL_CANCELLED;
    }

    //
    // Check quotas
    //

    DWORD dwSize = ComputeObjectMemory(pObj);

    hres = g_quotas.IncrementQuotaIndexByUser(ESSQ_POLLING_MEMORY,
                            m_pUser, dwSize);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Aborting polling query '%S' because the quota "
            "for memory used by polling is exceeded\n", m_strQuery));
        return hres;
    }

    //
    // Add the object to the current list
    //

    CCachedObject* pRecord = _new CCachedObject(pObj);
    if(pRecord == NULL || !pRecord->IsValid())
    {
        delete pRecord;
        return WBEM_E_OUT_OF_MEMORY;
    }


    if(m_papCurrentObjects->Add(pRecord) < 0)
    {
        delete pRecord;
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    return WBEM_S_NO_ERROR;
}

DWORD CPollingInstruction::ComputeObjectMemory(_IWmiObject* pObj)
{
    DWORD dwSize = 0;
    HRESULT hres = pObj->GetObjectMemory( NULL, 0, &dwSize );
    
    if (FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL )
    {
        return hres;
    }
    
    return dwSize;
}

HRESULT CPollingInstruction::ProcessQueryDone( HRESULT hresQuery, 
                                               IWbemClassObject* pErrorObj)
{
    HRESULT hres;

    if(FAILED(hresQuery))
    {
        //
        // If the query failed, retain the previous poll 
        // result --- that's the best we can do
        //

        SubtractMemory(m_papCurrentObjects);
        delete m_papCurrentObjects;
        m_papCurrentObjects = NULL;

        //
        // Report subscription error
        //

        return WBEM_S_FALSE;
    }
    else if ( m_papCurrentObjects == NULL )
    {
        //
        // Query came back empty --- emulate by creating an empty 
        // m_papCurrentObjects
        //

        m_papCurrentObjects = new CCachedArray;
        if(m_papCurrentObjects == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
                
    //
    // Sort the objects by path
    // 

    qsort((void*)m_papCurrentObjects->GetArrayPtr(), 
          m_papCurrentObjects->GetSize(), 
          sizeof(CCachedObject*), CCachedObject::compare);

    //
    // At this point, m_papCurrentObjects contains the sorted results of the
    // current query. If this is not the first time, m_papPrevObjects 
    // contains the previous result.  If first time, then all done for now.
    //

    if( m_papPrevObjects == NULL )
    {
        m_papPrevObjects = m_papCurrentObjects;
        m_papCurrentObjects = NULL;
        return WBEM_S_NO_ERROR;
    }

    //
    // Now is the time to compare
    //

    long lOldIndex = 0, lNewIndex = 0;

    while(lNewIndex < m_papCurrentObjects->GetSize() && 
          lOldIndex < m_papPrevObjects->GetSize())
    {
        int nCompare = 1;
        BSTR bstr1 = m_papCurrentObjects->GetAt(lNewIndex)->m_strPath, 
             bstr2 = m_papPrevObjects->GetAt(lOldIndex)->m_strPath;

        if((bstr1 != NULL) && (bstr2 != NULL))
           nCompare = wbem_wcsicmp(bstr1, bstr2);
        else if (bstr1 == bstr2)
           nCompare = 0;
        else
           nCompare = 1;
     
        if(nCompare < 0)
        {
            // The _new object is not in the old array --- object created
            // =========================================================

            if(m_dwEventMask & (1 << e_EventTypeInstanceCreation))
            {
                RaiseCreationEvent(m_papCurrentObjects->GetAt(lNewIndex));
            }
            lNewIndex++;
        }
        else if(nCompare > 0)
        {
            // The old object is not in the _new array --- object deleted
            // =========================================================
                
            if(m_dwEventMask & (1 << e_EventTypeInstanceDeletion))
            {
                RaiseDeletionEvent(m_papPrevObjects->GetAt(lOldIndex));
            }
            lOldIndex++;
        }
        else
        {
            if(m_dwEventMask & (1 << e_EventTypeInstanceModification))
            {
                // Compare the objects themselves
                // ==============================

                hres = m_papCurrentObjects->GetAt(lNewIndex)->m_pObject->
                    CompareTo(
                        WBEM_FLAG_IGNORE_CLASS | WBEM_FLAG_IGNORE_OBJECT_SOURCE,
                        m_papPrevObjects->GetAt(lOldIndex)->m_pObject);
                if(hres != S_OK)
                {
                    // The objects are not the same --- object changed
                    // ===============================================
        
                    RaiseModificationEvent(
                        m_papCurrentObjects->GetAt(lNewIndex),
                        m_papPrevObjects->GetAt(lOldIndex));
                }
            }
            lOldIndex++; lNewIndex++;
        }
    }
    
    if(m_dwEventMask & (1 << e_EventTypeInstanceDeletion))
    {
        while(lOldIndex < m_papPrevObjects->GetSize())
        {
            RaiseDeletionEvent(m_papPrevObjects->GetAt(lOldIndex));
            lOldIndex++;
        }
    }

    if(m_dwEventMask & (1 << e_EventTypeInstanceCreation))
    {
        while(lNewIndex < m_papCurrentObjects->GetSize())
        {
            RaiseCreationEvent(m_papCurrentObjects->GetAt(lNewIndex));
            lNewIndex++;
        }
    }

    // Replace the cached array with the new one
    // =========================================

    ResetPrevious();

    m_papPrevObjects = m_papCurrentObjects;
    m_papCurrentObjects = NULL;

    return S_OK;
}
  
HRESULT CPollingInstruction::RaiseCreationEvent(CCachedObject* pNewObj)
{
    IWbemClassObject* _pObj = pNewObj->m_pObject;

    CEventRepresentation Event;
    Event.type = e_EventTypeInstanceCreation;
    Event.wsz1 = (LPWSTR)m_pNamespace->GetName();

    BSTR strTemp = GetObjectClass(pNewObj);
    Event.wsz2 = (LPWSTR)strTemp;
    
    Event.wsz3 = NULL;
    Event.nObjects = 1;
    Event.apObjects = &_pObj;

    CWbemPtr<IWbemEvent> pEventObj;
    if(FAILED(Event.MakeWbemObject(m_pNamespace, &pEventObj)))
        return WBEM_E_OUT_OF_MEMORY;

    // BUGBUG: context
    HRESULT hres = m_pDest->Indicate(1, &pEventObj, NULL);

    SysFreeString(strTemp);
    return hres;
}

HRESULT CPollingInstruction::RaiseDeletionEvent(CCachedObject* pOldObj)
{
    IWbemClassObject* _pObj = pOldObj->m_pObject;

    CEventRepresentation Event;
    Event.type = e_EventTypeInstanceDeletion;
    Event.wsz1 = (LPWSTR)m_pNamespace->GetName();

    BSTR strTemp = GetObjectClass(pOldObj);
    Event.wsz2 = (LPWSTR)strTemp;
    
    Event.wsz3 = NULL;
    Event.nObjects = 1;
    Event.apObjects = &_pObj;

    CWbemPtr<IWbemEvent> pEventObj;
    if(FAILED(Event.MakeWbemObject(m_pNamespace, &pEventObj)))
        return WBEM_E_OUT_OF_MEMORY;

    // BUGBUG: context
    HRESULT hres = m_pDest->Indicate(1, &pEventObj, NULL);

    SysFreeString(strTemp);
    return hres;
}
    
HRESULT CPollingInstruction::RaiseModificationEvent(CCachedObject* pNewObj,
                                                    CCachedObject* pOldObj)
{
    IWbemClassObject* apObjects[2];

    CEventRepresentation Event;
    Event.type = e_EventTypeInstanceModification;
    Event.wsz1 = (LPWSTR)m_pNamespace->GetName();

    BSTR strTemp = GetObjectClass(pNewObj);
    Event.wsz2 = (LPWSTR)strTemp;
    
    Event.wsz3 = NULL;
    Event.nObjects = 2;
    Event.apObjects = (IWbemClassObject**)apObjects;
    Event.apObjects[0] = pNewObj->m_pObject;
    Event.apObjects[1] = (pOldObj?pOldObj->m_pObject:NULL);

    CWbemPtr<IWbemEvent> pEventObj;
    if(FAILED(Event.MakeWbemObject(m_pNamespace, &pEventObj)))
        return WBEM_E_OUT_OF_MEMORY;

    // BUGBUG: context
    HRESULT hres = m_pDest->Indicate(1, &pEventObj, NULL);

    SysFreeString(strTemp);
    return hres;
}

HRESULT CPollingInstruction::ResetPrevious()
{
    HRESULT hres;

    SubtractMemory(m_papPrevObjects);

    delete m_papPrevObjects;
    m_papPrevObjects = NULL;
    
    return S_OK;
}

HRESULT CPollingInstruction::SubtractMemory(CCachedArray* pArray)
{
    HRESULT hres;

    if(pArray == NULL)
        return S_FALSE;

    for(int i = 0; i < pArray->GetSize(); i++)
    {
        _IWmiObject* pObj = pArray->GetAt(i)->m_pObject;

        DWORD dwSize = ComputeObjectMemory(pObj);
        hres = g_quotas.DecrementQuotaIndexByUser(ESSQ_POLLING_MEMORY,
                                m_pUser, dwSize);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}


SYSFREE_ME BSTR CPollingInstruction::GetObjectClass(CCachedObject* pObj)
{
    VARIANT v;
    VariantInit(&v);
    if ( FAILED( pObj->m_pObject->Get(L"__CLASS", 0, &v, NULL, NULL) ) )
    {
        return NULL;
    }
    return V_BSTR(&v);
}

//*****************************************************************************
//*****************************************************************************
//
//                      P o l l e r
//
//*****************************************************************************
//*****************************************************************************

CPoller::CPoller(CEssNamespace* pNamespace)         
    : m_pNamespace(pNamespace), m_bInResync(FALSE)
{
}

CPoller::~CPoller()
{
}

void CPoller::Clear()
{
    CInstructionMap::iterator it = m_mapInstructions.begin(); 
    while(it != m_mapInstructions.end())
    {
        // Release the refcount this holds on the instructioin
        // ===================================================

        it->first->Cancel();
        it->first->DeleteTimer();
        it->first->Release();
        it = m_mapInstructions.erase(it);
    }
}
    
HRESULT CPoller::ActivateFilter(CEventFilter* pDest, 
                LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    // Check what kind of events it is looking for
    // ===========================================

    DWORD dwEventMask = CEventRepresentation::GetTypeMaskFromName(
                            pExpr->bsClassName);

    if((dwEventMask & 
        ((1 << e_EventTypeInstanceCreation) | 
         (1 << e_EventTypeInstanceDeletion) |
         (1 << e_EventTypeInstanceModification)
        )
       ) == 0
      )
    {
        // This registration does not involve instance-related events and
        // therefore there is no polling involved
        // ==============================================================
        
        return WBEM_S_FALSE;
    }

    // The query is looking for instance-change events. See what classes 
    // of objects it is interested in.
    // =================================================================

    CClassInfoArray* paInfos;
    HRESULT hres = m_Analyser.GetPossibleInstanceClasses(pExpr, paInfos);
    if(FAILED(hres)) return hres;
    CDeleteMe<CClassInfoArray> dm2(paInfos);

    if(!paInfos->IsLimited())
    {
        // Analyser could not find any limits on the possible classes.
        // Rephrase that as all children of ""
        // ===========================================================

        CClassInformation* pNewInfo = _new CClassInformation;
        if(pNewInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pNewInfo->m_wszClassName = NULL;
        pNewInfo->m_bIncludeChildren = TRUE;
        paInfos->AddClass(pNewInfo);

        paInfos->SetLimited(TRUE);
    }


    // See if it is looking for any dynamic classes.
    // =============================================
    for(int i = 0; i < paInfos->GetNumClasses(); i++)
    {
        CClassInfoArray aNonProvided;
        hres = ListNonProvidedClasses(
                            paInfos->GetClass(i), dwEventMask, aNonProvided);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,"Failed searching for classes to poll.\n"
                "Class name: %S, Error code: %X\n\n", 
                paInfos->GetClass(i)->m_wszClassName, hres));
            
            return hres;
        }


        // Increment our quotas if necessary.
        DWORD nClasses = aNonProvided.GetNumClasses();

        if (nClasses)
        {
            PSID pSID = pDest->GetOwner( );
            
            if ( pSID && STATUS_SUCCESS != IsUserAdministrator( pSID ) )
            {
                return WBEM_E_ACCESS_DENIED;
            }
            
            if (FAILED(hres = g_quotas.IncrementQuotaIndex(
                                   ESSQ_POLLING_INSTRUCTIONS, pDest, nClasses)))
            {
                return hres;
            }
        }


        // Institute polling for each class
        // ================================
        for(int j = 0; j < nClasses; j++)
        {
            // We have an instance-change event registration where dynamic 
            // instances are involved. Check if tolerance is specified
            // ===========================================================
    
            if(pExpr->Tolerance.m_bExact || 
                pExpr->Tolerance.m_fTolerance == 0)
            {
                return WBEMESS_E_REGISTRATION_TOO_PRECISE;
            }
        
            // Tolerance is there. Get the right query for this class
            // ======================================================

            LPWSTR wszThisQuery = NULL;
            hres = m_Analyser.GetLimitingQueryForInstanceClass(
                        pExpr, *aNonProvided.GetClass(j), wszThisQuery);
            CVectorDeleteMe<WCHAR> vdm1(wszThisQuery);

            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS,"ERROR: Limiting query extraction failed.\n"
                    "Original query: %S\nClass: %S\nError code: %X\n",
                    wszQuery, aNonProvided.GetClass(j)->m_wszClassName, hres));
                return hres;
            }

            DEBUGTRACE((LOG_ESS,"Instituting polling query %S to satisfy event"
                       " query %S\n", wszThisQuery, wszQuery));
    
            DWORD dwMs = pExpr->Tolerance.m_fTolerance * 1000;

            CWbemPtr<CPollingInstruction> pInst;
            pInst = _new CPollingInstruction(m_pNamespace);

            if(pInst == NULL)
                return WBEM_E_OUT_OF_MEMORY;
    
            hres = pInst->Initialize( L"WQL", 
                                      wszThisQuery, 
                                      dwMs, 
                                      aNonProvided.GetClass(j)->m_dwEventMask,
                                      pDest);
            if ( SUCCEEDED(hres) )
            {
                hres = AddInstruction( (DWORD_PTR)pDest, pInst );
            }

            if ( FAILED(hres) )
            {
                ERRORTRACE((LOG_ESS,
                    "ERROR: Polling instruction initialization failed\n"
                    "Query: %S\nError code: %X\n\n", wszThisQuery, hres));
                return hres;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CPoller::AddInstruction( DWORD_PTR dwKey, CPollingInstruction* pInst )
{
    HRESULT hr;
    CInCritSec ics(&m_cs);

    if( m_bInResync )
    {
        // Search for the instruction in the map
        // =====================================

        CInstructionMap::iterator it;
        for( it=m_mapInstructions.begin(); it != m_mapInstructions.end(); it++)
        {
            //
            // if the filter key is the same and the instructions have the 
            // same queries, then there is a match.  It is not enough to 
            // do just the filter key, since there can be multiple instructions
            // per filter, and it is not enough to do just the instruction 
            // comparison since multiple filters can have the same polling 
            // instruction queries.  Since there can never be multiple 
            // instructions with the same query for the same filter, 
            // comparing both works.
            //
            if( it->second.m_dwFilterId == dwKey && 
                it->first->CompareTo( pInst ) )
            {
                //
                // Found it, set to active but DO NOT add to the generator.
                // it is already there
                // 
                it->second.m_bActive = TRUE;
                return WBEM_S_FALSE;
            }
        }
    }
    
    //
    // add to the instruction to the map.
    //

    FilterInfo Info;
    Info.m_dwFilterId = dwKey;
    Info.m_bActive = TRUE;
    
    try
    {
        m_mapInstructions[pInst] = Info;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pInst->AddRef();  

    //
    // Postpone the first execution of the query.  
    // 1. Execution may not be done here, because the namespace is 
    //    locked
    // 2. Execution may not be done asynchronously, because we
    //    must get a baseline reading before returning to the 
    //    client.
    //
    
    CPostponedList* pList = GetCurrentPostponedList();
    _DBG_ASSERT( pList != NULL );

    CPostponedQuery* pReq = new CPostponedQuery( pInst );

    if ( pReq && pList )
    {
        hr = pList->AddRequest( m_pNamespace, pReq );

        if ( FAILED(hr) )
        {
            delete pReq;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        delete pReq;
    }

    if ( FAILED(hr) )
    {
        pInst->Release();
        m_mapInstructions.erase( pInst );
    }

    return hr;
}
    
HRESULT CPoller::DeactivateFilter(CEventFilter* pDest)
{
    CInCritSec ics(&m_cs);

    DWORD_PTR dwKey = (DWORD_PTR)pDest;

    // Remove it from the map
    // ======================

    CInstructionMap::iterator it = m_mapInstructions.begin(); 
    DWORD nItems = 0;

    while(it != m_mapInstructions.end())
    {
        if(it->second.m_dwFilterId == dwKey)
        {
            CBasePollingInstruction* pInst = it->first;
    
            //
            // First, cancel the instruction so that if it is executing, it will
            // abort at the earliest convenience
            //

            pInst->Cancel();

            //
            // Then, deactivate the timer.  This will block until the
            // instruction has finished executing, if it is currently doing so
            //

            pInst->DeleteTimer();

            //
            // Now we are safe --- release the instruction. 
            //

            it = m_mapInstructions.erase(it);
            pInst->Release();

            nItems++;
        }
        else it++;
    }

    // Release our quotas if needed.
    if (nItems)
        g_quotas.DecrementQuotaIndex(ESSQ_POLLING_INSTRUCTIONS, pDest, nItems);

    return WBEM_S_NO_ERROR;
}

HRESULT CPoller::ListNonProvidedClasses(IN CClassInformation* pInfo,
                                        IN DWORD dwDesiredMask,
                                        OUT CClassInfoArray& aNonProvided)
{
    HRESULT hres;
    aNonProvided.Clear();

    // Get the class itself
    // ====================

    IWbemServices* pNamespace;
    hres = m_pNamespace->GetNamespacePointer(&pNamespace);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm0(pNamespace);

    IWbemClassObject* pClass = NULL;
    hres = pNamespace->GetObject( CWbemBSTR( pInfo->m_wszClassName ), 0, 
                        GetCurrentEssContext(), &pClass, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    if(IsClassDynamic(pClass))
    {
        AddDynamicClass(pClass, dwDesiredMask, aNonProvided);
        return WBEM_S_NO_ERROR;
    }

    // Enumerate all its descendants
    // =============================

    IEnumWbemClassObject* pEnum;
    hres = pNamespace->CreateClassEnum( CWbemBSTR( pInfo->m_wszClassName ), 
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY |
                ((pInfo->m_bIncludeChildren)?WBEM_FLAG_DEEP:WBEM_FLAG_SHALLOW),
                                        GetCurrentEssContext(), &pEnum);
    if(FAILED(hres)) return hres;
    CReleaseMe rm3(pEnum);

    IWbemClassObject* pChild = NULL;
    DWORD dwNumRet;
    while(SUCCEEDED(pEnum->Next(INFINITE, 1, &pChild, &dwNumRet)) && dwNumRet > 0)
    {
        // Check if this one is dynamic
        // ============================

        if(IsClassDynamic(pChild))
        {
            AddDynamicClass(pChild, dwDesiredMask, aNonProvided);
        }

        pChild->Release();
        pChild = NULL;
    }
    
    return WBEM_S_NO_ERROR;
}

BOOL CPoller::AddDynamicClass(IWbemClassObject* pClass, DWORD dwDesiredMask, 
                              OUT CClassInfoArray& aNonProvided)
{
    // Check to see if all desired events are provided
    // ===============================================

    DWORD dwProvidedMask = m_pNamespace->GetProvidedEventMask(pClass);
    DWORD dwRemainingMask = ((~dwProvidedMask) & dwDesiredMask);
    if(dwRemainingMask)
    {
        // Add it to the array of classes to poll
        // ======================================

        CClassInformation* pNewInfo = _new CClassInformation;
        if(pNewInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        _variant_t v;
        if (FAILED(pClass->Get(L"__CLASS", 0, &v, NULL, NULL)))
        {
            delete pNewInfo;
            return WBEM_E_OUT_OF_MEMORY;
        }        	
        pNewInfo->m_wszClassName = CloneWstr(V_BSTR(&v));
        if(pNewInfo->m_wszClassName == NULL)
        {
            delete pNewInfo;
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        pNewInfo->m_bIncludeChildren = FALSE;            
        pNewInfo->m_dwEventMask = dwRemainingMask;
        pNewInfo->m_pClass = pClass;
        pClass->AddRef();
    
        if(!aNonProvided.AddClass(pNewInfo))
        {
            delete pNewInfo;
            return WBEM_E_OUT_OF_MEMORY;
        }
        return TRUE;
    }

    return FALSE;
}
            
BOOL CPoller::IsClassDynamic(IWbemClassObject* pClass)
{
    HRESULT hres;
    IWbemQualifierSet* pSet;
    hres = pClass->GetQualifierSet(&pSet);
    if(FAILED(hres))
        return TRUE;

    VARIANT v;
    VariantInit(&v);
    hres = pSet->Get(L"dynamic", 0, &v, NULL);
    pSet->Release();

    if(FAILED(hres)) return FALSE;
    
    BOOL bRes = V_BOOL(&v);
    VariantClear(&v);
    return bRes;
}

HRESULT CPoller::VirtuallyStopPolling()
{
    CInCritSec ics(&m_cs);

    // Mark all polling instructions in the map with the key of 0xFFFFFFFF
    // This will not stop them from working, but will separate them from the
    // new ones.
    // =====================================================================

    for(CInstructionMap::iterator it = m_mapInstructions.begin(); 
            it != m_mapInstructions.end(); it++)
    {
        it->second.m_bActive = FALSE;
    }

    m_bInResync = TRUE;

    return WBEM_S_NO_ERROR;

}

HRESULT CPoller::CancelUnnecessaryPolling()
{
    CInCritSec ics(&m_cs);

    // Remove it from the map
    // ======================

    CInstructionMap::iterator it = m_mapInstructions.begin(); 
    while(it != m_mapInstructions.end())
    {
        if( !it->second.m_bActive )
        {
            CBasePollingInstruction* pInst = it->first;

            //
            // First, cancel the instruction so that if it is executing, it will
            // abort at the earliest convenience
            //

            pInst->Cancel();

            //
            // Then, deactivate the timer.  This will block until the
            // instruction has finished executing, if it is currently doing so
            //

            pInst->DeleteTimer();

            //
            // Now we are safe --- release the instruction. 
            //

            it = m_mapInstructions.erase(it);
            pInst->Release();
        }
        else it++;
    }

    m_bInResync = FALSE;
    return WBEM_S_NO_ERROR;
}

void CPoller::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d polling instructions\n", m_mapInstructions.size());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\poller.h ===
//******************************************************************************
//
//  POLLER.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_POLLER__H_
#define __WBEM_POLLER__H_

#include <tss.h>
#include <wbemcomn.h>
#include <map>
#include <analyser.h>
#include <evsink.h>

#pragma warning(disable: 4786)
class CEssNamespace;

class CBasePollingInstruction : public CTimerInstruction
{
public:
    void AddRef();
    void Release();
    int GetInstructionType() {return INSTTYPE_INTERNAL;}

    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const;
    virtual CWbemTime GetFirstFiringTime() const;
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);

    bool DeleteTimer();

public:
    CBasePollingInstruction(CEssNamespace* pNamespace);
    virtual ~CBasePollingInstruction();

    HRESULT Initialize(LPCWSTR wszLanguage, 
                        LPCWSTR wszQuery, DWORD dwMsInterval,
                        bool bAffectsQuota = false);

    void Cancel();

protected:
    long m_lRef;

    CEssNamespace* m_pNamespace;
    BSTR m_strLanguage;
    BSTR m_strQuery;
    CWbemInterval m_Interval;
    IServerSecurity* m_pSecurity;
    bool m_bUsedQuota;
    bool m_bCancelled;
    HANDLE m_hTimer;
    CCritSec m_cs;
    
protected:
    HRESULT ExecQuery();

    virtual HRESULT ProcessObject(_IWmiObject* pObj) = 0;
    virtual HRESULT ProcessQueryDone(HRESULT hresQuery, 
                                     IWbemClassObject* pError) = 0;
    virtual BOOL CompareTo(CBasePollingInstruction* pOther);
    static void staticTimerCallback(void* pParam, BOOLEAN);
    void Destroy();
};

class CPollingInstruction : public CBasePollingInstruction
{
public:
    CPollingInstruction(CEssNamespace* pNamespace);
    ~CPollingInstruction();

    HRESULT Initialize(LPCWSTR wszLanguage, 
                        LPCWSTR wszQuery, DWORD dwMsInterval, 
                        DWORD dwEventMask, 
                        CEventFilter* pDest);
    HRESULT FirstExecute();

protected:
    DWORD m_dwEventMask;
    CEventFilter* m_pDest;
    bool m_bOnRestart;
    void* m_pUser;
    

    struct CCachedObject
    {
        BSTR m_strPath;
        _IWmiObject* m_pObject;
    
        CCachedObject(_IWmiObject* pObject);
        ~CCachedObject();
        BOOL IsValid(){    return (NULL != m_strPath); };
        static int __cdecl compare(const void* pelem1, const void* pelem2);
    };

    typedef CUniquePointerArray<CCachedObject> CCachedArray;
    CCachedArray* m_papPrevObjects;
    CCachedArray* m_papCurrentObjects;

    friend class CPoller;
protected:
    HRESULT RaiseCreationEvent(CCachedObject* pNewObj);
    HRESULT RaiseDeletionEvent(CCachedObject* pOldObj);
    HRESULT RaiseModificationEvent(CCachedObject* pNewObj, 
                                   CCachedObject* pOldObj = NULL);
    static SYSFREE_ME BSTR GetObjectClass(CCachedObject* pObj);

    HRESULT ProcessObject(_IWmiObject* pObj);
    HRESULT ProcessQueryDone(HRESULT hresQuery, 
                                     IWbemClassObject* pError);
    HRESULT SubtractMemory(CCachedArray* pArray);
    HRESULT ResetPrevious();
    DWORD ComputeObjectMemory(_IWmiObject* pObj);
};

class CEventFilterContainer;

class CPoller
{
public:
    CPoller(CEssNamespace* pEssNamespace);
    ~CPoller();
    void Clear();

    HRESULT ActivateFilter(CEventFilter* pDest, 
                LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp);
    HRESULT DeactivateFilter(CEventFilter* pDest);
    HRESULT VirtuallyStopPolling();
    HRESULT CancelUnnecessaryPolling();

    void DumpStatistics(FILE* f, long lFlags);

protected:
    CEssNamespace* m_pNamespace;
    CQueryAnalyser m_Analyser;
    BOOL m_bInResync;
    CCritSec m_cs;
    
    struct FilterInfo
    {
        BOOL m_bActive;
        DWORD_PTR m_dwFilterId;
    };

    typedef std::map<CPollingInstruction*, FilterInfo, std::less<CPollingInstruction*>, 
                     wbem_allocator<FilterInfo> > CInstructionMap;
    CInstructionMap m_mapInstructions;

    friend class CKeyTest;
    class CKeyTest : public CInstructionTest
    {
        DWORD_PTR m_dwKey;
        CInstructionMap& m_mapInstructions;
    public:
        CKeyTest(DWORD_PTR dwKey, CInstructionMap& mapInstructions) 
            : m_dwKey(dwKey), m_mapInstructions(mapInstructions)
        {}
    
        BOOL operator()(CTimerInstruction* pToTest) 
        {
            CInstructionMap::iterator it = 
                m_mapInstructions.find((CPollingInstruction*)pToTest);
            if(it == m_mapInstructions.end())
                return FALSE;            
            if ( !it->second.m_bActive && m_dwKey == 0xFFFFFFFF )
                return TRUE;
            return (it->second.m_dwFilterId == m_dwKey);
        }
    };
protected:
    HRESULT AddInstruction(DWORD_PTR dwKey, CPollingInstruction* pInst);

    HRESULT ListNonProvidedClasses(IN CClassInformation* pInfo,
                                   IN DWORD dwDesiredMask,
                                   OUT CClassInfoArray& aNonProvided);
    BOOL IsClassDynamic(IWbemClassObject* pClass);
    BOOL AddDynamicClass(IWbemClassObject* pClass, DWORD dwDesiredMask, 
                              OUT CClassInfoArray& aNonProvided);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\postpone.cpp ===
//******************************************************************************
//
//  POSTPONE.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <ess.h>
#include <postpone.h>

HRESULT CPostponedList::AddRequest( CEssNamespace* pNamespace,
                                    ACQUIRE CPostponedRequest* pReq )
{
    if ( pReq->DoesHoldTurn() )
    {
        m_cTurnsHeld++;
    }

    pReq->SetNamespace( pNamespace );

    if(!m_qpRequests.Enqueue(pReq))
        return WBEM_E_OUT_OF_MEMORY;
    else
        return WBEM_S_NO_ERROR;
}

HRESULT CPostponedList::Execute(CEssNamespace* pNamespace, 
                                EPostponedExecuteFlags eFlags,
                                DELETE_ME CPostponedRequest** ppFailed)
{
    if(ppFailed)
        *ppFailed = NULL;

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    while(m_qpRequests.GetQueueSize())
    {
        // Retrieve and remove the next request
        // ====================================

        CPostponedRequest* pReq = m_qpRequests.Dequeue();

        if ( pReq->DoesHoldTurn() )
        {
            _DBG_ASSERT( m_cTurnsHeld > 0 );
            m_cTurnsHeld--;
        }

        //
        // see if the namespace that postponed the request is different 
        // from the one executing it.  If it is, this is very bad. This
        // can happen in (faulty) cross namespace logic when one namespace is
        // executing an operation in the other,  normally while holding 
        // its own ns lock, and then the other fires the postponed 
        // operations for itself and the original namespace which surely 
        // was not intended.  Some requests aren't namespace specific, so
        // it we don't do the check for these.
        //
        _DBG_ASSERT( pReq->GetNamespace() == NULL || 
                     pReq->GetNamespace() == pNamespace );

        // Execute it
        // ==========

        HRESULT hres = pReq->Execute(pNamespace);
        if(FAILED(hres))
        {
            if(eFlags == e_StopOnFailure)
            {
                // Return the request and the error
                // ================================

                if(ppFailed)
                    *ppFailed = pReq;
                else
                    delete pReq;
                return hres;
            }
            else
            {
                // Record the request and the error
                // ================================

                if(ppFailed)
                {
                    delete *ppFailed;
                    *ppFailed = pReq;
                }
                else
                    delete pReq;

                if(SUCCEEDED(hresGlobal))
                    hresGlobal = hres;
            }
        }
        else
        {
            delete pReq;
        }
    }

    return hresGlobal;
}

HRESULT CPostponedList::Clear()
{
    m_qpRequests.Clear();
    m_cTurnsHeld = 0;
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\postpone.h ===
//******************************************************************************
//
//  POSTPONE.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_ESS_POSTPONE__H_
#define __WBEM_ESS_POSTPONE__H_

#include <arrtempl.h>
#include <wbemcomn.h>

class CEssNamespace;
class CPostponedRequest
{
    CEssNamespace* m_pNamespace; // stored for an assertion at execute()
public:
    CPostponedRequest() : m_pNamespace(NULL) {}
    virtual ~CPostponedRequest(){}

    void SetNamespace( CEssNamespace* pNamespace ) { m_pNamespace=pNamespace; }
    CEssNamespace* GetNamespace() { return m_pNamespace; }

    virtual HRESULT Execute(CEssNamespace* pNamespace) = 0;
    
    //
    // if a postponed request holds a CExecLine::Turn, then override this 
    // method to return TRUE.  ( used for debugging purposes - we want to know
    // if a postponed list is holding any turns )
    //
    virtual BOOL DoesHoldTurn() { return FALSE; }
};

class CPostponedList
{
protected:
    ULONG m_cTurnsHeld;
    CUniquePointerQueue<CPostponedRequest> m_qpRequests;

public:
    typedef enum
    {
        e_StopOnFailure, e_ReturnOneError
    } EPostponedExecuteFlags;

    CPostponedList() : m_qpRequests(0), m_cTurnsHeld(0) {}
    virtual ~CPostponedList(){}

    BOOL IsEmpty() { return m_qpRequests.GetQueueSize() == 0; }
    BOOL IsHoldingTurns() { return m_cTurnsHeld > 0; }

    HRESULT AddRequest( CEssNamespace* pNamespace, 
                        ACQUIRE CPostponedRequest* pReq );

    HRESULT Execute( CEssNamespace* pNamespace, 
                     EPostponedExecuteFlags eFlags,
                     DELETE_ME CPostponedRequest** ppFailed = NULL);
    HRESULT Clear();
};
        
       
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\pragmas.h ===
//******************************************************************************
//
//  PRAGMAS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#pragma warning(disable:4355)
#pragma warning(disable:4786)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\precomp.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#pragma warning (disable : 4786)

#define COREPROX_POLARITY __declspec( dllimport )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ole2.h>
#include <windows.h>

#include <comdef.h>
#include <helper.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\provreg.h ===
//******************************************************************************
//
//  PROVREG.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __EVENTPROV_REG__H_
#define __EVENTPROV_REG__H_

#include <time.h>
#include <wbemidl.h>
#include <arrtempl.h>
#include <analyser.h>
#include <evaltree.h>
#include <sync.h>
#include <filtprox.h>
#include <unload.h>
#include <postpone.h>
#include <mtgtpckt.h>

class CEventProviderCache;
class CEventProviderWatchInstruction : public CBasicUnloadInstruction
{
protected:
    CEventProviderCache* m_pCache;
    static CWbemInterval mstatic_Interval;

public:
    CEventProviderWatchInstruction(CEventProviderCache* pCache);
    static void staticInitialize(IWbemServices* pRoot);
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
};

class CProviderSinkServer;
class CFilterStub : public IWbemFilterStub, public IWbemMultiTarget,
                public IWbemFetchSmartMultiTarget, public IWbemSmartMultiTarget,
                public IWbemEventProviderRequirements
{
protected:
    CProviderSinkServer* m_pSink;
    CWbemClassCache m_ClassCache;

public:
    CFilterStub(CProviderSinkServer* pSink) : m_pSink(pSink){}

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT STDMETHODCALLTYPE RegisterProxy(IWbemFilterProxy* pProxy);
    HRESULT STDMETHODCALLTYPE UnregisterProxy(IWbemFilterProxy* pProxy);

    HRESULT STDMETHODCALLTYPE DeliverEvent(DWORD dwNumEvents, 
                        IWbemClassObject** apEvents, 
                        WBEM_REM_TARGETS* aTargets,
                        long lSDLength, BYTE* pSD);
    HRESULT STDMETHODCALLTYPE DeliverStatus(long lFlags, HRESULT hresStatus,
                        LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                        WBEM_REM_TARGETS* aTargets,
                        long lSDLength, BYTE* pSD);

	HRESULT STDMETHODCALLTYPE GetSmartMultiTarget(
		IWbemSmartMultiTarget** ppSmartMultiTarget );

	HRESULT STDMETHODCALLTYPE DeliverEvent(DWORD dwNumEvents, DWORD dwBuffSize,
						BYTE* pBuffer,
                        WBEM_REM_TARGETS* aTargets,
                        long lSDLength, BYTE* pSD);

    HRESULT STDMETHODCALLTYPE DeliverProviderRequest(long lFlags);

};

class CEssMetaData;
class CProviderSinkServer : public IUnknown
{
public:
    struct CEventDestination
    {
        private:
        CEventDestination& operator=( const CEventDestination& ); // not impl

        public:
        WBEM_REMOTE_TARGET_ID_TYPE m_id;
        CAbstractEventSink* m_pSink;

        CEventDestination(WBEM_REMOTE_TARGET_ID_TYPE Id, 
                            CAbstractEventSink* pSink);
        CEventDestination(const CEventDestination& Other);
        ~CEventDestination();
    };
    
    typedef CUniquePointerArray<CEventDestination> TDestinationArray;
protected:
    long m_lRef;

    CRefedPointerArray<IWbemFilterProxy> m_apProxies;
    TDestinationArray m_apDestinations;
    TDestinationArray m_apPreviousDestinations;
    WBEM_REMOTE_TARGET_ID_TYPE m_idNext;

    CWStringArray m_awsDefinitionQueries;

    IWbemLocalFilterProxy* m_pPseudoProxy;
    IWbemEventSink* m_pPseudoSink;

    CEssMetaData* m_pMetaData;
    CEssNamespace* m_pNamespace;
    IWbemEventProviderRequirements* m_pReqSink;

    CCritSec m_cs;
    long m_lLocks;

protected:
    CFilterStub m_Stub;

public:
    CProviderSinkServer();
    HRESULT Initialize(CEssNamespace* pNamespace, 
                        IWbemEventProviderRequirements* pReqSink);
    ~CProviderSinkServer();

    void Clear();
    HRESULT GetMainProxy(IWbemEventSink** ppSink);

    void GetStatistics(long* plProxies, long* plDestinations,
                    long* plFilters, long* plTargetLists, long* plTargets,
                    long* plPostponed);
    HRESULT GetDestinations(
                        TDestinationArray& apDestinations);
    INTERNAL CEssNamespace* GetNamespace() {return m_pNamespace;}

protected:
    HRESULT AddDestination(CAbstractEventSink* pDest, 
                        WBEM_REMOTE_TARGET_ID_TYPE* pID);
    BOOL GetProxies(CRefedPointerArray<IWbemFilterProxy>& apProxies);
   
    HRESULT FindDestinations(long lNum, 
                                IN WBEM_REMOTE_TARGET_ID_TYPE* aidTargets,
                                RELEASE_ME CAbstractEventSink** apSinks);

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT AddFilter(LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        CAbstractEventSink* pDest, 
                        WBEM_REMOTE_TARGET_ID_TYPE* pidRequest = NULL);
    HRESULT RemoveFilter(CAbstractEventSink* pDest,
                        WBEM_REMOTE_TARGET_ID_TYPE* pidRequest = NULL);
    void RemoveAllFilters();
    HRESULT AddDefinitionQuery(LPCWSTR wszQuery);
    HRESULT AllowUtilizeGuarantee();
    void RemoveAllDefinitionQueries();

    HRESULT Lock();
    void Unlock();

public: // IWbemMultiTarget (forwarded)

    HRESULT STDMETHODCALLTYPE DeliverEvent(DWORD dwNumEvents, 
                        IWbemClassObject** apEvents, 
                        WBEM_REM_TARGETS* aTargets,
                        CEventContext* pContext);
    HRESULT DeliverOneEvent(IWbemClassObject* pEvent,
                                        WBEM_REM_TARGETS* pTargets,
                        CEventContext* pContext);

    HRESULT STDMETHODCALLTYPE DeliverStatus(long lFlags, HRESULT hresStatus,
                        LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                        WBEM_REM_TARGETS* aTargets,
                        CEventContext* pContext);
    HRESULT MultiTargetDeliver(IWbemEvent* pEvent, WBEM_REM_TARGETS* pTargets,
                        CEventContext* pContext);

public: // IWbemFilterStub (forwarded)

    HRESULT STDMETHODCALLTYPE RegisterProxy(IWbemFilterProxy* pProxy);
    HRESULT STDMETHODCALLTYPE UnregisterProxy(IWbemFilterProxy* pProxy);

public: // IWbemEventProviderRequirements (forwarded)

    HRESULT STDMETHODCALLTYPE DeliverProviderRequest(long lFlags);

};

class CEventProviderCache
{
private:
    class CRequest
    {
    private:
        CAbstractEventSink* m_pDest;
        LPWSTR m_wszQuery;
        QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
        IWbemClassObject* m_pEventClass;
        DWORD m_dwEventMask;
        CClassInfoArray* m_papInstanceClasses;

    public:
        CRequest(IN CAbstractEventSink* pDest, LPWSTR wszQuery,
                    QL_LEVEL_1_RPN_EXPRESSION* pExp);
        ~CRequest();

        INTERNAL LPWSTR GetQuery() {return m_wszQuery;}
        INTERNAL CAbstractEventSink* GetDest() {return m_pDest;}

        INTERNAL QL_LEVEL_1_RPN_EXPRESSION* GetQueryExpr();
        DWORD GetEventMask();
        HRESULT GetInstanceClasses(CEssNamespace* pNamespace,
                                        INTERNAL CClassInfoArray** ppClasses);
        INTERNAL IWbemClassObject* GetEventClass(CEssNamespace* pNamespace);

        HRESULT CheckValidity(CEssNamespace* pNamespace);
    };


    class CRecord : IWbemEventProviderRequirements
    {
        class CQueryRecord
        {
            BSTR m_strQuery;
            IWbemClassObject* m_pEventClass;
            DWORD m_dwEventMask;
            CClassInfoArray* m_paInstanceClasses;
            QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
        
        public:
            CQueryRecord();
            HRESULT Initialize( COPY LPCWSTR wszQuery, 
                                LPCWSTR wszProvName,
                                CEssNamespace* pNamespace,
                                bool bSystem);
            ~CQueryRecord();
    
            HRESULT Update(LPCWSTR wszClassName, IWbemClassObject* pClass);
            HRESULT DoesIntersectWithQuery(CRequest& Request,
                                            CEssNamespace* pNamespace);
            DWORD GetProvidedEventMask(IWbemClassObject* pClass,
                                        BSTR strClassName);
            LPCWSTR GetQuery() {return m_strQuery;}

            HRESULT EnsureClasses( CEssNamespace* pNamespace );
            void ReleaseClasses();
        };

        friend class CEventProviderCache;
    public:
        long m_lRef;
        BSTR m_strNamespace;
        BSTR m_strName;
        BOOL m_bProviderSet;
        CUniquePointerArray<CQueryRecord> m_apQueries;
        long m_lUsageCount;
        long m_lPermUsageCount;
        BOOL m_bRecorded;
        BOOL m_bNeedsResync;
        CWbemTime m_LastUse;
        IWbemEventProvider* m_pProvider;
        IWbemEventProviderQuerySink* m_pQuerySink;
        IWbemEventProviderSecurity* m_pSecurity;
        CExecLine m_Line;
        bool m_bStarted;
        CEssNamespace* m_pNamespace;

        CProviderSinkServer* m_pMainSink;
    public:
        CRecord();
        HRESULT Initialize( LPCWSTR wszName, CEssNamespace* pNamespace );
        
        HRESULT SetProvider(IWbemClassObject* pWin32Prov);
        HRESULT SetProviderPointer(CEssNamespace* pNamespace, 
                                    IWbemEventProvider* pProvider);
        HRESULT ResetProvider();
        HRESULT SetQueries(CEssNamespace* pNamespace, 
                           IWbemClassObject* pRegistration);
        HRESULT SetQueries(CEssNamespace* pNamespace, long lNumQueries,
                                                 LPCWSTR* awszQueries);
        HRESULT ResetQueries();
        HRESULT Load(CEssNamespace* pNamespace);
        HRESULT DeactivateFilter(CAbstractEventSink* pDest);
        HRESULT CancelAllQueries();
        HRESULT STDMETHODCALLTYPE DeliverProviderRequest(long lFlags);

        static HRESULT GetProviderInfo(IWbemClassObject* pWin32Prov, 
                                       BSTR& strName);
        static HRESULT GetRegistrationInfo(IWbemClassObject* pRegistration, 
                                       BSTR& strName);
        HRESULT ActivateIfNeeded(IN CRequest& Request,
                    IN CEssNamespace* pNamespace);

        BOOL NeedsResync() { return m_bNeedsResync; }
        void ResetNeedsResync() { m_bNeedsResync = FALSE; }

        BOOL IsEmpty();  
        void ResetUsage();
        void CheckPermanentUsage();
        virtual bool DeactivateIfNotUsed();
        virtual bool IsUnloadable();
        HRESULT Update(LPCWSTR wszClassName, IWbemClassObject* pClass);
        DWORD GetProvidedEventMask(IWbemClassObject* pClass, BSTR strClassName);
        
        INTERNAL CProviderSinkServer* GetMainSink() {return m_pMainSink;}

        void Lock() {m_pMainSink->Lock();}
        void Unlock() {m_pMainSink->Unlock();}
        BOOL IsActive() {return (m_pProvider != NULL);}
        long GetUsageCount() {return m_lUsageCount;}

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv) {return E_FAIL;}

        ~CRecord();
    protected:

        HRESULT Activate(CEssNamespace* pNamespace, CRequest* pRequest,
                                WBEM_REMOTE_TARGET_ID_TYPE idRequest);
        HRESULT Deactivate( CAbstractEventSink* pDest,
                            WBEM_REMOTE_TARGET_ID_TYPE idRequest);

        HRESULT AddActiveProviderEntryToRegistry();
        HRESULT RemoveActiveProviderEntryFromRegistry();

        HRESULT AddDefinitionQuery(CEssNamespace* pNamespace, LPCWSTR wszQuery);
        HRESULT Exec_LoadProvider(CEssNamespace* pNamespace);
        HRESULT Exec_StartProvider(CEssNamespace* pNamespace);
        HRESULT Exec_NewQuery(CEssNamespace* pNamespace, 
                    CExecLine::CTurn* pTurn, DWORD dwID, 
                    LPCWSTR wszLanguage, LPCWSTR wszQuery,
                    CAbstractEventSink* pDest);
        HRESULT ActualExecNewQuery(CEssNamespace* pNamespace, 
                    DWORD dwID, LPCWSTR wszLanguage, LPCWSTR wszQuery,
                    CAbstractEventSink* pDest);
        HRESULT Exec_CancelQuery(CEssNamespace* pNamespace, 
                    CExecLine::CTurn* pTurn, DWORD dwId);
        CExecLine::CTurn* GetInLine();
        void DiscardTurn(CExecLine::CTurn* pTurn);

        virtual HRESULT PostponeNewQuery(CExecLine::CTurn* pTurn, DWORD dwId, 
                                 LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                                 CAbstractEventSink* pDest);
        virtual HRESULT PostponeCancelQuery(CExecLine::CTurn* pTurn, 
                                 DWORD dwId);
        void UnloadProvider();

        virtual bool IsSystem() {return false;}

        friend class CPostponedNewQuery;
        friend class CPostponedCancelQuery;
        friend class CPostponedProvideEvents;

    protected:
    };

    class CSystemRecord : public CRecord
    {
    public:
        virtual bool DeactivateIfNotUsed();
        virtual bool IsUnloadable();
/*        HRESULT PostponeNewQuery(CExecLine::CTurn* pTurn, DWORD dwId, 
                                 LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                                 CAbstractEventSink* pDest);
        HRESULT PostponeCancelQuery(CExecLine::CTurn* pTurn, DWORD dwId); */
        virtual bool IsSystem() {return true;}
    };
        

    friend class CPostponedNewQuery;
    friend class CPostponedCancelQuery;
    friend class CEventProviderWatchInstruction;
    friend class CPostponedProvideEvents;

    CRefedPointerArray<CRecord> m_aRecords;
    CEssNamespace* m_pNamespace;
    CEventProviderWatchInstruction* m_pInstruction;
    BOOL m_bInResync;

protected:
    long FindRecord(LPCWSTR wszName);

public:
    CEventProviderCache(CEssNamespace* pNamespace);
    ~CEventProviderCache();
    HRESULT Shutdown();

    HRESULT AddProvider(IWbemClassObject* pWin32Prov);
    HRESULT AddSystemProvider(IWbemEventProvider* pProvider, LPCWSTR wszName,
                              long lNumQueries, LPCWSTR* awszQueries);
    HRESULT RemoveProvider(IWbemClassObject* pWin32Prov);
    HRESULT CheckProviderRegistration(IWbemClassObject* pRegistration);
    HRESULT AddProviderRegistration(IWbemClassObject* pRegistration);
    HRESULT RemoveProviderRegistration(IWbemClassObject* pRegistration);

    HRESULT LoadProvidersForQuery(LPWSTR wszQuery,
                                    QL_LEVEL_1_RPN_EXPRESSION* pExp, 
                                    CAbstractEventSink* pDest);

    HRESULT ReleaseProvidersForQuery(CAbstractEventSink* pDest);

    DWORD GetProvidedEventMask(IWbemClassObject* pClass);
    HRESULT VirtuallyReleaseProviders();
    HRESULT CommitProviderUsage();
    HRESULT UnloadUnusedProviders(CWbemInterval Interval);
    void EnsureUnloadInstruction();

    void DumpStatistics(FILE* f, long lFlags);
};

class CPostponedNewQuery : public CPostponedRequest
{
protected:
    CEventProviderCache::CRecord* m_pRecord;
    DWORD m_dwId;
    CCompressedString* m_pcsQuery;
    CExecLine::CTurn* m_pTurn;
    CAbstractEventSink* m_pDest;

public:
    CPostponedNewQuery(CEventProviderCache::CRecord* pRecord, DWORD dwId,
                        LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                        CExecLine::CTurn* pTurn, CAbstractEventSink* pDest);
    ~CPostponedNewQuery();
    HRESULT Execute(CEssNamespace* pNamespace);
    BOOL DoesHoldTurn() { return TRUE; }

    void* operator new(size_t nSize);
    void operator delete(void* p);
};

class CPostponedCancelQuery : public CPostponedRequest
{
protected:
    DWORD m_dwId;
    CEventProviderCache::CRecord* m_pRecord;
    CExecLine::CTurn* m_pTurn;

public:
    CPostponedCancelQuery(CEventProviderCache::CRecord* pRecord, 
                            CExecLine::CTurn* pTurn, DWORD dwId)
        : m_pRecord(pRecord), m_dwId(dwId), m_pTurn(pTurn)
    {
        m_pRecord->AddRef();
    }
    ~CPostponedCancelQuery()
    {
        if(m_pTurn)
            m_pRecord->DiscardTurn(m_pTurn);
        m_pRecord->Release();
    }
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        HRESULT hres = m_pRecord->Exec_CancelQuery(pNamespace, m_pTurn, m_dwId);
        m_pTurn = NULL;
        return hres;
    }
    BOOL DoesHoldTurn() { return TRUE; }
};

class CPostponedProvideEvents : public CPostponedRequest
{
protected:
    DWORD m_dwId;
    CEventProviderCache::CRecord* m_pRecord;
    CExecLine::CTurn* m_pTurn;

public:
    CPostponedProvideEvents(CEventProviderCache::CRecord* pRecord)
        : m_pRecord(pRecord)
    {
        m_pRecord->AddRef();
    }
    ~CPostponedProvideEvents()
    {
        m_pRecord->Release();
    }
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        HRESULT hres = m_pRecord->Exec_StartProvider(pNamespace);
        return hres;
    }
    BOOL DoesHoldTurn() { return TRUE; }
};

class CPostponedSinkServerShutdown : public CPostponedRequest
{
protected:
    
    CWbemPtr<CProviderSinkServer> m_pSinkServer;
    
public:

    CPostponedSinkServerShutdown( CProviderSinkServer* pSinkServer ) 
    : m_pSinkServer( pSinkServer ) { }

    HRESULT Execute( CEssNamespace* pNamespace )
    {
        m_pSinkServer->Clear();
        return WBEM_S_NO_ERROR;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\provreg.cpp ===
//******************************************************************************
//
//  PROVREG.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <parmdefs.h>
#include <ql.h>
#include "ess.h"
#include <wbemutil.h>
#include <cominit.h>
#include <objpath.h>
#include <provinit.h>
#include <winmgmtr.h>
#include <comutl.h>
#include "NCEvents.h"

_IWmiObject* g_pCopy;

#define WBEM_MAX_FILTER_ID 0x80000000

inline BOOL IsRpcError( HRESULT hr ) 
{
    //
    // we'll consider any error but a wbem error to be an rpc error.
    //

    return HRESULT_FACILITY(hr) != FACILITY_ITF;
} 

CWbemInterval CEventProviderWatchInstruction::mstatic_Interval;

CEventProviderWatchInstruction::CEventProviderWatchInstruction(
                                                    CEventProviderCache* pCache)
        : CBasicUnloadInstruction(mstatic_Interval), m_pCache(pCache)
{
}

void CEventProviderWatchInstruction::staticInitialize(IWbemServices* pRoot)
{
    mstatic_Interval = CBasicUnloadInstruction::staticRead(pRoot, GetCurrentEssContext(), 
                                            L"__EventProviderCacheControl=@");
}

HRESULT CEventProviderWatchInstruction::Fire(long, CWbemTime)
{
    CInCritSec ics(&m_cs);

    if(!m_bTerminate)
    {
        SetCurrentEssThreadObject(NULL);
        
        if ( GetCurrentEssThreadObject() != NULL )
        {
            m_pCache->UnloadUnusedProviders(m_Interval);
            delete GetCurrentEssThreadObject();
            ClearCurrentEssThreadObject();
        }
    }

    return WBEM_S_FALSE;
}

//******************************************************************************
//******************************************************************************
//
//          PROVIDER SINK (SERVER)
//
//******************************************************************************
//******************************************************************************

CProviderSinkServer::CEventDestination::CEventDestination(
                                    WBEM_REMOTE_TARGET_ID_TYPE id,
                                    CAbstractEventSink* pSink)
    : m_id(id), m_pSink(pSink)
{
    if(m_pSink)
        m_pSink->AddRef();
}

CProviderSinkServer::CEventDestination::CEventDestination(
                                    const CEventDestination& Other)
    : m_id(Other.m_id), m_pSink(Other.m_pSink)
{
    if(m_pSink)
        m_pSink->AddRef();
}

CProviderSinkServer::CEventDestination::~CEventDestination()
{
    if(m_pSink)
        m_pSink->Release();
}

        
CProviderSinkServer::CProviderSinkServer()
: m_lRef(0), m_pNamespace(NULL), m_pMetaData(NULL), m_Stub(this),  m_idNext(0),
  m_pPseudoProxy(NULL), m_pPseudoSink(NULL), m_pReqSink(NULL), m_lLocks(0)
{
}

HRESULT CProviderSinkServer::Initialize( CEssNamespace* pNamespace,
                                    IWbemEventProviderRequirements* pReqSink )
{
    HRESULT hres;

    //
    // This sink owns us, so we intentionally do not AddRef it
    //

    m_pReqSink = pReqSink;

    m_pMetaData = new CEssMetaData(pNamespace);
    if(m_pMetaData == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    m_pMetaData->AddRef();

    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    //
    // create the pseudo proxy and sink.
    // 

    hres = WbemCoCreateInstance( CLSID_WbemFilterProxy, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER,
                                 IID_IWbemLocalFilterProxy, 
                                 (void**)&m_pPseudoProxy );
    if( FAILED(hres) )
    {
        return hres;
    }
            
    hres = m_pPseudoProxy->SetStub( &m_Stub );
            
    if(FAILED(hres))
    {
        return hres;
    }
    
    return m_pPseudoProxy->GetMainSink(&m_pPseudoSink);
}

HRESULT CProviderSinkServer::GetMainProxy(IWbemEventSink** ppSink)
{
    _DBG_ASSERT( m_pPseudoSink != NULL );
    m_pPseudoSink->AddRef();
    *ppSink = m_pPseudoSink;
    return WBEM_S_NO_ERROR;
}

CProviderSinkServer::~CProviderSinkServer()
{
    if(m_pPseudoProxy)
        m_pPseudoProxy->Release();
    if(m_pPseudoSink)
        m_pPseudoSink->Release();
    if(m_pMetaData)
        m_pMetaData->Release();
    if(m_pNamespace)
        m_pNamespace->Release();
}

ULONG STDMETHODCALLTYPE CProviderSinkServer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CProviderSinkServer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) 
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IMarshal)
        *ppv = (IMarshal*)this;
    else 
        return E_NOINTERFACE;
    
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::DeliverEvent(
                        DWORD dwNumEvents,
                        IWbemClassObject** apEvents, 
                        WBEM_REM_TARGETS* aTargets,
                        CEventContext* pContext)
{
    if(aTargets == NULL || aTargets->m_aTargets == NULL || apEvents == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL parameter received from a "
                    "filter proxy for an event provider. Either an internal "
                    "error has occurred, or a DENIAL OF SERVICE ATTACK has "
                    "been thwarted\n"));

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ensure that there is no ess thread object associated with this thread.
    // to avoid making the design more complicated we are not going to support
    // postpone operations being used on event signaling threads.  If we did
    // we have to start creating thread objects and firing postponed ops on
    // every event signaling - it would be rather messy and inefficient to 
    // say the least. 
    //

    CEssThreadObject* pThreadObj = GetCurrentEssThreadObject();

    if ( pThreadObj != NULL )
    {
        ClearCurrentEssThreadObject();
    }

    for(DWORD i = 0; i < dwNumEvents; i++)
    {
        DeliverOneEvent(apEvents[i], aTargets + i, pContext);
    }

    if ( pThreadObj != NULL )
    {
        SetConstructedEssThreadObject( pThreadObj );
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CProviderSinkServer::DeliverOneEvent( IWbemClassObject* pEvent,
                                              WBEM_REM_TARGETS* pTargets,
                                              CEventContext* pContext )
{
    HRESULT hres;

    _DBG_ASSERT( pContext != NULL );

    if(pEvent == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL parameter received from a "
                    "filter proxy for an event provider. Either an internal "
                    "error has occurred, or a DENIAL OF SERVICE ATTACK has "
                    "been thwarted\n"));

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // allocate the context to be used if we need to switch to a per event 
    // context ( e.g. when the event has a SD ).  
    // 
    CEventContext PerEventContext;
    
    //
    // take care of the event SD here.  If there is an SD associated with the 
    // context, then we always use that one.  If not, then we take the one 
    // associated with the event.  In the latter case, it is important to 
    // pull the SD out here because sometimes we perform the access check 
    // after the SD has been projected out from the event ( this happens in 
    // cross-namespace subscriptions.
    //

    if ( pContext->GetSD() == NULL )
    {
        ULONG cEventSD;
        PBYTE pEventSD = (PBYTE)GetSD( pEvent, &cEventSD );

        if ( pEventSD != NULL )
        {
            //
            // must use a different context for the event, 
            // since it has its own SD
            //
            pContext = &PerEventContext;

            //
            // we must copy the SD here because it is not guaranteed to be 
            // aligned properly since it is a ptr to the direct event object 
            // data.  The bytes MUST NOT be treated as an SD until it has 
            // been copied. 
            // 

            if ( !pContext->SetSD( cEventSD, pEventSD, TRUE ) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            
            if ( !IsValidSecurityDescriptor( 
                              (PSECURITY_DESCRIPTOR)pContext->GetSD() ) )
            {
                return WBEM_E_INVALID_OBJECT;
            }
        }
    }
    else
    {
        if ( !IsValidSecurityDescriptor( 
                              (PSECURITY_DESCRIPTOR)pContext->GetSD() ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    //
    // clone the event
    // 

    IWbemEvent* pClone = NULL;

    hres = pEvent->Clone(&pClone);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pClone);

    if(pTargets->m_lNumTargets > 1)
        return MultiTargetDeliver(pClone, pTargets, pContext);

    // Single target
    // =============

    // Check validity
    // ==============

    long lDestId = pTargets->m_aTargets[0];
    CAbstractEventSink* pDest = NULL;

    {
        CInCritSec ics(&m_cs);
        
        hres = FindDestinations(1, pTargets->m_aTargets, &pDest);
        if(FAILED(hres))
            return hres;

        if(!pDest)
            // No longer there --- that's OK
            return WBEM_S_FALSE;
    }

    hres = pDest->Indicate(1, &pClone, pContext);
    pDest->Release();

    return hres;
}


HRESULT CProviderSinkServer::MultiTargetDeliver(IWbemEvent* pEvent, 
                                    WBEM_REM_TARGETS* pTargets,
                                    CEventContext* pContext)
{
    HRESULT hres;

    // Convert the target IDs to the actual targets
    // ============================================

    CTempArray<CAbstractEventSink*> apSinks;
    if(!INIT_TEMP_ARRAY(apSinks, pTargets->m_lNumTargets))
        return WBEM_E_OUT_OF_MEMORY;

    {
        CInCritSec ics(&m_cs);
        
        hres = FindDestinations(pTargets->m_lNumTargets, pTargets->m_aTargets,
                                (CAbstractEventSink**)apSinks);
        if(FAILED(hres))
            return hres;
    }

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    for(int i = 0; i < pTargets->m_lNumTargets; i++)
    {
        if(apSinks[i])
        {
            hres = apSinks[i]->Indicate(1, &pEvent, pContext);
            if(FAILED(hres))
                hresGlobal = hres;
            apSinks[i]->Release();
        }
    }

    // DEBUGTRACE((LOG_ESS, "Done delivering\n"));
    return hresGlobal;
}
        
// assumes: locked
HRESULT CProviderSinkServer::FindDestinations(long lNum, 
                                IN WBEM_REMOTE_TARGET_ID_TYPE* aidTargets,
                                RELEASE_ME CAbstractEventSink** apSinks)
{
    //
    // Do a binary search for each one.  The range will be getting progressively
    // smaller with each element we find
    //

    long lLastFoundIndex = -1;

    for(long i = 0; i < lNum; i++)
    {
        long lMinIndex = lLastFoundIndex+1;
        long lMaxIndex = m_apDestinations.GetSize() - 1;
        long lFound = -1;
        WBEM_REMOTE_TARGET_ID_TYPE idCurrent = aidTargets[i];
    
        //
        // Search the remaining portion of the array
        //

        while(lMinIndex <= lMaxIndex)
        {
            long lMidIndex = (lMinIndex + lMaxIndex) / 2;

            WBEM_REMOTE_TARGET_ID_TYPE idMid = m_apDestinations[lMidIndex]->m_id;
            if(idMid == idCurrent)
            {
                lFound = lMidIndex;
                break;
            }
            else if(idCurrent < idMid)
            {
                lMaxIndex = lMidIndex - 1;
            }
            else
            {
                lMinIndex = lMidIndex + 1;
            }
        }

        if(lFound < 0)
        {
            //
            // Invalid target ID -- OK, so NULL target then
            //

            apSinks[i] = NULL;
        }
        else
        {
            apSinks[i] = m_apDestinations[lFound]->m_pSink;
            (apSinks[i])->AddRef();

            //
            // The rest of the IDs can only be found to the right of this one
            // because the targets are sorted
            //

            lLastFoundIndex = lFound;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::DeliverStatus(long lFlags, 
                        HRESULT hresStatus,
                        LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                        WBEM_REM_TARGETS* pTargets,
                        CEventContext* pContext)
{
    return WBEM_E_UNEXPECTED;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::DeliverProviderRequest(
                        long lFlags)
{
    if(m_pReqSink)
        return m_pReqSink->DeliverProviderRequest(lFlags);
    else
        return WBEM_E_UNEXPECTED;
}


// assumes: locked
HRESULT CProviderSinkServer::GetDestinations(
                        CUniquePointerArray<CEventDestination>& apDestinations)
{
    for(int i = 0; i < m_apDestinations.GetSize(); i++)
    {
        CEventDestination* pNew = new CEventDestination(*m_apDestinations[i]);
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(apDestinations.Add(pNew) < 0)
        {
            delete pNew;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
            
    return WBEM_S_NO_ERROR;
}
    
// assumes in m_cs;
HRESULT CProviderSinkServer::AddDestination(CAbstractEventSink* pDest,
                                WBEM_REMOTE_TARGET_ID_TYPE* pID)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //
    // Allocate a new destination ID
    //

    WBEM_REMOTE_TARGET_ID_TYPE idNew = m_idNext++;
    if(m_idNext > WBEM_MAX_FILTER_ID / 2)
    {
        // 
        // 32-bit integer roll-over! This provider has processed over 
        // 4000000000 filter creations!  Canfetti is falling from the ceiling
        //

        DEBUGTRACE((LOG_ESS, "Filter ID rollover!!!\n"));

        // BUGBUG: Postpone a call to reactivate all filters!
    }

    //
    // Add a new destination entry
    //

    CEventDestination* pDestRecord = new CEventDestination(idNew, pDest);
    if(pDestRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_apDestinations.Add(pDestRecord);
            
    // Record the ID in the TARGETS
    // ============================

    *pID = idNew;
    return hres;
}

HRESULT CProviderSinkServer::AddFilter(LPCWSTR wszQuery, 
                    QL_LEVEL_1_RPN_EXPRESSION* pExp,
                    CAbstractEventSink* pDest, 
                    WBEM_REMOTE_TARGET_ID_TYPE* pidRequest)
{
    HRESULT hres;
    WBEM_REMOTE_TARGET_ID_TYPE idDest;

    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);

        // Copy proxies
        // ============

        if(!GetProxies(apProxies))
            return WBEM_E_OUT_OF_MEMORY;

        // Add to the list of destinations registered with the provider and
        // construct the target identification for the proxies
        // ================================================================

        hres = AddDestination(pDest, &idDest);
        if(FAILED(hres))
            return hres;
    }
    
    if(pidRequest)
        *pidRequest = idDest;

    // Go through all the proxies and schedule calls
    // =============================================

    HRESULT hresReal = WBEM_S_NO_ERROR;
    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        IWbemLocalFilterProxy *pLocalProxy = NULL;

        // See if the proxy will allow us to call LocalAddFilter (in which case
        // it's the pseudo proxy).
        if (SUCCEEDED(apProxies[i]->QueryInterface(
			IID_IWbemLocalFilterProxy, (LPVOID*) &pLocalProxy)))
        {
            CReleaseMe rm1(pLocalProxy);

            hres = pLocalProxy->LocalAddFilter( GetCurrentEssContext(), 
                                                wszQuery, 
                                                pExp, 
                                                idDest );

            hresReal = hres; // other errors do not matter
        }
        else
        {
            hres = apProxies[i]->AddFilter( GetCurrentEssContext(), 
                                            wszQuery,
                                            idDest );
        }

        if( FAILED(hres) )
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }

            ERRORTRACE((LOG_ESS, "Unable to add query %S to a remote provider "
                        "proxy. Error code: %X\n", wszQuery, hres));
        }
    }

    if ( FAILED(hresReal) )
    {
        CInCritSec ics(&m_cs);
        //
        // guaranteed no destinations can be added since we added the last
        // one, so remove the last one.
        //
        m_apDestinations.RemoveAt( m_apDestinations.GetSize()-1 );
    }
            
    return hresReal;
}

HRESULT CProviderSinkServer::RemoveFilter(CAbstractEventSink* pDest,
                                    WBEM_REMOTE_TARGET_ID_TYPE* pidRequest)
{
    HRESULT hres;

    // Find and invalidate the filter in the list of destinations
    // ==========================================================

    CEventDestination* pToRemove = NULL;
    CRefedPointerArray<IWbemFilterProxy> apProxies;

    {
        CInCritSec ics(&m_cs);
    
        // Copy the proxies
        // ================

        if(!GetProxies(apProxies))
            return WBEM_E_OUT_OF_MEMORY;

        // Search for it in the array of destinations
        // ==========================================

        for(int i = 0; i < m_apDestinations.GetSize(); i++)
        {
            if(m_apDestinations[i]->m_pSink == pDest)
            {
                m_apDestinations.RemoveAt(i, &pToRemove);
                break;
            }
        }

        if(pToRemove == NULL)
            return WBEM_E_NOT_FOUND;
    }

    if(pidRequest)
        *pidRequest = pToRemove->m_id;

    // The filter is invalidated, but not removed. We are outside of the CS, so
    // events can be delivered (but no other changes can occur)
    // =========================================================================
    
    // Instruct all proxies to (later) remove this filter from consideration
    // =====================================================================

    for(int i = 0; i < apProxies.GetSize(); i++) 
    {
        hres = apProxies[i]->RemoveFilter(GetCurrentEssContext(), 
                                            pToRemove->m_id);
        if(FAILED(hres))
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }

            ERRORTRACE((LOG_ESS, "Unable to remove filter %I64d from an event "
                "provider proxy: 0x%X\n", pToRemove->m_id, hres));
        }
    }

    //
    // Delete the destination in question
    // 

    delete pToRemove;

    return WBEM_S_NO_ERROR;
}

// assumes all proxies are locked
void CProviderSinkServer::RemoveAllFilters()
{
    CRefedPointerArray<IWbemFilterProxy> apProxies;

    {
        CInCritSec ics(&m_cs);
    
        // Copy the proxies
        // ================

        if(!GetProxies(apProxies))
            return;

        //
        // Clear out both the list of destinations 
        //

        m_apDestinations.RemoveAll();
    }

    //
    // Remove all filters from all proxies
    //

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        HRESULT hres = 
            apProxies[i]->RemoveAllFilters(GetCurrentEssContext());
    
        if(FAILED(hres))
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }

            ERRORTRACE((LOG_ESS, "Unable to remove all queries from a "
                        "remote provider proxy. Error code: %X\n", hres));
        }
    }

}

//
// Only allow utilization of the guarantee if the proxy's definition
// matches the provider's definition.  In other words, only when
// the provider's registration has been successfully processed,
// and the proxies are set up to reflect it, should utilization of
// the guarantee be allowed.  The reason for this is that an incomplete
// source definition can cause bad things to happen when events are
// evaluated using a filter that was optimized for that definition.
//
HRESULT CProviderSinkServer::AllowUtilizeGuarantee()
{
    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);

        if ( !GetProxies( apProxies ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        HRESULT hr = apProxies[i]->AllowUtilizeGuarantee();

        if ( FAILED(hr) && IsRpcError(hr) )
        {
            UnregisterProxy( apProxies[i] );
        }   
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CProviderSinkServer::AddDefinitionQuery(LPCWSTR wszQuery)
{
    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        
        GetProxies(apProxies);
        
        if ( m_awsDefinitionQueries.Add(wszQuery) < 0 ) 
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    //
    // we always try to add the definition to all proxies, but if there's an
    // error ( other than RPC ) we return it to the caller.
    //

    HRESULT hresReturn = WBEM_S_NO_ERROR;

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        HRESULT hres = apProxies[i]->AddDefinitionQuery(
                                            GetCurrentEssContext(), wszQuery);
        if( FAILED(hres) )
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }
            else
            {
                hresReturn = hres;
            } 

            ERRORTRACE((LOG_ESS, "Unable to add definition query %S to a "
                        "provider proxy. Error code: %X\n", wszQuery, hres));
        }
    }

    return hresReturn;
}

// assumes: all proxies are locked
void CProviderSinkServer::RemoveAllDefinitionQueries()
{
    CInCritSec ics(&m_cs);

    m_awsDefinitionQueries.Empty();

    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres = m_apProxies[i]->RemoveAllDefinitionQueries(
                                        GetCurrentEssContext());
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove all definition queries from"
                                 " a provider proxy. Error code: %X\n", hres));
        }
    }
}

void CProviderSinkServer::Clear()
{
    // Provider is being removed.  First, we disconnect all proxies, ensuring
    // that no more events are delivered
    // ======================================================================

    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        GetProxies(apProxies);
        m_apProxies.RemoveAll();
        m_awsDefinitionQueries.Empty();
    }

    //
    // since we are going to disconnect the proxy it is illegal to own the
    // namespace lock.  Reason is that disconnecting takes ownership of the
    // proxy lock. 
    //
    _DBG_ASSERT( !m_pNamespace->DoesThreadOwnNamespaceLock() );

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        apProxies[i]->Disconnect();
    }

    // Now we clean up
    // ===============

    RemoveAllFilters();
    RemoveAllDefinitionQueries();

    m_pReqSink = NULL;

    CWbemPtr<IUnknown> pStubUnk;

    HRESULT hr = m_Stub.QueryInterface( IID_IUnknown, (void**)&pStubUnk );

    _DBG_ASSERT( SUCCEEDED(hr) );

    hr = CoDisconnectObject( pStubUnk, 0 );

    if ( FAILED( hr ) )
    {
        ERRORTRACE((LOG_ESS,"Failed Disconnecting Stub.\n"));
    }
}

HRESULT CProviderSinkServer::Lock()
{
    //
    // it is illegal to lock proxies while holding the namespace lock.
    //
    _DBG_ASSERT( !m_pNamespace->DoesThreadOwnNamespaceLock() );

    // DEBUGTRACE((LOG_ESS, "Server %p locking all proxies\n", this));

    // First we lock all the proxies.  In the interim, events are still
    // delivered.  Once done, events are blocked in proxies
    // ================================================================

    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        //
        // First, check if we are already locked.  If so, no need to bother
        // the proxies. Not only that, but since proxies are out-of-proc, we 
        // would be re-locking them on a different thread, causing a deadlock.
        //
        if(m_lLocks++ > 0)
            return WBEM_S_NO_ERROR;

        GetProxies(apProxies);
    }

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        // DEBUGTRACE((LOG_ESS, "Server %p locking proxy %p\n", this,
        //             apProxies[i]));

        HRESULT hres = apProxies[i]->Lock();

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to lock a remote provider proxy. "
                                 "Error code: %X\n", hres));            
            //
            // if we couldn't lock it because of an RPC Error, simply 
            // unregister, else we have big problems and should unlock all 
            // the proxies and return the error.
            // 

            if ( IsRpcError( hres ) ) 
            {
                UnregisterProxy( apProxies[i] );
            }
            else
            {
                for(int j = 0; j < i; j++)
                    apProxies[j]->Unlock();
                return hres;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

BOOL CProviderSinkServer::GetProxies(
                            CRefedPointerArray<IWbemFilterProxy>& apProxies)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        if(apProxies.Add(m_apProxies[i]) < 0)
            return FALSE;
    }

    return TRUE; 
}
    

void CProviderSinkServer::Unlock()
{
    // DEBUGTRACE((LOG_ESS, "Server %p unlocking all proxies\n", this));
    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        //
        // First, check if this is the last unlock.  If not, we didn't forward
        // this lock, so we shouldn't forward this unlock either
        //
        if(--m_lLocks != 0)
            return;

        GetProxies(apProxies);
    }

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        // DEBUGTRACE((LOG_ESS, "Server %p unlocking proxy %p\n", this,
        //             apProxies[i]));
        HRESULT hres = apProxies[i]->Unlock();
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to unlock a remote provider proxy. "
                        "Error code: %X\n", hres));
            
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }
        }
    }
}




HRESULT STDMETHODCALLTYPE CProviderSinkServer::RegisterProxy(
                                                    IWbemFilterProxy* pProxy)
{
    // Initialize it with ourselves
    // ============================

    HRESULT hres = pProxy->Initialize(m_pMetaData, &m_Stub);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to initialize remote proxy: %X\n", hres));
        return hres;
    }

    //
    // aquire ns lock here because we need to ensure that we have a 
    // consistent set of definition queries and filters to initialize the
    // proxy with.  The cs member of this class is not good enough by 
    // itself because definition queries and filters are all manipulated 
    // separately but are always consistent outside of a ess namespace 
    // operation - which is why we grab the ns lock.  It is likely that 
    // the provider lock is held in this control path already, but it is 
    // allowed for provider lock to be held when aquiring the ns lock (
    // but not the other way around ).  We need to ensure that the 
    // update lock is ALWAYS aquired before the cs to avoid deadlocks.
    // Furthermore, we need to hold the lock while populating the provider
    // with the filters.  This is consistent with all other modifications to
    // the provider's filter.
    //
    CInUpdate iu( m_pNamespace );

    {
        CInCritSec ics(&m_cs);
        if(m_apProxies.Add(pProxy) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Add all the definition queries to this proxy
    //
    
    int i;
    BOOL bUtilizeGuarantee = TRUE;
        
    for(i = 0; i < m_awsDefinitionQueries.Size(); i++)
    {
        hres = pProxy->AddDefinitionQuery( GetCurrentEssContext(), 
                                           m_awsDefinitionQueries[i]);

        if(FAILED(hres))
        {
            //
            // TODO : We need to mark the provider as inactive.
            // 

            ERRORTRACE((LOG_ESS, "Unable to add definition query '%S' to "
                        "provider sink: 0x%X.\n", 
                        m_awsDefinitionQueries[i], hres));
                
            bUtilizeGuarantee = FALSE;
        }
    }

    if ( bUtilizeGuarantee )
    {
        pProxy->AllowUtilizeGuarantee();
    }
        
    //
    // Add all the filters to this proxy
    //

    for(i = 0; i < m_apDestinations.GetSize(); i++)
    {
        // Retrieve the filter from the event sink
        // =======================================

        CEventDestination* pDest = m_apDestinations[i];
    
        CEventFilter* pFilter = pDest->m_pSink->GetEventFilter();
        if(pFilter == NULL)
        {
            ERRORTRACE((LOG_ESS, "Internal error: non-filter sink in "
                        "proxy\n"));
            continue;
        }

        LPWSTR wszQuery;
        LPWSTR wszQueryLanguage;
        BOOL bExact;
        if(SUCCEEDED(pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery,
                                               bExact, NULL)) && bExact)
        {
            // Add this filter to this proxy
            // =============================

            hres = pProxy->AddFilter(GetCurrentEssContext(), wszQuery, 
                                     pDest->m_id);

            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS, "Unable to add query %S to a remote "
                            "provider proxy. Error code: %X\n", wszQuery, hres));
            }

            delete [] wszQuery;
            delete [] wszQueryLanguage;
        }
    }

    return WBEM_S_NO_ERROR;
}    

HRESULT STDMETHODCALLTYPE CProviderSinkServer::UnregisterProxy(
                                                    IWbemFilterProxy* pProxy)
{
    CInCritSec ics(&m_cs);

    // Look for it
    // ===========

    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        if(m_apProxies[i] == pProxy)
        {
            // It is safe to release it, since the caller has a ref-count
            // ==========================================================
            m_apProxies.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}





ULONG STDMETHODCALLTYPE CFilterStub::AddRef()
{
    return m_pSink->AddRef();
}

ULONG STDMETHODCALLTYPE CFilterStub::Release()
{
    return m_pSink->Release();
}

HRESULT STDMETHODCALLTYPE CFilterStub::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemFilterStub)
    {
        *ppv = (IWbemFilterStub*)this;
    }
    else if(riid == IID_IWbemMultiTarget)
    {
        *ppv = (IWbemMultiTarget*)this;
    }
    else if ( riid == IID_IWbemFetchSmartMultiTarget )
    {
        *ppv = (IWbemFetchSmartMultiTarget*)this;
    }
    else if ( riid == IID_IWbemSmartMultiTarget )
    {
        *ppv = (IWbemSmartMultiTarget*)this;
    }
    else if( riid == IID_IWbemEventProviderRequirements)
    {
        *ppv = (IWbemEventProviderRequirements*)this;
    }
    else return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFilterStub::RegisterProxy(IWbemFilterProxy* pProxy)
{
    return m_pSink->RegisterProxy(pProxy);
}

HRESULT STDMETHODCALLTYPE CFilterStub::UnregisterProxy(IWbemFilterProxy* pProxy)
{
    return m_pSink->UnregisterProxy(pProxy);
}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverEvent(DWORD dwNumEvents,
                    IWbemClassObject** apEvents, 
                    WBEM_REM_TARGETS* aTargets,
                    long lSDLength, BYTE* pSD)
{
    CEventContext Context;
    Context.SetSD( lSDLength, pSD, FALSE );
    return m_pSink->DeliverEvent( dwNumEvents, apEvents, aTargets, &Context );
}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverStatus(long lFlags, 
                    HRESULT hresStatus,
                    LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                    WBEM_REM_TARGETS* pTargets,
                    long lSDLength, BYTE* pSD)
{
    CEventContext Context;
    Context.SetSD( lSDLength, pSD, FALSE );
    return m_pSink->DeliverStatus(lFlags, hresStatus, wszStatus, pErrorObj,
                                    pTargets, &Context);
}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverProviderRequest(long lFlags)
{
    return m_pSink->DeliverProviderRequest(lFlags);
}

HRESULT STDMETHODCALLTYPE  CFilterStub::GetSmartMultiTarget( IWbemSmartMultiTarget** ppSmartMultiTarget )
{
    return QueryInterface( IID_IWbemSmartMultiTarget, (void**) ppSmartMultiTarget );

}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverEvent(ULONG dwNumEvents,
                    ULONG dwBuffSize, 
                    BYTE* pBuffer,
                    WBEM_REM_TARGETS* pTargets, 
                    long lSDLength, BYTE* pSD)
{

    // Unwind the buffer into an object.  Note that because m_ClassCache is
    // STL based, it is intrinsically thread-safe.  Also, calling proxies are
    // serialized, so we shouldn't have any thread-safety problems here.

    CWbemMtgtDeliverEventPacket packet( (LPBYTE) pBuffer, dwBuffSize );
    long lObjectCount; 
    IWbemClassObject ** pObjArray;
    HRESULT hr = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

    if ( SUCCEEDED( hr ) )
    {
        // Number must be dwNumEvents

        if(lObjectCount == dwNumEvents)
        {
            // Now call the standard deliver event function and hand it the
            // object

            hr = DeliverEvent(dwNumEvents, pObjArray, pTargets, lSDLength, pSD);
        }
        else
        {
            hr = WBEM_E_UNEXPECTED;
        }

        // Release the objects in the array and clean up pObjArray

        for ( int lCtr = 0; lCtr < lObjectCount; lCtr++ )
        {
            pObjArray[lCtr]->Release();
        }

        delete [] pObjArray;

    }   // IF UnmarshalPacket

    return hr;
}
        

void CProviderSinkServer::GetStatistics(long* plProxies, long* plDestinations,
                    long* plFilters, long* plTargetLists, long* plTargets,
                    long* plPostponed)
{
    *plProxies = m_apProxies.GetSize();
    *plDestinations = m_apDestinations.GetSize();

/* BUGBUG: do properly for all sinks
    ((CFilterProxy*)m_pSink)->GetStatistics(plFilters, plTargetLists, 
                                plTargets, plPostponed);
*/
}

//******************************************************************************
//******************************************************************************
//
//          CRECORD :: CQUERY RECORD
//
//******************************************************************************
//******************************************************************************
CEventProviderCache::CRecord::CQueryRecord::CQueryRecord()
    : m_strQuery(NULL), m_pEventClass(NULL), 
        m_dwEventMask(0), m_paInstanceClasses(NULL), m_pExpr(NULL)
{
}

HRESULT CEventProviderCache::CRecord::CQueryRecord::EnsureClasses( 
                                                    CEssNamespace* pNamespace )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    _IWmiObject* pClass;

    if ( m_pEventClass == NULL )
    {
        if ( SUCCEEDED( pNamespace->GetClass( m_pExpr->bsClassName, 
                                                &pClass ) ) )
        {
            m_pEventClass = pClass;
        }
        else
        {
            hres = WBEM_S_FALSE;
        }
    }

    if ( m_paInstanceClasses != NULL )
    {
        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);

            if ( pInfo->m_pClass == NULL )
            {
                if ( SUCCEEDED( pNamespace->GetClass( pInfo->m_wszClassName, 
                                                      &pClass) ) )
                {
                    pInfo->m_pClass = pClass;
                }
                else
                {
                    hres = WBEM_S_FALSE;
                }
            }
        }
    }
    else
    {
        hres = WBEM_S_FALSE;
    }
        
    return hres;
}

void CEventProviderCache::CRecord::CQueryRecord::ReleaseClasses()
{
    if ( m_pEventClass != NULL )
    {
        m_pEventClass->Release();
        m_pEventClass = NULL;
    }

    if ( m_paInstanceClasses != NULL )
    {
        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);

            if ( pInfo->m_pClass != NULL )
            {
                pInfo->m_pClass->Release();
                pInfo->m_pClass = NULL;
            }
        }
    }
}

HRESULT CEventProviderCache::CRecord::CQueryRecord::Initialize(
                                                LPCWSTR wszQuery,
                                                LPCWSTR wszProvName,
                                                CEssNamespace* pNamespace,
                                                bool bSystem)
{
    HRESULT hres;

    m_strQuery = SysAllocString(wszQuery);
    if(m_strQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Parse the query
    // ===============

    CTextLexSource Source((LPWSTR)wszQuery);
    QL1_Parser Parser(&Source);
    if(Parser.Parse(&m_pExpr) != QL1_Parser::SUCCESS)
    {
        ERRORTRACE((LOG_ESS,
            "Invalid query in provider registration: %S\n", wszQuery));

        CEventLog Log; Log.Open();
        Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_INVALID_EVENT_PROVIDER_QUERY,
                                wszQuery);
        return WBEM_E_UNPARSABLE_QUERY;
    }

    if(!bSystem)
    {
        if(!wbem_wcsicmp(m_pExpr->bsClassName, L"__Event") ||
           !wbem_wcsicmp(m_pExpr->bsClassName, L"__ExtrinsicEvent"))
        {
            ERRORTRACE((LOG_ESS,
                "Provider claims to provide all events with "
                "query:  %S\n"
                "We don't believe it, so we ignore the registration\n\n",
                wszQuery));
    
            CEventLog Log; Log.Open();
            Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_TOO_BROAD,
                                wszQuery);
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
    }

    // Determine its event mask
    // ========================

    m_dwEventMask = CEventRepresentation::GetTypeMaskFromName(
                                m_pExpr->bsClassName);

    // Check if the mask mentions any pollable events
    // ==============================================

    if(m_dwEventMask & INTRINSIC_EVENTS_MASK)
    {
        // Yes. Get instance classes for which it providers these events
        // =============================================================

        hres = CQueryAnalyser::GetDefiniteInstanceClasses(m_pExpr, 
                                            m_paInstanceClasses);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,
                "Unable to determine instance classes for which events"
                    "are provided by this query: %S\n", wszQuery));

            CEventLog Log; Log.Open();
            Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_INVALID_EVENT_PROVIDER_INTRINSIC_QUERY,
                                wszQuery);
            return WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY;
        }

        if(!bSystem && !m_paInstanceClasses->IsLimited())
        {
            ERRORTRACE((LOG_ESS,
                "Provider claims to provide all intrinsic events with "
                "query:  %S\n"
                "We don't believe it, so we ignore the registration\n\n",
                wszQuery));

            CEventLog Log; Log.Open();
            Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_TOO_BROAD,
                                wszQuery);
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }

        // Get the actual classes from the namespace
        // =========================================

        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);
            _IWmiObject* pClass = NULL;
            hres = pNamespace->GetClass(pInfo->m_wszClassName, &pClass);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS,
                    "Could not get class %S for which provider claims"
                    " to provider events. Error code: %X\n", 
                    pInfo->m_wszClassName, hres));

                CEventLog Log; Log.Open();
                Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_NOT_FOUND,
                                wszQuery, pInfo->m_wszClassName);

                //
                // Before continuing, we register for class creation event on 
                // this class.  This way, when it is finally created, we will 
                // reactivate stuff and bring the system back on track
                //
        
                hres = pNamespace->RegisterProviderForClassChanges( 
                                                        pInfo->m_wszClassName,
                                                        wszProvName );

                // ignore error code --- what can we do?
                return WBEM_S_FALSE;
            }
            
            //
            // don't store, we'll retrieve it later as necessary.  This 
            // will require that the user call EnsureClasses() before calling
            // any function that needs those classes.
            //

            pClass->Release();
        }
    }
            
    // Get the event class
    // ===================

    _IWmiObject* pClass = NULL;
    hres = pNamespace->GetClass(m_pExpr->bsClassName, &pClass);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS,
            "Invalid event class %S in provider registration \n"
                    "Query was: %S\n\n", m_pExpr->bsClassName, wszQuery));

        CEventLog Log; Log.Open();
        Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_NOT_FOUND,
                                wszQuery, m_pExpr->bsClassName);

        //
        // Before continuing, we register for class creation event on this
        // class.  This way, when it is finally created, we will reactivate
        // stuff and bring the system back on track
        //

        hres = pNamespace->RegisterProviderForClassChanges(
                                                        m_pExpr->bsClassName,
                                                        wszProvName );
        // ignore error code --- what can we do?

        return WBEM_S_FALSE;
    }

    //
    // don't store, we'll retrieve it later as necessary.  This 
    // will require that the user call EnsureClasses() before calling
    // any function that needs those classes.
    //
    
    CReleaseMe rmpClass( pClass );

    if( pClass->InheritsFrom(L"__Event") != S_OK)
    {
        ERRORTRACE((LOG_ESS,
            "Invalid event class %S in provider registration \n"
                    "Query was: %S\n\n", m_pExpr->bsClassName, wszQuery));

        CEventLog Log; Log.Open();
        Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_NOT_EVENT,
                                wszQuery, m_pExpr->bsClassName);
        return WBEM_S_FALSE;
    }

    return WBEM_S_NO_ERROR;
}
    
CEventProviderCache::CRecord::CQueryRecord::~CQueryRecord()
{
    SysFreeString(m_strQuery);
    if(m_pEventClass)
        m_pEventClass->Release();
    delete m_paInstanceClasses;
    delete m_pExpr;
}

HRESULT CEventProviderCache::CRecord::CQueryRecord::Update(LPCWSTR wszClassName,
                            IWbemClassObject* pClass)
{
    HRESULT hres = WBEM_S_FALSE;

    // Check the event class
    // =====================

    if(!wbem_wcsicmp(wszClassName, m_pExpr->bsClassName))
    {
        if(pClass == NULL)
        {
            // This query record is hereby invalid
            // ===================================

            ERRORTRACE((LOG_ESS, 
                "Event provider query, %S, is invalidated by class "
                "deletion of %S\n", m_strQuery, m_pExpr->bsClassName));

            if(m_pEventClass)
                m_pEventClass->Release();
            m_pEventClass = NULL;
            delete m_paInstanceClasses;
            m_paInstanceClasses = NULL;
        }
        else
        {
            // Change the class definition
            // ===========================

            if(m_pEventClass)
            {
                m_pEventClass->Release();
                m_pEventClass = NULL;
                hres = pClass->Clone(&m_pEventClass);
                if ( FAILED(hres) )
                	return hres;
            }
        }

        hres = WBEM_S_NO_ERROR;
    }
            
    if(m_paInstanceClasses)
    {
        // Check the instance classes
        // ==========================

        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);
            
            if(!wbem_wcsicmp(wszClassName, pInfo->m_wszClassName))
            {
                if(pClass)
                {
                    // This class is no longer there
                    // =============================
        
                    ERRORTRACE((LOG_ESS,
                        "Class %S for which provider claims to provide"
                        " events is deleted", pInfo->m_wszClassName));

                    m_paInstanceClasses->RemoveClass(i);
                    i--;
                }
                else
                {
                    // Change the class definition
                    // ===========================
        
                    if(pInfo->m_pClass)
                    {
                        pInfo->m_pClass->Release();
                        pInfo->m_pClass = NULL;
                        hres = pClass->Clone(&pInfo->m_pClass);
                        if ( FAILED(hres) )
                        	return hres;
                    }
                }
                hres = WBEM_S_NO_ERROR;
            }
        }
    }

    return hres;
}
    
HRESULT CEventProviderCache::CRecord::CQueryRecord::DoesIntersectWithQuery(
                        IN CRequest& Request, CEssNamespace* pNamespace)
{
    HRESULT hres;

    if(m_pEventClass == NULL)
    {
        // Inactive record
        
        return WBEM_S_FALSE;
    }

    // Check that the classes are related --- one is derived from another
    // ==================================================================

    if(m_pEventClass->InheritsFrom(Request.GetQueryExpr()->bsClassName) 
                                != WBEM_S_NO_ERROR && 
       Request.GetEventClass(pNamespace)->InheritsFrom(m_pExpr->bsClassName)
                                != WBEM_S_NO_ERROR
      )
    {
        // Not the right class.
        // ====================

        return WBEM_S_FALSE;
    }

    // For extrinsic providers, this is good enough. But for 
    // intrinsic providers, we need to check if the requested
    // instance classes intersect with the provided ones
    // ======================================================

    if(Request.GetEventMask() & INSTANCE_EVENTS_MASK)
    {
        INTERNAL CClassInfoArray* pClasses = NULL;
        hres = Request.GetInstanceClasses(pNamespace, &pClasses);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,
                "Failed to determine instance classes required by query '%S':"
                "0x%X\n", Request.GetQuery(), hres));
            
            return hres;
        }

        if(!CQueryAnalyser::CompareRequestedToProvided(
                                      *pClasses, 
                                      *m_paInstanceClasses))
        {
            // This intrinsic provider does not need activation
            // ================================================

            return WBEM_S_FALSE;
        }
    }

    // All test have been passed
    // =========================

    return WBEM_S_NO_ERROR;
}

DWORD CEventProviderCache::CRecord::CQueryRecord::GetProvidedEventMask(
                                                   IWbemClassObject* pClass,
                                                   BSTR strClassName)
{
    if(m_pEventClass == NULL || m_paInstanceClasses == NULL)
    {
        // Not active as an intrinsic provider record
        // ==========================================

        return 0;
    }

    // Check that we supply intrinsic events
    // =====================================

    if((m_dwEventMask & INSTANCE_EVENTS_MASK) == 0)
        return 0;

    // Go through all the instance classes for which it provides events
    // ================================================================

    for(int k = 0; k < m_paInstanceClasses->GetNumClasses(); k++)
    {
        CClassInformation* pInfo = m_paInstanceClasses->GetClass(k);
        if(pInfo->m_pClass == NULL)
        {
            // Non-existent class
            // ==================

            return 0;
        }

        //
        // If desired class is derived from the provided class, then we are 
        // covered.  If it is the other way around, we are not
        //

        if(pClass->InheritsFrom(pInfo->m_wszClassName) == S_OK)
            return m_dwEventMask;
  }

    return 0;
}
    
//******************************************************************************
//******************************************************************************
//
//                                  CRECORD
//
//******************************************************************************
//******************************************************************************

CEventProviderCache::CRecord::CRecord()
    : m_strName(NULL), m_lRef(0), m_bStarted(false), m_lPermUsageCount(0),
       m_bProviderSet(FALSE), m_lUsageCount(0), m_pProvider(NULL),
       m_pQuerySink(NULL), m_pMainSink(NULL), m_pSecurity(NULL),
       m_LastUse(CWbemTime::GetCurrentTime()), m_bRecorded(FALSE),
       m_bNeedsResync(TRUE), m_strNamespace(NULL)
{
}

HRESULT CEventProviderCache::CRecord::Initialize( LPCWSTR wszName,
                                                  CEssNamespace* pNamespace )
                  
{
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    m_pMainSink = new CProviderSinkServer();
    if(m_pMainSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    m_pMainSink->AddRef();

    m_strNamespace = SysAllocString(pNamespace->GetName());
    if(m_strNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if ( wszName != NULL )
    {
        m_strName = SysAllocString(wszName);
        if(m_strName == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return m_pMainSink->Initialize(pNamespace, this);
}

CEventProviderCache::CRecord::~CRecord()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    if( m_pMainSink )
    {
        //
        // shutdown and release the sink server.  We must postpone the 
        // shutdown though because it will release any outstanding 
        // proxies which cannot be done while holding the namespace lock.
        //
        
        CPostponedList* pList = GetCurrentPostponedList();

        _DBG_ASSERT( pList != NULL );

        CPostponedSinkServerShutdown* pReq;

        pReq = new CPostponedSinkServerShutdown( m_pMainSink );

        if ( pReq != NULL )
        {
            if ( FAILED(pList->AddRequest( m_pNamespace, pReq ) ) )
            {
                delete pReq;
            }
        }

        m_pMainSink->Release();
    }

    UnloadProvider();

    SysFreeString(m_strNamespace);
    SysFreeString(m_strName);
}

ULONG CEventProviderCache::CRecord::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CEventProviderCache::CRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

BOOL CEventProviderCache::CRecord::IsEmpty() 
{
    return ( !m_bProviderSet && m_apQueries.GetSize() == 0);
}

HRESULT CEventProviderCache::CRecord::SetProvider(IWbemClassObject* pWin32Prov)
{
    HRESULT hres;

    // Clean out the old data
    // ======================
    
    m_bProviderSet = FALSE;

    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);

    // Verity object validity
    // ======================

    if(pWin32Prov->InheritsFrom(WIN32_PROVIDER_CLASS) != WBEM_S_NO_ERROR)
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;

    // removed doublecheck -  a decoupled provider does not have a clsid
	// if(FAILED(pWin32Prov->Get(PROVIDER_CLSID_PROPNAME, 0, &v, NULL, NULL)) ||
    //        V_VT(&v) != VT_BSTR)
    //    return WBEM_E_INVALID_PROVIDER_REGISTRATION;

    if(m_pProvider)
    {
        UnloadProvider();
    }

    // Store object for later use
    // ==========================

    m_bProviderSet = TRUE;

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::ResetProvider()
{
    if(m_bProviderSet)
    {
        m_bProviderSet = FALSE;
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_S_FALSE;
    }
}

HRESULT CEventProviderCache::CRecord::GetProviderInfo(
                                       IWbemClassObject* pRegistration, 
                                       BSTR& strName)
{
    VARIANT v;
    VariantInit(&v);
    strName = NULL;

    if(FAILED(pRegistration->Get(PROVIDER_NAME_PROPNAME, 0, &v, NULL, NULL)) ||
            V_VT(&v) != VT_BSTR)
    {
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    strName = V_BSTR(&v);
    // VARIANT intentionally not cleared
    return WBEM_S_NO_ERROR;
}
    
HRESULT CEventProviderCache::CRecord::GetRegistrationInfo(
                                       IWbemClassObject* pRegistration, 
                                       BSTR& strName)
{
    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);
    strName = NULL;

    if(FAILED(pRegistration->Get(EVPROVREG_PROVIDER_REF_PROPNAME, 0, &v, 
            NULL, NULL)) || V_VT(&v) != VT_BSTR)
    {
        ERRORTRACE((LOG_ESS, "NULL provider reference in event provider "
            "registration! Registration is invalid\n"));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    // Parse the path
    // ==============

    CObjectPathParser Parser;
    ParsedObjectPath* pPath;
    int nRes = Parser.Parse(V_BSTR(&v), &pPath);
    if(nRes != CObjectPathParser::NoError)
    {
        ERRORTRACE((LOG_ESS, "Unparsable provider reference in event provider "
            "registration: %S. Registration is invalid\n", V_BSTR(&v)));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    //
    // It would be good to check that the class specified here is valid, but
    // we cannot just compare the name since this may be a derived class of
    // __Win32Provider.  And getting the class definition and comparing would
    // be too expensive, so we'll just trust the provider here
    //
    //
    // if(wbem_wcsicmp(pPath->m_pClass, WIN32_PROVIDER_CLASS))
    // {
    //     Parser.Free(pPath);
    //     return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    // }

    if(pPath->m_dwNumKeys != 1)
    {
        Parser.Free(pPath);
        ERRORTRACE((LOG_ESS, "Wrong number of keys in provider reference in "
            "event provider registration: %S. Registration is invalid\n", 
            V_BSTR(&v)));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    if(V_VT(&pPath->m_paKeys[0]->m_vValue) != VT_BSTR)
    {
        Parser.Free(pPath);
        ERRORTRACE((LOG_ESS, "Wrong key type in provider reference in event "
            "provider registration: %S. Registration is invalid\n", 
            V_BSTR(&v)));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    strName = SysAllocString(V_BSTR(&pPath->m_paKeys[0]->m_vValue));
    Parser.Free(pPath);

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::SetQueries(CEssNamespace* pNamespace, 
                                                IWbemClassObject* pRegistration)
{
    HRESULT hres;
        
    // Get the list of class names
    // ===========================

    VARIANT v;
    VariantInit(&v);

    if(FAILED(pRegistration->Get(EVPROVREG_QUERY_LIST_PROPNAME, 0, &v, 
        NULL, NULL)) || V_VT(&v) != (VT_BSTR | VT_ARRAY))
    {
        ResetQueries();
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }
    CClearMe cm(&v);

    SAFEARRAY* psa = V_ARRAY(&v);
    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lElements = lUBound - lLBound + 1;

    BSTR* astrQueries;
    SafeArrayAccessData(psa, (void**)&astrQueries);
    CUnaccessMe um(psa);
    
    return SetQueries(pNamespace, lElements, (LPCWSTR*)astrQueries);
}

HRESULT CEventProviderCache::CRecord::SetQueries(CEssNamespace* pNamespace, 
                                                 long lNumQueries,
                                                 LPCWSTR* awszQueries)
{
    HRESULT hres;

    ResetQueries();

    // Create a record for each query
    // ==============================

    BOOL bUtilizeGuarantee = TRUE;

    for(long lQueryIndex = 0; lQueryIndex < lNumQueries; lQueryIndex++)
    {
        hres = AddDefinitionQuery(pNamespace, awszQueries[lQueryIndex]);

        if ( FAILED(hres) )
        {
            bUtilizeGuarantee = FALSE;
        }
        
        if( hres == WBEM_E_OUT_OF_MEMORY )
        {
            return hres;
        }
    }

    if ( bUtilizeGuarantee )
    {
        m_pMainSink->AllowUtilizeGuarantee();
    }

    return WBEM_S_NO_ERROR;
}


// assumes: CProviderSinkServer locked!
HRESULT CEventProviderCache::CRecord::AddDefinitionQuery(
                                                CEssNamespace* pNamespace, 
                                                LPCWSTR wszQuery)
{
    HRESULT hres;

    CQueryRecord* pNewQueryRecord = new CQueryRecord;
    if(pNewQueryRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = pNewQueryRecord->Initialize( wszQuery, m_strName, pNamespace, IsSystem());
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS,
            "Skipping provider %S invalid registration query %S\n",
            m_strName, wszQuery));
    }
    else
    {
        hres = m_pMainSink->AddDefinitionQuery(wszQuery);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, 
                "Skipping provider %S registration query %S\n"
               "   failed to merge: %X\n", 
                    m_strName, wszQuery, hres));
        }
        if(m_apQueries.Add(pNewQueryRecord) < 0)
        {
            delete pNewQueryRecord;
            hres = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hres;
}

HRESULT CEventProviderCache::CRecord::ResetQueries()
{
    m_apQueries.RemoveAll();
    m_pMainSink->RemoveAllDefinitionQueries();
    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::PostponeNewQuery(CExecLine::CTurn* pTurn,
        DWORD dwId, LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
        CAbstractEventSink* pDest)
{
    CPostponedList* pList = GetCurrentPostponedList();
    //
    // if null, then no thread object associated with thread.  caller may
    // need to use an CEssInternalOperationSink.
    // 
    _DBG_ASSERT( pList != NULL );

    CPostponedNewQuery* pReq = new CPostponedNewQuery(this, dwId, 
                        wszQueryLanguage, wszQuery, pTurn, pDest);
    if(pReq == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    HRESULT hr = pList->AddRequest( m_pNamespace, pReq);

    if ( FAILED(hr) )
    {
        delete pReq;
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::PostponeCancelQuery(
                                        CExecLine::CTurn* pTurn, DWORD dwId)
{
    CPostponedList* pList = GetCurrentPostponedList();
    //
    // if null, then no thread object associated with thread.  caller may
    // need to use an CEssInternalOperationSink.
    // 
    _DBG_ASSERT( pList != NULL );
    
    CPostponedCancelQuery* pReq = new CPostponedCancelQuery(this, pTurn, dwId);
    
    if( pReq == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = pList->AddRequest( m_pNamespace, pReq );

    if ( FAILED(hr) )
    {
        delete pReq;
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

// assumes: no locks are held
HRESULT CEventProviderCache::CRecord::Exec_LoadProvider(
                                            CEssNamespace* pNamespace)
{
    HRESULT hres;

    // Having locked the namespace, retrieve the necessary parameters
    // ==============================================================

    CLSID clsid;

    IWbemObjectSink* pEventSink = NULL;
    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        // Check if it is already loaded
        // =============================

        if(m_pProvider)
            return WBEM_S_FALSE;
    } 

    IWbemEventProvider* pProvider = NULL;
    hres = m_pNamespace->LoadEventProvider(m_strName, &pProvider);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to load event provider '%S' in namespace "
                    "'%S': 0x%X\n", m_strName, m_pNamespace->GetName(), hres));
        return hres;
    }
    CReleaseMe rm1(pProvider);

/* TAKEN CARE OF BY THE PROVSS
    //
    // In case this is a "framework" provider, inform it of its registration
    //

    IWbemProviderIdentity* pIdent = NULL;
    hres = pProvider->QueryInterface(IID_IWbemProviderIdentity, 
                                            (void**)&pIdent);
    if(SUCCEEDED(hres))
    {
        CReleaseMe rm(pIdent);
        hres = pIdent->SetRegistrationObject(0, m_pWin32Prov);

		if(hres == WBEM_E_PROVIDER_NOT_CAPABLE)
			hres = WBEM_S_SUBJECT_TO_SDS;

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Event provider %S failed to accept its "
                "registration object with error code 0x%X\n", m_strName, hres));
            return hres;
        }
    }
*/

    //
    // Deposit this and other provider pointers into the record
    //

    hres = SetProviderPointer(pNamespace, pProvider);
    if(FAILED(hres))
        return hres;

    //
    // Report the MSFT_WmiEventProviderLoaded event.
    //

    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiEventProviderLoaded], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        pNamespace->GetName(),
        m_strName);

    //
    // Postpone start until all activations are done
    //

    CPostponedList* pList = GetCurrentPostponedList();
    //
    // if null, then no thread object associated with thread.  caller may
    // need to use an CEssInternalOperationSink.
    // 
    _DBG_ASSERT( pList != NULL );
    
    CPostponedProvideEvents* pReq = new CPostponedProvideEvents(this);
    
    if(pReq == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = pList->AddRequest( m_pNamespace, pReq);

    if ( FAILED(hres) )
    {
        delete pReq;
    }
    
    return hres;
}

HRESULT CEventProviderCache::CRecord::SetProviderPointer(
                                                CEssNamespace* pNamespace,
                                                IWbemEventProvider* pProvider)
{
    HRESULT hres;

    //
    // Check the "smart provider" interface
    //

    IWbemEventProviderQuerySink* pQuerySink = NULL;
    hres = pProvider->QueryInterface(IID_IWbemEventProviderQuerySink,
                            (void**)&pQuerySink);
    CReleaseMe rm4(pQuerySink);

    //
    // Check the security interface
    //

    IWbemEventProviderSecurity* pSecurity = NULL;
    hres = pProvider->QueryInterface(IID_IWbemEventProviderSecurity,
                            (void**)&pSecurity);
    CReleaseMe rm5(pSecurity);

    // Having locked the namespace, deposit the pointers into the record
    // =================================================================

    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        m_pProvider = pProvider;
        pProvider->AddRef();
        m_pQuerySink = pQuerySink;
        if(pQuerySink)
            pQuerySink->AddRef();

        m_pSecurity = pSecurity;
        if(pSecurity)
            pSecurity->AddRef();
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CEventProviderCache::CRecord::Exec_StartProvider(
                                            CEssNamespace* pNamespace)
{
    IWbemEventProvider* pProvider = NULL;
    IWbemEventSink* pEventSink = NULL;
    HRESULT hres;

    {
        CInUpdate iu(pNamespace);

        if(m_bStarted)
            return WBEM_S_NO_ERROR;

        m_bStarted = true;

        pProvider = m_pProvider;
        if(pProvider)
            pProvider->AddRef();

        // Retrieve the sink to give to the provider
        // =========================================

        hres = m_pMainSink->GetMainProxy(&pEventSink);
        if(FAILED(hres))
            return hres;
    }

    CReleaseMe rm1(pProvider);
    CReleaseMe rm2(pEventSink);

    if(pProvider)
    {
        //
        // all calls to provider ( except AccessCheck ) should be made as 
        // the system.  It is incorrect to propagate the client's identity 
        // along in this call.
        //
        IUnknown *pOldCtx, *pTmpCtx;
        hres = CoSwitchCallContext( NULL, &pOldCtx );
        if ( FAILED( hres ) )
            return hres;
            
        hres = pProvider->ProvideEvents(pEventSink, 0);

        HRESULT hr = CoSwitchCallContext( pOldCtx, &pTmpCtx ); 
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,
                "Could not start provider %S. Error: %X\n", m_strName, hres));
            CInUpdate iu( pNamespace );
            UnloadProvider();
            return WBEM_E_PROVIDER_FAILURE;
        }
        else if ( FAILED(hr) ) // propagate ProvideEvents code in success case.
        {
            hres = hr;
        }

        return hres;
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::AddActiveProviderEntryToRegistry()
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace, hkeyProvider;

    DEBUGTRACE((LOG_ESS,"Adding provider %S from namespace %S to "
                " registry as active provider\n", m_strName, m_strNamespace));

    //
    // open ess key.  It is expected that this key is already created. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );

    if ( lRes == ERROR_SUCCESS )
    {
        //
        // open namespace key. It is expected that this key is already created.
        //

        lRes = RegOpenKeyExW( hkeyEss,
                              m_strNamespace,
                              0, 
                              KEY_ALL_ACCESS,
                              &hkeyNamespace );

        if ( lRes == ERROR_SUCCESS )
        {
            //
            // create the provider sub key.
            //

            lRes = RegCreateKeyExW( hkeyNamespace,
                                    m_strName,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hkeyProvider,
                                    NULL );

            if ( lRes == ERROR_SUCCESS )
            {
                RegCloseKey( hkeyProvider );
            }
            
            RegCloseKey( hkeyNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    return HRESULT_FROM_WIN32( lRes );
}

HRESULT CEventProviderCache::CRecord::RemoveActiveProviderEntryFromRegistry()
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace;

    DEBUGTRACE((LOG_ESS,"Removing provider %S from namespace %S from "
                " registry as active provider\n", m_strName, m_strNamespace));

    //
    // open ess key. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );

    if ( lRes == ERROR_SUCCESS )
    {
        //
        // open namespace key. It is expected that this key is already created.
        //

        lRes = RegOpenKeyExW( hkeyEss,
                              m_strNamespace,
                              0, 
                              KEY_ALL_ACCESS,
                              &hkeyNamespace );

        if ( lRes == ERROR_SUCCESS )
        {
            //
            // delete the provider sub key.
            //
            
            lRes = RegDeleteKeyW( hkeyNamespace, m_strName );

            RegCloseKey( hkeyNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    return HRESULT_FROM_WIN32( lRes );
}
                           
void CEventProviderCache::CRecord::UnloadProvider()
{
    HRESULT hr;

    DEBUGTRACE((LOG_ESS,"Unloading Provider %S in namespace %S\n",
                m_strName, m_strNamespace ));

    //
    // make sure the provider is removed from the provider cache.  This is 
    // so if we load the provider again in the near future, we don't call 
    // ProvideEvents() on it twice. 
    // 

    if ( m_pProvider != NULL )
    {
        CWbemPtr<_IWmiProviderCache> pProvCache;

        hr = m_pProvider->QueryInterface( IID__IWmiProviderCache, 
                                          (void**)&pProvCache );

        if ( SUCCEEDED(hr) )
        {
            hr = pProvCache->Expel( 0, GetCurrentEssContext() );

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"Could not expel provider %S from "
                            "provider cache in namespace %S. HR=0x%x\n",
                            m_strName,m_strNamespace,hr));
            }
        }

        m_pNamespace->PostponeRelease(m_pProvider);
        m_pProvider = NULL;
    }

    if(m_pQuerySink)
        m_pNamespace->PostponeRelease(m_pQuerySink);
    m_pQuerySink = NULL;

    if(m_pSecurity)
        m_pNamespace->PostponeRelease(m_pSecurity);
    m_pSecurity = NULL;
    m_bStarted = false;

    //
    // Report the MSFT_WmiEventProviderUnloaded event.
    //
    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiEventProviderUnloaded], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        m_strNamespace,
        m_strName);
}

HRESULT CEventProviderCache::CRecord::Exec_NewQuery(CEssNamespace* pNamespace,
            CExecLine::CTurn* pTurn,
            DWORD dwID, LPCWSTR wszLanguage, LPCWSTR wszQuery,
            CAbstractEventSink* pDest)
{
    HRESULT hres;

    // Wait for our turn to make changes
    // =================================

    CExecLine::CInTurn it(&m_Line, pTurn);
    
    hres = ActualExecNewQuery(pNamespace, dwID, wszLanguage, wszQuery, pDest);
    if(FAILED(hres))
    {
        //
        // Check:  it could be provider needs to be restarted
        //
    
        if(HRESULT_FACILITY(hres) != FACILITY_ITF)
        {
            ERRORTRACE((LOG_ESS, "Non-WMI error code recieved from provider "
                "%S: 0x%x.  WMI will attempt to re-activate\n", m_strName,
                hres));

            {
                CInUpdate iu( pNamespace );        
                UnloadProvider();
            }
            
            hres = ActualExecNewQuery(pNamespace, dwID, wszLanguage, wszQuery,
                                        pDest);
        }
    }

    if(FAILED(hres))
    {
        // Filter activation failed:  deactivate
        // =====================================

        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        pNamespace->DeactivateFilter(pDest->GetEventFilter());
    }

    return hres;
}

HRESULT CEventProviderCache::CRecord::ActualExecNewQuery(
            CEssNamespace* pNamespace,
            DWORD dwID, LPCWSTR wszLanguage, LPCWSTR wszQuery,
            CAbstractEventSink* pDest)
{
    HRESULT hres;

    // Ensure provider is loaded
    // =========================

    hres = Exec_LoadProvider(pNamespace);
    if(FAILED(hres))
        return hres;

    // With namespace locked, check if the provider is loaded
    // ======================================================

    IWbemEventProviderQuerySink* pSink = NULL;
    IWbemEventProviderSecurity* pSecurity = NULL;
    PSID pCopySid = NULL;
    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        if(m_pQuerySink != NULL)
        {
            pSink = m_pQuerySink;
            pSink->AddRef();
        }
        if(m_pSecurity != NULL)
        {
            pSecurity = m_pSecurity;
            pSecurity->AddRef();

            // Make a copy of the filter's owner SID
            // =====================================

            PSID pActualSid = pDest->GetEventFilter()->GetOwner();
            if(pActualSid != NULL)
            {
                pCopySid = new BYTE[GetLengthSid(pActualSid)];
                if(pCopySid == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
    
                if(!CopySid(GetLengthSid(pActualSid), pCopySid, pActualSid))
                {
                    delete [] pCopySid;
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    CReleaseMe rm1(pSink);
    CReleaseMe rm2(pSecurity);
    CVectorDeleteMe<BYTE> vdm((BYTE*)pCopySid);
    
    //
    // Check security, if possible.  If provider does not support the interface,
    // interpret as "check SDs", as this may be a new-model-only provider
    //

    hres = WBEM_S_SUBJECT_TO_SDS;
    if(pSecurity)
    {
        DWORD dwSidLen = pCopySid ? GetLengthSid(pCopySid) : 0;

        // Check security based on the SID or thread
        // =========================================

        if ( dwSidLen == 0 )
        {
            //
            // Check security based on the thread.  First save the current
            // call context, then switch it back after we're done.
            //
            
            IUnknown *pOldCtx, *pTmpCtx;
            hres = CoSwitchCallContext( NULL, &pOldCtx );
            if ( FAILED( hres ) )
            {
                return hres;
            }
            
            CWbemPtr<IUnknown> pNewCtx;
            hres = pDest->GetEventFilter()->SetThreadSecurity( &pNewCtx );

            if ( FAILED( hres ) )
            {
                return hres;
            }
            
            hres = pSecurity->AccessCheck( wszLanguage, 
                                           wszQuery, 
                                           0, 
                                           NULL );

            HRESULT hr = CoSwitchCallContext( pOldCtx, &pTmpCtx ); 

            if ( SUCCEEDED( hres ) && FAILED( hr ) )
            {
                hres = hr;
            }
        }
        else
        {
            hres = pSecurity->AccessCheck( wszLanguage, 
                                           wszQuery, 
                                           dwSidLen, 
                                           (BYTE*)pCopySid);
        }

        //
        // Report the MSFT_WmiEventProviderAccessCheck event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiEventProviderAccessCheck], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_strNamespace,
            m_strName,
            wszLanguage,
            wszQuery,
            pCopySid, dwSidLen,
            hres);
    }
    
	if(hres == WBEM_E_PROVIDER_NOT_CAPABLE)
		hres = WBEM_S_NO_ERROR;

    if(SUCCEEDED(hres))
    {
        // Security check has been passed: decrement remaining count
        // =========================================================

        pDest->GetEventFilter()->DecrementRemainingSecurityChecks(hres);
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Event provider refused consumer registration "
            "query %S for security reasons: 0x%X\n", wszQuery, hres));
    }

    // Call "NewQuery" if required
    // ===========================

    if(SUCCEEDED(hres) && pSink)
    {
        IUnknown *pOldCtx, *pTmpCtx;
        hres = CoSwitchCallContext( NULL, &pOldCtx );

        if ( SUCCEEDED(hres) )
        {
            hres = pSink->NewQuery(dwID, (LPWSTR)wszLanguage,(LPWSTR)wszQuery);
            if(hres == WBEM_E_PROVIDER_NOT_CAPABLE)
                hres = WBEM_S_NO_ERROR;

            HRESULT hr = CoSwitchCallContext( pOldCtx, &pTmpCtx );
            if ( SUCCEEDED(hres) && FAILED(hr) )
                hres = hr;
        }

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Event provider refused consumer registration "
                "query %S: error code 0x%X\n", wszQuery, hres));
        }

        //
        // Report the MSFT_WmiEventProviderNewQuery event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiEventProviderNewQuery], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_strNamespace,
            m_strName,
            wszLanguage,
            wszQuery,
            dwID,
            hres);
    }

    return hres;
}

HRESULT CEventProviderCache::CRecord::Exec_CancelQuery(
                            CEssNamespace* pNamespace, CExecLine::CTurn* pTurn,
                            DWORD dwId)
{
    CExecLine::CInTurn it(&m_Line, pTurn);

    // With namespace locked, check if the provider is loaded
    // ======================================================

    IWbemEventProviderQuerySink* pSink = NULL;
    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        if(m_pQuerySink == NULL)
            return WBEM_S_FALSE;

        pSink = m_pQuerySink;
        pSink->AddRef();
    }

    CReleaseMe rm1(pSink);
    
    // Make the call
    // =============
    HRESULT hr;

    IUnknown *pOldCtx, *pTmpCtx;
    hr = CoSwitchCallContext( NULL, &pOldCtx );

    if ( SUCCEEDED(hr) )
    {
        hr = pSink->CancelQuery(dwId);
        HRESULT hr2 = CoSwitchCallContext( pOldCtx, &pTmpCtx );
        if ( SUCCEEDED(hr) && FAILED(hr2) )
            hr = hr2;
    }
    
    //
    // Report the MSFT_WmiEventProviderCancelQuery event.
    //
    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiEventProviderCancelQuery], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        m_strNamespace,
        m_strName,
        dwId,
        hr);

    return hr;
}

HRESULT CEventProviderCache::CRecord::DeliverProviderRequest(
                        long lFlags)
{
    HRESULT hres;

    //
    // The only requirement we support is WBEM_REQUIREMENT_RECHECK_SUBSCRIPTIONS
    //

    if(lFlags != WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS)
        return WBEM_E_INVALID_PARAMETER;

    //
    // With this object locked, retrieve all the filters for this provider. 
    // Get provider pointers, as well
    //

    CProviderSinkServer::TDestinationArray apDestinations;
    IWbemEventProviderQuerySink* pSink = NULL;
    IWbemEventProviderSecurity* pSecurity = NULL;

    {
        CInUpdate iu(m_pMainSink->GetNamespace());

        hres = m_pMainSink->GetDestinations(apDestinations);
        if(FAILED(hres))
            return hres;

        if(m_pQuerySink != NULL)
        {
            pSink = m_pQuerySink;
            pSink->AddRef();
        }

        if(m_pSecurity != NULL)
        {
            pSecurity = m_pSecurity;
            pSecurity->AddRef();
        }
    }

    CReleaseMe rm1(pSink);
    CReleaseMe rm2(pSecurity);

    // 
    // Iterate over them all, rechecking each with the provider
    //

    for(int i = 0; i < apDestinations.GetSize(); i++)
    {
        CProviderSinkServer::CEventDestination* pEventDest = apDestinations[i];
        CAbstractEventSink* pDest = pEventDest->m_pSink;

        // 
        // Retrieve the event filter associated with this sink
        //

        CEventFilter* pFilter = pDest->GetEventFilter();
        if(pFilter == NULL)
        {
            ERRORTRACE((LOG_ESS, "Internal error: non-filter sink in proxy\n"));
            continue;
        }

        //
        // Retrieve the query from this filter.
        //

        LPWSTR wszQuery;
        LPWSTR wszQueryLanguage;
        BOOL bExact;
        hres = pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery,
                                       bExact, NULL);
        if(FAILED(hres) || !bExact)
            continue;
        
        CVectorDeleteMe<WCHAR> vdm1(wszQuery);
        CVectorDeleteMe<WCHAR> vdm2(wszQueryLanguage);

        //
        // Check security first
        //

        if(pSecurity)
        {
            PSID pSid = pFilter->GetOwner();
            if(pSid)
            {
                // Check security based on SID
                hres = pSecurity->AccessCheck(wszQueryLanguage, wszQuery, 
                                            GetLengthSid(pSid), 
                                            (BYTE*)pSid);
            }
            else
            {
                //
                // Check security based on the thread.  First save the current
                // call context, then switch it back after we're done.
                //

                IUnknown *pOldCtx, *pTmpCtx;
                hres = CoSwitchCallContext( NULL, &pOldCtx );
                if ( FAILED( hres ) )
                {
                    return hres;
                }
                
                CWbemPtr<IUnknown> pNewCtx;
                hres = pFilter->SetThreadSecurity( &pNewCtx );

                if ( FAILED(hres) )
                {
                    return hres;
                }

                hres = pSecurity->AccessCheck( wszQueryLanguage, 
                                               wszQuery, 
                                               0, 
                                               NULL );

                HRESULT hr = CoSwitchCallContext( pOldCtx, &pTmpCtx ); 

                if ( SUCCEEDED( hres ) && FAILED( hr ) )
                {
                    hres = hr;
                }
            }
            
            if(FAILED(hres))
            {
                //
                // Increment remaining security checks, thus disabling filter
                //

                ERRORTRACE((LOG_ESS, "Disabling filter %S as provider denies "
                    " access for this user: 0x%X\n", wszQuery, hres));
                
                pFilter->IncrementRemainingSecurityChecks();

                pDest->SetStatus( 0, WBEM_E_CALL_CANCELLED, NULL, NULL );
            }
        }

        if(SUCCEEDED(hres) && pSink)
        {
            //
            // Check everything else --- do a NewQuery
            //

            hres = pSink->NewQuery(pEventDest->m_id, (LPWSTR)wszQueryLanguage, 
                        (LPWSTR)wszQuery);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS, "Disabling filter %S as provider refuses "
                    "registration: error code 0x%X\n", wszQuery, hres));
            }
        }
    }
    
    return hres;
}

CExecLine::CTurn* CEventProviderCache::CRecord::GetInLine()
{
    return m_Line.GetInLine();
}
void CEventProviderCache::CRecord::DiscardTurn(CExecLine::CTurn* pTurn)
{
    m_Line.DiscardTurn(pTurn);
}

HRESULT CEventProviderCache::CRecord::Activate(CEssNamespace* pNamespace, 
                                                CRequest* pRequest,
                                        WBEM_REMOTE_TARGET_ID_TYPE idRequest)
{
    CExecLine::CTurn* pTurn = GetInLine();
    if(pTurn == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_lUsageCount++;
    m_LastUse = CWbemTime::GetCurrentTime();

    if ( pRequest->GetDest()->GetEventFilter()->IsPermanent() )
    {
        m_lPermUsageCount++;
        CheckPermanentUsage();
    }

    // Notify him of the new query, if required
    // ========================================

    HRESULT hr;

    hr = PostponeNewQuery( pTurn, 
                           idRequest, 
                           L"WQL", 
                           pRequest->GetQuery(), 
                           pRequest->GetDest() );
    if ( FAILED(hr) )
    {
        DiscardTurn( pTurn );
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::Deactivate( CAbstractEventSink* pDest,
                                        WBEM_REMOTE_TARGET_ID_TYPE idRequest )
{
    if( !m_bProviderSet )
    {
        // Provider is not registered.
        // ===========================

        return WBEM_S_FALSE;
    }

    // Notify him of the cancellation, if required
    // ===========================================

    CExecLine::CTurn* pTurn = GetInLine();

    if(pTurn == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = PostponeCancelQuery(pTurn, idRequest);

    if ( FAILED(hr) )
    {
        DiscardTurn( pTurn );
        return hr;
    }

    m_lUsageCount--;
    m_LastUse = CWbemTime::GetCurrentTime();
    
    if ( pDest->GetEventFilter()->IsPermanent() )
    {
        //
        // TODO: Out usage counts can easily get out of wack because of 
        // mismatched Activate/Deactivates in the presence of failures.
        // _DBG_ASSERT( m_lPermUsageCount > 0 );
        //
        m_lPermUsageCount--;
        CheckPermanentUsage();
    }
        
    return WBEM_S_NO_ERROR;
}
    
HRESULT CEventProviderCache::CRecord::DeactivateFilter(
                                        CAbstractEventSink* pDest)
{
    HRESULT hres;

    // Try to remove it from our stub
    // ==============================

    WBEM_REMOTE_TARGET_ID_TYPE idRequest;
    hres = m_pMainSink->RemoveFilter(pDest, &idRequest);

    if(hres == WBEM_E_NOT_FOUND) // not there --- no problem
        return WBEM_S_FALSE;
    else if(FAILED(hres))
        return hres;

    hres = Deactivate( pDest, idRequest);

    return hres;
}



HRESULT CEventProviderCache::CRecord::ActivateIfNeeded(CRequest& Request, 
                                        IN CEssNamespace* pNamespace)
{
    HRESULT hres;

    // Go through all the classes supplied by the provider and see if ours
    // is an ancestor of any of them.
    // ===================================================================

    for(int j = 0; j < m_apQueries.GetSize(); j++)
    {
        CQueryRecord* pQueryRecord = m_apQueries[j];

        _DBG_ASSERT( pQueryRecord != NULL );
        pQueryRecord->EnsureClasses( pNamespace );

        hres = pQueryRecord->DoesIntersectWithQuery(Request, pNamespace);
        
        pQueryRecord->ReleaseClasses();

        if(FAILED(hres))
        {
            // Something is wrong with the query itself --- no point in 
            // continuing to other registrations
            // ========================================================

            return hres;
        }
        else if(hres == WBEM_S_NO_ERROR)
        {
            DEBUGTRACE((LOG_ESS,"Activating filter '%S' with provider %S\n",
                        Request.GetQuery(), m_strName ));

            // First, increment the number of remaining security checks on this
            // filter, since, even though we are adding it to the proxy, we do 
            // not want events reaching it until the provider said OK
            // ================================================================

            Request.GetDest()->GetEventFilter()->
                                    IncrementRemainingSecurityChecks();

            // Add this filter to the proxies
            // ==============================
    
            WBEM_REMOTE_TARGET_ID_TYPE idRequest;
            hres = m_pMainSink->AddFilter(Request.GetQuery(), 
                                            Request.GetQueryExpr(),
                                            Request.GetDest(),
                                            &idRequest);
            if(FAILED(hres)) return hres;

            // Schedule activation of this record, which will involve loading
            // and notifying the provider. Also at that time, filter's security
            // check count will be reduced and events can start flowing
            // ================================================================

            hres = Activate(pNamespace, &Request, idRequest);

            if(hres != WBEM_S_NO_ERROR) // S_FALSE means no provider
            {
                m_pMainSink->RemoveFilter(Request.GetDest());
                return hres;
            }

            // No point in continuing --- the provider has been activated
            // ==========================================================
    
            break;
        }
    }

    return WBEM_S_NO_ERROR;
}



HRESULT CEventProviderCache::CRecord::CancelAllQueries()
{
    HRESULT hres;

    //
    // With this object locked, retrieve all the filters for this provider. 
    // Get provider pointers, as well
    //

    CProviderSinkServer::TDestinationArray apDestinations;
    IWbemEventProviderQuerySink* pSink = NULL;

    {
        CInUpdate iu(m_pMainSink->GetNamespace());

        if(m_pQuerySink == NULL)
        {
            //
            // Nothing to cancel!
            //

            return WBEM_S_FALSE;
        }

        hres = m_pMainSink->GetDestinations(apDestinations);
        if(FAILED(hres))
            return hres;

        pSink = m_pQuerySink;
        pSink->AddRef();
    }

    CReleaseMe rm1(pSink);

    // 
    // Iterate over them all, rechecking each with the provider
    //

    for(int i = 0; i < apDestinations.GetSize(); i++)
    {
        CProviderSinkServer::CEventDestination* pEventDest = apDestinations[i];

        //
        // Notify the provider of the cancellation
        //

        CExecLine::CTurn* pTurn = GetInLine();
        
        if( pTurn == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hres = PostponeCancelQuery(pTurn, pEventDest->m_id);
        
        if( FAILED(hres) )
        {
            DiscardTurn( pTurn );
            return hres;
        }
    }

    return S_OK;
}

//
// takes care of storing permanently the 'permanent' usage state of a provider 
//  
void CEventProviderCache::CRecord::CheckPermanentUsage()
{
    HRESULT hr;

    if ( IsSystem() )
    {
        return;
    }

    if ( m_lPermUsageCount == 0 && m_bRecorded )
    {
        hr = RemoveActiveProviderEntryFromRegistry();

        //
        // no matter what the outcome, make sure to set recorded to false.
        // 

        m_bRecorded = FALSE;

        //
        // since a namespace is deactivated before the filters are deactivated,
        // ( because filter deactivation is postponed ), it is possible that 
        // the namespace key will be deleted by the time we get here. 
        // this happens when we're deactivating the last permanent consumer
        // in the namespace.
        //

        if ( FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
        {
            ERRORTRACE((LOG_ESS,"Error removing active provider entry "
                        "from registry in namespace %S. HR=0x%x\n",
                        m_pNamespace->GetName(), hr ));
        }
    }
    else if ( m_lPermUsageCount > 0 && !m_bRecorded )
    {
        hr = AddActiveProviderEntryToRegistry();

        if ( SUCCEEDED(hr) )
        {
            m_bRecorded = TRUE;
        }
        else
        {
            ERRORTRACE((LOG_ESS,"Error adding active provider entry "
                        "to registry in namespace %S. HR=0x%x\n",
                        m_pNamespace->GetName(), hr ));
        }
    }
}

void CEventProviderCache::CRecord::ResetUsage()
{
    DEBUGTRACE((LOG_ESS,"Resetting provider '%S' in namespace '%S' to prepare "
                "for resync.\n", m_strName, m_strNamespace ));
    //
    // set a flag so that when all filters are reactivated we know to 
    // process them for this record.  
    //
    m_bNeedsResync = TRUE;

    CancelAllQueries();
    m_lUsageCount = 0;

    //
    // when the changes to the event provider cache is committed, we will 
    // enumerate all records and remove ones having a perm usage count still 0
    // from the registry. 
    // 
    m_lPermUsageCount = 0;

    m_pMainSink->RemoveAllFilters();
}

bool CEventProviderCache::CRecord::DeactivateIfNotUsed()
{
    if(m_lUsageCount == 0 && m_pProvider)
    {
        // Stop the provider
        // =================

        UnloadProvider();
        DEBUGTRACE((LOG_ESS, "Unloading event provider %S\n", m_strName));

        return true;
    }
    else
        return false;
}

bool CEventProviderCache::CRecord::IsUnloadable()
{
    return (IsActive() && GetUsageCount() == 0);
}

DWORD CEventProviderCache::CRecord::GetProvidedEventMask(
                                            IWbemClassObject* pClass,
                                            BSTR strClassName)
{
    DWORD dwEventMask = 0;

    // Go through all its registered queries
    // =====================================

    for(int j = 0; j < m_apQueries.GetSize(); j++)
    {
        CRecord::CQueryRecord* pQueryRecord = m_apQueries.GetAt(j);

        _DBG_ASSERT( pQueryRecord != NULL );
        pQueryRecord->EnsureClasses( m_pNamespace );

        dwEventMask |= pQueryRecord->GetProvidedEventMask(pClass, strClassName);

        pQueryRecord->ReleaseClasses();
    }

    return dwEventMask;
}


bool CEventProviderCache::CSystemRecord::DeactivateIfNotUsed()
{
    //
    // System providers cannot be deactivated
    //

    return false;
}
    
bool CEventProviderCache::CSystemRecord::IsUnloadable()
{
    //
    // System providers cannot be deactivated
    //

    return false;
}
    
/*
HRESULT CEventProviderCache::CSystemRecord::PostponeNewQuery(
                                 CExecLine::CTurn* pTurn, DWORD dwId, 
                                 LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                                 CAbstractEventSink* pDest)
{
    //
    // System providers do not need calls to them postponed!
    //

    return Exec_NewQuery(m_pNamespace, pTurn, dwId, wszQueryLanguage, wszQuery,
                            pDest);
}

    
HRESULT CEventProviderCache::CSystemRecord::PostponeCancelQuery(
                                CExecLine::CTurn* pTurn, DWORD dwId)
{
    //
    // System providers do not need calls to them postponed!
    //

    return Exec_CancelQuery(m_pNamespace, pTurn, dwId);
}
*/

//******************************************************************************
//******************************************************************************
//
//                            REQUEST
//
//******************************************************************************
//******************************************************************************

CEventProviderCache::CRequest::CRequest(IN CAbstractEventSink* pDest, 
        LPWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp)
    : m_pDest(pDest), 
        m_wszQuery(wszQuery), m_pExpr(pExp), 
        m_dwEventMask(0), m_papInstanceClasses(NULL), m_pEventClass(NULL)
{
}

CEventProviderCache::CRequest::~CRequest()
{
    // Do not delete namespace, language, and query, and QL -- they were STOREd
    // ========================================================================

    if(m_papInstanceClasses)
        delete m_papInstanceClasses;
    if(m_pEventClass)
        m_pEventClass->Release();
}

INTERNAL QL_LEVEL_1_RPN_EXPRESSION* CEventProviderCache::CRequest::
GetQueryExpr()
{
    return m_pExpr;
}

DWORD CEventProviderCache::CRequest::GetEventMask()
{
    if(m_dwEventMask == 0)
    {
        QL_LEVEL_1_RPN_EXPRESSION* pExpr = GetQueryExpr();
        if(pExpr == NULL)
            return 0;
        m_dwEventMask = 
            CEventRepresentation::GetTypeMaskFromName(pExpr->bsClassName);
    }

    return m_dwEventMask;
}
    
HRESULT CEventProviderCache::CRequest::GetInstanceClasses(
                                        CEssNamespace* pNamespace,
                                        INTERNAL CClassInfoArray** ppClasses)
{
    *ppClasses = NULL;
    if(!m_papInstanceClasses)
    {
        QL_LEVEL_1_RPN_EXPRESSION* pExpr = GetQueryExpr();
        if(pExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        HRESULT hres = CQueryAnalyser::GetPossibleInstanceClasses(
                        pExpr, m_papInstanceClasses);
        if(FAILED(hres))
        {
            return hres;
        }

        if(m_papInstanceClasses == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        // Get the actual classes from the namespace
        // =========================================

        for(int i = 0; i < m_papInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_papInstanceClasses->GetClass(i);
            _IWmiObject* pClass = NULL;

            hres = pNamespace->GetClass(pInfo->m_wszClassName, &pClass);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS,
                    "Could not get class %S for which intrinsic events"
                    " are requested. Error code: %X\n", 
                    pInfo->m_wszClassName, hres));

                delete m_papInstanceClasses;
                m_papInstanceClasses = NULL;

                if(hres == WBEM_E_NOT_FOUND)
                    hres = WBEM_E_INVALID_CLASS;

                return hres;
            }

            pInfo->m_pClass = pClass;
        }

    }
    *ppClasses = m_papInstanceClasses;
    return WBEM_S_NO_ERROR;
}

INTERNAL IWbemClassObject* CEventProviderCache::CRequest::GetEventClass(
                                        CEssNamespace* pNamespace)
{
    HRESULT hres;
    if(m_pEventClass == NULL)
    {
        QL_LEVEL_1_RPN_EXPRESSION* pExpr = GetQueryExpr();
        if(pExpr == NULL)
            return NULL;

        _IWmiObject* pClass = NULL;
        hres = pNamespace->GetClass(pExpr->bsClassName, &pClass);
        if(FAILED(hres))
        {
            return NULL;
        }
        m_pEventClass = pClass;
    }

    return m_pEventClass;
}

HRESULT CEventProviderCache::CRequest::CheckValidity(CEssNamespace* pNamespace)
{
    if(GetQueryExpr() == NULL)
        return WBEM_E_INVALID_QUERY;

    if(GetEventClass(pNamespace) == NULL)
        return WBEM_E_INVALID_CLASS;

    return WBEM_S_NO_ERROR;
}
//******************************************************************************
//******************************************************************************
//
//                            PROVIDER CACHE
//
//******************************************************************************
//******************************************************************************


CEventProviderCache::CEventProviderCache(CEssNamespace* pNamespace) 
    : m_pNamespace(pNamespace), m_pInstruction(NULL), m_bInResync(FALSE)
{
}

CEventProviderCache::~CEventProviderCache()
{
    Shutdown();
}

// assumes: in m_cs
long CEventProviderCache::FindRecord(LPCWSTR wszName)
{
    for(long l = 0; l < m_aRecords.GetSize(); l++)
    {
        if(!wbem_wcsicmp(wszName, m_aRecords[l]->m_strName))
        {
            return l;
        }
    }

    return -1;
}

HRESULT CEventProviderCache::AddProvider(IWbemClassObject* pWin32Prov)
{
    HRESULT hres;

    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    // Determine provider's name
    // =========================

    BSTR strName;
    hres = CRecord::GetProviderInfo(pWin32Prov, strName);
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm1(strName);

    // Check if it exists
    // ==================

    long lIndex = FindRecord(strName);
    if(lIndex != -1)
    {
        // Already there
        // =============

        hres = m_aRecords[lIndex]->SetProvider(pWin32Prov);
        if(FAILED(hres))
            return hres;

        return WBEM_S_FALSE;
    }

    // Create a new provider record
    // ============================

    CRecord* pNewRecord = _new CRecord;
    if(pNewRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewRecord->AddRef();
    CTemplateReleaseMe<CRecord> rm1(pNewRecord);
        
    hres = pNewRecord->Initialize( strName, m_pNamespace );
    if(FAILED(hres)) 
        return hres;

    hres = pNewRecord->SetProvider(pWin32Prov);
    if(FAILED(hres)) 
        return hres;

    // Store it
    // ========

    if(m_aRecords.Add(pNewRecord) < 0)
    {
        delete pNewRecord;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::AddSystemProvider(IWbemEventProvider* pProvider,
											    LPCWSTR wszName,
                                                long lNumQueries,
                                                LPCWSTR* awszQueries)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    //
    // First of all, construct a system provider record and add it
    //

    CSystemRecord* pNewRecord = new CSystemRecord;
    if(pNewRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewRecord->AddRef();
    CTemplateReleaseMe<CSystemRecord> rm1(pNewRecord);
        
    hres = pNewRecord->Initialize( wszName, m_pNamespace);
    if(FAILED(hres)) 
        return hres;

    //
    // Now, add all the queries in
    //

    hres = pNewRecord->SetQueries(m_pNamespace, lNumQueries, awszQueries);
    if(FAILED(hres)) 
        return hres;

    //
    // Populate it with the provider pointer
    //

    hres = pNewRecord->SetProviderPointer(m_pNamespace, pProvider);
    if(FAILED(hres)) 
        return hres;

    //
    // Launch it
    //

    hres = pNewRecord->Exec_StartProvider(m_pNamespace);
    if(FAILED(hres)) 
        return hres;
    
    if(m_aRecords.Add(pNewRecord) < 0)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}
    
    
HRESULT CEventProviderCache::RemoveProvider(IWbemClassObject* pWin32Prov)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    // Determine provider's name
    // =========================

    BSTR strName;
    hres = CRecord::GetProviderInfo(pWin32Prov, strName);
    if(FAILED(hres))
        return hres;

    // Find this record
    // ================

    long lIndex = FindRecord(strName);
    SysFreeString(strName);
    if(lIndex == -1)
    {
        return WBEM_S_FALSE;
    }
    else
    {
        m_aRecords[lIndex]->ResetUsage();
        m_aRecords[lIndex]->ResetProvider();

        if(m_aRecords[lIndex]->IsEmpty())
        {
            m_aRecords.RemoveAt(lIndex);
        }

        return WBEM_S_NO_ERROR;
    }
}

HRESULT CEventProviderCache::CheckProviderRegistration(
                                IWbemClassObject* pRegistration)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    // Create a new provider record
    // ============================

    CRecord* pRecord = new CRecord;
    if(pRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CRecord> dm1(pRecord);
    
    hres = pRecord->Initialize( NULL, m_pNamespace );
    if(FAILED(hres))
        return hres;

    // Set the queries into it
    // =======================

    hres = pRecord->SetQueries(m_pNamespace, pRegistration);
    return hres;
}

HRESULT CEventProviderCache::AddProviderRegistration(
                                IWbemClassObject* pRegistration)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    BSTR strName;

    hres = CRecord::GetRegistrationInfo( pRegistration, strName );
    
    if( FAILED(hres) ) 
    {
        return hres;
    }

    CSysFreeMe sfm( strName );

    long lIndex = FindRecord( strName );
    
    if(lIndex == -1)
    {
        CRecord* pRecord = new CRecord;
        
        if(pRecord == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        
        hres = pRecord->Initialize( strName, m_pNamespace );

        if(FAILED(hres))
        {
            delete pRecord;
            return hres;
        }

        hres = pRecord->SetQueries(m_pNamespace, pRegistration);

        if ( FAILED(hres) )
        {
            delete pRecord;
            return hres;
        }

        lIndex = m_aRecords.Add(pRecord);

        if(lIndex == -1)
        {
            delete pRecord;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hres = m_aRecords[lIndex]->SetQueries(m_pNamespace, pRegistration);
    }
        
    return hres;
}

HRESULT CEventProviderCache::RemoveProviderRegistration(
                                    IWbemClassObject* pRegistration)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    BSTR strName;

    hres = CRecord::GetRegistrationInfo( pRegistration, strName );
    
    if( FAILED(hres) ) 
    {
        return hres;
    }

    CSysFreeMe sfm( strName );

    long lIndex = FindRecord( strName );
   
    if(lIndex == -1)
       return WBEM_S_FALSE;

    // Set registration info
    // =====================

    m_aRecords[lIndex]->ResetUsage();
    m_aRecords[lIndex]->ResetQueries();

    if(m_aRecords[lIndex]->IsEmpty())
    {
        m_aRecords.RemoveAt(lIndex);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::ReleaseProvidersForQuery(CAbstractEventSink* pDest)
{
    HRESULT hres;

    //
    // it is possible that this one function can be called without ns set
    // 
    if ( m_pNamespace != NULL )
    {
        _DBG_ASSERT( m_pNamespace->IsShutdown() || 
                     m_pNamespace->DoesThreadOwnNamespaceLock() );
    }

    // Search all the providers
    // ========================

    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];
        hres = pRecord->DeactivateFilter(pDest);

        // If failures occur, they are logged. Continue.
    }

    // Make sure unload instruction is running
    // =======================================

    EnsureUnloadInstruction();

    return  WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::LoadProvidersForQuery(LPWSTR wszQuery,
        QL_LEVEL_1_RPN_EXPRESSION* pExp, CAbstractEventSink* pDest)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    // DEBUGTRACE((LOG_ESS, "Activating providers for %S (%p)\n", 
    //             wszQuery, pDest));

    // Create a request record
    // =======================

    CRequest Request(pDest, wszQuery, pExp);

    // Check query validity
    // ====================

    hres = Request.CheckValidity(m_pNamespace);
    if(FAILED(hres))
        return hres;

    // Search all the providers
    // ========================

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];

        if ( !m_bInResync || pRecord->NeedsResync() )
        {
            HRESULT hr = pRecord->ActivateIfNeeded(Request, m_pNamespace);
            if(FAILED(hr))
               hresGlobal = hr;
        }
    }

    return hresGlobal;
}

void CEventProviderCache::EnsureUnloadInstruction()
{
    if(m_pInstruction == NULL && m_pNamespace != NULL)
    {
        m_pInstruction = new CEventProviderWatchInstruction(this);
        if(m_pInstruction != NULL)
        {
            m_pInstruction->AddRef();
            m_pNamespace->GetTimerGenerator().Set(m_pInstruction);
        }
    }
}

DWORD CEventProviderCache::GetProvidedEventMask(IWbemClassObject* pClass)
{
    HRESULT hres;
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&v);


    DWORD dwProvidedMask = 0;

    // Search all the providers
    // ========================

    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];
        dwProvidedMask |= pRecord->GetProvidedEventMask(pClass, V_BSTR(&v));
    }
    return dwProvidedMask;
}
    
HRESULT CEventProviderCache::VirtuallyReleaseProviders()
{
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    //
    // just need to record the fact that we are in resync.  This allows us to
    // handle reactivation of filters differently than when not in resync.  
    // For example, during resync we only process reactivations for provider 
    // records that had changed causing the resync in the first place.
    //

    m_bInResync = TRUE;

    return WBEM_S_NO_ERROR;
}
    
HRESULT CEventProviderCache::CommitProviderUsage()
{
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( m_pNamespace->DoesThreadOwnNamespaceLock() );

    // Called after VirtuallyReleaseProviders and re-activating all filters
    // to actually deactivate all the providers whose usage count went to 0.
    // =====================================================================

    //
    // need to process all records and ensure that any having a perm usage 
    // count of 0 be removed from the registry.  Also make sure that we 
    // reset each records resync flag.
    // 
    for( int i=0; i < m_aRecords.GetSize(); i++ )
    {
        m_aRecords[i]->ResetNeedsResync();
        m_aRecords[i]->CheckPermanentUsage();
    }

    // At this point, there is nothing to be done.  When unload instruction 
    // executes, providers that are no longer needed will be unloaded. All we
    // need to do is allow the unload instruction to proceed.
    // ======================================================================

    m_bInResync = FALSE;
    EnsureUnloadInstruction();

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::UnloadUnusedProviders(CWbemInterval Interval)
{
    _DBG_ASSERT( m_pNamespace != NULL );
    _DBG_ASSERT( !m_pNamespace->DoesThreadOwnNamespaceLock() );

    {
        CInUpdate iu(m_pNamespace);
        
        if( m_pNamespace->IsShutdown())
            return WBEM_S_FALSE;
        
        if(m_bInResync)
        {
            // Usage counters are not up-to-date --- wait for the next time
            // ============================================================
            
            return WBEM_S_FALSE;
        }
        
        BOOL bDeactivated = FALSE;
        BOOL bActiveLeft = FALSE;
        for(int i = 0; i < m_aRecords.GetSize(); i++)
        {
            CRecord* pRecord = m_aRecords[i];
            if(pRecord->IsActive() && 
               CWbemTime::GetCurrentTime() - pRecord->m_LastUse > Interval)
            {
                if(pRecord->DeactivateIfNotUsed())
                    bDeactivated = TRUE;
            }
            
            //
            // Check if we need to come back for this one
            //

            if(pRecord->IsUnloadable())
                bActiveLeft = TRUE;
        }
        
        if(bDeactivated)
            m_pNamespace->GetTimerGenerator().ScheduleFreeUnusedLibraries();
        
        if(!bActiveLeft && m_pInstruction)
        {
            m_pInstruction->Terminate();
            m_pInstruction->Release();
            m_pInstruction = NULL;
        }
    }

    m_pNamespace->FirePostponedOperations();

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::Shutdown()
{
    //
    // check if we've already been shutdown.  we don't need a cs here because
    // this method is not multithread safe anyhow and is the only method that 
    // modifies the namespace member.
    //
    if ( m_pNamespace == NULL ) 
        return WBEM_S_FALSE;

    //
    // namespace lock cannot be held when calling this method.  This is 
    // because we will block here waiting for the timer instruction to 
    // shutdown and this thread aquires the namespace lock. 
    //
    _DBG_ASSERT( !m_pNamespace->DoesThreadOwnNamespaceLock() );

    if(m_pInstruction)
    {
        m_pInstruction->Terminate();
        m_pInstruction->Release();
        m_pInstruction = NULL;
    }

    m_aRecords.RemoveAll();

    //
    // we don't need a cs here to modify the namespace because we are 
    // assured that the only other thread that can access us concurrently, 
    // (the timer thread) has been shutdown.
    //
    m_pNamespace = NULL;

    return WBEM_S_NO_ERROR;
}

void CEventProviderCache::DumpStatistics(FILE* f, long lFlags)
{
    long lLoaded = 0;
    long lQueries = 0;
    long lProxies = 0;
    long lFilters = 0;
    long lDestinations = 0;
    long lTargetLists = 0;
    long lTargets = 0;
    long lPostponed = 0;
    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];
        if(pRecord->m_pProvider)
            lLoaded++;
        
        lQueries += pRecord->m_apQueries.GetSize();

        long lThisProxies = 0;
        long lThisFilters = 0;
        long lThisTargetLists = 0;
        long lThisTargets = 0;
        long lThisPostponed = 0;
        long lThisDestinations = 0;
        pRecord->m_pMainSink->GetStatistics(&lThisProxies, &lThisDestinations,
                                &lThisFilters, &lThisTargetLists, 
                                &lThisTargets, &lThisPostponed);

        lProxies += lThisProxies;
        lDestinations += lThisDestinations;
        lFilters += lThisFilters;
        lTargetLists += lThisTargetLists;
        lTargets += lThisTargets;
        lPostponed += lThisPostponed;
    }

    fprintf(f, "%d provider records, %d definition queries, %d proxies\n"
        "%d destinations, %d proxy filters, %d proxy target lists\n"
        "%d proxy targets, %d postponed in proxies\n", 
        m_aRecords.GetSize(), lQueries, lProxies, lDestinations, lFilters, 
        lTargetLists, lTargets, lPostponed);
}

CPostponedNewQuery::CPostponedNewQuery(CEventProviderCache::CRecord* pRecord, 
                    DWORD dwId, LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                    CExecLine::CTurn* pTurn, CAbstractEventSink* pDest)
    : m_pRecord(pRecord), m_dwId(dwId), m_pTurn(pTurn), m_pcsQuery(NULL),
        m_pDest(pDest)
{
    m_pRecord->AddRef();
    m_pDest->AddRef();

    // Figure out how much space we need
    // =================================

    int nSpace = CCompressedString::ComputeNecessarySpace(wszQuery);

    // Allocate this string on the temporary heap
    // ==========================================

    m_pcsQuery = (CCompressedString*)CTemporaryHeap::Alloc(nSpace);
    if(m_pcsQuery == NULL)
        return;

    m_pcsQuery->SetFromUnicode(wszQuery);
}

CPostponedNewQuery::~CPostponedNewQuery()
{
    if(m_pTurn)
        m_pRecord->DiscardTurn(m_pTurn);
    if(m_pcsQuery)
        CTemporaryHeap::Free(m_pcsQuery, m_pcsQuery->GetLength());
    if(m_pDest)
        m_pDest->Release();

    m_pRecord->Release();
}
HRESULT CPostponedNewQuery::Execute(CEssNamespace* pNamespace)
{
    if(m_pcsQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = m_pRecord->Exec_NewQuery(pNamespace, m_pTurn, m_dwId, 
                                    L"WQL", m_pcsQuery->CreateWStringCopy(),
                                    m_pDest);
    m_pTurn = NULL;
    return hres;
}

void* CPostponedNewQuery::operator new(size_t nSize)
{
    return CTemporaryHeap::Alloc(nSize);
}
void CPostponedNewQuery::operator delete(void* p)
{
    CTemporaryHeap::Free(p, sizeof(CPostponedNewQuery));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\qsink.cpp ===
//******************************************************************************
//
//  QSINK.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <genutils.h>
#include <cominit.h>
#include "ess.h"
#include "evsink.h"
#include "delivrec.h"

#define IN_SPIN_LOCK CInCritSec
#define MAX_EVENT_DELIVERY_SIZE 10000000
#define SLOWDOWN_DROP_LIMIT 1000
#define DELIVER_SPIN_COUNT 1000
   
/*****************************************************************************
  CQueueingEventSink
******************************************************************************/

CQueueingEventSink::CQueueingEventSink(CEssNamespace* pNamespace) 
: m_pNamespace(pNamespace), m_bDelivering(FALSE), m_dwTotalSize(0),
  m_dwMaxSize(0xFFFFFFFF), m_wszName(NULL), m_bRecovering(FALSE), 
  m_hRecoveryComplete(NULL), m_hrRecovery(S_OK)
{
    m_pNamespace->AddRef();
    m_pNamespace->AddCache();
}

CQueueingEventSink::~CQueueingEventSink() 
{
    if ( m_hRecoveryComplete != NULL )
    {
        CloseHandle( m_hRecoveryComplete );
    }
    delete m_wszName;
    m_pNamespace->RemoveCache();
    m_pNamespace->Release();
}

HRESULT CQueueingEventSink::SetName( LPCWSTR wszName )
{
    if ( m_wszName != NULL )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    m_wszName = new WCHAR[wcslen(wszName)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    StringCchCopyW( m_wszName, wcslen(wszName)+1, wszName );

    return WBEM_S_NO_ERROR;
}
   

STDMETHODIMP CQueueingEventSink::SecureIndicate( long lNumEvents, 
                                                 IWbemEvent** apEvents,
                                                 BOOL bMaintainSecurity,
                                                 BOOL bSlowDown,
                                                 DWORD dwQoS,
                                                 CEventContext* pContext)
{
    // BUGBUG: context. levn: no security implications at this level --- we
    // are past the filter

    HRESULT hres;
    DWORD dwSleep = 0;

    // If security needs to be maintained, record the calling security 
    // context
    // ===============================================================

    IWbemCallSecurity* pSecurity = NULL;

    if(bMaintainSecurity && IsNT())
    {
        pSecurity = CWbemCallSecurity::CreateInst();
        if (pSecurity == 0)
            return WBEM_E_OUT_OF_MEMORY;
        
        hres = pSecurity->CloneThreadContext(FALSE);
        if(FAILED(hres))
        {
            pSecurity->Release();
            return hres;
        }
    }

    CReleaseMe rmpSecurity( pSecurity );

    HRESULT hr;

    BOOL bSchedule = FALSE;

    for(int i = 0; i < lNumEvents; i++)
    {
        CWbemPtr<CDeliveryRecord> pRecord;
        
        //
        // TODO: Fix this so that we put multiple events in the record. 
        // 

        hr = GetDeliveryRecord( 1, 
                                &apEvents[i], 
                                dwQoS, 
                                pContext, 
                                pSecurity, 
                                &pRecord );

        if ( FAILED(hr) )
        {
            ERRORTRACE((LOG_ESS, "Couldn't create delivery record for %S "
                                 " sink. HR = 0x%x\n", m_wszName, hr ));
            ReportQosFailure( apEvents[i], hr );
            continue;
        }

        DWORD dwThisSleep;
        BOOL bFirst;
        
        if( !AddRecord( pRecord, bSlowDown, &dwThisSleep, &bFirst) )
        {
            //
            // make sure that we give the record a chance to perform any post 
            // deliver actions before getting rid of it.
            //
            pRecord->PostDeliverAction( NULL, S_OK );

            return WBEM_E_OUT_OF_MEMORY;
        }

        dwSleep += dwThisSleep;
        if(bFirst)
        bSchedule = TRUE;
    }

    if(bSchedule)
    {
        // DeliverAll();
        // TRACE((LOG_ESS, "Scheduling delivery!!\n"));
        hres = m_pNamespace->ScheduleDelivery(this);
    }
    else
    {
        // TRACE((LOG_ESS, "NOT Scheduling delivery!!\n"));
        hres = WBEM_S_FALSE;
    }

    if(dwSleep && bSlowDown)
    m_pNamespace->AddSleepCharge(dwSleep);

    return  hres;
}

BOOL CQueueingEventSink::AddRecord( CDeliveryRecord* pRecord, 
                                    BOOL bSlowDown,
                                    DWORD* pdwSleep, 
                                    BOOL* pbFirst )
{
    // Inform the system of the additional space in the queue
    // ======================================================

    DWORD dwRecordSize = pRecord->GetTotalBytes();

    pRecord->AddToCache( m_pNamespace, m_dwTotalSize, pdwSleep );

    BOOL bDrop = FALSE;

    // Check if the sleep is such as to cause us to drop the event
    // ===========================================================

    if(!bSlowDown && *pdwSleep > SLOWDOWN_DROP_LIMIT)
    {
        bDrop = TRUE;
    }
    else
    {
        // Check if our queue size is so large as to cause us to drop
        // ==============================================================

        if(m_dwTotalSize + dwRecordSize > m_dwMaxSize)
        bDrop = TRUE;
    }

    if( bDrop )
    {
        //
        // Report that we're dropping the events.  Call for each event.
        // 

        IWbemClassObject** apEvents = pRecord->GetEvents();

        for( ULONG i=0; i < pRecord->GetNumEvents(); i++ )
        {
            ReportQueueOverflow( apEvents[i], m_dwTotalSize + dwRecordSize );
        }

        *pdwSleep = 0;
        *pbFirst = FALSE;
    }
    else
    {
        IN_SPIN_LOCK isl(&m_sl);

        *pbFirst = (m_qpEvents.GetQueueSize() == 0) && !m_bDelivering;
        m_dwTotalSize += dwRecordSize;
        
        if(!m_qpEvents.Enqueue(pRecord))
        {
            *pdwSleep = 0;
            return FALSE;
        }
        pRecord->AddRef();
    }

    return TRUE;
}

HRESULT CQueueingEventSink::DeliverAll()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL    bSomeLeft = TRUE;

    while( bSomeLeft )
    {
        try
        {
            {
                IN_SPIN_LOCK ics(&m_sl);
                m_bDelivering = TRUE;
            }

            hr = DeliverSome( );
        }
        catch( CX_MemoryException )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch ( ... )
        {
            hr = WBEM_E_FAILED;
        }

        {
            IN_SPIN_LOCK ics(&m_sl);
            m_bDelivering = FALSE;

            if ( SUCCEEDED( hr ) )
            {
                bSomeLeft = (m_qpEvents.GetQueueSize() != 0);
            }
            else
            {
                m_qpEvents.Clear();
                bSomeLeft = FALSE;
            }
        }
    }

    return hr;
}

void CQueueingEventSink::ClearAll()
{
    IN_SPIN_LOCK isl(&m_sl);
    m_qpEvents.Clear();
}

#pragma optimize("", off)
void CQueueingEventSink::WaitABit()
{
    SwitchToThread();
/*
    int nCount = 0;
    while(m_qpEvents.GetQueueSize() == 0 && nCount++ < DELIVER_SPIN_COUNT);
*/
}
#pragma optimize("", on)


HRESULT CQueueingEventSink::DeliverSome( )
{
    // Retrieve records until maximum size is reached and while the same
    // security context is used for all
    // ==================================================================

    CTempArray<CDeliveryRecord*> apRecords;

    m_sl.Enter(); // CANNOT USE SCOPE BECAUSE CTempArray uses _alloca
    DWORD dwMaxRecords = m_qpEvents.GetQueueSize();
    m_sl.Leave();

    if(!INIT_TEMP_ARRAY(apRecords, dwMaxRecords))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CDeliveryRecord* pEventRec;
    DWORD dwDeliverySize = 0;
    DWORD dwTotalEvents = 0; 
    int cRecords = 0;
    LUID luidBatch;
    IWbemCallSecurity* pBatchSecurity = NULL;

    m_sl.Enter();

    while( dwDeliverySize < GetMaxDeliverySize() && 
           cRecords < dwMaxRecords &&
           (pEventRec = m_qpEvents.Dequeue()) != NULL ) 
    {
        // Compare it to the last context
        // ==============================

        m_sl.Leave();
        if( dwDeliverySize > 0 )
        {
            if(!DoesRecordFitBatch(pEventRec, pBatchSecurity, luidBatch))
            {
                // Put it back and that's it for the batch
                // =======================================

                IN_SPIN_LOCK ics(&m_sl);
                m_qpEvents.Requeue(pEventRec);

                m_sl.Enter();
                break;
            }
        }
        else
        {
            // First --- record luid
            // =====================

            pBatchSecurity = pEventRec->GetCallSecurity();

            if( pBatchSecurity )
            {
                pBatchSecurity->AddRef();
                pBatchSecurity->GetAuthenticationId( luidBatch );
            }
        }

        apRecords[cRecords++] = pEventRec;
        dwTotalEvents += pEventRec->GetNumEvents();
        
        // Matched batch parameters --- add it to the batch
        // ================================================

        DWORD dwRecordSize = pEventRec->GetTotalBytes();

        m_dwTotalSize -= dwRecordSize;
        dwDeliverySize += dwRecordSize;

        //
        // Remove this size from the total of events held
        //

        m_sl.Enter();
    }

    m_sl.Leave();

    //
    // we've now got one or more delivery records to handle. 
    //

    //
    // we now need to initialize the event array that we're going to indicate
    // to the client.
    //

    CTempArray<IWbemClassObject*> apEvents;

    if( !INIT_TEMP_ARRAY( apEvents, dwTotalEvents ))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // go through the delivery records and add their events to the 
    // events to deliver.  Also perform any PreDeliverAction on the   
    // record.
    //

    CWbemPtr<ITransaction> pTxn;
    HRESULT hr;
    int cEvents = 0;
    int i;

    for(i=0; i < cRecords; i++ )
    {
        //if ( apRecords[i]->RequiresTransaction() && pTxn == NULL )
        //{
            // TODO : XACT - aquire txn from DTC.
        //}

        hr = apRecords[i]->PreDeliverAction( pTxn );

        if ( FAILED(hr) )
        {
            // 
            // TODO : handle error reporting here.
            // 
            continue;
        }

        IWbemEvent** apRecordEvents = apRecords[i]->GetEvents();
        DWORD cRecordEvents = apRecords[i]->GetNumEvents();

        for( DWORD j=0; j < cRecordEvents; j++ )
        {
            apEvents[cEvents++] = apRecordEvents[j];
        }
    }
    
    // Actually Deliver
    // =======

    HRESULT hres = WBEM_S_NO_ERROR;

    if( dwDeliverySize > 0 )
    {
        //
        // Error returns are already logged in ActuallyDeliver
        // we do not need to return return value of DeliverEvents 
        //
        hres = DeliverEvents( pBatchSecurity, cEvents, apEvents );
    }

    //
    // call postdeliveryaction on all the records.  Then clean them up.
    // 

    for(i=0; i < cRecords; i++ )
    {
        apRecords[i]->PostDeliverAction( pTxn, hres );
        apRecords[i]->Release();
    }

    // Release all of the events.
    // ================

    if( pBatchSecurity )
    {
        pBatchSecurity->Release();
    }

    // Check if we need to continue
    // ============================

    WaitABit();

    return WBEM_S_NO_ERROR;
}

HRESULT CQueueingEventSink::DeliverEvents(IWbemCallSecurity* pBatchSecurity, 
                                          long lNumEvents, IWbemEvent** apEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    IUnknown* pOldSec = NULL;
    if(pBatchSecurity)
    {
        hres = WbemCoSwitchCallContext(pBatchSecurity, &pOldSec);
        if(FAILED(hres))
        {
            // Unable to set security --- cannot deliver
            // =========================================

            return hres;
        }
    }

    if(SUCCEEDED(hres))
    {
        // BUGBUG: propagate context.  levn: no security implications at this
        // point --- we are past the filter
        hres = ActuallyDeliver(lNumEvents, apEvents, (pBatchSecurity != NULL), 
                               NULL);
    }

    if(pBatchSecurity)
    {
        IUnknown* pTemp;
        
        HRESULT hr = WbemCoSwitchCallContext(pOldSec, &pTemp);

        if ( FAILED( hr ) && SUCCEEDED( hres ) )
        {
            return hr;
        }
    }

    return hres;
}

BOOL CQueueingEventSink::DoesRecordFitBatch( CDeliveryRecord* pEventRec, 
                                             IWbemCallSecurity* pBatchSecurity,
                                             LUID luidBatch )
{
    IWbemCallSecurity* pEventSec = pEventRec->GetCallSecurity();

    if( pEventSec != NULL || pBatchSecurity != NULL )
    {
        if( pEventSec == NULL || pBatchSecurity == NULL )
        {
            // Definite mistatch --- one NULL, one not
            // =======================================

            return FALSE;
        }
        else
        {
            LUID luidThis;
            pEventSec->GetAuthenticationId(luidThis);

            if( luidThis.LowPart != luidBatch.LowPart ||
                luidThis.HighPart != luidBatch.HighPart )
            {
                return FALSE;
            }
            else
            {
                return TRUE;
            }
        }
    }
    else
    {
        return TRUE;
    }
}

DWORD CQueueingEventSink::GetMaxDeliverySize()
{
    return MAX_EVENT_DELIVERY_SIZE;
}

HRESULT CQueueingEventSink::GetDeliveryRecord( ULONG cEvents,
                                               IWbemEvent** apEvents,
                                               DWORD dwQos,
                                               CEventContext* pContext,
                                               IWbemCallSecurity* pCallSec,
                                               CDeliveryRecord** ppRecord )
{
    *ppRecord = NULL;

    CWbemPtr<CDeliveryRecord> pRecord;

    if ( dwQos == WMIMSG_FLAG_QOS_EXPRESS )
    {
        pRecord = new CExpressDeliveryRecord;
        if ( pRecord == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        HRESULT hr = pRecord->Initialize( apEvents, cEvents, pCallSec );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
      

    pRecord->AddRef();
    *ppRecord = pRecord;

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\qsink.h ===
//******************************************************************************
//
//  QSINK.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __QSINK_H__
#define __QSINK_H__

#include <sync.h>
#include <unk.h>
#include <winntsec.h>
#include <callsec.h>
#include <newnew.h>
#include <buffer.h>
#include <comutl.h>
#include <wmimsg.h>
#include <map>

#include "eventrep.h"
#include "evsink.h"
#include "delivrec.h"

/***************************************************************************
  CQueueingEventSink
****************************************************************************/

class CQueueingEventSink : public CEventSink
{
protected:

    CUniquePointerQueue<CDeliveryRecord> m_qpEvents;
    CCritSec m_cs;
    CCritSec m_sl;
    BOOL m_bDelivering;
    DWORD m_dwTotalSize;
    DWORD m_dwMaxSize;
    CEssNamespace* m_pNamespace;

    //
    // the logical name of this queueing sink.  Queueing sinks can be
    // as fined grained ( e.g one per logical consumer instance ) or 
    // they can be more coarse grained (e.g one per consumer provider)
    // 
    LPWSTR m_wszName;

    //
    // aquired when performing and testing persistent queue initialization.
    //
    CCritSec m_csQueue;

    //
    // if recovery fails, then it stores its failure here.  When new 
    // deliveries come in we use this to tell us if we should reinitiate
    // recovery. 
    //
    HRESULT m_hrRecovery;

    //
    // Used to synchronize with recovery.  
    //
    HANDLE m_hRecoveryComplete;
    BOOL m_bRecovering;
    
    //
    // These buffers are used to marshal guaranteed deliveries.  This
    // happens in SaveDeliveryRecord().  All calls to SaveDeliveryRecord()
    // are serialized, so we can keep re-using the buffers.
    //
    CBuffer m_MsgData;
    CBuffer m_MsgAuxData;

    //
    // Is used for removing messages after delivery. 
    //
    CWbemPtr<IWmiMessageQueueReceiver> m_pRcvr;
    CWbemPtr<IWmiMessageQueueReceiver> m_pXactRcvr; // TODO : XACT

    //
    // Is used for saving deliveries before they are put into the 
    // transient queue.
    //
    CWbemPtr<IWmiMessageSendReceive> m_pSend;
    CWbemPtr<IWmiMessageSendReceive> m_pXactSend; // TODO : XACT
    
    //
    // saves the record in the specified queue.  called before the 
    // delivery record is put on the transient queue.  after a 
    // guaranteed type record is actually delivered to the 
    // consumer, then it will be removed from the queue.  This happens
    // in delivery record's PostDeliveryAction. 
    //
    HRESULT SaveDeliveryRecord( IWmiMessageSendReceive* pSend,
                                CDeliveryRecord* pRecord );

    //
    // Handles the creation of the appropriate persistent record type
    // based on QoS ( right now just guaranteed ).  Saves records before 
    // returning.
    //
    HRESULT GetPersistentRecord( ULONG cEvents,
                                 IWbemEvent** apEvents,
                                 DWORD dwQoS,
                                 CEventContext* pContext,
                                 CDeliveryRecord** ppRecord );
    // 
    // Handles creation of the appropriate record type based on the 
    // QoS specified.  If the QoS is a guaranteed type, then
    // it will call GetPersistentRecord().
    //
    HRESULT GetDeliveryRecord( ULONG cEvents,
                               IWbemEvent** apEvents,
                               DWORD dwQoS,
                               CEventContext* pContext,
                               IWbemCallSecurity* pCallSec,
                               CDeliveryRecord** ppRecord );

    // 
    // Called if GetPersistentRecord() returns an error.  If the problem
    // can be corrected ( e.g. msmq service can be restarted ), then 
    // recovery will be initiated.  a return code of S_OK indicates to 
    // the caller that they should retry their GetPersistentRecord() request.
    // 
    HRESULT HandlePersistentQueueError( HRESULT hr, DWORD dwQos ); 

    HRESULT InternalRecover( LPCWSTR wszQueueName, DWORD dwQoS );

    HRESULT OpenReceiver( LPCWSTR wszQueueName,
                          DWORD dwQoS, 
                          IWmiMessageSendReceive* pRecv,
                          IWmiMessageQueueReceiver** pRcvr );

    HRESULT OpenSender( LPCWSTR wszQueueName,
                        DWORD dwQoS, 
                        IWmiMessageSendReceive** ppSend );

    ~CQueueingEventSink();
 
public:

    CQueueingEventSink( CEssNamespace* pNamespace );

    HRESULT SetName( LPCWSTR wszName );

    void SetMaxQueueSize(DWORD dwMaxSize) {m_dwMaxSize = dwMaxSize;}

    // TODO : a lot of these parameters should go inside the context.
    STDMETHODIMP SecureIndicate( long lNumEvents, 
                                 IWbemEvent** apEvents,
                                 BOOL bMaintainSecurity, 
                                 BOOL bSlowDown,
                                 DWORD dwQoS, 
                                 CEventContext* pContext );

    HRESULT Indicate( long lNumEvents, 
                      IWbemEvent** apEvents, 
                      CEventContext* pContext )
    {
        return SecureIndicate( lNumEvents, 
                               apEvents, 
                               TRUE, 
                               FALSE, 
                               WMIMSG_FLAG_QOS_EXPRESS,
                               pContext);
    }

    HRESULT DeliverAll();
    virtual HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure, CEventContext* pContext) = 0;

    virtual HRESULT ReportQueueOverflow(IWbemEvent* pEvent, DWORD dwQueueSize) 
        {return S_OK;}
    virtual HRESULT ReportQosFailure(IWbemEvent* pEvent, HRESULT hresError )
        {return S_OK;}
 
    static HRESULT QueueNameToSinkName( LPCWSTR wszQueueName,
                                        WString& rwsSinkName,
                                        WString& rwsNamespace,
                                        DWORD& rdwQoS );

    static HRESULT SinkNameToQueueName( LPCWSTR wszSinkName,
                                        LPCWSTR wszNamespace,
                                        DWORD dwQoS,
                                        WString& rwsQueueName );

    // 
    // called by guaranteed delivery record when it needs to remove a 
    // delivery from the guaranteed queue.
    //
    HRESULT GuaranteedPostDeliverAction( IWmiMessageQueueReceiver* pRcvr );

    //
    // Opens the specified queue and initiates the delivery of persisted
    // records.  Called on startup by the ess object on a background thread.
    // Also called when encountering errors with saving or removing 
    // delivery records from the persistent queues.
    //
    HRESULT Recover( LPCWSTR wszQueueName, DWORD dwQoS );

    //
    // this method is called when a queueing sink is removed because all of 
    // the consumers associated with it have been removed.   
    // 
    HRESULT CleanupPersistentQueues();

protected:

    DWORD GetMaxDeliverySize();

    BOOL DoesRecordFitBatch( CDeliveryRecord* pRecord, 
                             IWbemCallSecurity* pBatchSecurity,
                             LUID luidBatch );

    HRESULT DeliverSome( );
    void ClearAll();
    HRESULT DeliverEvents( IWbemCallSecurity* pBatchSecurity, 
                           long lNumEvents, 
                           IWbemEvent** apEvents);

    BOOL AddRecord( ACQUIRE CDeliveryRecord* pRecord, 
                    BOOL bSlowDown, 
                    DWORD* pdwSleep, 
                    BOOL* pbFirst);
    
    void WaitABit();
};

#endif // __QSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\quota.cpp ===
//=============================================================================
//
//  Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
//  Quota.CPP
//
//  Implements the class that keeps track of quotas within ESS.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "essutils.h"
#include "nsrep.h"
#include "Quota.h"
#include <cominit.h>
#include <callsec.h>

// Global instance.
CQuota g_quotas;

#define WMICOREQUOTAS_NAMESPACE L"root"
#define WMICOREQUOTAS_OBJPATH   L"__ArbitratorConfiguration=@"
#define WMICOREQUOTAS_CLASS     L"__ArbitratorConfiguration"


CUserInfo::CUserInfo() :
    m_pData(NULL),
    m_dwSize(0),
    m_bAlloced(FALSE)
{
    ZeroMemory(m_dwUserCount, sizeof(m_dwUserCount));
}

CUserInfo::CUserInfo(LPBYTE pData, DWORD dwSize) :
    m_pData(pData),
    m_dwSize(dwSize),
    m_bAlloced(FALSE)
{
    ZeroMemory(m_dwUserCount, sizeof(m_dwUserCount));
}

CUserInfo::~CUserInfo()
{
    if (m_pData && m_bAlloced)
        delete m_pData;
}

BOOL CUserInfo::CopyData(LPBYTE pData, DWORD dwSize)
{
    BOOL bRet;

    m_pData = new BYTE[dwSize];
    if (m_pData)
    {
        memcpy(m_pData, pData, dwSize);
        m_dwSize = dwSize;
        m_bAlloced = TRUE;
        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

const CUserInfo& CUserInfo::operator = (const CUserInfo& other)
{
    if (other.m_bAlloced)
    {
        m_pData = other.m_pData;
        m_dwSize = other.m_dwSize;
        ((CUserInfo&)other).m_bAlloced = FALSE;
        m_bAlloced = TRUE;
    }
    else
        CopyData(other.m_pData, other.m_dwSize);

    memcpy(m_dwUserCount, other.m_dwUserCount, sizeof(m_dwUserCount));

    return *this;
}

BOOL CUserInfo::Init(LPBYTE pData, DWORD dwSize)
{
    BOOL bRet;

    // See if we need to get the data out of the token.
    if (!pData)
    {
        IWbemCallSecurity *pSecurity = NULL;

        bRet = FALSE;

        WbemCoGetCallContext(IID_IWbemCallSecurity, (void**) &pSecurity);        

        if (pSecurity)
        {
            // Get the client's SID.
            TOKEN_USER tu;
            DWORD      dwLen = 0;
            HANDLE     hToken = pSecurity->GetToken();
            
            GetTokenInformation(
                hToken, 
                TokenUser, 
                &tu, 
                sizeof(tu), 
                &dwLen);

            if (dwLen != 0)
            {
                BYTE  *pTemp = new BYTE[dwLen];
                DWORD dwRealLen = dwLen;

                if (pTemp)
                {
                    if (GetTokenInformation(
                        hToken, 
                        TokenUser, 
                        pTemp, 
                        dwRealLen, 
                        &dwLen))
                    {
                        // Make a copy of the SID
                        PSID  pSid = ((TOKEN_USER*)pTemp)->User.Sid;
                        DWORD dwSidLen = GetLengthSid(pSid);
                        
                        m_pData = new BYTE[dwSidLen];

                        if (m_pData)
                        {
                            CopySid(dwSidLen, m_pData, pSid);
                            m_dwSize = dwSidLen;
                            m_bAlloced = TRUE;

                            bRet = TRUE;
                        }
                    }

                    delete [] pTemp;
                }
            }

            pSecurity->Release();
        }    
    }
    else
    {
        m_pData = pData;
        m_dwSize = dwSize;
        m_bAlloced = FALSE;

        bRet = TRUE;
    }

    return bRet;
}

#define DEF_GLOBAL_LIMIT    100
#define DEF_USER_LIMIT      20

CQuota::CQuota() :
    m_pEss(NULL)
{
    // Zero this out.
    ZeroMemory(m_dwGlobalCount, sizeof(m_dwGlobalCount));
    
    // Setup some defaults.  These will eventually get overridden once 
    // Init() is called.
    for (int i = 0; i < ESSQ_INDEX_COUNT; i++)
    {
        m_dwGlobalLimits[i] = DEF_GLOBAL_LIMIT;
        m_dwUserLimits[i] = DEF_USER_LIMIT;
    }        

    m_dwGlobalLimits[ESSQ_POLLING_MEMORY] = 10000000;
    m_dwUserLimits[ESSQ_POLLING_MEMORY] = 5000000;

    try
    {
        InitializeCriticalSection(&m_cs);
    }
    catch(...)
    {
        throw CX_MemoryException();
    }
}

HRESULT CQuota::Init(CEss *pEss)
{
    HRESULT hr;

    m_pEss = pEss;

    CEssNamespace *pNamespace = NULL;

    hr = 
        pEss->GetNamespaceObject(
            WMICOREQUOTAS_NAMESPACE,
            TRUE,
            &pNamespace );
            
    if (SUCCEEDED(hr))
    {    
        _IWmiObject *pObj = NULL;

        hr = 
            pNamespace->GetInstance(
                WMICOREQUOTAS_OBJPATH,
                &pObj);

        if (SUCCEEDED(hr))
        {
            UpdateQuotaSettings(pObj);
            pObj->Release();

            {
                CInUpdate iu( pNamespace );

                hr = pNamespace->InternalRegisterNotificationSink(
                    L"WQL", 
                    L"select * from __InstanceModificationEvent "
                        L"where targetinstance isa '" WMICOREQUOTAS_CLASS L"'",
                    0, WMIMSG_FLAG_QOS_SYNCHRONOUS,
                    GetCurrentEssContext(), 
                    this,
                    true,
                    NULL );
            }
            pNamespace->FirePostponedOperations();
        }

        pNamespace->Release();
    }

    // Always return S_OK in case WMICOREQUOTAS_OBJPATH doesn't exist yet.
    // Hopefully at some point this instance will always be there.
    return S_OK;
}


HRESULT CQuota::Shutdown()
{
    if (m_pEss)
        m_pEss->RemoveNotificationSink(this);
    m_pEss = NULL;
    return S_OK;
}

CQuota::~CQuota()
{
    DeleteCriticalSection(&m_cs);
}

bool CUserInfo::operator == (const CUserInfo& other) const
{ 
    return m_dwSize == other.m_dwSize &&
            !memcmp(m_pData, other.m_pData, m_dwSize);
}

bool CUserInfo::operator < (const CUserInfo& other) const
{ 
    if (m_dwSize < other.m_dwSize)
        return TRUE;
    else if (m_dwSize > other.m_dwSize)
        return FALSE;
    else
        return memcmp(m_pData, other.m_pData, m_dwSize) < 0;
}

void GetSidInfo(CEventFilter *pFilter, LPVOID *ppSid, DWORD *pdwSize)
{
    if (pFilter)
    {
        *ppSid = pFilter->GetOwner();

        *pdwSize = *ppSid ? GetLengthSid(*ppSid) : 0;
    }
    else
    {
        *ppSid = NULL;
        *pdwSize = 0;
    }
}

HRESULT CQuota::FindUser(CEventFilter* pFilter, void** pUser)
{
    HRESULT hr = S_OK;
    LPVOID  pSid = NULL;
    DWORD   dwSize;

    GetSidInfo(pFilter, &pSid, &dwSize);

    // We'll save the context if there's not a Sid.
    BOOL             bDoSwitchContext = pSid == NULL;
    CSaveCallContext save(bDoSwitchContext);
    CWbemPtr<IUnknown> pNewCtx;

    if (bDoSwitchContext)
    {
        hr = pFilter->SetThreadSecurity( &pNewCtx );
        if(FAILED(hr))
            return hr;
    }

    CInCritSec ics(&m_cs);
    
    CUserInfo user;
    if (user.Init((LPBYTE) pSid, dwSize))
    {
        CUserMapIterator it;
    
        it= m_mapUserInfo.find(user);
        if (it!= m_mapUserInfo.end())
        {
            *pUser = new CUserMapIterator(it);
            if(*pUser == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            return S_OK;
        }
        else
        {
            // Add it to the map.
            
            try
            {
                m_mapUserInfo[user] = 0;
            }
            catch(CX_MemoryException)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            *pUser = new CUserMapIterator(m_mapUserInfo.find(user));
            if(*pUser == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            return S_OK;
        }
    }
    else
    {
        // Special case for calls Winmgmt makes: doesn't count against any 
        // user.

        *pUser = NULL;
        return S_FALSE;
    }
}
    
HRESULT CQuota::FreeUser(void* pUser)
{
    delete (CUserMapIterator*)pUser;
    return S_OK;
}

HRESULT CQuota::IncrementQuotaIndex(
    ESS_QUOTA_INDEX dwIndex, 
    CEventFilter *pFilter,
    DWORD dwToAdd)
{
    HRESULT hr = S_OK;
    LPVOID  pSid = NULL;
    DWORD   dwSize;

    GetSidInfo(pFilter, &pSid, &dwSize);

    // We'll save the context if there's not a Sid.
    BOOL             bDoSwitchContext = pSid == NULL;
    CSaveCallContext save(bDoSwitchContext);
    CWbemPtr<IUnknown> pNewCtx;

    if (bDoSwitchContext)
    {
        hr = pFilter->SetThreadSecurity( &pNewCtx );
        if(FAILED(hr))
            return hr;
    }

    Lock();
    
    if (m_dwGlobalCount[dwIndex] + dwToAdd <= m_dwGlobalLimits[dwIndex])
    {
        CUserInfo user;

        if (user.Init((LPBYTE) pSid, dwSize))
        {
            CUserMapIterator item;
        
            item = m_mapUserInfo.find(user);
        
            if (item != m_mapUserInfo.end())
            {
                CUserInfo &itemRef = (CUserInfo&) (*item).first;

                if (itemRef.m_dwUserCount[dwIndex] + dwToAdd <= m_dwUserLimits[dwIndex])
                {
                    itemRef.m_dwUserCount[dwIndex] += dwToAdd;
                    m_dwGlobalCount[dwIndex] += dwToAdd;
                }
                else
                    hr = WBEM_E_QUOTA_VIOLATION;
            }
            else
            {
                // Set the number of items to dwToAdd.

                user.m_dwUserCount[dwIndex] = dwToAdd;

                // Add it to the map.
                try
                {
                    m_mapUserInfo[user] = 0;
                }
                catch(CX_MemoryException)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if(SUCCEEDED(hr))
                {
                    m_dwGlobalCount[dwIndex] += dwToAdd;
                }
            }
        }
        else
        {
            // Special case for calls Winmgmt makes: doesn't count against any 
            // user.
            // Should this event count against our global counts?
            m_dwGlobalCount[dwIndex] += dwToAdd;
        }
    }
    else
        hr = WBEM_E_QUOTA_VIOLATION;

    Unlock();

    return hr;
}
    
HRESULT CQuota::DecrementQuotaIndex(
    ESS_QUOTA_INDEX dwIndex,
    CEventFilter *pFilter,
    DWORD dwToRemove)
{
    CUserInfo user;
    BOOL      bRet = FALSE;
    LPVOID    pSid;
    DWORD     dwSize;
    HRESULT hr;

    GetSidInfo(pFilter, &pSid, &dwSize);

    // We'll save the context if there's not a Sid.
    BOOL             bDoSwitchContext = pSid == NULL;
    CSaveCallContext save(bDoSwitchContext);
    CWbemPtr<IUnknown> pNewCtx;

    if (bDoSwitchContext)
    {
        hr = pFilter->SetThreadSecurity( &pNewCtx );
        if(FAILED(hr))
            return hr;
    }

    Lock();
    
    m_dwGlobalCount[dwIndex] -= dwToRemove;

    if (user.Init((LPBYTE) pSid, dwSize))
    {
        CUserMapIterator item;
        
        item = m_mapUserInfo.find(user);
        
        if (item != m_mapUserInfo.end())
        {
            CUserInfo &itemRef = (CUserInfo&) (*item).first;

            itemRef.m_dwUserCount[dwIndex] -= dwToRemove;
        }
    }

    Unlock();
    
    return ERROR_SUCCESS;
}



HRESULT CQuota::IncrementQuotaIndexByUser(
    ESS_QUOTA_INDEX dwIndex, 
    void *pUser,
    DWORD dwToAdd)
{
    CUserMapIterator* pIt = (CUserMapIterator*)pUser;

    HRESULT hr = S_OK;

    Lock();
    
    if (m_dwGlobalCount[dwIndex] + dwToAdd <= m_dwGlobalLimits[dwIndex])
    {
        if(pIt)
        {
            CUserInfo &itemRef = (CUserInfo&) (*pIt)->first;
    
            if (itemRef.m_dwUserCount[dwIndex] + dwToAdd <= 
                    m_dwUserLimits[dwIndex])
            {
                itemRef.m_dwUserCount[dwIndex] += dwToAdd;
                m_dwGlobalCount[dwIndex] += dwToAdd;
            }
            else
            {
                hr = WBEM_E_QUOTA_VIOLATION;
            }
        }
        else
        {
            // Special case for calls Winmgmt makes: doesn't count against any 
            // user.
            // Should this event count against our global counts?
            m_dwGlobalCount[dwIndex] += dwToAdd;
        }
    }
    else
        hr = WBEM_E_QUOTA_VIOLATION;

    Unlock();

    return hr;
}
    
HRESULT CQuota::DecrementQuotaIndexByUser(
    ESS_QUOTA_INDEX dwIndex,
    void *pUser,
    DWORD dwToRemove)
{
    CUserMapIterator* pIt = (CUserMapIterator*)pUser;

    Lock();
    
    m_dwGlobalCount[dwIndex] -= dwToRemove;

    if (pIt)
    {
        CUserInfo &itemRef = (CUserInfo&) (*pIt)->first;

        _ASSERT(itemRef.m_dwUserCount[dwIndex] >= dwToRemove, 
                L"Negative quotas!");

        itemRef.m_dwUserCount[dwIndex] -= dwToRemove;
    }

    Unlock();

    return S_OK;
}

const LPCWSTR szUserProps[] =
{
    L"TemporarySubscriptionsPerUser",
    L"PermanentSubscriptionsPerUser",
    L"PollingInstructionsPerUser", 
    L"PollingMemoryPerUser",
};

const LPCWSTR szGlobalProps[] =
{
    L"TemporarySubscriptionsTotal",
    L"PermanentSubscriptionsTotal",
    L"PollingInstructionsTotal", 
    L"PollingMemoryTotal",
};

void CQuota::UpdateQuotaSettings(IWbemClassObject *pObj)
{
    VARIANT vTemp;

    VariantInit(&vTemp);

    Lock();

    for (int i = 0; i < ESSQ_INVALID_INDEX; i++)
    {
        if (SUCCEEDED(pObj->Get(szUserProps[i], 0, &vTemp, NULL, NULL)))
            m_dwUserLimits[i] = V_I4(&vTemp);

        if (SUCCEEDED(pObj->Get(szGlobalProps[i], 0, &vTemp, NULL, NULL)))
            m_dwGlobalLimits[i] = V_I4(&vTemp);
    }             

    Unlock();
}

HRESULT WINAPI CQuota::Indicate(long lNumEvents, IWbemClassObject **ppEvents)
{
    VARIANT vTemp;

    VariantInit(&vTemp);

    if (SUCCEEDED(ppEvents[lNumEvents - 1]->Get(
        L"TARGETINSTANCE", 0, &vTemp, NULL, NULL)))
    {
        IWbemClassObject *pObj = NULL;
        
        vTemp.punkVal->QueryInterface(IID_IWbemClassObject, (LPVOID*) &pObj);

        if (pObj)
        {
            UpdateQuotaSettings(pObj);

            pObj->Release();
        }
    }

    VariantClear(&vTemp);

    return S_OK;
}

CSaveCallContext::CSaveCallContext(BOOL bSave) :
    m_pSecurity(NULL)
{
    m_bSaved = bSave;

    if (bSave)
        WbemCoGetCallContext(IID_IWbemCallSecurity, (LPVOID*) &m_pSecurity);
}

CSaveCallContext::~CSaveCallContext()
{
    if (m_bSaved)
    {
        IUnknown *pPrev = NULL;

        CoSwitchCallContext(m_pSecurity, &pPrev);

        if (m_pSecurity)
            m_pSecurity->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\quota.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************
// Quota.h

#ifndef __QUOTA_H
#define __QUOTA_H

#include <map>

enum ESS_QUOTA_INDEX
{
    ESSQ_TEMP_SUBSCRIPTIONS,
    ESSQ_PERM_SUBSCRIPTIONS,
    ESSQ_POLLING_INSTRUCTIONS,
    ESSQ_POLLING_MEMORY,
    ESSQ_INVALID_INDEX
};

#define ESSQ_INDEX_COUNT    ESSQ_INVALID_INDEX

class CSaveCallContext
{
public:
    CSaveCallContext(BOOL bSave);
    ~CSaveCallContext();

protected:
    IWbemCallSecurity *m_pSecurity;
    BOOL              m_bSaved;
};
    
class CUserInfo
{
public:
    CUserInfo();
    CUserInfo(LPBYTE pData, DWORD dwLen);
    CUserInfo(const CUserInfo &other)
    {
        *this = other;
    }

    ~CUserInfo();

    BOOL Init(LPBYTE pData, DWORD dwLen);

    const CUserInfo& operator = (const CUserInfo& other);
    bool operator == (const CUserInfo& other) const;
    bool operator < (const CUserInfo& other) const;

    DWORD  m_dwUserCount[ESSQ_INDEX_COUNT];

protected:
    LPBYTE m_pData;
    DWORD  m_dwSize;
    BOOL   m_bAlloced;

    BOOL CopyData(LPBYTE pData, DWORD dwLen);
};

class CQuota : public IWbemObjectSink
{
public:
    CQuota();
    ~CQuota();

    HRESULT IncrementQuotaIndex(
        ESS_QUOTA_INDEX dwIndex,
        CEventFilter *pFilter,
        DWORD dwToAdd);
    HRESULT DecrementQuotaIndex(
        ESS_QUOTA_INDEX dwIndex,
        CEventFilter *pFilter,
        DWORD dwToRemove);
    HRESULT FindUser(CEventFilter* pFilter, void** pUser);
    HRESULT FreeUser(void* pUser);
    HRESULT IncrementQuotaIndexByUser(ESS_QUOTA_INDEX dwIndex, 
                                void *pUser, DWORD dwToAdd);
    HRESULT DecrementQuotaIndexByUser(ESS_QUOTA_INDEX dwIndex, void *pUser,
                                DWORD dwToRemove);

    HRESULT Init(CEss *pEss);
    HRESULT Shutdown();

protected:
    typedef std::map<CUserInfo, DWORD, std::less<CUserInfo>, 
                    wbem_allocator<DWORD> > CUserMap;
    typedef CUserMap::iterator CUserMapIterator;

    CEss             *m_pEss;
    CUserMap         m_mapUserInfo;
    DWORD            m_dwGlobalCount[ESSQ_INDEX_COUNT],
                     m_dwUserLimits[ESSQ_INDEX_COUNT],
                     m_dwGlobalLimits[ESSQ_INDEX_COUNT];
    CRITICAL_SECTION m_cs;

    void UpdateQuotaSettings(IWbemClassObject *pObj);

    void Lock()
    {
        EnterCriticalSection(&m_cs);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_cs);
    }

    DWORD WINAPI AddRef()
    {
        return 1;
    }

    DWORD WINAPI Release()
    {
        return 1;
    }

    HRESULT WINAPI QueryInterface(REFIID riid, void **ppv)
    {
        if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        {
            *ppv = (IWbemObjectSink*) this;
            AddRef();
            
            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }
    HRESULT WINAPI Indicate(long lNumEvents, IWbemEvent** apEvents);
    HRESULT WINAPI SetStatus(long, long, BSTR, IWbemClassObject*)
    {
        return E_NOTIMPL;
    }
};

// Global instance of CQuota.
extern CQuota g_quotas;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tempbind.h ===
//******************************************************************************
//
//  TEMPBIND.H
//
//  Copyright (C) 2000 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TEMP_BINDING__H_
#define __WMI_ESS_TEMP_BINDING__H_

#include "binding.h"
#include "fastall.h"

class CTempBinding : public CBinding
{
public:
    CTempBinding( long lFlags, WMIMSG_QOS_FLAG lQosFlags, bool bSecure );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tempbind.cpp ===
//******************************************************************************
//
//  TEMPBIND.CPP
//
//  Copyright (C) 2000 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include <tempbind.h>

CTempBinding::CTempBinding( long lFlags, 
                            WMIMSG_QOS_FLAG lQosFlags,
                            bool bSecure )
{
    m_dwQoS = lQosFlags;
    m_bSecure = bSecure;
    m_bSlowDown = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tempcons.h ===
//******************************************************************************
//
//  TEMPCONS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TEMP_CONSUMER__H_
#define __WMI_ESS_TEMP_CONSUMER__H_

#include "binding.h"
#include "tempfilt.h"

class CTempConsumer : public CEventConsumer
{
    //
    // ESS can internally use temporary subscriptions to satisfy cross
    // namespace subscriptions.  We need to be able to propagate the
    // 'permanent'-ness with the temporary subscription to the target
    // namespace.
    //
    BOOL m_bEffectivelyPermanent;

    IWbemObjectSink* m_pSink;

public:
    CTempConsumer(CEssNamespace* pNamespace);
    HRESULT Initialize( BOOL bEffectivelyPermanent, IWbemObjectSink* pSink);
    ~CTempConsumer();

    BOOL IsPermanent() const { return m_bEffectivelyPermanent; }

    HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents, 
                            BOOL bSecure, CEventContext* pContext);
    
    static DELETE_ME LPWSTR ComputeKeyFromSink(IWbemObjectSink* pSink);

    HRESULT ReportQueueOverflow(IWbemEvent* pEvent, DWORD dwQueueSize);
    HRESULT Shutdown(bool bQuiet = false);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tempcons.cpp ===
//******************************************************************************
//
//  TEMPCONS.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "tempcons.h"

CTempConsumer::CTempConsumer(CEssNamespace* pNamespace)
    : CEventConsumer(pNamespace), m_pSink(NULL), m_bEffectivelyPermanent(FALSE)
{
    pNamespace->IncrementObjectCount();
}

HRESULT CTempConsumer::Initialize( BOOL bEffectivelyPermanent, 
                                   IWbemObjectSink* pSink)
{
    m_bEffectivelyPermanent = bEffectivelyPermanent;

    // Save the sink
    // =============

    m_pSink = pSink;
    if(m_pSink)
        m_pSink->AddRef();

    // Compute the key from the sink pointer
    // =====================================

    LPWSTR wszKey = ComputeKeyFromSink(pSink);

    if ( NULL == wszKey )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> vdm(wszKey);

    // Save the key into the compressed format
    // =======================================

    if( !( m_isKey = wszKey ) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

// This class represents a postponed request to disconnect a temporary consumer
// Its implementation is to call SetStatus followed by a release
class CPostponedDisconnect : public CPostponedRequest
{
protected:
    IWbemObjectSink* m_pSink;

public:
    CPostponedDisconnect(IWbemObjectSink* pSink) : m_pSink(pSink)
    {
        m_pSink->AddRef();
    }
    ~CPostponedDisconnect()
    {
        m_pSink->Release();
    }
    
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        m_pSink->SetStatus(0, WBEM_E_CALL_CANCELLED, NULL, NULL);
        m_pSink->Release();
        return WBEM_S_NO_ERROR;
    }
};
        
HRESULT CTempConsumer::Shutdown(bool bQuiet)
{
    IWbemObjectSink* pSink = NULL;
    {
        CInCritSec ics(&m_cs);
        if(m_pSink)
        {
            pSink = m_pSink;
            m_pSink = NULL;
        }
    }

    if(pSink)
    {
        if(!bQuiet)
            pSink->SetStatus(0, WBEM_E_CALL_CANCELLED, NULL, NULL);
        pSink->Release();
    }

    return WBEM_S_NO_ERROR;
}

CTempConsumer::~CTempConsumer()
{
    if(m_pSink)
    {
        //
        // Postpone disconnect request --- don't want the consumer to hand us
        // here
        //

        CPostponedList* pList = GetCurrentPostponedList();
        if(pList != NULL)
        {
            CPostponedDisconnect* pReq = new CPostponedDisconnect(m_pSink);
            
            if(pReq != NULL)
                pList->AddRequest( m_pNamespace, pReq);

            m_pSink = NULL;
        }
        else
        {
            m_pSink->Release();
            m_pSink = NULL;
        }
    }
    m_pNamespace->DecrementObjectCount();
}

HRESULT CTempConsumer::ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                        BOOL bSecure, CEventContext* pContext)
{
    HRESULT hres;
    IWbemObjectSink* pSink = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pSink)
        {
            pSink = m_pSink;
            pSink->AddRef();
        }
    }

    CReleaseMe rm1(pSink);

    if( pSink )
    {
        //
        // TODO: Separate out an InternalTempConsumer class that is used 
        // for cross-namespace delivery.  This way, we can remove all of the
        // cross-namespace hacks ( like one below ) from this class.
        // 
        if ( !m_bEffectivelyPermanent )
        {
            hres = pSink->Indicate(lNumEvents, apEvents);
        }
        else
        {
            //
            // before indicating to the sink, decorate the event so that 
            // the subscribers can tell which namespace the event originated
            // from.  
            // 

/*
BUGBUG: Removing because we do not support an event being modified by one 
of its consumers.  This is because we do not clone the event when delivering 
to each consumer.  

            for( long i=0; i < lNumEvents; i++ )
            {
                hres = m_pNamespace->DecorateObject( apEvents[i] );

                if ( FAILED(hres) )
                {
                    ERRORTRACE((LOG_ESS, "Failed to decorate a "
                     " cross-namespace event in namespace %S.\n", 
                     m_pNamespace->GetName() ));
                }        
            }
*/                
            hres = ((CAbstractEventSink*)pSink)->Indicate( lNumEvents,
                                                           apEvents,
                                                           pContext );
        }
    }
    else
        hres = WBEM_E_CRITICAL_ERROR;

    if(FAILED(hres) && hres != WBEM_E_CALL_CANCELLED)
    {
        ERRORTRACE((LOG_ESS, "An attempt to deliver an evento to a "
            "temporary consumer failed with %X\n", hres));

        // The wraper for the sink took care of cancellation
    }
    return hres;
}

HRESULT CTempConsumer::ReportQueueOverflow(IWbemEvent* pEvent, 
                                            DWORD dwQueueSize)
{
    IWbemObjectSink* pSink = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pSink)
        {
            pSink = m_pSink;
            pSink->AddRef();
        }
    }

    CReleaseMe rm1(pSink);

    // Call SetStatus to report
    // ========================

    if(pSink)
    {
        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_QUEUE_OVERFLOW, 
                            NULL, NULL);

        // Keep sink up.  Hope it recovers
        // ===============================

    }
    return S_OK;
}


DELETE_ME LPWSTR CTempConsumer::ComputeKeyFromSink(IWbemObjectSink* pSink)
{
    LPWSTR wszKey = _new WCHAR[20];

    if ( wszKey )
    {
        StringCchPrintfW( wszKey, 20, L"$%p", pSink );
    }

    return wszKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tempfilt.h ===
//******************************************************************************
//
//  TEMPFILT.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TEMP_FILTER__H_
#define __WMI_ESS_TEMP_FILTER__H_

#include "binding.h"
#include "filter.h"
#include <comutil.h>

class CTempFilter : public CGenericFilter
{
private:
    LPWSTR m_wszQuery;
    LPWSTR m_wszQueryLanguage;
    IWbemCallSecurity* m_pSecurity;
    CWbemPtr<IWbemObjectSink> m_pSink;
    bool m_bInternal;

public:
    CTempFilter(CEssNamespace* pNamespace);
    HRESULT Initialize( LPCWSTR wszQueryLanguage, 
                        LPCWSTR wszQuery, 
                        long lFlags,
                        PSID pOwnerSid,
                        bool bInternal,
                        IWbemContext* pContext, 
                        IWbemObjectSink* pSink );
    ~CTempFilter();

    virtual bool IsInternal() { return m_bInternal; }

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp);
    BOOL IsPermanent() { return m_pOwnerSid != NULL; }
    virtual DWORD GetForceFlags() {return WBEM_FLAG_STRONG_VALIDATION;}
    virtual HRESULT SetThreadSecurity( IUnknown** ppNewContext );
    HRESULT ObtainToken(IWbemToken** ppToken);

    STDMETHOD(SetStatus)(long a, long b, BSTR c, IWbemClassObject* d)
        { return m_pSink->SetStatus( a, b, c, d ); }

    DELETE_ME LPWSTR ComputeThisKey();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tkncache.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __WBEM_TOKEN_CACHE__H_
#define __WBEM_TOKEN_CACHE__H_

#include <wbemcomn.h>
#include <wbemint.h>
#include <sync.h>

class CWmiToken;
class CTokenCache : public CUnkBase<IWbemTokenCache, &IID_IWbemTokenCache>
{
protected:
    CCritSec m_cs;
    CRefedPointerArray<CWmiToken> m_apTokens;

protected:
    BOOL ConstructTokenFromHandle(HANDLE hToken, const BYTE* pSid,
                                                IWbemToken** ppToken);

public:
    CTokenCache(CLifeControl* pControl) : 
        CUnkBase<IWbemTokenCache, &IID_IWbemTokenCache>(pControl){}
    HRESULT STDMETHODCALLTYPE GetToken(const BYTE* pSid, IWbemToken** ppToken);
    HRESULT STDMETHODCALLTYPE Shutdown();
};

class CWmiToken : public CUnkBase<IWbemToken, &IID_IWbemToken>
{
protected:
    HANDLE m_hToken;
    CTokenCache* m_pCache;
    PSID m_pSid;
    bool m_bOwnHandle;

    friend CTokenCache;

public:
    CWmiToken(ADDREF CTokenCache* pCache, const PSID pSid, 
                ACQUIRE HANDLE hToken);
    CWmiToken(READ_ONLY HANDLE hToken);
    virtual ~CWmiToken();

    HRESULT STDMETHODCALLTYPE AccessCheck(DWORD dwDesiredAccess, 
                                            const BYTE* pSD, 
                                            DWORD* pdwGrantedAccess);
        
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tkncache.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <tkncache.h>
#include <groupsforuser.h>

CWmiToken::CWmiToken(ADDREF CTokenCache* pCache, const PSID pSid, 
                        ACQUIRE HANDLE hToken) :
    CUnkBase<IWbemToken, &IID_IWbemToken>(NULL), m_hToken(hToken), 
    m_pCache(pCache), m_pSid(NULL), m_bOwnHandle(true)
{
    if(m_pCache)
        m_pCache->AddRef();
    if(pSid)
    {
        m_pSid = (PSID)new BYTE[GetLengthSid(pSid)];
        if(m_pSid == NULL)
            return;
        CopySid(GetLengthSid(pSid), m_pSid, pSid);
    }
}

CWmiToken::CWmiToken(READ_ONLY HANDLE hToken) :
    CUnkBase<IWbemToken, &IID_IWbemToken>(NULL), m_hToken(hToken), 
    m_pCache(NULL), m_pSid(NULL), m_bOwnHandle(false)
{
}

CWmiToken::~CWmiToken()
{
    if(m_pCache)
        m_pCache->Release();
    if(m_bOwnHandle)
        CloseHandle(m_hToken);
    delete [] (BYTE*)m_pSid;
}    

STDMETHODIMP CWmiToken::AccessCheck(DWORD dwDesiredAccess, const BYTE* pSD,
                                            DWORD* pdwGrantedAccess)
{
    if(m_hToken == NULL)
        return WBEM_E_CRITICAL_ERROR;

    // BUGBUG: figure out what this is for!
    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0x1C;
    map.GenericExecute = 2;
    map.GenericAll = 0x6001f;
    PRIVILEGE_SET ps;
    DWORD dwPrivLength = sizeof(ps);

    BOOL bStatus;
    BOOL bRes = ::AccessCheck((SECURITY_DESCRIPTOR*)pSD, m_hToken, 
                                dwDesiredAccess, &map, &ps, 
                                &dwPrivLength, pdwGrantedAccess, &bStatus);
    if(!bRes)
    {
        return WBEM_E_ACCESS_DENIED;
    }
    else
    {
        return WBEM_S_NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\tempfilt.cpp ===
//******************************************************************************
//
//  TEMPFILT.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "tempfilt.h"
#include <cominit.h>
#include <tkncache.h>
#include <callsec.h>
#include <wbemutil.h>

CTempFilter::CTempFilter(CEssNamespace* pNamespace)
    : CGenericFilter(pNamespace), m_wszQueryLanguage(NULL), 
      m_wszQuery(NULL), m_pSecurity(NULL), m_bInternal( false )
{
}

HRESULT CTempFilter::Initialize( LPCWSTR wszQueryLanguage, 
                                 LPCWSTR wszQuery, 
                                 long lFlags, 
                                 PSID pOwnerSid,
                                 bool bInternal,
                                 IWbemContext* pContext, 
                                 IWbemObjectSink* pSink )
{
    HRESULT hres;

    _DBG_ASSERT( pSink != NULL );
    m_pSink = pSink;
    m_bInternal = bInternal;

    hres = CGenericFilter::Create(wszQueryLanguage, wszQuery);
    if(FAILED(hres))
        return hres;

    LPWSTR wszKey = ComputeThisKey();
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(wszKey);
    if(!(m_isKey = wszKey))
        return WBEM_E_OUT_OF_MEMORY;

    m_wszQueryLanguage = CloneWstr(wszQueryLanguage);
    if(m_wszQueryLanguage == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_wszQuery = CloneWstr(wszQuery);
    if(m_wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // if this filter is effectively permanent, that is it is being created
    // on behalf of a permanent subscription ( for cross namespace purposes ),
    // then we need to propagate the SID of the original subscription.
    // For a normal temp filter, we save the call context and use that later 
    // for checking access.
    //

    if ( pOwnerSid == NULL )
    {
        //
        // if this call is an on behalf of an internal call, no need to 
        // check security.
        // 
        if ( !bInternal )
        {
            WbemCoGetCallContext( IID_IWbemCallSecurity, (void**)&m_pSecurity);
        }
    }
    else
    {
        int cOwnerSid = GetLengthSid( pOwnerSid );

        m_pOwnerSid = new BYTE[cOwnerSid];

        if ( m_pOwnerSid == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy( m_pOwnerSid, pOwnerSid, cOwnerSid );
    }

    return WBEM_S_NO_ERROR;
}

CTempFilter::~CTempFilter()
{
    delete [] m_wszQuery;
    delete [] m_wszQueryLanguage;
    if(m_pSecurity)
        m_pSecurity->Release();
}

DELETE_ME LPWSTR CTempFilter::ComputeThisKey()
{
    LPWSTR wszKey = _new WCHAR[20];

    if ( wszKey )
    {
        StringCchPrintfW( wszKey, 20, L"$%p", this);
    }
    return wszKey;
}

HRESULT CTempFilter::GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp)
{
    bExact = TRUE;
    wszQueryLanguage = CloneWstr(m_wszQueryLanguage);
    if(wszQueryLanguage == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wszQuery = CloneWstr(m_wszQuery);
    if(wszQuery== NULL)
    {
        delete [] wszQueryLanguage;
        wszQueryLanguage = NULL;
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    if(ppExp)
    {
        CTextLexSource src((LPWSTR)wszQuery);
        QL1_Parser parser(&src);
        int nRes = parser.Parse(ppExp);
        if (nRes)
        {
            delete [] wszQueryLanguage;
            delete [] wszQuery;
            wszQueryLanguage = NULL;
            wszQuery = NULL;

            ERRORTRACE((LOG_ESS, "Unable to construct event filter with "
                "unparsable "
                "query '%S'.  The filter is not active\n", wszQuery));
            return WBEM_E_UNPARSABLE_QUERY;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CTempFilter::SetThreadSecurity( IUnknown** ppNewContext )
{
    *ppNewContext = NULL;

    HRESULT hr;

    if ( m_pSecurity != NULL )
    {        
        //
        // need to clone the security call context since it could be 
        // attached to multiple threads at the same time and the security
        // class is not designed for this.   Since the clone operation is 
        // also not MT safe, need to use cs here.
        // 
        CInCritSec ics(&m_cs);

        CWbemPtr<IWbemCallSecurity> pClone = CWbemCallSecurity::CreateInst();
        
        if ( pClone == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // 
        // CreateInst() returns a object with ref count of 1.  With our 
        // auto ref assignment operator, it is now 2.  Perform a release 
        // to knock it back down to the desired count.
        // 
        pClone->Release();

        IUnknown* pOld;
        hr = WbemCoSwitchCallContext( m_pSecurity, &pOld );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pClone->CloneThreadContext( TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = WbemCoSwitchCallContext( pClone, &pOld );

        if ( FAILED(hr) )
        {
            return hr;
        }

        *ppNewContext = pClone;
        pClone->AddRef();
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}
    
HRESULT CTempFilter::ObtainToken(IWbemToken** ppToken)
{
    HRESULT hr;
    *ppToken = NULL;

    //
    // Construct an IWbemToken object to return.
    //

    if ( m_pSecurity != NULL )
    {
        CWmiToken* pNewToken = new CWmiToken(m_pSecurity->GetToken());
    
        if ( pNewToken != NULL )
        {
            hr = pNewToken->QueryInterface(IID_IWbemToken, (void**)ppToken);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if ( m_pOwnerSid != NULL )
    {
        hr = m_pNamespace->GetToken( m_pOwnerSid, ppToken );
    }
    else if ( m_bInternal )
    {
        hr = WBEM_S_FALSE;
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\wbemtss.h ===
//*****************************************************************************
//
//  WBEMTSS.H
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  This file defines the classes used by the Timer Subsystem. 
//
//  Classes defined:
//
//      RecurrenceInstruction       Complex recurrence information.
//      TimerInstruction            Single instruction for the timer
//      
//      
//
//  26-Nov-96   raymcc      Draft
//  28-Dec-96   a-richm     Alpha PDK Release
//  12-Apr-97   a-levn      Extensive changes
//
//*****************************************************************************


#ifndef _WBEMTSS_H_
#define _WBEMTSS_H_

#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include "sync.h"
#include "statsync.h"
#include "CWbemTime.h"
#include "parmdefs.h"
#include "tss.h"
#include "wstring.h"


//*****************************************************************************
//
//  class CTimerInstruction
//
//  Generic timer instruction class. Has a name (m_wsTimerId) and knows 
//  whether events that were missed due to the system being halted or dead 
//  should be fired. 
//
//  Derived classes must be able to tell when their next firing time is.
//
//*****************************************************************************

class CEss;
class CWinMgmtTimerGenerator;
class CWBEMTimerInstruction : public CTimerInstruction
{
protected:
    long m_lRefCount;

    CWinMgmtTimerGenerator* m_pGenerator;
    IWbemServices* m_pNamespace;
    WString m_wsNamespace;
    WString m_wsTimerId;
    BOOL m_bSkipIfPassed;

    BOOL m_bRemoved;

public:
    CWBEMTimerInstruction();
    virtual ~CWBEMTimerInstruction();

    void AddRef()
        {InterlockedIncrement(&m_lRefCount);}
    void Release()
        {if(InterlockedDecrement(&m_lRefCount) == 0) delete this;}

    BOOL SkipIfPassed() const {return m_bSkipIfPassed;}
    void SetSkipIfPassed(BOOL bSkip) {m_bSkipIfPassed = bSkip;}

    INTERNAL LPCWSTR GetTimerId() {return m_wsTimerId;}
    INTERNAL LPCWSTR GetNamespace() {return m_wsNamespace;}
    void SetTimerId(LPCWSTR wszTimerId)
    {
        m_wsTimerId = wszTimerId;
    }

public:
    static HRESULT CheckObject(IWbemClassObject* pObject);
    static HRESULT LoadFromWbemObject(LPCWSTR wszNamespace,
        ADDREF IWbemServices* pNamespace,
        CWinMgmtTimerGenerator* pGenerator,
        IN IWbemClassObject* pObject, 
        OUT RELEASE_ME CWBEMTimerInstruction*& pInstruction);

    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const;
    virtual CWbemTime GetFirstFiringTime() const;
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFitingTime);
    virtual HRESULT MarkForRemoval();
    virtual int GetInstructionType() {return INSTTYPE_WBEM;}
    HRESULT StoreNextFiring(CWbemTime When);
    CWbemTime GetStartingFiringTime(CWbemTime OldTime) const;

protected:
    CWbemTime SkipMissed(CWbemTime Firing, long* plMissedCount = NULL) const;

    virtual CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const = 0;
    virtual CWbemTime ComputeFirstFiringTime() const = 0;
    virtual HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject) = 0;

protected:
    static CStaticCritSec mstatic_cs;
};

//*****************************************************************************
//
//  class CAbsoluteTimerInstruction
//
//  A type of timer instruction which only fires once --- at the preset time.
//
//*****************************************************************************

class CAbsoluteTimerInstruction : public CWBEMTimerInstruction
{
protected:
    CWbemTime m_When;

public:
    CAbsoluteTimerInstruction() : CWBEMTimerInstruction(){}
    CWbemTime GetFiringTime() const{return m_When;}
    void SetFiringTime(CWbemTime When) {m_When = When;}

public:
    CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const;
    CWbemTime ComputeFirstFiringTime() const;

    static HRESULT CheckObject(IWbemClassObject* pObject);
    HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject);
    static INTERNAL LPCWSTR GetWbemClassName()
        {return L"__AbsoluteTimerInstruction";}
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFitingTime);
};

//*****************************************************************************
//
//  class CIntervalTimerInstruction
//
//  A type of timer instruction which fires every N milliseconds starting at 
//  a given time.
//
//*****************************************************************************

class CIntervalTimerInstruction : public CWBEMTimerInstruction
{
protected:
    CWbemTime m_Start; // not used
    CWbemInterval m_Interval;

public:
    CIntervalTimerInstruction() 
        : CWBEMTimerInstruction(), m_Start(), m_Interval()
    {}

    CWbemTime GetStart() const {return m_Start;}
    void SetStart(CWbemTime Start) {m_Start = Start;}

    CWbemInterval GetInterval() const {return m_Interval;}
    void SetInterval(CWbemInterval Interval) {m_Interval = Interval;}

public:
    static HRESULT CheckObject(IWbemClassObject* pObject) {return S_OK;}
    CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const;
    CWbemTime ComputeFirstFiringTime() const;

    HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject);
    static INTERNAL LPCWSTR GetWbemClassName() 
        {return L"__IntervalTimerInstruction";}
};

//*****************************************************************************
//
//  class CRecurringInstruction
//
//  A more complex recurrence instruction. TBD
//
//*****************************************************************************

class CRecurringTimerInstruction : public CWBEMTimerInstruction
{
    // TBD
public:
    CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const
        {return CWbemTime::GetInfinity();}
    CWbemTime ComputeFirstFiringTime() const
        {return CWbemTime::GetInfinity();}

    HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject) 
        {return E_UNEXPECTED;}
    static INTERNAL LPCWSTR GetWbemClassName() 
        {return L"__RecurringTimerInstruction";}
    static HRESULT CheckObject(IWbemClassObject* pObject) {return S_OK;}
};

class CWinMgmtTimerGenerator : public CTimerGenerator
{
public:
    CWinMgmtTimerGenerator(CEss* pEss);
    HRESULT LoadTimerEventQueue(LPCWSTR wszNamespace, 
                                IWbemServices* pNamespace);
    HRESULT LoadTimerEventObject(LPCWSTR wszNamespace, 
                                 IWbemServices* pNamespace, 
                                 IWbemClassObject * pTimerInstruction,
                                 IWbemClassObject * pNextFiring = NULL);
    HRESULT LoadTimerEventObject(LPCWSTR wszNamespace, 
                                 IWbemClassObject * pTimerInstruction);
    HRESULT CheckTimerInstruction(IWbemClassObject* pInst);

    HRESULT Remove(LPCWSTR wszNamespace, LPCWSTR wszId);
    HRESULT Remove(LPCWSTR wszNamespace);
    HRESULT FireInstruction(CWBEMTimerInstruction* pInst, long lNumFirings);
    virtual HRESULT Shutdown();
    HRESULT SaveAndRemove(LONG bIsSystemShutDown);
    void DumpStatistics(FILE* f, long lFlags);

protected:
    class CIdTest : public CInstructionTest
    {
    protected:
        LPCWSTR m_wszId;
        LPCWSTR m_wszNamespace;
    public:
        CIdTest(LPCWSTR wszNamespace, LPCWSTR wszId) 
            : m_wszId(wszId), m_wszNamespace(wszNamespace) {}
        BOOL operator()(CTimerInstruction* pInst);
    };

    class CNamespaceTest : public CInstructionTest
    {
    protected:
        LPCWSTR m_wszNamespace;
    public:
        CNamespaceTest(LPCWSTR wszNamespace) 
            : m_wszNamespace(wszNamespace) {}
        BOOL operator()(CTimerInstruction* pInst);
    };
    
protected:

    CEss* m_pEss;
};                                                               


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\ess3\wbemtss.cpp ===
//*****************************************************************************
//
//  WBEMTSS.CPP
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  This file implements the classes used by the Timer Subsystem. 
//
//  Classes implemented:
//
//  26-Nov-96   raymcc      Draft
//  28-Dec-96   a-richm     Alpha PDK Release
//  12-Apr-97   a-levn      Extensive changes
//
//*****************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "wbemtss.h"

CStaticCritSec CWBEMTimerInstruction::mstatic_cs;

CWBEMTimerInstruction::CWBEMTimerInstruction() 
    : m_lRefCount(1), m_bSkipIfPassed(FALSE), m_pNamespace(NULL), 
        m_pGenerator(NULL), m_bRemoved(FALSE)
{
}


CWBEMTimerInstruction::~CWBEMTimerInstruction()
{
    if(m_pNamespace) m_pNamespace->Release();
}


CWbemTime CWBEMTimerInstruction::GetFirstFiringTime() const
{
    CWbemTime FirstTime = ComputeFirstFiringTime();
    
    if(FirstTime.IsZero())
    {
        // Instruction says: fire now
        // ==========================
        FirstTime = CWbemTime::GetCurrentTime();
    }
    else if(SkipIfPassed())
    {
        FirstTime = SkipMissed(FirstTime);
    }
    return FirstTime;
}

CWbemTime CWBEMTimerInstruction::GetStartingFiringTime(CWbemTime OldTime) const
{
    //
    // If SkipIfPassed is set, we need to set the starting firing time to the
    // next one after current
    //

    if(SkipIfPassed())
        return SkipMissed(OldTime);

    //
    // Otherwise, just leave it be --- the firing logic will figure out how many
    // we must have missed
    //

    return OldTime;
}

CWbemTime CWBEMTimerInstruction::SkipMissed(IN CWbemTime OldTime, 
                                         OUT long* plMissedFiringCount) const
{
    long lMissedCount = 0;
    CWbemTime Firing = OldTime;
    CWbemTime CurrentTime = CWbemTime::GetCurrentTime();
    while(Firing < CurrentTime)
    {
        Firing = ComputeNextFiringTime(Firing);
        lMissedCount++;
    }

    if(SkipIfPassed())
        lMissedCount = 0;

    if(plMissedFiringCount) 
        *plMissedFiringCount = lMissedCount;

    return Firing;
}

CWbemTime CWBEMTimerInstruction::GetNextFiringTime(IN CWbemTime LastFiringTime, 
                                         OUT long* plMissedFiringCount) const
{
    CWbemTime NextFiring = ComputeNextFiringTime(LastFiringTime);
    
    NextFiring = SkipMissed(NextFiring, plMissedFiringCount);

    return NextFiring;
}

HRESULT CWBEMTimerInstruction::CheckObject(IWbemClassObject* pInst)
{
    HRESULT hres;
    VARIANT v;

    VariantInit(&v);
    CClearMe cm(&v);

    hres = pInst->Get(L"SkipIfPassed", 0, &v, NULL, NULL);
    if(FAILED(hres)) 
        return hres;
    if(V_VT(&v) != VT_BOOL) 
        return WBEM_E_INVALID_OBJECT;

    hres = pInst->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    if(!wbem_wcsicmp(V_BSTR(&v), 
                CAbsoluteTimerInstruction::GetWbemClassName()))
    {
        return CAbsoluteTimerInstruction::CheckObject(pInst);
    }
    else if(!wbem_wcsicmp(V_BSTR(&v), 
                CIntervalTimerInstruction::GetWbemClassName()))
    {
        return CIntervalTimerInstruction::CheckObject(pInst);
    }
    else if(!wbem_wcsicmp(V_BSTR(&v),
                CRecurringTimerInstruction::GetWbemClassName()))
    {
        return CRecurringTimerInstruction::CheckObject(pInst);
    }
    else
    {
        return WBEM_E_INVALID_CLASS;
    }
}

    

HRESULT CWBEMTimerInstruction::LoadFromWbemObject(
        LPCWSTR wszNamespace,
        ADDREF IWbemServices* pNamespace,
        CWinMgmtTimerGenerator* pGenerator,
        IN IWbemClassObject* pObject, 
        OUT RELEASE_ME CWBEMTimerInstruction*& pInstruction)
{
    HRESULT hres;
    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pObject->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR) return WBEM_E_INVALID_OBJECT;

    if(!wbem_wcsicmp(V_BSTR(&v), CAbsoluteTimerInstruction::GetWbemClassName()))
    {
        pInstruction = _new CAbsoluteTimerInstruction;
    }
    else if(!wbem_wcsicmp(V_BSTR(&v), CIntervalTimerInstruction::GetWbemClassName()))
    {
        pInstruction = _new CIntervalTimerInstruction;
    }
    else if(!wbem_wcsicmp(V_BSTR(&v),CRecurringTimerInstruction::GetWbemClassName()))
    {
        pInstruction = _new CRecurringTimerInstruction;
    }
    else
    {
        return WBEM_E_INVALID_CLASS;
    }

    if(pInstruction == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    try
    {
        pInstruction->m_wsNamespace = wszNamespace;
        pInstruction->m_pGenerator = pGenerator;

        pInstruction->m_pNamespace = pNamespace;
        if(pNamespace) pNamespace->AddRef();    

        VariantClear(&v);

        hres = pObject->Get(L"TimerId", 0, &v, NULL, NULL);
        if(FAILED(hres)) return hres;
        if(V_VT(&v) != VT_BSTR) return WBEM_E_INVALID_OBJECT;

        pInstruction->m_wsTimerId = V_BSTR(&v);
        VariantClear(&v);

        hres = pObject->Get(L"SkipIfPassed", 0, &v, NULL, NULL);
        if(FAILED(hres)) return hres;
        if(V_VT(&v) != VT_BOOL) return WBEM_E_INVALID_OBJECT;

        pInstruction->m_bSkipIfPassed = (V_BOOL(&v) != VARIANT_FALSE);
  
        hres = pInstruction->LoadFromWbemObject(pObject);
    }
    catch( CX_MemoryException& )
    {
        delete pInstruction;
        pInstruction = NULL;
        hres = WBEM_E_OUT_OF_MEMORY;
    }

    return hres;
}

HRESULT CWBEMTimerInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    // Notify the sink
    // ===============

    HRESULT hres = m_pGenerator->FireInstruction(this, lNumTimes);
    return hres;
}


HRESULT CWBEMTimerInstruction::StoreNextFiring(CWbemTime When)
{
    SCODE  sc;

    // Create an instance of the NextFiring class
    // ==========================================

    IWbemClassObject* pClass = NULL;
    sc = m_pNamespace->GetObject(CWbemBSTR(L"__TimerNextFiring"), 0, NULL, &pClass, NULL);
    if(FAILED(sc)) return sc;
    CReleaseMe rm0(pClass);

    IWbemClassObject* pInstance = NULL;
    sc = pClass->SpawnInstance(0, &pInstance);
    if(FAILED(sc)) return sc;
    CReleaseMe rm1(pInstance);

    // Set the timer id
    // ================

    VARIANT varID;
    V_VT(&varID) = VT_BSTR;
    V_BSTR(&varID) = SysAllocString(m_wsTimerId);
    if(V_BSTR(&varID) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    sc = pInstance->Put(L"TimerID", 0, &varID, 0);
    VariantClear(&varID);
    if(FAILED(sc)) 
        return sc;

    // Set the next firing time
    // ========================

    VARIANT varNext;
    V_VT(&varNext) = VT_BSTR;
    V_BSTR(&varNext) = SysAllocStringLen(NULL, 100);
    if(V_BSTR(&varNext) == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchPrintfW( V_BSTR(&varNext), 100, L"%I64d", When.Get100nss());
    sc = pInstance->Put(L"NextEvent64BitTime", 0, &varNext, 0);
    VariantClear(&varNext);
    if(FAILED(sc)) 
        return sc;

    //
    // Save the instance in the repository using an internal API
    //

    IWbemInternalServices* pIntServ = NULL;
    sc = m_pNamespace->QueryInterface(IID_IWbemInternalServices, 
                                        (void**)&pIntServ);
    if(FAILED(sc))
    {
        ERRORTRACE((LOG_ESS, "Unable to aquire internal services from core: "
                    "0x%X\n", sc));
        return sc;
    }
    CReleaseMe rm2(pIntServ);

    sc = pIntServ->InternalPutInstance(pInstance);
    return sc;
}

HRESULT CWBEMTimerInstruction::MarkForRemoval()
{
    CInCritSec incs(&mstatic_cs);
    m_bRemoved = TRUE;
    DWORD cLen = wcslen(m_wsTimerId)+100;
    LPWSTR wszPath = _new WCHAR[cLen];
    if(wszPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchPrintfW(wszPath, 
                     cLen, 
                     L"__TimerNextFiring=\"%S\"", 
                     (LPCWSTR)m_wsTimerId );

    HRESULT hres = m_pNamespace->DeleteInstance(CWbemBSTR(wszPath), 0, NULL, NULL);
    delete [] wszPath;
    return hres;
}







CWbemTime CAbsoluteTimerInstruction::ComputeFirstFiringTime() const
{
    return m_When;
}

CWbemTime CAbsoluteTimerInstruction::ComputeNextFiringTime(
                                               CWbemTime LastFiringTime) const
{
    return CWbemTime::GetInfinity();
}

// static
HRESULT CAbsoluteTimerInstruction::CheckObject(IWbemClassObject* pInst)
{
    //
    // Check if EventDateTime is actually a date, and not an interval
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    HRESULT hres = pInst->Get(L"EventDateTime", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_ILLEGAL_NULL;

    //
    // Check for * --- invalid
    //

    if(wcschr(V_BSTR(&v), L'*'))
        return WBEM_E_INVALID_PROPERTY;

    //
    // Check for ':' --- interval --- invalid
    //

    if(V_BSTR(&v)[21] == L':')
        return WBEM_E_INVALID_PROPERTY_TYPE;

    return WBEM_S_NO_ERROR;
}

HRESULT CAbsoluteTimerInstruction::LoadFromWbemObject(IWbemClassObject* pObject)
{
    VARIANT v;
    VariantInit(&v);

    HRESULT hres = pObject->Get(L"EventDateTime", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR) return WBEM_E_INVALID_OBJECT;

    BOOL bRes = m_When.SetDMTF(V_BSTR(&v));
    VariantClear(&v);
    return (bRes ? WBEM_S_NO_ERROR : WBEM_E_INVALID_OBJECT);
}

HRESULT CAbsoluteTimerInstruction::Fire(long lNumTimes, 
                                            CWbemTime NextFiringTime)
{
    // Fire it
    // =======

    HRESULT hres = CWBEMTimerInstruction::Fire(lNumTimes, NextFiringTime);

    {
        CInCritSec incs(&mstatic_cs);
        if(!m_bRemoved)
        {
            // Save the next firing time in WinMgmt
            // ====================================

            StoreNextFiring(NextFiringTime);
        }
    }
    return hres;
}

CWbemTime CIntervalTimerInstruction::ComputeFirstFiringTime() const
{
    if(!m_Start.IsZero())
        return m_Start;
    else
    {
        // Indicate that current time should be used
        return CWbemTime::GetCurrentTime() + m_Interval;
    }
}

CWbemTime CIntervalTimerInstruction::ComputeNextFiringTime(
                                               CWbemTime LastFiringTime) const
{
    if(m_Interval.IsZero()) 
    {
        return CWbemTime::GetInfinity();
    }
    return LastFiringTime + m_Interval;
}

HRESULT CIntervalTimerInstruction::LoadFromWbemObject(IWbemClassObject* pObject)
{
    VARIANT v;
    VariantInit(&v);

    HRESULT hres = pObject->Get(L"IntervalBetweenEvents", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;

    if(V_VT(&v) != VT_I4 || V_I4(&v) == 0)
        return WBEM_E_INVALID_OBJECT;
    m_Interval.SetMilliseconds(V_I4(&v));
    return S_OK;
}




CWinMgmtTimerGenerator::CWinMgmtTimerGenerator(CEss* pEss) : CTimerGenerator(),
        m_pEss(pEss)
{
}   


HRESULT CWinMgmtTimerGenerator::LoadTimerEventObject(
                                            LPCWSTR wszNamespace,
                                            IWbemServices* pNamespace, 
                                            IWbemClassObject * pInstObject,
                                            IWbemClassObject * pNextFiring)
{
    CWBEMTimerInstruction* pInst;
    CWbemTime When;
    HRESULT hres;

    hres = CWBEMTimerInstruction::LoadFromWbemObject(wszNamespace, pNamespace, 
                                                this, pInstObject, pInst);
    if(FAILED(hres)) return hres;

    if(pNextFiring)
    {
        VARIANT v;
        VariantInit(&v);

        pNextFiring->Get(L"NextEvent64BitTime", 0 ,&v, NULL, NULL);
        if(V_VT(&v) != VT_BSTR)
        {
            delete pInst;
            return WBEM_E_FAILED;
        }
        __int64 i64;
        swscanf(V_BSTR(&v), L"%I64d", &i64);
        VariantClear(&v);

        When.Set100nss(i64);

        //
        // Ask the instruction to determine what the real first firing time
        // should be, given the fact what it was planned to be before we shut 
        // down
        //

        When = pInst->GetStartingFiringTime(When);
    }
    else
    {
        When = CWbemTime::GetZero();
    }
   
    // Remove old
    // ==========

    VARIANT vID;
    VariantInit(&vID);
    hres = pInstObject->Get(TIMER_ID_PROPNAME, 0, &vID, NULL, NULL);
    if(FAILED(hres)) return hres;

    Remove(wszNamespace, V_BSTR(&vID));
    VariantClear(&vID);

    hres = Set(pInst, When);
    pInst->Release();
    return hres;
}

HRESULT CWinMgmtTimerGenerator::CheckTimerInstruction(IWbemClassObject* pInst)
{
    return CWBEMTimerInstruction::CheckObject(pInst);
}

HRESULT CWinMgmtTimerGenerator::LoadTimerEventObject(
                                            LPCWSTR wszNamespace,
                                            IWbemClassObject * pInstObject)
{
    IWbemServices* pNamespace;
    HRESULT hres = m_pEss->GetNamespacePointer(wszNamespace,TRUE,&pNamespace);
    if(FAILED(hres))
        return hres;

    hres = LoadTimerEventObject(wszNamespace, pNamespace, pInstObject);
    pNamespace->Release();
    return hres;
}

SCODE CWinMgmtTimerGenerator::LoadTimerEventQueue(LPCWSTR wszNamespace,
                                               IWbemServices* pNamespace)
{
    SCODE  sc;

    ULONG uRet;
    WCHAR  pwcsCount[4] = L"";
    int iInstanceCount = 1;

    IEnumWbemClassObject* pEnum;
    sc = pNamespace->CreateInstanceEnum(CWbemBSTR(L"__TimerInstruction"), 
                                           WBEM_FLAG_DEEP, NULL, 
                                           &pEnum);
    if(FAILED(sc)) return sc;

    while (1) 
    {
        IWbemClassObject* pInstruction;
        sc = pEnum->Next( WBEM_INFINITE, 1, &pInstruction, &uRet);
        if(FAILED(sc)) return sc;
        if(sc != WBEM_S_NO_ERROR)
            break;

        // Get the next firing object
        // ==========================

        VARIANT vID;
        VariantInit(&vID);
        sc = pInstruction->Get(L"TimerID", 0, &vID, NULL, NULL);
        if(FAILED(sc)) return sc;

        DWORD cLen = wcslen(V_BSTR(&vID)) + 100;
        LPWSTR wszPath = _new WCHAR[cLen];
        if(wszPath == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        StringCchPrintfW( wszPath, 
                          cLen,
                          L"__TimerNextFiring.TimerID=\"%s\"", 
                          V_BSTR(&vID) );
        VariantClear(&vID);

        IWbemClassObject* pNextFiring = 0;
        if(FAILED(pNamespace->GetObject(CWbemBSTR(wszPath), 0, NULL, &pNextFiring, NULL)))
        {
            pNextFiring = NULL;
        }
        delete [] wszPath;

        LoadTimerEventObject(wszNamespace, pNamespace, pInstruction,
                                pNextFiring);
        
        if(pNextFiring) pNextFiring->Release();
        pInstruction->Release();
    }


    pEnum->Release();
    return WBEM_S_NO_ERROR;
}

HRESULT CWinMgmtTimerGenerator::Remove(LPCWSTR wszNamespace, LPCWSTR wszId)
{
    CIdTest test(wszNamespace, wszId);
    return CTimerGenerator::Remove(&test);
}

BOOL CWinMgmtTimerGenerator::CIdTest::operator()(CTimerInstruction* pInst)
{
    if(pInst->GetInstructionType() != INSTTYPE_WBEM)
        return FALSE;
    CWBEMTimerInstruction* pWbemInst = (CWBEMTimerInstruction*)pInst;

    if(wcscmp(m_wszId, pWbemInst->GetTimerId()))
        return FALSE;

    if(wbem_wcsicmp(m_wszNamespace, pWbemInst->GetNamespace()))
        return FALSE;

    return TRUE;
}

HRESULT CWinMgmtTimerGenerator::Remove(LPCWSTR wszNamespace)
{
    CNamespaceTest test(wszNamespace);
    return CTimerGenerator::Remove(&test);
}

BOOL CWinMgmtTimerGenerator::CNamespaceTest::operator()(
                                                    CTimerInstruction* pInst)
{
    if(pInst->GetInstructionType() != INSTTYPE_WBEM)
        return FALSE;
    CWBEMTimerInstruction* pWbemInst = (CWBEMTimerInstruction*)pInst;

    if(wbem_wcsicmp(m_wszNamespace, pWbemInst->GetNamespace()))
        return FALSE;

    return TRUE;
}

HRESULT CWinMgmtTimerGenerator::FireInstruction(
                            CWBEMTimerInstruction* pInst, long lNumFirings)
{
    HRESULT hres;

    CEventRepresentation Event;
    Event.type = e_EventTypeTimer;
    Event.wsz1 = (LPWSTR)pInst->GetNamespace();
    Event.wsz2 = (LPWSTR)pInst->GetTimerId();
    Event.wsz3 = NULL;
    Event.dw1 = (DWORD)lNumFirings;

    // Create the actual IWbemClassObject representing the event 
    // ========================================================

    Event.nObjects = 1;
    Event.apObjects = _new IWbemClassObject*[1];
    if(Event.apObjects == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<IWbemClassObject*> vdm1(Event.apObjects);

    IWbemClassObject* pClass = // internal
        CEventRepresentation::GetEventClass(m_pEss, e_EventTypeTimer);
    if(pClass == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = pClass->SpawnInstance(0, &(Event.apObjects[0]));
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(Event.apObjects[0]);

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pInst->GetTimerId());
    if(V_BSTR(&v) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = Event.apObjects[0]->Put(L"TimerId", 0, &v, 0);
    VariantClear(&v);
    if(FAILED(hres))
        return hres;

    V_VT(&v) = VT_I4;
    V_I4(&v) = lNumFirings;
    hres = Event.apObjects[0]->Put(L"NumFirings", 0, &v, 0);
    VariantClear(&v);
    if(FAILED(hres))
        return hres;

    // Decorate it
    // ===========

    hres = m_pEss->DecorateObject(Event.apObjects[0], pInst->GetNamespace());
    if(FAILED(hres))
        return hres;

    // Give it to the ESS
    // ==================

    hres = m_pEss->ProcessEvent(Event, 0);
    
    // ignore error

    return WBEM_S_NO_ERROR;
}

HRESULT CWinMgmtTimerGenerator::Shutdown()
{
    // Get the base class to shut everything down
    // ==========================================

    HRESULT hres = CTimerGenerator::Shutdown();

    hres = SaveAndRemove((LONG)FALSE);
    return hres;
}

HRESULT CWinMgmtTimerGenerator::SaveAndRemove(LONG lIsSystemShutDown)
{
    // Store next firing times for all the instructions in the list
    // ============================================================

    CTimerInstruction* pInst;
    CWbemTime NextTime;
    while(m_Queue.Dequeue(pInst, NextTime) == S_OK)
    {
        // Convert to the right class
        // ==========================

        if(pInst->GetInstructionType() == INSTTYPE_WBEM)
        {
            CWBEMTimerInstruction* pWbemInst = (CWBEMTimerInstruction*)pInst;
            pWbemInst->StoreNextFiring(NextTime);
        }
        if (!lIsSystemShutDown)
        {
            pInst->Release();
        }
    }

    return S_OK;
}


void CWinMgmtTimerGenerator::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d timer instructions in queue\n", 
                m_Queue.GetNumInstructions());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\analyser.h ===
//******************************************************************************
//
//  ANALYSER.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_ANALYSER__H_
#define __WBEM_ANALYSER__H_

#include "esscpol.h"
#include <stdio.h>
#include "wbemidl.h"
#include "wbemcomn.h"
#include "parmdefs.h"
#include "ql.h"
#include "eventrep.h"
#include "evaltree.h"

struct ESSCLI_POLARITY CClassInformation
{
    IWbemClassObject* m_pClass;
    LPWSTR m_wszClassName;
    BOOL m_bIncludeChildren;
    DWORD m_dwEventMask;
public:
    CClassInformation()
    {
        m_wszClassName = NULL;
        m_pClass = NULL;
    }
    CClassInformation(const CClassInformation& Other)
    {
        m_wszClassName = CloneWstr(Other.m_wszClassName);
        if (!m_wszClassName)
        	throw CX_MemoryException();
        m_pClass = Other.m_pClass;
        if(m_pClass) m_pClass->AddRef();        
        m_bIncludeChildren = Other.m_bIncludeChildren;
        m_dwEventMask = Other.m_dwEventMask;
    }

    ~CClassInformation()
    {
        delete [] m_wszClassName;
        if(m_pClass) m_pClass->Release();
    }
};

class ESSCLI_POLARITY CClassInfoArray
{
protected:
    BOOL m_bLimited;
    CUniquePointerArray<CClassInformation>* m_pClasses;

public:
    CClassInfoArray();
    ~CClassInfoArray(); 
    BOOL IsLimited() {return m_bLimited;}
    int GetNumClasses() {return m_pClasses->GetSize();}
    INTERNAL CClassInformation* GetClass(int nIndex) 
     {return (*m_pClasses)[nIndex]; }

    void SetLimited(BOOL bLimited) {m_bLimited = bLimited;}
    bool operator=(CClassInfoArray& Other);
    bool SetOne(LPCWSTR wszClass, BOOL bIncludeChildren);
    void Clear() {m_bLimited = FALSE; m_pClasses->RemoveAll();}
    bool AddClass(ACQUIRE CClassInformation* pInfo) 
        {return m_pClasses->Add(pInfo) >= 0;}
    void RemoveClass(int nIndex) {m_pClasses->RemoveAt(nIndex);}
};

class ESSCLI_POLARITY CQueryAnalyser
{
public:
    static HRESULT GetPossibleInstanceClasses(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                              CClassInfoArray*& paInfos);
    static HRESULT GetDefiniteInstanceClasses(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                              CClassInfoArray*& paInfos);
    static HRESULT GetLimitingQueryForInstanceClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       OUT LPWSTR& wszQuery);
    static HRESULT GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
    static HRESULT GetNecessaryQueryForClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IWbemClassObject* pClass,
                                       CWStringArray& awsOverriden,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
    static BOOL CompareRequestedToProvided(
                    CClassInfoArray& aRequestedInstanceClasses,
                    CClassInfoArray& aProvidedInstanceClasses);

    static HRESULT SimplifyQueryForChild(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            LPCWSTR wszClassName, IWbemClassObject* pClass,
                            CContextMetaData* pMeta,
                            DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
    static HRESULT CanPointToClass(IWbemClassObject* pRefClass, 
                    LPCWSTR wszPropName, LPCWSTR wszTargetClassName,
                    CContextMetaData* pMeta);
protected:
    enum 
    {
        e_Keep, e_True, e_False, e_Invalid
    };
    static HRESULT GetInstanceClasses(QL_LEVEL_1_TOKEN& Token, 
                                              CClassInfoArray& aInfos);
    static HRESULT AndPossibleClassArrays(IN CClassInfoArray* paFirst, 
                                 IN CClassInfoArray* paSecond, 
                                 OUT CClassInfoArray* paNew);
    static HRESULT OrPossibleClassArrays(IN CClassInfoArray* paFirst, 
                                IN CClassInfoArray* paSecond, 
                                OUT CClassInfoArray* paNew);
    static HRESULT NegatePossibleClassArray(IN CClassInfoArray* paOrig, 
                                   OUT CClassInfoArray* paNew);
    static HRESULT AndDefiniteClassArrays(IN CClassInfoArray* paFirst, 
                                 IN CClassInfoArray* paSecond, 
                                 OUT CClassInfoArray* paNew);
    static HRESULT OrDefiniteClassArrays(IN CClassInfoArray* paFirst, 
                                IN CClassInfoArray* paSecond, 
                                OUT CClassInfoArray* paNew);
    static HRESULT NegateDefiniteClassArray(IN CClassInfoArray* paOrig, 
                                   OUT CClassInfoArray* paNew);
    static BOOL IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName);
    static void AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource);
    static HRESULT AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT NegateQueryExpression(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            OUT QL_LEVEL_1_RPN_EXPRESSION* pNewExpr);
    static int SimplifyTokenForChild(QL_LEVEL_1_TOKEN& Token, 
                            LPCWSTR wszClass, IWbemClassObject* pClass, 
                            CContextMetaData* pMeta);
    static BOOL ValidateSQLDateTime(LPCWSTR wszDateTime);
    static HRESULT GetPropertiesThatMustDiffer(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       CWStringArray& wsProperties);
    static BOOL IsTokenAboutClass(QL_LEVEL_1_TOKEN& Token,
                        IWbemClassObject* pClass,
                        CWStringArray& awsOverriden);
    static BOOL IsPropertyInClass(CPropertyName& Prop,
                        IWbemClassObject* pClass, 
                        CWStringArray& awsOverriden);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\analyser.cpp ===
//******************************************************************************
//
//  ANALYSER.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include "pragmas.h"
#include "analyser.h"
#include <stack>
#include <strutils.h>
#include <objpath.h>
#include <fastval.h>
#include <genutils.h>
#include <datetimeparser.h>
#include "CWbemTime.h"
#include <wstlallc.h>

CClassInfoArray::CClassInfoArray()
    : m_bLimited( FALSE )
{
    m_pClasses = new CUniquePointerArray<CClassInformation>;

    if ( m_pClasses )
    {
        m_pClasses->RemoveAll();
    }
}

CClassInfoArray::~CClassInfoArray()
{
    delete m_pClasses;
}

bool CClassInfoArray::operator=(CClassInfoArray& Other)
{
    SetLimited(Other.IsLimited());
    m_pClasses->RemoveAll();

    for(int i = 0; i < Other.m_pClasses->GetSize(); i++)
    {
        CClassInformation* pInfo = new CClassInformation(*(*Other.m_pClasses)[i]);
        if(pInfo == NULL)
            return false;

        m_pClasses->Add(pInfo);
    }
    return true;
}

bool CClassInfoArray::SetOne(LPCWSTR wszClass, BOOL bIncludeChildren)
{
    CClassInformation* pNewInfo = _new CClassInformation;
    if(pNewInfo == NULL)
        return false;

    pNewInfo->m_wszClassName = CloneWstr(wszClass);
    if(pNewInfo->m_wszClassName == NULL)
    {
        delete pNewInfo;
        return false;
    }
    pNewInfo->m_bIncludeChildren = bIncludeChildren;

    m_pClasses->RemoveAll();
    m_pClasses->Add(pNewInfo);
    SetLimited(TRUE);
    return true;
}

HRESULT CQueryAnalyser::GetPossibleInstanceClasses(
                                       QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       CClassInfoArray*& paInfos)
{
    // Organize a stack of classinfo arrays
    // ====================================

    std::stack<CClassInfoArray*,std::deque<CClassInfoArray*,wbem_allocator<CClassInfoArray*> > > InfoStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        paInfos = _new CClassInfoArray;
        if(paInfos == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        paInfos->SetLimited(FALSE);
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        CClassInfoArray* paNew = _new CClassInfoArray;
        if(paNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CClassInfoArray* paFirst;
        CClassInfoArray* paSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            hres = GetInstanceClasses(Token, *paNew);
            InfoStack.push(paNew);
            break;

        case QL1_AND:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = AndPossibleClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_OR:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = OrPossibleClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_NOT:
            if(InfoStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();

            hres = NegatePossibleClassArray(paFirst, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete paNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && InfoStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!InfoStack.empty())
        {
            delete InfoStack.top();
            InfoStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    paInfos = InfoStack.top();
    return S_OK;
}

HRESULT CQueryAnalyser::AndPossibleClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // For now, simply pick one
    // ========================

    if(paFirst->IsLimited())
        *paNew = *paFirst;
    else
        *paNew = *paSecond;

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrPossibleClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // Append them together
    // ====================

    paNew->Clear();

    if(paFirst->IsLimited() && paSecond->IsLimited())
    {
        paNew->SetLimited(TRUE);
        for(int i = 0; i < paFirst->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paFirst->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        for(i = 0; i < paSecond->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paSecond->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::NegatePossibleClassArray(IN CClassInfoArray* paOrig,
                                        OUT CClassInfoArray* paNew)
{
    // No information!
    // ===============

    paNew->Clear();

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetDefiniteInstanceClasses(
                                       QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       CClassInfoArray*& paInfos)
{
    // Organize a stack of classinfo arrays
    // ====================================

    std::stack<CClassInfoArray*, std::deque<CClassInfoArray*,wbem_allocator<CClassInfoArray*> > > InfoStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        paInfos = _new CClassInfoArray;
        if(paInfos == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        paInfos->SetLimited(FALSE);
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        CClassInfoArray* paNew = _new CClassInfoArray;
        if(paNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        CClassInfoArray* paFirst;
        CClassInfoArray* paSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            hres = GetInstanceClasses(Token, *paNew);
            InfoStack.push(paNew);
            break;

        case QL1_AND:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = AndDefiniteClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_OR:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = OrDefiniteClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_NOT:
            if(InfoStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();

            hres = NegateDefiniteClassArray(paFirst, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete paNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && InfoStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!InfoStack.empty())
        {
            delete InfoStack.top();
            InfoStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    paInfos = InfoStack.top();
    return S_OK;
}

HRESULT CQueryAnalyser::AndDefiniteClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // Nothing is definite if both conditions have to hold
    // ===================================================

    paNew->Clear();
    paNew->SetLimited(TRUE);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrDefiniteClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // Append them together
    // ====================

    paNew->Clear();

    if(paFirst->IsLimited() && paSecond->IsLimited())
    {
        paNew->SetLimited(TRUE);
        for(int i = 0; i < paFirst->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paFirst->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        for(i = 0; i < paSecond->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paSecond->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::NegateDefiniteClassArray(IN CClassInfoArray* paOrig,
                                        OUT CClassInfoArray* paNew)
{
    // No information
    // ==============

    paNew->Clear();
    paNew->SetLimited(TRUE);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetInstanceClasses(QL_LEVEL_1_TOKEN& Token,
                                         CClassInfoArray& aInfos)
{
    // Preset aInfos to the "no information" value
    // ===========================================

    aInfos.Clear();

    // See if this token talks about TargetInstance or PreviousInstance
    // ================================================================

    if(Token.PropertyName.GetNumElements() < 1)
        return WBEM_S_NO_ERROR;

    LPCWSTR wszPrimaryName = Token.PropertyName.GetStringAt(0);
    if(wszPrimaryName == NULL ||
        (wbem_wcsicmp(wszPrimaryName, TARGET_INSTANCE_PROPNAME) &&
         wbem_wcsicmp(wszPrimaryName, PREVIOUS_INSTANCE_PROPNAME))
      )
    {
        // This token is irrelevant
        // =========================

        return WBEM_S_NO_ERROR;
    }

    // TargetInstance or PreviousInstance is found
    // ===========================================

    if(Token.PropertyName.GetNumElements() == 1)
    {
        // It's "TargetInstance <op> <const>" : look for ISA
        // =================================================

        if(Token.nOperator == QL1_OPERATOR_ISA &&
            V_VT(&Token.vConstValue) == VT_BSTR)
        {
            // Of this class; children included
            // ================================

            if(!aInfos.SetOne(V_BSTR(&Token.vConstValue), TRUE))
                return WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            // No information
            // ==============
        }

        return WBEM_S_NO_ERROR;
    }

    if(Token.PropertyName.GetNumElements() > 2)
    {
        // X.Y.Z --- too deep to be useful
        // ===============================

        return WBEM_S_NO_ERROR;
    }

    // It's "TargetInstance.X <op> <const>" : look for __CLASS
    // =======================================================

    LPCWSTR wszSecondaryName = Token.PropertyName.GetStringAt(1);
    if(wszSecondaryName == NULL || wbem_wcsicmp(wszSecondaryName, L"__CLASS"))
    {
        // Not __CLASS --- not useful
        // ==========================

        return WBEM_S_NO_ERROR;
    }
    else
    {
        // __CLASS --- check that the operator is =
        // ========================================

        if(Token.nOperator == QL1_OPERATOR_EQUALS &&
            V_VT(&Token.vConstValue) == VT_BSTR)
        {
            // Of this class -- children not included
            // ======================================

            if(!aInfos.SetOne(V_BSTR(&Token.vConstValue), FALSE))
                return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_NO_ERROR;
    }
}

HRESULT CQueryAnalyser::GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutProperty(Token, PropName))
            {
                pNew->AddToken(Token);
            }
            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();
    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName)
{
    CPropertyName& TokenPropName = Token.PropertyName;

    if(PropName.GetNumElements() != TokenPropName.GetNumElements())
        return FALSE;

    for(int i = 0; i < PropName.GetNumElements(); i++)
    {
        LPCWSTR wszPropElement = PropName.GetStringAt(i);
        LPCWSTR wszTokenElement = TokenPropName.GetStringAt(i);

        if(wszPropElement == NULL || wszTokenElement == NULL)
            return FALSE;

        if(wbem_wcsicmp(wszPropElement, wszTokenElement))
            return FALSE;
    }

    return TRUE;
}

void CQueryAnalyser::AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        pDest->AddToken(pSource->pArrayOfTokens[i]);
    }
}

HRESULT CQueryAnalyser::AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If either one is NULL (false), the result is NULL
    // =================================================

    if(pFirst == NULL || pSecond == NULL)
        return WBEM_S_FALSE;

    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_AND;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If both are NULL (false) so is the result
    // =========================================

    if(pFirst == NULL && pSecond == NULL)
        return WBEM_S_FALSE;

    // If one is NULL (false) return the other
    // =======================================

    if(pFirst == NULL)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond == NULL)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // If either one is empty, so is the result
    // ========================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- or together
    // ==============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_OR;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetPropertiesThatMustDiffer(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       CWStringArray& awsProperties)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //
    // "Evaluate" the query, looking for
    // PreviousInstance.Prop != TargetInstance.Prop expressions
    //

    awsProperties.Empty();
    std::stack<CWStringArray*, std::deque<CWStringArray*,wbem_allocator<CWStringArray*> > > PropArrayStack;

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        CWStringArray* pNew = NULL;
        CWStringArray* pFirst = NULL;
        CWStringArray* pSecond = NULL;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            //
            // Check if this token conforms to the
            // PreviousInstance.Prop != TargetInstance.Prop format
            //

            if(Token.m_bPropComp &&
                (Token.nOperator == QL1_OPERATOR_NOTEQUALS ||
                 Token.nOperator == QL1_OPERATOR_LESS ||
                 Token.nOperator == QL1_OPERATOR_GREATER) &&
                Token.PropertyName.GetNumElements() == 2 &&
                Token.PropertyName2.GetNumElements() == 2)
            {
                //
                // Make sure that one of them is talking about TargetInstance,
                // and another about PreviousInstance.
                //

                bool bRightForm = false;
                if(!wbem_wcsicmp(Token.PropertyName.GetStringAt(0),
                                L"TargetInstance") &&
                   !wbem_wcsicmp(Token.PropertyName2.GetStringAt(0),
                                L"PreviousInstance"))
                {
                    bRightForm = true;
                }

                if(!wbem_wcsicmp(Token.PropertyName.GetStringAt(0),
                                L"PreviousInstance") &&
                   !wbem_wcsicmp(Token.PropertyName2.GetStringAt(0),
                                L"TargetInstance"))
                {
                    bRightForm = true;
                }

                if(bRightForm)
                {
                    pNew = new CWStringArray;
                    if(pNew == NULL)
                        return WBEM_E_OUT_OF_MEMORY;

                    pNew->Add(Token.PropertyName.GetStringAt(1));
                }
            }

            PropArrayStack.push(pNew);
            break;

        case QL1_AND:
            if(PropArrayStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = PropArrayStack.top(); PropArrayStack.pop();
            pSecond = PropArrayStack.top(); PropArrayStack.pop();

            //
            // If either one of them is non-NULL, take either --- since every
            // array means "no unless one of these properties is different",
            // adding them together is at least as good as having one
            //

            if(pFirst)
            {
                pNew = pFirst;
                delete pSecond;
            }
            else
                pNew = pSecond;

            PropArrayStack.push(pNew);
            break;

        case QL1_OR:
            if(PropArrayStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = PropArrayStack.top(); PropArrayStack.pop();
            pSecond = PropArrayStack.top(); PropArrayStack.pop();

            //
            // Concatenate them --- since every
            // array means "no unless one of these properties is different",
            // oring them together means "no unless one of the properties in
            // either list is different".  If one is NULL, though, then we know
            // nothing
            //

            if(pFirst && pSecond)
            {
                pNew = new CWStringArray;
                if(pNew == NULL)
                    return WBEM_E_OUT_OF_MEMORY;

                CWStringArray::Union(*pFirst, *pSecond, *pNew);
            }

            PropArrayStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(PropArrayStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = PropArrayStack.top(); PropArrayStack.pop();

            // No information

            PropArrayStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if( SUCCEEDED(hres))
    {
        if( PropArrayStack.size() > 0 && PropArrayStack.top() )
            awsProperties = *PropArrayStack.top();
        else
            return WBEM_S_FALSE;
    }

    while(!PropArrayStack.empty())
    {
        delete PropArrayStack.top();
        PropArrayStack.pop();
    }

    return hres;
}

HRESULT CQueryAnalyser::GetLimitingQueryForInstanceClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       OUT DELETE_ME LPWSTR& wszQuery)
{
    HRESULT hres;

    //
    // "Evaluate" the query, looking for keys and other properties that do not
    // change over the life time of an instance (marked as [fixed]).  The idea
    // here is that if an instance creation/deletion/modification subscription
    // is issue and we need to poll, we can only utilize the parts of the WHERE
    // clause that talk about the properties that cannot change during the life
    // of an instance.  Otherwise, we will not be able to tell if an instance
    // changed or was created or deleted (when it walks in or out of our polling
    // results.
    //
    // The way we know that a property is such is if it is marked as [key], or
    // if it is marked as [fixed] --- the designation by the schema creator that
    // the property never changes.
    //

    //
    // Construct an array of all those property names
    //

    _IWmiObject* pClass = NULL;
    hres = Info.m_pClass->QueryInterface(IID__IWmiObject, (void**)&pClass);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;
    CReleaseMe rm1(pClass);


    CWStringArray awsFixed;
    hres = pClass->BeginEnumeration(0);
    if(FAILED(hres))
        return hres;

    BSTR strPropName = NULL;
    while((hres = pClass->Next(0, &strPropName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strPropName);

        //  
        // Check qualifiers
        //

        DWORD dwSize;
        hres = pClass->GetPropQual(strPropName, L"key", 0, 0, NULL, 
                                    NULL, &dwSize, NULL);
        if(SUCCEEDED(hres) ||  hres == WBEM_E_BUFFER_TOO_SMALL)
        {
            awsFixed.Add(strPropName);
        }
        else if(hres != WBEM_E_NOT_FOUND)
        {
            return hres;
        }

        hres = pClass->GetPropQual(strPropName, L"fixed", 0, 0, NULL, 
                                    NULL, &dwSize, NULL);
        if(SUCCEEDED(hres) ||  hres == WBEM_E_BUFFER_TOO_SMALL)
        {
            awsFixed.Add(strPropName);
        }
        else if(hres != WBEM_E_NOT_FOUND)
        {
            return hres;
        }
    }

    pClass->EndEnumeration();
    if(FAILED(hres))
        return hres;
        
    //
    // Now "evaluate" the query
    // 

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(Token.PropertyName.GetNumElements() > 1 &&
                awsFixed.FindStr(Token.PropertyName.GetStringAt(1),
                           CWStringArray::no_case) != CWStringArray::not_found)
            {
                //
                // This token is about a fixed property --- we can keep it
                //

                QL_LEVEL_1_TOKEN NewToken = Token;
                NewToken.PropertyName.Empty();
                NewToken.PropertyName.AddElement(
                                            Token.PropertyName.GetStringAt(1));
                pNew->AddToken(NewToken);
            }
            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(FAILED(hres))
    {
        //
        // An error occurred. Clear the stack
        //

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    QL_LEVEL_1_RPN_EXPRESSION* pNewExpr = NULL;
    if(ExprStack.size() != 0)
    {
        pNewExpr = ExprStack.top();
    }
    else
    {
        pNewExpr = new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm1(pNewExpr);

    //
    // Figure out the list of property names
    //

    bool bMayLimit;
    if(pExpr->bStar)
    {
        bMayLimit = false;
    }
    else if(wbem_wcsicmp(pExpr->bsClassName, L"__InstanceCreationEvent") &&
           wbem_wcsicmp(pExpr->bsClassName, L"__InstanceDeletionEvent"))
    {
        //
        // Instance modification events are included.  That means we need
        // to get enough properties from the provider to be able to compare
        // instances for changes. Check if this list is smaller than
        // everything
        //

        CWStringArray awsProperties;
        hres = GetPropertiesThatMustDiffer(pExpr, Info, awsProperties);
        if(hres == S_OK)
        {
            //
            // Got our list --- add it to the properties to get
            //

            for(int i = 0; i < awsProperties.Size(); i++)
            {
                CPropertyName NewProp;
                NewProp.AddElement(awsProperties[i]);
                pNewExpr->AddProperty(NewProp);
            }
            bMayLimit = true;
        }
        else
            bMayLimit = false;
    }
    else
    {
        //
        // No * in select and no modification events asked for --- limit
        //

        bMayLimit = true;
    }

    if(bMayLimit)
    {
        //
        // Add RELPATH and DERIVATION, for without them filtering is hard
        //

        CPropertyName NewProp;
        NewProp.AddElement(L"__RELPATH");
        pNewExpr->AddProperty(NewProp);

        NewProp.Empty();
        NewProp.AddElement(L"__DERIVATION");
        pNewExpr->AddProperty(NewProp);

        //
        // Add all the proeperties from the select clause, with
        // TargetInstance and PreviousInstance removed
        //

        for(int i = 0; i < pExpr->nNumberOfProperties; i++)
        {
            CPropertyName& Prop = pExpr->pRequestedPropertyNames[i];
            if(Prop.GetNumElements() > 1)
            {
                //
                // Embedded object property --- add it to the list
                //

                CPropertyName LocalProp;
                LocalProp.AddElement(Prop.GetStringAt(1));
                pNewExpr->AddProperty(LocalProp);
            }
        }

        //
        // Add all the properties from the where clause, on both sides of
        // the comparison
        //

        for(i = 0; i < pExpr->nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
            CPropertyName& Prop = Token.PropertyName;
            if(Prop.GetNumElements() > 1)
            {
                //
                // Embedded object property --- add it to the list
                //

                CPropertyName LocalProp;
                LocalProp.AddElement(Prop.GetStringAt(1));
                pNewExpr->AddProperty(LocalProp);
            }
            if(Token.m_bPropComp)
            {
                CPropertyName& Prop2 = Token.PropertyName2;
                if(Prop2.GetNumElements() > 1)
                {
                    //
                    // Embedded object property --- add it to the list
                    //

                    CPropertyName LocalProp;
                    LocalProp.AddElement(Prop2.GetStringAt(1));
                    pNewExpr->AddProperty(LocalProp);
                }
            }
        }
    }
    else
    {
        //
        // May not limit the set of properties to ask for
        //

        pNewExpr->bStar = TRUE;
    }

    //
    // Set the class name
    //

    pNewExpr->SetClassName(Info.m_wszClassName);

    //
    // Produce the text
    //

    wszQuery = pNewExpr->GetText();
    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}

BOOL CQueryAnalyser::CompareRequestedToProvided(
                    CClassInfoArray& aRequestedInstanceClasses,
                    CClassInfoArray& aProvidedInstanceClasses)
{
    if(!aRequestedInstanceClasses.IsLimited() ||
       !aProvidedInstanceClasses.IsLimited())
    {
        // Provided provides all or client wants all --- they intersect.
        // =============================================================

        return TRUE;
    }

    for(int nReqIndex = 0;
        nReqIndex < aRequestedInstanceClasses.GetNumClasses();
        nReqIndex++)
    {
        CClassInformation* pRequestedClass =
            aRequestedInstanceClasses.GetClass(nReqIndex);
        LPWSTR wszRequestedClass = pRequestedClass->m_wszClassName;

        for(int nProvIndex = 0;
            nProvIndex < aProvidedInstanceClasses.GetNumClasses();
            nProvIndex++)
        {
            // Check if this provided class is derived from the requested one
            // ==============================================================

            CClassInformation* pProvClass =
                aProvidedInstanceClasses.GetClass(nProvIndex);

            if(pProvClass->m_pClass != NULL &&
                (pProvClass->m_pClass->InheritsFrom(pRequestedClass->m_wszClassName) == S_OK ||
                 pRequestedClass->m_pClass->InheritsFrom(pProvClass->m_wszClassName) == S_OK)
                )
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

HRESULT CQueryAnalyser::NegateQueryExpression(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            OUT QL_LEVEL_1_RPN_EXPRESSION* pNewExpr)
{
    if(pExpr == NULL)
    {
        // pNewExpr is empty --- true
        return WBEM_S_NO_ERROR;
    }

    if(pExpr->nNumTokens == 0)
    {
        return WBEM_S_FALSE;
    }

    AppendQueryExpression(pNewExpr, pExpr);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_NOT;
    pNewExpr->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::SimplifyQueryForChild(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            LPCWSTR wszClassName, IWbemClassObject* pClass,
                            CContextMetaData* pMeta,
                            DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;
        int nDisposition;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            nDisposition = SimplifyTokenForChild(Token, wszClassName, pClass,
                                                        pMeta);
            if(nDisposition == e_Keep)
            {
                pNew->AddToken(Token);
            }
            else if(nDisposition == e_True)
            {
            }
            else if(nDisposition == e_False)
            {
                delete pNew;
                pNew = NULL;
            }
            else
            {
                // the whole thing is invalid
                hres = WBEM_E_INVALID_QUERY;
                delete pNew;
                break;
            }

            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);
            if(hres != S_OK)
            {
                delete pNew;
                pNew = NULL;
            }

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);
            if(hres != S_OK)
            {
                delete pNew;
                pNew = NULL;
            }

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }

            pFirst = ExprStack.top();  ExprStack.pop();
            hres = NegateQueryExpression(pFirst, pNew);
            if(hres != S_OK)
            {
                delete pNew;
                pNew = NULL;
            }

            ExprStack.push(pNew);
            delete pFirst;

            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();

    return S_OK;
}

int CQueryAnalyser::SimplifyTokenForChild(QL_LEVEL_1_TOKEN& Token,
                            LPCWSTR wszClassName, IWbemClassObject* pClass,
                            CContextMetaData* pMeta)
{
    HRESULT hres;

    //
    // Check if the main property exists
    //

    CIMTYPE ct;
    hres = pClass->Get((LPWSTR)Token.PropertyName.GetStringAt(0), 0, NULL,
                        &ct, NULL);
    if(FAILED(hres))
    {
        return e_Invalid;
    }

    //
    // Check if it is complex
    //

    if(Token.PropertyName.GetNumElements() > 1 && ct != CIM_OBJECT)
        return e_Invalid;

    //
    // Check if it's an array
    //
    if(ct & CIM_FLAG_ARRAY)
        return e_Invalid;

    //
    // If a CIM DateTime type, normalize it to have a zero UTC offset. Helps
    // providers to cope.
    //
    if (ct == CIM_DATETIME && Token.m_bPropComp == FALSE && V_VT(&Token.vConstValue) == VT_BSTR)
    {
        BSTR strSource = V_BSTR(&Token.vConstValue);
        if (strSource && wcslen(strSource))
        {
            BSTR strAdjusted = 0;
            BOOL bRes = NormalizeCimDateTime(strSource, &strAdjusted);
            if (bRes)
            {
                SysFreeString(strSource);
                V_BSTR(&Token.vConstValue) = strAdjusted;
            }
        }
    }

    //
    // Check operator validity for this type
    //

    //
    // Ensure that only valid operators are applied to boolean props.
    //

    if(ct == CIM_BOOLEAN && (Token.nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL &&
                             Token.nOperator != QL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
        return e_Invalid;

    //
    // Ensure that only valid operators are applied to reference props.
    //

    if(ct == CIM_REFERENCE && (Token.nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL &&
                             Token.nOperator != QL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
        return e_Invalid;

    if(Token.m_bPropComp)
    {
        //
        // Check if the other property exists
        //

        CIMTYPE ct2;
        hres = pClass->Get((LPWSTR)Token.PropertyName2.GetStringAt(0), 0, NULL,
                            &ct2, NULL);
        if(FAILED(hres))
        {
            return e_Invalid;
        }

        //
        // Check if it is complex
        //

        if(Token.PropertyName2.GetNumElements() > 1 && ct2 != CIM_OBJECT)
            return e_Invalid;

        //
        // Check if it's an array
        //

        if(ct2 & CIM_FLAG_ARRAY)
            return e_Invalid;

        //
        // Nothing else to say about prop-to-ptop
        //

        return e_Keep;
    }

    //
    // Check if the value is NULL
    //

    if(V_VT(&Token.vConstValue) == VT_NULL)
    {
        if(Token.nOperator != QL1_OPERATOR_EQUALS &&
                Token.nOperator != QL1_OPERATOR_NOTEQUALS)
        {
            return e_Invalid;
        }
        else
        {
            return e_Keep;
        }
    }

    if(ct == CIM_OBJECT)
        return e_Keep;

    // For boolean props ensure that only 1 or 0 or (-1, 0xFFFF [VARIANT_TRUE])
    // are used as numeric tests.
    // ========================================================================

    if (ct == CIM_BOOLEAN && V_VT(&Token.vConstValue) == VT_I4)
    {
        int n = V_I4(&Token.vConstValue);
        if (n != 0 && n != 1 && n != -1 && n != 0xFFFF)
            return e_Invalid;
    }


    //
    // If the constant is a real and the target is an integer, then fail the
    // query
    //

    if((V_VT(&Token.vConstValue) == VT_R8 || V_VT(&Token.vConstValue) == VT_R4 ) &&
        (ct == CIM_CHAR16 || ct == CIM_UINT8 || ct == CIM_SINT8 ||
         ct == CIM_UINT16 || ct == CIM_SINT16 || ct == CIM_UINT32 ||
         ct == CIM_SINT32 || ct == CIM_UINT64 || ct == CIM_SINT64))
        return e_Invalid;

    // Convert the constant to the right type
    // ======================================

    if(ct == CIM_CHAR16 && V_VT(&Token.vConstValue) == VT_BSTR)
    {
        BSTR str = V_BSTR(&Token.vConstValue);
        if(wcslen(str) != 1)
            return e_Invalid;

        return e_Keep;
    }

    VARTYPE vt = CType::GetVARTYPE(ct);
    if(ct == CIM_UINT32)
        vt = CIM_STRING;

    if(FAILED(VariantChangeType(&Token.vConstValue, &Token.vConstValue, 0, vt)))
    {
        return e_Invalid;
    }

    // Verify ranges
    // =============

    __int64 i64;
    unsigned __int64 ui64;

    switch(ct)
    {
    case CIM_UINT8:
        break;
    case CIM_SINT8:
        if(V_I2(&Token.vConstValue) < -128 || V_I2(&Token.vConstValue) > 127)
            return e_Invalid;
        break;
    case CIM_UINT16:
        if(V_I4(&Token.vConstValue) < 0 || V_I4(&Token.vConstValue) >= 1<<16)
            return e_Invalid;
        break;
    case CIM_SINT16:
        break;
    case CIM_SINT32:
        break;
    case CIM_UINT32:
        if(!ReadI64(V_BSTR(&Token.vConstValue), i64))
            return e_Invalid;
        if(i64 < 0 || i64 >= (__int64)1 << 32)
            return e_Invalid;
        break;
    case CIM_UINT64:
        if(!ReadUI64(V_BSTR(&Token.vConstValue), ui64))
            return e_Invalid;
        break;
    case CIM_SINT64:
        if(!ReadI64(V_BSTR(&Token.vConstValue), i64))
            return e_Invalid;
        break;
    case CIM_REAL32:
    case CIM_REAL64:
        break;
    case CIM_STRING:
        break;
    case CIM_DATETIME:
        if(!ValidateSQLDateTime(V_BSTR(&Token.vConstValue)))
            return e_Invalid;
    case CIM_REFERENCE:
        break;
    }

    // Check if it is a reference
    // ==========================

    if(ct != CIM_REFERENCE)
        return e_Keep;

    // Reference. Parse the path in the value
    // ======================================

    if(V_VT(&Token.vConstValue) != VT_BSTR)
        return e_Keep;

    CObjectPathParser Parser;
    ParsedObjectPath* pOutput = NULL;
    int nRes = Parser.Parse(V_BSTR(&Token.vConstValue), &pOutput);
    if(nRes != CObjectPathParser::NoError)
        return e_Invalid;

    WString wsPathClassName = pOutput->m_pClass;
    BOOL bInstance = (pOutput->m_bSingletonObj || pOutput->m_dwNumKeys != 0);

    // TBD: analyse the path for validity

    delete pOutput;

    hres = CanPointToClass(pClass, (LPWSTR)Token.PropertyName.GetStringAt(0),
                            wsPathClassName, pMeta);
    if(FAILED(hres))
        return e_Invalid;
    else if(hres == WBEM_S_NO_ERROR)
        return e_Keep;
    else
    {
        // Equality can never be achieved. The token is either always true,
        // or always false, depending on the operator

        if(Token.nOperator == QL1_OPERATOR_EQUALS)
            return e_False;
        else
            return e_True;
    }
}

BOOL CQueryAnalyser::ValidateSQLDateTime(LPCWSTR wszDateTime)
{
#ifndef UNICODE
    size_t cchBuffer = wcslen(wszDateTime)*4+1;
    char* szBuffer = new char[cchBuffer];
    if(szBuffer == NULL)
        return FALSE;
    StringCchPrintf(szBuffer, cchBuffer, "%S", wszDateTime);
    CDateTimeParser dtParser(szBuffer);
    delete [] szBuffer;
#else
    CDateTimeParser dtParser(wszDateTime);
#endif


    if(!dtParser.IsValidDateTime())
        return FALSE;

    WCHAR wszDMTF[26];
    dtParser.FillDMTF(wszDMTF, 26);
    CWbemTime wt;
    if(!wt.SetDMTF(wszDMTF))
        return FALSE;

    return TRUE;
}



HRESULT CQueryAnalyser::CanPointToClass(IWbemClassObject* pRefClass,
                    LPCWSTR wszPropName, LPCWSTR wszTargetClassName,
                    CContextMetaData* pMeta)
{
    // Check if the reference is typed
    // ===============================

    IWbemQualifierSet* pSet;
    if(FAILED(pRefClass->GetPropertyQualifierSet((LPWSTR)wszPropName, &pSet)))
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    VARIANT v;
    HRESULT hres;
    hres = pSet->Get(L"cimtype", 0, &v, NULL);
    pSet->Release();
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PROPERTY;

    CClearMe cm(&v);
    if(wbem_wcsicmp(V_BSTR(&v), L"ref") == 0)
        return WBEM_S_NO_ERROR; // can point to anything

    WString wsPropClassName = V_BSTR(&v) + 4;

    // Reference is strongly typed.
    // ============================

    if(!wbem_wcsicmp(wsPropClassName, wszTargetClassName))
        return WBEM_S_NO_ERROR;

    // Retrieve class def
    // ==================

    _IWmiObject* pPropClass = NULL;
    hres = pMeta->GetClass(wsPropClassName, &pPropClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1((IWbemClassObject*)pPropClass);

    // Make sure that the class in the reference is related to our cimtype
    // ===================================================================

    if(pPropClass->InheritsFrom((LPWSTR)wszTargetClassName) != S_OK)
    {
        // Get the class in the path to see if it inherits from us
        // =======================================================

        _IWmiObject* pPathClass = NULL;
        hres = pMeta->GetClass(wszTargetClassName, &pPathClass);
        if(FAILED(hres))
            return hres;

        hres = pPathClass->InheritsFrom(wsPropClassName);
        pPathClass->Release();

        if(hres != S_OK)
        {
            return WBEM_S_FALSE;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetNecessaryQueryForClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IWbemClassObject* pClass,
                                       CWStringArray& awsOverriden,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutClass(Token, pClass, awsOverriden))
            {
                pNew->AddToken(Token);
            }

            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- stays empty
        pNewExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    else if(ExprStack.size() != 1)
    {
        // internal error
        return WBEM_E_CRITICAL_ERROR;
    }
    else
    {
        // All is good
        // ===========

        pNewExpr = ExprStack.top();
    }

    //
    // Copy the class name
    //

    VARIANT vName;
    hres = pClass->Get(L"__CLASS", 0, &vName, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;

    pNewExpr->bsClassName = V_BSTR(&vName);
    // Variant intentionally not cleared

    //
    // Copy all the properties in the select clause except for irrelevant ones
    //

    pNewExpr->bStar = pExpr->bStar;
    if(!pNewExpr->bStar)
    {
        delete [] pNewExpr->pRequestedPropertyNames;
        pNewExpr->nCurPropSize = pExpr->nCurPropSize+1;
        pNewExpr->pRequestedPropertyNames =
            new CPropertyName[pNewExpr->nCurPropSize];
        if(pNewExpr->pRequestedPropertyNames == NULL)
        {
            delete pNewExpr;
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // Add __RELPATH, as we always need that!
        //

        pNewExpr->pRequestedPropertyNames[0].AddElement(L"__RELPATH");
        pNewExpr->nNumberOfProperties = 1;

        for(int i = 0; i < pExpr->nNumberOfProperties; i++)
        {
            //
            // Check if the property exists in the class
            //

            CIMTYPE ct;
            hres = pClass->Get(pExpr->pRequestedPropertyNames[i].GetStringAt(0),
                                0, NULL, &ct, NULL);
            if(SUCCEEDED(hres))
            {
                //
                // Add it to the list
                //

                pNewExpr->pRequestedPropertyNames[
                        pNewExpr->nNumberOfProperties++] =
                    pExpr->pRequestedPropertyNames[i];
            }
        }
    }

    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutClass(QL_LEVEL_1_TOKEN& Token,
                        IWbemClassObject* pClass,
                        CWStringArray& awsOverriden)
{
    //
    // Check if the property being compared is in our class
    // and not overriden
    //

    if(!IsPropertyInClass(Token.PropertyName, pClass, awsOverriden))
        return FALSE;

    //
    // If comparing to another property, check if that one is
    // likewise good
    //

    if(Token.m_bPropComp &&
            !IsPropertyInClass(Token.PropertyName2, pClass, awsOverriden))
        return FALSE;

    return TRUE;
}

BOOL CQueryAnalyser::IsPropertyInClass(CPropertyName& Prop,
                        IWbemClassObject* pClass,
                        CWStringArray& awsOverriden)
{
    //
    // Check if the property exists in the class
    //

    CIMTYPE ct;
    HRESULT hres = pClass->Get(Prop.GetStringAt(0), 0, NULL, &ct, NULL);
    if(FAILED(hres))
        return FALSE;

    //
    // Check if the property is overriden by any of our children
    //

    if(awsOverriden.FindStr(Prop.GetStringAt(0), CWStringArray::no_case) >= 0)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\dumbnode.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DUMBNODE.H

Abstract:

    WBEM Dumb Node

History:

--*/

#ifndef __WMI_DUMBNODE__H_
#define __WMI_DUMBNODE__H_

#include "evaltree.h"

//
// This node is used when not enough information exists about the objects being
// tested to perform fast, strongly typed, handle-based comparisons.  Instead,
// it is based on the core query engine code for evaluating a token. Having 
// evaluated a token, it can take a NULL, TRUE, or FALSE branches.
//

class CDumbNode : public CBranchingNode
{
protected:
    QL_LEVEL_1_TOKEN m_Token;
    
    int EvaluateToken(IWbemPropertySource *pTestObj, QL_LEVEL_1_TOKEN& Tok);
    LPWSTR NormalizePath(LPCWSTR wszObjectPath);

public:
    CDumbNode(QL_LEVEL_1_TOKEN& Token);
    CDumbNode(const CDumbNode& Other, BOOL bChildren = TRUE);
    virtual ~CDumbNode();
    HRESULT Validate(IWbemClassObject* pClass);

    virtual CEvalNode* Clone() const {return new CDumbNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CDumbNode(*this, FALSE);}
    virtual HRESULT Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications);
    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes);

    virtual long GetSubType();
    virtual int SubCompare(CEvalNode* pOther);
    virtual int ComparePrecedence(CBranchingNode* pOther);

    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);

    virtual void Dump(FILE* f, int nOffset);

    virtual HRESULT OptimizeSelf();
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\esscpol.h ===
#ifndef ESSCPOL_HEADERFILE_IS_INCLUDED
#define ESSCPOL_HEADERFILE_IS_INCLUDED

#ifdef USE_POLARITY
  #ifdef BUILDING_ESSCLI_DLL
   #define ESSCLI_POLARITY __declspec( dllexport )
  #else 
   #define ESSCLI_POLARITY __declspec( dllimport )
  #endif
 #else
  #define ESSCLI_POLARITY
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\dumbnode.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DUMBNODE.CPP

Abstract:

    WBEM Dumb Node

History:

--*/

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "dumbnode.h"
#include "CWbemTime.h"
#include "datetimeparser.h"

#define DUMBNODE_FALSE_BRANCH_INDEX 0
#define DUMBNODE_TRUE_BRANCH_INDEX 1


CDumbNode::CDumbNode(QL_LEVEL_1_TOKEN& Token) 
    : m_Token(Token)
{
    //
    // Add the branches for TRUE and FALSE
    //

    if(m_apBranches.Add(CValueNode::GetStandardFalse()) < 0)
        throw CX_MemoryException();

    CEvalNode* pNode = CValueNode::GetStandardTrue();
    if(pNode == NULL)
        throw CX_MemoryException();

    if(m_apBranches.Add( pNode ) < 0)
    {
        delete pNode;
        throw CX_MemoryException();
    }
}

HRESULT CDumbNode::Validate(IWbemClassObject* pClass)
{
    HRESULT hres;

    //
    // Check if the property is even in the class
    //

    CIMTYPE ct;
    hres = pClass->Get(m_Token.PropertyName.GetStringAt(0), 0, NULL, &ct, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PROPERTY;

    if(m_Token.m_bPropComp)
    {
        hres = pClass->Get(m_Token.PropertyName2.GetStringAt(0), 0, NULL, &ct, 
                            NULL);
        if(FAILED(hres))
            return WBEM_E_INVALID_PROPERTY;
    }

    if(ct == CIM_REFERENCE)
    {
        // 
        // Make sure that the operator is = or <>
        //
        
        if(m_Token.nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL &&
           m_Token.nOperator != QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
        {
            return WBEM_E_INVALID_OPERATOR;
        }
    
        // 
        // Make sure the path is parsable
        //

        if(!m_Token.m_bPropComp)
        {
            if(V_VT(&m_Token.vConstValue) != VT_BSTR)
            {
                if(V_VT(&m_Token.vConstValue) != VT_NULL)
                    return WBEM_E_TYPE_MISMATCH;
            }
            else
            {
                LPWSTR wszNormal = NormalizePath(V_BSTR(&m_Token.vConstValue));
                if(wszNormal == NULL)
                    return WBEM_E_INVALID_OBJECT_PATH;
                else
                    delete [] wszNormal;
            }
        }
    }
    else if(ct == CIM_DATETIME)
    {
        //
        // If comparing to a constant, make sure the constant is a date
        //

        if(!m_Token.m_bPropComp)
        {
            if(V_VT(&m_Token.vConstValue) != VT_BSTR)
            {
                if(V_VT(&m_Token.vConstValue) != VT_NULL)
                    return WBEM_E_TYPE_MISMATCH;
            }
            else
            {
                BSTR strConstVal = V_BSTR(&m_Token.vConstValue);
#ifdef UNICODE
                CDateTimeParser dtConst(strConstVal);
#else
                size_t  cchBuffer = wcslen(strConstVal) * 4 + 1;
                char* szBuffer = new char[cchBuffer];
                if(szBuffer == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
                StringCchPrintf(szBuffer, cchBuffer, "%S", strConstVal);
        
                CDateTimeParser dtConst(szBuffer);

                delete [] szBuffer;
#endif
        
                if(!dtConst.IsValidDateTime())
                    return WBEM_E_VALUE_OUT_OF_RANGE;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

CDumbNode::CDumbNode(const CDumbNode& Other, BOOL bChildren)
    : CBranchingNode(Other, bChildren), m_Token(Other.m_Token)
{
}

/* virtual */ long CDumbNode::GetSubType()
{
    return EVAL_NODE_TYPE_DUMB;
}

CDumbNode::~CDumbNode()
{
}

int CDumbNode::ComparePrecedence(CBranchingNode* pOther)
{
    //
    // Dumb nodes can only be merged if they are identical.  So, there 
    // precedence (level) is the same as theie comparison order
    //

    return SubCompare(pOther);
}

int CDumbNode::SubCompare(CEvalNode* pOther)
{
    CDumbNode* pDumbOther = (CDumbNode*)pOther;
    
    //
    // The easiest way to compare two tokens is to compare their textual
    // representations.  Optimizations paths for the future abound.
    //

    LPWSTR wszThisText = m_Token.GetText();
    if ( wszThisText == NULL )
        throw CX_MemoryException();

    CVectorDeleteMe<WCHAR> vdm1(wszThisText);

    LPWSTR wszOtherText = pDumbOther->m_Token.GetText();
    if ( wszOtherText == NULL )
        throw CX_MemoryException();

    CVectorDeleteMe<WCHAR> vdm2(wszOtherText);

    return wbem_wcsicmp(wszThisText, wszOtherText);
}
    
HRESULT CDumbNode::OptimizeSelf()
{
    //
    // Nothing to optimize for now.  Optimizations abound.
    //

    return WBEM_S_NO_ERROR;
}

#define INVALID 2

int CDumbNode::EvaluateToken(
    IWbemPropertySource *pTestObj,
    QL_LEVEL_1_TOKEN& Tok
    )
{
    VARIANT PropVal, CompVal;
    VariantInit(&PropVal);
    VariantInit(&CompVal);
    CClearMe clv(&PropVal);
    CClearMe clv2(&CompVal);

    WBEM_WSTR wszCimType, wszCimType2;
    HRESULT hRes;

    // Special-case 'this'
    // ===================

    if(Tok.PropertyName.GetNumElements() == 1 &&
        !wbem_wcsicmp(Tok.PropertyName.GetStringAt(0), L"__THIS"))
    {
        wszCimType = WbemStringCopy(L"object");
        V_VT(&PropVal) = VT_UNKNOWN;
        hRes = pTestObj->QueryInterface(IID_IWbemClassObject,
                                            (void**)&V_UNKNOWN(&PropVal));
    }
    else
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName, 0,
                                                &wszCimType, &PropVal);
    }
    if (FAILED(hRes))
        return FALSE;
    CMemFreeMe wsf(wszCimType);

    // Handle a property-to-property comparison,

    if (Tok.m_bPropComp != FALSE)
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName2, 0,
                                                &wszCimType2, &CompVal);
        if (FAILED(hRes))
            return FALSE;
    }
    else
    {
        if(FAILED(VariantCopy(&CompVal, &Tok.vConstValue)))
            return INVALID;
    }

    // Handle NULLs
    // ============

    if(V_VT(&PropVal) == VT_NULL)
    {
        if(V_VT(&CompVal) == VT_NULL)
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL ||
               Tok.nOperator == QL_LEVEL_1_TOKEN::OP_LIKE )
                return TRUE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL ||
                    Tok.nOperator == QL_LEVEL_1_TOKEN::OP_UNLIKE )
                return FALSE;
            else
                return INVALID;
        }
        else
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL || 
               Tok.nOperator == QL_LEVEL_1_TOKEN::OP_LIKE )
                return FALSE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL || 
                    Tok.nOperator == QL_LEVEL_1_TOKEN::OP_UNLIKE )
                return TRUE;
            else
                return INVALID;
        }
    }
    else if(V_VT(&CompVal) == VT_NULL)
    {
        if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
            return FALSE;
        else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
            return TRUE;
        else
            return INVALID;
    }

    // Handle references
    // =================

    if(wszCimType &&
        wbem_wcsnicmp(wszCimType, L"ref", 3) == 0 &&
        (wszCimType[3] == 0 || wszCimType[3] == L':'))
    {
        // This is a reference. The only operators allowed are = and !=
        // ============================================================

        if(V_VT(&PropVal) != VT_BSTR || V_VT(&CompVal) != VT_BSTR)
            return INVALID;

        LPWSTR va = CDumbNode::NormalizePath(V_BSTR(&PropVal));
        LPWSTR vb = CDumbNode::NormalizePath(V_BSTR(&CompVal));
        if(va == NULL || vb == NULL)
        {
            if(va)
                delete [] va;
            if(vb)
                delete [] vb;
            ERRORTRACE((LOG_ESS, "Invalid path %S or %S specified in an "
                "association\n", V_BSTR(&PropVal), V_BSTR(&CompVal)));
            return INVALID;
        }

        int nRet;
        switch (Tok.nOperator)
        {
        case QL_LEVEL_1_TOKEN::OP_EQUAL:
            nRet = (wbem_wcsicmp(va,vb) == 0);
            break;
        case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
            nRet = (wbem_wcsicmp(va, vb) != 0);
            break;
        default:
            nRet = INVALID;
            break;
        }

        delete [] va;
        delete [] vb;


        return nRet;
    }


    // Check if ISA is used
    // ====================

    if(Tok.nOperator == QL1_OPERATOR_ISA ||
       Tok.nOperator == QL1_OPERATOR_ISNOTA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
    {
        // Account for inversion
        // =====================

        VARIANT* pv1;
        VARIANT* pv2;
        int bNeedDerived;

        if(Tok.nOperator == QL1_OPERATOR_ISA ||
           Tok.nOperator == QL1_OPERATOR_ISNOTA)
        {
            pv2 = &CompVal;
            pv1 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_ISA);
        }
        else
        {
            pv1 = &CompVal;
            pv2 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_INV_ISA);
        }

        // The second argument has to be a string
        // ======================================

        if(V_VT(pv2) != VT_BSTR)
        {
            return INVALID;
        }

        BSTR strParentClass = V_BSTR(pv2);

        // The first argument has to be an object or a string
        // ==================================================

        BOOL bDerived;
        if(V_VT(pv1) == VT_EMBEDDED_OBJECT)
        {
            IWbemClassObject* pObj = (IWbemClassObject*)V_EMBEDDED_OBJECT(pv1);
            bDerived = (pObj->InheritsFrom(strParentClass) == WBEM_S_NO_ERROR);
        }
        else if(V_VT(pv1) == VT_BSTR)
        {
            // TBD
            // ===

            return INVALID;
        }
        else
        {
            return INVALID;
        }

        // Now that we have bDerived, see if it matches the requirement
        // ============================================================

        if(bDerived == bNeedDerived)
            return TRUE;
        else
            return FALSE;

    }
    else if ( Tok.nOperator == QL1_OPERATOR_LIKE || 
              Tok.nOperator == QL1_OPERATOR_UNLIKE )
    {
        if ( Tok.m_bPropComp != FALSE ) 
        {
            return INVALID;
        }

        if ( FAILED(VariantChangeType( &PropVal, &PropVal, 0, VT_BSTR )) ||
             V_VT(&CompVal) != VT_BSTR ) 
        {
            return INVALID;
        }

        try 
        {
            CLike Like( V_BSTR(&CompVal) );

            if ( Like.Match( V_BSTR(&PropVal) ) )
            {
                return Tok.nOperator == QL1_OPERATOR_LIKE ? TRUE : FALSE;
            }
            else
            {
                return Tok.nOperator == QL1_OPERATOR_UNLIKE ? TRUE : FALSE;
            }
        }
        catch( CX_MemoryException )
        {
            return INVALID;
        }
    }

    // Perform UINT32 workaround
    // =========================

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"uint32") &&
        V_VT(&PropVal) == VT_I4)
    {
        DWORD dwVal = (DWORD)V_I4(&PropVal);
        WCHAR wszVal[20];
        StringCchPrintfW(wszVal,20,L"%lu", dwVal);
        V_VT(&PropVal) = VT_BSTR;
        V_BSTR(&PropVal) = SysAllocString(wszVal);
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"sint64") ||
             !wbem_wcsicmp(wszCimType, L"uint64") ||
             !wbem_wcsicmp(wszCimType, L"uint32")) &&
        V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        BOOL bUnsigned = (wbem_wcsicmp(wszCimType, L"uint64") == 0);

        // We have a 64-bit comparison where both sides are present.
        // =========================================================

        hRes = VariantChangeType(&CompVal, &CompVal, 0,
                                    VT_BSTR);
        if(FAILED(hRes))
        {
            return INVALID;
        }

        if(bUnsigned)
        {
            unsigned __int64 ui64Prop, ui64Const;

            if(!ReadUI64(V_BSTR(&PropVal), ui64Prop))
                return INVALID;

            if(!ReadUI64(V_BSTR(&CompVal), ui64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (ui64Prop == ui64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (ui64Prop != ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (ui64Prop >= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (ui64Prop <= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (ui64Prop < ui64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (ui64Prop > ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (ui64Prop == ui64Const);
            }
            return INVALID;
        }
        else
        {
            __int64 i64Prop, i64Const;

            if(!ReadI64(V_BSTR(&PropVal), i64Prop))
                return INVALID;

            if(!ReadI64(V_BSTR(&CompVal), i64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (i64Prop != i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (i64Prop >= i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (i64Prop <= i64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (i64Prop < i64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (i64Prop > i64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
            }
            return INVALID;
        }
    }

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"char16") &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) != VT_NULL)
    {
        // Coerce strings correctly
        // ========================

        BSTR str = V_BSTR(&CompVal);
        if(wcslen(str) != 1)
            return INVALID;

        short va = V_I2(&PropVal);
        short vb = str[0];

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
        }

        return INVALID;
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"datetime")) &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) == VT_BSTR)
    {
        // Parse the constant specified in the query according to the
        // SQL rules
        // ==========================================================

        BSTR strConstVal = V_BSTR(&CompVal);
#ifdef UNICODE
        CDateTimeParser dtConst(strConstVal);
#else
        size_t cchBuffer = wcslen(strConstVal) * 4 + 1;
        char* szBuffer = new char[cchBuffer];
        if(szBuffer == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        StringCchPrintf(szBuffer, cchBuffer, "%S", strConstVal);

        CDateTimeParser dtConst(szBuffer);
        delete [] szBuffer;
#endif
        if(!dtConst.IsValidDateTime())
            return INVALID;

        WCHAR wszConstValDMTF[26];
        dtConst.FillDMTF(wszConstValDMTF, 26);

        // Read both DMTF values and parse them
        // ====================================

        CWbemTime wtConst, wtProp;
        if(!wtConst.SetDMTF(wszConstValDMTF))
            return INVALID;
        if(!wtProp.SetDMTF(V_BSTR(&PropVal)))
            return INVALID;

        __int64 i64Const = wtConst.Get100nss();
        __int64 i64Prop = wtProp.Get100nss();

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                return (i64Prop != i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                return (i64Prop >= i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                return (i64Prop <= i64Const);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                return (i64Prop < i64Const);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                return (i64Prop > i64Const);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
        }
    }

    // Coerce types to match.
    // ======================

    if(V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        hRes = VariantChangeType(&CompVal, &CompVal, 0, V_VT(&PropVal));
        if(FAILED(hRes))
        {
            return INVALID;
        }
    }


    switch (V_VT(&CompVal))
    {
        case VT_NULL:
            return INVALID; // handled above

        case VT_I4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LONG va = V_I4(&PropVal);
                LONG vb = V_I4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_I2:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                short va = V_I2(&PropVal);
                short vb = V_I2(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_UI1:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                BYTE va = V_I1(&PropVal);
                BYTE vb = V_I1(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BSTR:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
                LPWSTR vb = (LPWSTR) V_BSTR(&CompVal);

                int retCode = 0;
                BOOL bDidIt = TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL:
                        retCode = ( wbem_wcsicmp(va,vb) == 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                        retCode = (wbem_wcsicmp(va, vb) != 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) >= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) <= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) < 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) > 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LIKE:
                        retCode = (wbem_wcsicmp(va,vb) == 0);
                        break;
                    default:
                        bDidIt = FALSE;
                        break;
                }
                VariantClear(&CompVal);
                if (bDidIt)
                {
                    return retCode;
                }
            }
            break;

        case VT_R8:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                double va = V_R8(&PropVal);
                double vb = V_R8(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_R4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                float va = V_R4(&PropVal);
                float vb = V_R4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BOOL:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                VARIANT_BOOL va = V_BOOL(&PropVal);
                if(va != VARIANT_FALSE) va = VARIANT_TRUE;
                VARIANT_BOOL vb = V_BOOL(&CompVal);
                if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;
    }

    return FALSE;
}

LPWSTR CDumbNode::NormalizePath(LPCWSTR wszObjectPath)
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath;

    if(Parser.Parse((LPWSTR)wszObjectPath, &pParsedPath) !=
                        CObjectPathParser::NoError ||
        !pParsedPath->IsObject())
    {
        return NULL;
    }

    if(pParsedPath->m_pClass == NULL)
    {
        return NULL;
    }

    //
    // Ignore the server and the namespaze
    //

    //
    // Check for it being a class
    //

    LPWSTR wszKey = NULL;
    if(!pParsedPath->IsInstance())
    {
        // 
        // It's a class
        //

        DWORD cLen = wcslen(pParsedPath->m_pClass) +1;
        WCHAR* wszBuffer = new WCHAR[cLen];
        if(wszBuffer == NULL)
            return NULL;
        StringCchCopyW(wszBuffer, cLen, pParsedPath->m_pClass);
        return wszBuffer;
    }
    else
    {
        //
        // It's an instance
        //
        
        wszKey = pParsedPath->GetKeyString();
        if(wszKey == NULL)
            return NULL;
    
        CVectorDeleteMe<WCHAR> vdm(wszKey);
        DWORD cLen = wcslen(pParsedPath->m_pClass) + wcslen(wszKey) + 2;
        WCHAR* wszBuffer = new WCHAR[cLen];
        if(wszBuffer == NULL)
            return NULL;

        StringCchPrintfW(wszBuffer,cLen,L"%s.%s",pParsedPath->m_pClass,wszKey);
        return wszBuffer;
    }
}

HRESULT CDumbNode::Evaluate(CObjectInfo& ObjInfo, 
                                    INTERNAL CEvalNode** ppNext)
{
    _IWmiObject* pInst;
    HRESULT hres = GetContainerObject(ObjInfo, &pInst);
    if(FAILED(hres)) return hres;
    if(pInst == NULL)
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    //
    // Just evaluate the token, ala core.
    //

    IWbemPropertySource* pPropSource = NULL;
    hres = pInst->QueryInterface(IID_IWbemPropertySource, (void**)&pPropSource);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;
    CReleaseMe rm1(pPropSource);

    int nRes = EvaluateToken(pPropSource, m_Token);
    if(nRes == INVALID)
        *ppNext = m_pNullBranch;
    else if(nRes == FALSE)
        *ppNext = m_apBranches[DUMBNODE_FALSE_BRANCH_INDEX];
    else
        *ppNext = m_apBranches[DUMBNODE_TRUE_BRANCH_INDEX];
    
    return WBEM_S_NO_ERROR;
}

HRESULT CDumbNode::Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
{
    if (!m_pInfo)
    {
        try
        {
            m_pInfo = new CEmbeddingInfo;
        }
        catch(CX_MemoryException)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(m_pInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
            

    HRESULT hres = CompileEmbeddingPortion(pNamespace, Implications, NULL);
    return hres;
}

HRESULT CDumbNode::CombineBranchesWith(CBranchingNode* pRawArg2, int nOp,
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
                                            bool bDeleteThis, bool bDeleteArg2,
                                            CEvalNode** ppRes)
{
    HRESULT hres;

    // 
    // There is only one case in which combining dumb nodes is allowed ---
    // when both of them are exactly the same
    //

    CDumbNode* pArg2 = (CDumbNode*)pRawArg2;
    if(SubCompare(pArg2) != 0)
        return WBEM_E_CRITICAL_ERROR;

    if(!bDeleteThis && bDeleteArg2)
    {
        // It is easier to combine in the other direction
        // ==============================================

        return pArg2->CombineBranchesWith(this, FlipEvalOp(nOp), pNamespace,
                        OrigImplications, bDeleteArg2, bDeleteThis, ppRes);
    }

    // Either clone or use our node
    // ============================

    CDumbNode* pNew = NULL;
    if(bDeleteThis)
    {
        pNew = this;
    }
    else
    {
        // Clone this node without cloning the branches.
        // =============================================

        pNew = (CDumbNode*)CloneSelf();
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    CImplicationList Implications(OrigImplications);
    pNew->AdjustCompile(pNamespace, Implications);

    // Merge all branches
    // ==================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        // Prepare implications for taking this branch
        // ===========================================

        CImplicationList BranchImplications(Implications);

        CEvalNode* pNewBranch = NULL;
        hres = CEvalTree::Combine(m_apBranches[i], 
                           pArg2->m_apBranches[i],
                           nOp, pNamespace, BranchImplications, 
                           bDeleteThis, bDeleteArg2,
                           &pNewBranch);
        if(FAILED(hres))
        {
            if ( !bDeleteThis )
                delete pNew;
            return hres;
        }
        
        if(bDeleteThis)
        {
            m_apBranches.Discard(i);
            pNew->m_apBranches.SetAt(i, pNewBranch);
        }
        else
        {
            if(pNew->m_apBranches.Add(pNewBranch) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }

        if(bDeleteArg2)
            pArg2->m_apBranches.Discard(i);
    }

    // Merge the nulls
    // ===============
    
    CImplicationList NullImplications(Implications);
    CEvalNode* pNewBranch = NULL;
    hres = CEvalTree::Combine(m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                pNamespace, NullImplications, bDeleteThis, bDeleteArg2, 
                &pNewBranch);
    
    if(FAILED(hres))
    {
        if ( !bDeleteThis )
            delete pNew;
        return hres;
    }
    
    // Clear the old new branch, whatever it was, and replace it with the 
    // new one.
    // ==================================================================

    pNew->m_pNullBranch = pNewBranch;
        
    // Clear deleted branches
    // ======================

    if(bDeleteArg2)
        pArg2->m_pNullBranch = NULL;

    // Delete Arg2, if needed (reused portions have been nulled out)
    // =============================================================

    if(bDeleteArg2)
        delete pArg2;

    *ppRes = pNew;
    return WBEM_S_NO_ERROR;
}

void CDumbNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);
    LPWSTR wszText = m_Token.GetText();
    CVectorDeleteMe<WCHAR> vdm1(wszText);

    PrintOffset(f, nOffset);
    fprintf(f, "token %S:\n", wszText);

    PrintOffset(f, nOffset);
    fprintf(f, "FALSE->\n");
    DumpNode(f, nOffset+1, m_apBranches[DUMBNODE_FALSE_BRANCH_INDEX]);

    PrintOffset(f, nOffset);
    fprintf(f, "TRUE->\n");
    DumpNode(f, nOffset+1, m_apBranches[DUMBNODE_TRUE_BRANCH_INDEX]);

    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\evaltree.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EVALTREE.CPP

Abstract:

    WBEM Evaluation Tree

History:

--*/

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <fastall.h>
#include <genutils.h>
#include "evaltree.h"
#include "evaltree.inl"
#include "TwoPropNode.h"
#include "dumbnode.h"

// #define DUMP_EVAL_TREES 1

HRESULT CoreGetNumParents(_IWmiObject* pClass, ULONG *plNumParents)
{
/*
    *plNumParents = ((CWbemObject*)pClass)->GetNumParents();
*/
    DWORD dwSize;
    HRESULT hres = pClass->GetDerivation(0, 0, plNumParents, &dwSize, NULL);
    if(hres != WBEM_E_BUFFER_TOO_SMALL && hres != S_OK)
        return WBEM_E_FAILED;

    return S_OK;
}

RELEASE_ME _IWmiObject* CoreGetEmbeddedObj(_IWmiObject* pObj, long lHandle)
{
    _IWmiObject* pEmbedded = NULL;
    HRESULT hres = pObj->GetPropAddrByHandle(lHandle, 0, NULL, 
                                                (void**)&pEmbedded);
    if(FAILED(hres))
            return NULL;

    return pEmbedded;
}

INTERNAL CCompressedString* CoreGetPropertyString(_IWmiObject* pObj, 
                                                    long lHandle)
{
    CCompressedString* pcs = NULL;
    HRESULT hres = pObj->GetPropAddrByHandle(lHandle, 
                                WMIOBJECT_FLAG_ENCODING_V1, NULL,
                                (void**)&pcs);
    if(FAILED(hres))
            return NULL;

    return pcs;
}

INTERNAL CCompressedString* CoreGetClassInternal(_IWmiObject* pObj)
{
    CCompressedString* pcs = NULL;
    HRESULT hres = pObj->GetPropAddrByHandle(FASTOBJ_CLASSNAME_PROP_HANDLE, 
                                WMIOBJECT_FLAG_ENCODING_V1, NULL,
                                (void**)&pcs);
    if(FAILED(hres))
            return NULL;

    return pcs;
}

INTERNAL CCompressedString* CoreGetParentAtIndex(_IWmiObject* pObj, long lIndex)
{
    return ((CWbemObject*)pObj)->GetParentAtIndex(lIndex);
}

bool CoreIsDerived(_IWmiObject* pThis, _IWmiObject* pFrom)
{
    CCompressedString* pcs = CoreGetClassInternal(pFrom);
    if(pcs == NULL)
        return false;

    try
    {
	    return (pThis->InheritsFrom(pcs->CreateWStringCopy()) == S_OK);
    }
	catch (CX_MemoryException)
	{
		return false;
	}
}

//******************************************************************************
//******************************************************************************
//                  TOKEN VALUE
//******************************************************************************
//******************************************************************************
CTokenValue::CTokenValue()
{
    VariantInit(&m_v);
}
CTokenValue::CTokenValue(CTokenValue& Other)
{
    VariantInit(&m_v);
    *this = Other;
}

CTokenValue::~CTokenValue()
{
    VariantClear(&m_v);
}

bool CTokenValue::SetVariant(VARIANT& v)
{
    if(FAILED(VariantCopy(&m_v, &v)))
        return false;

    // Convert to a better type
    // ========================

    if(V_VT(&v) == VT_I2 || V_VT(&v) == VT_UI1)
    {
        if(FAILED(VariantChangeType(&m_v, &m_v, 0, VT_I4)))
            return false;
    }
    else if(V_VT(&v) == VT_R4)
    {
        if(FAILED(VariantChangeType(&m_v, &m_v, 0, VT_R8)))
            return false;
    }

    return true;
}

void CTokenValue::operator=(CTokenValue& Other)
{
    if(!SetVariant(Other.m_v))
        throw CX_MemoryException();
}

CTokenValue::operator unsigned __int64() const
{
    if(V_VT(&m_v) == VT_I4)
    {
        return V_I4(&m_v);
    }
    else if(V_VT(&m_v) == VT_BSTR)
    {
        unsigned __int64 ui64;
        if(ReadUI64(V_BSTR(&m_v), ui64))
            return ui64;
        else
            return 0; // TBD: errors
    }
    else return 0;
}

CTokenValue::operator unsigned long() const
{
    if(V_VT(&m_v) == VT_I4)
    {
        return V_I4(&m_v);
    }
    else if(V_VT(&m_v) == VT_BSTR)
    {
        unsigned __int64 ui64;
        if(ReadUI64(V_BSTR(&m_v), ui64))
            return (unsigned long)ui64;
        else
            return 0; // TBD: errors
    }
    else return 0;
}

CTokenValue::operator __int64() const
{
    if(V_VT(&m_v) == VT_I4)
    {
        return V_I4(&m_v);
    }
    else if(V_VT(&m_v) == VT_BSTR)
    {
        __int64 i64;
        if(ReadI64(V_BSTR(&m_v), i64))
            return i64;
        else
            return 0; // TBD: errors
    }
    else return 0;
}
CTokenValue::operator short() const
{
    if(V_VT(&m_v) == VT_I4)
        return V_I4(&m_v);
    else if(V_VT(&m_v) == VT_BOOL)
        return V_BOOL(&m_v);
    else return 0;
}
CTokenValue::operator float() const
{
    if(V_VT(&m_v) == VT_I4)
        return V_I4(&m_v);
    else if(V_VT(&m_v) == VT_R8)
        return V_R8(&m_v);
    else return 0;
}

CTokenValue::operator double() const
{
    if(V_VT(&m_v) == VT_I4)
        return V_I4(&m_v);
    else if(V_VT(&m_v) == VT_R8)
        return V_R8(&m_v);
    else return 0;
}

CTokenValue::operator WString() const
{
    if(V_VT(&m_v) == VT_BSTR)
        return WString(V_BSTR(&m_v));
    else
        return WString(L"");
}

int CTokenValue::Compare(const CTokenValue& Other) const
{
    if ( V_VT(&m_v) != V_VT(&Other.m_v) )
    	return V_VT(&m_v) - V_VT(&Other.m_v);
    
    switch(V_VT(&m_v))
    {
    case VT_I4:
        return V_I4(&m_v) - V_I4(&Other.m_v);
    case VT_R8:
        return (V_R8(&m_v) - V_R8(&Other.m_v)<0 ? -1 : 1);
    case VT_BSTR:
        return wbem_wcsicmp(V_BSTR(&m_v), V_BSTR(&Other.m_v));
    case VT_BOOL:
        return V_BOOL(&m_v) - V_BOOL(&Other.m_v);
    }
    return 0;
}
//******************************************************************************
//******************************************************************************
//                  OBJECT INFO
//******************************************************************************
//******************************************************************************

bool CObjectInfo::SetLength(long lLength)
{
    if(lLength > m_lLength)
    {
        delete [] m_apObj;
        m_apObj = new _IWmiObject*[lLength];
        if (m_apObj == NULL)
            return false;

        memset(m_apObj, 0, lLength * sizeof(_IWmiObject*));
    }
    m_lLength = lLength;
    return true;
}

void CObjectInfo::Clear()
{
    for(long i = 1; i < m_lLength; i++)
    {
        if(m_apObj[i])
            m_apObj[i]->Release();
        m_apObj[i] = NULL;
    }
    m_apObj[0] = NULL; // do not release
}

void CObjectInfo::SetObjectAt(long lIndex, READ_ONLY _IWmiObject* pObj) 
{
    if(m_apObj[lIndex])
        m_apObj[lIndex]->Release();

    m_apObj[lIndex] = pObj;
}


CObjectInfo::~CObjectInfo()
{
    for(long i = 0; i < m_lLength; i++)
    {
        if(m_apObj[i])
            m_apObj[i]->Release();
    }
    delete [] m_apObj;
}

//******************************************************************************
//******************************************************************************
//                  IMPLICATION LIST
//******************************************************************************
//******************************************************************************

CImplicationList::CRecord::CRecord(const CImplicationList::CRecord& Other)
    : m_PropName(Other.m_PropName), m_pClass(Other.m_pClass),
    m_lObjIndex(Other.m_lObjIndex), m_nNull(Other.m_nNull)
{
    if(m_pClass)
        m_pClass->AddRef();

    for(int i = 0; i < Other.m_awsNotClasses.Size(); i++)
    {
        if(m_awsNotClasses.Add(Other.m_awsNotClasses[i]) != 
                CWStringArray::no_error)
        {
            throw CX_MemoryException();
        }
    }
}

CImplicationList::CRecord::~CRecord()
{
    if(m_pClass)
        m_pClass->Release();
}

HRESULT CImplicationList::CRecord::ImproveKnown(_IWmiObject* pClass)
{
    if ( pClass == NULL )
    {
        //
        // not much we can improve on, but NULL is still a valid param.
        //
        return WBEM_S_NO_ERROR;
    }

    if(m_nNull == EVAL_VALUE_TRUE)
    {
        // Contradiction
        // =============

        return WBEM_E_TYPE_MISMATCH;
    }

    m_nNull = EVAL_VALUE_FALSE;

    ULONG lNumParents, lRecordNumParents;
    HRESULT hres = CoreGetNumParents(pClass, &lNumParents);
    if(FAILED(hres))
        return hres;

	if(m_pClass)
    {
		hres = CoreGetNumParents(m_pClass, &lRecordNumParents);
        if(FAILED(hres))
            return hres;
    }
    
    if(m_pClass == NULL || lNumParents > lRecordNumParents)
    {
        // Better than before. Check for inconsistencies
        // =============================================

        if(m_pClass)
        {
            if(!CoreIsDerived(pClass, m_pClass))
                return WBEM_E_TYPE_MISMATCH;
        }

        for(int i = 0; i < m_awsNotClasses.Size(); i++)
        {
            if(pClass->InheritsFrom(m_awsNotClasses[i]) == S_OK)
            {
                // Contradiction
                // =============

                return WBEM_E_TYPE_MISMATCH;
            }
        }

        // Replace
        // =======

        pClass->AddRef();
        if(m_pClass)
            m_pClass->Release();
        m_pClass = pClass;
    }
    else
    {
        // Verify that we are a parent of the selected and do not replace
        // ==============================================================

        if(!CoreIsDerived(m_pClass, pClass))
            return WBEM_E_TYPE_MISMATCH;
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CImplicationList::CRecord::ImproveKnownNot(LPCWSTR wszClassName)
{
    if(m_nNull == EVAL_VALUE_TRUE)
    {
        // Contradiction
        // =============

        return WBEM_E_TYPE_MISMATCH;
    }

    // Check for inconsistencies
    // =========================

    if(m_nNull == EVAL_VALUE_FALSE && m_pClass &&
        m_pClass->InheritsFrom(wszClassName) == S_OK)
    {
        // Contradiction
        // =============

        return WBEM_E_TYPE_MISMATCH;
    }

    try
    {
        if(m_awsNotClasses.Add(wszClassName) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    m_nNull = EVAL_VALUE_FALSE;
    return WBEM_S_NO_ERROR;
}
        
HRESULT CImplicationList::CRecord::ImproveKnownNull()
{
    if(m_nNull == EVAL_VALUE_FALSE)
    {
        return WBEM_E_TYPE_MISMATCH;
    }
    m_nNull = EVAL_VALUE_TRUE;

    return WBEM_S_NO_ERROR;
}

void CImplicationList::CRecord::Dump(FILE* f, int nOffset)
{
    LPWSTR wszProp = m_PropName.GetText();
    CEvalNode::PrintOffset(f, nOffset);
    fprintf(f, "Learn about %S:\n", wszProp);

    if(m_pClass)
    {
        VARIANT v;
        m_pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        CEvalNode::PrintOffset(f, nOffset+1);
        fprintf(f, "Is of class %S\n", V_BSTR(&v));
    }
    for(int i = 0; i < m_awsNotClasses.Size(); i++)
    {
        CEvalNode::PrintOffset(f, nOffset+1);
        fprintf(f, "Not of class %S\n", m_awsNotClasses[i]);
    }
    if(m_nNull == EVAL_VALUE_TRUE)
    {
        CEvalNode::PrintOffset(f, nOffset+1);
        fprintf(f, "Is NULL\n");
    }
}

CImplicationList::CImplicationList(long lFlags) 
    : m_lNextIndex(1), m_lRequiredDepth(1), m_pParent(NULL), m_lFlags(lFlags)
{
    CPropertyName Empty;
    CRecord* pRecord = new CRecord(Empty, 0);
    if(pRecord == NULL)
        throw CX_MemoryException();

    if(m_apRecords.Add(pRecord) < 0)
        throw CX_MemoryException();
}

CImplicationList::CImplicationList(CImplicationList& Other, bool bLink)
    : m_lNextIndex(Other.m_lNextIndex), 
        m_lRequiredDepth(Other.m_lRequiredDepth),
        m_pParent(NULL), m_lFlags(Other.m_lFlags)
{
    if(bLink)
        m_pParent = &Other;

    for(int i = 0; i < Other.m_apRecords.GetSize(); i++)
    {
        CRecord* pOtherRecord = Other.m_apRecords[i];
        CRecord* pNewRecord = new CRecord(*pOtherRecord);
        if(pNewRecord == NULL)
            throw CX_MemoryException();
            
        if(m_apRecords.Add(pNewRecord) < 0)
            throw CX_MemoryException();
    }
}

CImplicationList::~CImplicationList()
{
    m_lNextIndex = 0;
}

void CImplicationList::FindBestComputedContainer(CPropertyName* pPropName,
                                             long* plRecord, long* plMatched)
{
    // Look for the largest match
    // ==========================

    long lMax = -1;
    long lMaxRecord = -1;
    for(long lRecord = 0; lRecord < m_apRecords.GetSize(); lRecord++)
    {
        CRecord* pRecord = m_apRecords[lRecord];
        
        if ( pRecord->m_lObjIndex == -1 )
        {
            //
            // we only consider computed records
            //
            continue;
        }

        for(int i = 0; i < pPropName->GetNumElements() && 
                       i < pRecord->m_PropName.GetNumElements();
                i++)
        {
            if(wbem_wcsicmp(pPropName->GetStringAt(i), 
                        pRecord->m_PropName.GetStringAt(i)))
                break;
        }

        if(i > lMax)
        {
            lMax = i;
            lMaxRecord = lRecord;
        }
    }
    
    if(plRecord)
        *plRecord = lMaxRecord;
    if(plMatched)
        *plMatched = lMax;
}

HRESULT CImplicationList::FindRecordForProp(CPropertyName* pPropName,
                                             long lNumElements,
                                             long* plRecord)
{
    if(lNumElements == -1)
    {
        if(pPropName)
            lNumElements = pPropName->GetNumElements();
        else
            lNumElements = 0;
    }

    //
    // Look for the exact match
    //

    for(long lRecord = 0; lRecord < m_apRecords.GetSize(); lRecord++)
    {
        CRecord* pRecord = m_apRecords[lRecord];
        
        if(pRecord->m_PropName.GetNumElements() != lNumElements)
            continue;

        for(int i = 0; i < lNumElements; i++)
        {
            if(wbem_wcsicmp(pPropName->GetStringAt(i), 
                        pRecord->m_PropName.GetStringAt(i)))
                break;
        }

        if(i  == lNumElements)
        {
            break;
        }
    }
    
    if(lRecord < m_apRecords.GetSize())
    {
        // Found it!

        *plRecord = lRecord;
        return S_OK;
    }
    else
        return WBEM_E_NOT_FOUND;
}

HRESULT CImplicationList::FindBestComputedContainer(CPropertyName* pPropName,
            long* plFirstUnknownProp, long* plObjIndex, 
            RELEASE_ME _IWmiObject** ppContainerClass)
{
    if (!pPropName)
        return WBEM_E_FAILED;
    
    long lMax, lMaxRecord;
    FindBestComputedContainer(pPropName, &lMaxRecord, &lMax);
    if(lMaxRecord < 0)
        return WBEM_E_FAILED;

    if(plFirstUnknownProp)
        *plFirstUnknownProp = lMax;

    CRecord* pRecord = m_apRecords[lMaxRecord];
    if(plObjIndex)
        *plObjIndex = pRecord->m_lObjIndex;

    if(ppContainerClass)
    {
        *ppContainerClass = pRecord->m_pClass;
        if(pRecord->m_pClass)
            pRecord->m_pClass->AddRef();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CImplicationList::FindClassForProp(CPropertyName* pPropName,
            long lNumElements, RELEASE_ME _IWmiObject** ppClass)
{
    // don't have a property name? djinn one up for use...
    CPropertyName* pPropNameLocal;
    CPropertyName blank;
    
    if (pPropName)
        pPropNameLocal = pPropName;
    else
        pPropNameLocal = &blank;
    
    long lRecord;
    CRecord* pRecord;
    if(SUCCEEDED(FindRecordForProp(pPropNameLocal, -1, &lRecord)))
    {
        //
        // A record is there --- return its class
        //

        *ppClass = m_apRecords[lRecord]->m_pClass;
        if(*ppClass)
        {
            (*ppClass)->AddRef();
            return WBEM_S_NO_ERROR;
        }
        else
            return WBEM_E_NOT_FOUND;
    }
    else
        return WBEM_E_NOT_FOUND;
}
        
HRESULT CImplicationList::FindOrCreateRecordForProp(CPropertyName* pPropName, 
                                        CImplicationList::CRecord** ppRecord)
{
    // don't have a property name? djinn one up for use...
    CPropertyName* pPropNameLocal;
    CPropertyName blank;
    
    if (pPropName)
        pPropNameLocal = pPropName;
    else
        pPropNameLocal = &blank;
    
    long lRecord;
    CRecord* pRecord;
    if(SUCCEEDED(FindRecordForProp(pPropNameLocal, -1, &lRecord)))
    {
        //
        // A record is there --- improve it
        //

        pRecord = m_apRecords[lRecord];
    }
    else
    {
        try
        {
            pRecord = new CRecord(*pPropNameLocal, -1);
            if(pRecord == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }
        if(m_apRecords.Add(pRecord) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    *ppRecord = pRecord;
    return WBEM_S_NO_ERROR;
}

HRESULT CImplicationList::ImproveKnown(CPropertyName* pPropName, 
                                        _IWmiObject* pClass)
{   
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(pPropName, &pRecord);
    if(FAILED(hres))
        return hres;

    return pRecord->ImproveKnown(pClass);
}

HRESULT CImplicationList::ImproveKnownNot(CPropertyName* pPropName,
                                        LPCWSTR wszClassName)
{
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(pPropName, &pRecord);
    if(FAILED(hres))
        return hres;

    return pRecord->ImproveKnownNot(wszClassName);
}

HRESULT CImplicationList::ImproveKnownNull(CPropertyName* pPropName)
{
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(pPropName, &pRecord);
    if(FAILED(hres))
        return hres;

    return pRecord->ImproveKnownNull();
}
    
HRESULT CImplicationList::AddComputation(CPropertyName& PropName, 
                                _IWmiObject* pClass, long* plObjIndex)
{
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(&PropName, &pRecord);
    if(FAILED(hres))
        return hres;

    if(pClass)
    {
        hres = pRecord->ImproveKnown(pClass);
        if(FAILED(hres))
            return hres;
    }

    pRecord->m_lObjIndex = m_lNextIndex;
    *plObjIndex = m_lNextIndex++;

    RequireDepth(m_lNextIndex);
    return WBEM_S_NO_ERROR;
}

long CImplicationList::GetRequiredDepth()
{
    return m_lRequiredDepth;
}

void CImplicationList::RequireDepth(long lDepth)
{
    if(lDepth > m_lRequiredDepth)
    {
        m_lRequiredDepth = lDepth;
        if(m_pParent)
            m_pParent->RequireDepth(lDepth);
    }
}

HRESULT CImplicationList::MergeIn(CImplicationList* pList)
{
    //
    // Add everything we learn from the second list into our own
    //

    HRESULT hres;
    for(int i = 0; i < pList->m_apRecords.GetSize(); i++)
    {
        CRecord* pRecord = pList->m_apRecords[i];

        hres = MergeIn(pRecord);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}

HRESULT CImplicationList::MergeIn(CImplicationList::CRecord* pRecord)
{
    HRESULT hres;

    //
    // Add everything we learn from the record into our own list
    //

    if(pRecord->m_pClass)
    {
        hres = ImproveKnown(&pRecord->m_PropName, pRecord->m_pClass);
        if(FAILED(hres))
            return hres;
    }

    for(int i = 0; i < pRecord->m_awsNotClasses.Size(); i++)
    {
        hres = ImproveKnownNot(&pRecord->m_PropName, 
                                pRecord->m_awsNotClasses[i]);
        if(FAILED(hres))
            return hres;
    }

    if(pRecord->m_nNull == EVAL_VALUE_TRUE)
    {
        hres = ImproveKnownNull(&pRecord->m_PropName);
        if(FAILED(hres))
            return hres;
    }

    return WBEM_S_NO_ERROR;
}

    
void CImplicationList::Dump(FILE* f, int nOffset)
{
    for(int i = 0; i < m_apRecords.GetSize(); i++)
        m_apRecords[i]->Dump(f, nOffset);
}




//******************************************************************************
//******************************************************************************
//                  EVAL NODE
//******************************************************************************
//******************************************************************************
CEvalNode::CEvalNode()
{
#ifdef CHECK_TREES
	g_treeChecker.AddNode(this);
#endif
}

CEvalNode::CEvalNode(const CEvalNode& other)
{
#ifdef CHECK_TREES
	g_treeChecker.AddNode(this);
#endif
}

CEvalNode::~CEvalNode()
{
#ifdef CHECK_TREES
	g_treeChecker.RemoveNode(this);
#endif
}

void CEvalNode::PrintOffset(FILE* f, int nOffset)
{
    for(int i = 0; i < nOffset; i++)
    {
        fprintf(f, "   ");
    }
}

void CEvalNode::DumpNode(FILE* f, int nOffset, CEvalNode* pNode)
{
    if(pNode == NULL)
    {
        PrintOffset(f, nOffset);
        fprintf(f, "FALSE\n");
    }
    else pNode->Dump(f, nOffset);
}

CEvalNode* CEvalNode::CloneNode(const CEvalNode* pNode)
{
    if(pNode == NULL)
        return NULL;
    
    CEvalNode* pNew = pNode->Clone();

    if ( pNew == NULL )
    	throw CX_MemoryException();

    return pNew;
}

bool CEvalNode::IsNoop(CEvalNode* pNode, int nOp)
{
    if(pNode)
        return pNode->IsNoop(nOp);
    else
        return CValueNode::IsNoop(NULL, nOp);
}

#ifdef CHECK_TREES
void CEvalNode::CheckNode(CTreeChecker *pCheck)
{
	pCheck->CheckoffNode(this);
}
#endif

//******************************************************************************
//******************************************************************************
//                  SORTED ARRAY
//******************************************************************************
//******************************************************************************

// construct from a 'normal' array
CSortedArray::CSortedArray(unsigned nElements, QueryID* pArray)  : CFlexArray(nElements)
{
    memcpy(GetArrayPtr(), pArray, nElements * sizeof(void*));
    SetSize(nElements);
}


int CSortedArray::CopyDataFrom(const QueryID* pArray, unsigned nElements)
{
    EnsureExtent(nElements);
    SetSize(nElements);

    memcpy(GetArrayPtr(), pArray, nElements * sizeof(void*));

    return nElements;
}


unsigned CSortedArray::Find(QueryID n)
{
    unsigned ret = InvalidID;

    // bailout if empty
    if(Size() == 0)
        return InvalidID;

    unsigned lBound = 0;
    unsigned uBound = Size() -1;
    
    // bailout checks - if it's on the boundary, don't search
    // if it's outside the boundaries, we ain't got it
    if (n == GetAt(uBound))
        ret = uBound;
    else if (n == GetAt(lBound))
        ret = lBound;
    else if ((n > GetAt(lBound)) && (n < GetAt(uBound)))
    {
        // binary search
        // warning: break in middle of loop
        do 
        {
            unsigned testBound = (lBound + uBound) / 2;

            if (n < GetAt(testBound))
                uBound = testBound;
            else if (n > GetAt(testBound))
                lBound = testBound;
            else
            {
                ret = testBound;
                break;
            }
        } while (lBound < uBound -1);
    }
    
    return ret;
}

// inserts n in proper position
// no dups allowed
void CSortedArray::Insert(QueryID n)
{
    // looks a lot like 'find'
    unsigned lBound = 0;
    unsigned uBound = Size() == 0 ? 0 : Size() -1;
    unsigned testBound = InvalidID;
    
    // check boundaries, empty array, out of bounds conditions...
    if ((Size() == 0) || (n < GetAt(lBound)))
        CFlexArray::InsertAt(0, (void *)n);
    else if (n > GetAt(uBound))
        Add(n);
    else if ((n != GetAt(uBound)) && (n != GetAt(lBound)))
    {
        // binary search
        // warning: break in middle of loop
        do 
        {
            testBound = (lBound + uBound) / 2;

            if (n < GetAt(testBound))
                uBound = testBound;
            else if (n > GetAt(testBound))
                lBound = testBound;
            else
                break;
        } while (lBound < uBound -1);

        // at this point, three cases:
        //  1) we found the item at testBound
        //  2) we didn't find it, uBound  = lBound +1
        //  3) we didn't find it, uBound == lBound
        if (n != GetAt(testBound))
        {
            if (n < GetAt(lBound))
                InsertAt(lBound, (void *)n);
            else
                InsertAt(uBound, (void *)n);
        }
    }
}

// removes element with value of n
// NOT the nth element
bool CSortedArray::Remove(QueryID n)
{
    unsigned index;
    index = Find(n);
    
    if (index != InvalidID)
    {
        CFlexArray::RemoveAt(index);
        return true;
    }
    else
        return false;
}

//returns zero if arrays are equivalent
// same number of USED elements w/ same values
// LEVN: changed to return < 0 if less, > 0  if more
int CSortedArray::Compare(CSortedArray& otherArray)
{
    int nCompare = Size() - otherArray.Size();
    if(nCompare)
        return nCompare;

    nCompare = memcmp(GetArrayPtr(), otherArray.GetArrayPtr(),
                      Size() * sizeof(void*));
    return nCompare;
}

// changes all QueryID's to begin at newBase
// e.g. if the array is {0,1,5}
// Rebase(6) will change to {6,7,11}
void CSortedArray::Rebase(QueryID newBase)
{
    for (int i = 0; i < Size(); i++)
        SetAt(i, (void *)(GetAt(i) + newBase));
}

// adds the values from the other array into this one
int CSortedArray::AddDataFrom(const CSortedArray& otherArray)
{
    // Check for emptiness
    if(otherArray.Size() == 0)
        return no_error;

    // Ensure there is enough room in our array for the union
    // ======================================================

    if(EnsureExtent(m_nSize + otherArray.m_nSize))
        return out_of_memory;
    
    // Start merging from the end
    // ==========================

    int nThisSourceIndex = m_nSize - 1;
    int nThisDestIndex = m_nSize + otherArray.m_nSize - 1;
    int nOtherIndex = otherArray.m_nSize - 1;
    while(nThisSourceIndex >= 0 && nOtherIndex >= 0)
    {
        int nCompare = 
            (QueryID)m_pArray[nThisSourceIndex] - (QueryID)otherArray[nOtherIndex];
        if(nCompare < 0)
        {
            m_pArray[nThisDestIndex--] = otherArray[nOtherIndex--];
        }
        else if(nCompare > 0)
        {
            m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];
        }
        else
        {
            m_pArray[nThisDestIndex--] = otherArray[nOtherIndex--];
            nThisSourceIndex--;
        }
    }

    // Add remainders
    // ==============

    while(nThisSourceIndex >= 0)
        m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];

    while(nOtherIndex >= 0)
        m_pArray[nThisDestIndex--] = otherArray[nOtherIndex--];

    // Move the array forward if needed
    // ================================

    if(nThisDestIndex >= 0)
    {
        for(int i = nThisDestIndex+1; i < m_nSize + otherArray.m_nSize; i++)
        {
            m_pArray[i-nThisDestIndex-1] = m_pArray[i];
        }
    }

    m_nSize = m_nSize + otherArray.m_nSize - (nThisDestIndex+1);
    return no_error;
}

// adds the values from the other array into this one
int CSortedArray::AddDataFrom(const QueryID* pOtherArray, unsigned nValues)
{
    // Check for emptiness
    if(nValues == 0)
        return no_error;

    // Ensure there is enough room in our array for the union
    // ======================================================

    if(EnsureExtent(m_nSize + nValues))
        return out_of_memory;
    
    // Start merging from the end
    // ==========================

    int nThisSourceIndex = m_nSize - 1;
    int nThisDestIndex = m_nSize + nValues - 1;
    int nOtherIndex = nValues - 1;
    while(nThisSourceIndex >= 0 && nOtherIndex >= 0)
    {
        int nCompare = 
            (QueryID)m_pArray[nThisSourceIndex] - (QueryID)pOtherArray[nOtherIndex];
        if(nCompare < 0)
        {
            m_pArray[nThisDestIndex--] = (void*)pOtherArray[nOtherIndex--];
        }
        else if(nCompare > 0)
        {
            m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];
        }
        else
        {
            m_pArray[nThisDestIndex--] = (void*)pOtherArray[nOtherIndex--];
            nThisSourceIndex--;
        }
    }

    // Add remainders
    // ==============

    while(nThisSourceIndex >= 0)
        m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];

    while(nOtherIndex >= 0)
        m_pArray[nThisDestIndex--] = (void*)pOtherArray[nOtherIndex--];

    // Move the array forward if needed
    // ================================

    if(nThisDestIndex >= 0)
    {
        for(int i = nThisDestIndex+1; i < m_nSize + nValues; i++)
        {
            m_pArray[i-nThisDestIndex-1] = m_pArray[i];
        }
    }

    m_nSize = m_nSize + nValues - (nThisDestIndex+1);
    return no_error;
}

// copies this array to destination
// only copies size number of elements
// returns number of elements copied
unsigned CSortedArray::CopyTo(QueryID* pDest, unsigned size)
{
    unsigned mySize = Size();
    unsigned nElementsToCopy = min(size, mySize);

    if (nElementsToCopy) 
        memcpy(pDest, GetArrayPtr(), nElementsToCopy * sizeof(void*));

    return nElementsToCopy;
}


//******************************************************************************
//******************************************************************************
//                  VALUE NODE
//******************************************************************************
//******************************************************************************

CValueNode::CValueNode(int nNumValues) 
{
}

CValueNode::~CValueNode()
{
    // this page intentionally left blank
}

/* virtual */ int CValueNode::GetType()
{
    return EVAL_NODE_TYPE_VALUE;
}


// changes all QueryID's in all arrays to begin at newBase
// e.g. if the array is {0,1,5}
// Rebase(6) will change to {6,7,11}
void CValueNode::Rebase(QueryID newBase)
{
    for (int i = 0; i < m_nValues; i++)
        m_trueIDs[i] += newBase;
}
 

// returns array index of n
// or InvalidID if not found
unsigned CValueNode::FindQueryID(QueryID n)
{
    unsigned ret = InvalidID;

    if ( m_nValues == 0 )
    {
        return ret;
    }

    unsigned lBound = 0;
    unsigned uBound = m_nValues - 1;

    // bailout checks - if it's on the boundary, don't search
    // if it's outside the boundaries, we ain't got it
    if (n == m_trueIDs[uBound])
        ret = uBound;
    else if (n == m_trueIDs[lBound])
        ret = lBound;
    else if ((n > m_trueIDs[lBound]) && (n < m_trueIDs[uBound]))
    {
        // binary search
        // warning: break in middle of loop
        do 
        {
            unsigned testBound = (lBound + uBound) / 2;

            if (n < m_trueIDs[testBound])
                uBound = testBound;
            else if (n > m_trueIDs[testBound])
                lBound = testBound;
            else
            {
                ret = testBound;
                break;
            }
        } while (lBound < uBound -1);
    }

    return ret;
}

bool CValueNode::RemoveQueryID(QueryID nQuery)
{
    unsigned n;
    if ((n = FindQueryID(nQuery)) != InvalidID)
    {
        if ((m_nValues > 1) && (n != m_nValues -1))
            memcpy(&(m_trueIDs[n]), &(m_trueIDs[n+1]), (m_nValues -n -1) * sizeof(QueryID));
            
        if (m_nValues > 0)
            m_trueIDs[--m_nValues] = InvalidID;
    }
    return (n != InvalidID);
}

// pointers point to arrays that are at the corresponding sizes
// caller is responsible for ensuring that the output array is large enough
// return value #elements inserted into new array;
unsigned CValueNode::ORarrays(QueryID* pArray1, unsigned size1,
                              QueryID* pArray2, unsigned size2, 
                              QueryID* pOutput)
{
    unsigned nElements = 0;

    // 
    //  really shouldn't happen - one side has should have come from this
    // 
    _DBG_ASSERT( !(pArray1 == NULL && pArray2 == NULL) );
    
    if (pArray2 == NULL)
    {
        nElements = size1;
        memcpy(pOutput, pArray1, sizeof(QueryID) * size1);
    }
    else if (pArray1 == NULL)
    {
        nElements = size2;
        memcpy(pOutput, pArray2, sizeof(QueryID) * size2);
    }
    else
    {    
        QueryID* pQID1 = pArray1;
        QueryID* pQID2 = pArray2;
        QueryID* pOut  = pOutput;

        // note that the 'ends' are really one past the end, careful now...
        QueryID* pEnd1 = pQID1 + size1;
        QueryID* pEnd2 = pQID2 + size2;

        // walk through both arrays, always adding smallest value to new array
        while ((pQID1 < pEnd1) && (pQID2 < pEnd2))
        {
            if (*pQID1 == *pQID2)
            {
                // found match, add to array & bump up both cursors
                *pOut++ = *pQID1++;
                pQID2++;
                nElements++;
            }
            else if (*pQID2 < *pQID1)
            {
                // add it
                *pOut++ = *pQID2++;
                nElements++;
            }
            else
            {
                // other side must be smaller, add IT.
                *pOut++ = *pQID1++;
                nElements++;
            }
        }

        // run out whichever array we didn't finish
        // only one should ever hit
        while (pQID1 < pEnd1)
        {
            *pOut++ = *pQID1++;
            nElements++;
        }
        while (pQID2 < pEnd2)
        {
            *pOut++ = *pQID2++;
            nElements++;
        }
    }

    return nElements;
}

unsigned CValueNode::ANDarrays(QueryID* pArray1, unsigned size1,
                               QueryID* pArray2, unsigned size2, 
                               QueryID* pOutput)
{
    unsigned nElements = 0;
    
    if ((pArray1 != NULL) &&
        (pArray2 != NULL))
    {

        QueryID* pQID1 = pArray1;
        QueryID* pQID2 = pArray2;
        QueryID* pOut  = pOutput;

        // note that the 'ends' are really one past the end, careful now...
        QueryID* pEnd1 = pQID1 + size1;
        QueryID* pEnd2 = pQID2 + size2;

        // walk through both arrays, adding any values that appear in both
        while ((pQID1 < pEnd1) && (pQID2 < pEnd2))
        {
            if (*pQID1 == *pQID2)
            {
                // found match, add to array & bump up both cursors
                *pOut++ = *pQID1++;
                pQID2++;
                nElements++;
            }
            else if (*pQID2 < *pQID1)
                pQID2++;
            else
                pQID1++;
        }
    }

    return nElements;
}

unsigned CValueNode::CombineArrays(QueryID* pArray1, unsigned size1,
                                   QueryID* pArray2, unsigned size2, 
                                   QueryID* pOutput)
{
    unsigned nElements = 0;
    
    // 
    //  really shouldn't happen - one side has should have come from this
    // 
    _DBG_ASSERT( !(pArray1 == NULL && pArray2 == NULL) );
    
    if (pArray2 == NULL)
    {
        nElements = size1;
        memcpy(pOutput, pArray1, sizeof(QueryID) * size1);
    }
    else if (pArray1 == NULL)
    {
        nElements = size2;
        memcpy(pOutput, pArray2, sizeof(QueryID) * size2);
    }
    else
    {    
        QueryID* pQID1 = pArray1;
        QueryID* pQID2 = pArray2;
        QueryID* pOut  = pOutput;

        // note that the 'ends' are really one past the end, careful now...
        QueryID* pEnd1 = pQID1 + size1;
        QueryID* pEnd2 = pQID2 + size2;

        while ((pQID1 < pEnd1) && (pQID2 < pEnd2))
        {
            if (*pQID1 == *pQID2)
            {
                // found match, add to array & bump up both cursors
                *pOut++ = *pQID1++;
                pQID2++;
                nElements++;
            }
            else if (*pQID2 < *pQID1)
            {
                // add it
                *pOut++ = *pQID2++;
                nElements++;
            }
            else
            {
                // other side must be smaller, add IT.
                *pOut++ = *pQID1++;
                nElements++;
            }
       }    

        // run out whichever array we didn't finish
        // only one should ever hit
        while (pQID1 < pEnd1)
        {
            *pOut++ = *pQID1++;
            nElements++;
        }
        while (pQID2 < pEnd2)
        {
            *pOut++ = *pQID2++;
            nElements++;
        }
    }

    return nElements;
}

// size of new arrays is predicated on the assumption that
// there will usually be more TRUE nodes than INVALID ones
HRESULT CValueNode::CombineWith(CEvalNode* pRawArg2, int nOp, 
                            CContextMetaData* pNamespace, 
                            CImplicationList& Implications, 
                            bool bDeleteThis, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CValueNode* pArg2 = (CValueNode*)pRawArg2;

    // Check for immediate solutions
    // =============================

    if(nOp != EVAL_OP_AND)
    {
        if(IsAllFalse(pArg2) && bDeleteThis)
        {
            // Just return this!
            // =================
            
            *ppRes = this;
            if(bDeleteArg2)
                delete pArg2;
            return WBEM_S_NO_ERROR;
        }
        else if(IsAllFalse(this) && bDeleteArg2)
        {
            // Just return arg2!
            // =================
            
            *ppRes = pRawArg2;
            if(bDeleteThis)
                delete this;
            return WBEM_S_NO_ERROR;
        }
    }

    // if we got enough room in a stack array, we'll use that,
    // elsewise we'll allocate one from the heap
    const unsigned NewArraySize = 128;
    QueryID  newArray[NewArraySize];
    QueryID* pNewArray = newArray;
    CDeleteMe<QueryID> deleteMe;

    CValueNode* pNew;
    unsigned nElements = 0;

    unsigned arg2Values;
    QueryID* arg2Array;
    if (pArg2)
    {
        arg2Values = pArg2->m_nValues;
        arg2Array  = pArg2->m_trueIDs; 
    }
    else
    {
        arg2Values = 0;
        arg2Array  = NULL; 
    }

    if (nOp == EVAL_OP_AND)
    {
        if (max(m_nValues, arg2Values) > NewArraySize)
        {
            pNewArray = new QueryID[max(m_nValues, arg2Values)];
            if(pNewArray == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            deleteMe = pNewArray;
        }
    
        nElements = ANDarrays(m_trueIDs, m_nValues, 
                              arg2Array, arg2Values, 
                              pNewArray);
    }
    // HMH: it sure looks to me like OR and COMBINE are the same for this case
    //      I'm too afraid to risk changing it, tho
    else if (nOp == EVAL_OP_OR)
    {
        if ((m_nValues + arg2Values) > NewArraySize)
        {
            pNewArray = new QueryID[m_nValues+arg2Values];
            if(pNewArray == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            deleteMe = pNewArray;
        }

        nElements = ORarrays(m_trueIDs, m_nValues, 
                             arg2Array, arg2Values, 
                             pNewArray);
    }
    else if ((nOp == EVAL_OP_COMBINE) || (nOp == EVAL_OP_INVERSE_COMBINE))
    {
        if ((m_nValues + arg2Values) > NewArraySize)
        {
            pNewArray = new QueryID[m_nValues + arg2Values];
            if(pNewArray == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            deleteMe = pNewArray;
        }

        nElements = CombineArrays(m_trueIDs, m_nValues, 
                                  arg2Array, arg2Values, 
                                  pNewArray);
    }

    // check to see if we can reuse a node, note this could result in the array 'shrinking'
    if (nElements == 0)
        *ppRes = NULL;
    else if (bDeleteThis && (nElements <= m_nValues))
    {
        *ppRes = this;
        memcpy(m_trueIDs, pNewArray, nElements * sizeof(QueryID));
        m_nValues = nElements;
        bDeleteThis = false;
    }
    else if (bDeleteArg2 && pArg2 && (nElements <= pArg2->m_nValues))
    {
        *ppRes = pArg2;
        memcpy(pArg2->m_trueIDs, pNewArray, nElements * sizeof(QueryID));
        pArg2->m_nValues = nElements;
        bDeleteArg2 = false;
    }
    else if (pNew = CreateNode(nElements))
    {   // can't reuse one, start a new one
        *ppRes = pNew;
        memcpy(pNew->m_trueIDs, pNewArray, nElements * sizeof(QueryID));
    }
    else
        hRes = WBEM_E_OUT_OF_MEMORY;

    // Delete what needed deletion
    // ===========================
    // deleteMe will take care of the array pointer if allocated
    if(bDeleteThis)
        delete this;
    if(bDeleteArg2)
        delete pArg2;

    return WBEM_S_NO_ERROR;
}    

//static 
bool CValueNode::IsNoop(CValueNode* pNode, int nOp)
{
    if(nOp == EVAL_OP_OR)
        return IsAllFalse(pNode);
    else if(nOp == EVAL_OP_AND)
        return false; // BUGBUG: would be nice to have IsAllTrue, but can't
    else if(nOp == EVAL_OP_COMBINE || nOp == EVAL_OP_INVERSE_COMBINE)
        return IsAllFalse(pNode);
    else 
    {
        //?
        return false;
    }
}
        

HRESULT CValueNode::TryShortCircuit(CEvalNode* pArg2, int nOp, 
                                    bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes)
{
    if(IsAllFalse(this))
    {
        if(nOp == EVAL_OP_AND)
        {
            // FALSE & X is FALSE
            if(bDeleteThis)
                *ppRes = this;
            else
            {
                *ppRes = Clone();
                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            if(bDeleteArg2)
                delete pArg2;
            return WBEM_S_NO_ERROR;
        }
        else // OR and COMBINE are identical in this case
        {
            // FALSE | X is X

            //
            // Well, this is true, but the problem is with optimizations.  
            // Some branches in X might not be valid under the implications in
            // this branch of the tree, and so need to be removed. For now, I
            // will simply turn off this short-circuiting path.  It may turn out
            // that there are some critical performance gains to be had by 
            // keeping it, in which case we would need to put this back and
            // make an efficient pass through it, checking branches.
            //
        
            return WBEM_S_FALSE;
/*
            if(bDeleteArg2)
                *ppRes = pArg2;
            else if (pArg2)
            {
                *ppRes = pArg2->Clone();
                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
                *ppRes = NULL;

            if(bDeleteThis)
                delete this;
            return WBEM_S_NO_ERROR;
*/
        }
    }
        
    return WBEM_S_FALSE;
}

HRESULT CValueNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode)
{
    //
    // Projection of a constant is, again, a constant
    //

    if(bDeleteThis)
    {
        *ppNewNode = this;
    }
    else
    {
        *ppNewNode = Clone();
        if(*ppNewNode == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

CEvalNode* CValueNode::Clone() const
{
    
    CValueNode* pNew;
        
    if (pNew = CreateNode(m_nValues))
        memcpy(pNew->m_trueIDs, m_trueIDs, m_nValues * sizeof(QueryID));

    return pNew;
}

int CValueNode::Compare(CEvalNode* pRawOther)
{
    if (!pRawOther)
        return m_nValues;
    
    CValueNode* pOther = (CValueNode*)pRawOther;
    int nCompare = m_nValues - pOther->m_nValues;

    if ((nCompare == 0) && (m_nValues != 0))
        nCompare = memcmp(m_trueIDs, pOther->m_trueIDs, m_nValues * sizeof(QueryID));

    return nCompare;
}

CValueNode* CValueNode::GetStandardTrue()
{
    CValueNode* pNew = CreateNode(1);
    if(pNew)
        pNew->m_trueIDs[0] = 0;

    return pNew;
}

CValueNode* CValueNode::GetStandardInvalid()
{
    return new CInvalidNode;
}

/*static*/ CValueNode* CValueNode::CreateNode(size_t nNumValues)
{
    return new(nNumValues) CValueNode;
}

/*static*/ CValueNode* CValueNode::CreateNode(CSortedArray& values)
{
    CValueNode* pNode;
    
    pNode = new(values.Size()) CValueNode;
    if (pNode)
        values.CopyTo(pNode->m_trueIDs, values.Size());

    return pNode;
}

void* CValueNode::operator new( size_t stAllocateBlock, unsigned nEntries)
{
    void *pvTemp;
    if (pvTemp = ::new byte[ stAllocateBlock + ((nEntries ==0)? 0 : ((nEntries -1)* sizeof(QueryID)))] )
        ((CValueNode*)pvTemp)->m_nValues = nEntries;

    return pvTemp;
}

//    VC 5 only allows one delete operator per class
#if _MSC_VER >= 1200
void CValueNode::operator delete( void *p, unsigned nEntries )
{
    ::delete[] (byte*)p;
}
#endif


void CValueNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);
    fprintf(f, "TRUE: ");

    for (int i = 0; i < m_nValues; i++)
    {
        fprintf(f, "%u", m_trueIDs[i]);
        if(i < m_nValues-1)
            fprintf(f, ", %u", m_trueIDs[i]);
    }

    fprintf(f, "\n");
}
        

void CInvalidNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);
    fprintf(f, "Invalid node (0x%p)\n", this);
}
//******************************************************************************
//******************************************************************************
//                  EMBEDDING INFO
//******************************************************************************
//******************************************************************************
    
CEmbeddingInfo::CEmbeddingInfo()
: m_lNumJumps(0), m_aJumps(NULL), m_lStartingObjIndex(0)
{
}

CEmbeddingInfo::CEmbeddingInfo(const CEmbeddingInfo& Other)
: m_lNumJumps(0), m_aJumps(NULL), m_lStartingObjIndex(0) 
{
    *this = Other;
}

void CEmbeddingInfo::operator=(const CEmbeddingInfo& Other)
{
    m_EmbeddedObjPropName = Other.m_EmbeddedObjPropName;
    m_lNumJumps = Other.m_lNumJumps;
    m_lStartingObjIndex = Other.m_lStartingObjIndex;

    delete [] m_aJumps;

    if(m_lNumJumps > 0)
    {
        m_aJumps = new JumpInfo[m_lNumJumps];
        if (m_aJumps == NULL)
            throw CX_MemoryException();   
        memcpy(m_aJumps, Other.m_aJumps, m_lNumJumps * sizeof(JumpInfo));
    }
    else m_aJumps = NULL;
}

CEmbeddingInfo::~CEmbeddingInfo()
{
    delete [] m_aJumps;
}

bool CEmbeddingInfo::IsEmpty() const
{
    return (m_EmbeddedObjPropName.GetNumElements() == 0);
}

bool CEmbeddingInfo::SetPropertyNameButLast(const CPropertyName& Name)
{
    try
    {
        m_EmbeddedObjPropName.Empty();
        for(int i = 0; i < Name.GetNumElements() - 1; i++)
        {
            m_EmbeddedObjPropName.AddElement(Name.GetStringAt(i));
        }
        return true;
    }
    catch (CX_MemoryException)
    {
        return false;
    }
}

int CEmbeddingInfo::ComparePrecedence(const CEmbeddingInfo* pOther)
{
    if (pOther)
    {   
        int nCompare = m_EmbeddedObjPropName.GetNumElements() - 
                        pOther->m_EmbeddedObjPropName.GetNumElements();
        if(nCompare) return nCompare;
    
        for(int i = 0; i < m_EmbeddedObjPropName.GetNumElements(); i++)
        {
            nCompare = wbem_wcsicmp(m_EmbeddedObjPropName.GetStringAt(i),
                                pOther->m_EmbeddedObjPropName.GetStringAt(i));
            if(nCompare) return nCompare;
        }
    }

    return 0;
}

BOOL CEmbeddingInfo::operator==(const CEmbeddingInfo& Other)
{
    if(m_lStartingObjIndex != Other.m_lStartingObjIndex)
        return FALSE;
    if(m_lNumJumps != Other.m_lNumJumps)
        return FALSE;
    if(m_aJumps == NULL)
    {
        if(Other.m_aJumps == NULL)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        if(Other.m_aJumps == NULL)
            return FALSE;
        else
            return (memcmp(m_aJumps, Other.m_aJumps, 
                            m_lNumJumps * sizeof(JumpInfo)) == 0);
    }
}
    
HRESULT CEmbeddingInfo::Compile( CContextMetaData* pNamespace, 
                                 CImplicationList& Implications,
                                _IWmiObject** ppResultClass )
{
    HRESULT hres;

    long lFirstUnknownProp;
    _IWmiObject* pContainerClass;

    hres = Implications.FindBestComputedContainer( &m_EmbeddedObjPropName,
                                                   &lFirstUnknownProp, 
                                                   &m_lStartingObjIndex, 
                                                   &pContainerClass );

    if(FAILED(hres))
        return hres;

    int nNumEmbeddedJumps = m_EmbeddedObjPropName.GetNumElements();

    if(lFirstUnknownProp < nNumEmbeddedJumps)
    {
        // Not everything is already loaded
        // ================================

        delete [] m_aJumps;
        
        m_lNumJumps = nNumEmbeddedJumps - lFirstUnknownProp;
        m_aJumps = new JumpInfo[m_lNumJumps];
        if (!m_aJumps)
            return WBEM_E_OUT_OF_MEMORY;

        JumpInfo* pji = NULL;

        for(int i = lFirstUnknownProp; i < nNumEmbeddedJumps; i++)
        {
            if(pContainerClass == NULL)
                return WBEMESS_E_REGISTRATION_TOO_BROAD;

            // Get the handle of this property
            // ===============================

            CIMTYPE ct;

            pji = m_aJumps + i - lFirstUnknownProp;
            pji->lTarget = -1;

            hres = pContainerClass->GetPropertyHandleEx(
                (LPWSTR)m_EmbeddedObjPropName.GetStringAt(i), 0L, &ct,
                &pji->lJump );

            if(FAILED(hres) || ct != CIM_OBJECT)
            {
                // Invalid. Return 
                pContainerClass->Release();
                return WBEM_E_INVALID_PROPERTY;
            }

            //
            // Check if the implications know anything about the class name
            // for this property
            //

            _IWmiObject* pNewContainerClass = NULL;
            hres = Implications.FindClassForProp(&m_EmbeddedObjPropName,
                        i+1, &pNewContainerClass);
            if(FAILED(hres))
            {
                // 
                // Nothing implied --- have to go with the CIMTYPE qualifier
                //
            
                //
                // Get CIMTYPE qualifier
                // 
    
                CVar vCimtype;
                DWORD dwSize;
                hres = pContainerClass->GetPropQual(
                    (LPWSTR)m_EmbeddedObjPropName.GetStringAt(i), 
                    L"CIMTYPE", 0, 0, NULL, NULL, &dwSize, NULL);
                if(hres != WBEM_E_BUFFER_TOO_SMALL)
                    return WBEM_E_INVALID_PROPERTY;
    
                LPWSTR wszCimType = (LPWSTR)new BYTE[dwSize];
                if(wszCimType == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
                CVectorDeleteMe<BYTE> vdm((BYTE*)wszCimType);
    
                CIMTYPE ctQualType;
                hres = pContainerClass->GetPropQual(
                    (LPWSTR)m_EmbeddedObjPropName.GetStringAt(i), 
                    L"CIMTYPE", 0, dwSize, &ctQualType, NULL, &dwSize, 
                    wszCimType);
                if(FAILED(hres) || ctQualType != CIM_STRING)
                    return WBEM_E_INVALID_PROPERTY;
    

                //
                // Figure out what it references, if available
                //
    
                WCHAR* pwc = wcschr(wszCimType, L':');
                if(pwc)
                {
                    // Information about the class is available
                    // ========================================
    
                    hres = pNamespace->GetClass(pwc+1, &pNewContainerClass);
                    if(FAILED(hres))
                    {
                        return WBEM_E_INVALID_CIM_TYPE;
                    }
                }
            }

            pContainerClass->Release();
            pContainerClass = pNewContainerClass;
        }

        // Get a location for the result and store in the last jump info elem
        // ==================================================================
    
        Implications.AddComputation( m_EmbeddedObjPropName, 
                                     pContainerClass, 
                                     &pji->lTarget );
    }
    else
    {
        // Everything is covered
        // =====================

        delete [] m_aJumps;
        m_aJumps = NULL;
        m_lNumJumps = 0;
    }

    if(ppResultClass)
    {
        *ppResultClass = pContainerClass;
    }
    else
    {
        if(pContainerClass)
            pContainerClass->Release();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEmbeddingInfo::GetContainerObject( CObjectInfo& ObjInfo, 
                                            INTERNAL _IWmiObject** ppInst)
{
    if( m_lNumJumps == 0 )
    {
        *ppInst = ObjInfo.GetObjectAt(m_lStartingObjIndex);
        return WBEM_S_NO_ERROR;
    }

    _IWmiObject* pCurrent = ObjInfo.GetObjectAt(m_lStartingObjIndex);
    pCurrent->AddRef();
    
    for(int i = 0; i < m_lNumJumps; i++)
    {
       _IWmiObject* pNew = NULL;
        HRESULT hres = pCurrent->GetPropAddrByHandle( m_aJumps[i].lJump, 0, NULL, ( void** )&pNew );

        if( FAILED( hres ) )
        {
            return hres;
        }
        
        pCurrent->Release();
        pCurrent = pNew;
        
        if(pNew == NULL)
        {
            *ppInst = pCurrent;
            return WBEM_S_FALSE;
        }

        //
        // save the object if required.
        //

        if ( m_aJumps[i].lTarget != -1 )
        {
            ObjInfo.SetObjectAt( m_aJumps[i].lTarget, pCurrent );
        }
    }

    *ppInst = pCurrent;
    return WBEM_S_NO_ERROR;
}

bool CEmbeddingInfo::AreJumpsRelated(const CEmbeddingInfo* pInfo)
{
    if ( !pInfo )
    {
        return false;
    }

    //
    // look through the targets of the info and see if we depend on any.
    //

    for( int i=0; i < pInfo->m_lNumJumps; i++ )
    {
        if ( pInfo->m_aJumps[i].lTarget == m_lStartingObjIndex )
        {
            return true;
        }
    }

    return false;
}

bool CEmbeddingInfo::MixInJumps(const CEmbeddingInfo* pInfo)
{
    //
    // Assumes AreJumpsRelated() has been called and returned TRUE.
    //

    m_lStartingObjIndex = pInfo->m_lStartingObjIndex;

    JumpInfo* aNewJumps = new JumpInfo[m_lNumJumps + pInfo->m_lNumJumps];
    if(aNewJumps == NULL)
        return false;

    if( pInfo->m_lNumJumps > 0 )
    {
        memcpy( aNewJumps, 
                pInfo->m_aJumps, 
                sizeof(JumpInfo)*(pInfo->m_lNumJumps) );
    }

    if( m_lNumJumps > 0 )
    {
        memcpy( aNewJumps + pInfo->m_lNumJumps, 
                m_aJumps, 
                sizeof(JumpInfo)*m_lNumJumps );
    }

    m_lNumJumps += pInfo->m_lNumJumps;

    delete [] m_aJumps;
    m_aJumps = aNewJumps;

    return true;
}


void CEmbeddingInfo::Dump(FILE* f)
{
    fprintf(f, "Name=");
    int i;
    for(i = 0; i < m_EmbeddedObjPropName.GetNumElements(); i++)
    {
        if(i != 0)
            fprintf(f, ".");
        fprintf(f, "%S", m_EmbeddedObjPropName.GetStringAt(i));
    }

    fprintf(f, ", Alg=%d -> (", m_lStartingObjIndex);
    for(i = 0; i < m_lNumJumps; i++)
    {
        if(i != 0)
            fprintf(f, ", ");
        fprintf(f, "0x%x : %d", m_aJumps[i].lJump, m_aJumps[i].lTarget );
    }
    fprintf(f, ")");
}
    
//******************************************************************************
//******************************************************************************
//                  BRANCHING NODE
//******************************************************************************
//******************************************************************************

CNodeWithImplications::CNodeWithImplications(const CNodeWithImplications& Other)
    : CEvalNode(Other), m_pExtraImplications(NULL)
{
    if(Other.m_pExtraImplications)
    {
        m_pExtraImplications = 
            new CImplicationList(*Other.m_pExtraImplications, false); // no link
        if(m_pExtraImplications == NULL)
            throw CX_MemoryException();
    }
}

void CNodeWithImplications::Dump(FILE* f, int nOffset)
{
    if(m_pExtraImplications)
        m_pExtraImplications->Dump(f, nOffset);
}

CBranchingNode::CBranchingNode() 
    : CNodeWithImplications(), m_pNullBranch(NULL), m_pInfo(NULL)
{
    m_pNullBranch = CValueNode::GetStandardFalse();
}

CBranchingNode::CBranchingNode(const CBranchingNode& Other, BOOL bChildren)
    : CNodeWithImplications(Other), m_pInfo(NULL)
{
    if (Other.m_pInfo)
    {
        m_pInfo = new CEmbeddingInfo(*(Other.m_pInfo));
        if(m_pInfo == NULL)
            throw CX_MemoryException();
    }

    int i;
    if(bChildren)
    {
        m_pNullBranch = (CBranchingNode*)CloneNode(Other.m_pNullBranch);
        if(m_pNullBranch == NULL && Other.m_pNullBranch != NULL)
            throw CX_MemoryException();

        for(i = 0; i < Other.m_apBranches.GetSize(); i++)
        {
            CBranchingNode* pNewBranch = 
                (CBranchingNode*)CloneNode(Other.m_apBranches[i]);

            if(pNewBranch == NULL && Other.m_apBranches[i] != NULL)
                throw CX_MemoryException();

            if(m_apBranches.Add(pNewBranch) < 0)
                throw CX_MemoryException();
        }
    }
    else
    {
        m_pNullBranch = CValueNode::GetStandardFalse();
    }
}

/* virtual */ int CBranchingNode::GetType()
{
    return EVAL_NODE_TYPE_BRANCH;
}

CBranchingNode::~CBranchingNode()
{
    delete m_pNullBranch;
    delete m_pInfo;
}

bool CBranchingNode::MixInJumps( const CEmbeddingInfo* pJump )
{            
    bool bRet;

    if ( !pJump )
    {
        return true;
    }

    //
    // we want to find the first node in the tree that is related to the 
    // ancestor embedding info. If this node is related, then we mix in the
    // jumps and return.  If not, then we propagate the info down the tree.
    // 
    
    if ( m_pInfo )
    {
        if ( m_pInfo->AreJumpsRelated( pJump ) )
        {
            return m_pInfo->MixInJumps( pJump );
        }
    }

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if ( CEvalNode::GetType(m_apBranches[i]) == EVAL_NODE_TYPE_BRANCH )
        {
            if ( !((CBranchingNode*)m_apBranches[i])->MixInJumps( pJump ) )
            {
                return false;
            }
        }
    }

    return true;
}

bool CBranchingNode::SetEmbeddedObjPropName(CPropertyName& Name) 
{ 
    try
    {
        if (!m_pInfo)
        {
            m_pInfo = new CEmbeddingInfo;
            if(m_pInfo == NULL)
                return false;
        }
    
        m_pInfo->SetEmbeddedObjPropName(Name);
        return true;
    }
	catch (CX_MemoryException)
	{
		return false;
	}
}

void CBranchingNode::SetNullBranch(CEvalNode* pBranch)
{
    delete m_pNullBranch;
    m_pNullBranch = pBranch;
}

DELETE_ME CBranchIterator* CBranchingNode::GetBranchIterator()
{
    return new CDefaultBranchIterator(this);
}

int CBranchingNode::ComparePrecedence(CBranchingNode* pArg1, 
                                        CBranchingNode* pArg2)
{
    int nCompare;
    nCompare = pArg1->GetSubType() - pArg2->GetSubType();
    if(nCompare) return nCompare;

    // Compare embedding specs
    // =======================

    if (pArg1->m_pInfo && pArg2->m_pInfo) 
    {
        nCompare = pArg1->m_pInfo->ComparePrecedence(pArg2->m_pInfo);
        if(nCompare) return nCompare;
    }
    else if (pArg2->m_pInfo)
        return -1;
    else if (pArg1->m_pInfo)
        return 1;


    // Embedding are the same --- compare lower levels
    // ===============================================

    return pArg1->ComparePrecedence(pArg2);
}
    
DWORD CBranchingNode::ApplyPredicate(CLeafPredicate* pPred)
{
    DWORD dwRes;
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if(m_apBranches[i] == NULL)
            dwRes = (*pPred)(NULL);
        else
            dwRes = m_apBranches[i]->ApplyPredicate(pPred);

        if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
        {
            m_apBranches.SetAt(i, NULL);
            dwRes &= ~WBEM_DISPOSITION_FLAG_DELETE;
        }

        if(dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE)
        {
            m_apBranches.SetAt(i, CValueNode::GetStandardInvalid());
            dwRes &= ~WBEM_DISPOSITION_FLAG_INVALIDATE;
        }

        if(dwRes == WBEM_DISPOSITION_STOPLEVEL)
            return WBEM_DISPOSITION_NORMAL;
        if(dwRes == WBEM_DISPOSITION_STOPALL)
            return dwRes;
    }

    if(m_pNullBranch)
		dwRes = m_pNullBranch->ApplyPredicate(pPred);
	else
		dwRes = (*pPred)(NULL);

    if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
    {
        delete m_pNullBranch;
        m_pNullBranch = NULL;
        dwRes &= ~WBEM_DISPOSITION_FLAG_DELETE;
    }
    if(dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE)
    {
        delete m_pNullBranch;
        m_pNullBranch = CValueNode::GetStandardInvalid();
        dwRes &= ~WBEM_DISPOSITION_FLAG_INVALIDATE;
    }

    if(dwRes == WBEM_DISPOSITION_STOPALL)
        return dwRes;
        
    return WBEM_DISPOSITION_NORMAL;
}
        
HRESULT CBranchingNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter, EProjectionType eType, 
                            bool bDeleteThis, CEvalNode** ppNewNode) 
{ 
	HRESULT hres;

    try
    {
        //
        // Record what we learn by even getting here
        //
    
        CImplicationList TheseImplications(Implications);
        if(GetExtraImplications())
        {
            hres = TheseImplications.MergeIn(GetExtraImplications());
            if(FAILED(hres))
                return hres;
        }
    
        // BUGBUG: we could be more efficient and not clone the node when 
        // bDeleteThis is not specified. 
    
        CBranchingNode* pNew; 
        if(bDeleteThis) 
        {
            pNew = this;
        }
        else
        {
            pNew = (CBranchingNode*)Clone();
            if(pNew == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        // BUGBUG: it is not always necessary to project all children.  Could be
        // more efficient, but can't find the perfect algorithm...
        
        //
        // Project all our children
        //
    
        CBranchIterator* pit = pNew->GetBranchIterator();
        if(pit == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe<CBranchIterator> dm1(pit);
    
        while(pit->IsValid())
        {
            if(!CEvalNode::IsInvalid(pit->GetNode()))
            { 
            	CImplicationList BranchImplications(TheseImplications);
            	pit->RecordBranch(pMeta, BranchImplications);
    
            	CEvalNode* pNewBranch;
            	hres = CEvalTree::Project(pMeta, BranchImplications, 
                                    pit->GetNode(), pFilter, eType, 
                                    true, &pNewBranch);
            	if(FAILED(hres))
                	return hres;
            	pit->SetNode(pNewBranch); // old one already deleted
            }
            pit->Advance();
        }
    
        //
        // Determine if this is an "in" node for this filter
        //
    
        bool bIn = pFilter->IsInSet(this);
    
        if(bIn)
        {
            //
            // For nodes martching the filter that's it --- both necessary and
            // sufficient conditions are simply projections of what's below
            //
    
            *ppNewNode = pNew;
        }
        else
        {
            //
            // The node does not match the filter.  Now is when the difference
            // between sufficient and necessary conditions applies
            //
    
            int nBranchOp;
            if(eType == e_Sufficient)
            {
                //
                // For a condition to be sufficient for the truth of the entire
                // node, it should appear in every single branch of the node.
                // Therefore, we must AND all the branches together. Except for 
                // invalid ones --- they can't happen, so we can omit them from 
                // the analysis
                //
            
                nBranchOp = EVAL_OP_AND;
            }
            else if(eType == e_Necessary)
            {
                //
                // For a condition to be necessary for this node, it has to 
                // appear in at least one branch.  Therefore, we must OR all 
                // the branches together.  Except for invalid ones.
                //
    
                nBranchOp = EVAL_OP_OR;
            }
            else
                return WBEM_E_INVALID_PARAMETER;
    
            //  
            // Perform the needed operation on them all
            //
                
            CBranchIterator* pitInner = pNew->GetBranchIterator();
            if(pitInner == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            CDeleteMe<CBranchIterator> dm2(pitInner);
    
            //
            // Merge all of the, in, one at a time, deleting them as we go.  
            // It is safe to delete them always, since we cloned the entire node
            // in the beginning if deletion was not allowed.
            //
    
            CEvalNode* pCombination = NULL;
            bool bInited = false;
            while(pitInner->IsValid())
            {
                if(!CEvalNode::IsInvalid(pitInner->GetNode()))
                {
                	if(bInited)
                	{
                    	hres = CEvalTree::Combine(pCombination, pitInner->GetNode(), 
                                                nBranchOp,
                                                pMeta, Implications, 
                                                true, true, &pCombination);
                   	 if(FAILED(hres))
                        	return hres;
                	}
                	else
                	{
                    		pCombination = pitInner->GetNode();
                    		bInited = true;
                	}
    
                	pitInner->SetNode(NULL);
                }
                pitInner->Advance();
            }
    
            if(!bInited)
            {
                // 
                // No valid nodes??
                //
    
                pCombination = CValueNode::GetStandardInvalid();
            }
    
            //
            // The combination is it.
            //
    
            *ppNewNode = pCombination;
            delete pNew;
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    return S_OK;
}
            
        
int CBranchingNode::Compare(CEvalNode* pRawOther)
{
    CBranchingNode* pOther = (CBranchingNode*)pRawOther;

    int nCompare;
    nCompare = GetSubType() - pOther->GetSubType();
    if(nCompare) return nCompare;

    // First, compare embeddings
    // =========================

    if(m_pInfo == NULL && pOther->m_pInfo != NULL)
        return -1;

    if(m_pInfo != NULL && pOther->m_pInfo == NULL)
        return 1;

    if(m_pInfo != NULL && pOther->m_pInfo != NULL)
    {
        nCompare = m_pInfo->ComparePrecedence(pOther->m_pInfo);
        if(nCompare)
            return nCompare;
    }

    if(m_apBranches.GetSize() != pOther->m_apBranches.GetSize())
        return m_apBranches.GetSize() - pOther->m_apBranches.GetSize();

    // Then, compare derived portions
    // ==============================

    nCompare = SubCompare(pOther);
    if(nCompare)
        return nCompare;

    // Finally, compare children
    // =========================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        nCompare = CEvalTree::Compare(m_apBranches[i], pOther->m_apBranches[i]);
        if(nCompare)
            return nCompare;
    }

    return 0;
}

HRESULT CBranchingNode::CombineWith(CEvalNode* pRawArg2, int nOp, 
                                    CContextMetaData* pNamespace, 
                                    CImplicationList& Implications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes)
{
    CBranchingNode* pArg2 = (CBranchingNode*)pRawArg2;
    HRESULT hres;

    // Compare arguments for precedence
    // ================================

    int nCompare = ComparePrecedence(this, pArg2);
    if(nCompare < 0)
    {
        // Put pArg1 first and continue
        // ============================

        hres = CombineInOrderWith(pArg2, nOp, 
            pNamespace, Implications, bDeleteThis, bDeleteArg2, ppRes);
    }
    else if(nCompare > 0)
    {
        // Put pArg2 first and continue (reverse delete indicators!!)
        // ==========================================================

        hres = pArg2->CombineInOrderWith(this, FlipEvalOp(nOp), 
            pNamespace, Implications, bDeleteArg2, bDeleteThis, ppRes);
    }
    else
    {
        // They are about the same property. Combine lookup lists.
        // =======================================================

        hres = CombineBranchesWith(pArg2, nOp, pNamespace, Implications, 
                                    bDeleteThis, bDeleteArg2, ppRes);
    }

    return hres;
}

HRESULT CBranchingNode::CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes)
{
    HRESULT hres;
	CBranchingNode* pNew = NULL;

	if(bDeleteThis)
	{
		pNew = this;
	}
	else
	{
		// 
		// I'd like to clone self here, but can't because there is no 
		// such virtual method.  Something to be improved, perhaps
		//

		pNew = (CBranchingNode*)Clone();
		if(pNew == NULL)
			return WBEM_E_OUT_OF_MEMORY;
	}

    try
    {
        CImplicationList Implications(OrigImplications);
        hres = pNew->AdjustCompile(pNamespace, Implications);
        if(FAILED(hres))
        {
            if ( !bDeleteThis )
                delete pNew;
            return hres;
        }
    
        //
        // Maintain a counter telling us whether any invalid branches (that 
        // cannot occur under these implications) were detected.  If so, we 
        // need to re-optimize this node
        //
    
        bool bInvalidBranchesDetected = false;
    
        for(int i = 0; i < m_apBranches.GetSize(); i++)
        {
            CEvalNode* pNewBranch = NULL;
            
            CImplicationList BranchImplications(Implications);
            hres = RecordBranch(pNamespace, BranchImplications, i);
            if(SUCCEEDED(hres))
            {
                // Always delete the branch --- if bDeleteThis, we should, and
                // if not, we cloned it!
    
                hres = CEvalTree::Combine(pNew->m_apBranches[i], pArg2, nOp, 
                    pNamespace, BranchImplications, true, false, &pNewBranch);
                
                if(FAILED(hres))
                {
                    if ( !bDeleteThis )
                        delete pNew;
                    return hres;
                }
                
                pNew->m_apBranches.Discard(i);
            }
            else
            {
                pNewBranch = CValueNode::GetStandardInvalid();
                bInvalidBranchesDetected = true;
            }
            
            pNew->m_apBranches.SetAt(i, pNewBranch);
        }
    
        CEvalNode* pNewBranch = NULL;
        CImplicationList BranchImplications(Implications);
        hres = RecordBranch(pNamespace, BranchImplications, -1);
    
        if(SUCCEEDED(hres))
        {
            //
            // Always delete the branch --- if bDeleteThis, we should, and
            // if not, we cloned it!
            //

            hres = CEvalTree::Combine(pNew->GetNullBranch(), pArg2, nOp, 
                pNamespace, BranchImplications, true, false, &pNewBranch);
            
            if(FAILED(hres))
            {
                if ( !bDeleteThis )
                    delete pNew;
                return hres;
            }
            
            pNew->m_pNullBranch = NULL;
        }
        else
        {
            pNewBranch = CValueNode::GetStandardInvalid();
            bInvalidBranchesDetected = true;
        }
    
        pNew->SetNullBranch(pNewBranch);
    
        if(bDeleteArg2)         
            delete pArg2;
    
        //
        // If invalid branches were cut, re-optimize
        //
    
        if(bInvalidBranchesDetected)
        {
            hres = pNew->Optimize(pNamespace, ppRes);
    
            if ( SUCCEEDED( hres ) && *ppRes != pNew)
                delete pNew;
    
            return hres;
        }
        else
        {
            *ppRes = pNew;
            return WBEM_S_NO_ERROR;
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

BOOL CBranchingNode::AreAllSame(CEvalNode** apNodes, int nSize, 
                                int* pnFoundIndex) 
{
    BOOL bFoundTwo = FALSE;

    *pnFoundIndex = -1;
    CEvalNode* pFound = NULL;    

    for(int i = 0; i < nSize; i++)
    {
        // ignore invalid nodes --- they don't count
        if(CEvalNode::IsInvalid(apNodes[i]))
            continue;

        if(*pnFoundIndex == -1)
        {
            //
            // This is the first valid chils this node has. Record it --- it 
            // might be the only one
            //

            *pnFoundIndex = i;
            pFound = apNodes[i];
        }
        else if(CEvalTree::Compare(apNodes[i], pFound) != 0)
        {
            bFoundTwo = TRUE;
            break;
        }
    }

    return !bFoundTwo;
}

HRESULT CBranchingNode::StoreBranchImplications(CContextMetaData* pNamespace,
                            int nBranchIndex, CEvalNode* pResult)
{
    if(pResult)
    {
        CImplicationList* pBranchImplications = NULL;
        try
        {
            pBranchImplications = new CImplicationList;
            if(pBranchImplications == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

        HRESULT hres = RecordBranch(pNamespace, *pBranchImplications, 
                                        nBranchIndex);
        if(FAILED(hres))
		{
			delete pBranchImplications;
            return hres;
		}

        if(pBranchImplications->IsEmpty())
        {
            // Nothing useful to say!
            delete pBranchImplications;
            pBranchImplications = NULL;
        }

        pResult->SetExtraImplications(pBranchImplications); // acquires
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CBranchingNode::Optimize(CContextMetaData* pNamespace, 
                                CEvalNode** ppNew)
{
    int i;
    HRESULT hres;

    // Optimize all branches
    // =====================

    for(i = 0; i < m_apBranches.GetSize(); i++)
    {
        if(m_apBranches[i])
        {
            CEvalNode* pNew = NULL;
            m_apBranches[i]->Optimize(pNamespace, &pNew);
            if(pNew != m_apBranches[i])
            {
                m_apBranches.SetAt(i, pNew);
            }
        }
    }

    if(CEvalNode::GetType(m_pNullBranch) == EVAL_NODE_TYPE_BRANCH)
    {
        CEvalNode* pNew;
        ((CBranchingNode*)m_pNullBranch)->Optimize(pNamespace, &pNew);
        if(pNew != m_pNullBranch)
        {
            SetNullBranch(pNew);
        }
    }


    // Self-optimize
    // =============

    OptimizeSelf();

    // Count the number of branches
    // ============================

    int nFoundIndex = -1;
    
    BOOL bFoundTwo = !AreAllSame(m_apBranches.GetArrayPtr(), 
        m_apBranches.GetSize(), &nFoundIndex);

    if(bFoundTwo)
    {
        *ppNew = this;
        return WBEM_S_NO_ERROR;
    }

    if(nFoundIndex == -1)
    {

        if(CEvalNode::IsInvalid(m_pNullBranch))
        {
            //
            // Totally invalid, the whole lot
            //

            *ppNew = m_pNullBranch;
            m_pNullBranch = NULL;
        }
        else
        {
            //
            // There are no valid branches, except for the NullBranch.
            // We can replace ourselves with the NullBranch
            //

            *ppNew = m_pNullBranch;
			m_pNullBranch = NULL;

            //
            // Now, we need to copy
            // the branch implications into the "extras".  This is because
            // the information about which branch was taken in this test is
            // critical to the compilation of the lower nodes --- it tells them
            // about the classes of some of our embedded objects.
            //

            hres = StoreBranchImplications(pNamespace, -1, *ppNew);
            if(FAILED(hres))
                return hres;
           
            //
            // since this node is going away, mix in the embedding info it 
            // has with the child node. 
            //

            if ( CEvalNode::GetType(*ppNew) == EVAL_NODE_TYPE_BRANCH )
            {
                CBranchingNode* pBranchNode = (CBranchingNode*)*ppNew;
                if(!pBranchNode->MixInJumps( m_pInfo ))
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else 
    {
        //
        // There is one valid branch in the regular list.  Two hopes: that the
        // NullBranch is invalid, or that it is the same as the only valid 
        // branch in the regular list
        //

        if(CEvalNode::IsInvalid(m_pNullBranch) || 
            CEvalTree::Compare(m_pNullBranch, m_apBranches[nFoundIndex]) == 0)
        {
            //
            // Hurray.  We could replace ourselves with the remaining branch.
            //

            m_apBranches.SetAt(nFoundIndex, NULL, ppNew);

            //
            // Now, we need to copy
            // the branch implications into the "extras".  This is because
            // the information about which branch was taken in this test is
            // critical to the compilation of the lower nodes --- it tells them
            // about the classes of some of our embedded objects.
            //

            hres = StoreBranchImplications(pNamespace, nFoundIndex, *ppNew);
            if(FAILED(hres))
                return hres;

            //
            // since this node is going away, mix in the embedding info it 
            // has with the child node. 
            //

            if ( CEvalNode::GetType(*ppNew) == EVAL_NODE_TYPE_BRANCH )
            {
                CBranchingNode* pBranchNode = (CBranchingNode*)*ppNew;
                if(!pBranchNode->MixInJumps( m_pInfo ))
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            *ppNew = this;
        }
        return WBEM_S_NO_ERROR;
    }
    return WBEM_S_NO_ERROR;
}


void CBranchingNode::Dump(FILE* f, int nOffset)
{
    CNodeWithImplications::Dump(f, nOffset);
    if (m_pInfo)
    {
        PrintOffset(f, nOffset);
        fprintf(f, "Embedding: ");
        m_pInfo->Dump(f);
        fprintf(f, "\n");
    }
}
        


//******************************************************************************
//******************************************************************************
//                         PROPERTY NODE
//******************************************************************************
//******************************************************************************
    
bool CPropertyNode::SetPropertyInfo(LPCWSTR wszPropName, long lPropHandle)
{
    m_lPropHandle = lPropHandle;
    try
    {
        m_wsPropName = wszPropName;
    }
	catch (CX_MemoryException)
	{
		return false;
	}
    return true;
}

int CPropertyNode::ComparePrecedence(CBranchingNode* pOther)
{
    CPropertyNode* pOtherNode = (CPropertyNode*)pOther;
    return m_lPropHandle - pOtherNode->m_lPropHandle;
}

bool CPropertyNode::SetEmbeddingInfo(const CEmbeddingInfo* pInfo)
{
    try
    {
        if ((pInfo == NULL) || (pInfo->IsEmpty()))
        {
            delete m_pInfo;
            m_pInfo = NULL;
        }
        else if (!m_pInfo)
        {
            m_pInfo = new CEmbeddingInfo(*pInfo);
            if(m_pInfo == NULL)
                return false;
        }
        else
            *m_pInfo = *pInfo;
    }
	catch (CX_MemoryException)
	{
		return false;
	}

    return true;
}

HRESULT CPropertyNode::SetNullTest(int nOperator)
{
    if(nOperator == QL1_OPERATOR_EQUALS)
    {
        if(m_apBranches.Add(CValueNode::GetStandardFalse()) < 0)
            return WBEM_E_OUT_OF_MEMORY;

        CEvalNode* pTrue = CValueNode::GetStandardTrue();
        if(pTrue == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        SetNullBranch(pTrue);
    }
    else if(nOperator == QL1_OPERATOR_NOTEQUALS)
    {
        CEvalNode* pTrue = CValueNode::GetStandardTrue();
        if(pTrue == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        if(m_apBranches.Add(pTrue) < 0)
        {
            delete pTrue;
            return WBEM_E_OUT_OF_MEMORY;
        }

        SetNullBranch(CValueNode::GetStandardFalse());
    }
    else
        return WBEM_E_INVALID_QUERY;

    return WBEM_S_NO_ERROR;
}

HRESULT CPropertyNode::SetOperator(int nOperator)
{
    m_apBranches.RemoveAll();

    #define GET_STD_TRUE CValueNode::GetStandardTrue()
    #define GET_STD_FALSE CValueNode::GetStandardFalse()

    #define ADD_STD_TRUE  {CEvalNode* p = GET_STD_TRUE; \
        if(p == NULL) return WBEM_E_OUT_OF_MEMORY; \
        if(m_apBranches.Add(p) < 0) {delete p; return WBEM_E_OUT_OF_MEMORY;}}

    #define ADD_STD_FALSE {CEvalNode* p = GET_STD_FALSE; \
        if(m_apBranches.Add(p) < 0) {delete p; return WBEM_E_OUT_OF_MEMORY;}}
        
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        break;

    case QL1_OPERATOR_NOTEQUALS:
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        break;

    case QL1_OPERATOR_LESS:
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        ADD_STD_FALSE;
        break;
        
    case QL1_OPERATOR_GREATER:
        ADD_STD_FALSE;
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        break;
    
    case QL1_OPERATOR_LESSOREQUALS:
        ADD_STD_TRUE;
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        break;

    case QL1_OPERATOR_GREATEROREQUALS:
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        ADD_STD_TRUE;
        break;

    case QL1_OPERATOR_LIKE:
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        break;

    case QL1_OPERATOR_UNLIKE:
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        break;

    default:
        return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}


//******************************************************************************
//******************************************************************************
//                  STRING PROPERTY NODE
//******************************************************************************
//******************************************************************************

CStringPropNode::CStringPropNode(const CStringPropNode& Other, BOOL bChildren)
    : CFullCompareNode<CInternalString>(Other, bChildren)
{
}

CStringPropNode::~CStringPropNode()
{
}


HRESULT CStringPropNode::Evaluate(CObjectInfo& ObjInfo, 
                                    INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    
    HRESULT hres;
    _IWmiObject* pObj;
    
    hres = GetContainerObject(ObjInfo, &pObj);
    if( S_OK != hres ) 
    {
        return hres;
    }

    // Get the property from the object
    // ================================

    CCompressedString* pcs = CoreGetPropertyString(pObj, m_lPropHandle);
    CInternalString is;
    if(pcs == NULL)
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    is.AcquireCompressedString(pcs);

    // Search for the value
    // ====================

    TTestPointIterator it;
    bool bMatch = m_aTestPoints.Find(is, &it);
    if(bMatch)
        *ppNext = it->m_pAt;
    else if(it == m_aTestPoints.End())
        *ppNext = m_pRightMost;
    else
        *ppNext = it->m_pLeftOf;

    is.Unbind();

    return WBEM_S_NO_ERROR;
}

void CStringPropNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);

    PrintOffset(f, nOffset);
    fprintf(f, "LastPropName = (0x%x)\n", m_lPropHandle);

    for(TConstTestPointIterator it = m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++)
    {
        PrintOffset(f, nOffset);
        if (it != m_aTestPoints.Begin())
        {
            TConstTestPointIterator itPrev(it);
            itPrev--;
            fprintf(f, "%s < ", itPrev->m_Test.GetText());
        }
        fprintf(f, "X < %s\n", it->m_Test.GetText());
        DumpNode(f, nOffset +1, it->m_pLeftOf);

        PrintOffset(f, nOffset);
        fprintf(f, "X = %s\n", it->m_Test.GetText());
        DumpNode(f, nOffset +1, it->m_pAt);
    }

    PrintOffset(f, nOffset);
    if (it != m_aTestPoints.Begin())
    {
        TConstTestPointIterator itPrev(it);
        itPrev--;
        fprintf(f, "X > %s\n", itPrev->m_Test.GetText());
    }
    else
        fprintf(f, "ANY\n");
    DumpNode(f, nOffset+1, m_pRightMost);

    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}

/*****************************************************************************
  CLikeStringPropNode
******************************************************************************/

CLikeStringPropNode::CLikeStringPropNode( const CLikeStringPropNode& Other, 
                                          BOOL bChildren )
: CPropertyNode( Other, bChildren )
{
    m_Like = Other.m_Like;
}

int CLikeStringPropNode::ComparePrecedence( CBranchingNode* pRawOther )
{
    int nCompare = CPropertyNode::ComparePrecedence( pRawOther );
    
    if( nCompare )
    {
        return nCompare;
    }

    CLikeStringPropNode* pOther = (CLikeStringPropNode*)pRawOther;

    return wbem_wcsicmp( m_Like.GetExpression(), pOther->m_Like.GetExpression() );
}

int CLikeStringPropNode::SubCompare( CEvalNode* pRawOther )
{
    int nCompare;

    CLikeStringPropNode* pOther = (CLikeStringPropNode*)pRawOther;

    _DBG_ASSERT( m_apBranches.GetSize() == 2 );
    _DBG_ASSERT( pOther->m_apBranches.GetSize() == 2 );

    nCompare = CEvalTree::Compare( m_apBranches[0], pOther->m_apBranches[0] );

    if ( nCompare )
    {
        return nCompare;
    }

    nCompare = CEvalTree::Compare( m_apBranches[1], pOther->m_apBranches[1] );

    if ( nCompare )
    {
        return nCompare;
    }

    return CEvalTree::Compare( m_pNullBranch, pOther->m_pNullBranch );
}

HRESULT CLikeStringPropNode::Evaluate( CObjectInfo& ObjInfo,
                                       CEvalNode** ppNext )
{
    *ppNext = NULL;

    HRESULT hr;

    //
    // get the string value.
    //

    _IWmiObject* pObj;
    hr = GetContainerObject( ObjInfo, &pObj );

    if( S_OK != hr )
    {
        return hr;
    }

    CCompressedString* pcs = CoreGetPropertyString( pObj, m_lPropHandle );

    //
    // if null, then simply take null branch.
    //

    if( pcs == NULL )
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    CInternalString is;
    is.AcquireCompressedString(pcs);

    WString ws = is;

    //
    // run through like filter.  take branch accordingly. 
    //

    if ( m_Like.Match( ws ) )
    {
        *ppNext = m_apBranches[0];
    }
    else
    {
        *ppNext = m_apBranches[1];
    }

    is.Unbind();

    return WBEM_S_NO_ERROR;
}


HRESULT CLikeStringPropNode::SetTest( VARIANT& v )
{
    if ( V_VT(&v) != VT_BSTR )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    try
    {
        m_Like.SetExpression( V_BSTR(&v) );
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CLikeStringPropNode::CombineBranchesWith( 
                                       CBranchingNode* pRawArg2, 
                                       int nOp, 
                                       CContextMetaData* pNamespace, 
                                       CImplicationList& Implications,
                                       bool bDeleteThis, 
                                       bool bDeleteArg2,
                                       CEvalNode** ppRes )
{
    HRESULT hres;
    *ppRes = NULL;
    
    CLikeStringPropNode* pArg2 = (CLikeStringPropNode*)pRawArg2;
    
    if ( !bDeleteThis )
    {
    	 CLikeStringPropNode* pClone = (CLikeStringPropNode*)Clone();

    	 if ( pClone == NULL )
    	 	return WBEM_E_OUT_OF_MEMORY;
    	 
        return pClone->CombineBranchesWith(
            pRawArg2, nOp, pNamespace, Implications, true, // reuse clone!
            bDeleteArg2, ppRes );
    }

    CEvalNode* pNew = NULL;

    //
    // merge the 'match' branches
    //

    hres = CEvalTree::Combine( m_apBranches[0], pArg2->m_apBranches[0], nOp, 
                               pNamespace, Implications, true, bDeleteArg2, 
                               &pNew );
    
    if(FAILED(hres))
        return hres;

    m_apBranches.Discard( 0 );
    m_apBranches.SetAt( 0, pNew );

    if( bDeleteArg2 )
    {
        pArg2->m_apBranches.Discard( 0 );
    }

    //
    // merge the 'nomatch' branches
    //

    hres = CEvalTree::Combine( m_apBranches[1], pArg2->m_apBranches[1], nOp, 
                               pNamespace, Implications, true, bDeleteArg2, 
                               &pNew );
    
    if(FAILED(hres))
        return hres;

    m_apBranches.Discard( 1 );
    m_apBranches.SetAt( 1, pNew );
   
    if( bDeleteArg2 )
    {
        pArg2->m_apBranches.Discard( 1 );
    }

    //
    // merge the 'null' branches
    //

    hres = CEvalTree::Combine( m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                               pNamespace, Implications, true, bDeleteArg2, 
                               &pNew );
    
    if(FAILED(hres))
        return hres;
    
    m_pNullBranch = pNew;

    if( bDeleteArg2 )
        pArg2->m_pNullBranch = NULL;

    //
    // Delete what needs deleting
    //

    if(bDeleteArg2)
        delete pArg2;
    
    *ppRes = this;
    return WBEM_S_NO_ERROR;
}

HRESULT CLikeStringPropNode::OptimizeSelf()
{
    _DBG_ASSERT( m_apBranches.GetSize() == 2 );

    return WBEM_S_NO_ERROR;
}
        
void CLikeStringPropNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);

    PrintOffset(f, nOffset);
    fprintf(f, "LastPropName = (0x%x)\n", m_lPropHandle);

    PrintOffset( f, nOffset );
    fprintf(f, "Like Expression : %S\n", m_Like.GetExpression() );

    PrintOffset( f, nOffset );
    fprintf(f, "Match : \n" );
    DumpNode(f, nOffset+1, m_apBranches[0] );

    PrintOffset( f, nOffset );
    fprintf(f, "NoMatch : \n" );
    DumpNode(f, nOffset+1, m_apBranches[1] );

    PrintOffset( f, nOffset );
    fprintf(f, "NULL : \n" );
    DumpNode(f, nOffset+1, m_pNullBranch );
}


//******************************************************************************
//******************************************************************************
//                  INHERITANCE NODE
//******************************************************************************
//******************************************************************************

CInheritanceNode::CInheritanceNode() 
    : m_lDerivationIndex(-1),
        m_lNumPoints(0), m_apcsTestPoints(NULL)
{
    // Add a none-of-the-above node
    // ============================

    m_apBranches.Add(CValueNode::GetStandardFalse());
}

CInheritanceNode::CInheritanceNode(const CInheritanceNode& Other, 
                                    BOOL bChildren)
    : CBranchingNode(Other, bChildren), 
        m_lDerivationIndex(Other.m_lDerivationIndex)
{
    m_lNumPoints = Other.m_lNumPoints;
    m_apcsTestPoints = new CCompressedString*[m_lNumPoints];
    if(m_apcsTestPoints == NULL)
        throw CX_MemoryException();

    for(int i = 0; i < m_lNumPoints; i++)
    {
        m_apcsTestPoints[i] = (CCompressedString*)
            _new BYTE[Other.m_apcsTestPoints[i]->GetLength()];

        if(m_apcsTestPoints[i] == NULL)
            throw CX_MemoryException();

        memcpy((void*)m_apcsTestPoints[i],
                (void*)Other.m_apcsTestPoints[i], 
                Other.m_apcsTestPoints[i]->GetLength());
    }
}

/* virtual */ long CInheritanceNode::GetSubType()
{
    return EVAL_NODE_TYPE_INHERITANCE;
}

CInheritanceNode::~CInheritanceNode()
{
	RemoveAllTestPoints();
}

void CInheritanceNode::RemoveAllTestPoints()
{
    for(int i = 0; i < m_lNumPoints; i++)
    {
        delete [] (BYTE*)m_apcsTestPoints[i];
    }
    delete [] m_apcsTestPoints;
	m_apcsTestPoints = NULL;
}

bool CInheritanceNode::SetPropertyInfo(CContextMetaData* pNamespace, 
                                        CPropertyName& PropName)
{
    return SetEmbeddedObjPropName(PropName);
}

HRESULT CInheritanceNode::AddClass(CContextMetaData* pNamespace, 
                                    LPCWSTR wszClassName, CEvalNode* pDestination)
{
    HRESULT hres;

    // Get the class from the namespace
    // ================================

    _IWmiObject* pObj = NULL;
    hres = pNamespace->GetClass(wszClassName, &pObj);
    if(FAILED(hres)) 
        return hres;

    hres = AddClass(pNamespace, wszClassName, pObj, pDestination);
    pObj->Release();
    return hres;
}

HRESULT CInheritanceNode::AddClass(CContextMetaData* pNamespace, 
                                    LPCWSTR wszClassName, _IWmiObject* pClass,
                                    CEvalNode* pDestination)
{
    // Get the number of items in its derivation --- that's the index where we
    // need to look for its name in its children
    // =======================================================================

    ULONG lDerivationIndex;
    HRESULT hRes = CoreGetNumParents(pClass, &lDerivationIndex);
    if (FAILED (hRes))
        return hRes;

    if(m_lDerivationIndex == -1)
    {
        // We don't have a currently set derivation index --- this is the first
        // ====================================================================

        m_lDerivationIndex = lDerivationIndex;
    }
    else if(m_lDerivationIndex != lDerivationIndex)
    {
        // Can't add this class --- derivation index mismatch
        // ==================================================

        return WBEM_E_FAILED;
    }

    // Allocate a compressed string
    // ============================

    int nLength = CCompressedString::ComputeNecessarySpace(wszClassName);
    CCompressedString* pcs = (CCompressedString*)new BYTE[nLength];
    if (pcs)
        pcs->SetFromUnicode(wszClassName);
    else
        return WBEM_E_OUT_OF_MEMORY;

    // Extend the lists by one
    // =======================

    CCompressedString** apcsNewTestPoints = 
        new CCompressedString*[m_lNumPoints+1];
    if (!apcsNewTestPoints)
        return WBEM_E_OUT_OF_MEMORY;

    // Insert it into the list of tests and the list of branches
    // =========================================================

    int i = 0;
    while(i < m_lNumPoints && pcs->CheapCompare(*m_apcsTestPoints[i]) > 0)
    {
        apcsNewTestPoints[i] = m_apcsTestPoints[i];
        i++;
    }

    apcsNewTestPoints[i] = pcs;
    m_apBranches.InsertAt(i+1, pDestination);

    while(i < m_lNumPoints)
    {
        apcsNewTestPoints[i+1] = m_apcsTestPoints[i];
    }
        
    // Set the new list
    // ================

    delete [] m_apcsTestPoints;
    m_apcsTestPoints = apcsNewTestPoints;
    m_lNumPoints++;

    return WBEM_S_NO_ERROR;
}

HRESULT CInheritanceNode::RecordBranch(CContextMetaData* pNamespace, 
                             CImplicationList& Implications, long lBranchIndex)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    if(lBranchIndex == -1)
    {
        // Recording NULL branch
        // =====================

        hres = Implications.ImproveKnownNull(GetEmbeddedObjPropName());
    }
    else if(lBranchIndex == 0)
    {
        // Recording none of the above branch
        // ==================================

        for(int i = 0; i < m_lNumPoints; i++)
        {
            LPWSTR wszClassName = NULL;
            try
            {
                wszClassName = 
                    m_apcsTestPoints[i]->CreateWStringCopy().UnbindPtr();
            }
	        catch (CX_MemoryException)
	        {
                return WBEM_E_OUT_OF_MEMORY;
	        }
           
            if(wszClassName == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CVectorDeleteMe<WCHAR> vdm(wszClassName);

            hres = Implications.ImproveKnownNot(GetEmbeddedObjPropName(), 
                                                wszClassName);
            if(FAILED(hres))
            {
                // Contradicts known information --- fail recording
                // ================================================

                return hres;
            }
        }
    }
    else
    {
        // Normal branch --- record the class
        // ==================================

        BSTR strClassName = m_apcsTestPoints[lBranchIndex - 1]->
                                CreateBSTRCopy();
        _IWmiObject* pObj = NULL;
        hres = pNamespace->GetClass(strClassName, &pObj);
        SysFreeString(strClassName);
        if(FAILED(hres))
            return hres;

        hres = Implications.ImproveKnown(GetEmbeddedObjPropName(), pObj);
        pObj->Release();
    }
    
    return hres;
}

int CInheritanceNode::ComparePrecedence(CBranchingNode* pOther)
{
    CInheritanceNode* pInhOther = (CInheritanceNode*)pOther;
    return (m_lDerivationIndex - pInhOther->m_lDerivationIndex);
}

int CInheritanceNode::SubCompare(CEvalNode* pOther)
{
    CInheritanceNode* pInhOther = (CInheritanceNode*)pOther;
    int nCompare;

    nCompare = m_lDerivationIndex - pInhOther->m_lDerivationIndex;
    if(nCompare)
        return nCompare;

    nCompare = m_lNumPoints - pInhOther->m_lNumPoints;
    if(nCompare)
        return nCompare;

    for(int i = 0; i < m_lNumPoints; i++)
    {
        nCompare = m_apcsTestPoints[i]->CompareNoCase(
                                    *pInhOther->m_apcsTestPoints[i]);
        if(nCompare)
            return nCompare;
    }

    return 0;
}
    
void CInheritanceNode::RemoveTestPoint(int i)
{
    delete [] m_apcsTestPoints[i];
    memcpy((void*)(m_apcsTestPoints + i), 
           (void*)(m_apcsTestPoints + i + 1),
            sizeof(CCompressedString*) * (m_lNumPoints - i - 1));
    m_lNumPoints--;
}

HRESULT CInheritanceNode::OptimizeSelf()
{
    for(int i = 0; i < m_lNumPoints; i++)
    {
        // Compare this branch to the "nothing" branch
        // ===========================================

        if(CEvalNode::IsInvalid(m_apBranches[i+1]) ||
            CEvalTree::Compare(m_apBranches[0], m_apBranches[i+1]) == 0)
        {
            RemoveTestPoint(i);
            m_apBranches.RemoveAt(i+1);
            i--;
            continue;
        }

        // Check if this node is another class check on the same object
        // ============================================================

        if(CEvalNode::GetType(m_apBranches[i+1]) != EVAL_NODE_TYPE_BRANCH)
            continue;
        CBranchingNode* pBranch = (CBranchingNode*)(m_apBranches[i+1]);
        if(pBranch->GetSubType() == EVAL_NODE_TYPE_INHERITANCE &&
            pBranch->GetEmbeddedObjPropName() == GetEmbeddedObjPropName())
        {
            // If the "none-of-the-above" branch of this child is the same
            // as the "none-of-the-above" branch of ourselves, we can replace
            // our "none-of-the-above" branch with this node, since anything
            // that is falling under none-of-the-above now will fall under
            // none-of-the-above of our child (otherwise there is an 
            // optimization flaw in the child). 
            // IMPORTANT: this will no longer be true if we change the 
            // precedence order of inheritance nodes!!!

            if(CEvalTree::Compare(m_apBranches[0], pBranch->GetBranches()[0])
                == 0)
            {
                m_apBranches.SetAt(0, pBranch);
                m_apBranches.GetArrayPtr()[i+1] = NULL;
                m_apBranches.RemoveAt(i+1);
                RemoveTestPoint(i);
                i--;
            }
        }        
    }

    return S_OK;
}

HRESULT CInheritanceNode::Optimize(CContextMetaData* pNamespace, 
                                    CEvalNode** ppNew)
{
    // Delegate to the normal branch optimization process
    // ==================================================

    *ppNew = NULL;
    HRESULT hres = CBranchingNode::Optimize(pNamespace, ppNew);
    if(FAILED(hres) || *ppNew != this)
        return hres;

    // Specific post-processing
    // ========================

    if(m_apBranches.GetSize() == 1)
    {
        // We are reduced to checking for NULL. If our non-NULL branch is
        // talking about the same property, push the test there.
        // ==============================================================

        if (CEvalNode::GetType(m_apBranches[0]) != EVAL_NODE_TYPE_BRANCH)
            return hres;

        CBranchingNode* pBranch = (CBranchingNode*)(m_apBranches[0]);
        if(pBranch && pBranch->GetSubType() == EVAL_NODE_TYPE_INHERITANCE &&
            pBranch->GetEmbeddedObjPropName() == GetEmbeddedObjPropName())
        {
            pBranch->SetNullBranch(m_pNullBranch);
            pBranch->Optimize(pNamespace, ppNew);
            if(*ppNew != pBranch)
                m_apBranches.RemoveAll();
            else
                m_apBranches.GetArrayPtr()[0] = NULL;

            m_pNullBranch = NULL;

            return S_OK;
        }
    }

    return S_OK;
}

HRESULT CInheritanceNode::Evaluate(CObjectInfo& ObjInfo, 
                                    INTERNAL CEvalNode** ppNext)
{
    _IWmiObject* pInst;
    HRESULT hres = GetContainerObject(ObjInfo, &pInst);
    if(FAILED(hres)) return hres;
    if(pInst == NULL)
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    // Get the parent at the right index
    // =================================
    
    CCompressedString* pcs;
    ULONG lNumParents;
    HRESULT hRes = CoreGetNumParents(pInst, &lNumParents);
    if (FAILED(hRes))
        return hRes;
        
    if(lNumParents < m_lDerivationIndex)
    {
        if (m_apBranches.GetSize())
            *ppNext = m_apBranches[0];
        else
            *ppNext = NULL;
        return WBEM_S_NO_ERROR;
    }
    else if(lNumParents == m_lDerivationIndex)
    {
        pcs = CoreGetClassInternal(pInst);
    }
    else
    {        
        pcs = CoreGetParentAtIndex(pInst, m_lDerivationIndex);
    }

    if(pcs == NULL)
    {
        //
        // This class does not even have that long an ancestry --- clearly
        // not derived from any of those
        //

        if (m_apBranches.GetSize())
            *ppNext = m_apBranches[0];
        else
            *ppNext = NULL;

        return WBEM_S_NO_ERROR;
    }

    
    // Search for the value
    // ====================

    long lLeft = -1;
    long lRight = m_lNumPoints;
    while(lRight > lLeft + 1)
    {
        long lMiddle = (lRight + lLeft) >> 1;
        int nCompare = pcs->CheapCompare(*m_apcsTestPoints[lMiddle]);
        if(nCompare < 0)
        {
            lRight = lMiddle;
        }
        else if(nCompare > 0)
        {
            lLeft = lMiddle;
        }
        else
        {
            *ppNext = m_apBranches[lMiddle+1];
            return WBEM_S_NO_ERROR;
        }
    }

    if (m_apBranches.GetSize())
        *ppNext = m_apBranches[0];
    else
        *ppNext = NULL;

    return WBEM_S_NO_ERROR;
}

HRESULT CInheritanceNode::Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
{
    if (!m_pInfo)
    {
        m_pInfo = new CEmbeddingInfo;
        if(m_pInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hres = CompileEmbeddingPortion(pNamespace, Implications, NULL);
    return hres;
}

// Computes preliminary parameters for merging two inheritance nodes at the
// same level --- which children will be used, and how many times.
HRESULT CInheritanceNode::ComputeUsageForMerge(CInheritanceNode* pArg2, 
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
											bool bDeleteThis, bool bDeleteArg2,
											DWORD* pdwFirstNoneCount,
											DWORD* pdwSecondNoneCount,
											bool* pbBothNonePossible)
{
	HRESULT hres;

	*pdwFirstNoneCount = 0;
	*pdwSecondNoneCount = 0;
	*pbBothNonePossible = false;

    try
    {
        CImplicationList Implications(OrigImplications);
    
        BOOL bFirstNonePossible, bSecondNonePossible;
    
        CImplicationList NoneImplications(Implications);
        hres = RecordBranch(pNamespace, NoneImplications, 0);
        if(FAILED(hres))
        {	
            bFirstNonePossible = FALSE;
            bSecondNonePossible = 
                SUCCEEDED(pArg2->RecordBranch(pNamespace, NoneImplications, 0));
        }
        else
        {
            bFirstNonePossible = TRUE;
            hres = pArg2->RecordBranch(pNamespace, NoneImplications, 0);
            if(FAILED(hres))
            {
                // Check if the second one can survive in isolation
                // ================================================
    
                CImplicationList NoneImplications1(Implications);
                bSecondNonePossible = 
                   SUCCEEDED(pArg2->RecordBranch(pNamespace, NoneImplications1, 0));
            }
            else
            {
                bSecondNonePossible = TRUE;
            }
        }
    
        if(bFirstNonePossible && bSecondNonePossible)
        {
            //
            // Both of them will be used at least once: with each other!
            //
    
            *pdwFirstNoneCount = *pdwSecondNoneCount = 1;
            *pbBothNonePossible = true;
        }
    
        //
        // If we are not deleting something, the usage count should be infinite!
        //
    
        if(!bDeleteThis)
            *pdwFirstNoneCount = 0xFFFFFFFF;
        if(!bDeleteArg2)
            *pdwSecondNoneCount = 0xFFFFFFFF;
        //
        // Merge lookup lists
        // 
    
        long lFirstIndex = 0;
        long lSecondIndex = 0;
    
        while(lFirstIndex < m_lNumPoints || lSecondIndex < pArg2->m_lNumPoints)
        {
            //
            // Retrieve the test points from both lists and compare them,
            // taking care of boundary conditions
            //
    
            int nCompare;
            CCompressedString* pcsFirstVal = NULL;
            CCompressedString* pcsSecondVal = NULL;
    
            if(lFirstIndex == m_lNumPoints)
            {
                nCompare = 1;
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
            }
            else if(lSecondIndex == pArg2->m_lNumPoints)
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                nCompare = -1;
            }
            else
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
                nCompare = pcsFirstVal->CheapCompare(*pcsSecondVal);
            }
    
            if(nCompare < 0)
            {
                //
                // At this index is the first value combined with second none
                // 
    
                if(!bDeleteArg2) // not interesting
                {
                    lFirstIndex++;
                    continue;
                }
                if(!bSecondNonePossible)
                {
                    lFirstIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 
                                        lFirstIndex+1)))
                {
                    lFirstIndex++;
                    continue;
                }
                if(FAILED(pArg2->RecordBranch(pNamespace, BranchImplications, 0)))
                {
                    lFirstIndex++;
                    continue;
                }
                
                (*pdwSecondNoneCount)++;
                lFirstIndex++;
            }
            else if(nCompare > 0)
            {
                // At this index is the second value combined with first none
                // ==========================================================
    
                if(!bDeleteThis) // not interesting
                {
                    lSecondIndex++;
                    continue;
                }
    
                if(!bFirstNonePossible)
                {
                    lSecondIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(pArg2->RecordBranch(pNamespace, BranchImplications, 
                                        lSecondIndex+1)))
                {
                    lSecondIndex++;
                    continue;
                }
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 0)))
                {
                    lSecondIndex++;
                    continue;
                }
                
                (*pdwFirstNoneCount)++;
                lSecondIndex++;
            }
            else
            {
                // At this index is the combinations of the ats
                // ============================================
                            
                lFirstIndex++;
                lSecondIndex++;
            }
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	return S_OK;
}


HRESULT CInheritanceNode::CombineBranchesWith(CBranchingNode* pRawArg2, int nOp,
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
                                            bool bDeleteThis, bool bDeleteArg2,
                                            CEvalNode** ppRes)
{
    HRESULT hres;

    CInheritanceNode* pArg2 = (CInheritanceNode*)pRawArg2;

    if(!bDeleteThis && bDeleteArg2)
    {
        // It is easier to combine in the other direction
        // ==============================================

        return pArg2->CombineBranchesWith(this, FlipEvalOp(nOp), pNamespace,
                        OrigImplications, bDeleteArg2, bDeleteThis, ppRes);
    }

    try
    {
        // Either clone or use our node
        // ============================
    
        CInheritanceNode* pNew = NULL;
        if(bDeleteThis)
        {
            pNew = this;
        }
        else
        {
            // Clone this node without cloning the branches.
            // =============================================
    
            pNew = (CInheritanceNode*)CloneSelf();
            if(pNew == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        CImplicationList Implications(OrigImplications);
        hres = pNew->AdjustCompile(pNamespace, Implications);
        if(FAILED(hres))
        {
            if(!bDeleteThis)
                delete pNew;
            return hres;
        }
    
        //
        // Get overall information
        //
    
        DWORD dwFirstNoneCount, dwSecondNoneCount;
        bool bBothNonePossible;
    
        hres = ComputeUsageForMerge(pArg2, pNamespace, Implications, 
                    bDeleteThis, bDeleteArg2,
                    &dwFirstNoneCount, &dwSecondNoneCount,
                    &bBothNonePossible);
        if(FAILED(hres))
        {
            if(!bDeleteThis)
                delete pNew;
            return hres;
        }
    
        bool bFirstNonePossible = (dwFirstNoneCount > 0);
        bool bSecondNonePossible = (dwSecondNoneCount > 0);
    
        //
        // Allocate a new array of test points and a new array of branches.  We 
        // can't use the ones in pNew because we are using some of the 
        // elements in those arrays in this many times and don't want to trample
        // them (since pNew and this might be the same).  Therefore, we create 
        // and fill these arrays outside of the node and then place them into 
        // pNew when we are done.
        //
        // As we delete the child nodes in the Branches array, we will set them
        // to NULL so that we can clear the branch array in the end
        //
    
        CCompressedString** apcsTestPoints = 
            new CCompressedString*[m_lNumPoints + pArg2->m_lNumPoints];                                               
        if(apcsTestPoints == NULL)
        {
            if(!bDeleteThis)
                delete pNew;
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        CUniquePointerArray<CEvalNode> apBranches;
    
        //
        // Merge none-of-the-above branches
        // 
    
        if(bBothNonePossible)
        {
            //
            // They have to be merged
            //
    
            CImplicationList NoneImplications(Implications);
            hres = RecordBranch(pNamespace, NoneImplications, 0);
            if(FAILED(hres))
            {
                if(!bDeleteThis)
                    delete pNew;
                return hres;
            }
            
            hres = pArg2->RecordBranch(pNamespace, NoneImplications, 0);
            if(FAILED(hres))
            {
                if(!bDeleteThis)
                    delete pNew;
                return hres;
            }
    
            //
            // We may delete our None nodes if and only if there predicted usage
            // count (adjusted for usage that has already occurred) is dropping
            // to 0 --- that is, noone will use these nodes further during this
            // merge
            //
    
            CEvalNode* pNone = NULL;
            bool bDeleteFirstBranch = (--dwFirstNoneCount == 0);
            bool bDeleteSecondBranch = (--dwSecondNoneCount == 0);
            hres = CEvalTree::Combine(m_apBranches[0], pArg2->m_apBranches[0], nOp, 
                                pNamespace, NoneImplications, bDeleteFirstBranch, 
                                bDeleteSecondBranch, &pNone);
            
            if ( FAILED( hres ) )
            {
                if(!bDeleteThis)
                    delete pNew;
                return hres;
            }
                
            if(bDeleteSecondBranch)
                pArg2->m_apBranches.Discard(0);
            if(bDeleteFirstBranch)
                m_apBranches.Discard(0);
    
            if(apBranches.Add(pNone) < 0)
            {
                if(!bDeleteThis)
                    delete pNew;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            //
            // Since both none is not possible, we set this branch to FALSE
            //
    
            if(apBranches.Add(NULL) < 0)
            {
                if(!bDeleteThis)
                    delete pNew;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    
        //
        // Merge lookup lists
        // 
    
        long lFirstIndex = 0;
        long lSecondIndex = 0;
        long lNewIndex = 0;
    
        while(lFirstIndex < m_lNumPoints || lSecondIndex < pArg2->m_lNumPoints)
        {
            //
            // Retrieve the test points from both lists and compare them,
            // taking care of boundary conditions
            //
    
            int nCompare;
            CCompressedString* pcsFirstVal = NULL;
            CCompressedString* pcsSecondVal = NULL;
    
            if(lFirstIndex == m_lNumPoints)
            {
                nCompare = 1;
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
            }
            else if(lSecondIndex == pArg2->m_lNumPoints)
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                nCompare = -1;
            }
            else
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
                nCompare = pcsFirstVal->CheapCompare(*pcsSecondVal);
            }
    
            //
            // Compute the branch to be added and its test point
            //
            CEvalNode* pNewBranch = NULL;
            CCompressedString* pcsCurrentVal = NULL;
    
            if(nCompare < 0)
            {
                //
                // At this index is the first value combined with second none
                // 
    
                if(!bSecondNonePossible)
                {
                    lFirstIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 
                                        lFirstIndex+1)))
                {
                    lFirstIndex++;
                    continue;
                }
                pArg2->RecordBranch(pNamespace, BranchImplications, 0);
                
                //
                // We may delete our None nodes if and only if there predicted 
                // usage count (adjusted for usage that has already occurred) is
                // dropping to 0 --- that is, noone will use these nodes further
                // during this merge
                //

                bool bDeleteOtherBranch = (--dwSecondNoneCount == 0);
                hres = CEvalTree::Combine(m_apBranches[lFirstIndex+1], 
                                   pArg2->m_apBranches[0],
                                   nOp, pNamespace, BranchImplications, 
                                   bDeleteThis, bDeleteOtherBranch,
                                   &pNewBranch);
                
                if ( FAILED( hres ) )
                {
                    if(!bDeleteThis)
                        delete pNew;
                    return hres;
                }
                
                if(bDeleteOtherBranch)
                    pArg2->m_apBranches.Discard(0);
                if(bDeleteThis)
                    m_apBranches.Discard(lFirstIndex+1);
    
                pcsCurrentVal = pcsFirstVal;
                lFirstIndex++;
            }
            else if(nCompare > 0)
            {
                // At this index is the second value combined with first none
                // ==========================================================
    
                if(!bFirstNonePossible)
                {
                    lSecondIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(pArg2->RecordBranch(pNamespace, BranchImplications, 
                                        lSecondIndex+1)))
                {
                    lSecondIndex++;
                    continue;
                }
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 0)))
                {
                    lSecondIndex++;
                    continue;
                }
                
                //
                // We may delete our None nodes if and only if there predicted 
                // usage count (adjusted for usage that has already occurred) is
                // dropping to 0 --- that is, noone will use these nodes further
                // during this merge
                //
    
                bool bDeleteThisBranch = (--dwFirstNoneCount == 0);
                hres = CEvalTree::Combine(m_apBranches[0], 
                                   pArg2->m_apBranches[lSecondIndex+1],
                                   nOp, pNamespace, BranchImplications, 
                                   bDeleteThisBranch, bDeleteArg2,
                                   &pNewBranch);
                
                if ( FAILED( hres ) )
                {
                    if(!bDeleteThis)
                        delete pNew;
                    return hres;
                }
    
                if(bDeleteArg2)
                    pArg2->m_apBranches.Discard(lSecondIndex+1);
                if(bDeleteThisBranch)
                    m_apBranches.Discard(0);
    
                pcsCurrentVal = pcsSecondVal;
                lSecondIndex++;
            }
            else
            {
                // At this index is the combinations of the ats
                // ============================================
                
                CImplicationList BranchImplications(Implications);
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 
                                        lFirstIndex+1)))
                {
                    lSecondIndex++;
                    lFirstIndex++;
                    continue;
                }
    
                hres = CEvalTree::Combine(m_apBranches[lFirstIndex+1], 
                                   pArg2->m_apBranches[lSecondIndex+1],
                                   nOp, pNamespace, BranchImplications, 
                                   bDeleteThis, bDeleteArg2,
                                   &pNewBranch);
     
                if ( FAILED( hres ) )
                {
                    if(!bDeleteThis)
                        delete pNew;
                    return hres;
                }
    
                if(bDeleteArg2)
                    pArg2->m_apBranches.Discard(lSecondIndex+1);
                if(bDeleteThis)
                    m_apBranches.Discard(lFirstIndex+1);
    
                pcsCurrentVal = pcsFirstVal; // doesn't matter --- same
                lFirstIndex++;
                lSecondIndex++;
            }
    
            //
            // Add the newely constructed branch
            //
    
            if(apBranches.Add(pNewBranch) < 0)
            {
                if ( !bDeleteThis )
                    delete pNew;
                return WBEM_E_OUT_OF_MEMORY;
            }
            
            //
            // Add the newely constructed test point
            //
    
            apcsTestPoints[lNewIndex] = 
                (CCompressedString*)_new BYTE[pcsCurrentVal->GetLength()];
    
            if(apcsTestPoints[lNewIndex] == NULL)
            {
                if ( !bDeleteThis )
                    delete pNew;
                return WBEM_E_OUT_OF_MEMORY;
            }
            
            memcpy((void*)apcsTestPoints[lNewIndex],
                (void*)pcsCurrentVal, pcsCurrentVal->GetLength());
    
            lNewIndex++;
        }
    
        //
        // Now that we are done with testing, place the test-point array into 
        // pNew
        //
    
        pNew->RemoveAllTestPoints();
        pNew->m_apcsTestPoints = apcsTestPoints;
        pNew->m_lNumPoints = lNewIndex;
    
        //
        // Replace the array of branches that we may have had (guaranteed to 
        // all be NULL, since we were NULLing them out as we went).
        //
    
        pNew->m_apBranches.RemoveAll();
    
        for(int i = 0; i < apBranches.GetSize(); i++)
        {
            pNew->m_apBranches.Add(apBranches[i]);
            apBranches.Discard(i);
        }
                
        //
        // Merge the nulls
        // 
        
        CImplicationList NullImplications(Implications);
        hres = RecordBranch(pNamespace, Implications, -1);
    
        if(SUCCEEDED(hres))
        {
            CEvalNode* pNewBranch = NULL;
            hres = CEvalTree::Combine(m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                        pNamespace, NullImplications, bDeleteThis, bDeleteArg2, 
                        &pNewBranch);
            
            if ( FAILED( hres ) )
            {
                if(!bDeleteThis)
                    delete pNew;
                
                return hres;
            }
    
            //
            // Clear the old new branch, whatever it was, (it has been deleted,
            // if it ever were there at all) and replace it with the new one.
            // 
    
            pNew->m_pNullBranch = pNewBranch;
                
            // Clear deleted branches
            // ======================
    
            if(bDeleteArg2)
                pArg2->m_pNullBranch = NULL;
        }
    
        // Delete Arg2, if needed (reused portions have been nulled out)
        // =============================================================
    
        if(bDeleteArg2)
            delete pArg2;
    
        *ppRes = pNew;
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}


HRESULT CInheritanceNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode)
{
    //
    // There are two choices here: either it is about us, or we are not
    // interested.
    //

    if(pFilter->IsInSet(this))  
    {
        return CBranchingNode::Project(pMeta, Implications, pFilter, eType,
                                        bDeleteThis, ppNewNode);
    }
    else
    {
        if(eType == e_Sufficient)
            *ppNewNode = CValueNode::GetStandardFalse();
        else
        {
            *ppNewNode = CValueNode::GetStandardTrue();
            if(*ppNewNode == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }

        if(bDeleteThis)
            delete this;

        return S_OK;
    }
}

void CInheritanceNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);
    PrintOffset(f, nOffset);
    fprintf(f, "inheritance index %d: (0x%p)\n", m_lDerivationIndex, this);

    for(int i = 0; i < m_lNumPoints; i++)
    {
        WString ws = m_apcsTestPoints[i]->CreateWStringCopy();
        PrintOffset(f, nOffset);
        fprintf(f, "%S->\n", (LPWSTR)ws);
        DumpNode(f, nOffset+1, m_apBranches[i+1]);
    }

    PrintOffset(f, nOffset);
    fprintf(f, "none of the above->\n");
    DumpNode(f, nOffset+1, m_apBranches[0]);

    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}

#ifdef CHECK_TREES
void CBranchingNode::CheckNode(CTreeChecker *pCheck)
{
    pCheck->CheckoffNode(this);

	int nItems = m_apBranches.GetSize();

	for (int i = 0; i < nItems; i++)
    {
        CEvalNode *pNode = m_apBranches[i];

		if (pNode)
			m_apBranches[i]->CheckNode(pCheck);
    }

	if (m_pNullBranch)
		m_pNullBranch->CheckNode(pCheck);
}
#endif

//******************************************************************************
//******************************************************************************
//
//                          OR NODE
// 
//******************************************************************************
//******************************************************************************

void COrNode::operator=(const COrNode& Other)
{
    // Remove all our children
    // =======================

    m_apBranches.RemoveAll();

    // Clone all the branches from the other
    // =====================================

    for(int i = 0; i < Other.m_apBranches.GetSize(); i++)
    {
        CEvalNode* pNewBranch = CloneNode(Other.m_apBranches[i]);

        if(pNewBranch == NULL && Other.m_apBranches[i] != NULL)
            throw CX_MemoryException();

        if(m_apBranches.Add(pNewBranch) < 0)
            throw CX_MemoryException();
    }
}

HRESULT COrNode::CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2,
        CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = NULL;

    // We don't support AND combines on OR nodes
    // =========================================

    if(nOp == EVAL_OP_AND)
        return WBEM_E_CRITICAL_ERROR; 

    // If the other is another OR node, delegate to the iterator
    // =========================================================

    if(CEvalNode::GetType(pArg2) == EVAL_NODE_TYPE_OR)
    {
        return CombineWithOrNode((COrNode*)pArg2, nOp, pNamespace, Implications,
                                    bDeleteThis, bDeleteArg2, ppRes);
    }

    // Make a copy --- the new node will be mostly us
    // ==============================================

    COrNode* pNew = NULL;

    if(!bDeleteThis)
    {
        pNew = (COrNode*)Clone();
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pNew = this;
    }

    // Combining an OR node with a non-OR --- try all branches
    // =======================================================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        // Check if this branch is a good fit for the other node
        // =====================================================

        if(CEvalTree::IsMergeAdvisable(m_apBranches[i], pArg2, Implications) == 
                WBEM_S_NO_ERROR)
        {
            // It is --- merge it in
            // =====================

            CEvalNode* pNewBranch = NULL;
            hres = CEvalTree::Combine(m_apBranches[i], pArg2, nOp,
                                pNamespace, Implications, 
                                bDeleteThis, bDeleteArg2, &pNewBranch);
            if(FAILED(hres))
            {
                if ( !bDeleteThis )
              	delete pNew;
                return hres;
            }

            if(bDeleteThis)
                m_apBranches.Discard(i);

            pNew->m_apBranches.SetAt(i, pNewBranch);
	    *ppRes = pNew;
            return WBEM_S_NO_ERROR;
        }
    }

    // No branch was a good fit --- add the node to our list
    // =====================================================

    if(bDeleteArg2)
    {
        hres = pNew->AddBranch(pArg2);
    }
    else
    {
        CEvalNode* pNode = pArg2->Clone();
        if(pNode == NULL)
        {
            if ( !bDeleteThis )
                delete pNew;
            return WBEM_E_OUT_OF_MEMORY;
        }
        hres = pNew->AddBranch(pNode);
    }

    if(FAILED(hres))
    {
        if ( !bDeleteThis )
            delete pNew;
        return hres;    
    }

    *ppRes = pNew;
    return WBEM_S_NO_ERROR;
}

HRESULT COrNode::AddBranch(CEvalNode* pNewBranch)
{
    // Search for a place in our array of branches
    // ===========================================

    
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        int nCompare = CEvalTree::Compare(pNewBranch, m_apBranches[i]);
        if(nCompare == 0) 
        {
            // Could happen: sometimes we force an OR-merge
            nCompare = -1;
        }

        if(nCompare < 0)
        {
            // pNewBranch comes before this branch, so insert it right here
            // ============================================================

            if(!m_apBranches.InsertAt(i, pNewBranch))
                return WBEM_E_OUT_OF_MEMORY;

            return WBEM_S_NO_ERROR;
        }
    }

    // It is after all branches --- append
    // ===================================

    if(m_apBranches.Add(pNewBranch) < 0)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
            
HRESULT COrNode::CombineWithOrNode(COrNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes)
{
	*ppRes = NULL;
	
    // NOTE: this function may delete THIS in the middle of execution!!
    // ================================================================

    // Combine us with every branch of the other
    // =========================================

    CEvalNode* pCurrent = this;
    bool bDeleteCurrent = bDeleteThis;
    for(int i = 0; i < pArg2->m_apBranches.GetSize(); i++)
    {
        CEvalNode* pNew = NULL;
        HRESULT hres = pCurrent->CombineWith(pArg2->m_apBranches[i], nOp, 
                            pNamespace, Implications, 
                            bDeleteCurrent, bDeleteArg2, &pNew);
        
        if(FAILED(hres))
            return hres;
        
        pCurrent = pNew;

        // At this point, we can safely delete pCurrent if needed --- it's ours
        // ====================================================================

        bDeleteCurrent = TRUE;

        // If pArg2's branch has been deleted, reset it
        // ============================================

        if(bDeleteArg2)
            pArg2->m_apBranches.Discard(i);
    }

    *ppRes = pCurrent;

    if(bDeleteArg2)
        delete pArg2;
    
    return WBEM_S_NO_ERROR;
}
        

int COrNode::Compare(CEvalNode* pOther)
{
    COrNode* pOtherNode = (COrNode*)pOther;

    // Compare array sizes
    // ===================

    if(m_apBranches.GetSize() != pOtherNode->m_apBranches.GetSize())
        return m_apBranches.GetSize() - pOtherNode->m_apBranches.GetSize();

    // Compare individual nodes
    // ========================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        int nCompare = CEvalTree::Compare(m_apBranches[i], 
                                        pOtherNode->m_apBranches[i]);
        if(nCompare != 0)
            return nCompare;
    }

    return 0;
}


DWORD COrNode::ApplyPredicate(CLeafPredicate* pPred)
{
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if (m_apBranches[i])
            m_apBranches[i]->ApplyPredicate(pPred);
    }
    return WBEM_DISPOSITION_NORMAL;
}

HRESULT COrNode::Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // First, optimize all its branches
    // ================================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        CEvalNode* pNew = NULL;
        if (m_apBranches[i])
        {
            hres = m_apBranches[i]->Optimize(pNamespace, &pNew);
            if(FAILED(hres))
                return hres;
        }

        if(pNew != m_apBranches[i])
        {
            // Replace, but check for emptiness first
            // ======================================

            if(!CEvalNode::IsAllFalse(pNew))
                m_apBranches.SetAt(i, pNew);
            else
            {
                delete pNew;
                m_apBranches.RemoveAt(i);
                i--;
            }
        }
    }

    if(m_apBranches.GetSize() == 0)
    {
        // We have no branches --- equivalent to no successes
        // ==================================================

        *ppNew = CValueNode::GetStandardFalse();
        return WBEM_S_NO_ERROR;
    }
    else if(m_apBranches.GetSize() == 1)
    {
        // One branch --- equivalent to that branch
        // ========================================

        m_apBranches.RemoveAt(0, ppNew);
    }
    else 
    {
        *ppNew = this;
    }
    return WBEM_S_NO_ERROR;
}

void COrNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);
    fprintf(f, "FOREST\n");

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if (m_apBranches[i])
            m_apBranches[i]->Dump(f, nOffset+1);
        else
            fprintf(f, "all false ValueNode (or error?)\n");
    }
}

HRESULT COrNode::Evaluate(CObjectInfo& Info, CSortedArray& trueIDs)
{
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if (m_apBranches[i])
        {
            HRESULT hres = CEvalTree::Evaluate(Info, m_apBranches[i], trueIDs);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT COrNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode)
{
	*ppNewNode = NULL;
	
    COrNode* pNew;
    if(bDeleteThis)
        pNew = this;
    else
        pNew = (COrNode*)Clone();

    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Simply project all the branches
    //

    for(int i = 0; i < pNew->m_apBranches.GetSize(); i++)
    {
        CEvalNode* pProjected = NULL;

        HRESULT hres = CEvalTree::Project(pMeta, Implications, 
                            pNew->m_apBranches[i], pFilter, eType,
                            true, // always delete --- has been cloned
                            &pProjected);
        if(FAILED(hres))
            return hres;

        pNew->m_apBranches.Discard(i);
        pNew->m_apBranches.SetAt(i, pProjected);
    }

    *ppNewNode = pNew;
    return S_OK;
}
    
            

//******************************************************************************
//******************************************************************************
//                  PREDICATES
//******************************************************************************
//******************************************************************************

// NOTE: Not checking for NULL leaves, should be checked by caller
DWORD CEvalTree::CRemoveIndexPredicate::operator()(CValueNode* pLeaf)
{
    if(pLeaf)
    {
        pLeaf->RemoveQueryID(m_nIndex);
        if(pLeaf->GetNumTrues() == 0)
            return WBEM_DISPOSITION_FLAG_DELETE;
    }
    return WBEM_DISPOSITION_NORMAL;
}

// NOTE: Not checking for NULL leaves, should be checked by caller
DWORD CEvalTree::CRebasePredicate::operator()(CValueNode* pLeaf)
{
    if(pLeaf)
        pLeaf->Rebase(m_newBase);
    return WBEM_DISPOSITION_NORMAL;
}

// NOTE: Not checking for NULL leaves, should be checked by caller
DWORD CEvalTree::CRemoveFailureAtIndexPredicate::operator()(CValueNode* pLeaf)
{
    if(pLeaf == NULL || pLeaf->GetAt(m_nIndex) != EVAL_VALUE_TRUE)
        return WBEM_DISPOSITION_FLAG_INVALIDATE;
    
    pLeaf->RemoveQueryID(m_nIndex);
    if(pLeaf->GetNumTrues() == 0)
        return WBEM_DISPOSITION_FLAG_DELETE;

    return WBEM_DISPOSITION_NORMAL;
}

//******************************************************************************
//******************************************************************************
//                  EVALUATION TREE
//******************************************************************************
//******************************************************************************

CEvalTree::CEvalTree() 
    : m_lRef(0), m_pStart(NULL), m_nNumValues(0)
{
#ifdef CHECK_TREES
	g_treeChecker.AddTree(this);
#endif
}

CEvalTree::CEvalTree(const CEvalTree& Other) 
    : m_lRef(0), m_pStart(NULL), m_nNumValues(0)
{
#ifdef CHECK_TREES
	g_treeChecker.AddTree(this);
#endif

    *this = Other;
}
        
CEvalTree::~CEvalTree() 
{
#ifdef CHECK_TREES
	g_treeChecker.RemoveTree(this);
#endif

	delete m_pStart;
}


bool CEvalTree::SetBool(BOOL bVal)
{
    CInCritSec ics(&m_cs);

    delete m_pStart;
    CValueNode* pNode;
    
    if (bVal)
    {
        pNode = CValueNode::GetStandardTrue();
        if(pNode == NULL)
            return false;
    }
    else
        pNode = CValueNode::GetStandardFalse();
    
    m_pStart = pNode;
    m_nNumValues = 1;
    if(!m_ObjectInfo.SetLength(1))
        return false;

    return true;
}

bool CEvalTree::IsFalse()
{
    return (m_pStart == NULL);
}

bool CEvalTree::IsValid()
{
    return !CEvalNode::IsInvalid(m_pStart);
}

int CEvalTree::Compare(CEvalNode* pArg1, CEvalNode* pArg2)
{
    if(pArg1 == NULL)
    {
        if(pArg2 == NULL)
            return 0;
        else
            return 1;
    }
    else if(pArg2 == NULL)
        return -1;
    else if(CEvalNode::GetType(pArg1) != CEvalNode::GetType(pArg2))
        return CEvalNode::GetType(pArg1) - CEvalNode::GetType(pArg2);
    else return pArg1->Compare(pArg2);
}


HRESULT CEvalTree::CreateFromQuery(CContextMetaData* pNamespace, 
                            LPCWSTR wszQuery, long lFlags, long lMaxTokens)
{
    CTextLexSource src((LPWSTR)wszQuery);
    QL1_Parser parser(&src);
    QL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    int nRes = parser.Parse(&pExp);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> deleteMe(pExp);

    if (nRes)
        return WBEM_E_INVALID_QUERY;
 
    HRESULT hres = CreateFromQuery(pNamespace, pExp, lFlags, lMaxTokens);
    return hres;
}
    
HRESULT CEvalTree::CreateFromQuery(CContextMetaData* pNamespace, 
           QL_LEVEL_1_RPN_EXPRESSION* pQuery, long lFlags, long lMaxTokens)
{
    return CreateFromQuery(pNamespace, pQuery->bsClassName, pQuery->nNumTokens,
                            pQuery->pArrayOfTokens, lFlags, lMaxTokens);
}

HRESULT CEvalTree::CreateFromQuery(CContextMetaData* pNamespace, 
           LPCWSTR wszClassName, int nNumTokens, QL_LEVEL_1_TOKEN* apTokens,
           long lFlags, long lMaxTokens)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    // Create basic implication list
    // =============================

    _IWmiObject* pObj = NULL;
    hres = pNamespace->GetClass(wszClassName, &pObj);
    if(FAILED(hres))
    {
        return hres;
    }

	CReleaseMe rm1(pObj);

    try
    {
        CImplicationList Implications(lFlags);
        CPropertyName EmptyName;
        Implications.ImproveKnown(&EmptyName, pObj);
    
    #ifdef CHECK_TREES
        CheckTrees();
    #endif
        
        CEvalNode* pWhere = NULL;
    
        if(nNumTokens)
        {
            // Convert the token list to DNF
            // =============================
    
            CDNFExpression DNF;
            QL_LEVEL_1_TOKEN* pEnd = apTokens + nNumTokens - 1;
            hres = DNF.CreateFromTokens(pEnd, 0, lMaxTokens);
			if(FAILED(hres))
				return hres;

            if(pEnd != apTokens - 1)
            {
                return WBEM_E_CRITICAL_ERROR;
            }
            DNF.Sort();
    
            // Build a tree for the token list
            // ===============================
    
            hres = CreateFromDNF(pNamespace, Implications, &DNF, &pWhere);
    
            if(FAILED(hres))
            {
                return hres;
            }
        }
        else
        {
            pWhere = CValueNode::GetStandardTrue();
            if(pWhere == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        // Add inheritance check
        // =====================
    
        CInheritanceNode* pInhNode = new CInheritanceNode;
        if (!pInhNode)
            return WBEM_E_OUT_OF_MEMORY;
    
        hres = pInhNode->AddClass(pNamespace, wszClassName, (_IWmiObject*)pObj, 
                                    pWhere);
        if(FAILED(hres))
        {
            delete pWhere;
            delete pInhNode;
            return hres;
        }
    
        if(!m_ObjectInfo.SetLength(Implications.GetRequiredDepth()))
        {
            delete pInhNode;
            return WBEM_E_OUT_OF_MEMORY;
        }
            
        delete m_pStart;
        m_pStart = pInhNode;
        m_nNumValues = 1;
    
    #ifdef CHECK_TREES
        CheckTrees();
    #endif
    
        Optimize(pNamespace);
    
    #ifdef CHECK_TREES
        CheckTrees();
    #endif
    
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

// extension of BuildFromToken to build nodes that have two properties
// e.g. this would service "select * from class where prop1 < prop2"
HRESULT CEvalTree::BuildTwoPropFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes)
{
    HRESULT hres;
    
    CEmbeddingInfo leftInfo, rightInfo;
    if(!leftInfo.SetPropertyNameButLast(Token.PropertyName))
        return WBEM_E_OUT_OF_MEMORY;
    if(!rightInfo.SetPropertyNameButLast(Token.PropertyName2))
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject* pLeftClass;
    hres = leftInfo.Compile(pNamespace, Implications, &pLeftClass);
    if(FAILED(hres))
        return hres;
    if(pLeftClass == NULL)
        return WBEMESS_E_REGISTRATION_TOO_BROAD;

    _IWmiObject* pRightClass;
    hres = rightInfo.Compile(pNamespace, Implications, &pRightClass);
    if(FAILED(hres))
        return hres;
    if(pRightClass == NULL)
    {
        pLeftClass->Release();
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }


    // Get the property types and handles
    // ==================================

    LPCWSTR wszLeftPropName = Token.PropertyName.GetStringAt(
        Token.PropertyName.GetNumElements() - 1);
    LPCWSTR wszRightPropName = Token.PropertyName2.GetStringAt(
        Token.PropertyName2.GetNumElements() - 1);

    CIMTYPE ctLeft, ctRight;
    long lLeftPropHandle, lRightPropHandle;
    hres = pLeftClass->GetPropertyHandleEx(wszLeftPropName, 0L, &ctLeft, 
                                            &lLeftPropHandle);
    pLeftClass->Release();  
    if(FAILED(hres)) return hres;   
    hres = pRightClass->GetPropertyHandleEx(wszRightPropName, 0L, &ctRight, 
                                            &lRightPropHandle);
    pRightClass->Release();  
    if(FAILED(hres)) return hres;   

    if(    ((ctLeft & CIM_FLAG_ARRAY) != 0) || (ctLeft == CIM_OBJECT)
        || ((ctRight & CIM_FLAG_ARRAY) != 0) || (ctRight == CIM_OBJECT) )
        return WBEM_E_NOT_SUPPORTED;

    // if the type of either node is reference or date, go to dumb
    if (  (ctLeft == CIM_DATETIME)   ||
          (ctLeft == CIM_REFERENCE)   ||
          (ctRight == CIM_DATETIME) ||
          (ctRight == CIM_REFERENCE) 
       )
    {
        if(ctLeft != ctRight)
            return WBEM_E_TYPE_MISMATCH;

        CDumbNode* pDumb = NULL;
        try
        {
            pDumb = new CDumbNode(Token);
            if(pDumb == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

        hres = pDumb->Validate(pLeftClass);
        if(FAILED(hres))
        {
            delete pDumb;
            return hres;
        }
        
        *ppRes = pDumb;
        return WBEM_S_NO_ERROR;
    }
    
    // if the node is mismatched (different types in either node)
    // we'll want to create the most flexible node needed to hold both types
    CIMTYPE ctNode = ctLeft;

    CPropertyNode* pNode = NULL;

    try
    {
        bool bMismatchedNode = (ctLeft != ctRight);
        if (bMismatchedNode)
        {
            // we'll be real forgiving about strings matching strings
            if (  (ctLeft == CIM_STRING)    ||
                  (ctRight == CIM_STRING)
               )
               pNode = new CTwoMismatchedStringNode;
            else if ( (ctRight == CIM_REAL32) ||
                      (ctRight == CIM_REAL64)  ||
                      (ctLeft  == CIM_REAL32) ||
                      (ctLeft  == CIM_REAL64)
                    )
                pNode = new CTwoMismatchedFloatNode;
            else if ( (ctLeft  == CIM_UINT64)  ||
                      (ctRight == CIM_UINT64)
                    )
                pNode = new CTwoMismatchedUInt64Node;
            else if ( (ctLeft  == CIM_SINT64 ) ||
                      (ctRight == CIM_SINT64 )
                    )
                pNode = new CTwoMismatchedInt64Node;
            else if ( (ctRight == CIM_UINT32)  ||
                      (ctLeft  == CIM_UINT32)
                    )
                pNode = new CTwoMismatchedUIntNode;
            else 
                pNode = new CTwoMismatchedIntNode;           
        }
        else
        // not mistmatched - go with the exact type
        {
            // Create the Proper node
            // =====================
    
            switch(ctNode)
            {
            case CIM_SINT8:
                pNode = new TTwoScalarPropNode<signed char>;
                break;
            case CIM_UINT8:
                pNode = new TTwoScalarPropNode<unsigned char>;
                break;
            case CIM_SINT16:
                pNode = new TTwoScalarPropNode<short>;
                break;
            case CIM_UINT16:
            case CIM_CHAR16:
                pNode = new TTwoScalarPropNode<unsigned short>;
                break;
            case CIM_SINT32:
                pNode = new TTwoScalarPropNode<long>;
                break;
            case CIM_UINT32:
                pNode = new TTwoScalarPropNode<unsigned long>;
                break;
            case CIM_SINT64:
                pNode = new TTwoScalarPropNode<__int64>;
                break;
            case CIM_UINT64:
                pNode = new TTwoScalarPropNode<unsigned __int64>;
                break;
            case CIM_REAL32:
                pNode = new TTwoScalarPropNode<float>;
                break;
            case CIM_REAL64:
                pNode = new TTwoScalarPropNode<double>;
                break;
            case CIM_BOOLEAN:
                pNode = new TTwoScalarPropNode<VARIANT_BOOL>;
                break;
            case CIM_STRING:
                pNode = new CTwoStringPropNode;
                break;
            case CIM_DATETIME:
            case CIM_REFERENCE:
                {
                    CDumbNode* pDumb = new CDumbNode(Token);
                    hres = pDumb->Validate(pLeftClass);
                    if(FAILED(hres))
                    {
                        delete pDumb;
                        return hres;
                    }
                    else
                    {
                        *ppRes = pDumb;
                        return WBEM_S_NO_ERROR;
                    }
                }
                return WBEM_S_NO_ERROR;
            default:
                return WBEM_E_CRITICAL_ERROR;
            }
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    if (!pNode)
        return WBEM_E_OUT_OF_MEMORY;

    if(!pNode->SetEmbeddingInfo(&leftInfo))
        return WBEM_E_OUT_OF_MEMORY;
        
    if(!pNode->SetPropertyInfo(wszLeftPropName, lLeftPropHandle))
        return WBEM_E_OUT_OF_MEMORY;

    ((CTwoPropNode*)pNode)->SetRightEmbeddingInfo(&rightInfo);
    ((CTwoPropNode*)pNode)->SetRightPropertyInfo(wszRightPropName, 
                                                    lRightPropHandle);

    hres = pNode->SetOperator(Token.nOperator);
    if(FAILED(hres))
        return hres;

    *ppRes = pNode;
    return WBEM_S_NO_ERROR;
}
    

HRESULT CEvalTree::BuildFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes)
{
    HRESULT hres;

    *ppRes = NULL;
    
    if (Token.m_bPropComp)
    {
        hres = BuildTwoPropFromToken(pNamespace, Implications, Token, ppRes);
        if(hres == WBEMESS_E_REGISTRATION_TOO_BROAD ||
			hres == WBEM_E_INVALID_PROPERTY)
        {
            //
            // Not enough information to use efficient evaluation
            //

            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }

            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
        else 
            return hres;
    }
            

    //
    // Retrieve event class definition
    //

    _IWmiObject* pEventClass;
    hres = Implications.FindClassForProp(NULL, 0, &pEventClass);
    if(FAILED(hres))
        return hres;
    if(pEventClass == NULL)
        return WBEM_E_INVALID_QUERY;
    CReleaseMe rm1((IWbemClassObject*)pEventClass);

    if(Token.nOperator == QL1_OPERATOR_ISA)
    {
        //
        // Inheritance node are rarely applicable in Nova --- we have no way
        // of telling *which definition* of the class is being referenced. Thus,
        // we only construct an inheritance node in one case --- where the 
        // embedded object in question is a property of an instance operation
        // event.  These we trust.
        //

        if(pEventClass->InheritsFrom(L"__InstanceOperationEvent") == S_OK)
        {
            // 
            // OK, can use an inheritance node
            //

            if(V_VT(&Token.vConstValue) != VT_BSTR)
                return WBEM_E_INVALID_QUERY;
            BSTR strClassName = V_BSTR(&Token.vConstValue);
    
            CInheritanceNode* pNode = NULL;
            try
            {
                pNode = new CInheritanceNode;
                if (!pNode)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }
    
            CDeleteMe<CInheritanceNode> deleteMe(pNode);
            
            CEvalNode* pTrue = CValueNode::GetStandardTrue();
            if(pTrue == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            hres = pNode->AddClass(pNamespace, strClassName, pTrue);
            if(FAILED(hres))
                return hres;
    
            if(!pNode->SetPropertyInfo(pNamespace, Token.PropertyName))
                return WBEM_E_OUT_OF_MEMORY;
               
            hres = pNode->Compile(pNamespace, Implications);
            if(FAILED(hres))
                return hres;
    
            // Record the fact that TRUE branch is being taken
            // ===============================================
            pNode->RecordBranch(pNamespace, Implications, 1);
    
            // in the event that we made it this far,
            // we no longer WANT to delete node
            deleteMe = NULL;
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
        else
        {
            //
            // May not use an inheritance node --- use a dumb one instead
            //

            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }

            hres = pNode->Validate(pEventClass);
            if(FAILED(hres))
            {
                delete pNode;
                return hres;
            }
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
    }
    else 
    {
        //
        // Attempt to compile the embedding portion.  This will only succeed if
        // the rest of the query implies enough information for us to know
        // exactly what class the embedded object is
        // 

        CEmbeddingInfo Info;
        if(!Info.SetPropertyNameButLast(Token.PropertyName))
            return WBEM_E_OUT_OF_MEMORY;

        _IWmiObject* pClass;
        hres = Info.Compile(pNamespace, Implications, &pClass);
        if(hres == WBEMESS_E_REGISTRATION_TOO_BROAD || 
			hres == WBEM_E_INVALID_PROPERTY || // invalid or not yet known?
			pClass == NULL)
        {
            //
            // Not enough information --- have to use the dumb node
            //
            
            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }
        
            hres = pNode->Validate(pEventClass);
            if(FAILED(hres))
            {
                delete pNode;
                return hres;
            }
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
   
        if(FAILED(hres))
            return hres;

        //
        // We do know the class definition.  Check if this is a system property,
        // though, in which case we still have toi use a dumb node
        //

        LPCWSTR wszPropName = Token.PropertyName.GetStringAt(
            Token.PropertyName.GetNumElements() - 1);

        if(wszPropName == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        if(wszPropName[0] == '_')
        {
            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }

            hres = pNode->Validate(pEventClass);
            if(FAILED(hres))
            {
                delete pNode;
                return hres;
            }
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
            
        // Get the property type and handle
        // ================================

        CIMTYPE ct;
        long lPropHandle;
        hres = pClass->GetPropertyHandleEx(wszPropName, 0L, &ct, &lPropHandle);
        pClass->Release();  
        if(FAILED(hres)) return hres;   
    
        if(((ct & CIM_FLAG_ARRAY) != 0) || (ct == CIM_OBJECT))
            return WBEM_E_NOT_SUPPORTED;

        // Coerce the constant to the right type
        // =====================================

        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);
        if(V_VT(&Token.vConstValue) != VT_NULL)
        {
            hres = ChangeVariantToCIMTYPE(&v, &Token.vConstValue, ct);
            if(FAILED(hres)) return hres;
        }
        else
        {
            V_VT(&v) = VT_NULL;
        }

        
        //
        // Create the right node
        //

        CPropertyNode* pNode = NULL;
        
        try
        {
            if ( Token.nOperator != QL1_OPERATOR_LIKE &&
                 Token.nOperator != QL1_OPERATOR_UNLIKE )
            {
                switch(ct)
                {
                case CIM_SINT8:
                    pNode = new CScalarPropNode<signed char>;
                    break;
                case CIM_UINT8:
                    pNode = new CScalarPropNode<unsigned char>;
                    break;
                case CIM_SINT16:
                    pNode = new CScalarPropNode<short>;
                    break;
                case CIM_UINT16:
                case CIM_CHAR16:
                    pNode = new CScalarPropNode<unsigned short>;
                    break;
                case CIM_SINT32:
                    pNode = new CScalarPropNode<long>;
                    break;
                case CIM_UINT32:
                    pNode = new CScalarPropNode<unsigned long>;
                    break;
                case CIM_SINT64:
                    pNode = new CScalarPropNode<__int64>;
                    break;
                case CIM_UINT64:
                    pNode = new CScalarPropNode<unsigned __int64>;
                    break;
                case CIM_REAL32:
                    pNode = new CScalarPropNode<float>;
                    break;
                case CIM_REAL64:
                    pNode = new CScalarPropNode<double>;
                    break;
                case CIM_BOOLEAN:
                    pNode = new CScalarPropNode<VARIANT_BOOL>;
                    break;
                case CIM_STRING:
                    pNode = new CStringPropNode;
                    break;
                case CIM_DATETIME:
                case CIM_REFERENCE:
                    {
                        CDumbNode* pDumb = new CDumbNode(Token);
                        if(pDumb == NULL)
                        return WBEM_E_OUT_OF_MEMORY;

                        hres = pDumb->Validate(pEventClass);
                        if(FAILED(hres))
                        {
                            delete pDumb;
                            return hres;
                        }
                        else
                        {
                            *ppRes = pDumb;
                            return WBEM_S_NO_ERROR;
                        }
                    }
                default:
                    return WBEM_E_CRITICAL_ERROR;
                }
            }
            else
            {
                if ( V_VT(&v) != VT_BSTR )
                    return WBEM_E_INVALID_QUERY;

                pNode = new CLikeStringPropNode;
            }
        }            
        catch (CX_MemoryException)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if (!pNode)
            return WBEM_E_OUT_OF_MEMORY;

        if(!pNode->SetEmbeddingInfo(&Info))
        {
            delete pNode;
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(!pNode->SetPropertyInfo(wszPropName, lPropHandle))
        {
            delete pNode;
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(V_VT(&v) == VT_NULL)
        {
            pNode->SetNullTest(Token.nOperator);
        }
        else
        {
            //
            // Check if the operator makes sense for the type
            //

            if(ct == CIM_BOOLEAN &&
                (Token.nOperator != QL1_OPERATOR_EQUALS &&
                    Token.nOperator != QL1_OPERATOR_NOTEQUALS))
            {
                // No < > for booleans
                return WBEM_E_INVALID_QUERY;
            }

            hres = pNode->SetOperator(Token.nOperator);
            if(FAILED(hres))
                return hres;
            
            hres = pNode->SetTest(v);
            if(FAILED(hres))
                return hres;
        }

        *ppRes = pNode;
        return WBEM_S_NO_ERROR;
    }
}
        
        
HRESULT CEvalTree::Combine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hres;

    try
    {
        //
        // Apply the extra implications of the nodes being combined
        //
    
        CImplicationList* pArg1List = NULL;
        if(pArg1 && pArg1->GetExtraImplications())
        {
            pArg1List = new CImplicationList(*pArg1->GetExtraImplications(), 
                                                    false);
            if(pArg1List == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
        CDeleteMe<CImplicationList> dm1(pArg1List);
    
        CImplicationList* pArg2List = NULL;
        if(pArg2 && pArg2->GetExtraImplications())
        {
            pArg2List = new CImplicationList(*pArg2->GetExtraImplications(), 
                                                false);
            if(pArg2List == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        CDeleteMe<CImplicationList> dm2(pArg2List);
    
        if(pArg1List || pArg2List)
        {
            CImplicationList TheseImplications(Implications);
    
            if(pArg1List)
            {
                hres = TheseImplications.MergeIn(pArg1List);
                if(FAILED(hres))
                    return hres;
            }
    
            if(pArg2List)
            {
                hres = TheseImplications.MergeIn(pArg2List);
                if(FAILED(hres))
                    return hres;
            }
    
            //
            // Call inner combine to do everything but the implications
            //
        
            hres = InnerCombine(pArg1, pArg2, nOp, pNamespace, 
                                        TheseImplications,
                                        bDeleteArg1, bDeleteArg2, ppRes);
        }
        else
        {
            //
            // Call inner combine to do everything but the implications
            //
        
            hres = InnerCombine(pArg1, pArg2, nOp, pNamespace, Implications,
                                        bDeleteArg1, bDeleteArg2, ppRes);
        }
    
        if(FAILED(hres))
            return hres;
    
        //
        // The implication of the combined node is the combination of the 
        // individual node implications.  It does not matter what the operation 
        // is: by the time we have arrived here, we have arrived to these 
        // respective
        // points in the individual trees, so the implications have commenced.
        // OK, I am convinced :-)
        //
    
        if(*ppRes)
        {
            CImplicationList* pResultList = NULL;
        
            if(pArg1List || pArg2List)
            {
                // 
                // There is actually some implication info in one of them --- 
                // merge them
                //
            
                if(pArg1List == NULL)
                {
                    pResultList = new CImplicationList(*pArg2List, false); 
                    if(pResultList == NULL)
                        return WBEM_E_OUT_OF_MEMORY;
                }
                else 
                {
                    pResultList = new CImplicationList(*pArg1List, false); 
                    if(pResultList == NULL)
                        return WBEM_E_OUT_OF_MEMORY;
                    if(pArg2List != NULL)
                    {
                        hres = pResultList->MergeIn(pArg2List);
                        if(FAILED(hres))
                        {
                            delete pResultList;
                            return hres;
                        }
                    }
                }
        
            }
        
            return (*ppRes)->SetExtraImplications(pResultList); // acquires
        }
        else
            return S_OK;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::InnerCombine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = NULL;

    if ((pArg1 == NULL) && (pArg2 == NULL))
        return WBEM_S_NO_ERROR;

	if(CEvalNode::IsInvalid(pArg1) || CEvalNode::IsInvalid(pArg2))
	{
		// 
		// Invalid branches cannot be taken, so the result is invalid
		//

		*ppRes = CValueNode::GetStandardInvalid();
        if(bDeleteArg1)
            delete pArg1;
        if(bDeleteArg2)
            delete pArg2;
		return S_OK;
	}

    int arg1Type = CEvalNode::GetType(pArg1);
    int arg2Type = CEvalNode::GetType(pArg2);

    // Check if merging the nodes is called for
    // ========================================

    if(nOp != EVAL_OP_AND && 
        IsMergeAdvisable(pArg1, pArg2, Implications) != WBEM_S_NO_ERROR)
    {
        // Create an OR node instead
        // =========================

        COrNode* pNew = NULL;
        try
        {
            pNew = new COrNode;
            if(pNew == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

        if(bDeleteArg1)
        {
            hres = pNew->AddBranch(pArg1);
        }
        else
        {
            CEvalNode* pClone = pArg1->Clone();
            if(pClone == NULL)
            {
                delete pNew;
                return WBEM_E_OUT_OF_MEMORY;
            }
            hres = pNew->AddBranch(pClone);
        }
        
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }
        
        if(bDeleteArg2)
        {
            hres = pNew->AddBranch(pArg2);
        }
        else
        {
            CEvalNode* pClone = pArg2->Clone();
            if(pClone == NULL)
            {
                delete pNew;
                return WBEM_E_OUT_OF_MEMORY;
            }
            hres = pNew->AddBranch(pClone);
        }
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }

        *ppRes = pNew;
        return WBEM_S_NO_ERROR;
    }
        
    // Delegate same-type operations to the type
    // =========================================


    if(arg1Type == arg2Type)
    {
        if ( ((pArg1 == NULL) || (pArg2 == NULL))
        // well, gosh - if we've already decided they're the same type, no reason for redundant checks...
         && (arg1Type == EVAL_NODE_TYPE_VALUE))
        {
            if(nOp == EVAL_OP_AND)
            {
                // FALSE AND anything is FALSE
                // ===========================

                *ppRes = NULL;
                if(bDeleteArg1)
                    delete pArg1;
                if(bDeleteArg2)
                    delete pArg2;

                return WBEM_S_NO_ERROR;
            }

            // FALSE combined in any other way with anything is that thing
            // ===========================================================

            if (pArg1)
            {

                if (bDeleteArg1)
                    *ppRes = pArg1;
                else
                    *ppRes = pArg1->Clone();

                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else if (pArg2)
            {
                if (bDeleteArg2)
                    *ppRes = pArg2;
                else
                    *ppRes = pArg2->Clone();

                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
                // can't touch this
                *ppRes = NULL;

            return WBEM_S_NO_ERROR;
        }
        else // not value nodes
            return pArg1->CombineWith(pArg2, nOp, pNamespace, Implications, 
                                      bDeleteArg1, bDeleteArg2, ppRes);
    }
    
    // Check if one is an OR
    // =====================

    if(arg1Type == EVAL_NODE_TYPE_OR)
        return pArg1->CombineWith(pArg2, nOp, pNamespace, Implications, 
                        bDeleteArg1, bDeleteArg2, ppRes); 

    if(arg2Type == EVAL_NODE_TYPE_OR)
        return pArg2->CombineWith(pArg1, FlipEvalOp(nOp), pNamespace, 
                        Implications, bDeleteArg2, bDeleteArg1, ppRes); 
        
    // One leaf, one branch
    // ====================

    if(arg1Type == EVAL_NODE_TYPE_VALUE)
    {
        return CombineLeafWithBranch((CValueNode*)pArg1, (CBranchingNode*)pArg2,
                nOp, pNamespace, Implications, bDeleteArg1, bDeleteArg2, ppRes);
    }
    else // it's pArg2
    {
        return CombineLeafWithBranch((CValueNode*)pArg2, (CBranchingNode*)pArg1,
                FlipEvalOp(nOp), pNamespace, Implications, 
                bDeleteArg2, bDeleteArg1, ppRes);
    }
}

// static
HRESULT CEvalTree::CombineLeafWithBranch(CValueNode* pArg1, 
                            CBranchingNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hres;

    if (pArg1 == NULL)
    {
        *ppRes = NULL;
        if(nOp == EVAL_OP_AND)
        {
            // Anding a FALSE with something --- getting a FALSE!
            // ==================================================

            if(bDeleteArg2)
                delete pArg2;

	        return WBEM_S_NO_ERROR;
        }
        else
        {
            // Anything else combined with FALSE gives itself!
            // ===============================================

            // Well, this is true, but the problem is with optimizations.  
            // Some branches in X might not be valid under the implications in
            // this branch of the tree, and so need to be removed. For now, I
            // will simply turn off this short-circuiting path.  It may turn out
            // that there are some critical performance gains to be had by 
            // keeping it, in which case we would need to put this back and
            // make an efficient pass through it, checking branches.
            //

			/*
            if(bDeleteArg2)
                *ppRes = pArg2;
            else
                *ppRes = pArg2->Clone();

			return WBEM_S_NO_ERROR;
			*/
        }
    }
    else
    {
        // Try to short-circuit
        // ====================

        hres = pArg1->TryShortCircuit(pArg2, nOp, bDeleteArg1, bDeleteArg2, ppRes);
        if(FAILED(hres))
            return hres; // hard-failure
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR; // short-circuit succeeded
    }

    // Didn't short-circuit
    // ====================
    
    return ((CBranchingNode*)pArg2)->CombineInOrderWith(pArg1, 
                              FlipEvalOp(nOp), pNamespace, Implications, 
                              bDeleteArg2, bDeleteArg1, ppRes);
}

HRESULT CEvalTree::Evaluate(CObjectInfo& Info, CEvalNode* pStart, 
                                CSortedArray& trueIDs)
{
    HRESULT hres;

    // Loop as long as we are still seeing branching nodes
    // ===================================================

    CEvalNode* pCurrent = pStart;
    int nType;
    while((nType = CEvalNode::GetType(pCurrent)) == EVAL_NODE_TYPE_BRANCH)
    {   
        hres = ((CBranchingNode*)pCurrent)->Evaluate(Info, &pCurrent);
        if(FAILED(hres)) return hres;
    }

    if(nType == EVAL_NODE_TYPE_OR)
    {
        hres = ((COrNode*)pCurrent)->Evaluate(Info, trueIDs);
        if(FAILED(hres)) return hres;
    }
    else  // VALUE
    {
        if (CValueNode::AreAnyTrue((CValueNode*)pCurrent))
            ((CValueNode*)pCurrent)->AddTruesTo(trueIDs);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEvalTree::Evaluate(IWbemObjectAccess* pObj, CSortedArray& trueIDs)
{
    CInCritSec ics(&m_cs);

    trueIDs.SetSize(0);

    HRESULT hres = WBEM_S_NO_ERROR;
    
    if(m_pStart != NULL)
    {
        m_ObjectInfo.SetObjectAt(0, (_IWmiObject*)pObj);

        hres = Evaluate(m_ObjectInfo, m_pStart, trueIDs);

        m_ObjectInfo.Clear();
    }

    return hres;
}

HRESULT CEvalTree::Optimize(CContextMetaData* pNamespace)
{
    CInCritSec ics(&m_cs);

    if(m_pStart == NULL)
        return WBEM_S_NO_ERROR;

    CEvalNode* pNew = NULL;
    HRESULT hres = m_pStart->Optimize(pNamespace, &pNew);
    if(pNew != m_pStart)
    {
        delete m_pStart;
        m_pStart = pNew;
    }

    if(CEvalNode::GetType(m_pStart) == EVAL_NODE_TYPE_VALUE)
    {
        if(!m_ObjectInfo.SetLength(1))
            return WBEM_E_OUT_OF_MEMORY;
    }

    return hres;
}

HRESULT CEvalTree::CombineWith(CEvalTree& Other, CContextMetaData* pNamespace, 
                               int nOp, long lFlags)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    try
    {
        CImplicationList Implications(lFlags);
    
        //
        // Compute required object info depth.  We are not set up to configure 
        // it properly, so we'll estimate the upper bound as the sum of the 
        // depths of the trees being merged.  Except that the first object 
        // doesn't count --- it's the event itself.  Unless one of the objects 
        // is empty --- in that case it doesn't mention the event itself, and 
        // so we should not subtract that 1.
        //
    
        long lRequiredDepth = 
            m_ObjectInfo.GetLength() + Other.m_ObjectInfo.GetLength();
        if(m_ObjectInfo.GetLength() > 0 && Other.m_ObjectInfo.GetLength() > 0)
            lRequiredDepth--;
            
        //
        // Combine our Start node with the new tree's.  Ours will be deleted in
        // the process.
        //
    
        CEvalNode* pNew;
        hres = CEvalTree::Combine(m_pStart, Other.m_pStart, nOp, pNamespace, 
                                    Implications, 
                                    true, // delete ours
                                    false, // don't touch theirs
                                    &pNew);
        if(FAILED(hres))
        {
            m_pStart = NULL;
            return hres;
        }
        m_pStart = pNew;
    
        if(!m_ObjectInfo.SetLength(lRequiredDepth))
            return WBEM_E_OUT_OF_MEMORY;
    
        if(nOp == EVAL_OP_COMBINE || nOp == EVAL_OP_INVERSE_COMBINE)
            m_nNumValues += Other.m_nNumValues;
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::IsMergeAdvisable(CEvalNode* pArg1, CEvalNode* pArg2, 
                                    CImplicationList& Implications)
{
    if(Implications.IsMergeMandatory())
        return S_OK;

    int arg1Type = CEvalNode::GetType(pArg1);
    int arg2Type = CEvalNode::GetType(pArg2);
    
    // if we have ONE non-false ValueNode, and ONE Branch Node, do not merge
    if  ( ((arg1Type == EVAL_NODE_TYPE_VALUE)
            && 
           (arg2Type == EVAL_NODE_TYPE_BRANCH)
            &&
          !CValueNode::IsAllFalse((CValueNode*)pArg1))
        ||
          ((arg2Type == EVAL_NODE_TYPE_VALUE)
             && 
           (arg1Type == EVAL_NODE_TYPE_BRANCH)
             &&
          !CValueNode::IsAllFalse((CValueNode*)pArg2))
        )
        return WBEM_S_FALSE;
    else
         // otherwise, if one of the nodes is not Branching, certainly yes (how hard can it be?)
        if(arg1Type != EVAL_NODE_TYPE_BRANCH ||
           arg2Type != EVAL_NODE_TYPE_BRANCH)
        {
            return WBEM_S_NO_ERROR;
        }

    // They are both branching.  If not about the same property, then certainly
    // inadvisable, since there is very little to be gained
    // ========================================================================

    CBranchingNode* pBranching1 = (CBranchingNode*)pArg1;
    CBranchingNode* pBranching2 = (CBranchingNode*)pArg2;

    if(CBranchingNode::ComparePrecedence(pBranching1, pBranching2))
        return WBEM_S_FALSE;
    
    // Check if the nodes are inheritance --- in that case we can only merge if
    // they have identical checks
    // ========================================================================

    if(pBranching1->GetSubType() == EVAL_NODE_TYPE_INHERITANCE)
    {
        // So is the other one, given that precedence is identical
        // =======================================================

        if(((CInheritanceNode*)pBranching1)->SubCompare(
            (CInheritanceNode*)pBranching2) != 0)
        {
            return WBEM_S_FALSE;
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }
    else if(pBranching1->GetSubType() == EVAL_NODE_TYPE_DUMB)
    {
        //
        // Only merge if identical
        //

        if(((CDumbNode*)pBranching1)->SubCompare(
            (CDumbNode*)pBranching2) != 0)
        {
            return WBEM_S_FALSE;
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }
        
    // Same property.  TBD: better checks
    // ==================================

    return WBEM_S_NO_ERROR;
}

HRESULT CEvalTree::RemoveIndex(int nIndex)
{
    CInCritSec ics(&m_cs);

    if(m_pStart != NULL)
    {
        CRemoveIndexPredicate P(nIndex);
        m_pStart->ApplyPredicate(&P);

        m_nNumValues--;
    }

    return S_OK;
}

HRESULT CEvalTree::UtilizeGuarantee(CEvalTree& Guaranteed, 
                                    CContextMetaData* pNamespace)
{
    CInCritSec ics(&m_cs);
#ifdef DUMP_EVAL_TREES
	FILE* f;
    f = fopen("c:\\log", "a");
    fprintf(f, "\n\nORIGINAL:\n");
    Dump(f);
    fprintf(f, "\n\nGUARANTEE:\n");
    Guaranteed.Dump(f);
    fflush(f);
#endif

#ifdef CHECK_TREES
	CheckTrees();
#endif

    //
    // Combine them together
    //

	//
	// This is a single-valued tree -- rebase it to 1 to distinguish from
	// the guarantee
	//

	Rebase(1);
    HRESULT hres = CombineWith(Guaranteed, pNamespace, EVAL_OP_COMBINE,
                                WBEM_FLAG_MANDATORY_MERGE);
    if(FAILED(hres)) return hres;

#ifdef DUMP_EVAL_TREES
    fprintf(f, "AFTER MERGE:\n");
    Dump(f);
    fflush(f);
#endif

	// Eliminate all nodes where Guaranteed is failing
    // ===============================================

    if(m_pStart)
    {
        CRemoveFailureAtIndexPredicate P(0);
        hres = m_pStart->ApplyPredicate(&P);
        if(FAILED(hres)) return hres;
    }
    m_nNumValues--;

#ifdef CHECK_TREES
	CheckTrees();
#endif

#ifdef DUMP_EVAL_TREES
    fprintf(f, "AFTER REMOVE:\n");
    Dump(f);
    fflush(f);
#endif

    hres = Optimize(pNamespace);
    if(FAILED(hres)) return hres;
	Rebase((QueryID)-1);

#ifdef CHECK_TREES
	CheckTrees();
#endif

#ifdef DUMP_EVAL_TREES
    fprintf(f, "AFTER OPTIMIZE:\n");
    Dump(f);

    fclose(f);
#endif
	
    return S_OK;
}

HRESULT CEvalTree::ApplyPredicate(CLeafPredicate* pPred)
{
    CInCritSec ics(&m_cs);

    if(m_pStart != NULL)
        m_pStart->ApplyPredicate(pPred);

    return S_OK;
}


void CEvalTree::operator=(const CEvalTree& Other)
{
    CInCritSec ics(&m_cs);

    delete m_pStart;
    m_pStart  = (Other.m_pStart ? Other.m_pStart->Clone() : NULL);

    if(m_pStart == NULL && Other.m_pStart != NULL)
        throw CX_MemoryException();
    
    m_nNumValues = Other.m_nNumValues;
    if(!m_ObjectInfo.SetLength(m_nNumValues))
        throw CX_MemoryException();
}
        
// renumber the QueryIDs in the leaves of the tree
void CEvalTree::Rebase(QueryID newBase)
{
    CRebasePredicate predRebase(newBase);
    ApplyPredicate(&predRebase);
}

bool CEvalTree::Clear()
{
    CInCritSec ics(&m_cs);

    delete m_pStart;
    m_pStart = CValueNode::GetStandardFalse();
    if(!m_ObjectInfo.SetLength(1))
        return false;

    m_nNumValues = 0;
    return true;
}

void CEvalTree::Dump(FILE* f)
{
    CEvalNode::DumpNode(f, 0, m_pStart);
}

#ifdef CHECK_TREES
void CEvalTree::CheckNodes(CTreeChecker *pChecker)
{
	CInCritSec ics2(&m_cs);
	
	if (m_pStart)
		m_pStart->CheckNode(pChecker);
}
#endif

HRESULT CEvalTree::CreateFromConjunction(CContextMetaData* pNamespace, 
                                  CImplicationList& Implications,
                                  CConjunction* pConj,
                                  CEvalNode** ppRes)
{
    HRESULT hres;

    *ppRes = NULL;

    // Build them for all tokens and AND together
    // ==========================================

    try
    {
        CImplicationList BranchImplications(Implications);
        for(int i = 0; i < pConj->GetNumTokens(); i++)
        {
            CEvalNode* pNew = NULL;
            hres = CEvalTree::BuildFromToken(pNamespace, BranchImplications,
                *pConj->GetTokenAt(i), &pNew);
            if(FAILED(hres))
            {
                delete *ppRes;
                return hres;
            }
    
            if(i > 0)
            {
                CEvalNode* pOld = *ppRes;
                hres = CEvalTree::Combine(pOld, pNew, EVAL_OP_AND, pNamespace, 
                    Implications, true, true, ppRes); // delete both
                if ( FAILED( hres ) )
                {
                    delete pOld;
                    return hres;
                }
            }
            else
            {
                *ppRes = pNew;
            }
        }
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::CreateFromDNF(CContextMetaData* pNamespace, 
                                 CImplicationList& Implications,
                                 CDNFExpression* pDNF,
                                 CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = NULL;

    // Check if there is only one conjunction to talk about
    // ====================================================

    if(pDNF->GetNumTerms() == 1)
    {
        // Just build that one
        // ===================

        return CreateFromConjunction(pNamespace, Implications, 
                                     pDNF->GetTermAt(0), ppRes);
    }

    // Build them for all conjunctions and OR together
    // ===============================================

    CEvalNode* pRes = NULL;
    for(int i = 0; i < pDNF->GetNumTerms(); i++)
    {
        CEvalNode* pNew;
        hres = CreateFromConjunction(pNamespace, Implications, 
                                     pDNF->GetTermAt(i), &pNew);
        if(FAILED(hres))
        {
            delete pRes;
            return hres;
        }

        if(pRes == NULL)
        {
            pRes = pNew;
        }
        else
        {
            CEvalNode* pNewRes = NULL;
            hres = CEvalTree::Combine(pRes, pNew, EVAL_OP_COMBINE, 
                    pNamespace, Implications, true, true, &pNewRes);
            if(FAILED(hres))
            {
                delete pRes;
                delete pNew;
                return hres;
            }
            pRes = pNewRes;
        }
    }

    *ppRes = pRes;
    return WBEM_S_NO_ERROR;
}

HRESULT CEvalTree::CreateProjection(CEvalTree& Old, CContextMetaData* pMeta,
                            CProjectionFilter* pFilter, 
                            EProjectionType eType, bool bDeleteOld)
{
    delete m_pStart;
    m_pStart = NULL;

    try
    {
        CImplicationList Implications;
        return CEvalTree::Project(pMeta, Implications, Old.m_pStart, pFilter, 
                                    eType, bDeleteOld, &m_pStart);
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications, 
                            CEvalNode* pOldNode, CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteOld,
                            CEvalNode** ppNewNode)
{
    if(pOldNode == NULL)
    {
        *ppNewNode = NULL;
        return WBEM_S_NO_ERROR;
    }

    return pOldNode->Project(pMeta, Implications, pFilter, eType, bDeleteOld, 
                                ppNewNode);
}
    



CPropertyProjectionFilter::CPropertyProjectionFilter()
{
    m_papProperties = new CUniquePointerArray<CPropertyName>;
    if(m_papProperties == NULL)
        throw CX_MemoryException();
}

CPropertyProjectionFilter::~CPropertyProjectionFilter()
{
    delete m_papProperties;
}

bool CPropertyProjectionFilter::IsInSet(CEvalNode* pNode)
{
    if(CEvalNode::GetType(pNode) != EVAL_NODE_TYPE_BRANCH)
        return false;

    CBranchingNode* pBranchingNode = (CBranchingNode*)pNode;
    CPropertyName* pEmbeddedObjName = pBranchingNode->GetEmbeddedObjPropName();
    
    CPropertyName ThisName;
    if(pEmbeddedObjName)
        ThisName = *pEmbeddedObjName;

    int nSubType = pBranchingNode->GetSubType();
    if(nSubType == EVAL_NODE_TYPE_SCALAR || nSubType == EVAL_NODE_TYPE_STRING)
    {
        //
        // Derived from CPropertyNode --- get its property name
        //

        ThisName.AddElement(
            ((CPropertyNode*)pBranchingNode)->GetPropertyName());
    }
    else if(nSubType == EVAL_NODE_TYPE_INHERITANCE)
    {
        // No extra name parts
    }
    else
    {
        //
        // Two-prop, perhaps.  Just say no
        //

        return false;
    }

    //
    // Search for the name in our list
    //

    for(int i = 0; i < m_papProperties->GetSize(); i++)
    {
        if(*(m_papProperties->GetAt(i)) == ThisName)
            return true;
    }

    return false;
}

bool CPropertyProjectionFilter::AddProperty(const CPropertyName& Prop)
{
    CPropertyName* pProp = NULL;
    try
    {
        pProp = new CPropertyName(Prop);
        if(pProp == NULL)
            return false;
    }
	catch (CX_MemoryException)
	{
		return false;
	}

    if(m_papProperties->Add(pProp) < 0)
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\esscli\evaltree.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EVALTREE.H

Abstract:

    WBEM Evaluation Tree

History:

--*/

#ifndef __WBEM_EVALUTAION_TREE__H_
#define __WBEM_EVALUTAION_TREE__H_

#include "esscpol.h"
#include <parmdefs.h>
#include <ql.h>
#include <sync.h>
#include <limits.h>
#include <sortarr.h>
#include <newnew.h>
#include <wbemmeta.h>
#include <wbemdnf.h>
#include <fastall.h>
#include <like.h>

// Uncomment this to enable tree checking.
//#define CHECK_TREES

#ifdef CHECK_TREES
    class CTreeChecker;
#endif

typedef DWORD_PTR QueryID;
#define InvalidID UINT_MAX

enum {EVAL_VALUE_TRUE, EVAL_VALUE_FALSE, EVAL_VALUE_INVALID};

#define WBEM_FLAG_MANDATORY_MERGE 0x100
#define MAX_TOKENS_IN_DNF 100

// This is where we keep the extracted embedded objects
class ESSCLI_POLARITY CObjectInfo
{
protected:
    long m_lLength;
    _IWmiObject** m_apObj;

public:
    CObjectInfo() : m_apObj(NULL), m_lLength(0){}
    ~CObjectInfo();

    long GetLength() {return m_lLength;}
    bool SetLength(long lLength);
    void Clear();

    INTERNAL _IWmiObject* GetObjectAt(long lIndex) 
        {return m_apObj[lIndex];}
    void SetObjectAt(long lIndex, READ_ONLY _IWmiObject* pObj);
};

// This is where we keep what we've learned about the object in the query
// as we move down the tree.
class CImplicationList
{
public:
    struct CRecord
    {
        CPropertyName m_PropName;
        _IWmiObject* m_pClass;
        long m_lObjIndex;
        CWStringArray m_awsNotClasses;
        int m_nNull;

    public:
        CRecord(CPropertyName& PropName, long lObjIndex)
            : m_PropName(PropName), m_pClass(NULL), m_lObjIndex(lObjIndex),
            m_nNull(EVAL_VALUE_INVALID)
        {}
        CRecord(const CRecord& Other);
        ~CRecord();

        HRESULT ImproveKnown(_IWmiObject* pClass);
        HRESULT ImproveKnownNot(LPCWSTR wszClassName);
        HRESULT ImproveKnownNull();

        void Dump(FILE* f, int nOffset);

    private:

        CRecord& operator=( const CRecord& Other );
    };

protected:
    long m_lRequiredDepth;
    CUniquePointerArray<CRecord> m_apRecords;
    long m_lNextIndex;
    CImplicationList* m_pParent;
    long m_lFlags;
   
protected:
    void FindBestComputedContainer(CPropertyName* pPropName,
                                             long* plRecord, long* plMatched);
    HRESULT MergeIn(CImplicationList::CRecord* pRecord);
    HRESULT FindRecordForProp(CPropertyName* pPropName, long lNumElements,
                                             long* plRecord);
    HRESULT FindOrCreateRecordForProp(CPropertyName* pPropName, 
                                        CImplicationList::CRecord** ppRecord);

private:

    CImplicationList& operator=( const CImplicationList& Other );

public:
    CImplicationList(long lFlags = 0);
    CImplicationList(CImplicationList& Other, bool bLink = true);
    ~CImplicationList();


    HRESULT FindBestComputedContainer(CPropertyName* pPropName,
            long* plFirstUnknownProp, long* plObjIndex, 
            RELEASE_ME _IWmiObject** ppContainerClass);
    HRESULT FindClassForProp(CPropertyName* pPropName,
            long lNumElements, RELEASE_ME _IWmiObject** ppClass);
    HRESULT AddComputation(CPropertyName& PropName, 
                                _IWmiObject* pClass, long* plObjIndex);
    HRESULT MergeIn(CImplicationList* pList);


    long GetRequiredDepth();
    void RequireDepth(long lDepth);
    HRESULT ImproveKnown(CPropertyName* pPropName, _IWmiObject* pClass);
    HRESULT ImproveKnownNot(CPropertyName* pPropName, LPCWSTR wszClassName);
    HRESULT ImproveKnownNull(CPropertyName* pPropName);

    bool IsMergeMandatory() 
        {return ((m_lFlags & WBEM_FLAG_MANDATORY_MERGE) != 0);}

    bool IsEmpty() {return m_apRecords.GetSize() == 0;}
    void Dump(FILE* f, int nOffset);
};
    
// Wrapper for arbitrary values
class CTokenValue
{
protected:
    VARIANT m_v;
public:
    CTokenValue();
    CTokenValue(CTokenValue& Other);
    ~CTokenValue();

    bool SetVariant(VARIANT& v);
    void operator=(CTokenValue& Other);

    operator signed char() const {return (signed char)V_I4(&m_v);}
    operator unsigned char() const {return (unsigned char)V_I4(&m_v);}
    operator unsigned short() const {return (unsigned short)V_I4(&m_v);}
    operator long() const {return (long)V_I4(&m_v);}
    operator unsigned long() const;
    operator __int64() const;
    operator unsigned __int64() const;
    operator float() const;
    operator double() const;
    operator short() const;
    operator WString() const;
    operator CInternalString() const {return CInternalString((WString)*this);}

    int Compare(const CTokenValue& Other) const;

    BOOL operator<(const CTokenValue& Other) const
    {return Compare(Other) < 0;}
    BOOL operator>(const CTokenValue& Other) const
    {return Compare(Other) > 0;}
    BOOL operator==(const CTokenValue& Other) const
    {return Compare(Other) == 0;}
};

enum {EVAL_OP_AND, EVAL_OP_OR, EVAL_OP_COMBINE, EVAL_OP_INVERSE_COMBINE};
inline int FlipEvalOp(int nOp)
{
    if(nOp == EVAL_OP_COMBINE) return EVAL_OP_INVERSE_COMBINE;
    else if(nOp == EVAL_OP_INVERSE_COMBINE) return EVAL_OP_COMBINE;
    else return nOp;
}

enum
{
    EVAL_NODE_TYPE_VALUE,
    EVAL_NODE_TYPE_BRANCH,
    EVAL_NODE_TYPE_OR,
    EVAL_NODE_TYPE_INHERITANCE,
    EVAL_NODE_TYPE_SCALAR,
    EVAL_NODE_TYPE_TWO_SCALARS,
    EVAL_NODE_TYPE_STRING,
    EVAL_NODE_TYPE_TWO_STRINGS,
    EVAL_NODE_TYPE_MISMATCHED_INTS,
    EVAL_NODE_TYPE_MISMATCHED_FLOATS,
    EVAL_NODE_TYPE_MISMATCHED_STRINGS,
    EVAL_NODE_TYPE_DUMB,
    EVAL_NODE_TYPE_LIKE_STRING
};

// Base class for all sorts of operations one can perform on leaf nodes of a 
// tree.  When applied to a leaf, it can change it, and return a value from the
// list below to control the rest of the traversal
enum 
{
    WBEM_DISPOSITION_NORMAL = 0, 
    WBEM_DISPOSITION_STOPLEVEL = 1,
    WBEM_DISPOSITION_STOPALL = 2,
    WBEM_DISPOSITION_FLAG_DELETE = 16,
    WBEM_DISPOSITION_FLAG_INVALIDATE = 32
};

class CLeafPredicate
{
public:
    virtual DWORD operator()(class CValueNode* pLeaf) = 0;

};

class CProjectionFilter
{
public:
    virtual bool IsInSet(class CEvalNode* pNode) = 0;
};

typedef enum {e_Sufficient, e_Necessary} EProjectionType;

// Base class for all nodes in the tree
class ESSCLI_POLARITY CEvalNode
{
protected:
    // int m_nType;
    virtual int GetType() = 0;

private:
	CEvalNode& operator=( const CEvalNode& ); // notimpl
	
public:
    CEvalNode();
	CEvalNode(const CEvalNode& other);
    virtual ~CEvalNode();
    
    // NULL EvalNode interpreted as a Value Node with all false
    static int GetType(CEvalNode *pNode)
    {
        if (pNode)
            return pNode->GetType();
        else
            return EVAL_NODE_TYPE_VALUE;
    }


    virtual CEvalNode* Clone() const = 0;
    virtual HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes)=0;
    virtual int Compare(CEvalNode* pOther) = 0;
    virtual DWORD ApplyPredicate(CLeafPredicate* pPred) = 0;
    virtual void Dump(FILE* f, int nOffset) = 0;
#ifdef CHECK_TREES
	virtual void CheckNode(CTreeChecker *pCheck);
#endif

    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew) 
        {*ppNew = this; return WBEM_S_NO_ERROR;}
    virtual bool IsInvalid() {return false;}

    static bool IsInvalid(CEvalNode* pNode)
    {
        if(pNode)
            return pNode->IsInvalid();
        else
            return false;
    }

    virtual bool IsAllFalse() {return false;}
    static bool IsAllFalse(CEvalNode* pNode)
    {
        if(pNode)
            return pNode->IsAllFalse();
        else
            return true; // empty node is FALSE
    }
            
    virtual bool IsNoop(int nOp) {return false;}
    static bool IsNoop(CEvalNode* pNode, int nOp);

    virtual CImplicationList* GetExtraImplications() = 0;
    virtual HRESULT SetExtraImplications(CImplicationList* pList) = 0;

    static void PrintOffset(FILE* f, int nOffset);
    static CEvalNode* CloneNode(const CEvalNode* pNode);
    virtual HRESULT Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode) = 0;
    static void DumpNode(FILE* f, int nOffset, CEvalNode* pNode);

};

// just like CFlexArray, except:
//     array is always sorted
//     duplicates are not allowed
//     deals with QueryIDs (unsigneds), rather than pointers
//     intended for use by CValueNode, not necessarily as a generic sorted array
//     ASSUMPTION: pointer is same size as an unsigned 
class ESSCLI_POLARITY CSortedArray : protected CFlexArray
{
public:
    // Constructs a sorted array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CSortedArray(int nInitialSize = 32,
                int nGrowBy = 32
                ) : CFlexArray(nInitialSize, nGrowBy)
    {}


    CSortedArray(unsigned nElements, QueryID* pArray);
    // ~CSortedArray(); don't need it, yet...

    void operator=(const CSortedArray &that) 
        {((CFlexArray&)*this = (CFlexArray&)that); }

    int inline Size() const { return CFlexArray::Size(); }

    inline QueryID GetAt(int nIndex)  
        { return (QueryID)CFlexArray::GetAt(nIndex); }

    inline void Empty() { CFlexArray::Empty(); }
    inline void SetSize(int nSize) {CFlexArray::SetSize(nSize);}

    void DebugDump() { CFlexArray::DebugDump(); }

    // copies this array to destination
    // returns number of elements copied
    unsigned CopyTo(QueryID* pDest, unsigned size);

    //returns zero if arrays are equivalent
    // same number of USED elements w/ same values
    int Compare(CSortedArray& otherArray);

    // finds n in array
    // return index of found element
    // returns -1 if not found
    unsigned Find(QueryID n);

    // inserts n in proper position in array
    void Insert(QueryID n);

    // removes n from array
    // returns true if it did
    bool Remove(QueryID n);

    // add to end of array
    inline int Add(QueryID n) { return CFlexArray::Add((void *)n); };

    // changes all QueryID's to begin at newBase
    // e.g. if the array is {0,1,5}
    // Rebase(6) will change to {6,7,11}
    void Rebase(QueryID newBase);

    // Retrieves internal pointer to the data in the array
    inline QueryID* GetArrayPtr() {return (QueryID*)CFlexArray::GetArrayPtr();}

    // Retrieves the pointer to the data in the array and empties the array
    // The caller is responsible for the memory returned
    inline QueryID* UnbindPtr() {return (QueryID*)CFlexArray::UnbindPtr();}

    // Copies the data (but not the extent) from another array
    // Its own data is overwritten
    inline int CopyDataFrom(const CSortedArray& aOther) 
        {return CFlexArray::CopyDataFrom(aOther);}

    int AddDataFrom(const CSortedArray& aOther);
    int AddDataFrom(const QueryID* pOtherArray, unsigned nValues);


    int CopyDataFrom(const QueryID* pArray, unsigned nElements);

protected:

};
                                
// Leaf node --- contains the list of queries that matched
class  CValueNode : public CEvalNode
{
protected:
    DWORD m_nValues;
    // this data member MUST be the last in the class
    // to allow an array size defined at runtime
    // this array is always assumed to be sorted
    QueryID m_trueIDs[1];
    
    unsigned ORarrays(QueryID* pArray1, unsigned size1,
                      QueryID* pArray2, unsigned size2, 
                      QueryID* pOutput);

    unsigned ANDarrays(QueryID* pArray1, unsigned size1,
                       QueryID* pArray2, unsigned size2, 
                       QueryID* pOutput);

    unsigned CombineArrays(QueryID* pArray1, unsigned size1,
                           QueryID* pArray2, unsigned size2, 
                           QueryID* pOutput);


    // ctors moved to 'protected' to force callers to use the CreateNode function
    CValueNode() 
    {}

    CValueNode(int nNumValues);
    virtual int GetType();

public:
    
    virtual ~CValueNode();
    static CValueNode* CreateNode(size_t nNumValues);
    static CValueNode* CreateNode(CSortedArray& values);

    void *operator new( size_t stAllocateBlock, unsigned nEntries = 0);

    // VC 5 only allows one delete operator per class
#if _MSC_VER >= 1200
    void operator delete( void *p, unsigned nEntries );
#endif
    void operator delete(void* p) { ::delete[] (byte*)p; };


    // changes all QueryID's to begin at newBase
    // e.g. if the array is {0,1,5}
    // Rebase(6) will change to {6,7,11}

    DWORD GetNumTrues() {return m_nValues;}
    void Rebase(QueryID newBase);

    unsigned FindQueryID(QueryID n);

    int GetAt(int nIndex) 
    { 
        if (FindQueryID(nIndex) != InvalidID)
            return EVAL_VALUE_TRUE;                         
        else
            return EVAL_VALUE_FALSE;
    }

    bool IsAllFalse()
    {
            return (m_nValues == 0);
    }
    static bool IsAllFalse(CValueNode* pNode)
    {
        if (pNode)
            return pNode->IsAllFalse();
        else
            return true;
    }
    
    static bool IsNoop(CValueNode* pNode, int nOp);
    bool IsNoop(int nOp)
    {
        return IsNoop(this, nOp);
    }

    static bool AreAnyTrue(CValueNode* pNode)
    {    
        if (pNode)
            return (pNode->m_nValues > 0);
        else
            return false;
    }

    CEvalNode* Clone() const;
    HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications,
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes);
    int Compare(CEvalNode* pOther);
    HRESULT TryShortCircuit(CEvalNode* pArg2, int nOp, bool bDeleteThis,
                            bool bDeleteArg2, CEvalNode** ppRes);

    DWORD ApplyPredicate(CLeafPredicate* pPred) {return (*pPred)(this);}

    bool RemoveQueryID(QueryID nQuery);

    void CopyTruesTo(CSortedArray& trueIDs) const 
        {trueIDs.CopyDataFrom(m_trueIDs, m_nValues);}

    void AddTruesTo(CSortedArray& trueIDs) const
    {
        int nWasSize = trueIDs.Size();
        if(nWasSize == 0)
            trueIDs.CopyDataFrom((QueryID*)&m_trueIDs, m_nValues);
        else if (m_nValues > 0)
            trueIDs.AddDataFrom((QueryID*)&m_trueIDs, m_nValues);
    }


    static CValueNode* GetStandardTrue();
    static CValueNode* GetStandardFalse() { return NULL; };
    static CValueNode* GetStandardInvalid();

    virtual CImplicationList* GetExtraImplications() {return NULL;}
    virtual HRESULT SetExtraImplications(CImplicationList* pList)
    {
        // CValueNodes don't use or need this, so just delete it.
		delete pList;

        return S_OK;
    }

    virtual HRESULT Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode);

    virtual void Dump(FILE* f, int nOffset);
};

class CInvalidNode : public CValueNode
{
public:
    CInvalidNode() : CValueNode(0){}

    bool IsInvalid() {return true;}
    void Dump(FILE* f, int nOffset);
};

    

// Contains information about the portion of the node exclusing the last 
// component of the property name

class CEmbeddingInfo
{
protected:
    CPropertyName m_EmbeddedObjPropName;
    
    long m_lStartingObjIndex;
    long m_lNumJumps;
    
    struct JumpInfo {
        long lJump;
        long lTarget; 
    }* m_aJumps;

public:
    CEmbeddingInfo();
    CEmbeddingInfo(const CEmbeddingInfo& Other);
    ~CEmbeddingInfo();
    void operator=(const CEmbeddingInfo& Other);

    CPropertyName* GetEmbeddedObjPropName() {return &m_EmbeddedObjPropName;}
    void SetEmbeddedObjPropName(CPropertyName& Name) 
        {m_EmbeddedObjPropName = Name;}

    bool SetPropertyNameButLast(const CPropertyName& Name);

    BOOL operator==(const CEmbeddingInfo& Other);
    BOOL operator!=(const CEmbeddingInfo& Other)
        {return !(*this == Other);}

    HRESULT Compile(CContextMetaData* pNamespace, 
                    CImplicationList& Implications, 
                    _IWmiObject** ppResultClass);
    HRESULT GetContainerObject(CObjectInfo& ObjInfo, 
                                INTERNAL _IWmiObject** ppInst);
    int ComparePrecedence(const CEmbeddingInfo* pOther);
    bool AreJumpsRelated( const CEmbeddingInfo* pInfo );
    bool MixInJumps(const CEmbeddingInfo* pInfo );
    bool IsEmpty() const;
    void Dump(FILE* f);
};


// A node that is interested in the implications that have accrued

class CNodeWithImplications : public CEvalNode
{
protected:
    CImplicationList* m_pExtraImplications;

private : 
	CNodeWithImplications& operator=( const CNodeWithImplications& ); // notimpl
	
public:
    CNodeWithImplications() : m_pExtraImplications(NULL){}
    CNodeWithImplications(const CNodeWithImplications& Other);
    ~CNodeWithImplications()
    {
        delete m_pExtraImplications;
    }

    virtual CImplicationList* GetExtraImplications()
    {
        return m_pExtraImplications;
    }
    virtual HRESULT SetExtraImplications(ACQUIRE CImplicationList* pList)
    {
        if(m_pExtraImplications)
            delete m_pExtraImplications;
        m_pExtraImplications = pList;
        return S_OK;
    }
    void Dump(FILE* f, int nOffset);
};


class CBranchIterator
{
public:
    virtual ~CBranchIterator(){}
    virtual INTERNAL CEvalNode* GetNode() = 0;
    virtual void SetNode(ACQUIRE CEvalNode* pNode) = 0;

    virtual bool IsValid() = 0;
    virtual void Advance() = 0;

    virtual HRESULT RecordBranch(CContextMetaData* pMeta, 
                                    CImplicationList& Implications) = 0;
};

// A node with a test and a whole bunch of branches, including a special one for
// the case where the thing being tested was NULL

class CBranchingNode : public CNodeWithImplications
{
// protected:
public: // because I don't know how to make a template a friend
    CUniquePointerArray<CEvalNode> m_apBranches;
    CEvalNode* m_pNullBranch;

    CEmbeddingInfo* m_pInfo;

protected:
    void operator=(const CBranchingNode& Other);
    HRESULT CompileEmbeddingPortion(CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                _IWmiObject** ppResultClass)
    {
        if (!m_pInfo)
            return WBEM_S_NO_ERROR;
        else
            return m_pInfo->Compile(pNamespace, Implications, ppResultClass);
    }

    HRESULT GetContainerObject(CObjectInfo& ObjInfo, 
                                INTERNAL _IWmiObject** ppInst)
    {
        if (!m_pInfo)
        {
            // this SEEMS to be the behavior of the code prior to changes
            *ppInst = ObjInfo.GetObjectAt(0);
            return WBEM_S_NO_ERROR;
        }                
        else
            return m_pInfo->GetContainerObject(ObjInfo, ppInst);
    }

    bool SetEmbeddedObjPropName(CPropertyName& Name);
    bool MixInJumps(const CEmbeddingInfo* pInfo);

    HRESULT StoreBranchImplications(CContextMetaData* pNamespace,
                            int nBranchIndex, CEvalNode* pResult);
public:
    CBranchingNode();
    CBranchingNode(const CBranchingNode& Other, BOOL bChildren = TRUE);
    ~CBranchingNode();

    virtual int GetType();
    virtual long GetSubType() = 0;
    CUniquePointerArray<CEvalNode>& GetBranches() {return m_apBranches;}
    CEvalNode* GetNullBranch() {return m_pNullBranch;}
    void SetNullBranch(CEvalNode* pBranch);
    CPropertyName* GetEmbeddedObjPropName() 
    {
        if (!m_pInfo)
            return NULL;
        else                
            return m_pInfo->GetEmbeddedObjPropName();
    }

    virtual DWORD ApplyPredicate(CLeafPredicate* pPred);
    virtual DELETE_ME CBranchIterator* GetBranchIterator();
    
    virtual int ComparePrecedence(CBranchingNode* pOther) = 0;
    virtual int Compare(CEvalNode* pNode);
    virtual int SubCompare(CEvalNode* pNode) = 0;

    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, 
                                INTERNAL CEvalNode** ppNext) = 0;
    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes) = 0;
    virtual HRESULT RecordBranch(CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                long lBranchIndex)
        {return WBEM_S_NO_ERROR;}
    virtual HRESULT OptimizeSelf() {return WBEM_S_NO_ERROR;}

    HRESULT AdjustCompile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
    {   
        if (!m_pInfo)
            return WBEM_S_NO_ERROR;
        else
            return m_pInfo->Compile(pNamespace, Implications, NULL);
    }

    HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications, 
                        bool bDeleteThis, bool bDeleteArg2, 
                        CEvalNode** ppRes);
    virtual HRESULT CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes);
    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    BOOL AreAllSame(CEvalNode** apNodes, int nSize, int* pnFoundIndex);
    static int ComparePrecedence(CBranchingNode* pArg1, CBranchingNode* pArg2);

    HRESULT Project(CContextMetaData* pMeta, CImplicationList& Implications,
                            CProjectionFilter* pFilter, EProjectionType eType, 
                            bool bDeleteThis, CEvalNode** ppNewNode);
    void Dump(FILE* f, int nOffset);
#ifdef CHECK_TREES
	virtual void CheckNode(CTreeChecker *pCheck);
#endif
    friend class CDefaultBranchIterator;
};

class CDefaultBranchIterator : public CBranchIterator
{
protected:
    CBranchingNode* m_pNode;
    int m_nIndex;

public:
    CDefaultBranchIterator(CBranchingNode* pNode) : m_pNode(pNode), m_nIndex(-1)
    {}

    virtual INTERNAL CEvalNode* GetNode()
    {
        if(m_nIndex == -1)
            return m_pNode->m_pNullBranch;
        else
            return m_pNode->m_apBranches[m_nIndex];
    }
    virtual void SetNode(ACQUIRE CEvalNode* pNode)
    {
        CEvalNode* pOld;
        if(m_nIndex == -1)
            m_pNode->m_pNullBranch = pNode;
        else
            m_pNode->m_apBranches.SetAt(m_nIndex, pNode, &pOld);
    }

    virtual bool IsValid() { return m_nIndex < m_pNode->m_apBranches.GetSize();}
    virtual void Advance() { m_nIndex++;}
    virtual HRESULT RecordBranch(CContextMetaData* pMeta, 
                                    CImplicationList& Implications)
    {
        return m_pNode->RecordBranch(pMeta, Implications, m_nIndex);
    }
};
    



// The node where a property is tested against a value.  The property is 
// identified by a handle
class CPropertyNode : public CBranchingNode
{
protected:
    long m_lPropHandle;
    WString m_wsPropName;

private:
	CPropertyNode& operator=( const CPropertyNode& ); // notimpl
	
public:
    CPropertyNode() 
        : m_lPropHandle(-1)
    {}
    CPropertyNode(const CPropertyNode& Other, BOOL bChildren = TRUE)
        : CBranchingNode(Other, bChildren), m_lPropHandle(Other.m_lPropHandle),
            m_wsPropName(Other.m_wsPropName)
    {}
    virtual ~CPropertyNode(){}

    virtual int ComparePrecedence(CBranchingNode* pOther);
    bool SetPropertyInfo(LPCWSTR wszPropName, long lPropHandle);
    LPCWSTR GetPropertyName() {return m_wsPropName;}
    bool SetEmbeddingInfo(const CEmbeddingInfo* pInfo);
    virtual HRESULT SetNullTest(int nOperator);
    virtual HRESULT SetOperator(int nOperator);

    virtual HRESULT SetTest(VARIANT& v) = 0;
};

// An element in the array of test points
template<class TPropType>
struct CTestPoint
{
    TPropType m_Test;
    CEvalNode* m_pLeftOf;
    CEvalNode* m_pAt;

    CTestPoint() : m_pLeftOf(NULL), m_pAt(NULL){}
    void Destruct() {delete m_pLeftOf; delete m_pAt;}
};

template<class TPropType>
struct CTestPointCompare
{
    typedef CTestPoint<TPropType> TTestPoint;

    inline int Compare(const TPropType& t, const TTestPoint& p) const
    {
        if(t < p.m_Test)
            return -1;
        else if(t == p.m_Test)
            return 0;
        else return 1;
    }
    inline int Compare(const TPropType& t1, const TPropType& t2) const
    {
        if(t1 < t2)
            return -1;
        else if(t1 == t2)
            return 0;
        else return 1;
    }
    inline int Compare(const TTestPoint& p1, const TTestPoint& p2) const
    {
        return Compare(p1.m_Test, p2);
    }
    inline const TPropType& Extract(const TTestPoint& p) const
    {
        return p.m_Test;
    }
};

template<class TPropType>
struct CTestPointManager
{
    typedef CTestPoint<TPropType> TTestPoint;

    void AddRefElement(TTestPoint& p){}
    void ReleaseElement(TTestPoint& p) {p.Destruct();}
};
        
template<class TPropType>
class CFullCompareNode : public CPropertyNode
{
// protected:
public: // because I can't make a template a friend of this one??
    typedef CSmartSortedTree<
                TPropType, 
                CTestPoint<TPropType>, 
                CTestPointManager<TPropType>,
                CTestPointCompare<TPropType> > TTestPointArray;

    typedef typename TTestPointArray::TIterator TTestPointIterator;
    typedef typename TTestPointArray::TConstIterator TConstTestPointIterator;
    TTestPointArray m_aTestPoints;
    CEvalNode* m_pRightMost;

public:
    CFullCompareNode() : m_pRightMost(NULL) 
    {}
    CFullCompareNode(const CFullCompareNode<TPropType>& Other, 
                            BOOL bChildren = TRUE);
    virtual ~CFullCompareNode();

    HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                bool bDeleteThis, bool bDeleteArg2,
                                CEvalNode** ppRes);
    HRESULT CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes);
    int SubCompare(CEvalNode* pOther);
    virtual HRESULT OptimizeSelf();
    virtual HRESULT SetTest(VARIANT& v);

    virtual DWORD ApplyPredicate(CLeafPredicate* pPred);
    virtual DELETE_ME CBranchIterator* GetBranchIterator()
    {
        return new CFullCompareBranchIterator<TPropType>(this);
    }
    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    HRESULT SetNullTest(int nOperator);
    HRESULT SetOperator(int nOperator);

protected:
    HRESULT CombineWithBranchesToLeft(
            TTestPointIterator itWalk, TTestPointIterator itLast,
            CEvalNode* pArg2,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& OrigImplications);
    HRESULT InsertLess(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& OrigImplications, bool bDeleteArg2);
    HRESULT InsertMatching(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& OrigImplications, bool bDeleteArg2);

};

template<class TPropType>
class CFullCompareBranchIterator : public CBranchIterator
{
protected:
    CFullCompareNode<TPropType>* m_pNode;
    typename CFullCompareNode<TPropType>::TTestPointIterator m_it;
    typename CFullCompareNode<TPropType>::TTestPointIterator m_itEnd;
    bool m_bLeft;
    bool m_bValid;

public:
    CFullCompareBranchIterator(CFullCompareNode<TPropType>* pNode) 
        : m_pNode(pNode), m_it(pNode->m_aTestPoints.Begin()), m_bLeft(true),
          m_itEnd(pNode->m_aTestPoints.End()), m_bValid(true)
    {}

    virtual INTERNAL CEvalNode* GetNode()
    {
        if(m_it == m_itEnd)
        {
            if(m_bLeft)
                return m_pNode->m_pRightMost;
            else
                return m_pNode->m_pNullBranch;
        }
        else 
        {
            if(m_bLeft)
                return m_it->m_pLeftOf;
            else
                return m_it->m_pAt;
        }
    }
    virtual void SetNode(ACQUIRE CEvalNode* pNode)
    {
        if(m_it == m_itEnd)
        {
            if(m_bLeft)
                m_pNode->m_pRightMost = pNode;
            else
                m_pNode->m_pNullBranch = pNode;
        }
        else 
        {
            if(m_bLeft)
                m_it->m_pLeftOf = pNode;
            else
                m_it->m_pAt = pNode;
        }
    }

    virtual bool IsValid() { return m_bValid;}
    virtual void Advance()
    {
        if(m_bLeft)
            m_bLeft = false;
        else if(m_it == m_itEnd)
            m_bValid = false;
        else
        {
            m_it++;
            m_bLeft = true;
        }
    } 
    virtual HRESULT RecordBranch(CContextMetaData* pMeta, 
                                    CImplicationList& Implications)
    {
        return S_OK; // fullcompare nodes don't have implications
    }
};
    


template<class TPropType>
class CScalarPropNode : public CFullCompareNode<TPropType>
{
public:
    CScalarPropNode() : CFullCompareNode<TPropType>()
    {}
    CScalarPropNode(const CScalarPropNode<TPropType>& Other, 
                        BOOL bChildren = TRUE)
        : CFullCompareNode<TPropType>(Other, bChildren)
    {}
    virtual ~CScalarPropNode(){}

    virtual long GetSubType() {return EVAL_NODE_TYPE_SCALAR; }
    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);
    virtual CEvalNode* Clone() const 
        {return new CScalarPropNode<TPropType>(*this);}
    virtual CBranchingNode* CloneSelf() const
       {return new CScalarPropNode<TPropType>(*this, FALSE);}
    virtual void Dump(FILE* f, int nOffset);
};

class CStringPropNode : public CFullCompareNode<CInternalString>
{
public:
    CStringPropNode() 
        : CFullCompareNode<CInternalString>()
    {}
    CStringPropNode(const CStringPropNode& Other, BOOL bChildren = TRUE);
    virtual ~CStringPropNode();

    virtual long GetSubType() { return EVAL_NODE_TYPE_STRING; }

    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);
    virtual CEvalNode* Clone() const {return new CStringPropNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CStringPropNode(*this, FALSE);}
    virtual void Dump(FILE* f, int nOffset);
};

class CLikeStringPropNode : public CPropertyNode
{
protected:

    CLike m_Like;

private:
    CLikeStringPropNode& operator=( const CLikeStringPropNode& ); // notimpl

public:

    CLikeStringPropNode() {} ;
    CLikeStringPropNode(const CLikeStringPropNode& Other, BOOL bChildren=TRUE);

    virtual long GetSubType() { return EVAL_NODE_TYPE_LIKE_STRING; }

    virtual int ComparePrecedence(CBranchingNode* pNode);
    virtual int SubCompare(CEvalNode* pNode);

    virtual HRESULT SetTest( VARIANT& v );

    virtual HRESULT Evaluate( CObjectInfo& ObjInfo, CEvalNode** ppNext );

    virtual HRESULT CombineBranchesWith( CBranchingNode* pArg2, int nOp, 
                                         CContextMetaData* pNamespace, 
                                         CImplicationList& Implications,
                                         bool bDeleteThis, bool bDeleteArg2,
                                         CEvalNode** ppRes );
    virtual HRESULT OptimizeSelf();

    virtual CEvalNode* Clone() const {return new CLikeStringPropNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CLikeStringPropNode(*this, FALSE);}
    virtual void Dump(FILE* f, int nOffset);
};
    

class CInheritanceNode : public CBranchingNode
{
protected:
    long m_lDerivationIndex;
    
    long m_lNumPoints;
    CCompressedString** m_apcsTestPoints;

private:
    CInheritanceNode& operator= ( const CInheritanceNode& Other ); // notimpl

public:
    CInheritanceNode();
    CInheritanceNode(const CInheritanceNode& Other, BOOL bChildren = TRUE);
    virtual ~CInheritanceNode();

    virtual long GetSubType();
    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);
    virtual int ComparePrecedence(CBranchingNode* pOther);
    virtual CEvalNode* Clone() const {return new CInheritanceNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CInheritanceNode(*this, FALSE);}
    virtual HRESULT Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications);
    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes);
    virtual HRESULT RecordBranch(CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                long lBranchIndex);
    virtual int SubCompare(CEvalNode* pOther);
    virtual HRESULT OptimizeSelf();
    HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    void RemoveTestPoint(int nIndex);
    HRESULT Project(CContextMetaData* pMeta, CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode);
    virtual void Dump(FILE* f, int nOffset);
public:
    HRESULT AddClass(CContextMetaData* pNamespace, LPCWSTR wszClassName,
                        CEvalNode* pDestination);
    HRESULT AddClass(CContextMetaData* pNamespace, 
                                    LPCWSTR wszClassName, _IWmiObject* pClass,
                                    CEvalNode* pDestination);
    bool SetPropertyInfo(CContextMetaData* pNamespace, CPropertyName& PropName);
protected:
	void RemoveAllTestPoints();

	HRESULT ComputeUsageForMerge(CInheritanceNode* pArg2, 
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
											bool bDeleteThis, bool bDeleteArg2,
											DWORD* pdwFirstNoneCount,
								