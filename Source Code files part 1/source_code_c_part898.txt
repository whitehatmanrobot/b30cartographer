      if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                lRes = (LONG)bPaintPath(pSurf, ppo,prcl, pdbrush->iSolidColor, TRUE,flOptions);
            }
            else if (pSurf->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        lRes = (LONG)bBrushPath(pSurf, ppo, prcl, pdbrush, pptlBrush, DPA_PATXOR,flOptions);
                    }
                }
            }

            break;

        case 0xAAAA:    // D
            lRes = TRUE;
            break;

        case 0xF0F0:    // P
            if (pdbrush->iSolidColor != 0xFFFFFFFF)
            {
                lRes = (LONG)bPaintPath(pSurf, ppo,prcl, pdbrush->iSolidColor, FALSE,flOptions);
            }
            else if ( (pSurf->iFormat() == BMF_4BPP) ||
                      (pSurf->iFormat() == BMF_8BPP) )

            {

            // We only support 8x8 DIB4 patterns with SRCCOPY right now

                if (pvGetEngRbrush(pdbrush) != NULL)
                {
                    if ((((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat == 8) &&
                        (((EBRUSHOBJ *) pdbrush)->pengbrush()->cyPat == 8))
                    {
                        lRes = (LONG)bBrushPathN_8x8(
                                                     pSurf,
                                                     ppo,
                                                     prcl,
                                                     pdbrush,
                                                     pptlBrush,
                                                     pSurf->iFormat(),
                                                     flOptions
                                                    );

                    }
                }
            }
            else if (pSurf->iFormat() >= BMF_8BPP)
            {
                if (pvGetEngRbrush(pdbrush))    // Can we use this brush?
                {
                    if (((EBRUSHOBJ *) pdbrush)->pengbrush()->cxPat >= 4)
                    {
                        lRes = (LONG)bBrushPath(pSurf, ppo,prcl, pdbrush, pptlBrush, DPA_PATCOPY, flOptions);
                    }
                }
            }

            break;

        case 0xFFFF:    // White
            lRes = (LONG)bPaintPath(pSurf, ppo,prcl, (ULONG)~0, FALSE,flOptions);
            break;
        }
    }

    return(lRes);
}

/******************************Public*Routine******************************\
* bFastFill()
*
*   Fills a convex polygon quickly.  Calls pfnRow with lists of adjacent
*   rows, pfn if a verticle rectangle is found.
*
* returns:
*   true  if it is a simple polygon and has been drawn
*   false if it is too complex.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* initial code stolen from s3 driver.
\**************************************************************************/

BOOL bMsg = FALSE;

BOOL bFastFill(
    LONG      cEdges,       // Includes close figure edge
    POINTFIX* pptfxFirst,
    PRECTL    prclClip,
    PFN_FF    pfn,
    PFN_FFROW pfnRow,
    PVOID     pv)
{
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    LONG yCurrent;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    // Make sure we initialize the DDAs appropriately:

#define RIGHT 0
#define LEFT  1

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

// setup the rectangles for enumeration

    #define MAXROW 40
    RECTL  rclClip;

    ROW     arow[MAXROW];
    PROW    prow = arow;
    ULONG   crow = 0;
    LONG    yTop = 0;

    yCurrent = (pptfxTop->y + 15) >> 4;

    if (prclClip)
    {
        rclClip = *prclClip;
        if (rclClip.top > yCurrent)
            yCurrent = rclClip.top;

        if (yCurrent >= rclClip.bottom)
            return(TRUE);
    }
    else
    {
        rclClip.top    = NEG_INFINITY;
        rclClip.bottom = POS_INFINITY;
    }

// if there is clipping, remove all edges above rectangle

    if (prclClip)
    {
        for (LONG iEdge = 1; iEdge >= 0; iEdge--)
        {
            ped = &aed[iEdge];

            for (;;)
            {
                if (cEdges == 0)
                    return(TRUE);

            // find the next edge

                POINTFIX *pptfxNew = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (pptfxNew < pptfxFirst)
                    pptfxNew = pptfxLast;
                else if (pptfxNew > pptfxLast)
                    pptfxNew = pptfxFirst;

            // we have found one that intersects the rect

                if ((pptfxNew->y >> 4) >= rclClip.top)
                    break;

            // the bottom is outside the cliprect, throw it away and get the next

                cEdges--;
                ped->pptfx = pptfxNew;
            };
        }
    }

// now do the real work.  We must loop through all edges.

NextEdge:

    // We loop through this routine on a per-trapezoid basis.

    for (LONG iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if ((cEdges < 0) || (yCurrent >= rclClip.bottom))
                {
                // flush the batch
                    if (crow > 0)
                        (*pfnRow)(yTop,arow,crow,pv);

                    return(TRUE);
                }

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yCurrent:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yCurrent;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yCurrent'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTGDI(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i > 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;

        // advance to the top

            yStart = (yStart + 15) >> 4;

            if (yStart < rclClip.top)
            {
                LONG yDelta = rclClip.top - yStart;

            // if x must change, advance to the x by the height of the trap

                if (((ped->pptfx->y >> 4) >= rclClip.top) ||
                    ped->dx || ped->lErrorUp)
                {
                    ped->x += ped->dx * yDelta;

                    LONGLONG eqerr = Int32x32To64(ped->lErrorUp,yDelta);
                    eqerr += (LONGLONG) ped->lError;

                    if (eqerr >= 0)
                    {
                    // warning.  This divide is extremely expensive
                        // NTFIXED 269540 02-02-2000 pravins  GDI-some long
                        // wide geometric lines dont show up in dibsections
                        // We now shift eqerr by 31 bits to the right to see if
                        // the it cannot be just cast as a LONG.

                        if (eqerr >> 31)
                        {
                            // Cannot cast eqerr as a LONG
                            ULONG ulRemainder;
                            eqerr = DIVREM(eqerr,ped->lErrorDown,&ulRemainder);

                            ped->lError = ulRemainder - ped->lErrorDown;
                            ped->x += (LONG)eqerr + 1;
                        }
                        else
                        {
                            // Can cast eqerr as a LONG.
                            ped->x += (LONG) eqerr / ped->lErrorDown + 1;
                            ped->lError = (LONG) eqerr % ped->lErrorDown - ped->lErrorDown;
                        }
                    }
                    else
                        ped->lError = (LONG) eqerr;
                }

            #if DBG
                if (bMsg)
                {
                    DbgPrint("x = %ld, e = %ld, eU = %ld, eD = %ld, cy = %ld, yD = %ld\n",
                              ped->x,ped->lError,ped->lErrorUp, ped->lErrorDown,ped->cy,yDelta);
                    DbgPrint("ptfxold.y = 0x%lx, ptfx.y = 0x%lx, yStart = %ld, yCurrent = %ld\n",
                              pptfxOld->y,ped->pptfx->y,yStart,yCurrent);
                }
            #endif
            }
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;

// make sure we never go off the bottom

    if ((yCurrent + cyTrapezoid) > rclClip.bottom)
        cyTrapezoid = rclClip.bottom - yCurrent;

// If the left and right edges are vertical, simply output as a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 2))
    {
    // must flush any existing rows since rows must be contiguous

        if (crow)
        {
            (*pfnRow)(yTop,arow,crow,pv);
            prow = arow;
            crow = 0;
        }

        LONG xL = aed[LEFT].x;
        LONG xR = aed[RIGHT].x;

        if (xL != xR)
        {
            if (xL > xR)
            {
                LONG l = xL;
                xL = xR;
                xR = l;
            }

        // check if we are clipped

            RECTL rcl;
            rcl.top    = yCurrent;
            rcl.bottom = yCurrent+cyTrapezoid;

            if (prclClip)
            {
                rcl.left   = (xL >= rclClip.left)  ? xL : rclClip.left;
                rcl.right  = (xR <= rclClip.right) ? xR : rclClip.right;

                if (rcl.left < rcl.right)
                    (*pfn)(&rcl,1,pv);
            }
            else
            {
                rcl.left   = xL;
                rcl.right  = xR;
                (*pfn)(&rcl,1,pv);
            }
        }

        yCurrent += cyTrapezoid;

    // done with the current trapezoid

        goto NextEdge;
    }

// make sure we reset yTop when necessary

    if (crow == 0)
        yTop = yCurrent;

// now run the dda, anytime a row is empty, we need to flush the batch

    while (TRUE)
    {
        LONG lWidth = aed[RIGHT].x - aed[LEFT].x;

        if (lWidth > 0)
        {
        // handle the unclipped case quickly

            if (!prclClip)
            {
                prow->left   = aed[LEFT].x;
                prow->right  = aed[RIGHT].x;
                ++crow;
                ++prow;

            CheckForFlush:

                if (crow == MAXROW)
                {
                // flush the batch

                    (*pfnRow)(yTop,arow,crow,pv);
                    prow = arow;
                    crow = 0;
                    yTop = yCurrent + 1;
                }

            ContinueAfterZero:

                // Advance the right wall:

                aed[RIGHT].x      += aed[RIGHT].dx;
                aed[RIGHT].lError += aed[RIGHT].lErrorUp;

                if (aed[RIGHT].lError >= 0)
                {
                    aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                    aed[RIGHT].x++;
                }

                // Advance the left wall:

                aed[LEFT].x      += aed[LEFT].dx;
                aed[LEFT].lError += aed[LEFT].lErrorUp;

                if (aed[LEFT].lError >= 0)
                {
                    aed[LEFT].lError -= aed[LEFT].lErrorDown;
                    aed[LEFT].x++;
                }

                cyTrapezoid--;
                ++yCurrent;

                if (cyTrapezoid == 0)
                    goto NextEdge;

                continue;
            }
            else
            {
            // we are clipped.  Need to do some real work

                prow->left   = (aed[LEFT].x >= rclClip.left)  ? aed[LEFT].x : rclClip.left;
                prow->right  = (aed[RIGHT].x <= rclClip.right) ? aed[RIGHT].x : rclClip.right;

                if (prow->left < prow->right)
                {
                    ++crow;
                    ++prow;
                    goto CheckForFlush;
                }
                else
                {
                // NULL scan - we must flush the batch

                    if (crow)
                    {
                        (*pfnRow)(yTop,arow,crow,pv);
                        prow = arow;
                        crow = 0;
                    }

                    yTop = yCurrent+1;

                // check if we are donewith this trapezoid,
                // if the trap is fully left or fully right

                    if (((aed[LEFT].x < rclClip.left) &&
                         ((aed[LEFT].pptfx->x >> 4) < rclClip.left) &&
                         ((aed[RIGHT].pptfx->x >> 4) < rclClip.left)) ||
                        ((aed[LEFT].x  >= rclClip.right) &&
                         ((aed[LEFT].pptfx->x >> 4) >= rclClip.right) &&
                         ((aed[RIGHT].pptfx->x >> 4) >= rclClip.right)))
                    {
                        yCurrent += cyTrapezoid;

                        goto NextEdge;
                    }
                    goto ContinueAfterZero;
                }
            }

        }
        else if (lWidth == 0)
        {
        // NULL scan - we must flush the batch

            if (crow)
            {
                (*pfnRow)(yTop,arow,crow,pv);
                prow = arow;
                crow = 0;
            }

            yTop = yCurrent + 1;

            goto ContinueAfterZero;
        }
        else
        {
            #define SWAP(a, b, tmp) { tmp = a; a = b; b = tmp; }

            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            EDGEDATA edTmp;
            SWAP(aed[LEFT],aed[RIGHT],edTmp);

            continue;
        }
    }
}


/******************************Public*Routine******************************\
* bFill()
*
*   Fill a path the slow way.  This handles arbitrary paths, builds up a list
*   of rectangles, and calls pfn.
*
*   This code is very similar to RGNMEMOBJ::vCreate.
*
* History:
*  07-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL bFill(
    EPATHOBJ& po,
    PRECTL    prclClip,
    FLONG     flOptions,  // ALTERNATE or WINDING
    PFN_FF    pfn,
    PVOID     pv)
{
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE aEdge[MAX_POINTS];

// Allocate memory for edge storage.

    BOOL bAlloc;
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges

    if (po.cCurves <= MAX_POINTS)
    {
        pFreeEdges = &aEdge[0];
        bAlloc     = FALSE;
    }
    else
    {
        pFreeEdges = (PEDGE)PALLOCNOZ(sizeof(EDGE) * po.cCurves,'gdeG');
        if (pFreeEdges == (PEDGE)NULL)
            return(FALSE);
        bAlloc     = TRUE;
    }

// setup the rectangles for enumeration

    #define MAXRECT 20
    RECTL  arcl[MAXRECT];
    PRECTL prcl = arcl;
    ULONG  crcl = 0;
    RECTL  rclClip;
    RECTL rclBounds,*prclBounds;

    if (prclClip)
    {
        rclClip = *prclClip;

    // we'll pass this to vConstructGET which will clip edges to the top and
    // bottom of the clip rect

        rclBounds.top = prclClip->top << 4;          //we need GIQ coordinats
        rclBounds.bottom = prclClip->bottom << 4;
        prclBounds = &rclBounds;
    }
    else
    {
        rclClip.top    = NEG_INFINITY;
        rclClip.bottom = POS_INFINITY;
        prclBounds = NULL;
    }

// Construct the global edge list.

    pGETHead = &GETHead;
    vConstructGET(po, pGETHead, pFreeEdges,prclBounds);    // bad line coordinates or

    LONG yTop = NEG_INFINITY;   // scan line for which we're currently scanning

// Create an empty AET with the head node also a tail sentinel

    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;   // mark that the AET is empty
    AETHead.Y = 0;              // used as a count for number of edges in AET
    AETHead.X = 0x7FFFFFFF;     // this is greater than any valid X value, so
                                //  searches will always terminate

// Loop through all the scans in the polygon, adding edges from the GET to
// the Active Edge Table (AET) as we come to their starts, and scanning out
// the AET at each scan into a rectangle list. Each time it fills up, the
// rectangle list is passed to the filling routine, and then once again at
// the end if any rectangles remain undrawn. We continue so long as there
// are edges to be scanned out.

    while ( 1 )
    {
    // Advance the edges in the AET one scan, discarding any that have
    // reached the end (if there are any edges in the AET)

        if (AETHead.pNext != pAETHead)
            vAdvanceAETEdges(pAETHead);

    // If the AET is empty, done if the GET is empty, else jump ahead to
    // the next edge in the GET; if the AET isn't empty, re-sort the AET

        if (AETHead.pNext == pAETHead)
        {
        // Done if there are no edges in either the AET or the GET

            if (GETHead.pNext == pGETHead)
                break;

        // There are no edges in the AET, so jump ahead to the next edge in
        // the GET.

            yTop = ((EDGE *)GETHead.pNext)->Y;

        }
        else
        {
        // Re-sort the edges in the AET by X coordinate, if there are at
        // least two edges in the AET (there could be one edge if the
        // balancing edge hasn't yet been added from the GET)

            if (((EDGE *)AETHead.pNext)->pNext != pAETHead)
                vXSortAETEdges(pAETHead);
        }

    // Move any new edges that start on this scan from the GET to the AET;
    // bother calling only if there's at least one edge to add

        if (((EDGE *)GETHead.pNext)->Y == yTop)
            vMoveNewEdges(pGETHead, pAETHead, yTop);

    // Scan the AET into region scans (there's always at least one
    // edge pair in the AET)

        EDGE *pCurrentEdge = AETHead.pNext;   // point to the first edge

        do {

        // The left edge of any given edge pair is easy to find; it's just
        // wherever we happen to be currently

            LONG iLeftEdge = (int)pCurrentEdge->X;

        // Find the matching right edge according to the current fill rule

            if ((flOptions & FP_WINDINGMODE) != 0)
            {
                LONG lWindingCount;

            // Do winding fill; scan across until we've found equal numbers
            // of up and down edges

                lWindingCount = pCurrentEdge->lWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    lWindingCount += pCurrentEdge->lWindingDirection;
                } while (lWindingCount != 0);

            }
            else
            {
            // Odd-even fill; the next edge is the matching right edge

                pCurrentEdge = pCurrentEdge->pNext;
            }

        // See if the resulting span encompasses at least one pixel, and
        // add it to the list of rectangles to draw if so

            if (iLeftEdge < pCurrentEdge->X)
            {
            // Add the rectangle representing the current edge pair

                if (prclClip)
                {
                    prcl->left   = (iLeftEdge >= rclClip.left)  ? iLeftEdge : rclClip.left;
                    prcl->right  = (pCurrentEdge->X <= rclClip.right) ? pCurrentEdge->X : rclClip.right;;
                    prcl->top    = yTop;
                    prcl->bottom = yTop+1;

                    if (prcl->left < prcl->right)
                    {
                        ++crcl;
                        ++prcl;
                    }
                }
                else
                {
                    prcl->left   = iLeftEdge;
                    prcl->right  = pCurrentEdge->X;
                    prcl->top    = yTop;
                    prcl->bottom = yTop+1;
                    ++crcl;
                    ++prcl;
                }

                if (crcl == MAXRECT)
                {
                // flush the batch

                    (*pfn)(arcl,crcl,pv);
                    prcl = arcl;
                    crcl = 0;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        yTop++;    // next scan
    }

// flush the final batch
    if (crcl > 0)
        (*pfn)(arcl,crcl,pv);

    if (bAlloc)
        VFREEMEM(pFreeEdges);

    return(TRUE);
}

/******************************Member*Function*****************************\
* bEngFastFillEnum()
*
*   fill in the path.  If the path only has one sub path and fewer than 40
*   points, try bFastFill.  If we can't use bFastFill, do it the slow way
*   through bFill().
*
* History:
*  27-Sep-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#define QUICKPOINTS 40

BOOL bEngFastFillEnum(
    EPATHOBJ &epo,
    PRECTL   prclClip,
    FLONG    flOptions,
    PFN_FF   pfn,
    PFN_FFROW pfnRow,
    PVOID    pv)
{
    PATHDATA pd;
    BOOL     bRes = FALSE;

// check if there is anything to do

    if (epo.cCurves < 2)
        return(TRUE);

// see if we can do it through fastfill

    epo.vEnumStart();

    if (epo.bEnum(&pd))
    {
        // if this ends the sub path, that means there is more than one sub path.
        // also don't handle if we can't copy points onto stack

        if (!(pd.flags & PD_ENDSUBPATH) && (epo.cCurves <= QUICKPOINTS))
        {
            POINTFIX aptfx[QUICKPOINTS];
            LONG cPoints;
            BOOL bMore;

            RtlCopyMemory(aptfx,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
            cPoints = pd.count;

            do {
                bMore = epo.bEnum(&pd);

                if (pd.flags & PD_BEGINSUBPATH)
                {
                    cPoints = 0;
                    break;
                }

                RtlCopyMemory(aptfx+cPoints,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
                cPoints += pd.count;

            } while(bMore);

            ASSERTGDI(cPoints <= QUICKPOINTS,"bFastFillWrapper - too many points\n");

            if (cPoints)
                bRes = bFastFill(cPoints,aptfx,prclClip,pfn,pfnRow,pv);
        }
    }
    else if (pd.count > 1)
    {
        bRes = bFastFill(pd.count,pd.pptfx,prclClip,pfn,pfnRow,pv);
    }
    else
    {
        bRes = TRUE;
    }

// did we succeed with fast fill?

    if (bRes == FALSE)
    {
        bRes = bFill(epo,prclClip,flOptions,pfn,pv);
    }

    return(bRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fillddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: fillddi.cxx
*
* Contains filling simulations code and help functions.
*
* Created: 04-Apr-1991 17:30:35
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Member*Function*****************************\
* EngFillPath
*
*  This routine first converts the given pathobj to rgnmemobj then
*  calls EngPaint to fill.
*
* History:
*  07-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote to call (Drv/Eng)Paint
*
*  13-Feb-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL EngFillPath(
 SURFOBJ  *pso,
 PATHOBJ  *ppo,
 CLIPOBJ  *pco,
 BRUSHOBJ *pbo,
 PPOINTL   pptlBrushOrg,
 MIX       mix,
 FLONG     flOptions
)
{
    GDIFunctionID(EngFillPath);
    ASSERTGDI(pso != (SURFOBJ *) NULL, "pso is NULL\n");
    ASSERTGDI(ppo != (PATHOBJ *) NULL, "ppo is NULL\n");
    ASSERTGDI(pco != (CLIPOBJ *) NULL, "pco is NULL\n");

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);
    PDEVOBJ po(pSurf->hdev());
    SUSPENDWATCH sw(po);

    ASSERTGDI(pco->iMode == TC_RECTANGLES, "Invalid clip object iMode");

// Check if we have to flatten any Beziers:

    if (ppo->fl & PO_BEZIERS)
        if (!((EPATHOBJ*) ppo)->bFlatten())
            return(FALSE);

// Before we touch any bits, make sure the device is happy about it.

    po.vSync(pso,&pco->rclBounds,0);

// check if we can try the fast fill.

    if (!( pSurf->flags() & HOOK_PAINT) &&
         (pco->iDComplexity != DC_COMPLEX))
    {
        PRECTL prclClip = NULL;

        if ((pco->iDComplexity == DC_RECT) ||
            (pco->fjOptions & OC_BANK_CLIP))
        {
            RECTFX rcfx = ((EPATHOBJ*)ppo)->rcfxBoundBox();

        // check the bound box, maybe it really is unclipped

            if ((pco->rclBounds.left   > (rcfx.xLeft          >> 4)) ||
                (pco->rclBounds.right  < ((rcfx.xRight  + 15) >> 4)) ||
                (pco->rclBounds.top    > (rcfx.yTop           >> 4)) ||
                (pco->rclBounds.bottom < ((rcfx.yBottom + 15) >> 4)))
            {
                prclClip = &pco->rclBounds;
            }
        }

    // -1 - couldn't handle, 0 error, 1 success

        LONG lRes = EngFastFill(pso,ppo,prclClip,pbo,pptlBrushOrg,mix,flOptions);
        if (lRes >= 0)
            return(lRes);
    }

// Convert path to region.

    RECTL Bounds,*pBounds;

    if( pco->iDComplexity != DC_TRIVIAL )
    {
        Bounds.top = (pco->rclBounds.top) << 4;
        Bounds.bottom = (pco->rclBounds.bottom) << 4;
        pBounds = &Bounds;
    }
    else
    {
        pBounds = NULL;
    }

    RGNMEMOBJTMP rmo(*((EPATHOBJ *)ppo), flOptions, pBounds);

    if (!rmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (rmo.iComplexity() == NULLREGION)
        return(TRUE);

// CLIPOBJ_bEnum will do the clipping if clipping is not complex.

    ERECTL erclClip(pco->rclBounds);

    if (pco->iDComplexity == DC_TRIVIAL)
    {
        ECLIPOBJ    ecoPath(rmo.prgnGet(), erclClip);
        if (ecoPath.erclExclude().bEmpty())
            return(TRUE);

        if (ecoPath.iDComplexity == DC_TRIVIAL)
            ecoPath.iDComplexity = DC_RECT;

    // Inc the target surface uniqueness

        INC_SURF_UNIQ(pSurf);

        BOOL    bRet;
        sw.Resume();
        
        bRet = EngPaint(
            pso,                                // Destination surface.
           &ecoPath,                            // Clip object.
            pbo,                                // Realized brush.
            pptlBrushOrg,                       // Brush origin.
            mix);                               // Mix mode.

        return(bRet);
    }

// Create a RGNMEMOBJ for bMerge since it will trash the target.

    RGNMEMOBJTMP rmoTrg;

    if (!rmoTrg.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

// Merge the region we just constructed with the clip region.

    if (!rmoTrg.bMerge(rmo, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
        return(FALSE);

    ERECTL  ercl;
    rmoTrg.vGet_rcl(&ercl);

    ercl *= ((ECLIPOBJ *)pco)->erclExclude();

    ECLIPOBJ co(rmoTrg.prgnGet(), ercl);

    if (co.erclExclude().bEmpty())
        return(TRUE);

    if (co.iDComplexity == DC_TRIVIAL)
        co.iDComplexity = DC_RECT;

// Inc the target surface uniqueness

    INC_SURF_UNIQ(pSurf);
    sw.Resume();

    sw.Resume();
    return(EngPaint(
        pso,                                // Destination surface.
       &co,                                 // Clip object.
        pbo,                                // Realized brush.
        pptlBrushOrg,                       // Brush origin.
        mix));                              // Mix mode.
}

/******************************Member*Function*****************************\
* EngStrokeAndFillPath
*
*  Engine simulation for stroking and filling the given path.
*
* History:
*  06-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Re-wrote it to do region subtraction.
*
*  02-Oct-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL EngStrokeAndFillPath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pboStroke,
LINEATTRS *pla,
BRUSHOBJ  *pboFill,
POINTL    *pptlBrushOrg,
MIX        mix,
FLONG      flOptions)
{
    BOOL bRet = FALSE;

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    MIX mixFill, mixStroke;

    mixFill = mixStroke = mix;

    if (!((EBRUSHOBJ *)pboFill)->bIsMasking())
    {
        mixFill = (mix & 0xff) | ((mix & 0xff) << 8);
    }

    if (!((EBRUSHOBJ *)pboStroke)->bIsMasking())
    {
        mixStroke = (mix & 0xff) | ((mix & 0xff) << 8);
    }

    ERECTL ercl;

    // If we're not doing a wide-line, or if we're doing a wide-line and
    // the mix is overwrite so we don't care about re-lighting pixels,
    // make two calls out of it:

    if (!(pla->fl & LA_GEOMETRIC) || ((mix & 0xFF) == R2_COPYPEN))
    {
        bRet = EngFillPath(pso,
                           ppo,
                           pco,
                           pboFill,
                           pptlBrushOrg,
                           mixFill,
                           flOptions) &&
               EngStrokePath(pso,
                             ppo,
                             pco,
                             pxo,
                             pboStroke,
                             pptlBrushOrg,
                             pla,
                             mixStroke);
        return(bRet);
    }

    // Okay, we have a wideline call with a weird mix mode.  Because part
    // of the wide-line overlaps part of the fill, we will convert both to
    // regions, and subtract them so that they won't overlap.

    // Convert the widened outline to a region.  We have to widen the path
    // before flattening it (for the fill) because the widener will produce
    // better looking wide curves that way:

    PATHMEMOBJ pmoStroke;

    if (!pmoStroke.bValid() ||
        !pmoStroke.bComputeWidenedBounds(*(EPATHOBJ*) ppo, pxo, pla) ||
        !pmoStroke.bWiden(*(EPATHOBJ*) ppo, pxo, pla))
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }

    // First flatten any curves and then convert the interior to a region:

    if (ppo->fl & PO_BEZIERS)
    {
        if (!((EPATHOBJ*) ppo)->bFlatten())
        {
            return(bRet);
        }
    }

    // Create the regions:

    RGNMEMOBJTMP rmoStroke(pmoStroke, WINDING);
    RGNMEMOBJTMP rmoFill(*((EPATHOBJ *)ppo), flOptions);
    RGNMEMOBJTMP rmoNewFill;

    if (rmoFill.bValid() &&
        rmoStroke.bValid() &&
        rmoNewFill.bValid() &&
        rmoNewFill.bMerge(rmoFill, rmoStroke, gafjRgnOp[RGN_DIFF]))
    {
        // Create a RGNMEMOBJ for bMerge since it will trash the target.

        RGNMEMOBJTMP rmoTrg;

        if (rmoTrg.bValid())
        {
            PDEVOBJ pdo(pSurf->hdev());

            // Paint the stroked outline:

            if (rmoStroke.iComplexity() != NULLREGION)
            {
                // Merge the outline region with the clip region:

                if (!rmoTrg.bMerge(rmoStroke, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
                {
                    bRet = FALSE;
                }
                else
                {
                    rmoTrg.vGet_rcl(&ercl);
                    ECLIPOBJ co(rmoTrg.prgnGet(), ercl);

                    if (co.erclExclude().bEmpty())
                    {
                        bRet = TRUE;
                    }
                    else
                    {
                        INC_SURF_UNIQ(pSurf);

                        bRet = EngPaint(
                                pso,
                                &co,
                                pboStroke,
                                pptlBrushOrg,
                                mixStroke);

                    }
                }
            }

            // Paint the filled interior:

            if ((bRet == TRUE) &&
                rmoNewFill.iComplexity() != NULLREGION)
            {
                // Merge the inside region with the clip region.

                if (!rmoTrg.bMerge(rmoNewFill, *((ECLIPOBJ *)pco), gafjRgnOp[RGN_AND]))
                {
                    bRet = FALSE;
                }
                else
                {
                    rmoTrg.vGet_rcl(&ercl);
                    ECLIPOBJ co(rmoTrg.prgnGet(), ercl);

                    if (co.erclExclude().bEmpty())
                    {
                        bRet = TRUE;
                    }
                    else
                    {
                        INC_SURF_UNIQ(pSurf);

                        bRet = EngPaint(pso,
                                        &co,
                                        pboFill,
                                        pptlBrushOrg,
                                        mixFill);
                    }
                }
            }
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\floodgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: floodgdi.cxx
*
* Contains FLOODFILL and its helper functions.
*
* Created: 20-May-1991 14:33:19
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Valid iMode for bExpandScanline().

#define EXPAND_MERGE_SCANLINE   1
#define EXPAND_SCRATCH_SCANLINE 0

// Valid iMode fore STACKMEMOBJ().

#define ALLOC_MERGE_SCANLINE   1
#define DONT_ALLOC_MERGE_SCANLINE 0


#define FLOOD_REGION_SIZE  (NULL_REGION_SIZE                                 + \
                           (NULL_SCAN_SIZE + (sizeof(INDEX_LONG) * 2)) * 200 + \
                            NULL_SCAN_SIZE)

typedef struct _SPAN
{
    LONG    xLeft;      // inclusive left
    LONG    xRight;     // exclusive right
}SPAN, *PSPAN;

class SCANLINE;
typedef SCANLINE *PSCANLINE ;

/*********************************Class************************************\
* class SCANLINE
*
* This variable length structure describes an area in a scanline which
* should be filled.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class SCANLINE
{
public:
    LONG        y;                  // y coordinate of this scanline
    COUNT       cSpans;             // number of spans
    ULONGSIZE_T      cjScanline;         // size in byte of this scanline
    PSCANLINE   psclBelow;          // -> the scanline below
    SPAN        aSpan[1];           // variable length of spans
};

#define SCANLINEHEADER_SIZE (sizeof(SCANLINE) - sizeof(SPAN))

// The stack is empty when psclTop->psclBelow points to psclTop itself.
// At this time, cjStack must be 0.

/*********************************Class************************************\
* class STACKOBJ
*
* Stack to hold SCANLINEs in the order of the flooding.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class STACKOBJ
{
public:
    ULONGSIZE_T      cjObj;              // size of the memory allocated
    ULONGSIZE_T      cjStack;            // size of the object used
    PSCANLINE   psclTop;            // -> the scanline at the top of the stack
    PSCANLINE   psclScratch;        // -> the sratch scanline
    PSCANLINE   psclMerge;          // -> the merging scanline
    PBYTE       pjStackBase;        // the base address of this stack

public:
    SCANLINE&   scl2ndTop()         { return(*(psclTop->psclBelow)); }
    BOOL        bValid()            { return(pjStackBase != (PBYTE)NULL); }
    LONG        yTop()              { return(psclTop->y); }
    LONG        y2ndTop()           { return((psclTop->psclBelow)->y); }
    BOOL        bEmpty()            { return(cjStack == 0); }
    BOOL        bNotEmpty()         { return(cjStack != 0); }
    BOOL        bMoreThanOneEntry() { return(psclTop->psclBelow != (PSCANLINE)NULL); }
    BOOL        bExpand(ULONGSIZE_T cj);
    BOOL        bExpandScanline(ULONGSIZE_T cj, ULONG iMode);
    VOID        vPop()
    {
        ASSERTGDI(bNotEmpty(), "Pop an empty stack");
        cjStack -= psclTop->cjScanline;
        psclTop = psclTop->psclBelow;
    }

    BOOL         bPushMergeScrScan();
    BOOL         bPopPushMergeScrScan()
    {
        vPop();
        return(bPushMergeScrScan());
    }

};

/*********************************Class************************************\
* class STACKMEMOBJ
*
* Memory object for STACKOBJ.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class STACKMEMOBJ : public STACKOBJ
{
public:
    STACKMEMOBJ(ULONGSIZE_T cj, ULONG iMode, LONG y, LONG xLeft, LONG xRight);
   ~STACKMEMOBJ();
};

#define SCRATCH_SCANLINE_SIZE   SCANLINEHEADER_SIZE + 20 * sizeof(SPAN)
#define MERGE_SCANLINE_SIZE     SCANLINEHEADER_SIZE + 20 * sizeof(SPAN)
#define SCANLINE_INC_SIZE       20 * sizeof(SPAN)
#define DOWNSTACK_SIZE          sizeof(STACKOBJ) + 2 * SCRATCH_SCANLINE_SIZE
#define UPSTACK_SIZE            sizeof(STACKOBJ) + 10 * SCRATCH_SCANLINE_SIZE
#define STACK_INC_SIZE          10 * SCRATCH_SCANLINE_SIZE

/*********************************Class************************************\
* class FLOODBM
*
* Contains information about FloodFill and the destination bitmap where
* it takes place.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

class FLOODBM
{
public:
    ULONG iFormat;      // format of the bitmap
    RECTL rcl;          // clipping rectangle
    ULONG iColor;       // color passed in to ExtFloodFill
    DWORD iFillType;    // filling mode passed in to ExtFloodFill
    PBYTE pjBits;       // pointer to the current scanline
    FLONG flMask;       // mask of used bits

public:
    FLOODBM(ULONG _iFormat, RECTL& _rcl, ULONG _iColor,
             DWORD _iFillType, PBYTE _pjBits, PALETTE  *pPal);

   ~FLOODBM()          {}

    ULONG iColorGet(LONG x);
    VOID  vFindExtent(LONG x, LONG& xLeft, LONG& xRight);
    BOOL  bSearchAllSpans(LONG xLeft, LONG xRight, LONG& xLeftNew, LONG& xRightNew,
                          PBYTE pjStart, STACKOBJ& sto, PSCANLINE pscl);
    BOOL  bExtendScanline(STACKOBJ& st, STACKOBJ& stOp, LONG lyNxt,
                          PBYTE pjBitsCur, PBYTE pjBitsNxt);
};

/******************************Public*Routine******************************\
* FLOODBM::FLOODBM(
*
* History:
*  16-Aug-1994 -by-  Eric Kutter [erick]
* Made it out of line.
\**************************************************************************/

FLOODBM::FLOODBM(
    ULONG _iFormat,
    RECTL& _rcl,
    ULONG _iColor,
    DWORD _iFillType,
    PBYTE _pjBits,
    PALETTE  *pPal)
{
    iFormat = _iFormat;
    rcl = _rcl;
    iColor = _iColor;
    iFillType = _iFillType;
    pjBits = _pjBits;
    flMask = 0xffffffff;

    XEPALOBJ pal(pPal);

    if (pal.bValid())
    {
        if (pal.bIsRGB() || pal.bIsBGR())
            flMask =0xffffff;
        else if (pal.bIsBitfields())
            flMask = pal.flRed() | pal.flGre() | pal.flBlu();
    }
}

/******************************Member*Function*****************************\
* VOID vMergeSpans(pspnSrc1, pspnEndSrc1, pspnSrc2, pspnEndSrc2, pspnTrg)
*
*  Merge two arrays of spans together and store into the target span.
*
* History:
*  12-Jun-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID vMergeSpans(PSPAN pspnSrc1, PSPAN pspnEndSrc1,
                 PSPAN pspnSrc2, PSPAN pspnEndSrc2, PSPAN pspnTrg)
{
    while((pspnSrc1 < pspnEndSrc1) && (pspnSrc2 < pspnEndSrc2))
    {
        if (pspnSrc1->xLeft < pspnSrc2->xLeft)
        {
            ASSERTGDI((pspnSrc1->xRight < pspnSrc2->xLeft),
                      "vMergeSpans walls overlapped\n");
            *pspnTrg++ = *pspnSrc1++;
        }
        else
        {
            ASSERTGDI((pspnSrc2->xRight < pspnSrc1->xRight),
                      "vMergeSpans walls overlapped\n");

            *pspnTrg++ = *pspnSrc2++;
        }
    }

    while (pspnSrc1 < pspnEndSrc1)
        *pspnTrg++ = *pspnSrc1++;

    while (pspnSrc2 < pspnEndSrc2)
        *pspnTrg++ = *pspnSrc2++;
}

/******************************Member*Function*****************************\
* STACKMEMOBJ::STACKMEMOBJ(cj, bMerge, y, xLeft, xRight)
*
*  Constructor.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

STACKMEMOBJ::STACKMEMOBJ(ULONGSIZE_T cj, ULONG iMode, LONG y,
                         LONG xLeft, LONG xRight)
{
    psclMerge = (PSCANLINE)NULL;
    pjStackBase = (PBYTE)NULL;

    psclScratch = (PSCANLINE)PALLOCNOZ(SCRATCH_SCANLINE_SIZE, 'dlFG');

    if (psclScratch == (PSCANLINE)NULL)
    {
        return;
    }

    psclScratch->cjScanline = SCRATCH_SCANLINE_SIZE;
    psclScratch->cSpans = 0;

    if (iMode == ALLOC_MERGE_SCANLINE)
    {
        psclMerge = (PSCANLINE)PALLOCNOZ(MERGE_SCANLINE_SIZE, 'dlFG');
        if (psclMerge == (PSCANLINE)NULL)
            return;
        psclMerge->cjScanline = MERGE_SCANLINE_SIZE;
        psclMerge->cSpans = 0;
    }

    cjObj = cj;
    cjStack = sizeof(SCANLINE);
    pjStackBase = (PBYTE)PALLOCNOZ(cj, 'dlFG');
    if (pjStackBase == (PBYTE)NULL)
        return;

    psclTop = (PSCANLINE)pjStackBase;

    psclTop->y = y;
    psclTop->cSpans = 1;
    psclTop->cjScanline = sizeof(SCANLINE);
    psclTop->psclBelow = psclTop;
    psclTop->aSpan[0].xLeft = xLeft;
    psclTop->aSpan[0].xRight = xRight;
}

/******************************Member*Function*****************************\
* STACKMEMOBJ::~STACKMEMOBJ()
*
*  Destructor.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

STACKMEMOBJ::~STACKMEMOBJ()
{
    if (pjStackBase != (PBYTE)NULL)
        VFREEMEM(pjStackBase);
    if (psclScratch != (PSCANLINE)NULL)
        VFREEMEM(psclScratch);
    if (psclMerge != (PSCANLINE)NULL)
        VFREEMEM(psclMerge);

    psclScratch = psclMerge = (PSCANLINE)NULL;
    pjStackBase = (PBYTE)NULL;
}

/******************************Member*Function*****************************\
* BOOL STACKOBJ::bPushMergeScrScan()
*
* Push the scanline pointed to by psclScratch onto the stack.  If the y
* of the given scanline is the same as the y of the scanline on top of the
* stack, merge them together.
*
* History:
*  06-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL STACKOBJ::bPushMergeScrScan()
{
// Get out of here if nothing to push.

    if (psclScratch->cSpans == 0)
        return(TRUE);

#ifdef DBG_FLOOD

    DbgPrint("bPushMergeScrScan: y = %ld, cSpans = %ld\n",
              psclScratch->y,psclScratch->cSpans);

    for (COUNT j = 0; j < psclScratch->cSpans; j++)
        DbgPrint("                 Left = %ld, Right = %ld\n",
                  psclScratch->aSpan[j].xLeft,psclScratch->aSpan[j].xRight);
#endif

    PSCANLINE psclNew = psclScratch;

    ULONGSIZE_T cjNew = SCANLINEHEADER_SIZE + (ULONGSIZE_T)psclNew->cSpans * sizeof(SPAN);
    ULONGSIZE_T cjInc = cjNew;

// If we'll have to do merge later on.  The cjInc is SCANLINEHEADER_SIZE
// bigger than the actual stack size increase after this function.  We
// might end up expanding the stack unnecessarily.  But it's OK since
// we're so close to use up our stack space and subsequent calls might
// cause stack expansion anyway.

    if ((cjStack + cjInc) > cjObj)
    {
        if (!bExpand(cjStack + cjNew))
            return(FALSE);
    }

    psclNew->psclBelow = psclTop;

// Check if merge is necessary.

    if (bNotEmpty())
    {
        if (yTop() == psclScratch->y)
        {
        // We have to do merge here.

            ASSERTGDI((psclMerge != (PSCANLINE)NULL),
                      "bPushMergeScrScan:invalid psclMerge");

            cjNew += psclTop->cjScanline - SCANLINEHEADER_SIZE;
            cjInc -= SCANLINEHEADER_SIZE;

            if (cjNew > psclMerge->cjScanline)
            {
                if (!bExpandScanline(cjNew, EXPAND_MERGE_SCANLINE))
                    return(FALSE);
            }

            ASSERTGDI((cjNew <= psclMerge->cjScanline),
                      "bPushMergeScrScan: did not alloc enough space\n");

            psclMerge->y = psclScratch->y;
            psclMerge->psclBelow = psclTop->psclBelow;
            psclMerge->cSpans = psclTop->cSpans + psclScratch->cSpans;

            vMergeSpans((PSPAN)&psclTop->aSpan[0].xLeft,
                        (PSPAN)&psclTop->aSpan[psclTop->cSpans].xLeft,
                        (PSPAN)&psclScratch->aSpan[0].xLeft,
                        (PSPAN)&psclScratch->aSpan[psclScratch->cSpans].xLeft,
                        (PSPAN)&psclMerge->aSpan[0].xLeft);

            psclNew = psclMerge;
        }
        else
        {
        // No merge is necessary.  Update pointers so we'll push to the
        // right spot.

            PBYTE pj = (PBYTE)psclTop + psclTop->cjScanline;
            psclTop = (PSCANLINE)pj;
        }
    }

    cjStack += cjInc;

    ASSERTGDI((cjStack <= cjObj),
              "bPushMergeScrScan: bExpand() failed to alloc enough space\n");

    ASSERTGDI((cjNew == (psclNew->cSpans * sizeof(SPAN) + SCANLINEHEADER_SIZE)),
              "bPushMergeScrScan: wrong cjNew\n");

    ASSERTGDI(((pjStackBase + cjStack) ==
               ((PBYTE)psclTop + cjNew)),
               "bPushMergeScrScan: stack error\n");

    psclNew->cjScanline = cjNew;
    RtlCopyMemory(psclTop, psclNew, cjNew);

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL STACKOBJ::bExpand(cj)
*
*  Expand the stack to the given size plus a size defined as STACK_INC_SIZE.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL STACKOBJ::bExpand(ULONGSIZE_T cj)
{
#ifdef DBG_FLOOD
    DbgPrint("Enter STACKOBJ::bExpand()\n");
#endif

    PBYTE pjStackBaseOld = pjStackBase;

    pjStackBase = (PBYTE)PALLOCNOZ(cj + STACK_INC_SIZE, 'dlFG');
    if (pjStackBase == (PBYTE)NULL)
        return(FALSE);

// Copy the contents of the old stack into the new one.

    RtlCopyMemory((PLONG)pjStackBase, (PLONG)pjStackBaseOld, cjStack);

    cjObj = cj + STACK_INC_SIZE;

// Update all the pointers in the stack.

    //Sundown: safe to truncate to ULONG since cjStack won't exceed 4gb
    PTRDIFF pdDiff = (ULONG)(pjStackBase - pjStackBaseOld);
    PBYTE pl = (PBYTE)psclTop + pdDiff;
    PSCANLINE pscl = psclTop = (PSCANLINE)pl;

    if (cjStack == 0)
    {
        psclTop->psclBelow = psclTop;
    }
    else
    {
        while (pscl->psclBelow != (PSCANLINE)pjStackBase)
        {
            pl = (PBYTE)pscl->psclBelow + pdDiff;
            pscl = (pscl->psclBelow = (PSCANLINE)pl);
        }
    }

// Free the old stack.

    VFREEMEM(pjStackBaseOld);
    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL STACKOBJ::bExpandScanline(cj, iMode)
*
*  Expand the stack.
*
* History:
*  08-Sep-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL STACKOBJ::bExpandScanline(ULONGSIZE_T cj, ULONG iMode)
{
#ifdef DBG_FLOOD
    DbgPrint("Enter STACKOBJ::bExpandScanline()\n");
#endif

    PSCANLINE pscl, psclNew;

    if (iMode == EXPAND_MERGE_SCANLINE)
        pscl = psclMerge;
    else
        pscl = psclScratch;

    ASSERTGDI((pscl != (PSCANLINE)NULL), "bExpandScanline: pscl is NULL");

// Allocate memory for the new scanline then copy the contents over.

    psclNew = (PSCANLINE)PALLOCNOZ((cj + SCANLINE_INC_SIZE), 'dlFG');
    if (psclNew == (PSCANLINE)NULL)
        return(FALSE);

    RtlCopyMemory(psclNew, pscl, pscl->cjScanline);

// Reflect the size of the new scanline and free the old scanline.

    psclNew->cjScanline = cj + SCANLINE_INC_SIZE;
    VFREEMEM(pscl);

// Store the pointer back into the stack.

    if (iMode == EXPAND_MERGE_SCANLINE)
        psclMerge = psclNew;
    else
        psclScratch = psclNew;

    return(TRUE);
}

/******************************Member*Function*****************************\
* ULONG FLOODBM::iColorGet(LONG x)
*
*  Get the color of the given x.  pjBits points to the first pel of the
*  y scanline.  iFormat gives the format of the bitmap.
*
* History:
*  13-Jun-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

ULONG FLOODBM::iColorGet(LONG x)
{
    ULONG ulColor;

    switch(iFormat)
    {
    case BMF_1BPP:
        ulColor = (ULONG) *(pjBits + (x >> 3));
        ulColor = ulColor >> (7 - (x & 7));
        return(ulColor & 1);

    case BMF_4BPP:
        ulColor = (ULONG) *(pjBits + (x >> 1));

        if (x & 1)
            return(ulColor & 15);
        else
            return(ulColor >> 4);

    case BMF_8BPP:
        return((ULONG) *(pjBits + x));

    case BMF_16BPP:
        return(((ULONG) *((PUSHORT) (pjBits + (x << 1)))) & flMask);

    case BMF_24BPP:
        {
            PBYTE   pjX = pjBits + (x * 3);
            ulColor = (ULONG) *(pjX + 2);
            ulColor <<= 8;
            ulColor |= ((ULONG) *(pjX + 1));
            ulColor <<= 8;
            return(ulColor | ((ULONG) *pjX));
        }

    case BMF_32BPP:
        return(((ULONG) *((PULONG) (pjBits + (x << 2)))) & flMask);

    default:
        RIP("iColorGet error\n");
    }
    return(0L);
}

/******************************Private*Routine*****************************\
* VOID FLOODBM::vFindExtent(x, xEnd, &xLeft, &xRight)
*
* Find the pixel extent in this scan that should be filled.
* x is the seed for this scan.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID FLOODBM::vFindExtent(LONG x, LONG& xLeft, LONG& xRight)
{
    LONG xLeftTemp = x - 1;
    LONG xRightTemp = x + 1;

    if (iFillType == FLOODFILLBORDER)
    {
        ASSERTGDI((iColorGet(x) != iColor),
                  "vFindExtent x has wrong color\n");

        while((xLeftTemp >= rcl.left) && (iColorGet(xLeftTemp) != iColor))
            xLeftTemp--;

        while((xRightTemp < rcl.right) && (iColorGet(xRightTemp) != iColor))
            xRightTemp++;
    }
    else
    {
        ASSERTGDI((iColorGet(x) == iColor),
                  "vFindExtent x has wrong color\n");

        while((xLeftTemp >= rcl.left) && (iColorGet(xLeftTemp) == iColor))
            xLeftTemp--;

        while((xRightTemp < rcl.right) && (iColorGet(xRightTemp) == iColor))
            xRightTemp++;
    }

    xLeft = xLeftTemp + 1;      // the extreme left pixel
    xRight = xRightTemp;        // the extreme right pixel

    ASSERTGDI((xLeft != xRight),"vFindExtent error\n");
}

/******************************Member*Function*****************************\
* BOOL FLOODBM::bSearchAllSpans(xLeft, xRight, xMax, pjStart, psclNew, pscl)
*
*  Search for all the spans between the given xLeft and xRight.
*
* History:
*  11-Jun-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL FLOODBM::bSearchAllSpans(LONG xLeft, LONG xRight,
                               LONG& xLeftNew, LONG& xRightNew,
                               PBYTE pjStart, STACKOBJ& sto, PSCANLINE pscl)
{
#ifdef DBG_FLOOD
    DbgPrint("bSearchAllSpans xLeft = %ld, xRight = %ld, pjStart = %ld\n",
              xLeft,xRight,pjStart);
#endif

    PSCANLINE psclNew = sto.psclScratch;    // We'll store the new scanline
                                            // at the location pointed to by
                                            // sto.psclScratch.
    LONG x = xLeft;
    COUNT cSpans = psclNew->cSpans;
    ULONGSIZE_T cjNew = SCANLINEHEADER_SIZE + (ULONGSIZE_T)cSpans * sizeof(SPAN);
                                        // size of scanline that has been used
    pjBits = pjStart;                   // update pointer to the current
                                        // scanline in the FLOODBM struct
    while (x < xRight)
    {
    // find the first pixel to fill.

        if (iFillType == FLOODFILLBORDER)
        {
            if (iColorGet(x) == iColor)
            {
                do { x++; }
                while ((x < xRight) && (iColorGet(x) == iColor));
            }
        }
        else
        {
            if (iColorGet(x) != iColor)
            {
                do { x++; }
                while ((x < xRight) && (iColorGet(x) != iColor));
            }
        }

        if (x == xRight)
            break;


    // Don't have to search for extent if we already know it.

        BOOL bNeedSearch = TRUE;

        if (pscl != (PSCANLINE)NULL)
        {
        // pscl points to a sorted list of spans that we found for this
        // scanline before.  See if x is within any of the spans.

            for (COUNT i = 0; i < pscl->cSpans; i++)
            {
                if (x >= pscl->aSpan[i].xLeft)
                {
                    if (x < pscl->aSpan[i].xRight)
                    {
                        x = pscl->aSpan[i].xRight;
                        bNeedSearch = FALSE;
                        break;
                    }
                }
                else break;
            }
        }

        if (bNeedSearch)
        {
        // sclNew contains an un-sorted list of spans that we just found
        // for this scanline.  See if x is within any of the spans.

            for (COUNT i = 0; i < psclNew->cSpans; i++)
            {
                if ((x >= psclNew->aSpan[i].xLeft) &&
                    (x < psclNew->aSpan[i].xRight))
                {
                    x = psclNew->aSpan[i].xRight;
                    bNeedSearch = FALSE;
                    break;
                }
            }

            if (bNeedSearch)
            {
            // Find the pixel boundary of the current span

                if ((cjNew += sizeof(SPAN)) > psclNew->cjScanline)
                {
                    if (!sto.bExpandScanline(cjNew, EXPAND_SCRATCH_SCANLINE))
                        return(FALSE);          // allocation failed

                    psclNew = sto.psclScratch;
                }

                ASSERTGDI((cjNew <= psclNew->cjScanline),
                          "bSearchAllSpans: did not alloc enough space\n");

                vFindExtent(x, psclNew->aSpan[psclNew->cSpans].xLeft,
                               psclNew->aSpan[psclNew->cSpans].xRight);

                x = psclNew->aSpan[psclNew->cSpans].xRight + 1;
                psclNew->cSpans++;
            }
        }
    }

    if (cSpans == psclNew->cSpans)
        xLeftNew = xRightNew = 0;
    else
    {
    // Store the new xLeft and xRight onto the stack.

        xLeftNew = psclNew->aSpan[cSpans].xLeft;
        xRightNew = psclNew->aSpan[psclNew->cSpans-1].xRight;

    // Sort the spans out.

        for (COUNT i = 0; i < (psclNew->cSpans - 1); i++)
        {
            LONG xMin = psclNew->aSpan[i].xLeft;
            ULONG iMin = i;

            for (COUNT j = i; j < psclNew->cSpans; j++)
            {
                if (psclNew->aSpan[j].xLeft < xMin)
                {
                    xMin = psclNew->aSpan[j].xLeft;
                    iMin = j;
                }
            }

        // Swap the first span with the span with the smallest x.

            if (i != iMin)
            {
                SPAN sp = psclNew->aSpan[i];
                psclNew->aSpan[i] = psclNew->aSpan[iMin];
                psclNew->aSpan[iMin] = sp;
            }
        }

#ifdef DBG_FLOOD
    DbgPrint("bSearchAllSpans xLeftNew = %ld, xRightNew = %ld\n",
              xLeftNew,xRightNew);
#endif
    }

    return(TRUE);
}

/******************************Private*Routine*****************************\
* BOOL FLOODBM::bExtendScanline(&sto, &stoOp, lyNxt, pjBitsCur, pjBitsNxt)
*
* Check if the next scanline is previously filled or is a boundary.  If not,
* find the span of the next scanline and search for any spillage.  Push
* the resultant spans onto the stack.
*
* History:
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL FLOODBM::bExtendScanline(STACKOBJ& sto, STACKOBJ& stoOp, LONG lyNext,
                               PBYTE pjBitsCurr, PBYTE pjBitsNext)
{
// For each span in the current scanline, find the spans for the next scanline.

    PSCANLINE pscl = sto.psclTop;            // top of current stack

// psclCurr and psclNext point to the scanlines we're about to extend
// to.  The space for these scanlines were allocated in STACKMEMOBJ()
// and are used over and over again in this routine so that reallocation
// is not needed every time we enter here.

    PSCANLINE psclCurr = stoOp.psclScratch;
    PSCANLINE psclNext = sto.psclScratch;
    psclNext->cSpans = psclCurr->cSpans = 0;
    psclCurr->y = pscl->y; psclNext->y = lyNext;
    PSCANLINE psclNextOld = (PSCANLINE)NULL;

// See if we've handled the next scanline before.  If we do, pass the
// structure to bSearchAllSpans() to eliminate searching for the same
// extents twice.  If the next scanline was dealt with before, its
// must be stored in the current stack at the 2nd entry from the top.

    if (sto.bMoreThanOneEntry() && (sto.y2ndTop() == lyNext))
        psclNextOld = &sto.scl2ndTop();

    BOOL bReturn = TRUE;

    for (COUNT i = 0; i < pscl->cSpans; i++)
    {
        LONG xLeft = pscl->aSpan[i].xLeft;
        LONG xRight = pscl->aSpan[i].xRight;
        LONG xLeftNew, xRightNew, xTemp;

        bReturn = bSearchAllSpans(xLeft, xRight, xLeftNew, xRightNew,
                                  pjBitsNext, sto, psclNextOld);

        if(!bReturn)
        {
            break; 
        }
       
        if (xLeftNew != xRightNew)
        {
search_left:
            if (xLeftNew < (xLeft - 1))
            {
            // Check for spillage on the left for the current scanline.

                xTemp = xLeft - 1;
                xLeft = xLeftNew;

                bReturn &= bSearchAllSpans(xLeft, xTemp, xLeftNew, xTemp,
                                           pjBitsCurr, stoOp, pscl);

                if(!bReturn) 
                {
                    break; 
                }

                if ((xLeftNew != xTemp) && (xLeftNew < (xLeft - 1)))
                {
                // Check for spillage on the left for the next scanline.

                    xTemp = xLeft - 1;
                    xLeft = xLeftNew;

                    bReturn &= bSearchAllSpans(xLeft, xTemp, xLeftNew, xTemp,
                                               pjBitsNext, sto, psclNextOld);

                    if(!bReturn)
                    {
                        break; 
                    }

                    if (xLeftNew != xTemp)
                        goto search_left;
                }
            }

search_right:

            if (xRightNew > (xRight + 1))
            {
            // Check for spillage on the right for the current scanline.

                xTemp = xRight + 1;
                xRight = xRightNew;

                bReturn &= bSearchAllSpans(xTemp, xRight, xLeftNew, xRightNew,
                                           pjBitsCurr, stoOp, pscl);
                if(!bReturn)
                {
                    break;
                }

                if ((xLeftNew != xRightNew) && (xRightNew > (xRight + 1)))
                {
                // Check for spillage on the right for the next scanline.

                    xTemp = xRight + 1;
                    xRight = xRightNew;

                    bReturn &= bSearchAllSpans(xTemp, xRight, xLeftNew,
                                xRightNew, pjBitsNext, sto, psclNextOld);
                    if(!bReturn)
                    {
                        break;
                    }

                    if (xLeftNew != xRightNew)
                        goto search_right;
                }
            }
        }
    }

// Push the newly found extents onto the stack.

    if( bReturn )
    {
        bReturn &= (stoOp.bPushMergeScrScan() & sto.bPopPushMergeScrScan());
    }

    return(bReturn);
}

/******************************Member*Function*****************************\
* BOOL RGNOBJ::bMergeScanline(&sto)
*
*  Merge a new scanline into the existing region.  This is used by
*  ExtFloodFill to construct regions.
*
* History:
*  31-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL RGNMEMOBJ::bMergeScanline(STACKOBJ& sto)
{
    PSCAN pscn;
    PSPAN pspn;
    COUNT cWalls;
    PSCANLINE psclNew = sto.psclTop;

#ifdef DBG_FLOOD

    DbgPrint("y = %ld, cSpans = %ld\n",psclNew->y,psclNew->cSpans);

    for (COUNT j = 0; j < psclNew->cSpans; j++)
        DbgPrint("  Left = %ld, Right = %ld\n",
                  psclNew->aSpan[j].xLeft,psclNew->aSpan[j].xRight);
#endif

    if (prgn->sizeRgn == NULL_REGION_SIZE)
    {
    // We just got the first scanline for this region.

        ULONGSIZE_T sizeRgn;

        if ((sizeRgn = NULL_REGION_SIZE + NULL_SCAN_SIZE + NULL_SCAN_SIZE +
                sizeof(INDEX_LONG) * (ULONGSIZE_T)(cWalls = psclNew->cSpans << 1)) >
             prgn->sizeObj)
        {
        // Hopefully this is big enough to avoid reallocation later on.

            if (!bExpand(sizeRgn + FLOOD_REGION_SIZE))
                return(FALSE);
        }

        prgn->sizeRgn = sizeRgn;
        prgn->cScans = 3;

        pscn = prgn->pscnHead();            // first scan
        pscn->yBottom = psclNew->y;

        pscn = pscnGet(pscn);               // second scan
        pscn->cWalls = cWalls;

        pscn->yTop = psclNew->y;
        pscn->yBottom = psclNew->y+1;
        pspn = (PSPAN)&psclNew->aSpan[0].xLeft;
        COUNT i;

        for (i = 0; i < cWalls; i+=2)
        {
            pscn->ai_x[i].x = pspn->xLeft;
            pscn->ai_x[i+1].x = pspn->xRight;
            pspn++;
        }
        pscn->ai_x[i].x = cWalls;           // This sets cWalls2

    // Fix the bounding box

        prgn->rcl.top = psclNew->y;
        prgn->rcl.bottom = psclNew->y+1;
        prgn->rcl.left = pscn->ai_x[0].x;
        prgn->rcl.right = pscn->ai_x[cWalls-1].x;
        ASSERTGDI((prgn->rcl.left < prgn->rcl.right), "bMergeScanline error");

        pscn = pscnGet(pscn);               // third scan
        pscn->cWalls = 0;
        pscn->yTop = psclNew->y+1;
        pscn->yBottom = POS_INFINITY;
        pscn->ai_x[0].x = 0;                // This sets cWalls

        prgn->pscnTail = pscnGet(pscn);
        return TRUE;
    }

// Check for nearly full region

    ULONGSIZE_T sizInc = NULL_SCAN_SIZE + sizeof(SPAN) * (ULONGSIZE_T)psclNew->cSpans;

    if (sizInc > prgn->sizeObj - prgn->sizeRgn)
    {
    // Lets expand it generously since this region is tossed when FloodFill
    // is done.

        if (!bExpand(prgn->sizeObj + sizInc + FLOOD_REGION_SIZE))
            return(FALSE);
    }

    pscn = prgn->pscnHead();
    PSCAN       pscnTail = prgn->pscnTail;
    PSCANLINE   pscl;

// Search for the scan that's right below the scanline to be merged in.

    while (psclNew->y > pscn->yTop)
        pscn = pscnGet(pscn);           // points to the next scan

    ASSERTGDI((pscn < pscnTail), "search has gone beyond the region\n");

    if (psclNew->y == pscn->yTop)
    {
    // We have to merge with the scan pointed to by pscn.

        if (pscn->yTop+1 != pscn->yBottom)
        {
            prgn->cScans += 1;          // adjust the bounding box
            prgn->rcl.bottom = psclNew->y+1;

            pscn->yTop = psclNew->y+1;  // adjust yTop of the to-be next scan
            pscl = psclNew;
        }
        else
        {
        // The scan is one pel high.  We'll prepare and store the resultant
        // scanline in the space pointed to by psclMerge.

            ASSERTGDI(!(pscn->cWalls & 1),"Odd Walls in bMergeScanline\n");
            PSCANLINE psclMerge = sto.psclScratch;

            psclMerge->y = pscn->yTop;
            psclMerge->cSpans = psclNew->cSpans + (pscn->cWalls >> 1);

        // If the space pointed to by psclMerge is not big enough for
        // the merged scanline, we have to expand it.

            sizInc -= NULL_SCAN_SIZE;   // don't need to store scan header
            ULONGSIZE_T sizeMerge = (ULONGSIZE_T)psclMerge->cSpans * sizeof(SPAN) +
                                    SCANLINEHEADER_SIZE;

            if (sizeMerge > psclMerge->cjScanline)
            {
                 if (!sto.bExpandScanline(sizeMerge, EXPAND_SCRATCH_SCANLINE))
                     return(FALSE);

                psclMerge = sto.psclScratch;
            }

            ASSERTGDI((sizeMerge <= psclMerge->cjScanline),
                      "bMergeScanline: did not alloc enough space\n");

        // Call the real merger.

            vMergeSpans((PSPAN)&pscn->ai_x[0].x,
                        (PSPAN)&pscn->ai_x[pscn->cWalls].x,
                        (PSPAN)&psclNew->aSpan[0].xLeft,
                        (PSPAN)&psclNew->aSpan[psclNew->cSpans].xLeft,
                        (PSPAN)&psclMerge->aSpan[0].xLeft);
            pscl = psclMerge;
        }
    }
    else                                    // psclNew->y < pscn->yTop
    {
    // The new scanline is above the scan pointed to by pscn.

        PSCAN pscnPrev = pscnGot(pscn);     // adjust yBottom of prev scan
        pscnPrev->yBottom = psclNew->y;

        prgn->cScans += 1;
        if (psclNew->y < prgn->rcl.top)     // adjust bounding box
            prgn->rcl.top = psclNew->y;

        pscl = psclNew;
    }

register    PLONG plDst = (PLONG)((PBYTE)pscnTail + sizInc);
register    PLONG plSrc = (PLONG)pscnTail;

    prgn->pscnTail = (PSCAN)plDst;  // update tail of scan

    while (plSrc > (PLONG)pscn)     // move the scans below to the right place
        *--plDst = *--plSrc;

    pscn->cWalls = pscl->cSpans << 1;
    pscn->yTop = pscl->y;
    pscn->yBottom = pscl->y+1;
    pspn = (PSPAN)&pscl->aSpan[0].xLeft;

// Fill in info for walls.

    cWalls = pscn->cWalls;
    COUNT i;

    for (i = 0; i < cWalls; i+=2)
    {
        pscn->ai_x[i].x = pspn->xLeft;
        pscn->ai_x[i+1].x = pspn->xRight;
        pspn++;
    }
    pscn->ai_x[i].x = cWalls;               // This sets cWalls2

// Recalculate xLeft and xRight in the bounding box.

    if (prgn->rcl.left > pscn->ai_x[0].x)
        prgn->rcl.left = pscn->ai_x[0].x;

    if (prgn->rcl.right < pscn->ai_x[cWalls-1].x)
        prgn->rcl.right = pscn->ai_x[cWalls-1].x;

    prgn->sizeRgn += sizInc;

    return(TRUE);
}

/******************************Public*Routine*****************************\
* BOOL NtGdiExtFloodFill (hdc,x,y,crColor,iFillType,pac)
*
* Fills an area with the current brush.  It begins at the given (x, y)
* point and continues in all directions.  If iFillType is
* FLOODFILLBORDER, the filling area is bounded by crColor.  If iFillType
* is FLOODFILLSURFACE, the filling area contains the color crColor.
*
* History:
*  Tue 10-Sep-1991 -by- Patrick Haluptzok [patrickh]
* put in different DIBMEMOBJ constructor, no more palette creation
*
*  Mon 24-Jun-1991 -by- Patrick Haluptzok [patrickh]
* Check for NULL brush, new brush constructor.
*
*  20-May-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\*************************************************************************/

BOOL
APIENTRY
NtGdiExtFloodFill(
    HDC      hdc,
    INT      x,
    INT      y,
    COLORREF crColor,
    UINT     iFillType
    )
{
    GDIFunctionID(NtGdiExtFloodFill);

    DCOBJ dco(hdc);

    if (!dco.bValidSurf())
    {
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }
        else
        {
            if (dco.fjAccum())
            {
                // Use the device's surface size to accumulate bounds.

                PDEVOBJ po(dco.hdev());
                ASSERTGDI(po.bValid(),"invalid pdev\n");

                SIZEL   sizl;

                // if there is no surface, use the dc size. This can happen
                // during metafiling.
                //
                // acquire the devlock to protect us from a dynamic mode
                // change happening while we're munging around in pSurface()

                GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

                if (po.pSurface())
                    sizl = (po.pSurface())->sizl();
                else
                    sizl = dco.pdc->sizl();

                GreReleaseSemaphoreEx(po.hsemDevLock());

                ERECTL  ercl(0, 0, sizl.cx, sizl.cy);

                dco.vAccumulate(ercl);
            }
            return(TRUE);
        }
    }

    SYNC_DRAWING_ATTRS(dco.pdc);

// Lock the Rao region and surface, ensure VisRgn up to date.

    DEVLOCKOBJ dlo(dco);

    SURFACE *pSurf = dco.pSurface();

    if ((pSurf != NULL) && (pSurf->iType() == STYPE_DEVBITMAP))
    {
        //
        // Convert the DFB to a DIB.  FloodFills to DFBs are EXTREMELY
        // inefficient so this is how we prevent them.  If we don't do
        // this, every floodfill (no matter how big) requires copying
        // the entire DFB to a DIB and then copying the entire DIB back
        // to the DFB (and the floodfills tend to come many at a time).
        //

        if (bConvertDfbDcToDib(&dco))
        {
            pSurf = dco.pSurface();    // it might have changed
        }
        else
        {
            WARNING("bConvertDfbDcToDib failed\n");
        }
    }

// Transform (x,y) from world to device space.

    EPOINTL eptl(x,y);

    EXFORMOBJ xo(dco, WORLD_TO_DEVICE);

    if (!xo.bXform(eptl))
        return(FALSE);

// User objects for all our toys.

    PDEVOBJ pdo(pSurf->hdev());
    XEPALOBJ palSurf(pSurf->ppal());
    XEPALOBJ palDC(dco.ppal());

    ULONG iSolidColor;
    FLONG flColorType;

// If somebody wants to floodfill a printer, they're out of luck.  [EricK]

    if (dco.bPrinter())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        WARNING("FloodFill not allowed on this surface\n");
        return(FALSE);
    }

    if (dco.pdc->bIsCMYKColor() || dco.pdc->bIsDeviceICM())
    {
        // because, usually, CMYK color and device ICM is for Printer...

        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        WARNING("FloodFill not allowed with CMYK color or Device ICM context\n");
        return(FALSE);
    }

// Map required color from palette

    iSolidColor = ulGetNearestIndexFromColorref(palSurf, palDC, crColor);

    if (dco.pdc->bIsSoftwareICM())
    {
        flColorType = BR_HOST_ICM;
    }
    else
    {
        flColorType = 0;
    }

// Realize the brush

    EBRUSHOBJ *peboFill = dco.peboFill();

    if ((dco.ulDirty() & DIRTY_FILL) || (dco.pdc->flbrush() & DIRTY_FILL))
    {
        dco.ulDirtySub(DIRTY_FILL);
        dco.pdc->flbrushSub(DIRTY_FILL);

        peboFill->vInitBrush(dco.pdc,
                             dco.pdc->pbrushFill(),
                             palDC,
                             palSurf,
                             pSurf);
    }

    if (peboFill->bIsNull())
        return(TRUE);

    if (!dlo.bValid())
        return(dco.bFullScreen());

// Convert (x,y) to SCREEN coordinates.  Return FALSE if the given point
// is clipped out.

    eptl += dco.eptlOrigin();

    RGNOBJ  roRao(dco.prgnEffRao());

    if (roRao.bInside(&eptl) != REGION_POINT_INSIDE)
        return(FALSE);

    PBYTE pjBits;
    LONG xLeft, xRight, lDelta;
    ULONG iFormat;
    DEVBITMAPINFO dbmi;
    ERECTL  erclRao;
    SURFMEM dimo;

// Synchronize with the device driver before touching the device surface.

    {
        PDEVOBJ po(pSurf->hdev());
        po.vSync(pSurf->pSurfobj(),NULL,0);
    }

// Exclude the pointer before calling CopyBits so that pointer won't be
// copied.

    roRao.vGet_rcl((PRECTL)&erclRao);
    DEVEXCLUDEOBJ dxo(dco, &erclRao);
    

    // If the surface is not a bitmap, we will create a temporary
    // DIB, the size of the RaoRegion bounding box, to create the 
    // that's used to create the final painting region. When this is 
    // done we need to offset the RaoRegion, eptl and erclRao to 
    // correspond to the new coodinate system. We set the flag below to indicate 
    // we need to offset the resulting region back when drawing to 
    // the actual destination surface. This was done to fix bug #139701

    BOOL    bOffsetNeeded = FALSE; 
    POINTL  ptlOffset; 

    if ((pSurf->iType() != STYPE_BITMAP) || (roRao.iComplexity() == COMPLEXREGION))
    {
    // Allocate up an RGB palette and a DIB of the size of the RaoRegion.

    // Figure out what format the engine should use by looking at the
    // size of palette.  This is a clone from CreateCompatibleBitmap().

        dbmi.iFormat = iFormat = pSurf->iFormat();
        dbmi.cxBitmap = erclRao.right - erclRao.left;
        dbmi.cyBitmap = erclRao.bottom - erclRao.top;
        dbmi.hpal = 0;
        dbmi.fl = BMF_TOPDOWN;

        if (pSurf->bUMPD())
            dbmi.fl |= UMPD_SURFACE;

        dimo.bCreateDIB(&dbmi, (PVOID)NULL);

        if (!dimo.bValid())
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

    // Copy the area as big as the size of the RaoRegion.

        BOOL bRes;

        ERECTL erclDIB; 
         
        erclDIB.left = 0; 
        erclDIB.top  = 0; 
        erclDIB.right= dbmi.cxBitmap;
        erclDIB.bottom = dbmi.cyBitmap;

        bRes = (*PPFNGET(pdo, CopyBits, pSurf->flags()))
                                (dimo.pSurfobj(),
                                 pSurf->pSurfobj(),
                                 (CLIPOBJ *) NULL,
                                 &xloIdent,
                                 (RECTL *) &erclDIB,
                                 (POINTL *) &erclRao);
        
    // Calculate the offset necessary to make all coordinated relative
    // to the DIB surface's coordinate system. 

        ptlOffset.x = -erclRao.left; 
        ptlOffset.y = -erclRao.top; 

        if ((bRes) && (roRao.iComplexity() == COMPLEXREGION))
        {
        // Color the boundary of the clip region so we don't flood over the
        // area outside.

            bRes = FALSE;
            RGNMEMOBJTMP rmoRaoBounds;
            RGNMEMOBJTMP rmoDiff;

            if (rmoRaoBounds.bValid() && rmoDiff.bValid())
            {
                rmoRaoBounds.vSet((RECTL *)&erclRao);
                if (rmoDiff.bMerge(rmoRaoBounds, roRao, gafjRgnOp[RGN_DIFF]))
                {
                // Make the resulting region's and the raoRectangle 
                // relative to the ccorinate system of the DIB

                    if(!rmoDiff.bOffset(&ptlOffset))
                        return(FALSE);                    

                    erclRao += ptlOffset; 

                // Fill the area outside the rao region but inside the
                // rao bounding box with the border color if in border mode.
                // Fill with a different than the surface color (1 if surface color
                // is an even index and 0 otherwise) if in surface mode.

                    ECLIPOBJ co(rmoDiff.prgnGet(), erclRao);
                    BBRUSHOBJ bo;

                    bo.flColorType = flColorType;
                    bo.pvRbrush    = (PVOID)NULL;

                    if (iFillType == FLOODFILLBORDER)
                    {
                        bo.iSolidColor = iSolidColor;

                        if (gbMultiMonMismatchColor)
                        {
                            bo.crRealized(crColor);
                            bo.crDCPalColor(crColor);
                        }
                    }
                    else // if (iFillType == FLOODFILLSURFACE)
                    {
                        bo.iSolidColor = ~iSolidColor & 1;

                        if (gbMultiMonMismatchColor)
                        {
                            // Get corresponding RGB value for iSolidColor.
                            //
                            // NOTE: Color will be quantaized by primary

                            ULONG ulRGB = ulIndexToRGB(palSurf,palDC,bo.iSolidColor);
                            bo.crRealized(ulRGB);
                            bo.crDCPalColor(ulRGB);
                        }
                    }

                    bRes = EngPaint(
                            dimo.pSurfobj(),                 // Destination surface
                            (CLIPOBJ *) &co,                 // Clip object
                            &bo,                             // Realized brush
                            (POINTL *) NULL,                 // Brush origin
                            ((R2_COPYPEN << 8) | R2_COPYPEN) // ROP
                            );
                }
            }
        }
        else
        {
        // Offset just the rectangle since the raoRegion is not
        // needed in this case

            erclRao += ptlOffset; 
        }

        if (!bRes)
        {
            return(FALSE);
        }

    // Make the flood point relative to the DIB's coordinates

        eptl.x += ptlOffset.x; 
        eptl.y += ptlOffset.y; 

    // Setup for the inversion of this offset when drawing to
    // the actual destination surface. 

        bOffsetNeeded = TRUE; 

        ptlOffset.x = -ptlOffset.x; 
        ptlOffset.y = -ptlOffset.y; 


        lDelta = dimo.ps->lDelta();
        pjBits = (PBYTE) dimo.ps->pvScan0();
    }
    else
    {
        pjBits  = (PBYTE) pSurf->pvScan0();
        lDelta  = pSurf->lDelta();
        iFormat = pSurf->iFormat();
    }

#if DEBUG_FLOOD
    DbgPrint("lDelta = %lx, pjBits = %lx, color = %lx\n",
              lDelta, pjBits, iSolidColor);
#endif

// Check if (x,y) is boundary color.  Return FALSE if the given point
// has the wrong color.

    PBYTE pjBitsY = pjBits + (lDelta * eptl.y);

    FLOODBM fd(iFormat, erclRao, iSolidColor, iFillType, pjBitsY, pSurf->ppal());

    ULONG iColorGivenPt = fd.iColorGet(eptl.x);

    if (((iFillType == FLOODFILLBORDER) && (iColorGivenPt == iSolidColor)) ||
        ((iFillType == FLOODFILLSURFACE) && (iColorGivenPt != iSolidColor)))
    {
        return(FALSE);
    }

// Find the extent of the span in the starting scanline.

    fd.vFindExtent(eptl.x, xLeft, xRight);

// Initialize the Up/Down stacks with the initial extents.

    STACKMEMOBJ stoUp(UPSTACK_SIZE, ALLOC_MERGE_SCANLINE, eptl.y, xLeft, xRight);
    if (!stoUp.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    STACKMEMOBJ stoDown(DOWNSTACK_SIZE, DONT_ALLOC_MERGE_SCANLINE, eptl.y,
                       xLeft, xRight);
    if (!stoDown.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    RGNMEMOBJTMP ro((ULONGSIZE_T)FLOOD_REGION_SIZE);
    if (!ro.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    BOOL bReturn = TRUE;
    LONG yBottom = erclRao.bottom-1;   // make bottom inclusive
    LONG yTop = erclRao.top;

    if (eptl.y < yBottom)
        bReturn &= fd.bExtendScanline(stoDown, stoUp, eptl.y+1, pjBitsY,
                                      pjBitsY+lDelta);
    else
        stoDown.vPop();

    if(bReturn) 
    {
        while (stoDown.bNotEmpty() || stoUp.bNotEmpty())
        {
            LONG y;
    
            if (stoDown.bNotEmpty())
            {
                if (!ro.bMergeScanline(stoDown))
                {
                    bReturn = FALSE;
                    break;
                }
    
            // Extend the scanline below
    
                if ((y = stoDown.yTop()) < yBottom)
                {
                    pjBitsY = pjBits + (lDelta * y);
                    if (!fd.bExtendScanline(stoDown, stoUp, y+1,
                                                  pjBitsY, pjBitsY+lDelta))
                    {
                        bReturn = FALSE;
                        break;
                    }
                }
                else
                    stoDown.vPop();     // hit border, pop the stack
            }
            else
            {
                bReturn &= ro.bMergeScanline(stoUp);
    
            // Extend the scanline above
    
                if ((y = stoUp.yTop()) > yTop)
                {
                    pjBitsY = pjBits + (lDelta * y);
                    if (!fd.bExtendScanline(stoUp, stoDown, y-1,
                                            pjBitsY, pjBitsY-lDelta))
                    {
                        bReturn = FALSE;
                        break;
                    }
                }
                else
                    stoUp.vPop();       // hit border, pop the stack
            }
        }
    }

    if ((bReturn) && (ro.iComplexity() != NULLREGION))
    {
    // Invert the offseting if necessary 

        if(bOffsetNeeded) 
        {
            if(!ro.bOffset(&ptlOffset))
                return FALSE; 
            erclRao += ptlOffset; 
        }

    // Accumulate bounds in device space.

        if (dco.fjAccum())
        {
            RECTL rcl;

            ro.vGet_rcl(&rcl);
            dco.vAccumulate(*((ERECTL *)&rcl));
        }

        MIX mix = peboFill->mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());

    // Inc the target surface uniqueness

        INC_SURF_UNIQ(pSurf);
        ECLIPOBJ co(ro.prgnGet(), erclRao);

    // Call Paint to draw to the destination surface.

        bReturn = EngPaint(
                        pSurf->pSurfobj(),
                        &co,
                        peboFill,
                        &dco.pdc->ptlFillOrigin(),
                        mix);
    }

    if (!bReturn)
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fntassoc.cxx ===
/***********************************************************************************
 * Module Name: fntassoc.cxx
 *
 * Font association routines.
 *
 * History
 *
 * 4-8-96 Gerrit van Wingerden  Moved code from flinkgdi.cxx
 *
 * Copyright (c) 1996-1999 Microsoft Corporation
 **********************************************************************************/

#include "precomp.hxx"

#ifdef FE_SB

#define FONT_ASSOCIATION_CHARSET_KEY     \
     L"FontAssoc\\Associated CharSet"
#define FONT_ASSOCIATION_DEFAULT_KEY     \
     L"FontAssoc\\Associated DefaultFonts"
#define FONT_ASSOCIATION_FONTS_KEY       \
     L"FontAssoc\\Associated Fonts"


// Font Association configuration value

UINT  fFontAssocStatus = 0x0;

//
// Fontfile path for AssocSystemFont in
//  KEY   : HKL\\SYSTEM\\CurrentControlSet\\Control\\FontAssoc\\Associated DefaultFonts
//  VALUE : AssocSystemFont
//
// This font is loaded at system initialization stage. and will be used to provide
// DBCS glyphs for System/Terminal/FixedSys/... This font should have all glyphs that
// will be used on current system locale
//
// This hehavior is described in ...
//  "Font Association for Far East implementation for Windows 95"
//   Revision : 1.02
//   Author   : WJPark,ShusukeU.
//

// Holds the path of the font the font used to provide glyphs to system,terminal,
// and fixedsys fonts.

WCHAR gawcSystemDBCSFontPath[MAX_PATH];

// Identifies the facename to use for DBCS glyphs.  This value comes out of the
// "FontPackage" value in AssociatedDefaultFonts key

static WCHAR gawcSystemDBCSFontFaceName[LF_FACESIZE+1];

// Holds the pfe's (vertical and non-vertical) for the system DBCS font face name

PFE *gappfeSystemDBCS[2] = { PPFENULL , PPFENULL };

// set to TRUE if SystemDBCS font is enabled.

BOOL gbSystemDBCSFontEnabled = FALSE;

//
// Font association default link initialization value.
//
// This value never be TRUE, if FontAssociation features are disabled.
// And this value will be TRUE, if we suceed to read "Associated DefaultFonts"
// key and fill up FontAssocDefaultTable.
//
BOOL  bReadyToInitializeFontAssocDefault = FALSE;
//
// This value never be TRUE, if FontAssociation features are disabled.
// And this value also never be TRUE, no-user logged-on this window station.
// This value become TRUE at first time that GreEnableEUDC() is called.
// and this value is turned off when user logout.
//
BOOL  bFinallyInitializeFontAssocDefault = FALSE;

//
// Font Association default link configuration table
//
#define NUMBER_OF_FONTASSOC_DEFAULT    7
#define FF_DEFAULT                  0xFF

FONT_DEFAULTASSOC FontAssocDefaultTable[NUMBER_OF_FONTASSOC_DEFAULT] = {
   {FALSE, FF_DONTCARE, L"FontPackageDontCare", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_ROMAN, L"FontPackageRoman", L"\0", L"\0" , {PPFENULL,PPFENULL}},
   {FALSE, FF_SWISS, L"FontPackageSwiss", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_MODERN, L"FontPackageModern", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_SCRIPT, L"FontPackageScript", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_DECORATIVE, L"FontPackageDecorative", L"\0", L"\0", {PPFENULL,PPFENULL}},
   {FALSE, FF_DEFAULT, L"FontPackage", L"\0", L"\0", {PPFENULL,PPFENULL}}
};


// Is font association substitition turned on?

static BOOL  bEnableFontAssocSubstitutes = FALSE;

// Pointer to Substitution table for font association.

static ULONG ulNumFontAssocSubs = 0L;
PFONT_ASSOC_SUB pFontAssocSubs = (PFONT_ASSOC_SUB) NULL;

// definition is in flinkgdi.cxx

extern RTL_QUERY_REGISTRY_TABLE SharedQueryTable[2];

extern BOOL bAppendSysDirectory( WCHAR *pwcTarget, const WCHAR *pwcSource, UINT cchBufferSize );
extern BOOL bComputeQuickLookup(QUICKLOOKUP *pql, PFE *pPFE, BOOL bSystemEUDC);

/******************************Public*Routine******************************\
* NTSTATUS CountRegistryEntryCoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  19-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
CountRegistryEntryRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    (*(ULONG *)EntryContext) += 1L;

    return( STATUS_SUCCESS );
}


/******************************Public*Routine******************************\
* NTSTATUS FontAssocCharsetRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  28-Aug-1995 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
FontAssocCharsetRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    //
    // Only process follows if the data value is "YES"
    //
    if( _wcsicmp((LPWSTR) ValueData, L"YES" ) == 0)
    {
        //
        // Check ANSI charset association is enabled
        //
        if( _wcsicmp(ValueName, L"ANSI(00)") == 0)
        {
            #if DBG
            DbgPrint("GDISRV:FONTASSOC CHARSET:Enable ANSI association\n");
            #endif
            fFontAssocStatus |= ANSI_ASSOC;
            return(STATUS_SUCCESS);
        }
        //
        // Check SYMBOL charset association is enabled
        //
         else if( _wcsicmp(ValueName, L"SYMBOL(02)") == 0)
        {
            #if DBG
            DbgPrint("GDISRV:FONTASSOC CHARSET:Enable SYMBOL association\n");
            #endif
            fFontAssocStatus |= SYMBOL_ASSOC;
            return(STATUS_SUCCESS);
        }
        //
        // Check OEM charset association is enabled
        //
         else if( _wcsicmp(ValueName, L"OEM(FF)") == 0)
        {
            #if DBG
            DbgPrint("GDISRV:FONTASSOC CHARSET:Enable OEM association\n");
            #endif
            fFontAssocStatus |= OEM_ASSOC;
            return(STATUS_SUCCESS);
        }
    }

    //
    //  return STATUS_SUCCESS everytime,even we got error from above call, to
    // get next enumuration.
    //

    return(STATUS_SUCCESS);
}

/******************************Public*Routine******************************\
* NTSTATUS FontAssocDefaultRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  14-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
FontAssocDefaultRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    UINT iIndex;

    if(_wcsicmp(ValueName,L"AssocSystemFont") == 0)
    {
        bAppendSysDirectory(gawcSystemDBCSFontPath,(const WCHAR *)ValueData, MAX_PATH);
        return(STATUS_SUCCESS);
    }
    else
    if(_wcsicmp(ValueName,L"FontPackage") == 0)
    {
        cCapString(gawcSystemDBCSFontFaceName,(const WCHAR*)ValueData,LF_FACESIZE);
        return(STATUS_SUCCESS);
    }



    for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
    {
        if(_wcsicmp(ValueName,
                    FontAssocDefaultTable[iIndex].DefaultFontTypeID) == 0)
        {
        // Check if the registry has some data.

            if( *(LPWSTR)ValueData != L'\0' )
            {
                if (FAILED(StringCchCopyW(FontAssocDefaultTable[iIndex].DefaultFontFaceName, LF_FACESIZE+1, (const WCHAR *)ValueData)))
                {
                    WARNING("FontAssocDefaultRoutine: not enough space in DefaultFontFaceName buffer\n");
                    return STATUS_SUCCESS;
                }

                FontAssocDefaultTable[iIndex].ValidRegData = TRUE;

                #if DBG
                DbgPrint("GDISRV:FONTASSOC DEFAULT:%ws -> %ws\n",
                    FontAssocDefaultTable[iIndex].DefaultFontTypeID,
                    FontAssocDefaultTable[iIndex].DefaultFontFaceName);
                #endif                
            }

            return(STATUS_SUCCESS);
        }
    }

    #if DBG
    DbgPrint("GDISRV:FONTASSOC DEFAULT:%ws is invalid registry key\n",(LPWSTR)ValueName);
    #endif

    //
    //  return STATUS_SUCCESS everytime,even we got error to do next enumuration.
    //
    return(STATUS_SUCCESS);
}

/******************************Public*Routine******************************\
* NTSTATUS FontAssocFontsRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
*
* History:
*  19-Jan-1996 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
FontAssocFontsRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    UINT iIndex = (*(UINT *)EntryContext);
    PFONT_ASSOC_SUB pfas = pFontAssocSubs + iIndex;

    ASSERTGDI(iIndex < ulNumFontAssocSubs,
              "GDIOSRV:FONTASSOC iIndex >= ulNumFontAssocSubs\n");

    //
    // Copy the registry data to local buffer..
    //
    cCapString(pfas->AssociatedName,(const WCHAR*)ValueData,LF_FACESIZE+1);
    cCapString(pfas->OriginalName  ,ValueName,LF_FACESIZE+1);

    #if DBG
    pfas->UniqNo = iIndex;

    DbgPrint("GDISRV:FONTASSOC FontSubs %d %ws -> %ws\n",iIndex,
                                                         pfas->OriginalName,
                                                         pfas->AssociatedName);
    #endif

    //
    // for Next entry....
    //
    (*(UINT *)EntryContext) = ++iIndex;

    return (STATUS_SUCCESS);
}


/******************************Public*Routine******************************\
* VOID vInitializeFontAssocStatus()
*
* History:
*  28-Aug-1995 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID vInitializeFontAssocStatus(VOID)
{
    NTSTATUS NtStatus;

// Read Font Association configuration value.

// Initialize "FontAssoc\Association CharSet" related.

    SharedQueryTable[0].QueryRoutine = FontAssocCharsetRoutine;
    SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    SharedQueryTable[0].Name = (PWSTR)NULL;
    SharedQueryTable[0].EntryContext = (PVOID)NULL;
    SharedQueryTable[0].DefaultType = REG_NONE;
    SharedQueryTable[0].DefaultData = NULL;
    SharedQueryTable[0].DefaultLength = 0;

    SharedQueryTable[1].QueryRoutine = NULL;
    SharedQueryTable[1].Flags = 0;
    SharedQueryTable[1].Name = (PWSTR)NULL;

    fFontAssocStatus = 0;
    gawcSystemDBCSFontPath[0] = L'\0';

// Enumurate registry values

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
                                      FONT_ASSOCIATION_CHARSET_KEY,
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING1("GDISRV:FontAssociation is disabled\n");

        fFontAssocStatus = 0;
    }

    gawcSystemDBCSFontFaceName[0] = 0;

// Initialize "FontAssoc\Association DefaultFonts" related.

    SharedQueryTable[0].QueryRoutine = FontAssocDefaultRoutine;

// Enumurate registry values

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
                                      FONT_ASSOCIATION_DEFAULT_KEY,
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if( !NT_SUCCESS(NtStatus) )
    {
        WARNING1("GDISRV:FontAssociation:Default table is not presented\n");

        bReadyToInitializeFontAssocDefault = FALSE;
    }
    else
    {
    // We succeeded to read registry and fill up FontAssocDefaultTable.

        bReadyToInitializeFontAssocDefault = TRUE;

    // try to load the system DBCS font if we detected the appropriate registry
    // entries

        if(gawcSystemDBCSFontPath[0] && gawcSystemDBCSFontFaceName[0])
        {
            PUBLIC_PFTOBJ  pfto;

            LONG cFonts;
            EUDCLOAD EudcLoadData;
            PFF      *placeHolder;
            
            EudcLoadData.pppfeData = gappfeSystemDBCS;
            EudcLoadData.LinkedFace = gawcSystemDBCSFontFaceName;

            if(pfto.bLoadAFont(gawcSystemDBCSFontPath,
                               (PULONG) &cFonts,
                               PFF_STATE_EUDC_FONT,
                               &placeHolder,
                               &EudcLoadData ))
            {
            // initialize quick lookup table if we successfully loaded the font

            // this must be NULL for bComputeQuickLookup

                gqlTTSystem.puiBits = NULL;


                if(bComputeQuickLookup(&gqlTTSystem, gappfeSystemDBCS[PFE_NORMAL], FALSE))
                {
                // now try the vertical face if one is provided

                    FLINKMESSAGE2(DEBUG_FONTLINK_INIT,
                                  "Loaded SystemDBCSFont %ws\n",
                                  gawcSystemDBCSFontPath);

                    gbSystemDBCSFontEnabled = TRUE;
                    gbAnyLinkedFonts = TRUE;

                }

                if(!gbSystemDBCSFontEnabled)
                {
                    WARNING("vInitializeFontAssocStatus: error creating \
                             quick lookup tables for SystemDBCSFont\n");

                    pfto.bUnloadEUDCFont(gawcSystemDBCSFontPath);
                }
            }
            else
            {
                WARNING("vInitializeFontAssocStatus: error loading SystemDBCSFont\n");
            }
        }
    }


// Initialize "Font Association\Fonts" related.

    bEnableFontAssocSubstitutes = FALSE;

    SharedQueryTable[0].QueryRoutine = CountRegistryEntryRoutine;
    SharedQueryTable[0].EntryContext = (PVOID)(&ulNumFontAssocSubs);

// Count the number of the registry entries.

//    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
//                                      FONT_ASSOCIATION_FONTS_KEY,
//                                      SharedQueryTable,
//                                      NULL,
//                                      NULL);

    ulNumFontAssocSubs = 0;

    if( NT_SUCCESS(NtStatus) && (ulNumFontAssocSubs != 0) )
    {
        #if DBG
        DbgPrint("GDISRV:FONTASSOC %d FontAssoc Substitution is found\n",
                 ulNumFontAssocSubs);
        #endif

    // Allocate lookaside table for fontassociation's substitution.

        pFontAssocSubs = (PFONT_ASSOC_SUB)
          PALLOCMEM(sizeof(FONT_ASSOC_SUB)*ulNumFontAssocSubs,'flnk');

        if( pFontAssocSubs != NULL )
        {
            UINT iCount = 0; // This will be used as Current Table Index.

            SharedQueryTable[0].QueryRoutine = FontAssocFontsRoutine;
            SharedQueryTable[0].EntryContext = (PVOID)(&iCount);

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL|RTL_REGISTRY_OPTIONAL,
                                              FONT_ASSOCIATION_FONTS_KEY,
                                              SharedQueryTable,
                                              NULL,
                                              NULL);

            if( !NT_SUCCESS(NtStatus) )
            {
                VFREEMEM( pFontAssocSubs );
                ulNumFontAssocSubs = 0L;
            }
             else
            {
                bEnableFontAssocSubstitutes = TRUE;
                gbAnyLinkedFonts = TRUE;
            }
        }
         else
        {
            ulNumFontAssocSubs = 0L;
        }
    }

    return;
}

/*****************************************************************************\
 * GreGetFontAssocStatus( BOOL bEnable )
 *
 * History:
 *  28-Aug-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 *****************************************************************************/

UINT GreGetFontAssocStatus(VOID)
{
    return(fFontAssocStatus);
}




/*****************************************************************************
 * BOOL bSetupDefaultFlEntry(BOOL,BOOL,INT)
 *
 *  This function load font and build link for eudc font according to
 * the default link table.
 *
 * History
 *  1-15-96 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL bSetupDefaultFlEntry(VOID)
{
    UINT iIndex;
    UINT bRet = FALSE;

    //
    // get and validate PFT user object
    //
    PUBLIC_PFTOBJ  pfto;  // access the public font table

    ASSERTGDI(
        pfto.bValid(),
        "gdisrv!bSetupDefaultFlEntry(): could not access the public font table\n"
        );

    for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
    {
        //
        // Check the registry data and fontpath is valid ,and
        // this font is not loaded, yet.
        //
        if( (FontAssocDefaultTable[iIndex].ValidRegData) &&
            (FontAssocDefaultTable[iIndex].DefaultFontPathName[0] != L'\0') &&
            (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] == PPFENULL) )
        {
            PPFE     appfeLink[2];  // temporary buffer
            LONG     cFonts;        // count of fonts
            EUDCLOAD EudcLoadData;  // eudc load data
            PFF      *placeHolder;

            PWSZ     FontPathName = FontAssocDefaultTable[iIndex].DefaultFontPathName;

            //
            // Fill up EudcLoadData structure
            //
            EudcLoadData.pppfeData  = appfeLink;
            EudcLoadData.LinkedFace = FontAssocDefaultTable[iIndex].DefaultFontFaceName;

            //
            // Load the linked font.
            //
            if( pfto.bLoadAFont( FontPathName,
                                 (PULONG) &cFonts,
                                 (PFF_STATE_EUDC_FONT | PFF_STATE_PERMANENT_FONT),
                                 &placeHolder,
                                 &EudcLoadData ) )
            {
            //
            // Check we really succeed to load requested facename font.
            //
            //
            // Compute table for normal face
            //
               if(!bComputeQuickLookup(NULL, appfeLink[PFE_NORMAL], FALSE ))
               {
                   WARNING("Unable to compute QuickLookUp for default link\n");

               //
               // Unload the fonts.
               //
                   pfto.bUnloadEUDCFont(FontPathName);

               //
               // we got error during load, maybe font itself might be invalid,
               // just invalidate the pathname the default table.
               //
                   FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';

               //
               // Do next entry in default table.
               //
                   continue;
               }

               //
               // Compute table for vertical face, if vertical face font is provided,
               //

               if( !bComputeQuickLookup(NULL, appfeLink[PFE_VERTICAL], FALSE ))
               {
                   WARNING("Unable to compute QuickLookUp for default link\n");

               // Unload the fonts.
                    pfto.bUnloadEUDCFont(FontPathName);

               // we got error during load, maybe font itself might be invalid,
               // just invalidate the pathname the default table.

                    FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';

               // Do next entry in default table.

                    continue;
                }
                
                //
                // Finally, we keeps the PFEs in default array.
                //
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] =
                  appfeLink[PFE_NORMAL];
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] =
                  appfeLink[PFE_VERTICAL];

                #if DBG
                DbgPrint("GDISRV:FONTASSOC DEFAULT:Load %ws for %ws\n",
                    FontAssocDefaultTable[iIndex].DefaultFontPathName,
                    FontAssocDefaultTable[iIndex].DefaultFontTypeID);
                #endif

             // We can load Associated font.

                bRet = TRUE;
            }
             else
            {
                #if DBG
                DbgPrint("Failed to load default link font. (%ws)\n",FontPathName);
                #endif

                //
                // we got error during load, maybe font itself might be invalid,
                // just invalidate the pathname the default table.
                //
                FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';

                //
                // Make sure the PFEs are invalid.
                //
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL]   = PPFENULL;
                FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] = PPFENULL;
            }
        }
    }

    return(bRet);
}


/*****************************************************************************
 * ULONG NtGdiQueryFontAssocInfo
 *
 * Shared kernel mode entry point for QueryFontAssocStatus and
 * GetFontAssocStatus
 *
 * History
 *  6-12-96 Gerrit van Wingerden [gerritv]
 * Wrote it.
 ****************************************************************************/

#define GFA_NOT_SUPPORTED 0
#define GFA_SUPPORTED     1
#define GFA_DBCSFONT      2

extern "C" ULONG NtGdiQueryFontAssocInfo(HDC hdc)
{
// if hdc is NULL then just return fFontAssocStatus

    if(hdc == NULL)
    {
        return(fFontAssocStatus);
    }
    else
    {
    // for now eventually merge/share with NtGdiGetCharSet

        FLONG    flSim;
        POINTL   ptlSim;
        FLONG    flAboutMatch;
        PFE     *ppfe;

        DCOBJ dco (hdc);
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(GFA_NOT_SUPPORTED);
        }

        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "gdisrv!GetCharSet: bad pdev in dc\n");

        if (!pdo.bGotFonts())
          pdo.bGetDeviceFonts();

        LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

        if (dco.ulDirty() & DIRTY_CHARSET)
        {
        // force mapping

            if (!lfo.bValid())
            {
                WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
                return(GFA_NOT_SUPPORTED);
            }


        // Stabilize the public PFT for mapping.

            SEMOBJ  so(ghsemPublicPFT);

        // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
        // a simulation type (ist)
        // also store charset to the DC

            ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch);

            ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
                          "NtGdiGetCharSet, charset is dirty\n");

        }

        UINT Charset = (dco.pdc->iCS_CP() >> 16) & 0xFF;

        if (IS_ANY_DBCS_CHARSET( Charset ))
        {
            return GFA_DBCSFONT;
        }

        if (((Charset == ANSI_CHARSET)   && (fFontAssocStatus & ANSI_ASSOC))  ||
            ((Charset == OEM_CHARSET)    && (fFontAssocStatus & OEM_ASSOC))   ||
            ((Charset == SYMBOL_CHARSET) && (fFontAssocStatus & SYMBOL_ASSOC))  )
        {
            if(!(lfo.plfw()->lfClipPrecision & CLIP_DFA_DISABLE))
            {
                return(GFA_SUPPORTED);
            }
        }
        return(GFA_NOT_SUPPORTED);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fntxform.cxx ===
/******************************Module*Header*******************************\
* Module Name: fntxform.cxx
*
* Created: 02-Feb-1993 16:33:14
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/


#ifdef COMMENT_BLOCK

Author of these notes: BodinD

Differences between vector fonts and tt fonts in win31 + notes about what
nt does in these cases

1) Italicization

        for vector fonts it is done is device space (wrong)
        after notional to device transform has been applied

        for tt fonts it is done right, font is first italicized in notional
        space and then notional to device transform is applied.

        on NT I italicized both vector and tt fonts in notional space.

2) emboldening

        On NT I was able to fix vector fonts so as to shift
        the glyph in the direction of baseline (which may be different
        from x axis if esc != 0) thus preserving
        rotational invariance of emboldened vector fonts. (check it out, it is cool)

        for NT 5.0 we will have this also working for TT.

3) scaling properties under anisotropic page to device transform

        tt fonts scale ISOtropically which clearly is wrong for
        ANISOtropic page to device transform. The isotropic scaling factor
        for tt fonts is the ABSOLUTE VALUE value of the yy component
        of the page to device transform. From here it follows that
        tt fonts igore the request  to flip x and/or y axis
        and the text is always written left to right up side up.

        unlike tt fonts, vector fonts do scale ANISOtropically given
        the anisotropic page to device xform. The request to flip
        y axis  is ignored (like for tt fonts). If the tranform
        requests the flip of text in x axis, the text comes out GARBLED.
        (DavidW, please, give it a try)

        on NT I emulated this behavior in COMPATIBLE mode, execpt for the
        GARBLED "mode" for vector fonts. In ADVANCED mode I made both vt and tt
        fonts respect xform and behave in the same fashion wrt xforms.

4) interpretation of escapement and orientation

        in tt case escapement is intepreted as DEVICE space concept
        What this means is that after notional to world  and world to
        device scaling factors are applied the font is rotated in device space.
        (conceptually wrong but agrees with win31 spec).

        in vector font case escapement is intepreted as WORLD space concept
        font is first rotated in world space and then world (page) to device
        transform is applied.
        (conceptually correct but it disagrees with with win31 spec)

        on NT I went through excruiciating pain to emulate this behavior
        under COMPATIBLE  mode. In ADVANCED mode, vector and tt fonts
        behave the same and esc and orientation are interpreted as WORLD
        space concepts.


5) behavior in case of (esc != orientation)

        tt fonts set orientation = esc

        vector fonts snap orientation to the nearest multiple of
        90 degrees relative to orientation.
        (e.g. esc=300, or = -500 => esc = 300, or = - 600)
        (DavidW, please, give it a try, also please use anisotropic
        xform with window extents (-1,1))


        on NT we emulate this behavior for in COMPATIBLE mode,
        except for snapp orientation "fetature". The motivation is that
        apps will explicitely set orientation and escapement to differ
        by +/- 900, if they want it, rather than make use
        of "snapping feature". In advanced mode if esc!=orientation
        we use egg-shell algorithm to render text.




#endif COMMENT_BLOCK



#include "precomp.hxx"
#include "flhack.hxx"
// We include winuserp.h for the app compatibility #define GACF2_MSSHELLDLG
#include "winuserp.h"

//
// external procedures from draweng.cxx
//

extern BOOL gbShellFontCompatible;

EFLOAT efCos(EFLOAT x);
EFLOAT efSin(EFLOAT x);

/******************************Public*Routine******************************\
* lGetDefaultWorldHeight                                                   *
*                                                                          *
* "If lfHeight is zero, a reasonable default size is substituted."         *
* [SDK Vol 2]. Fortunately, the device driver is kind enough to            *
* suggest a nice height (in pixels). We shall return this suggestion       *
* in World corrdinates.                                                    *
*                                                                          *
* History:                                                                 *
*  Thu 23-Jul-1992 13:01:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

LONG
lGetDefaultWorldHeight(
    DCOBJ *pdco
    )
{
    LONG lfHeight;
    {
        PDEVOBJ pdo(pdco->hdev());
        if (!pdo.bValid())
        {
            RIP("gdisrv!MAPPER:MAPPER -- invalid DCOBJ\n");
            return(FM_EMERGENCY_DEFAULT_HEIGHT);
        }

        LFONTOBJ lfo(pdo.hlfntDefault());
        if (!lfo.bValid())
        {
            RIP("gdisrv!MAPPER::MAPPER -- invalid LFONTOBJ\n");
            return(FM_EMERGENCY_DEFAULT_HEIGHT);
        }

        lfHeight = lfo.plfw()->lfHeight;
    }

//
// Now I must transform this default height in pixels to a height
// in World coordinates. Then this default height must be written
// into the LFONTOBJ supplied by the DC.
//
    if (!pdco->pdc->bWorldToDeviceIdentity())
    {
    //
    // Calculate the scaling factor along the y direction
    // The correct thing to do might be to take the
    // scaling factor along the ascender direction [kirko]
    //
        EFLOAT efT;
        efT.eqMul(pdco->pdc->efM21(),pdco->pdc->efM21());

        EFLOAT efU;
        efU.eqMul(pdco->pdc->efM22(),pdco->pdc->efM22());

        efU.eqAdd(efU,efT);
        efU.eqSqrt(efU);

// at this point efU scales from world to device

        efT.vSetToOne();
        efU.eqDiv(efT,efU);

// at this point efU scales from device to world

        lfHeight =  lCvt(efU,FIX_FROM_LONG(lfHeight));
    }

// insure against a trivial default height

    if (lfHeight == 0)
    {
        return(FM_EMERGENCY_DEFAULT_HEIGHT);
    }

    //
    // This value should be the character height and not the CELL height for
    // Win 3.1 compatability.  Fine Windows apps like CA Super Project will
    // have clipped text if this isn't the case. [gerritv]
    //

    lfHeight *= -1;


    return(lfHeight);
}



/******************************Public*Routine******************************\
* vGetNtoW
*
* Calculates the notional to world transformation for fonts. This
* includes that funny factor of -1 for the different mapping modes
*
* Called by:
*   bGetNtoW                                            [FONTMAP.CXX]
*
* History:
*  Wed 15-Apr-1992 15:35:10 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

LONG lNormAngle(LONG lAngle);

VOID vGetNtoW
(
    MATRIX      *pmx,   // destination for transform
    LOGFONTW    *pelfw, // wish list
    IFIOBJ&     ifio,   // font to be used
    DCOBJ       *pdco
)
{
    LONG lAngle,lfHeight;
    EFLOAT efHeightScale,efWidthScale;

    lfHeight = pelfw->lfHeight;

    if (lfHeight == 0)
    {
        lfHeight = lGetDefaultWorldHeight(pdco);
    }
    ASSERTGDI(lfHeight,"gdisrv!vGetNtoW -- zero lfHeight\n");

// compute the height scale:

    {
        EFLOAT efHeightNum,efHeightDen;

        if (lfHeight > 0)
        {
            efHeightNum = lfHeight;
            efHeightDen = ifio.lfHeight();
        }
        else if (lfHeight < 0)
        {
            efHeightNum = -lfHeight;
            efHeightDen = (LONG) ifio.fwdUnitsPerEm();
        }
        efHeightScale.eqDiv(efHeightNum,efHeightDen);
    }

// compute the width scale:

    POINTL ptlRes;

    if (pelfw->lfWidth != 0)
    {
        EFLOAT efWidthNum,efWidthDen;

        ptlRes.x = ptlRes.y = 1;

        if (ifio.lfWidth() >= 0)
        {
            efWidthNum = (LONG) ABS(pelfw->lfWidth);
            efWidthDen = ifio.lfWidth();
            efWidthScale.eqDiv(efWidthNum,efWidthDen);
        }
        else
        {
            RIP("   gdisrv!vGetNtoW -- bad fwdAveCharWidth\n");
            efWidthScale = efHeightScale;
        }
    }
    else
    {
        ptlRes = *ifio.pptlAspect();
        efWidthScale = efHeightScale;
    }

// make sure that fonts look the same on printers of different resolutions:

    PDEVOBJ pdo(pdco->hdev());
    if (pdo.bValid())
    {
        if (pdo.ulLogPixelsX() != pdo.ulLogPixelsY())
        {
            ptlRes.y *= (LONG)pdo.ulLogPixelsX();
            ptlRes.x *= (LONG)pdo.ulLogPixelsY();
        }
    }
    else
    {
        RIP("gdisrv!bGetNtoW, pdevobj problem\n");
    }

    pmx->efM11.vSetToZero();
    pmx->efM12.vSetToZero();
    pmx->efM21.vSetToZero();
    pmx->efM22.vSetToZero();

// Get the orientation from the LOGFONT.  Win 3.1 treats the orientation
// as a rotation towards the negative y-axis.  We do the same, which
// requires adjustment for some map modes.

    lAngle = pelfw->lfOrientation;
    if (pdco->pdc->bYisUp())
        lAngle = 3600-lAngle;
    lAngle = lNormAngle(lAngle);

    switch (lAngle)
    {
    case 0 * ORIENTATION_90_DEG:

        pmx->efM11 = efWidthScale;
        pmx->efM22 = efHeightScale;

        if (!pdco->pdc->bYisUp())
        {
            pmx->efM22.vNegate();
        }
        break;

    case 1 * ORIENTATION_90_DEG:

        pmx->efM12 = efWidthScale;
        pmx->efM21 = efHeightScale;

        if (!pdco->pdc->bYisUp())
        {
            pmx->efM12.vNegate();
        }
        pmx->efM21.vNegate();
        break;

    case 2 * ORIENTATION_90_DEG:

        pmx->efM11 = efWidthScale;
        pmx->efM22 = efHeightScale;

        pmx->efM11.vNegate();
        if (pdco->pdc->bYisUp())
        {
            pmx->efM22.vNegate();
        }
        break;

    case 3 * ORIENTATION_90_DEG:

        pmx->efM12 = efWidthScale;
        pmx->efM21 = efHeightScale;

        if (pdco->pdc->bYisUp())
        {
            pmx->efM12.vNegate();
        }

        break;

    default:

        {
            EFLOATEXT efAngle = lAngle;
            efAngle /= (LONG) 10;

            EFLOAT efCosine = efCos(efAngle);
            EFLOAT efSine   = efSin(efAngle);

            pmx->efM11.eqMul(efWidthScale, efCosine);
            pmx->efM22.eqMul(efHeightScale,efCosine);

            pmx->efM12.eqMul(efWidthScale, efSine);
            pmx->efM21.eqMul(efHeightScale,efSine);
        }
        pmx->efM21.vNegate();
        if (!pdco->pdc->bYisUp())
        {
            pmx->efM12.vNegate();
            pmx->efM22.vNegate();
        }
        break;
    }

// adjust for non-square resolution:

    if (pdo.ulLogPixelsX() != pdo.ulLogPixelsY())
    {
        EFLOATEXT efTmp = (LONG)pdo.ulLogPixelsX();
        efTmp /= (LONG)pdo.ulLogPixelsY();

        if (pelfw->lfWidth == 0)
        {
            pmx->efM11 *= efTmp;
            pmx->efM21 *= efTmp;
        }
        else
        {
            pmx->efM12 /= efTmp;
            pmx->efM21 *= efTmp;
        }
    }

    EXFORMOBJ xoNW(pmx, DONT_COMPUTE_FLAGS);
    xoNW.vRemoveTranslation();
    xoNW.vComputeAccelFlags();
}

//
// galFloat -- an array of LONG's that represent the IEEE floating
//             point equivalents of the integers corresponding
//             to the indices
//

LONG
galFloat[] = {
    0x00000000, // = 0.0
    0x3f800000, // = 1.0
    0x40000000, // = 2.0
    0x40400000, // = 3.0
    0x40800000, // = 4.0
    0x40a00000, // = 5.0
    0x40c00000, // = 6.0
    0x40e00000, // = 7.0
    0x41000000  // = 8.0
};


LONG
galFloatNeg[] = {
    0x00000000, // =  0.0
    0xBf800000, // = -1.0
    0xC0000000, // = -2.0
    0xC0400000, // = -3.0
    0xC0800000, // = -4.0
    0xC0a00000, // = -5.0
    0xC0c00000, // = -6.0
    0xC0e00000, // = -7.0
    0xC1000000  // = -8.0
};


/******************************Public*Routine******************************\
* bGetNtoD
*
* Get the notional to device transform for the font drivers
*
* Called by:
*   PFEOBJ::bSetFontXform                               [PFEOBJ.CXX]
*
* History:
*  Tue 12-Jan-1993 11:58:41 by Kirk Olynyk [kirko]
* Added a quick code path for non-transformable (bitmap) fonts.
*  Wed 15-Apr-1992 15:09:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL
bGetNtoD(
    FD_XFORM    *pfdx,  // pointer to the buffer to recieve the
                        // notional to device transformation for the
                        // font driver.  There are a couple of
                        // important things to remember.  First,
                        // according to the conventions of the ISO
                        // committee, the coordinate space for notional
                        // (font designer) spaces are cartesian.
                        // However, due to a series of errors on my part
                        // [kirko] the convention that is used by the
                        // DDI is that the notional to device transformation
                        // passed over the DDI assumes that both the notional
                        // and the device space are anti-Cartesian, that is,
                        // positive y increases in the downward direction.
                        // The fontdriver assumes that
                        // one unit in device space corresponds to the
                        // distance between pixels. This is different from
                        // GDI's internal view, where one device unit
                        // corresponds to a sub-pixel unit.


    LOGFONTW *pelfw,    // points to the extended logical font defining
                        // the font that is requested by the application.
                        // Units are ususally in World coordinates.

    IFIOBJ&     ifio,   // font to be used

    DCOBJ       *pdco,  // the device context defines the transforms between
                        // the various coordinate spaces.

    POINTL* const pptlSim
    )
{
    MATRIX mxNW, mxND;

    if(( pptlSim->x ) && !ifio.bContinuousScaling())

    {
    //
    // This code path is for bitmap / non-scalable fonts. The notional
    // to device transformation is determined by simply looking up
    // the scaling factors for both the x-direction and y-direcion
    //

       #if DBG
        if (!(0 < pptlSim->x && pptlSim->x <= sizeof(galFloat)/sizeof(LONG)))
        {
            DbgPrint("\t*pptlSim = (%d,%d)\n",pptlSim->x,pptlSim->y);
            RIP("gre -- bad *pptlSim\n");

        //
        // bogus fix up for debugging purposes only
        //
            pptlSim->x = 1;
            pptlSim->y = 1;
        }
      #endif

        ULONG uAngle = 0;
        
        if( ifio.b90DegreeRotations() )
        {
            
            // If the WorldToDeive transform is not identity,
        // We have to consider WToD Xform for font orientation
        // This is only for Advanced Mode

            if(!(pdco->pdc->bWorldToDeviceIdentity()) )
            {
                INT s11,s12,s21,s22;
                EXFORMOBJ xo(*pdco,WORLD_TO_DEVICE);

            // Get Matrix element
            // lSignum() returns -1, if the element is minus value, otherwise 1

                s11 = (INT) xo.efM11().lSignum();
                s12 = (INT) xo.efM12().lSignum();
                s21 = (INT) xo.efM21().lSignum();
                s22 = (INT) xo.efM22().lSignum();

            // Check mapping mode

                if (pdco->pdc->bYisUp())
                {
                    s21 = -s21;
                    s22 = -s22;
                    uAngle = 3600 - lNormAngle( pelfw->lfOrientation );
                }
                 else
                {
                    uAngle = lNormAngle( pelfw->lfOrientation );
                }

           // Compute font orientation on distination device
           //
           // This logic depend on that -1 is represented as All bits are ON.

                uAngle = (ULONG)( lNormAngle
                                  (
                                      uAngle
                                         + (s12 &  900)
                                         + (s11 & 1800)
                                         + (s21 & 2700)
                                  ) / ORIENTATION_90_DEG
                                );
            }
             else
            {
                uAngle = (ULONG)(lNormAngle(pelfw->lfOrientation) /
                                 ORIENTATION_90_DEG );
            }
        }

        switch( uAngle )
        {
        case 0: // 0 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloatNeg[pptlSim->y]);
            break;
        case 1: // 90 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloatNeg[pptlSim->y]);
            break;
        case 2: // 180 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[pptlSim->y]);
            break;
        case 3:  // 270 Degress
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[pptlSim->y]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[pptlSim->x]);
            break;
        default:
            WARNING("bGetNtoD():Invalid Angle\n");
            break;
        }
        return(TRUE);
    }

    vGetNtoW(&mxNW, pelfw, ifio, pdco);

    EXFORMOBJ xoND(&mxND, DONT_COMPUTE_FLAGS);

    if ( pdco->pdc->bWorldToDeviceIdentity() == FALSE)
    {
        if (!xoND.bMultiply(&mxNW,&pdco->pdc->mxWorldToDevice()))
        {
            return(FALSE);
        }

    //
    // Compensate for the fact that for the font driver, one
    // device unit corresponds to the distance between pixels,
    // whereas for the engine, one device unit corresponds to
    // 1/16'th the way between pixels
    //
        mxND.efM11.vDivBy16();
        mxND.efM12.vDivBy16();
        mxND.efM21.vDivBy16();
        mxND.efM22.vDivBy16();
    }
    else
    {
        mxND = mxNW;
    }

    SET_FLOAT_WITH_LONG(pfdx->eXX,mxND.efM11.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eXY,mxND.efM12.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYX,mxND.efM21.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYY,mxND.efM22.lEfToF());

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* bGetNtoW_Win31
*
* Computes notional to world transform for the compatible
* mode Basically, computes notional to device transform in
* win31 style using page to device transform (ignoring
* possibly exhistent world to page transform.  then page to
* device is factored out leaving us with win31 style crippled
* notional to world transform.  As to the page to device
* transform, either the one in the dc is used, or if this
* routine has a metafile client, then page to device
* transform of the recording device is used.  Metafile code
* stored this transform in the dc.
*
* Called by:
*   bGetNtoD_Win31                                      [FONTMAP.CXX]
*
* History:
*  24-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL
bGetNtoW_Win31(
    MATRIX      *pmxNW, // store the result here
    LOGFONTW    *pelfw, // points to the extended logical font defining
                        // the font that is requested by the application.
                        // Units are ususally in World coordinates.

    IFIOBJ&     ifio,   // font to be used

    DCOBJ       *pdco,  // the device context defines the transforms between
                        // the various coordinate spaces.

    FLONG       fl,     // The flags supported are:
                        //
                        //     ND_IGNORE_ESC_AND_ORIENT
                        //
                        //         The presence of this flag indicates that
                        //         the escapement and orientation values
                        //         of the LOGFONT should be ignored.  This
                        //         is used for GetGlyphOutline which ignores
                        //         these values on Win 3.1.  Corel Draw 5.0
                        //         relies on this behavior to print rotated
                        //         text.
                        //
    BOOL     bIsLinkedFont  // is passed in as TRUE if the font is linked, FALSE otherwise
    )
{

    ASSERTGDI(
        (fl & ~(ND_IGNORE_ESC_AND_ORIENT | ND_IGNORE_MAP_MODE)) == 0,
        "gdisrv!NtoW_Win31 -- bad value for fl\n"
        );

    LONG   lfHeight;


    EFLOAT efHeightScale,
           efHeightNum,
           efHeightDen,
           efWidthScale,
           efWidthDen,
           efDefaultScale;

    if (ifio.lfWidth() == 0)
    {
        WARNING("gdisrv!bGetNtoW_Win31, AvgChW\n");
    }

    BOOL bUseMeta = pdco->pdc->bUseMetaPtoD();

    BOOL bDoXform = (!(fl & ND_IGNORE_MAP_MODE) &&
                      (bUseMeta || !pdco->pdc->bPageToDeviceScaleIdentity()));

    BOOL bPD11Is1 = TRUE;  // efPD11 == 1
    BOOL bPD22IsNeg    = FALSE; // efPD22 is negative

    EFLOATEXT efPD11;

    if ((lfHeight = pelfw->lfHeight) == 0)
    {
        lfHeight = lGetDefaultWorldHeight(pdco);
    }

    ASSERTGDI(lfHeight,"gdisrv!vGetNtoW -- zero lfHeight\n");


    // dchinn 9/16/98:
    // A fix to the Visual FoxPro 5.0 hcw.exe bug.  The bug is that the
    // dialog boxes in hcw.exe are designed with 8pt MS Shell Dlg
    // (at 96dpi, that's 11ppem), but the text in the dialog appears
    // as 12ppem in NT 5.  A possible contributing reason for this bug
    // is that the default shell dialog font in NT 4 is MS Sans Serif, which
    // is a bitmap font with only sizes 8, 10, 12, 14, 18, 24.  The default
    // shell dialog font for NT 5 is Microsoft Sans Serif, which is an OpenType
    // (TrueType) font.  Perhaps FoxPro somehow hardcodes 12ppem somewhere.
    // The fix here is that if the logfont is for the MS Shell Dlg at 12ppem
    // then we actually use an lfHeight of 11ppem.
    //
    // We only adjust for negative lfHeight because when lfHeight is negative,
    // the logfont is requesting an em height (as opposed to ascender plus
    // descender if lfHeight is positive).
    //
    // Well, change of heart, Lotus notes is asking for lfHeight == +15,
    // expecting to get the same size font as ms sans serif at lfHeight = -11;
    // so we have to adjust for positive lfHeights as well [bodind]
    //
    // Finally, this table of conversions below handles the case when
    // small fonts is set on the system (not large fonts)
    // (actually, it handles the lowest size for large fonts
    // and two smallest sizes for small fonts [bodind])


    if (gbShellFontCompatible &&
        !_wcsicmp(pelfw->lfFaceName, L"MS Shell Dlg") &&
        !bIsLinkedFont)  // don't do font size collapsing if dealing with a linked font
    {
        if (lfHeight > 0)
        {
	// sizes 12 and 13 are mapped to 14 because in bitmap font there is
	// no size smaller than 14. But we do not want to map everything from
	// 1 to 15 to 14 for tt, we only want to bump up as few sizes as needed to
	// get the backwards compat with nt 40 in the shell.

	    if ((lfHeight >= 12) && (lfHeight <= 15))
            {
		lfHeight = 14;	// same as -11 for ms sans serif
            }
            else if ((lfHeight > 15) && (lfHeight <= 19))
            {
		lfHeight = 16;	// same as -13 for ms sans serif
            }
        }
        else // lfHeight < 0
        {
	// sizes -9 and -10 are mapped to -11 because in bitmap font there is
	// no size smaller than -11.  But we do not want to map everything from
	// -11 to -15 to 14 for tt, we only want to bump up as few sizes as needed to
	// get the backwards compat with nt 40 in the shell.

            if ((lfHeight >= -12) && (lfHeight <= -9))
            {
                lfHeight = -11;  // fixes older version of outlook and janna contact dialogs
            }
            else if ((lfHeight > -16) && (lfHeight <= -13))
            {
                lfHeight = -13;  // just in case
            }
        }

    #if 0
      if (gbShellFontCompatible && !_wcsicmp(pelfw->lfFaceName, L"MS Shell Dlg") && ((lfHeight == -12) || (lfHeight == -14)
          || (lfHeight == -15) || (lfHeight == -17) || (lfHeight == -18) || (lfHeight > -11)
          || ((lfHeight > -24) && (lfHeight < -19))
          || ((lfHeight > -32) && (lfHeight < -24)) || (lfHeight < -32)
          ))
      {
         DbgPrint("\tNTFONT: MS Shell Dlg used at size %d ppem\n, dialog may be clipped",-lfHeight);
      }
    #endif
    }

    if (lfHeight > 0)
    {
        efHeightNum = (LONG)lfHeight;
        efHeightDen = (LONG)ifio.lfHeight();
    }
    else // lfHeight < 0
    {
        efHeightNum = (LONG)(-lfHeight);
        efHeightDen = (LONG) ifio.fwdUnitsPerEm();
    }

    efDefaultScale.eqDiv(efHeightNum,efHeightDen);

    pmxNW->efM22  = efDefaultScale;
    efHeightScale = efDefaultScale;

    if (bDoXform)
    {
        EFLOATEXT efPD22;

    // first check if hock wants us to use his page to device scale factors

        if (bUseMeta)
        {
            efPD11 = pdco->pdc->efMetaPtoD11();
            efPD22 = pdco->pdc->efMetaPtoD22();
        }
        else if (!pdco->pdc->bPageToDeviceScaleIdentity())
        {
            if (!pdco->pdc->bWorldToPageIdentity())
            {
            // need to compute page to device scaling coefficients
            // that will be used in computing crippled win31 style
            // notional to world scaling coefficients
            // This is because PtoD is not stored on the server side
            // any more. This somewhat slow code path is infrequent
            // and not perf critical

                EFLOATEXT efTmp;

                efPD11 = pdco->pdc->lViewportExtCx();
                efTmp = pdco->pdc->lWindowExtCx();
                efPD11.eqDiv(efPD11,efTmp);

                efPD22 = pdco->pdc->lViewportExtCy();
                efTmp = pdco->pdc->lWindowExtCy();
                efPD22.eqDiv(efPD22,efTmp);
            }
            else // page to device == world to device:
            {
                efPD11 = pdco->pdc->efM11();
                efPD22 = pdco->pdc->efM22();

            // Compensate for the fact that for the font driver, one
            // device unit corresponds to the distance between pixels,
            // whereas for the engine, one device unit corresponds to
            // 1/16'th the way between pixels

                efPD11.vDivBy16();
                efPD22.vDivBy16();

                ASSERTGDI(pdco->pdc->efM12().bIsZero(), "GDISRV: nonzero m12 IN WIN31 MODE\n");
                ASSERTGDI(pdco->pdc->efM21().bIsZero(), "GDISRV: nonzero m21 IN WIN31 MODE\n");
            }

        }
         #if DBG
        else
            RIP("gdisrv!ntow_win31\n");
        #endif

        bPD11Is1 = efPD11.bIs1();
        bPD22IsNeg = efPD22.bIsNegative();

        if (!efPD22.bIs1())
            efHeightScale.eqMul(efHeightScale,efPD22);

    // In win31 possible y flip or x flip on the text are not respected
    // so that signs do not make it into the xform

        efHeightScale.vAbs();
    }

    if (bPD22IsNeg)
    {
    // change the sign if necessary so that
    // pmxNW->efM22 * efPtoD22 == efHeightScale, which is enforced to be > 0

        pmxNW->efM22.vNegate();
    }


    PDEVOBJ pdo(pdco->hdev());
    if (!pdo.bValid())
    {
        RIP("gdisrv!bGetNtoW_Win31, pdevobj problem\n");
        return FALSE;
    }

// In the case that lfWidth is zero or in the MSBADWIDTH case we will need
// to adjust efWidthScale if VerRes != HorRez

    BOOL bMustCheckResolution = TRUE;

    if (pelfw->lfWidth)
    {
    // This makes no sense, but has to be here for win31 compatibility.
    // Win31 is computing the number of
    // pixels in x direction of the avgchar width scaled along y.
    // I find this a little bizzare [bodind]

        EFLOAT efAveChPixelWidth;
        efAveChPixelWidth = (LONG) ifio.fwdAveCharWidth();

    // take the resolution into account,

        #if 0

        if ((pdo.ulLogPixelsX() != pdo.ulLogPixelsY()) && !bUseMeta)
        {
            EFLOAT efTmp;
            efTmp = (LONG)pdo.ulLogPixelsY();
            efAveChPixelWidth.eqMul(efAveChPixelWidth,efTmp);
            efTmp = (LONG)pdo.ulLogPixelsX();
            efAveChPixelWidth.eqDiv(efAveChPixelWidth,efTmp);
        }

        #endif

        efWidthDen = efAveChPixelWidth; // save the result for later

        efAveChPixelWidth.eqMul(efAveChPixelWidth,efHeightScale);

        LONG lAvChPixelW, lReqPixelWidth;

    // requested width in pixels:

        EFLOAT efReqPixelWidth;
        lReqPixelWidth  = (LONG)ABS(pelfw->lfWidth);
        efReqPixelWidth = lReqPixelWidth;

        BOOL bOk = TRUE;

        if (bDoXform)
        {
            if (!bPD11Is1)
            {
                efReqPixelWidth.eqMul(efReqPixelWidth,efPD11);
                bOk =  efReqPixelWidth.bEfToL(lReqPixelWidth);
            }
            efReqPixelWidth.vAbs();
            if (lReqPixelWidth < 0)
                lReqPixelWidth = -lReqPixelWidth;
        }

    // win 31 does not allow tt fonts of zero width. This makes sense,
    // as we know rasterizer chokes on these.
    // Win31 does not allow fonts that are very wide either.
    // The code below is exactly what win31 is doing. Win31 has a bogus
    // criterion for determining a cut off for width.
    // Below this cut off, because of the  bug in win31 code,
    // the text goes from right to left.
    // For even smaller lfWidth
    // we get the expected "good" behavior. NT eliminates the Win31 bug
    // where for range of lfWidhts width scaling factor is negative.

        if
        (
            (
             efAveChPixelWidth.bEfToL(lAvChPixelW) &&
             (lAvChPixelW > 0)                     && // not too narrow !
             bOk                                   &&
             ((lReqPixelWidth / 256) < lAvChPixelW)   // bogus win31 criterion
            )
            ||
            ifio.bStroke()  // vector fonts can be arbitrarily wide or narrow
        )
        {
            bMustCheckResolution = FALSE;
            efWidthScale.eqDiv(efReqPixelWidth,efWidthDen);
        }
        /*
        else
        {
        //  win31 in either of these cases branches into MSFBadWidth case
        //  which is equivalent to setting lfWidth == 0 [bodind]
        }
        */
    }

    if (bMustCheckResolution)
    {
    // must compute width scale because it has not been
    // computed in lfWidth != 0 case

        if (ifio.bStroke())
        {
        // win31 behaves differently for vector fonts:
        // unlike tt fonts, vector fonts stretch along x, respecting
        // page to device xform. However, they ignore the request to flip
        // either x or y axis

            efWidthScale = efDefaultScale;
            if (!bPD11Is1)
            {
                efWidthScale.eqMul(efWidthScale,efPD11);
                efWidthScale.vAbs();
            }
        }
        else
        {
        // tt fonts make x scaling the same as y scaling,

            efWidthScale = efHeightScale;
        }

        POINTL ptlRes = *ifio.pptlAspect();

    // If VertRez != HorRez and we are using the default width we need to
    // adjust for the differences in resolution.
    // This is done in order to ensure that fonts look the same on printers
    // of different resolutions [bodind]

        if ((pdo.ulLogPixelsX() != pdo.ulLogPixelsY()) && !bUseMeta)
        {
            ptlRes.y *= (LONG)pdo.ulLogPixelsX();
            ptlRes.x *= (LONG)pdo.ulLogPixelsY();
        }

        if (ptlRes.x != ptlRes.y)
        {
            EFLOAT efTmp;
            efTmp = ptlRes.y;
            efWidthScale *= efTmp ;
            efTmp = ptlRes.x;
            efWidthScale /= efTmp;
        }

    }

// now that we have width scale we can compute pmxNW->efM11. We factor out
// (PtoD)11 out of width scale to obtain the effective NW x scale:

    if (!bPD11Is1)
        pmxNW->efM11.eqDiv(efWidthScale,efPD11);
    else
        pmxNW->efM11 = efWidthScale;

    pmxNW->efDx.vSetToZero();
    pmxNW->efDy.vSetToZero();
    pmxNW->efM12.vSetToZero();
    pmxNW->efM21.vSetToZero();

    EXFORMOBJ xoNW(pmxNW, DONT_COMPUTE_FLAGS);

// see if orientation angle has to be taken into account:

    if (ifio.bStroke())
    {
    // allow esc != orientation for vector fonts because win31 does it
    // also note that for vector fonts Orientation is treated as world space
    // concept, so we multiply here before applying world to device transform
    // while for tt fonts esc is treated as device space concept so that
    // this multiplication is occuring after world to page transform is applied

        if (pelfw->lfOrientation)
        {
            EFLOATEXT efAngle = pelfw->lfOrientation;
            efAngle /= (LONG) 10;

            MATRIX mxRot, mxTmp;

            mxRot.efM11 = efCos(efAngle);
            mxRot.efM22 = mxRot.efM11;
            mxRot.efM12 = efSin(efAngle);
            mxRot.efM21 = mxRot.efM12;
            mxRot.efM21.vNegate();
            mxRot.efDx.vSetToZero();
            mxRot.efDy.vSetToZero();

            mxTmp = *pmxNW;

            if (!xoNW.bMultiply(&mxTmp,&mxRot))
                return FALSE;
        }

    }

// take into account different orientation of y axes of notional
// and world spaces:

    pmxNW->efM12.vNegate();
    pmxNW->efM22.vNegate();

    xoNW.vComputeAccelFlags();

    return(TRUE);
}


/******************************Public*Routine******************************\
*
* BOOL bParityViolatingXform(DCOBJ  *pdco)
*
* History:
*  04-Jun-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bParityViolatingXform(DCOBJ  *pdco)
{

    if (pdco->pdc->bWorldToPageIdentity())
    {
        if (pdco->pdc->bPageToDeviceScaleIdentity())
        {
        // identity except maybe for translations

            return FALSE;
        }

        return (pdco->pdc->efM11().lSignum() != pdco->pdc->efM22().lSignum());
    }
    else
    {
    // we are in the metafile code

        return( pdco->pdc->efMetaPtoD11().lSignum() != pdco->pdc->efMetaPtoD22().lSignum() );
    }
}





/******************************Public*Routine******************************\
*
* bGetNtoD_Win31
*
* Called by:
*   PFEOBJ::bSetFontXform                               [PFEOBJ.CXX]
*
* History:
*  Tue 12-Jan-1993 11:58:41 by Kirk Olynyk [kirko]
* Added a quick code path for non-transformable (bitmap) fonts.
*  30-Sep-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bGetNtoD_Win31(
    FD_XFORM    *pfdx,  // pointer to the buffer to recieve the
                        // notional to device transformation for the
                        // font driver.  There are a couple of
                        // important things to remember.  First,
                        // according to the conventions of the ISO
                        // committee, the coordinate space for notional
                        // (font designer) spaces are cartesian.
                        // However, due to a series of errors on my part
                        // [kirko] the convention that is used by the
                        // DDI is that the notional to device transformation
                        // passed over the DDI assumes that both the notional
                        // and the device space are anti-Cartesian, that is,
                        // positive y increases in the downward direction.
                        // The fontdriver assumes that
                        // one unit in device space corresponds to the
                        // distance between pixels. This is different from
                        // GDI's internal view, where one device unit
                        // corresponds to a sub-pixel unit.

    LOGFONTW *pelfw,    // points to the extended logical font defining
                        // the font that is requested by the application.
                        // Units are ususally in World coordinates.

    IFIOBJ&     ifio,   // font to be used

    DCOBJ       *pdco,  // the device context defines the transforms between
                        // the various coordinate spaces.

    FLONG       fl,     // The flags supported are:
                        //
                        //     ND_IGNORE_ESC_AND_ORIENT
                        //
                        //         The presence of this flag indicates that
                        //         the escapement and orientation values
                        //         of the LOGFONT should be ignored.  This
                        //         is used for GetGlyphOutline which ignores
                        //         these values on Win 3.1.  Corel Draw 5.0
                        //         relies on this behavior to print rotated
                        //         text.
                        //
    POINTL * const pptlSim,
    BOOL     bIsLinkedFont  // is passed in as TRUE if the font is linked, FALSE otherwise
    )
{
    MATRIX mxNW, mxND;
    ASSERTGDI(
        (fl & ~(ND_IGNORE_ESC_AND_ORIENT | ND_IGNORE_MAP_MODE))== 0,
        "gdisrv!bGetNtoD_Win31 -- bad value for fl\n"
        );

    if((pptlSim->x) && !ifio.bContinuousScaling())
    {
    //
    // This code path is for bitmap / non-scalable fonts. The notional
    // to device transformation is determined by simply looking up
    // the scaling factors for both the x-direction and y-direcion
    //

       #if DBG
        if (!(0 < pptlSim->x && pptlSim->x <= sizeof(galFloat)/sizeof(LONG)))
        {
            DbgPrint("\t*pptlSim = (%d,%d)\n",pptlSim->x,pptlSim->y);
            RIP("gre -- bad *pptlSim\n");
        }
      #endif


    // Win3.1J ignore orientation anytime. But use escapement for rotate Glyph data.

    // If the font driver that this font provide , has not arbitality flag.
    // Angle should be 0 , 900 , 1800 or 2700
    // for Win31J compatibility

        ULONG uAngle = 0;

        if (gbDBCSCodePage)
        {
            if( ifio.b90DegreeRotations() )
            {
                if (pdco->pdc->bYisUp())
                    uAngle = (ULONG)(((3600-lNormAngle(pelfw->lfEscapement)) /
                                      ORIENTATION_90_DEG) % 4);
                 else
                    uAngle = (ULONG)( lNormAngle(pelfw->lfEscapement) /
                                     ORIENTATION_90_DEG );
            }
        }

        switch( uAngle )
        {
        case 0: // 0 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloatNeg[pptlSim->y]);
            break;
        case 1: // 90 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloatNeg[pptlSim->y]);
            break;
        case 2: // 180 Degrees
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloatNeg[pptlSim->x]);
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[pptlSim->y]);
            break;
        case 3:  // 270 Degress
            SET_FLOAT_WITH_LONG(pfdx->eXY,galFloat[pptlSim->y]);
            SET_FLOAT_WITH_LONG(pfdx->eXX,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYY,galFloat[0         ]);
            SET_FLOAT_WITH_LONG(pfdx->eYX,galFloat[pptlSim->x]);
            break;
        default:
            WARNING("bGetNtoD_Win31():Invalid Angle\n");
            break;
        }

        return(TRUE);
    }

    if (!bGetNtoW_Win31(&mxNW, pelfw, ifio, pdco, fl, bIsLinkedFont))
        return FALSE;

    EXFORMOBJ xoND(&mxND, DONT_COMPUTE_FLAGS);

    if( (pdco->pdc->bWorldToDeviceIdentity() == FALSE) &&
        !(fl & ND_IGNORE_MAP_MODE) )
    {
        if (!xoND.bMultiply(&mxNW,&pdco->pdc->mxWorldToDevice()))
        {
            return(FALSE);
        }

    //
    // Compensate for the fact that for the font driver, one
    // device unit corresponds to the distance between pixels,
    // whereas for the engine, one device unit corresponds to
    // 1/16'th the way between pixels
    //
        mxND.efM11.vDivBy16();
        mxND.efM12.vDivBy16();
        mxND.efM21.vDivBy16();
        mxND.efM22.vDivBy16();
    }
    else
    {
        mxND = mxNW;
    }

    if (!ifio.bStroke())
    {
    // for tt fonts escapement and orientation are treated as
    // device space concepts. That is why for these fonts we apply
    // rotation by lAngle last

        LONG lAngle;


        if( ifio.b90DegreeRotations() )
        {
            lAngle = (LONG)( ( lNormAngle(pelfw->lfEscapement)
                           / ORIENTATION_90_DEG ) % 4 ) * ORIENTATION_90_DEG;
        }
        else // ifio.bArbXform() is TRUE
        {
            lAngle = pelfw->lfEscapement;
        }

        if(lAngle != 0 && (!(fl & ND_IGNORE_ESC_AND_ORIENT) || gbDBCSCodePage))
        {
            // more of win31 compatability: the line below would make sense
            // if this was y -> -y type of xform. But they also do it
            // for x -> -x xform. [bodind]

            if (bParityViolatingXform(pdco))
            {
                lAngle = -lAngle;
            }

            EFLOATEXT efAngle = lAngle;
            efAngle /= (LONG) 10;

            MATRIX mxRot, mxTmp;

            mxRot.efM11 = efCos(efAngle);
            mxRot.efM22 = mxRot.efM11;
            mxRot.efM12 = efSin(efAngle);
            mxRot.efM21 = mxRot.efM12;
            mxRot.efM12.vNegate();
            mxRot.efDx.vSetToZero();
            mxRot.efDy.vSetToZero();

            mxTmp = mxND;

            if (!xoND.bMultiply(&mxTmp,&mxRot))
                return FALSE;

        }
        
    // adjust for nonsquare resolution

        PDEVOBJ pdo(pdco->hdev());
        if (pdo.ulLogPixelsX() != pdo.ulLogPixelsY())
        {
            EFLOATEXT efTmp = (LONG)pdo.ulLogPixelsX();
            efTmp /= (LONG)pdo.ulLogPixelsY();
            MATRIX mxW2D = pdco->pdc->mxWorldToDevice();

	     if(mxW2D.efM12.bIsZero() && mxW2D.efM21.bIsZero()){// for 1,4 -up printing
            	mxND.efM12 /= efTmp;
            	mxND.efM21 *= efTmp;
            }
            else{	// for 2, 6-up printing, i.e. 270 rotation
            	mxND.efM11 *= efTmp;
            	mxND.efM22 /= efTmp;
            }            
        }
    }

    SET_FLOAT_WITH_LONG(pfdx->eXX,mxND.efM11.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eXY,mxND.efM12.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYX,mxND.efM21.lEfToF());
    SET_FLOAT_WITH_LONG(pfdx->eYY,mxND.efM22.lEfToF());

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fntcache.cxx ===
/*****************************************************************************
* Module Name: fntcache.cxx
*
* Font Cahce API's for NT font engine.
*
* History:
*  4-15-99 We need to add the code for WTS (Hydra)
*  There are 3 major changes,
*  (1) We can not write to fntcache.dat in read mode. So we have modified the code
*  to make sure there there is no writing to fntcache in read mode.
*  (2) Implement a lock algorithm so than no remote session can open the fntcache.dat
*  during write mode of console.
*  (3) Check the time stamp of win32k.sys and atmfd.dll
*  4-3-98 Yung-Jen Tony Tsai   Wrote it.
*
* Copyright (c) 1998-1999 Microsoft Corporation
*****************************************************************************/

#include "precomp.hxx"
#include <ntverp.h>

FLONG       gflFntCacheState;
FNTCACHE    *gFntCache;
HSEMAPHORE  ghsemFntCache = NULL;

extern "C"          gbJpn98FixPitch;

extern BOOL         G_fConsole;

#define FNTCACHEPATH L"\\SystemRoot\\system32\\FNTCACHE.DAT"
#define WIN32KPATH  L"\\SystemRoot\\system32\\win32k.sys"
#define ATMFDPATH  L"\\SystemRoot\\system32\\atmfd.dll"
#define DISABLE_REMOTE_FONT_BOOT_CACHE  L"DisableRemoteFontBootCache"
#define LASTBOOTTIME_FONT_CACHE_STATE    L"LastBootTimeFontCacheState"
#define FNT_CACHE_EXTRA_SIZE (16*512)
#define RESERVE_LINKS        200

#if DBG
VOID DebugGreTrackRemoveMapView(PVOID ViewBase);

#define     FNTCACHE_DBG_LEVEL_0    0
#define     FNTCACHE_DBG_LEVEL_1    1
#define     FNTCACHE_DBG_LEVEL_2    2
#define     FNTCACHE_DBG_LEVEL_3    3

ULONG       gFntTest = FNTCACHE_DBG_LEVEL_3;

#define FNT_KdBreakPoint(d, s1)     \
{                                   \
    if (d >= gFntTest)              \
    {                               \
        DbgPrint s1;                \
                                    \
        if (d >= FNTCACHE_DBG_LEVEL_1)  \
            DbgBreakPoint();            \
    }                               \
}
#else

#define FNT_KdBreakPoint(d, s1)

#endif

extern "C" ULONG ComputeFileviewCheckSum(PVOID, ULONG);

#define FNTCacheFileCheckSum(pTableView, cjView)  ComputeFileviewCheckSum((PVOID)((PBYTE) pTableView + 4), (cjView -4))

#define FNTINDEX_INVALID 0xffffffff

ULONG   ComupteFNTCacheFastCheckSum(ULONG cwc, PWSZ pwsz, PFONTFILEVIEW *ppfv,ULONG cFiles, DESIGNVECTOR *pdv, ULONG cjDV);
VOID    SearchFNTCacheHlink(ULONG ulFastCheckSum, FNTHLINK **ppfntHLink, FNTCACHEHEADER *pTable);
BOOL    bFntCacheCreateHLink(ULONG ulFastCheckSum);
VOID    PutFNTCacheIFI(ULONG ulFastCheckSum, PBYTE pIfi, ULONG ulSize);
FNTHLINK * SearchFntCacheNewLink(ULONG ulFastCheckSum);
BOOL    bInitCacheTable(ULONG ulTTFonts, ULONG ulT1FOnts, LARGE_INTEGER FntRegLWT, LARGE_INTEGER T1RegLWT, ULONG CodePage);

// Here is only for performance evaluation
#define KEY_GRE_INITIALIZE  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Gre_Initialize"
#define KEY_NT_CURRENTVERSION  L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion"

#define FNT_DISABLEFONTCACHE    L"DisableFontBootCache"
#define CURRENT_BUILDNUMBER     L"CurrentBuildNumber"


BOOL bQueryValueKey(PWSZ pwszValue, HANDLE RegistryKey, PKEY_VALUE_PARTIAL_INFORMATION ValueKeyInfo, ULONG ValueLength);
BOOL bOpenKey(PWSZ pwszKey, HANDLE *pRegistryKey);
VOID vUnmapFontCacheFile(VOID);

#define EXTRA_BUFFER 48
#define BUFF_LENGTH  (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + EXTRA_BUFFER)

typedef union _KVINFO
{
    KEY_VALUE_PARTIAL_INFORMATION kv;
    BYTE                          aj[BUFF_LENGTH];
} KVINFO;


VOID vCleanUpFntCache(VOID)
{

    if (ghsemFntCache == NULL)
        return;

    HSEMAPHORE hsemTmp = ghsemFntCache;

    {
        SEMOBJ  so(ghsemFntCache);

        if (gFntCache)
        {
            if (gFntCache->pTable)
            {
                vUnmapFontCacheFile();
            }


            VFREEMEM((PVOID) gFntCache);
            gFntCache = NULL;
        }

        gflFntCacheState = 0;
        ghsemFntCache = NULL;
    }

// delete the semaphore, no longer needed

    GreDeleteSemaphore(hsemTmp);
}

BOOL bFntCacheDriverLWT( PCWSTR pcwFontDriverFileName, LARGE_INTEGER  *pLastWriteTime)
{
    UNICODE_STRING            UnicodeString;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    NTSTATUS                  NtStatus;
    HANDLE                    FileHandle = 0;
    IO_STATUS_BLOCK           IoStatusBlock;
    FILE_BASIC_INFORMATION    FileBasicInfo;

    BOOL bRet = FALSE;

    pLastWriteTime->QuadPart = 0;

    RtlInitUnicodeString(&UnicodeString, pcwFontDriverFileName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        0,
        0);

    NtStatus = IoCreateFile(
                   &FileHandle,
                   FILE_GENERIC_READ 
                    | FILE_GENERIC_EXECUTE
                    | SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   FILE_ATTRIBUTE_NORMAL,
                   FILE_SHARE_READ,
                   FILE_OPEN,       // Flag for file open.
                   FILE_SYNCHRONOUS_IO_ALERT,
                   0,
                   0,
                   CreateFileTypeNone,
                   NULL,
                   IO_FORCE_ACCESS_CHECK |     // Ensure the user has access to the file
                   IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                   IO_CHECK_CREATE_PARAMETERS);

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

// Get the time stamp

    NtStatus = ZwQueryInformationFile(
                   FileHandle,
                   &IoStatusBlock,
                   &FileBasicInfo,
                   sizeof(FileBasicInfo),
                   FileBasicInformation);

    ZwClose(FileHandle);

    if (NT_SUCCESS(NtStatus))
    {
        *pLastWriteTime = FileBasicInfo.LastWriteTime;
        bRet = TRUE;
    }

    return bRet;
}

VOID vGetFontDriverLWT(LARGE_INTEGER *pWin32kLWT, LARGE_INTEGER *pAtmfdLWT)
{
    LARGE_INTEGER  LastWriteTime;

    if (bFntCacheDriverLWT( WIN32KPATH, &LastWriteTime))
    {
        pWin32kLWT->QuadPart = LastWriteTime.QuadPart;
    }

    if (bFntCacheDriverLWT( ATMFDPATH, &LastWriteTime))
    {
        pAtmfdLWT->QuadPart = LastWriteTime.QuadPart;
    }
    
}

NTSTATUS GetGreRegKey(HANDLE *phkRegistry, ACCESS_MASK dwDesiredAccess, PCWSTR pcwsz)
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;

    RtlInitUnicodeString(&UnicodeString, pcwsz);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    return ZwOpenKey(phkRegistry, dwDesiredAccess, &ObjectAttributes);
}

BOOL bSetFntCacheReg(PCWSTR pcwsz, DWORD dwValue)
{
    HANDLE                      hkRegistry;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    BOOL                        bRet = FALSE;

    status = GetGreRegKey(&hkRegistry, GENERIC_WRITE, KEY_GRE_INITIALIZE);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, pcwsz);

        status = ZwSetValueKey(hkRegistry,
                               &UnicodeString,
                               0,
                               REG_DWORD,
                               &dwValue,
                               sizeof(DWORD));


        if (NT_SUCCESS(status))
            bRet = TRUE;
        else
            WARNING(" Failed to set DisableRemoteFontBootCache registry");

        ZwCloseKey(hkRegistry);
    }

    return bRet;
    
}

DWORD bQueryFntCacheReg (HANDLE  hkRegistry, PCWSTR pcwsz, DWORD *pdwDisableMode)
{
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;
    BOOL                        bRet = FALSE;

    RtlInitUnicodeString(&UnicodeString, pcwsz);

    Length = sizeof(KEY_VALUE_FULL_INFORMATION) + (wcslen(pcwsz) + 1) * 2 +
             sizeof(DWORD);

    Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, 'CFTT');

    if (Information)
    {
        status = ZwQueryValueKey(hkRegistry,
                                 &UnicodeString,
                                 KeyValueFullInformation,
                                 Information,
                                 Length,
                                 &Length);

        if (NT_SUCCESS(status))
        {
            *pdwDisableMode = *(LPDWORD) ((((PUCHAR)Information) +
                                             Information->DataOffset));
            bRet = TRUE;
        }

        VFREEMEM(Information);
    }

    return bRet;
}

VOID vGetLastBootTimeStatus(void)
{
    HANDLE                      hkRegistry;
    NTSTATUS                    status;
    DWORD                       dwReg = 0;

    status = GetGreRegKey(&hkRegistry, GENERIC_READ, KEY_GRE_INITIALIZE);

    gFntCache->flPrevBoot = 0;

    if (NT_SUCCESS(status))
    {
        if (bQueryFntCacheReg(hkRegistry, LASTBOOTTIME_FONT_CACHE_STATE, &dwReg))
        {
            gFntCache->flPrevBoot = (FLONG) dwReg;
        }
        ZwCloseKey(hkRegistry);
    }

// If we are going to be opening the fntcache.dat in read mode than current boot time state
// will be the same as the previous boot time state. But flThisBoot will change
// if we will be opening the file CREATE (write) mode.

    gFntCache->flThisBoot = gFntCache->flPrevBoot;
}


/*****************************************************************************
 * BOOL bFntCacheDisabled()
 *
 * Tempary routine for performance evaluation
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bFntCacheDisabled()
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;
    DWORD                       dwDisableMode = 0;
    BOOL                        bRet = FALSE;


    status = GetGreRegKey(&hkRegistry, GENERIC_READ, KEY_GRE_INITIALIZE);

    if (NT_SUCCESS(status))
    {
    // let us check if somebody wanted to disable fontcache.dat by setting the
    // DisableFontBootCache in the registry:

        if (bQueryFntCacheReg(hkRegistry, L"DisableFontBootCache", &dwDisableMode))
        {
            if (dwDisableMode)
                bRet = TRUE;
        }

        if (!bRet && !G_fConsole)
        {
        // we may still want to disable the use of font cache for this remote hydra session.
        // We would do this if the console session is writing to the font cache at this time
        // (the console session would set the dwDisableMode to 1 in the registry so that
        // remote sessions do not try to access the cache)
        // or
        // if the font cache is in a suspcious state, so that whoever read from or wrote to
        // the cache before set the dwDisableMode to 1 in the registry

            if (bQueryFntCacheReg(hkRegistry, DISABLE_REMOTE_FONT_BOOT_CACHE, &dwDisableMode))
            {
                if (dwDisableMode)
                    bRet = TRUE;
            }
            else
            {
            // for some reason, to read the registry failed. So it would be safe to
            // disable the font cache.
                bRet = TRUE;
            }
        }

        ZwCloseKey(hkRegistry);
    }

    return bRet;
}

/*****************************************************************************
 * BOOL bFntCacheDisabled()
 *
 * This routine to get the registry only for JPN fix pitch compatible width
 *
 * History
 *  2-3-2000 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID vGetJpn98FixPitch()
{
    HANDLE                      hkRegistry;
    NTSTATUS                    status;
    DWORD                       dwFixPitch = 0;
    
    status = GetGreRegKey(&hkRegistry, GENERIC_READ, KEY_GRE_INITIALIZE);

    if (NT_SUCCESS(status))
    {
        if (bQueryFntCacheReg(hkRegistry, L"Jpn98FixPitch", &dwFixPitch))
        {
            if (dwFixPitch)
                gbJpn98FixPitch = TRUE;
            else
                gbJpn98FixPitch = FALSE;
        }

        ZwCloseKey(hkRegistry);
    }
}


/*****************************************************************************
 * VOID    FntCacheHDEV()
 *
 * Cache the font driver handle, include TT, OT, BMP and VT
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    FntCacheHDEV(PPDEV hdev, ULONG ulDrv)
{
    // There is no cache
    if (!(gflFntCacheState & FNT_CACHE_MASK))
    {
        return;
    }

    ASSERTGDI (ulDrv && hdev, " Fnt Cache HDEV is wrong \n");

    if (ulDrv)
        gFntCache->hDev[ulDrv] = hdev;

}

/*****************************************************************************
 * extern "C" VOID    EngFntCacheFault(ULONG ulFastCheckSum, FLONG fl)
 *
 * Fault reprot for Engine font cache.
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C" VOID    EngFntCacheFault(ULONG ulFastCheckSum, FLONG fl)
{
    FNTHLINK        *pFntHlink = NULL;
    BOOL            bExcept = FALSE;

    // There is no cache
    if (ghsemFntCache == NULL)
        return;

    SEMOBJ          so(ghsemFntCache);

    if (!(gflFntCacheState & FNT_CACHE_MASK))
    {
        return;
    }

    BOOL    bUpdate = FALSE;

    switch (fl)
    {
        case ENG_FNT_CACHE_READ_FAULT:
        case ENG_FNT_CACHE_WRITE_FAULT:

        // if we have already marked the font cache as bad, do not need to do it again

            if (!(gFntCache->flThisBoot & FNT_CACHE_STATE_ERROR))
                bUpdate = TRUE;

            break;

        default:
            break;
    }

    if (bUpdate)
    {
    // we do need to mark the cache invalid

        gFntCache->flThisBoot |= FNT_CACHE_STATE_ERROR;
        bSetFntCacheReg (LASTBOOTTIME_FONT_CACHE_STATE, gFntCache->flThisBoot);
    }
}

/*****************************************************************************
 * VOID    PutFntCacheDrv(ULONG ulFastCheckSum, PPDEV hdev)
 *
 * Each font file is mapped to one font driver and cache it.
 *
 * History
 *  10-15-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    PutFntCacheDrv(ULONG ulFastCheckSum, PPDEV hdev)
{
    if (ghsemFntCache == NULL)
        return;

    SEMOBJ  so(ghsemFntCache);

    // There is no cache
    if (!(gflFntCacheState & FNT_CACHE_MASK))
    {
        return;
    }

    // No checksum mean nothing we can do
    if (ulFastCheckSum)
    {
        ULONG   i, ulMode;

        ulMode = FNT_DUMMY_DRV;

        // Serched the cached device handle
        for (i = FNT_TT_DRV; i <= FNT_OT_DRV; i++)
        {
            if (hdev == gFntCache->hDev[i])
            {
                ulMode = i;
                break;
            }
        }

    // some unknown font driver has been used for the system, and we will not cache it.
        if (ulMode == FNT_DUMMY_DRV)
            return;

        // We cached it when FNTCache is in write mode

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {
            FNTHLINK        *pFntHlink = NULL;

            pFntHlink = SearchFntCacheNewLink(ulFastCheckSum);

            if (pFntHlink)
            {
            // If fast check sum is in conflict, we can not cache it.

                if (pFntHlink->ulDrvMode == FNT_DUMMY_DRV) // uninitialized link
                {
                    pFntHlink->ulDrvMode = ulMode;
                }
                else
                {
                // Ok, fast checksum conflict

                    WARNING("Checksum conflict in  PutFntCacheDrv");
                    pFntHlink->flLink |= FNT_CACHE_CHECKSUM_CONFLICT;
                }
            }
            else
            {
                gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
            }

            gFntCache->bWrite = TRUE;
        }
        else
        {
            ASSERTGDI(gflFntCacheState & FNT_CACHE_LOOKUP_MODE,
                           "PutFntCacheDrv: gflFntCacheState\n");

        // attempting to write during the read mode.
        // This may happen if somebody overwrote the file in the fonts directory
        // without updating the [Fonts] section in the registry. In this (infrequent) case we
        // want to force the rebuild of the cache at the next boot time.

            gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
        }
    }
}

VOID vUnmapFontCacheFile(VOID)
{
    NTSTATUS ntStatus;

    ASSERTGDI(gFntCache->pSection, "vUnmapFontCacheFile: gFntCache->pSection is NULL\n");
    ASSERTGDI(gFntCache->pTable, "vUnmapFontCacheFile: gFntCache->pTable is NULL\n");
    
#if defined(_GDIPLUS_)

    ntStatus = UnmapViewInProcessSpace(gFntCache->pTable);

#elif defined(_HYDRA_)

    // MmUnmapViewInSessionSpace is internally promoted to
    // MmUnmapViewInSystemSpace on non-Hydra systems.

    ntStatus = Win32UnmapViewInSessionSpace((PVOID) gFntCache->pTable );
#else
    ntStatus = MmUnmapViewInSystemSpace((PVOID)gFntCache->pTable)));
#endif

#if DBG
    if (!NT_SUCCESS(ntStatus))
        RIP(" Font cache file remove Map View failed \n");
#endif

#if DBG && defined(_HYDRA_)
    if ((!G_fConsole) && (NT_SUCCESS(ntStatus)))
    {
        DebugGreTrackRemoveMapView((PVOID) gFntCache->pTable);
    }
#endif

    DEREFERENCE_FONTVIEW_SECTION(gFntCache->pSection);

    gFntCache->pSection = NULL;
    gFntCache->pTable = NULL;

    return;
}

/*****************************************************************************
 * VOID  CloseFNTCache()
 *
 * Clean font cache after system boot
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C" VOID  CloseFNTCache()
{
// do paranoid check

    HSEMAPHORE hsemTmp = ghsemFntCache;

    if (ghsemFntCache == NULL)
        return;

    {
        SEMOBJ  so(ghsemFntCache);

        if (!(gflFntCacheState & FNT_CACHE_MASK))
        {
            gflFntCacheState = 0;
            return;
        }

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {
        // Close the file, we are done recreating it

            if (gFntCache->pTable)
            {
                if (gFntCache->bWrite)
                {
                    gFntCache->pTable->ulTotalLinks = gFntCache->ulCurrentHlink;
                    gFntCache->pTable->cjDataUsed = (ULONG)(gFntCache->pCacheBuf - gFntCache->pCacheBufStart);
                    gFntCache->pTable->CheckSum = FNTCacheFileCheckSum(gFntCache->pTable, gFntCache->pTable->ulFileSize);
                }
            }
        }

        if (gFntCache->pTable)
        {
            vUnmapFontCacheFile();
        }

    // now that the file is closed set the registry to indicate that it is ok for remote
    // sessions to read from the cache file

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {
            if (gFntCache->flPrevBoot != gFntCache->flThisBoot)
                bSetFntCacheReg(LASTBOOTTIME_FONT_CACHE_STATE, gFntCache->flThisBoot);

        // Unlock fnt cache file, say that it is ok to read from it

            bSetFntCacheReg(DISABLE_REMOTE_FONT_BOOT_CACHE, 0);
        }
        else
        {
            if (gFntCache->flThisBoot & (FNT_CACHE_STATE_ERROR | FNT_CACHE_STATE_FULL))
                bSetFntCacheReg(LASTBOOTTIME_FONT_CACHE_STATE, gFntCache->flThisBoot);
        }

        VFREEMEM((PVOID) gFntCache);
        gFntCache = NULL;

        gflFntCacheState = 0;
        ghsemFntCache = NULL;
    }

// delete the semaphore, no longer needed

    GreDeleteSemaphore(hsemTmp);
}

/*****************************************************************************
 * BOOL bReAllocCacheFile(ULONG ulSize)
 *
 * ReAlloc font cache buffer
 *
 * History
 *  10-14-98 modified [YungT]
 *  8-22-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bReAllocCacheFile(ULONG ulSize)
{
    BOOL            bOK = FALSE;
    ULONG           ulSizeExtraOrg;
    ULONG           ulFileSizeOrg;
    ULONG           ulSizeExtra;
    ULONG           ulCurrentSize;
    ULONG           ulFileSize;
    DWORD           dpOffsetStart;
    FILEVIEW        FileView;

// OVERFLOW means that we would like to get a bigger cache file but the OS would not give it to us.
// In this case we just close the cache file, update the checksum (bWrite set to true) and
// let remote sessions that are to be started later use the partial cache file

    if (gFntCache->flThisBoot & FNT_CACHE_STATE_OVERFLOW)
    {
    // we tried this once before and it did not work, so we do not bother to do it again

        return bOK;
    }

    ulFileSizeOrg = gFntCache->pTable->ulFileSize;
    ulCurrentSize = (ULONG) (gFntCache->pCacheBufEnd - gFntCache->pCacheBuf);

// Calculate the extra cache we need

    ulSizeExtra = QWORD_ALIGN(ulSize - ulCurrentSize) + FNT_CACHE_EXTRA_SIZE;

    ulFileSize = ulFileSizeOrg + ulSizeExtra;

    dpOffsetStart = (DWORD) (gFntCache->pCacheBufStart - (PBYTE) gFntCache->pTable);

    if (gFntCache->pTable)
    {
       vUnmapFontCacheFile();
    }

    RtlZeroMemory(&FileView, sizeof(FILEVIEW));

    if (bMapFile(FNTCACHEPATH, &FileView, ulFileSize, NULL))
    {
        DWORD dpOffset;

        gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
        gFntCache->pSection = FileView.pSection;

        gFntCache->pTable->ulFileSize = ulFileSize;
        gFntCache->pTable->cjDataExtra += ulSizeExtra;


        dpOffset = (ULONG)(gFntCache->pCacheBuf - gFntCache->pCacheBufStart);

    // Got a new Table and got to re-calculate the buffer end pointer

        gFntCache->pCacheBufStart = (PBYTE) gFntCache->pTable + dpOffsetStart;

        gFntCache->pCacheBuf = gFntCache->pCacheBufStart + dpOffset;

        gFntCache->pCacheBufEnd = gFntCache->pCacheBufStart + gFntCache->pTable->cjDataAll +
                                         gFntCache->pTable->cjDataExtra;

        bOK = TRUE;
    }
    else
    {
    // Something wrong, so we do not change anything

        RtlZeroMemory(&FileView, sizeof(FILEVIEW));

        if (bMapFile(FNTCACHEPATH, &FileView, ulFileSizeOrg, NULL))
        {
            gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
            gFntCache->pSection = FileView.pSection;

        // we want the cache properly closed, with check sum recomputed etc.

            gFntCache->bWrite = TRUE;

        // Force rebuild on the next boot, but for this boot let remote sessions
        // use the partial cache file.

            gFntCache->flThisBoot |= (FNT_CACHE_STATE_OVERFLOW | FNT_CACHE_STATE_FULL);
        }
        else
        {
        // Something wrong here. We need to set it to no cache mode.

            WARNING("bReAllocCacheFile failed to allocate more buffer \n");
            gFntCache->flThisBoot |= FNT_CACHE_STATE_ERROR;
        }
    }

    return bOK;
}

/*****************************************************************************
 * ULONG QueryFontReg(PWCHAR pwcRegKeyPath, LARGE_INTEGER *pFontRegLastWriteTime)
 *
 * Helper function for query fonts information from TT and T1 fonts registry
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL QueryFontReg(PWCHAR pwcRegKeyPath, LARGE_INTEGER *pFontRegLastWriteTime, ULONG * pulFonts)
{
    NTSTATUS                Status;
    KEY_FULL_INFORMATION    KeyInfo;
    HANDLE                  hkey = NULL;
    DWORD                   Length;

    *pulFonts = 0;

    Status = GetGreRegKey(&hkey,KEY_READ, pwcRegKeyPath);

    if (NT_SUCCESS(Status))
    {

        // get the number of entries in the [Fonts] section and get the last write time
        Status = ZwQueryKey(hkey,
                            KeyFullInformation,
                            &KeyInfo,
                            sizeof(KeyInfo),
                            &Length);

        if (NT_SUCCESS(Status))
        {

        // for additional fonts that do not load from fonts section of the registry

            *pulFonts = KeyInfo.Values;
            pFontRegLastWriteTime->QuadPart =   KeyInfo.LastWriteTime.QuadPart;

            FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_0, (" %d items in Font key \n", *pulFonts));

        }

        ZwCloseKey(hkey);
    }

    return NT_SUCCESS(Status);
}

/*****************************************************************************
 * PVOID EngFntCacheAlloc(ULONG ulFastCheckSum, ULONG ulSize)
 *
 * Alloc the cached buffer for font driver
 *
 * History
 *  10-5-98 rewrite [YungT]
 *  8-22-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C"  PVOID EngFntCacheAlloc(ULONG ulFastCheckSum, ULONG ulSize)
{

    PVOID pvIfi = NULL;

    {
        if (ghsemFntCache == NULL)
            return pvIfi;

        SEMOBJ  so(ghsemFntCache);

        if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
        {

            if ( (gFntCache->pCacheBuf + QWORD_ALIGN(ulSize) < gFntCache->pCacheBufEnd)
                || bReAllocCacheFile(ulSize))
            {
                FNTHLINK        *pFntHlink = NULL;

                if (pFntHlink = SearchFntCacheNewLink(ulFastCheckSum))
                {
                // If fast check sum is conflict, we can not cache it.

                   if (pFntHlink->cjData == 0 && pFntHlink->dpData == 0)
                   {
                        pvIfi = (PVOID) gFntCache->pCacheBuf;

                   // Gaurantee the cache pointer is at 8 byte boundary

                        gFntCache->pCacheBuf = gFntCache->pCacheBuf + QWORD_ALIGN(ulSize);
                        pFntHlink->cjData = ulSize;
                        pFntHlink->dpData = (DWORD) ((PBYTE) pvIfi - gFntCache->pCacheBufStart);
                    }
                    else
                    {
                        WARNING("Checksum conflict in  EngFntCacheAlloc");
                        pFntHlink->flLink |= FNT_CACHE_CHECKSUM_CONFLICT;
                    }

                    gFntCache->bWrite = TRUE;
                }
            }
        }
        else
        {
            ASSERTGDI(gflFntCacheState & FNT_CACHE_LOOKUP_MODE,
                      "EngFntCacheAlloc: gflFntCacheState\n");

        // During read mode, the remote session still wants to write into fntcache.dat.
        // This could happen if RemoteSession1 adds more fonts to both registry and on the disk.
        // Then later, the RemoteSession2 may attepmpt during its initialization to add these fonts
        // to the font cache, but we will reject this and ask that on the next boot the cache file
        // be rebuilt. also, the files could have been overwritten on the disk without
        // registry entries being updated, so we just force rebuild next time to be safe.

            gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
        }
    }

    if (gFntCache->flThisBoot & FNT_CACHE_STATE_ERROR)
    {
        CloseFNTCache();
        pvIfi = NULL;
    }

    return pvIfi;
}

/*****************************************************************************
 * PVOID EngFntCacheLookUp(ULONG FastCheckSum, ULONG *pcjData)
 *
 * Lookup font cache
 *
 * History
 *  10-5-98 rewrite [YungT]
 *  8-22-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

extern "C" PVOID EngFntCacheLookUp(ULONG FastCheckSum, ULONG *pcjData)
{
    FNTHLINK   *pFntHlink;
    PBYTE       pCache = NULL;

    *pcjData = 0;
    pFntHlink = NULL;

    if (ghsemFntCache == NULL)
       return (PVOID) pCache;

    SEMOBJ  so(ghsemFntCache);

    if (gflFntCacheState & FNT_CACHE_LOOKUP_MODE)
    {
        if (gFntCache->pTable)
        {

        // Search the cache table

            SearchFNTCacheHlink( FastCheckSum, &pFntHlink, gFntCache->pTable);

            if(pFntHlink && !(pFntHlink->flLink & FNT_CACHE_CHECKSUM_CONFLICT))
            {

                *pcjData = pFntHlink->cjData;

                if (*pcjData)
                {
                    pCache = gFntCache->pCacheBufStart + pFntHlink->dpData;

                }
            }
            #if DBG
            else
            {
                if (pFntHlink && (pFntHlink->flLink & FNT_CACHE_CHECKSUM_CONFLICT))
                    WARNING("Catch the checksum conflict in EngFntCacheLookUp \n");
            }
            #endif
        }

    }

    return (PVOID) pCache;
}


/*****************************************************************************
 * VOID  InitNewCacheTable()
 *
 * Initialize font cache, open the fntcache,dat file and create hash table
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL  bInitCacheTable(ULONG ulTTFonts, ULONG ulT1Fonts, LARGE_INTEGER FntRegLWT, LARGE_INTEGER T1RegLWT, 
                       LARGE_INTEGER Win32kLWT, LARGE_INTEGER AtmfdLWT, ULONG CodePage)
{
    ULONG   ulSize, ulIfiSize;
    BOOL bOk = FALSE;
    ULONG   ulMaxFonts;
    FILEVIEW        FileView;

    ulMaxFonts = ulTTFonts + ulT1Fonts + RESERVE_LINKS;

    ulSize = SZ_FNTCACHE(ulMaxFonts) + SZ_FNTIFICACHE(ulTTFonts, ulT1Fonts);

    if (gFntCache->pTable)
    {
       vUnmapFontCacheFile();
    }

    RtlZeroMemory(&FileView, sizeof(FILEVIEW));

    if(bMapFile(FNTCACHEPATH, &FileView, ulSize, NULL))
    {
        gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
        gFntCache->pSection = FileView.pSection;

        RtlFillMemory((PBYTE) gFntCache->pTable->aiBuckets,
                    FNTCACHE_MAX_BUCKETS * sizeof(DWORD), 0xFF);
        RtlZeroMemory((PBYTE) gFntCache->pTable->ahlnk,
                    ulMaxFonts * sizeof(FNTHLINK));

        gFntCache->pTable->ulCodePage = (ULONG) CodePage;
        gFntCache->pTable->ulMaxFonts = ulMaxFonts;
        gFntCache->pTable->ulTotalLinks = 0;
        gFntCache->pTable->CheckSum = 0;
        gFntCache->pTable->FntRegLWT.QuadPart = FntRegLWT.QuadPart;
        gFntCache->pTable->T1RegLWT.QuadPart = T1RegLWT.QuadPart;
        gFntCache->pTable->Win32kLWT.QuadPart = Win32kLWT.QuadPart;
        gFntCache->pTable->AtmfdLWT.QuadPart = AtmfdLWT.QuadPart;
        
        gFntCache->pTable->ulFileSize = ulSize;
        gFntCache->pTable->cjDataAll = SZ_FNTIFICACHE(ulTTFonts, ulT1Fonts);
        gFntCache->pTable->cjDataExtra = 0;
        gFntCache->pTable->cjDataUsed = 0;

        bOk = TRUE;
    }

    return bOk;
}

/*****************************************************************************
 * VOID  InitFNTCache()
 *
 * Initialize font cache, open the fntcache,dat file and create hash table
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID  InitFNTCache()
{

    LARGE_INTEGER           FntRegLWT = { 0, 0};
    LARGE_INTEGER           T1RegLWT = { 0, 0};
    LARGE_INTEGER           Win32kLWT = { 0, 0};
    LARGE_INTEGER           AtmfdLWT = { 0, 0};

    ULONG                   ulTTFonts = 0;
    ULONG                   ulT1Fonts;
    ULONG                   ulSize = 0;
    BOOL                    bQryFntReg = FALSE;
    USHORT                  AnsiCodePage, OemCodePage;
    BOOL                    bLocked = TRUE;

// Initialize all the global variables

    gflFntCacheState = 0;

    ghsemFntCache = GreCreateSemaphore();

    if (ghsemFntCache == NULL)
    {
        goto CleanUp;
    }
    
// Only for performance evaluation.
    if (bFntCacheDisabled())
    {
        goto CleanUp;
    }

// Initialize and zero out all the memory
    gFntCache = (FNTCACHE *) PALLOCMEM(sizeof(FNTCACHE), 'CFTT');

// There is something wrong we can not allocate buf
    if (!gFntCache)
    {
        goto CleanUp;
    }
    
    if (G_fConsole)
        bLocked = bSetFntCacheReg(DISABLE_REMOTE_FONT_BOOT_CACHE, 1);

// If we can not lock the font cache file, 
// then we can not open it in console 

    if (!bLocked)
    {
        goto CleanUp;
    }

    gFntCache->pTable = NULL;
    gFntCache->ulCurrentHlink = 0;
    gFntCache->hDev[0] = 0;
    gFntCache->hDev[1] = 0;
    gFntCache->hDev[2] = 0;
    gFntCache->hDev[3] = 0;
    gFntCache->hDev[4] = 0;
    gFntCache->bWrite = FALSE;

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

 // Get the last boot time status

    vGetLastBootTimeStatus();

// Get LWT of font driver

    vGetFontDriverLWT(&Win32kLWT, &AtmfdLWT);

// now open the TT Fonts key :

    if (QueryFontReg(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts",
                            &FntRegLWT, &ulTTFonts))
    {
        ulTTFonts += FNTCACHE_EXTRA_LINKS;

    // now open the Type 1 Fonts key :
        if (QueryFontReg(L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts",
                            &T1RegLWT, &ulT1Fonts))
        {
            bQryFntReg = TRUE;
        }
    }

    {
        FILEVIEW FileView;

        RtlZeroMemory(&FileView, sizeof(FILEVIEW));

        if (bMapFile(FNTCACHEPATH, &FileView, 0, NULL))
        {
            gFntCache->pTable = (FNTCACHEHEADER *) FileView.pvKView;
            gFntCache->pSection = (FNTCACHEHEADER *) FileView.pSection;
        }

        if (gFntCache->pTable)
        {
            ULONG   ulCheckSum;
            BOOL    bCacheRead;
            BOOL    bCheckSum;

            bCacheRead = FALSE;
            bCheckSum = FALSE;

            // File did not change from last time boot.

            if (gFntCache->pTable->CheckSum && FileView.cjView == gFntCache->pTable->ulFileSize &&
                gFntCache->pTable->CheckSum == FNTCacheFileCheckSum(gFntCache->pTable, FileView.cjView) &&
                gFntCache->pTable->AtmfdLWT.QuadPart == AtmfdLWT.QuadPart && // current signature of atmfd
                gFntCache->pTable->ulCodePage == AnsiCodePage &&  // If locale changed, we need to re-create the cache
                !(gFntCache->flPrevBoot & FNT_CACHE_STATE_ERROR) && // No error at last boot time
                (!G_fConsole ||   // for remote session would not care about the registry update
                    (!(gFntCache->flPrevBoot & FNT_CACHE_STATE_FULL) &&
                     gFntCache->pTable->Win32kLWT.QuadPart == Win32kLWT.QuadPart && // check signature of win32k.sys
                     FntRegLWT.QuadPart == gFntCache->pTable->FntRegLWT.QuadPart &&  // Check date time of cache file
                     T1RegLWT.QuadPart == gFntCache->pTable->T1RegLWT.QuadPart
                    )
                )
            )
            {
                gflFntCacheState = FNT_CACHE_LOOKUP_MODE;
            }
            else
            {
                if(G_fConsole && bInitCacheTable(ulTTFonts, ulT1Fonts, FntRegLWT, T1RegLWT, Win32kLWT, AtmfdLWT, (ULONG) AnsiCodePage))
                {

                    // If something will not match, then it means we need to create FNTCACHE again

                        gflFntCacheState = FNT_CACHE_CREATE_MODE;
                }
                else
                {
                    if (G_fConsole)
                    {
                        WARNING(" Boot time Font Cache failed\n");
                        WARNING(" The pTable is corrupted and font registry is failed to open\n");
                    }                        
                }
           }
        }
        else
        {
        // If there is no FNTCACHE.DAT file
        // Then we need to create it.
            if(G_fConsole && bInitCacheTable(ulTTFonts, ulT1Fonts, FntRegLWT, T1RegLWT, Win32kLWT, AtmfdLWT, (ULONG) AnsiCodePage))
            {
                gflFntCacheState = FNT_CACHE_CREATE_MODE;

            }
            else
            {
                if (G_fConsole)
                {
                    WARNING("Boot time Font Cache failed\n");
                    WARNING(" If you read this message, please contact YungT or NTFONTS\n");
                    WARNING(" You can continue without any harm, just hit g\n");
                }
            }
        }

    }

CleanUp:

// Semaphore initialized

    if (gflFntCacheState & FNT_CACHE_MASK)
    {

        ASSERTGDI(gFntCache->pTable, "Fnt Cache pTable did not open \n");

    // Initialize the start pointer of current Cache table

        gFntCache->pCacheBufStart = (PBYTE) gFntCache->pTable +
                             SZ_FNTCACHE(gFntCache->pTable->ulMaxFonts);
        gFntCache->pCacheBuf = gFntCache->pCacheBufStart + gFntCache->pTable->cjDataUsed;
        gFntCache->pCacheBufEnd = gFntCache->pCacheBufStart + gFntCache->pTable->cjDataAll +
                                  gFntCache->pTable->cjDataExtra;

        gFntCache->ulCurrentHlink = gFntCache->pTable->ulTotalLinks;

        if (gflFntCacheState & FNT_CACHE_LOOKUP_MODE)
        {
        // Unlock the the font cache file to make other session to use it
            bSetFntCacheReg(DISABLE_REMOTE_FONT_BOOT_CACHE, 0);
        }
        else // FNT_CACHE_CREATE_MODE
        {
            gFntCache->flThisBoot = 0;
        }
    }
    else
    {
        gflFntCacheState = 0;

    // Clean up the memory
        if (gFntCache)
        {
            if (gFntCache->pTable)
            {
                vUnmapFontCacheFile();
            }

            VFREEMEM((PVOID) gFntCache);
            gFntCache = NULL;
        }

        if (ghsemFntCache)
        {
            GreDeleteSemaphore(ghsemFntCache);
            ghsemFntCache = NULL;
        }

    }

    FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_1, ("FNT Cache Create mode %d\n", gflFntCacheState));
}


/*****************************************************************************
 * ULONG ComupteFNTCacheFastCheckSum(ULONG cwc, PWSZ pwsz)
 *
 * Helper function to compute fast checksum
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

ULONG ComupteFNTCacheFastCheckSum(ULONG cwc, PWSZ pwsz, PFONTFILEVIEW *ppfv,ULONG cFiles, DESIGNVECTOR *pdv, ULONG cjDV)
{
    ULONG   i;
    ULONG   checksum = 0;
    USHORT  *pusCode;

    for ( i = 0; i < cFiles; i++)
    {
        checksum += (checksum * 256 + ppfv[i]->fv.cjView);
        checksum += (checksum * 256 + (ULONG) ppfv[i]->fv.LastWriteTime.LowPart);
        checksum += (checksum * 256 + (ULONG) ppfv[i]->fv.LastWriteTime.HighPart);
    }

    pusCode = (USHORT *) pwsz;

    for ( i = 0; i < cwc; i++, pusCode++)
    {
    // SUM offset by 1 bit, it will make FastCheckSum unique

        checksum += (checksum * 256 + (ULONG) *pusCode);
    }

    if (pdv && cjDV)
    {
        PULONG pulCur, pulEnd;

        pulCur = (PULONG) pdv;

        for (pulEnd = pulCur + cjDV / sizeof(ULONG); pulCur < pulEnd; pulCur ++)
        {
            checksum += 256 * checksum + *pulCur;
        }
    }

    return checksum;
}


/*****************************************************************************
 * ULONG   LookUpFNTCacheTable(ULONG cwc, PWSZ pwszPathname, PULONG pulFastCheckSum)
 *
 * Lookup hash table if UFI exist then we return it, otherwise return 0
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

ULONG   LookUpFNTCacheTable(ULONG cwc, PWSZ pwszPathname, PULONG pulFastCheckSum, PFONTFILEVIEW *ppfv, ULONG cFiles, PPDEV  * pppDevCache,
                                DESIGNVECTOR *pdv, ULONG cjDV)
{
    ULONG       ulUFI = 0;
    ULONG       ulBucket = 0;
    FNTHLINK    *pFntHlink;


    *pulFastCheckSum = 0;
    *pppDevCache = NULL;

    if (ghsemFntCache == NULL)
        return ulUFI;

    SEMOBJ          so(ghsemFntCache);

    if(cwc != 0)
    {
        *pulFastCheckSum = ComupteFNTCacheFastCheckSum ( cwc, pwszPathname, ppfv, cFiles, pdv, cjDV);

        // If in CREATE mode, then nothing is in the cache

        if (gflFntCacheState & FNT_CACHE_LOOKUP_MODE)
        {
            pFntHlink = NULL;

            SearchFNTCacheHlink( *pulFastCheckSum, &pFntHlink, gFntCache->pTable);

            if(pFntHlink && !(pFntHlink->flLink & FNT_CACHE_CHECKSUM_CONFLICT))
            {
                ASSERTGDI( pFntHlink->ulFastCheckSum == *pulFastCheckSum, "ulFastCheckSum != pFntHlink->ulFastCheckSum \n");
                ulUFI = pFntHlink->ulUFI;
                *pppDevCache = gFntCache->hDev[pFntHlink->ulDrvMode];
            }
        }
    }

    return ulUFI;
}

/*****************************************************************************
 * VOID SearchFNTCacheHlink(ULONG ulFastCheckSum, FNTHLINK **ppFntHlink)
 *
 * Hash table search function
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID SearchFNTCacheHlink(ULONG ulFastCheckSum, FNTHLINK **ppFntHlink, FNTCACHEHEADER *pTable)
{
// If there is a Cache, then ppFntHlink will not be NULL

    FNTHLINK    *pFntHlink;

    *ppFntHlink = NULL;

    ULONG   ulHashBucket;

    DWORD   iNext;

// Calculate the hash buckets

    ulHashBucket = ulFastCheckSum % FNTCACHE_MAX_BUCKETS;

// Start from the first Offset.

    iNext = pTable->aiBuckets[ulHashBucket];

    while (iNext != FNTINDEX_INVALID)
    {
        pFntHlink = &pTable->ahlnk[iNext];

        if (ulFastCheckSum == pFntHlink->ulFastCheckSum)
        {
            *ppFntHlink = pFntHlink;
            break;
        }

        iNext = pFntHlink->iNext;
    }

    return;
}

FNTHLINK * SearchFntCacheNewLink(ULONG ulFastCheckSum)
{
    FNTHLINK        *pFntHlink = NULL;

// Search the new Link from pNewTable
    SearchFNTCacheHlink(ulFastCheckSum, &pFntHlink, gFntCache->pTable);

// new Link dose not exist, we got to create it from pNewTable
    if (!pFntHlink)
    {
        if (gFntCache->ulCurrentHlink < gFntCache->pTable->ulMaxFonts && bFntCacheCreateHLink(ulFastCheckSum))
        {
            pFntHlink = &gFntCache->pTable->ahlnk[gFntCache->ulCurrentHlink];
            pFntHlink->ulFastCheckSum = ulFastCheckSum;
            pFntHlink->ulUFI = 0;
            pFntHlink->iNext = FNTINDEX_INVALID;
            pFntHlink->cjData = 0;
            pFntHlink->dpData = 0;
            pFntHlink->flLink = 0;

            pFntHlink->ulDrvMode = FNT_DUMMY_DRV;
            gFntCache->ulCurrentHlink++;
        }
        else
        {
            gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
        }
    }

    return pFntHlink;
}

/*****************************************************************************
 * VOID PutFNTCacheCheckSum(ULONG ulFastCheckSum,ULONG ulUFI)
 *
 * Hash table write mode, the UFI does not have in hash and then we put it in.
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

VOID    PutFNTCacheCheckSum(ULONG ulFastCheckSum,ULONG ulUFI)
{
    FNTHLINK        *pFntHlink;
    
    if (ghsemFntCache == NULL)
        return;

    SEMOBJ          so(ghsemFntCache);

    if (gflFntCacheState & FNT_CACHE_CREATE_MODE)
    {

        pFntHlink = NULL;

        if (pFntHlink = SearchFntCacheNewLink(ulFastCheckSum))
        {
            // If fast check sum is conflict, we can not cache it.
            if(pFntHlink->ulUFI == 0)
            {
               pFntHlink->ulUFI = ulUFI;
            }
            else
            {
                WARNING("Checksum conflict in  PutFNTCacheCheckSum");
                pFntHlink->flLink |= FNT_CACHE_CHECKSUM_CONFLICT;
            }

            gFntCache->bWrite = TRUE;

        }
        else
        {
            WARNING("FNTCACHE is not big enough \n");
            FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_1, ("Put Trace: buckets %d, FastCheckSum %x,Check Sum %x \n", 
                                                    gFntCache->ulCurrentHlink, ulFastCheckSum, ulUFI));
        }
    }
    else
    {
        ASSERTGDI(gflFntCacheState & FNT_CACHE_LOOKUP_MODE, "PutFNTCacheCheckSum: gflFntCacheState\n");
    // During read mode, it still wants to write into fntcache.dat
    // Then we will rebuild it at next boot time.
        gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
    }

}

/*****************************************************************************
 * void FntCacheCreateHLink
 *
 * Build hash link in hash table
 *
 * History
 *  4-3-98 Yung-Jen Tony Tsai [YungT]
 * Wrote it.
 *****************************************************************************/

BOOL bFntCacheCreateHLink(ULONG ulFastCheckSum)
{
    ULONG       ulHashBucket;
    FNTHLINK    *pCurHlink;
    DWORD       iNextLink;

    ulHashBucket = ulFastCheckSum % FNTCACHE_MAX_BUCKETS;

    iNextLink = gFntCache->pTable->aiBuckets[ulHashBucket];

    if (iNextLink != FNTINDEX_INVALID)
    {
        if (iNextLink > gFntCache->pTable->ulMaxFonts)
            return FALSE;

        pCurHlink = &gFntCache->pTable->ahlnk[iNextLink];

    // We put the new link at the end so that the search time is faster

        while (pCurHlink->iNext != FNTINDEX_INVALID)
        {
            if (pCurHlink->iNext > gFntCache->pTable->ulMaxFonts)
            {
                gFntCache->flThisBoot |= FNT_CACHE_STATE_FULL;
                return FALSE;
            }

            pCurHlink = &gFntCache->pTable->ahlnk[pCurHlink->iNext];

            FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_0, ("Current iNextLink %x\n", pCurHlink->iNext));
        }

        pCurHlink->iNext = gFntCache->ulCurrentHlink;

    }
    else
    {
    // put it at the head of the linked list

        gFntCache->pTable->aiBuckets[ulHashBucket] = gFntCache->ulCurrentHlink;

        FNT_KdBreakPoint(FNTCACHE_DBG_LEVEL_0, ("Put on HashBuckets %x\n", ulHashBucket));
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\flinkgdi.cxx ===
/*****************************************************************************
* Module Name: fontlink.cxx
*
* FontLink (EUDC) API's for NT graphics engine.
*
* History:
*
*  1-18-96 Gerrit van Wingerden   Moved to kernel mode.
*  1-14-96 Hideyuki Nagase        Add Font Association emulation features.
*  1-09-95 Hideyuki Nagase        Rewrote it for new fontlink features.
*  1-04-94 Hideyuki Nagase        Update for Daytona fontlink.
*  2-10-93 Gerrit van Wingerden   Wrote it.
*
* Copyright (c) 1993-1999 Microsoft Corporation
*****************************************************************************/

#include "precomp.hxx"

#ifdef FE_SB

LONG lNormAngle(LONG lAngle);
VOID vInitializeFontAssocStatus(VOID);

#define EUDC_USER_REGISTRY_KEY   \
     L"\\EUDC\\"
#define EUDC_SYSTEM_REGISTRY_KEY \
     L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink"
#define FONT_ASSOC_REGISTRY_KEY \
     L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FontAssoc"

#define DEFAULT_EUDC_FONT L"EUDC.TTE"

extern PFONT_ASSOC_SUB pFontAssocSubs;


HSEMAPHORE ghsemEUDC1;
HSEMAPHORE ghsemEUDC2;

// used to signal the EUDC API's that it is okay to change EUDC link data

// used to protects gappfeSysEUDC[] and gawcEUDCPath
//  - This mutex should be locked during referring above two values without
//   holding ghsemEUDC1. and updating above two data anytime.


// used to protects BaseFontListHead
//  - This mutex should be locked during referring above list without
//   holding ghsemEUDC1. and updating above list anytime.

LONG  gcEUDCCount   = 0;
BOOL  gbAnyLinkedFonts = FALSE;

// Global variables for System EUDC.


// FontLink Configuration value.

ULONG ulFontLinkControl = 0L;
static ULONG ulFontLinkChange  = 0L;


// HPFE for system EUDC font.

PFE *gappfeSysEUDC[2] = { PPFENULL , PPFENULL };

// Path of system EUDC font

static WCHAR gawcEUDCPath[MAX_PATH+1];

// QUICKLOOKUP for system EUDC font && TT System Font

QUICKLOOKUP gqlEUDC;
QUICKLOOKUP gqlTTSystem;

// System eudc uniq number

static ULONG ulSystemEUDCTimeStamp = 0;

// FaceName eudc uniq number

static ULONG ulFaceNameEUDCTimeStamp = 0;

// Global variables for FaceName EUDC.

// Count of face name links in the system
static UINT  gcNumLinks = 0;

// Pointer to list of base font list

static LIST_ENTRY BaseFontListHead = { (PLIST_ENTRY)&BaseFontListHead ,
                                (PLIST_ENTRY)&BaseFontListHead };

LIST_ENTRY NullListHead = { (PLIST_ENTRY)&NullListHead ,
                            (PLIST_ENTRY)&NullListHead };

static WCHAR gawcSystemACP[10];

// Eudc Default Unicode codepoint

WCHAR EudcDefaultChar = 0x30fb;

RTL_QUERY_REGISTRY_TABLE SharedQueryTable[2];

extern BOOL bSetupDefaultFlEntry(VOID);
extern WCHAR gawcSystemDBCSFontPath[MAX_PATH];

//
// global EUDC debugging flags
//
#if DBG
FLONG gflEUDCDebug = 0x0000;
FLONG gflDumpDebug = 0x0000;
#endif


/*****************************************************************************
 * IsRegNameEqual (HANDLE hKey, HANDLE hKeyLink, BOOL *bIsEqual)
 *
 * Given two handles to registry keys,
 * return TRUE in bIsEqual if and only if the names of the paths are the same
 * (i.e., if the handles were created using ZwOpenKey (once without OBJ_OPENLINK
 * and once with), then the key is actually a symbolic link if this routine
 * returns FALSE in bIsEqual).
 *
 * If an error occurs (e.g., ZwQueryKey fails), this function returns the NTSTATUS.
 * If a memory allocation fails within this routine, this function returns 0.
 *
 * History:
 * 6-10-99  Donald Chinn
 *   Wrote it.
 *****************************************************************************/
static
NTSTATUS IsRegNameEqual (HANDLE hKey,
                         HANDLE hKeyLink,
                         BOOL *bIsEqual)

{
    NTSTATUS rv;
    PKEY_NAME_INFORMATION Buffer = NULL;
    PKEY_NAME_INFORMATION BufferLink = NULL;
    ULONG BufferSize, BufferLinkSize;

    *bIsEqual = FALSE;

    // get the size of the return buffers so that we can allocate memory for them
    ZwQueryKey (hKey, KeyNameInformation, NULL, 0, &BufferSize);
    ZwQueryKey (hKeyLink, KeyNameInformation, NULL, 0, &BufferLinkSize);

    // Add space for a null character for each buffer
    BufferSize += sizeof(WCHAR);
    BufferLinkSize += sizeof(WCHAR);
    // Round BufferSize up to the nearest multiple of sizeof(DWORD)
    BufferSize = ((BufferSize + sizeof(DWORD) - 1) / sizeof(DWORD)) * sizeof(DWORD);

    if ((Buffer = (PKEY_NAME_INFORMATION) PALLOCMEM (BufferSize + BufferLinkSize, 'flnk')) == NULL)
    {
        rv = 0;
        goto done;
    }
    BufferLink = (PKEY_NAME_INFORMATION) ((PBYTE) Buffer + BufferSize);

    if (!NT_SUCCESS(rv = ZwQueryKey (hKey, KeyNameInformation,
                                     Buffer, BufferSize, &BufferSize)))
    {
        goto done;
    }
    Buffer->Name[Buffer->NameLength / sizeof(WCHAR)] = L'\0';
    
    if (!NT_SUCCESS(rv = ZwQueryKey (hKeyLink, KeyNameInformation,
                                BufferLink, BufferLinkSize, &BufferLinkSize)))
    {
        goto done;
    }
    BufferLink->Name[BufferLink->NameLength / sizeof(WCHAR)] = L'\0';

    *bIsEqual = (wcscmp (Buffer->Name, BufferLink->Name) ? FALSE : TRUE);

done:
    if (Buffer)
        VFREEMEM (Buffer);

    return rv;    
}


/*****************************************************************************
 * BOOL bNotIsKeySymbolicLink (const WCHAR *RegistryPathBuffer,
 *                             HANDLE *phKey,
 *                             HANDLE *phKeyLink,
 *                             BOOL *pbIsEqual)
 *
 * Given an absolute path name in the registry,
 * return TRUE if the function completed successfully and
 * return FALSE otherwise.
 *
 * The function also returns two handles associated with the key
 * as parameters.  One is the handle returned from ZwOpenKey and
 * the other handle is the handle returned from ZwOpenKey when asked
 * to open it as a link.
 *
 * If the function succeeds, then pbIsEqual will contain TRUE
 * if the registry paths associated with the two handles are equal
 * (and FALSE otherwise).  pbIsEqual is TRUE exactly when the
 * registry key is not a symbolic link.
 *
 * History:
 * 6-10-99  Donald Chinn
 *   Wrote it.
 *****************************************************************************/
static
BOOL bNotIsKeySymbolicLink (const WCHAR *RegistryPathBuffer,
                            HANDLE *phKey,
                            HANDLE *phKeyLink,
                            BOOL *pbIsEqual)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING EUDCSubKey;
    BOOL bIsEqual = FALSE;

    *phKey = NULL;
    *phKeyLink = NULL;

    // set up the pathname
    RtlInitUnicodeString(&EUDCSubKey, RegistryPathBuffer);

    InitializeObjectAttributes (&ObjectAttributes, &EUDCSubKey,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL, NULL);
    if (!NT_SUCCESS(ZwOpenKey (phKey, KEY_ALL_ACCESS, &ObjectAttributes)))
        return FALSE;

    InitializeObjectAttributes (&ObjectAttributes, &EUDCSubKey,
                                OBJ_CASE_INSENSITIVE | OBJ_OPENLINK | OBJ_KERNEL_HANDLE,
                                NULL, NULL)
    if (!NT_SUCCESS(ZwOpenKey (phKeyLink, KEY_ALL_ACCESS, &ObjectAttributes)))
        return FALSE;

    // The key is a symbolic link exactly when the names of the keys are different
    if (!NT_SUCCESS(IsRegNameEqual (*phKey, *phKeyLink, pbIsEqual)))
    {
        return FALSE;
    }

    return TRUE;
}


/*****************************************************************************
 * VOID CleanUpEUDC()
 *
 * This function clean up EUDC when HYDRA shout down
 *
 * History
 *  8-26-98 Yung-Jen Tony Tsai
 * Wrote it.
 *****************************************************************************/

VOID CleanUpEUDC()
{
    // disable/unload system wide/facename eudc for current user.
    // clean up eudc links
    // on Hydra system, when the user/client goes away so does the gre
    // but the flag ulFontLinkChange is only set for FLINK_UNLOAD_FACENAME_USER
    // at this point. We need to set bit FLINK_UNLOAD_FACENAME_SYSTEM.

    SEMOBJ so(ghsemPublicPFT);

    PUBLIC_PFTOBJ pfto;  // access the public font table

    ulFontLinkChange |= FLINK_UNLOAD_FACENAME_SYSTEM;
    GreEnableEUDC(FALSE);

    if (gqlEUDC.puiBits)
    {
        VFREEMEM(gqlEUDC.puiBits);
        gqlEUDC.puiBits = NULL;
    }

    if (gqlTTSystem.puiBits)
    {

        VFREEMEM(gqlTTSystem.puiBits);
        gqlTTSystem.puiBits = NULL;

    }

    // Release Font Associate allocated memory
    if (bFinallyInitializeFontAssocDefault)
    {
        ULONG   iIndex;

        for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
        {
            if( (FontAssocDefaultTable[iIndex].ValidRegData) &&
                (FontAssocDefaultTable[iIndex].DefaultFontPathName[0] != L'\0') &&
                (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] != PPFENULL) )
            {
                QUICKLOOKUP * pql;

                {
                    PFEOBJ pfeo( FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] );

                    pql = pfeo.pql();
                    if (pql->puiBits)
                    {
                        VFREEMEM(pql->puiBits);
                        pql->puiBits = NULL;
                    }

                    FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] = PPFENULL;
                }
                    
                if (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] != PPFENULL)
                {
                    PFEOBJ pfeov(FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL]);

                    pql = pfeov.pql();
                    if (pql->puiBits)
                    {
                        VFREEMEM(pql->puiBits);
                        pql->puiBits = NULL;
                    }

                    FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] = PPFENULL;
                }

            }
        }

        for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
        {
            if( (FontAssocDefaultTable[iIndex].ValidRegData) &&
                (FontAssocDefaultTable[iIndex].DefaultFontPathName[0] != L'\0'))
            {
                pfto.bUnloadEUDCFont(FontAssocDefaultTable[iIndex].DefaultFontPathName);
                FontAssocDefaultTable[iIndex].DefaultFontPathName[0] = L'\0';
            }            
        }
    }

    if (pFontAssocSubs)
    {
        VFREEMEM( pFontAssocSubs );
        pFontAssocSubs = NULL;
    }
    
    if (gbSystemDBCSFontEnabled)
       pfto.bUnloadEUDCFont(gawcSystemDBCSFontPath);

}

/*****************************************************************************
 * VOID PFFOBJ::vGetEUDC(PEUDCLOAD)
 *
 * This function finds requested facename PFEs
 *
 * History
 *  4-14-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

VOID PFFOBJ::vGetEUDC
(
    PEUDCLOAD pEudcLoadData
)
{
    ASSERTGDI(pEudcLoadData != NULL,"PFFOBJ::vGetEUDC() pEudcLoadData == NULL\n");

    //
    // Initialize return buffer with NULL.
    //

    pEudcLoadData->pppfeData[PFE_NORMAL]   = NULL;
    pEudcLoadData->pppfeData[PFE_VERTICAL] = NULL;

    if( pEudcLoadData->LinkedFace == NULL )
    {
        //
        // Linked face name is not specified. In this case if the font has 2 PFEs
        // we assume first entry is for Normal face, and 2nd is Verical face.
        //
        //
        // Fill it with normal face PFE.
        //
        pEudcLoadData->pppfeData[PFE_NORMAL] = ppfe(PFE_NORMAL);

        //
        // if this font has 2 PFEs, get 2nd PFE for vertical face. otherwise
        // use same PFE as normal face for Vertical face.
        //
        if( cFonts() == 2 )
            pEudcLoadData->pppfeData[PFE_VERTICAL] = ppfe(PFE_VERTICAL);
         else
            pEudcLoadData->pppfeData[PFE_VERTICAL] = ppfe(PFE_NORMAL);
    }
     else
    {
        //
        // Linked face name is specified, try to find out its PFE.
        //

        COUNT cFont;

        for( cFont = 0; cFont < cFonts(); cFont++ )
        {
            PFEOBJ pfeo(ppfe(cFont));
            PWSTR  pwszEudcFace = pfeo.pwszFamilyName();
            ULONG  iPfeOffset   = PFE_NORMAL;

            //
            // Is this a vertical face ?
            //
            if( pwszEudcFace[0] == (WCHAR) L'@' )
            {
                iPfeOffset = PFE_VERTICAL;
            }

            //
            // Is this a face that we want ?
            //
            if(pfeo.bCheckFamilyName(pEudcLoadData->LinkedFace,1))
            {
                //
                // Yes....., keep it.
                //
                pEudcLoadData->pppfeData[iPfeOffset] = pfeo.ppfeGet();

                //
                // if this is a PFE for Normal face, also keep it for Vertical face.
                // after this, this value might be over-written by CORRRCT vertical
                // face's PFE.
                //
                // NOTE :
                //  This code assume Normal face come faster than Vertical face...
                //
                if( iPfeOffset == PFE_NORMAL )
                {
                    pEudcLoadData->pppfeData[PFE_VERTICAL] = pfeo.ppfeGet();
                }
            }
        }
    }
}

/*****************************************************************************
 * BOOL bValidFontLinkParameter(PWSTR,PWSTR *)
 *
 * This function make sure the linked font parameter is valid or not.
 *
 * History
 *  3-29-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

static
BOOL bValidFontLinkParameter
(
    PWSTR  LinkedFontName,
    PWSTR *LinkedFaceName
)
{
    PWSTR  lp = LinkedFontName;
    BOOL   bFound = FALSE;

    *LinkedFaceName = NULL;

    while( *lp )
    {
        if( *lp == L',' )
        {
            if(bFound)
            {
                *LinkedFaceName = NULL;
                return(FALSE);
            }
            else
            {
                *LinkedFaceName = lp + 1;
                *lp = (WCHAR)NULL;
                bFound = TRUE;
            }
        }
        lp++;
    }

   return(TRUE);
}

/******************************************************************************
 * BOOL bComputeQuickLookup( QUICKLOOKUP *pql, FD_GLYPHSET *pfdg, BOOL bSystemEUDC )
 *
 * This routine computes a quick lookup structure from an FD_GLYPHSET structure.
 *
 * History:
 *  7-7-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

#define uiMask2(X) (0xFFFFFFFF << (31-(X)))
#define uiMask1(X) (0xFFFFFFFF >> (X))

BOOL bComputeQuickLookup( QUICKLOOKUP *pql, PFE * pPFE, BOOL bSystemEUDC )
{
    WCRUN *pwcrun;
    WCHAR wcHigh = 0x0000;
    WCHAR wcLow = 0xFFFF;
    UINT ui;

// if this is not SystemEUDC and puiBits has pointer, the Lookup table
// was already initialized.

    PFEOBJ pfeObj(pPFE);
    if (!pfeObj.bValid())
        return FALSE;

    if (pql == NULL)
        pql = pfeObj.pql();

    if ( !bSystemEUDC && pql->puiBits )
        return (TRUE);

    PFD_GLYPHSET    pfdg;

    if(!(pfdg = pfeObj.pfdg()))
        return FALSE;

    pwcrun = pfdg->awcrun;

// first figure out the high and low glyphs for this font

    for( ui = 0; ui < pfdg->cRuns; ui++ )
    {
        if( wcLow > pwcrun[ui].wcLow )
        {
            wcLow = pwcrun[ui].wcLow;
        }

        if( wcHigh < pwcrun[ui].wcLow + pwcrun[ui].cGlyphs )
        {
            wcHigh = ( pwcrun[ui].wcLow + pwcrun[ui].cGlyphs - 1 );
        }
    }

    (*pql).wcLow = wcLow;
    (*pql).wcHigh = wcHigh;

// Now we need to allocate puiBits.  In the case of the system EUDC font will
// do this only once even though the glyph set can change dynamically.  This
// means we will always allocate 0xFFFF bits.  If *pql.puiBits != NULL then
// we assume the glyphset has been allocated before and leave it alone

    if( bSystemEUDC )
    {
    // see if already allocated before and if so don't allocate it again
    // we determine this by checking if *pql.auiBits is NULL or not
    // 8k * 8 = 64k, 64k glyphs
    // 8k == 8192
        if( (*pql).puiBits == NULL )
        {
            (*pql).puiBits = (UINT*)PALLOCMEM( 8192, 'flnk' );

        }
        else
        {
            RtlZeroMemory( (*pql).puiBits, 8192);
        }

        wcLow = 0;
    }
    else
    {
        (*pql).puiBits = (UINT*)PALLOCMEM((((wcHigh - wcLow + 1) + 31) / 32) * 4,'flnk');
    }

    if((*pql).puiBits == (UINT*) NULL)
    {
        WARNING("bComputeQuickLookup out of memory.\n");
        pfeObj.vFreepfdg();
        return(FALSE);
    }

    for( ui = 0; ui < pfdg->cRuns ; ui++ )
    {
        UINT uiFirst = ( pwcrun[ui].wcLow - wcLow ) / 32 ;
        UINT uiLast =  ( pwcrun[ui].wcLow - wcLow + pwcrun[ui].cGlyphs - 1 ) / 32;

        if( uiFirst == uiLast)
        {

            (*pql).puiBits[uiFirst] |= uiMask2(pwcrun[ui].cGlyphs-1) >>
                                    ( ( pwcrun[ui].wcLow - wcLow ) % 32 );
        }
        else
        {
            (*pql).puiBits[uiFirst] |= uiMask1((pwcrun[ui].wcLow - wcLow)%32);

            for( UINT uiRun = uiFirst+1; uiRun < uiLast; uiRun++ )
            {
                (*pql).puiBits[uiRun] = 0xFFFFFFFF;
            }

            (*pql).puiBits[uiLast] |=
                uiMask2((pwcrun[ui].wcLow - wcLow + pwcrun[ui].cGlyphs-1)%32);
        }
    }

    pfeObj.vFreepfdg();

    return(TRUE);
}

/******************************************************************************
 * BOOL bAppendSysDirectory( WCHAR *pwcTarget, const WCHAR *pwcSource, UINT cchBufferSize )
 *
 * Given a file name in pwcSource, this function appends it to the
 * appropirate directory and returns it into the buffer pointed to
 * by pwcTarget.  If the file already has a path it just copies
 * pwcSource to pwcTarget.
 *
 * History:
 *  8-30-93 Hideyuki Nagase [hideyukn]
 * Add code for searching path
 *
 *  3-23-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

BOOL bAppendSysDirectory( WCHAR *pwcTarget, const WCHAR *pwcSource, UINT cchBufferSize )
{
    WCHAR pwcTemp[MAX_PATH];

// Check it is file name only or full path name

    if( wcschr(pwcSource,L'\\') != NULL )
    {
        WCHAR *pSystemRoot;

    // full path.
    //
    // Catitalize path name.
    // cCapString guarantees NULL termination of destination string
        cCapString(pwcTarget,pwcSource,cchBufferSize);

    // The path contains %SYSTEMROOT% ?

        if( (pSystemRoot = wcsstr(pwcTarget,L"%SYSTEMROOT%")) != NULL )
        {
        // Yes,
        //
        // Replace %SystemRoot%\FileName with \SystemRoot\FileName.
        //         012345678901

            pSystemRoot[0] = L'\\';
            wcscpy(&(pSystemRoot[11]),&(pSystemRoot[12]));
        }
        else
        {
        // if the file format is "C:\....", we appen "\??\" to make NtPath.
        //                        0123

        // [note]
        //
        // for formal way... we need call RtlDosPathNameToNtPathName_U().
        // the function could not be called from kernel mode....
        //
            if((pwcTarget[1] == L':') && (pwcTarget[2] == L'\\'))
            {
                // keep a back up to pwcTemp.
                // Put "\??\" first.
                // Put original path.
                //
                if (FAILED(StringCchCopyW(pwcTemp, MAX_PATH, pwcTarget)) ||
                    FAILED(StringCchCopyW(pwcTarget, cchBufferSize, L"\\??\\")) ||
                    FAILED(StringCchCatW(pwcTarget, cchBufferSize, pwcTemp)))
                {
                    WARNING("bAppendSysDirectory: target buffer too short.\n");
                    return FALSE;
                }
            }
            else
            {
                WARNING("bAppenSysDirectory():Need conversion (DosPath -> NtPath)\n");
            }
        }

        #if DBG
        DbgPrint("bAppenSysDirectory():Path --> %ws\n",pwcTarget);
        #endif
    }
    else
    {
    // assume it is in the "fonts" directory
    
        if (FAILED(StringCchCopyW(pwcTemp, MAX_PATH, L"\\??\\")) ||
            FAILED(StringCchCatW(pwcTemp, MAX_PATH, USER_SHARED_DATA->NtSystemRoot)) ||
            FAILED(StringCchCatW(pwcTemp, MAX_PATH, L"\\fonts\\")) ||
            FAILED(StringCchCatW(pwcTemp, MAX_PATH, pwcSource)))
        {
            WARNING("bAppendSysDirectory: target buffer too short.\n");
            return FALSE;
        }

        cCapString(pwcTarget,pwcTemp,cchBufferSize);
    }
    return TRUE;
}

/****************************************************************************
 * GetUserEUDCRegistryPath(LPWSTR,USHORT)
 *
 *  Get EUDC registry path for current loggedon user.
 *
 * History:
 *  9-Feb-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 ***************************************************************************/
static
NTSTATUS GetUserEUDCRegistryPath
(
    LPWSTR UserEUDCPathBuffer,
    USHORT UserEUDCPathLen
)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING UserEUDCPath;
    UNICODE_STRING UserRegistryPath;

    UserEUDCPath.Length = 0;
    UserEUDCPath.MaximumLength = UserEUDCPathLen;
    UserEUDCPath.Buffer = UserEUDCPathBuffer;

// Get path of CurrentUser key.


    if(NT_SUCCESS(RtlFormatCurrentUserKeyPath(&UserRegistryPath)))
    {
    // Build path for EUDC data

        status = RtlAppendUnicodeStringToString(&UserEUDCPath,&UserRegistryPath);
        if (NT_SUCCESS(status))
            status = RtlAppendUnicodeToString(&UserEUDCPath,EUDC_USER_REGISTRY_KEY);
        if (NT_SUCCESS(status))
            status = RtlAppendUnicodeToString(&UserEUDCPath,gawcSystemACP);

        RtlFreeUnicodeString(&UserRegistryPath);

    }
    else
    {
        WARNING("GetUserEUDCRegistryPath():RtlFormatCurrentUserKeyPath\n");

    // just retuen default path..

        status = RtlAppendUnicodeToString(&UserEUDCPath,L"\\Registry\\User\\.DEFAULT");
        if (NT_SUCCESS(status))
            status = RtlAppendUnicodeToString(&UserEUDCPath,EUDC_USER_REGISTRY_KEY);
        if (NT_SUCCESS(status))
            status = RtlAppendUnicodeToString(&UserEUDCPath,gawcSystemACP);
    }
    if (NT_SUCCESS(status))
    {
        // check if RtlAppendXXX didn't null-terminate the output string
        if (UserEUDCPath.Length == UserEUDCPath.MaximumLength)
        {
            WARNING("GetUserEUDCRegistryPath(): the output string is not null-terminated\n");
            status = STATUS_BUFFER_TOO_SMALL;
        }
    }
    return status;
}


/******************************************************************************
 * bWriteUserSystemEUDCRegistry(LPWSTR)
 *
 *  Write system wide eudc font file path for request user.
 *
 * History:
 *  9-Feb-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 *****************************************************************************/
static
BOOL bWriteUserSystemEUDCRegistry
(
    LPWSTR DataBuffer,
    USHORT DataLen
)
{
    WCHAR    RegistryPathBuffer[MAX_PATH];

    HANDLE hKey = NULL;
    HANDLE hKeyLink = NULL;
    BOOL bIsEqual = FALSE;

    // Get EUDC registry path for requested user

    NTSTATUS NtStatus = GetUserEUDCRegistryPath(RegistryPathBuffer,sizeof(RegistryPathBuffer));

    if (NT_SUCCESS(NtStatus))
    {
        // if the registry entry is a symbolic link, fail the call
        if (bNotIsKeySymbolicLink (RegistryPathBuffer, &hKey, &hKeyLink, &bIsEqual) &&
            bIsEqual)
        {
            // Write registry.
            NtStatus = RtlWriteRegistryValue( RTL_REGISTRY_ABSOLUTE,
                                            RegistryPathBuffer,
                                            L"SystemDefaultEUDCFont",
                                            REG_SZ,
                                            DataBuffer,
                                            DataLen * sizeof(WCHAR) );
        }
        else
        {
            NtStatus = (STATUS_SEVERITY_ERROR << 30);  // any non-zero error is sufficient
        }
    }

    if (hKey)
        ZwClose (hKey);
    if (hKeyLink)
        ZwClose (hKeyLink);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING("bWriteUserSystemEUDCRegistry():fail\n");
        return(FALSE);
    }

    return(TRUE);
}

/******************************************************************************
 * bReadUserSystemEUDCRegistry(LPWSTR,USHORT)
 *
 *  Read system wide eudc font file path for request user.
 *
 * History:
 *  9-Feb-1995 -by- Hideyuki Nagase [hideyukn]
 * Wrote it.
 *****************************************************************************/
static
BOOL bReadUserSystemEUDCRegistry
(
    LPWSTR FilePathBuffer,
    USHORT FilePathLen
)
{
    WCHAR          NoExpandFilePathBuffer[MAX_PATH];
    WCHAR          RegistryPathBuffer[MAX_PATH];
    UNICODE_STRING FilePath;

    HANDLE hKey = NULL;
    HANDLE hKeyLink = NULL;
    BOOL bIsEqual = FALSE;

    RegistryPathBuffer[0] = NoExpandFilePathBuffer[0] = 0;
    FilePath.Length = 0;
    FilePath.MaximumLength = sizeof(NoExpandFilePathBuffer);
    FilePath.Buffer = NoExpandFilePathBuffer;

// Get EUDC registry path for requested user

    NTSTATUS NtStatus = GetUserEUDCRegistryPath(RegistryPathBuffer,sizeof(RegistryPathBuffer));
    if (NT_SUCCESS(NtStatus))
    {
        // if the registry entry is a symbolic link, fail the call
        if (bNotIsKeySymbolicLink (RegistryPathBuffer, &hKey, &hKeyLink, &bIsEqual) &&
            bIsEqual)
        {
            SharedQueryTable[0].QueryRoutine = NULL;
            SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                        RTL_QUERY_REGISTRY_DIRECT;
            SharedQueryTable[0].Name = (PWSTR) L"SystemDefaultEUDCFont";
            SharedQueryTable[0].EntryContext = (PVOID) &FilePath;
            SharedQueryTable[0].DefaultType = REG_NONE;
            SharedQueryTable[0].DefaultData = NULL;
            SharedQueryTable[0].DefaultLength = 0;

            SharedQueryTable[1].QueryRoutine = NULL;
            SharedQueryTable[1].Flags = 0;
            SharedQueryTable[1].Name = NULL;

            // Read registry.

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                            RegistryPathBuffer,
                                            SharedQueryTable,
                                            NULL,
                                            NULL);
        }
        else
        {
            NtStatus = (STATUS_SEVERITY_ERROR << 30);  // any non-zero error is sufficient
        }
    }

    if (hKey)
        ZwClose (hKey);
    if (hKeyLink)
        ZwClose (hKeyLink);

    if(!NT_SUCCESS(NtStatus) || FilePath.Length == 0)
    {
        if(NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            WCHAR *LastBackslash = NULL;

            //
            // if the user does not have EUDC\ActiveCodePage\SystemDefaultEUDCFont
            // key\value, we create the key and set the default value here..
            //
            // Create key.

            LastBackslash = wcsrchr(RegistryPathBuffer,L'\\');

            if(LastBackslash != NULL && _wcsicmp(LastBackslash+1,gawcSystemACP) == 0)
            {
                // Create HKEY_CURRENT_USER\EUDC key.

                *LastBackslash = L'\0';
                RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,RegistryPathBuffer);

                // Create HKEY_CURRENT_USER\EUDC\ActiveCodePage key.

                *LastBackslash = L'\\';
                RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,RegistryPathBuffer);

                // Set value.

                if(bWriteUserSystemEUDCRegistry(DEFAULT_EUDC_FONT,
                                                wcslen(DEFAULT_EUDC_FONT)+1) )
                {
                    //
                    // Initialize FilePath with default.
                    //

                    RtlInitUnicodeString(&FilePath,DEFAULT_EUDC_FONT);
                }
                 else goto ErrorReturn;
            }
             else goto ErrorReturn;
        }
         else goto ErrorReturn;
    }
    else
    {
        if (FilePath.Length == FilePath.MaximumLength)
        {
            WARNING("bReadUserSystemEUDCRegistry(): SystemDefaultEUDCFont path too long.\n");
            goto ErrorReturn;
        }
    }

    wcsncpy(FilePathBuffer,FilePath.Buffer,FilePathLen);
    return(TRUE);

ErrorReturn:
    return(FALSE);
}

/*****************************************************************************
 * BOOL bKillEudcRFONTs( RFONT *prfntVictims )
 *
 * Given a linked list of EUDC RFONT this routine kills them all.
 *
 * History
 *  6-30-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/
static
BOOL bKillEudcRFONTs( RFONT *prfntVictims )
{
    PRFONT prfnt;

    while( (prfnt = prfntVictims ) != (PRFONT) NULL )
    {
        prfntVictims = prfntVictims->rflPDEV.prfntNext;

        {
            RFONTTMPOBJ rfloVictim(prfnt);

        // Need this so we can remove this from the PFF's RFONT list.

            PFFOBJ pffo(prfnt->pPFF);

            ASSERTGDI(pffo.bValid(), "gdisrv!vKillEudcRFONTs: bad HPFF");

        // We pass in NULL for ppdo because we've already removed it from the
        // PDEV list.

            if( !rfloVictim.bDeleteRFONT((PDEVOBJ *) NULL, &pffo))
            {
                WARNING("Unable vKillEudcRFONTs unable to delete RFONT.\n");
                return(FALSE);
            }
        }
    }

    return(TRUE);
}

/*****************************************************************************
 * RFONT *prfntDeactivateEudcRFONTs(PFE **)
 *
 * Tracks down all the EUDC RFONTS in the system removes them from the active
 * and deactive lists and puts them on a list for deletion which it then
 * returns to the caller.
 *
 * The public font table semaphore must be held by the caller for this to work.
 *
 * History
 *  23-01-95 Hideyuki Nagase
 * Rewrote it.
 *
 *   2-10-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/
static
VOID vDeactivateEudcRFONTsWorker
(
    PPFE  *appfe,
    PPFF  pPFF,
    RFONT **pprfntToBeKilled
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // Check if this font file is really loaded as EUDC font..

        if(pffo.bEUDC())
        {
            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

                if( ( prfnt->ppfe == appfe[PFE_NORMAL]   ) ||
                    ( prfnt->ppfe == appfe[PFE_VERTICAL] )   )
                {
                    FLINKMESSAGE2(DEBUG_FONTLINK_UNLOAD,
                                  "Removing EUDC font %x.\n", prfnt);

                    RFONTTMPOBJ rfo(prfnt);

                    PDEVOBJ pdo(prfnt->hdevConsumer);
                    PRFONT prf;

                // remove it from the active or inactive list

                    if( prfnt->cSelected != 0 )
                    {
                        prf = pdo.prfntActive();
                        rfo.vRemove(&prf, PDEV_LIST);
                        pdo.prfntActive(prf);
                    }
                    else
                    {
                        prf = pdo.prfntInactive();
                        rfo.vRemove(&prf, PDEV_LIST);
                        pdo.prfntInactive(prf);
                        pdo.cInactive( pdo.cInactive()-1 );
                    }

                // add it to the kill list

                    rfo.vInsert( pprfntToBeKilled, PDEV_LIST );
                }

                prfnt = prfntNext;
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

static
RFONT *prfntDeactivateEudcRFONTs( PPFE *appfe )
{
    RFONT *prfntToBeKilled = PRFNTNULL;

    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,"Deactivating EUDC RFONTs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vDeactivateEudcRFONTsWorker( appfe, pPFF, &prfntToBeKilled );
        }
    }

    return(prfntToBeKilled);
}

/*****************************************************************************
 * BOOL bUnloadEudcFont( PFE ** )
 *
 * This function delete RFONTs and unload fontfile for specified PFE
 *
 * History:
 *  24-01-1995 -by- Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
static
BOOL bUnloadEudcFont( PFE **ppfe )
{
    WCHAR awcPathBuffer[MAX_PATH + 1];

    PUBLIC_PFTOBJ pfto;  // access the public font table

    PFEOBJ pfeo( ppfe[PFE_NORMAL] );
    PFFOBJ pffo( pfeo.pPFF() );

// get font file path.

    if (FAILED(StringCchCopyW(awcPathBuffer, MAX_PATH + 1, pffo.pwszPathname())))
    {
        WARNING("bUnloadEudcFont: temporary buffer too short\n");
        return FALSE;
    }


    QUICKLOOKUP *pqlDelete;

// Progress Normal face..

    pqlDelete = pfeo.pql();

// if this is system wide eudc, won't need to free it.

    if( pqlDelete->puiBits != NULL )
    {
        VFREEMEM(pqlDelete->puiBits);
        pqlDelete->puiBits = NULL;
    }

    PFEOBJ pfeoVert( ppfe[PFE_VERTICAL] );

    if( pfeoVert.bValid() )
    {
        pqlDelete = pfeoVert.pql();

    // if this is system wide eudc, won't need to free it.

        if( pqlDelete->puiBits != NULL )
        {
            VFREEMEM(pqlDelete->puiBits);
            pqlDelete->puiBits = NULL;
        }
    }

// Deactivate all RFONT for this PFE

    PRFONT prfntToBeKilled = prfntDeactivateEudcRFONTs( ppfe );

// Kill all RFONT for this PFE

    if(!bKillEudcRFONTs( prfntToBeKilled ))
    {
        WARNING("bDeleteAllFlEntry():Can not kill Eudc RFONTs\n");
        return(FALSE);
    }

    //
    // Unload this font file.
    //
    //  if others link are using this font file, the font
    // is not unloaded here. At the last link that is using
    // this font, it will be really unloaded.
    //

    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
    {
        DbgPrint("Unloading... %ws\n",awcPathBuffer);
    }
    #endif

    if(!pfto.bUnloadEUDCFont(awcPathBuffer))
    {
        #if DBG
        DbgPrint("bDeleteAllFlEntry():Can not unload Eudc %ws\n",awcPathBuffer);
        #endif
        return(FALSE);
    }

    return(TRUE);
}

/*****************************************************************************
 * PFLENTRY FindBaseFontEntry(const WCHAR *)
 *
 * This function scan the base font list to find specified font is already
 * exist or not.
 *
 * Return.
 *  Exist     - Pointer to FLENTRY strucrure.
 *  Not exist - NULL
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

PFLENTRY FindBaseFontEntry
(
    const WCHAR * BaseFontName
)
{
    PLIST_ENTRY p;
    PFLENTRY    pFlEntry;

    p = BaseFontListHead.Flink;
    pFlEntry = NULL;

    while( p != &BaseFontListHead )
    {
        pFlEntry = CONTAINING_RECORD(p,FLENTRY,baseFontList);

        #if DBG
        if( gflEUDCDebug & (DEBUG_FONTLINK_INIT) )
        {
            DbgPrint("%ws v.s. %ws\n",BaseFontName,pFlEntry->awcFaceName);
        }
        #endif

        //
        // if this is Vertical font name, compair without '@'
        //
        const WCHAR * pFaceName = ( (pFlEntry->awcFaceName[0] != L'@') ? &(pFlEntry->awcFaceName[0]) :
                                                           &(pFlEntry->awcFaceName[1])   );

        const WCHAR * pBaseFaceName = ( (BaseFontName[0] != L'@') ? &BaseFontName[0] :
                                                      &BaseFontName[1]   );

        //
        // Compair font face name.
        //

        if( _wcsicmp(pBaseFaceName,pFaceName) == 0 )
        {
            //
            // Find it.
            //
            break;
        }

        //
        // try next.
        //

        p = p->Flink;
        pFlEntry = NULL;
    }

    return(pFlEntry);
}

/*****************************************************************************
 * PPFEDATA FindLinkedFontEntry(PLIST_ENTRY,PWSTR,PWSTR)
 *
 * This function scan the linked font list to find specified font is already
 * exist or not.
 *
 * Return.
 *  Exist     - Pointer to PPFEDATA strucrure.
 *  Not exist - NULL
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
static
PPFEDATA FindLinkedFontEntry
(
    PLIST_ENTRY LinkedFontList,
    const WCHAR * LinkedFontPath,
    const WCHAR * LinkedFontFace
)
{
    PLIST_ENTRY p;
    PPFEDATA    ppfeData;

    p = LinkedFontList->Flink;
    ppfeData = NULL;

    while( p != LinkedFontList )
    {
        ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);

        //
        // get PFE and PFF user object.
        //

        PFEOBJ pfeo( ppfeData->appfe[PFE_NORMAL] );
        PFFOBJ pffo( pfeo.pPFF() );

        #if DBG
        if( gflEUDCDebug & (DEBUG_FONTLINK_INIT) )
        {
            DbgPrint("%ws v.s. %ws\n",pffo.pwszPathname(),LinkedFontPath);
        }
        #endif

        //
        // compair file path
        //

        if( _wcsicmp( pffo.pwszPathname() , LinkedFontPath ) == 0 )
        {
            //
            // if facename of linked font is specified, check it also.
            //

            if( ((LinkedFontFace == NULL) &&
                 ((ppfeData->FontLinkFlag & FLINK_FACENAME_SPECIFIED) == 0)) ||
                ((LinkedFontFace != NULL ) &&
                 ((ppfeData->FontLinkFlag & FLINK_FACENAME_SPECIFIED) != 0) &&
                 ((_wcsicmp(pfeo.pwszFamilyName() , LinkedFontFace))== 0)
                )
              )
            {
                //
                // Find it.
                //
                break;
            }
        }

        //
        // try next.
        //

        p = p->Flink;
        ppfeData = NULL;
    }

    return(ppfeData);
}

/*****************************************************************************\
 * BOOL FindDefaultLinkedFontEntry
 *
 * This codepath check the passed facename is registered as Default link
 * facename in Default link table. if so, keep its facename for the facename.
 *
 * History
 *  1-14-96 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL FindDefaultLinkedFontEntry
(
    const WCHAR * CandidateFaceName,
    const WCHAR * CandidatePathName
)
{
    UINT iIndex;

    for( iIndex = 0; iIndex < NUMBER_OF_FONTASSOC_DEFAULT; iIndex++ )
    {
        //
        // Check the data can be read from registry or not.
        //
        if( FontAssocDefaultTable[iIndex].ValidRegData )
        {
            //
            // Check this path is not filled.
            //
            if( FontAssocDefaultTable[iIndex].DefaultFontPathName[0] == L'\0' )
            {
                //
                // Check the candidate is matched with the facename from registry.
                //
                if( _wcsicmp(CandidateFaceName,FontAssocDefaultTable[iIndex].DefaultFontFaceName) == 0 )
                {
                    //
                    // Mark the candidate path to default table. This font file will be RE-loaded
                    // EUDC font file when GreEnableEUDC() was called next time.
                    //
                    if (FAILED(StringCchCopyW(FontAssocDefaultTable[iIndex].DefaultFontPathName, MAX_PATH+1, CandidatePathName)))
                    {
                        WARNING("FindDefaultLinkedFontEntry: temporary buffer too short\n");
                        return FALSE;
                    }

                    #if DBG
                    DbgPrint("GDISRV:FONTASSOC DEFAULT:%ws -> %ws\n",
                        FontAssocDefaultTable[iIndex].DefaultFontTypeID,
                        FontAssocDefaultTable[iIndex].DefaultFontPathName);
                    #endif
                }
            }
        }
    }

    return TRUE;
}



/*****************************************************************************
 * VOID vLinkEudcPFEs(PFLENTRY)
 *
 *  This routine will find base font PFE from PFT, and set up Eudc data.
 *
 * History:
 *  24-Jan-1995 -by- Hideyuki Nagase
 * Wrote it.
 ****************************************************************************/
static
VOID vLinkEudcPFEsWorker
(
    PFLENTRY pFlEntry,
    PPFF     pPFF
)
{
    while(pPFF)
    {
        //
        // get PFF user object
        //

        PFFOBJ pffo(pPFF);

        //
        // if this font is loaded as EUDC, it can not be a BaseFont.
        //

        if( !pffo.bEUDC() )
        {
            for( COUNT c = 0 ; c < pffo.cFonts() ; c++ )
            {
                PFEOBJ   pfeo(pffo.ppfe(c));

                if( pfeo.bValid() )
                {
                    BOOL     bFound = FALSE;
                    PFLENTRY pFlEntrySelected = pFlEntry;

                    if( pFlEntrySelected )
                    {
                        bFound = pfeo.bCheckFamilyName(pFlEntrySelected->awcFaceName, 0);
                    }
                     else
                    {
                        const WCHAR * pwszAlias = NULL;
                        BOOL bIsFamilyNameAlias = FALSE;


                        pwszAlias = pfeo.pwszFamilyNameAlias(&bIsFamilyNameAlias);
                        bFound =
                            ((pFlEntrySelected = FindBaseFontEntry(pwszAlias)) != NULL);

                        if (!bFound && bIsFamilyNameAlias)
                        {
                            pwszAlias += (wcslen(pwszAlias) + 1);
                            bFound = ((pFlEntrySelected =
                                    FindBaseFontEntry(pwszAlias)) != NULL);
                        }
                    }

                    if( bFound )
                    {
                        //
                        // set eudc list..
                        //

                        pfeo.vSetLinkedFontEntry( pFlEntrySelected );

                        #if DBG
                        if( gflEUDCDebug & DEBUG_FACENAME_EUDC )
                        {
                            PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;

                            DbgPrint("Found FaceName EUDC for %ws (%ws) is ",
                                      pfeo.pwszFamilyName(),pffo.pwszPathname());

                            while( p != &(pFlEntrySelected->linkedFontListHead) )
                            {
                                PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);
                                PFEOBJ pfeoTemp( ppfeData->appfe[PFE_NORMAL] );
                                PFFOBJ pffoTemp( pfeoTemp.pPFF() );

                                DbgPrint(" %ws ",pffoTemp.pwszPathname());

                                p = p->Flink;
                            }

                            DbgPrint("\n");
                        }
                        #endif
                    }
                     else
                    {
                        // mark the FaceNameEUDC pfe as NULL

                        pfeo.vSetLinkedFontEntry( NULL );
                    }
                }
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

static
VOID vLinkEudcPFEs
(
    PFLENTRY pFlEntry
)
{
    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
    {
        DbgPrint( "vLinkEudcPFEs():Linking All EUDC PFEs.\n");
    }
    #endif

    SEMOBJ so(ghsemPublicPFT);

    //
    // WE HAD BETTER USE FONTHASH TO SEARCH BASE FONT'S PFF.
    //

    COUNT cBuckets;
    PPFF  pPFF;

    //
    // get PFT user object.
    //

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vLinkEudcPFEsWorker( pFlEntry, pPFF );
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vLinkEudcPFEsWorker( pFlEntry, pPFF );
        }
    }
}

/*****************************************************************************
 * VOID vUnlinkEudcRFONTs( PPFE * )
 *
 * This routine reset RFONT that has specified linked font.
 *
 * History:
 *  23-Jan-1995 -by- Hideyuki Nagase
 * Wrote it
 ****************************************************************************/
static
VOID vUnlinkEudcRFONTsWorker
(
    PPFE *appfe,
    PPFF pPFF
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // if this font is loaded as EUDC, it can not be a BaseFont.

        if( !pffo.bEUDC() )
        {
        // Unlink Eudc from the RFONTs if it has specified Eudc..

            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

            // if this RFONT has Eudc font, search this Eudc..

                for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
                {
                // Is this the Eudc RFONT that we want to remove?


                    if((prfnt->paprfntFaceName[ii] != NULL ) &&
                       (((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_NORMAL])  ||
                        ((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_VERTICAL])))
                    {

                        #if DBG
                        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                        {
                            DbgPrint("Removing face name EUDC pair %x -> %x\n",
                                             prfnt, prfnt->paprfntFaceName[ii]);
                        }
                        #endif

                        prfnt->paprfntFaceName[ii] = NULL;
                    }
                }

            // this RFONT's linked font array will be updated with new configuration
            // when this RFONT is used again (see vInitEUDC()).
            // and, if all Eudc font has been removed for this RFONT.
            // the array, its pointer and other information for Eudc will be
            // deleted/updated, vUnlinkEudcRFONTsAndPFEs() will be called instead
            // of this.

                prfnt->flEUDCState = 0;

                prfnt = prfntNext;
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

static
VOID vUnlinkEudcRFONTs
(
    PPFE *appfe
)
{
    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,"vUnlinkEudcRFONTs():Unlinking EUDC RFONTs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsWorker(appfe,pPFF);
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsWorker(appfe,pPFF);
        }
    }
}

/*****************************************************************************
 * VOID vUnlinkEudcRFONTsAndPFEs(PPFE *,PFLENTRY)
 *
 * This routine reset RFONT and PFE structure that has specified linked font.
 *
 * History:
 *  23-Jan-1995 -by- Hideyuki Nagase
 * Wrote it
 ****************************************************************************/
static
VOID vUnlinkEudcRFONTsAndPFEsWorker
(
    PPFE     *appfe,
    PFLENTRY pFlEntry,
    PPFF     pPFF
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // if this font is loaded as EUDC, it can not be a BaseFont.

        if( !pffo.bEUDC() )
        {
        // Unlink Eudc from the RFONTs if it has specified Eudc..

            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

            // if this RFONT has Eudc font, search this Eudc..


                BOOL bFound = FALSE;

                for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
                {
                // Is this the Eudc RFONT that we want to remove?

                    if(((prfnt->paprfntFaceName[ii]) != NULL ) &&
                       (((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_NORMAL])  ||
                        ((prfnt->paprfntFaceName[ii])->ppfe == appfe[PFE_VERTICAL])))
                    {
                        #if DBG
                        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                        {
                            DbgPrint("Removing face name EUDC pair %x -> %x\n",
                                      prfnt, prfnt->paprfntFaceName[ii]);
                        }

                        //
                        // Invalidate it for checking.
                        //
                        prfnt->paprfntFaceName[ii] = NULL;
                        #endif

                        bFound = TRUE;
                        break;
                    }
                }

                if( bFound )
                {
                    #if DBG
                // make sure the linked font array is really empty.

                    for( UINT jj = 0; jj < prfnt->uiNumLinks ; jj++ )
                    {
                        if( prfnt->paprfntFaceName[jj] != NULL )
                        {
                            DbgPrint("vUnloadEudcRFONTsAndPFEs():*** Deleteing Eudc \
                                      array that has valid data\n");
                        }
                    }
                    #endif

                // if the linked RFONT table was allocated, free it here

                    if( prfnt->paprfntFaceName != prfnt->aprfntQuickBuff )
                        VFREEMEM( prfnt->paprfntFaceName );

                // we have no facename eudc for this RFONT.

                    prfnt->paprfntFaceName  = NULL;
                    prfnt->uiNumLinks       = 0;
                    prfnt->bFilledEudcArray = FALSE;
                    prfnt->ulTimeStamp      = 0L;
                }

                prfnt->flEUDCState = 0;

                prfnt = prfntNext;
            }

        // Unlink Eudcs from All PFEs that has Eudcs.

            for( COUNT c = 0 ; c < pffo.cFonts() ; c++ )
            {
                PFEOBJ pfeo(pffo.ppfe(c));

                if( pfeo.pGetLinkedFontEntry() == pFlEntry )
                {
                    FLINKMESSAGE2(DEBUG_FONTLINK_UNLOAD,
                                  "Removing face name PFE for %x (PFE)\n",pffo.ppfe(c));

                    pfeo.vSetLinkedFontEntry( NULL );
                }
            }
        }

        pPFF = pPFF->pPFFNext;
    }
}

static
VOID vUnlinkEudcRFONTsAndPFEs
(
    PPFE     *appfe,
    PFLENTRY pFlEntry
)
{
    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,
                 "vUnlinkEudcRFONTsAndPFEs():Unlinking EUDC RFONTs ans PFEs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

// get PFT user object.

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsAndPFEsWorker(appfe,pFlEntry,pPFF);
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vUnlinkEudcRFONTsAndPFEsWorker(appfe,pFlEntry,pPFF);
        }
    }
}

/*****************************************************************************
 * VOID vUnlinkAllEudcRFONTsAndPFEs(BOOL,BOOL)
 *
 * This routine reset RFONT and PFE structure that has any linked font.
 *
 * History:
 *  23-Jan-1995 -by- Hideyuki Nagase
 * Wrote it
 ****************************************************************************/
static
VOID vUnlinkAllEudcRFONTsAndPFEsWorker
(
    BOOL bUnlinkSystem,
    BOOL bUnlinkFaceName,
    PPFF pPFF
)
{
    while(pPFF)
    {
        PFFOBJ pffo(pPFF);

    // if this font is loaded as EUDC, it can not be a BaseFont.

        if( !pffo.bEUDC() )
        {
        // Unlink Eudc from All RFONTs that has Eudc..


            for( PRFONT prfnt = pffo.prfntList() ; prfnt != (PRFONT) NULL;  )
            {
                PRFONT prfntNext;

                {
                    RFONTTMPOBJ rflo(prfnt);
                    prfntNext = rflo.prflPFF()->prfntNext;
                }

             // if this RFONT has system wide eudc, unlink it..


                if( bUnlinkSystem )
                {
                #if DBG
                    if( prfnt->prfntSysEUDC != (PRFONT) NULL  )
                    {
                        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                        {
                            DbgPrint("Removing system wide EUDC pair %x -> %x\n",
                                      prfnt, prfnt->prfntSysEUDC);
                        }

                        prfnt->prfntSysEUDC = NULL;
                    }
                 #else
                    prfnt->prfntSysEUDC = NULL;
                 #endif
                }


                 // if this RFONT has face name eudc, unlink it..


                 if( bUnlinkFaceName )
                 {
                  // NOTE :
                  //
                  // We will unlink the pointer to Rfont, even some of
                  // eudc link will valid (i.g. if we have on-bit of FONTLINK_SYSTEM in
                  // FontLinkChange value. the type of EUDC may not need to unlink.
                  // Because we should restructure the Rfonts array for following case,
                  // when even we want to only USER attribute EUDC....
                  //
                  // Before :
                  //  BaseFont->FaceNameEUDC(SYS)->FaceNameEUDC(USER)->FaceNameEUDC(SYS)
                  //
                  // After :
                  //  BaseFont -> FaceNameEUDC(SYS) -> FaceNameEUDC(SYS)
                  //

                    if( prfnt->paprfntFaceName != NULL )
                    {
                        for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
                        {
                            #if DBG
                            if( prfnt->paprfntFaceName[ii] != NULL )
                            {
                                if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
                                {
                                    DbgPrint("Removing face name EUDC pair %x -> %x\n",
                                                      prfnt, prfnt->paprfntFaceName[ii]);
                                }
                                prfnt->paprfntFaceName[ii] = NULL;
                            }
                            #else
                            prfnt->paprfntFaceName[ii] = NULL;
                            #endif
                        }

                         if( prfnt->paprfntFaceName != prfnt->aprfntQuickBuff )
                             VFREEMEM( prfnt->paprfntFaceName );

                         prfnt->uiNumLinks = 0;
                         prfnt->paprfntFaceName = NULL;
                         prfnt->bFilledEudcArray = FALSE;
                         prfnt->ulTimeStamp = 0;
                     }
                 }

                 prfnt->flEUDCState = 0;
                 prfnt = prfntNext;
             }


             if( bUnlinkFaceName )
             {
                 for( COUNT c = 0 ; c < pffo.cFonts() ; c++ )
                 {
                     PFEOBJ pfeo(pffo.ppfe(c));

                     #if DBG
                     if( pfeo.pGetLinkedFontEntry() != NULL )
                     {
                         FLINKMESSAGE2(DEBUG_FONTLINK_UNLOAD,                   \
                                       "Removing face name PFE for %x (PFE)\n", \
                                       pffo.ppfe(c));



                         pfeo.vSetLinkedFontEntry( NULL );
                     }
                     #else
                     pfeo.vSetLinkedFontEntry( NULL );
                     #endif
                 }

             }
        }
        pPFF = pPFF->pPFFNext;
    }
}


static
VOID vUnlinkAllEudcRFONTsAndPFEs
(
    BOOL bUnlinkSystem,
    BOOL bUnlinkFaceName
)
{
    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD,
                 "vUnlinkAllEudcRFONTsAndPFEs():Unlinking All EUDC RFONTs and PFEs.\n");

    SEMOBJ so1(ghsemPublicPFT);
    SEMOBJ so2(ghsemRFONTList);

    COUNT cBuckets;
    PPFF  pPFF;

    //
    // get PFT user object.
    //

    PUBLIC_PFTOBJ pftoPublic;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoPublic.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoPublic.pPFF(cBuckets)) != NULL )
        {
            vUnlinkAllEudcRFONTsAndPFEsWorker(bUnlinkSystem,bUnlinkFaceName,pPFF);
        }
    }

    DEVICE_PFTOBJ pftoDevice;  // access the public font table

    for( cBuckets = 0; cBuckets < pftoDevice.cBuckets(); cBuckets++ )
    {
        if( (pPFF = pftoDevice.pPFF(cBuckets)) != NULL )
        {
            vUnlinkAllEudcRFONTsAndPFEsWorker(bUnlinkSystem,bUnlinkFaceName,pPFF);
        }
    }
}

/*****************************************************************************
 * BOOL bDeleteFlEntry(PWSTR,PWSTR,INT)
 *
 * This function delete base font and linked font pair from list.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

static
BOOL bDeleteFlEntry
(
    const WCHAR * BaseFontName,
    const WCHAR * LinkedFontPathAndName,
    INT      iFontLinkType    // FONTLINK_SYSTEM or FONTLINK_USER
)
{
    PFLENTRY pFlEntry = NULL;
    PPFEDATA ppfeData = NULL;
    PWSTR    LinkedFaceName = NULL;
    WCHAR    awcPathBuffer[MAX_PATH];
    WCHAR    LinkedFontName[LF_FACESIZE+MAX_PATH+1];

    //
    // Have a local copy...
    //

    if (FAILED(StringCchCopyW(LinkedFontName, LF_FACESIZE+MAX_PATH+1, LinkedFontPathAndName)))
    {
        WARNING("bDeleteFlEntry: temporary buffer too short\n");
        return FALSE;
    }

    //
    // Find ',' char from LinkedFontName
    //
    // Registry format :
    //
    // Type 1:
    //
    //  This format is for the specified Linked font contains only 1 font resource.
    //  Except Vertical "@" face font, such as TrueType font (not TTC), and Vector font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName" , ...
    //
    // Type 2:
    //
    //  This format is for the specified Linked font contains more than 1 font resource,
    //  TTC TrueType font, and Bitmap font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName,FontFaceNameInTheFile" , ...
    //
    // After calling ValidLinkedRegistry(), the ',' character is replaced with NULL if
    // found.
    //

    if( !bValidFontLinkParameter(LinkedFontName,&LinkedFaceName) )
    {
        #if DBG
        DbgPrint("Invalid Registry format - %ws\n",LinkedFontName);
        #endif
        return(FALSE);
    }

    //
    // Get full path name for this font file.
    //

    if (!bAppendSysDirectory(awcPathBuffer, LinkedFontName, MAX_PATH))
        return FALSE;

    // If this file is being used as the system EUDC file then it can't be used
    // as a facename EUDC file.


    if( _wcsicmp(awcPathBuffer,gawcEUDCPath) == 0 )
    {
        #if DBG
        DbgPrint("%ws can't be unload as a facename link because it is the system \
                 EUDC file.\n", LinkedFontName);
        #endif
        return(FALSE);
    }

    //
    // Check base font list, To remove, the base font should be listed..
    //

    if( IsListEmpty( &BaseFontListHead )                       ||
        (pFlEntry = FindBaseFontEntry( BaseFontName )) == NULL    )
    {
        //
        // We can not find out this base font in current link list.
        //
        return(FALSE);
    }

    //
    // The Entry for this base font is already exist....
    //

    #if DBG
    //
    // The FLENTRY should have one or more PFEDATA.
    //
    if( IsListEmpty( &(pFlEntry->linkedFontListHead) ) )
    {
        DbgPrint("This FLENTRY has no PFEDATA (%ws)\n",pFlEntry->awcFaceName);
    }
    #endif

    //
    // Scan linked font list for this base font.
    // if this linked font is already listed, we do not add this.
    //

    if( (ppfeData = FindLinkedFontEntry( &(pFlEntry->linkedFontListHead) ,
                                         awcPathBuffer, LinkedFaceName )   ) == NULL )
    {
        #if DBG
        if( gflEUDCDebug & (DEBUG_FONTLINK_INIT|DEBUG_FONTLINK_LOAD|DEBUG_FACENAME_EUDC) )
        {
            DbgPrint("Can not find linked font %ws -> %ws\n",BaseFontName,LinkedFontName);
        }
        #endif
        return(FALSE);
    }

    //
    // Check we can really unload this eudc font.
    //

    if( ppfeData->FontLinkType == iFontLinkType )
    {
        //
        // Now we can find out target PFEDATA.
        //

        //
        // Remove the PFEDATA from current list.
        //

        RemoveEntryList( &(ppfeData->linkedFontList) );

        //
        // Decrement number of linked list count.
        //

        pFlEntry->uiNumLinks--;

        //
        // if there is no PFEDATA for this FLENTRY...
        //

        if( pFlEntry->uiNumLinks == 0 )
        {
            #if DBG
            if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
            {
                DbgPrint("Deleting FLENTRY for %ws\n",pFlEntry->awcFaceName);
            }

            if(!IsListEmpty(&(pFlEntry->linkedFontListHead)))
            {
                DbgPrint("bDeleteFlEntry():Deleting FLENTRY that has PFEDATA \
                          (%ws -> %ws)\n", BaseFontName,LinkedFontName);
            }
            #endif

            //
            // disable the link of this facename.
            //

            vUnlinkEudcRFONTsAndPFEs(ppfeData->appfe,pFlEntry);

            //
            // Remove this FLENTRY from BaseFontList.
            //

            RemoveEntryList( &(pFlEntry->baseFontList) );

            //
            // Free this FLENTRY.
            //

            VFREEMEM( pFlEntry );

            //
            // Decrement global base font number
            //

            gcNumLinks--;

            //
            // BaseFontList has been change, update TimeStamp
            //

            ulFaceNameEUDCTimeStamp++;
        }
         else
        {
            //
            // disable the link of this facename Eudc.
            //

            vUnlinkEudcRFONTs(ppfeData->appfe);

            //
            // Update time stamp for this facename link.
            //

            pFlEntry->ulTimeStamp++;
        }

        //
        // Unload this Eudc font.
        //

        if( !bUnloadEudcFont( ppfeData->appfe ) )
        {
        #if DBG
            DbgPrint("bDeleteFlEntry():bUnloadEudcFont() fail - %ws\n",LinkedFontName);
        #endif
        }

        #if DBG
        if( gflEUDCDebug & DEBUG_FONTLINK_UNLOAD )
        {
            PFEOBJ pfeo(ppfeData->appfe[PFE_NORMAL]);
            PFFOBJ pffo(pfeo.pPFF());

            DbgPrint("Deleting PFEDATA for %ws\n",pffo.pwszPathname());
        }
        #endif

        //
        // Free this PFEDATA.
        //

        VFREEMEM( ppfeData );

        return(TRUE);
    }
     else
    {
        return(FALSE);
    }
}


/*****************************************************************************
 * BOOL bAddFlEntry(const WCHAR *,const WCHAR *,INT,PFLENTRY *)
 *
 * This function add new base font and linked font pair into list.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

static
BOOL bAddFlEntry
(
    const WCHAR * BaseFontName,
    const WCHAR * LinkedFontPathAndName,
    INT      iFontLinkType,   // FONTLINK_SYSTEM or FONTLINK_USER
    INT      iPriority,
    PFLENTRY *ppFlEntry
)
{
    PFLENTRY pFlEntry = (PFLENTRY) NULL;
    PFLENTRY tempEntry = (PFLENTRY) NULL;
    PPFEDATA ppfeData = (PPFEDATA) NULL;
    PWSTR    LinkedFaceName = NULL;
    WCHAR    awcBuf[MAX_PATH + (MAX_PATH+LF_FACESIZE)];
    PWSTR    TempPathBuffer = awcBuf;
    PWSTR    LinkedFontName = &awcBuf[MAX_PATH];
    BOOL     bRet = FALSE;


    gbAnyLinkedFonts = TRUE;

    //
    // if ppFlEntry is presented, initialize with NULL.
    //

    if( ppFlEntry != NULL ) 
        *ppFlEntry = NULL;

    //
    // Have a local copy...
    //

    if (FAILED(StringCchCopyW(LinkedFontName, MAX_PATH + LF_FACESIZE, LinkedFontPathAndName)))
    {
        WARNING("bAddFlEntry: temporary buffer too short\n");
        return FALSE;
    }

    //
    // Find ',' char from LinkedFontName
    //
    // Registry format :
    //
    // Type 1:
    //
    //  This format is for the specified Linked font contains only 1 font resource.
    //  Except Vertical "@" face font, such as TrueType font (not TTC), and Vector font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName" , ...
    //
    // Type 2:
    //
    //  This format is for the specified Linked font contains more than 1 font resource,
    //  TTC TrueType font, and Bitmap font.
    //
    //  BaseFontFaceName = REG_MULTI_SZ "FontPathFileName,FontFaceNameInTheFile" , ...
    //
    // After calling ValidLinkedRegistry(), the ',' character is replaced with NULL if
    // found.
    //

    if( !bValidFontLinkParameter(LinkedFontName,&LinkedFaceName) )
    {
        #if DBG
        DbgPrint("Invalid Registry format - %ws\n",LinkedFontName);
        #endif

        return bRet;
    }

    #if DBG
    if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
    {
        if( LinkedFaceName )
        {
            DbgPrint("FontFile - %ws : FontFace - %ws\n",LinkedFontName,LinkedFaceName);
        }
    }
    #endif

    //
    // Get full path name for this font file.
    //

    if (!bAppendSysDirectory(TempPathBuffer, LinkedFontName, MAX_PATH))
        return FALSE;

    //
    // If this file is being used as the system EUDC file then it can't be used
    // as a facename EUDC file.
    //

    if( _wcsicmp(TempPathBuffer,gawcEUDCPath) == 0 )
    {
        #if DBG
        DbgPrint(
            "%ws can't be load as a facename link because it is the system EUDC file.\n",
             LinkedFontName
        );
        #endif
        
        return bRet;
    }

    //
    // Check base font list, it is a new one ?
    //

    if( !IsListEmpty( &BaseFontListHead )                      &&
        (pFlEntry = FindBaseFontEntry( BaseFontName )) != NULL    )
    {
        //
        // The Entry for this base font is already exist....
        //

        if( !IsListEmpty( &(pFlEntry->linkedFontListHead) ) )
        {
            //
            // Scan linked font list for this base font.
            // if this linked font is already listed, we do not add this.
            //

            if( FindLinkedFontEntry( &(pFlEntry->linkedFontListHead) ,
                                     TempPathBuffer , LinkedFaceName ) != NULL )
            {
                #if DBG
                DbgPrint("Dupulicate linked font - %ws\n",LinkedFontName);
                #endif

                return bRet;
            }
        }
    }

    {
        //
        // get and validate PFT user object
        //

        PUBLIC_PFTOBJ  pfto;          // access the public font table
        PPFE           appfeLink[2];  // temporary buffer
        LONG           cFonts;        // count of fonts
        EUDCLOAD       EudcLoadData;  // eudc load data

        //
        // parameter for PFTOBJ::bLoadFonts()
        //

        FLONG          flParam = PFF_STATE_EUDC_FONT;

        //
        // Fill up EudcLoadData structure
        //

        EudcLoadData.pppfeData  = appfeLink;
        EudcLoadData.LinkedFace = LinkedFaceName;

        //
        // if the FontLinkType is system, it should be a Permanent font.
        //

        if( iFontLinkType == FONTLINK_SYSTEM )
        {
            flParam |= PFF_STATE_PERMANENT_FONT;
        }


        if( pFlEntry == NULL )
        {
        // Allocate new FLENTRY..

            tempEntry = pFlEntry = (PFLENTRY) PALLOCNOZ( sizeof(FLENTRY), 'flnk' );

            if (!pFlEntry)
            {
                goto FreeMemAndExit;
            }

        }

        //
        // Allocate new PFEDATA...
        //

        ppfeData = (PPFEDATA) PALLOCNOZ(sizeof(PFEDATA), 'flnk' );

        if (!ppfeData)
        {
            goto FreeMemAndExit;
        }

        //
        // Load the linked font.
        //

        PFF *placeHolder;

        if( pfto.bLoadAFont( TempPathBuffer,
                             (PULONG) &cFonts,
                             flParam,
                             &placeHolder,
                             &EudcLoadData ) )
        {
            //
            // Check we really succeed to load requested facename font.
            //
            if(!bComputeQuickLookup( NULL, appfeLink[PFE_NORMAL], FALSE ))
            {
            //
            // Compute table for normal face
            //
                WARNING("Unable to compute QuickLookUp for face name link\n");

                pfto.bUnloadEUDCFont(TempPathBuffer);
    
                goto FreeMemAndExit;
            }
            
            //
            // Compute table for vertical face, if vertical face font is provided,
            //

            if( !bComputeQuickLookup( NULL, appfeLink[PFE_VERTICAL], FALSE ))
            {
                WARNING("Unable to compute QuickLookUp for face name link\n");

                pfto.bUnloadEUDCFont(TempPathBuffer);

                goto FreeMemAndExit;
            }

            if (tempEntry)
            {
    
                
            // Initialize number of linked font count.

                pFlEntry->uiNumLinks = 0;

            // Initialize link time stamp

                pFlEntry->ulTimeStamp = 0;

            // Copy base font name to buffer.

                if (FAILED(StringCchCopyW(pFlEntry->awcFaceName, LF_FACESIZE+1, BaseFontName)))
                {
                    WARNING("bAddFlEntry: target buffer too short.\n");
                    pfto.bUnloadEUDCFont(TempPathBuffer);
                    goto FreeMemAndExit;
                }

            // Initialize linked font list for this base font.

                InitializeListHead( &(pFlEntry->linkedFontListHead) );

            // Add this entry to BaseFontList.

                InsertTailList( &BaseFontListHead , &(pFlEntry->baseFontList) );

            // Increment global base font number

                gcNumLinks++;

            // just notify new FLENTRY was allocated to caller

                if( ppFlEntry != NULL ) 
                    *(PFLENTRY *)ppFlEntry = pFlEntry;

            // BaseFontList has been change, update TimeStamp

                ulFaceNameEUDCTimeStamp++;
            }
                
            #if DBG
            if(gflEUDCDebug&(DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_INIT|DEBUG_FACENAME_EUDC))
            {
                DbgPrint("Allocate PFEDATA for %ws - %ws\n",BaseFontName,LinkedFontName);
            }
            #endif

            //
            // Set PFE for linked font into the structure.
            //

            ppfeData->appfe[PFE_NORMAL] = appfeLink[PFE_NORMAL];
            ppfeData->appfe[PFE_VERTICAL] = appfeLink[PFE_VERTICAL];

            //
            // Set FontLinkType.
            //

            ppfeData->FontLinkType = iFontLinkType;

            //
            // Set FontLinkFlag.
            //

            ppfeData->FontLinkFlag = 0L;

            if( EudcLoadData.LinkedFace )
                ppfeData->FontLinkFlag |= FLINK_FACENAME_SPECIFIED;

            //
            // Incremant number of linked font count for this base face name.
            //

            pFlEntry->uiNumLinks++;

            //
            // Update time stamp
            //

            pFlEntry->ulTimeStamp++;

            //
            // add pfe for this font our list of flinks
            //

            if( iPriority < 0 )
            {
            //
            // Insert end of this list.
            //

                InsertTailList(&(pFlEntry->linkedFontListHead),
                               &(ppfeData->linkedFontList) );
            }
            else // later if( iPriority == 0 )
            {
                //
                // Insert top of this list.
                //

                InsertHeadList(&(pFlEntry->linkedFontListHead),
                               &(ppfeData->linkedFontList));
            }

            bRet = TRUE;
        }
        else
        {
            #if DBG
            DbgPrint("Failed to load EUDC font - %ws\n",TempPathBuffer);
            #endif
        }
    }

FreeMemAndExit:

    if (!bRet)
    {
        if(tempEntry)
        {
            VFREEMEM(tempEntry);
        }
        
        if (ppfeData)
        {
            VFREEMEM(ppfeData);
        }
    }

    return(bRet);
}

/*****************************************************************************
 * BOOL bDeleteAllFlEntry(BOOL,BOOL)
 *
 * This function delete all linked font information including system wide eudc.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
static
BOOL bDeleteAllFlEntry
(
    BOOL bDeleteSystem,
    BOOL bDeleteFaceName
)
{
    BOOL bRet = TRUE;
    PFEDATA **UnloadBuffer;
    PFEDATA **UnloadBufferNew;
    ULONG NumUnload = 0;
    ULONG MaxUnload = 40;
    PFE *LocalppfeSysEUDC[2] = {NULL, NULL};

    //
    // make sure we are the only ones changing the EUDC data
    //

    GreAcquireSemaphore( ghsemEUDC1 );

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        //
        // another EUDC API is currently in progress
        //

        FLINKMESSAGE(DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_UNLOAD,
         " another EUDC API is currently in progress. bDeleteAllFlEntry() is failed.\n");
        EngSetLastError(ERROR_LOCK_FAILED);
        GreReleaseSemaphore( ghsemEUDC1 );
        return(FALSE);
    }

    UnloadBuffer = (PFEDATA **)PALLOCNOZ(sizeof(PFEDATA *) * MaxUnload, 'dueG');
    if (!UnloadBuffer) {
        MaxUnload = 0;
    }

// disable the link of all facename and system wide eudc.

    vUnlinkAllEudcRFONTsAndPFEs(bDeleteSystem,bDeleteFaceName);

// if there is no system wife eudc font.. skip it.

    if( bDeleteSystem && IS_SYSTEM_EUDC_PRESENT() )
    {
    // Unload system wide eudc font

        LocalppfeSysEUDC[PFE_NORMAL] = gappfeSysEUDC[PFE_NORMAL];
        LocalppfeSysEUDC[PFE_VERTICAL] = gappfeSysEUDC[PFE_VERTICAL];

    // Clear global data.

        gappfeSysEUDC[PFE_NORMAL]   = NULL;
        gappfeSysEUDC[PFE_VERTICAL] = NULL;

        gawcEUDCPath[0] = 0;

        ulSystemEUDCTimeStamp++;
    }

// if there is no facename eudc, just return here.

    if( bDeleteFaceName && !IsListEmpty(&BaseFontListHead) )
    {
        COUNT NumberOfLinks = gcNumLinks;

    // start to scan facename link list.

        PLIST_ENTRY p = BaseFontListHead.Flink;

        while( p != &BaseFontListHead )
        {
            PFLENTRY    pFlEntry;
            PLIST_ENTRY pDelete = p;
            ULONG       AlivePfeData = 0;

            pFlEntry = CONTAINING_RECORD(pDelete,FLENTRY,baseFontList);

        // if there is no linked font for this base face, try next base font.

            if(IsListEmpty(&(pFlEntry->linkedFontListHead)))
            {
                continue;
            }

        // get pointer to PFEDATA list.

            PLIST_ENTRY pp = pFlEntry->linkedFontListHead.Flink;

            FLINKMESSAGE2((DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_UNLOAD),
                          "Delete %ws link\n",pFlEntry->awcFaceName);

            while( pp != &(pFlEntry->linkedFontListHead) )
            {
                PPFEDATA     ppfeData;
                PLIST_ENTRY  ppDelete = pp;

                ppfeData = CONTAINING_RECORD(ppDelete,PFEDATA,linkedFontList);

            // Check Current FontLinkChange state to see if we can really unload
            // EUDC font.

                if( (ppfeData->FontLinkType == FONTLINK_SYSTEM &&
                     ulFontLinkChange & FLINK_UNLOAD_FACENAME_SYSTEM) ||
                    (ppfeData->FontLinkType == FONTLINK_USER   &&
                     ulFontLinkChange & FLINK_UNLOAD_FACENAME_USER))
                {
                // Remember PFE to unload font later.

                    if (MaxUnload == NumUnload) {
                        UnloadBufferNew = (PFEDATA **)PALLOCNOZ(sizeof(PFEDATA *) * MaxUnload + 10, 'dueG');
                        if (UnloadBufferNew) {
                            MaxUnload += 10;
                            memcpy(UnloadBufferNew, UnloadBuffer, sizeof(PFEDATA *) * NumUnload);
                            if (UnloadBuffer) 
                                VFREEMEM(UnloadBuffer);
                            UnloadBuffer = UnloadBufferNew;
                        }
                    }
                    if (MaxUnload > NumUnload) 
                    {
                        UnloadBuffer[NumUnload++] = ppfeData;

                        pp = ppDelete->Flink;

                        // Delete this PFEDATA from this link list

                        RemoveEntryList(ppDelete);
                    } else {
                    // This PFEDATA is still valid...

                        AlivePfeData++;
                        pp = ppDelete->Flink;
                        bRet = FALSE;
                    }
                }
                else
                {
                // This PFEDATA is still valid...

                    AlivePfeData++;
                    pp = ppDelete->Flink;
                }
            }

        // next FLENTRY...

            p = pDelete->Flink;

            if( AlivePfeData == 0 )
            {
            // Delete this FLENTRY from link list

                RemoveEntryList(pDelete);

            // Free FLENTRY

                VFREEMEM(pDelete);

            // Decrement number of facename links

                gcNumLinks--;
            }
            else
            {
                if( pFlEntry->uiNumLinks != AlivePfeData )
                {
                // Update Timestamp for this

                    pFlEntry->ulTimeStamp++;

                // Update number of linked font.

                    pFlEntry->uiNumLinks = AlivePfeData;
                }
            }
        }

        if( NumberOfLinks != gcNumLinks )
        {
        // BaseFontList has been changed, update TimeStamp

            ulFaceNameEUDCTimeStamp++;
        }

        if( gcNumLinks != 0 )
        {
        // Connect to loaded PFEs for valid FLENTRY/PFEDATA.

            vLinkEudcPFEs(NULL);
        }
    }

    GreReleaseSemaphore( ghsemEUDC1 );

// if there is no system wide eudc font.. skip it.

    if( bDeleteSystem && 
       ((LocalppfeSysEUDC[PFE_NORMAL] != NULL) || (LocalppfeSysEUDC[PFE_VERTICAL] != NULL)))
    {
    // Unload system wide eudc font

        if( !bUnloadEudcFont( LocalppfeSysEUDC ) )
        {
            WARNING("bDeleteAllFlEntry():Can not unload system wide eudc\n");
        }
    }

    for (ULONG i = 0; i < NumUnload; i++) {
        if( !bUnloadEudcFont(UnloadBuffer[i]->appfe)) {
            WARNING("bDeleteAllFlEntry():Can not unload eudc\n");
        }
        VFREEMEM(UnloadBuffer[i]);
    }

    if (UnloadBuffer) 
        VFREEMEM(UnloadBuffer);

    return(bRet);
}

/*****************************************************************************
 * NTSTATUS BuildAndLoadLinkedFontRoutine(PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID)
 *
 * This is a callback function that is called by RtlQueryRegistryValues()
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
extern "C"
NTSTATUS
BuildAndLoadLinkedFontRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{
    PWSTR FontPathName = (PWSTR) PALLOCNOZ((ValueLength + 1)*sizeof(WCHAR),'flnk');

    if (FontPathName == NULL) {
        return (STATUS_NO_MEMORY);
    }

    #if DBG
    if( gflEUDCDebug & (DEBUG_FACENAME_EUDC|DEBUG_FONTLINK_INIT) )
    {
        DbgPrint("BaseFontName - %ws : LinkedFont - %ws\n",ValueName,ValueData);
    }
    #endif

// if this is a value for System EUDC, return here...

    if(_wcsicmp(ValueName,(PWSTR)L"SystemDefaultEUDCFont") == 0)
    {
        goto FreeMem;
    }

// Copy it to local buffer and make sure its null-termination.

    RtlMoveMemory(FontPathName,ValueData,ValueLength);
    FontPathName[ValueLength/sizeof(WCHAR)] = L'\0';

// Add base font and linked font pair into global list..

// Sundown: the 3rd parameter to bAddFlEntry is iFontlinkType int
    if(!bAddFlEntry(ValueName,FontPathName,(INT)(ULONG_PTR)EntryContext,-1,NULL))
    {
        WARNING("BuildAndLoadLinkedFontRoutine():lAddFlEntry() fail\n");
    }

FreeMem:
    VFREEMEM(FontPathName);

// return STATUS_SUCCESS everytime,even we got error from above call, to
// get next enumuration.

    return(STATUS_SUCCESS);
}

/*****************************************************************************
 * NTSTATUS bAddAllFlEntryWorker(LPWSTR,INT)
 *
 *  This function load font and build link for eudc font according to registry.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
static
NTSTATUS bAddAllFlEntryWorker
(
    const WCHAR * EUDCRegistryPath,
    INT    FontLinkType       // FONTLINK_SYSTEM or FONTLINK_USER
)
{
    NTSTATUS NtStatus;

    //
    // initialize/load face name eudc
    //

    SharedQueryTable[0].QueryRoutine = BuildAndLoadLinkedFontRoutine;
    SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    SharedQueryTable[0].Name = (PWSTR)NULL;
    SharedQueryTable[0].EntryContext = (PVOID)(ULONG_PTR)FontLinkType;
    SharedQueryTable[0].DefaultType = REG_NONE;
    SharedQueryTable[0].DefaultData = NULL;
    SharedQueryTable[0].DefaultLength = 0;

    SharedQueryTable[1].QueryRoutine = NULL;
    SharedQueryTable[1].Flags = 0;
    SharedQueryTable[1].Name = (PWSTR)NULL;

    //
    // Enumurate registry values
    //

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                      EUDCRegistryPath,
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    return(NtStatus);
}

/*****************************************************************************
 * BOOL bAddAllFlEntry(BOOL,BOOL,INT)
 *
 *  This function load font and build link for eudc font according to registry.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/
static
BOOL bAddAllFlEntry
(
    BOOL bAddSystem,
    BOOL bAddFaceName
)
{
    NTSTATUS NtStatus;
    BOOL     bLoadSystem = FALSE;
    WCHAR    TempPathBuffer1[MAX_PATH];
    WCHAR    TempPathBuffer2[MAX_PATH];

    TempPathBuffer1[0] = TempPathBuffer2[0] = 0;

    FLINKMESSAGE(DEBUG_FONTLINK_INIT|DEBUG_FONTLINK_LOAD,
                 "bAddAllFlEntry():Initializing EUDC data.\n");

    //
    // make sure we are the only ones changing the EUDC data
    //

    GreAcquireSemaphore( ghsemEUDC1 );

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        //
        // another EUDC API is currently in progress
        //

        FLINKMESSAGE(DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_UNLOAD,
         " another EUDC API is currently in progress. bAddAllFlEntry() is failed.\n");            
        EngSetLastError(ERROR_LOCK_FAILED);          
        GreReleaseSemaphore( ghsemEUDC1 );
        return(FALSE);
    }

// initialize/load the system-wide ( all face-name EUDC font )

    if( bAddSystem && !IS_SYSTEM_EUDC_PRESENT() )
    {
        //
        // read registry data for System eudc
        //

        if(bReadUserSystemEUDCRegistry(TempPathBuffer1, MAX_PATH))
        {
            PPFE appfeSysEUDC[2];

            //
            // Search system-wide EUDC font. if the specified registry value does not
            // contain full path name.
            //
            // bAppendSysDirectory return TRUE, when we have to update registry data.
            // otherwise return FALSE.
            //
            // If the Eudc file is under Windows root directory (ex. WINNT) we want to
            // update registry data. because we might fail to load EUDC after user had
            // change System root with Disk Administrator.
            //

            if (!bAppendSysDirectory(TempPathBuffer2,TempPathBuffer1, MAX_PATH))
            {
                WARNING("bAddAllFlEntry: buffer too short\n");
                return FALSE;
            }
            
            //
            // NOTE :
            //
            //  Currently Systen wide EUDC does not support Type 1 Registry format.
            // See description in bAddFlEntry().
            //

            //
            // get and validate PFT user object
            //

            PUBLIC_PFTOBJ  pfto;  // access the public font table

            ASSERTGDI (
                pfto.bValid(),
                "gdisrv!bAddAllFlEntry(): could not access the public font table\n"
            );

            {
                SEMOBJ so(ghsemPublicPFT);

                //
                // Check this font is already loaded as Eudc font or not.
                //

                if( !pfto.pPFFGet(TempPathBuffer2,
                                  wcslen(TempPathBuffer2) + 1, // cwc
                                  1,                           // cFiles
                                  NULL,                        // pdv
                                  0,                           // cjDV
                                  NULL,                        // pppPFE
                                  TRUE) )                      // bEudc
                {
                    EUDCLOAD EudcLoadData;

                    //
                    // fill up EUDCLOAD structure
                    //

                    EudcLoadData.pppfeData  = appfeSysEUDC;
                    EudcLoadData.LinkedFace = NULL;

                    //
                    // load this font as eudc font.
                    //

                    LONG cFonts;  // count of fonts
                    PFF *placeHolder;

                    bLoadSystem = pfto.bLoadAFont(TempPathBuffer2,
                                                   (PULONG) &cFonts,
                                                    PFF_STATE_EUDC_FONT,
                                                    &placeHolder,
                                                    &EudcLoadData );
                }
                 else
                {
                    #if DBG
                    DbgPrint("bAddAllElEntry():%ws is loaded as EUDC already\n",
                             TempPathBuffer2);
                    #endif

                    bLoadSystem = FALSE;
                }
            }

            if( bLoadSystem )
            {
                //
                // Compute table besed on normal face
                //

                if(!bComputeQuickLookup( &gqlEUDC, appfeSysEUDC[PFE_NORMAL], TRUE ) )
                {
                    WARNING("Unable to compute QuickLookUp for system EUDC\n");

                //
                // Unload font..
                //

                    pfto.bUnloadEUDCFont(TempPathBuffer2);

                    gappfeSysEUDC[PFE_NORMAL] = NULL;
                    gappfeSysEUDC[PFE_VERTICAL] = NULL;

                    gawcEUDCPath[0] = 0;
                }
                else
                {
                    //
                    // We believe that vertical face has same glyphset as normal face.
                    //

                    //
                    // Update system wide Eudc global data..
                    //
                    
                    gappfeSysEUDC[PFE_NORMAL]   = appfeSysEUDC[PFE_NORMAL];
                    gappfeSysEUDC[PFE_VERTICAL] = appfeSysEUDC[PFE_VERTICAL];

                    wcscpy(gawcEUDCPath,TempPathBuffer2);

                    //
                    // Update global eudc timestamp.
                    //

                    ulSystemEUDCTimeStamp++;
                }
            }
             else
            {
                //WARNING("Failed to load system wide EUDC font.\n");

                gappfeSysEUDC[PFE_NORMAL]   = PPFENULL;
                gappfeSysEUDC[PFE_VERTICAL] = PPFENULL;

                gawcEUDCPath[0] = 0;
            }

            #if DBG
            if( gflEUDCDebug & (DEBUG_SYSTEM_EUDC|DEBUG_FONTLINK_INIT) )
            {
                DbgPrint("EUDC system wide %ws hpfe is %x vert hpfe is %x\n",
                          gawcEUDCPath, gappfeSysEUDC[PFE_NORMAL],
                         gappfeSysEUDC[PFE_VERTICAL]);
            }
            #endif
        }
    }

    if( bAddFaceName )
    {
        if( ulFontLinkChange & FLINK_LOAD_FACENAME_SYSTEM )
        {
            //
            // Call worker function.
            //

            NtStatus = bAddAllFlEntryWorker(EUDC_SYSTEM_REGISTRY_KEY,FONTLINK_SYSTEM);

            #if DBG
            if( !NT_SUCCESS(NtStatus) )
            {
                WARNING1("Face name eudc is disabled (FONTLINK_SYSTEM)\n");
            }
            #endif
        }

        if( ulFontLinkChange & FLINK_LOAD_FACENAME_USER )
        {
            HANDLE hKey = NULL;
            HANDLE hKeyLink = NULL;
            BOOL bIsEqual = FALSE;

            //
            // Get Registry path for Eudc..
            //

            NtStatus = GetUserEUDCRegistryPath(TempPathBuffer1, sizeof(TempPathBuffer1));
            if (NT_SUCCESS(NtStatus))
            {
                // if the registry entry is a symbolic link, fail the call
                if (bNotIsKeySymbolicLink (TempPathBuffer1, &hKey, &hKeyLink, &bIsEqual) &&
                    bIsEqual)
                {
                    //
                    // Call worker function.
                    //

                    NtStatus = bAddAllFlEntryWorker(TempPathBuffer1,FONTLINK_USER);
                }
                else
                {
                    NtStatus = (STATUS_SEVERITY_ERROR << 30);  // any non-zero error is sufficient
                }
            }

            if (hKey)
                ZwClose (hKey);
            if (hKeyLink)
                ZwClose (hKeyLink);

            #if DBG
            if( !NT_SUCCESS(NtStatus) )
            {
                WARNING1("Face name eudc is disabled (FONTLINK_USER)\n");
            }
            #endif
        }

        //
        // Connect to loaded PFEs.
        //

        vLinkEudcPFEs(NULL);
    }

    GreReleaseSemaphore( ghsemEUDC1 );

    return(TRUE);
}



/*****************************************************************************
 * BOOL bInitializeEUDC(VOID)
 *
 * This is called once during win32k.sys initialization and initializes the
 * system EUDC information.  First it creates a FLINKOBJ and set ghflEUDC to
 * it.  Then it initializes the FLINKOBJ with information from the registry.
 * After that it loads all the EUDC fonts and sets up links between base
 * font PFE's and EUDC font pfe's.
 *
 * History
 *  1-09-95 Hideyuki Nagase
 * Rewrote it.
 *
 *  2-10-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/

BOOL bInitializeEUDC(VOID)
{
    NTSTATUS NtStatus;

    FLINKMESSAGE(DEBUG_FONTLINK_INIT,
                 "bInitializeEUDC():Initializing EUDC data.\n");

    gawcEUDCPath[0] = L'\0';

// Set up Global EUDC semaphores

    if ( !(ghsemEUDC1 = GreCreateSemaphore()))
    {
        return FALSE;
    }

    if ( !(ghsemEUDC2 = GreCreateSemaphore()))
    {
        return FALSE;
    }

    // KeInitializeEvent( &gfmEUDC2, SynchronizationEvent, FALSE );

    // Set up EUDC QUICKLOOKUP Table

    gqlEUDC.puiBits = NULL;
    gqlEUDC.wcLow   = 1;
    gqlEUDC.wcHigh  = 0;

// Get Current codepage to access registry..

    USHORT usACP,usOEMCP;

    EngGetCurrentCodePage(&usOEMCP,&usACP);

// Convert Integer to Unicode string..

    UNICODE_STRING SystemACPString;

    SystemACPString.Length = 0;
    SystemACPString.MaximumLength = sizeof(gawcSystemACP);
    SystemACPString.Buffer = gawcSystemACP;

    RtlIntegerToUnicodeString( (int) usACP, 10, &SystemACPString );

    FLINKMESSAGE2(DEBUG_FONTLINK_INIT,"GDISRV:System ACP is %ws\n",gawcSystemACP);

// Read FontLink configuration value.

    SharedQueryTable[0].QueryRoutine = NULL;
    SharedQueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                RTL_QUERY_REGISTRY_DIRECT;
    SharedQueryTable[0].Name = (PWSTR)L"FontLinkControl";
    SharedQueryTable[0].EntryContext = (PVOID) &ulFontLinkControl;
    SharedQueryTable[0].DefaultType = REG_DWORD;
    SharedQueryTable[0].DefaultData = 0;
    SharedQueryTable[0].DefaultLength = 0;

    SharedQueryTable[1].QueryRoutine = NULL;
    SharedQueryTable[1].Flags = 0;
    SharedQueryTable[1].Name = (PWSTR)NULL;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"FontLink",
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        // WARNING("Error reading FontLinkControl\n");
        ulFontLinkControl = 0L;
    }

    FLINKMESSAGE2(DEBUG_FONTLINK_CONTROL,
                  "win32ksys:FontLinkControl = %x\n",ulFontLinkControl);

// initialize Eudc default char code in Unicode.

    DWORD dwEudcDefaultChar;

    SharedQueryTable[0].Name = (PWSTR)L"FontLinkDefaultChar";
    SharedQueryTable[0].EntryContext = (PVOID) &dwEudcDefaultChar;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"FontLink",
                                      SharedQueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        // WARNING("Error reading FontLinkDefaultChar\n");
        EudcDefaultChar = 0x30fb;
    }
    else
    {
        EudcDefaultChar = (WCHAR)dwEudcDefaultChar;
    }

// initialize base font list

    InitializeListHead(&BaseFontListHead);

// if FontLink feature is disabled, nothing to do.....

    if( ulFontLinkControl & FLINK_DISABLE_FONTLINK )
    {
        return TRUE;
    }

// Load and setup SYSTEM Global facename EUDC data.

    ulFontLinkChange = FLINK_LOAD_FACENAME_SYSTEM   |
                       FLINK_UNLOAD_FACENAME_SYSTEM;

// Enable only FaceName (system common) EUDC.
    bAddAllFlEntry(FALSE,TRUE);

// After load system global EUDC, we will only allow to user to
// load/unload per user eudc configuration.

    ulFontLinkChange = FLINK_LOAD_FACENAME_USER   |
                       FLINK_UNLOAD_FACENAME_USER;

// Initialize font association scheme.

    vInitializeFontAssocStatus();

    return TRUE;
}



/*****************************************************************************\
 * GreEnableEUDC( BOOL bEnable )
 *
 * This routine enable/disable system wide/face name specific EUDCs
 *
 * History:
 *  23-Jan-1995 Hideyuki Nagase
 * Wrote it.
 *****************************************************************************/

BOOL GreEnableEUDC
(
    BOOL bEnableEUDC
)
{
    BOOL bRet = TRUE;

    //
    // This quick check for non-zero ghsemEUDC1 is a work around for hydra
    // cleanup assertions
    //

    if (!ghsemEUDC1 || !ghsemEUDC2)
    {
       return TRUE;
    }

    GreAcquireSemaphore( ghsemEUDC2 );

    if( bEnableEUDC )
    {
        //
        // if DefaultLink is ready to initalize and its is not initialized,
        // do the initialization.
        //

        if( (bReadyToInitializeFontAssocDefault == TRUE ) &&
            (bFinallyInitializeFontAssocDefault == FALSE)   )
        {
            //
            // Load default linked font and fill up nessesary data fields.
            //

            if( bSetupDefaultFlEntry()) {

                //
                // Yes, we finally initialized default link font successfully.
                //

                bFinallyInitializeFontAssocDefault = TRUE;
            }
        }
    }

    if( bEnableEUDC )
    {
        //
        // Enable EUDC link.
        //
        
        bRet = bAddAllFlEntry(TRUE,TRUE);

    }
    else
    {
        // Disable EUDC link.
        
        bRet = bDeleteAllFlEntry(TRUE,TRUE);
    }
    GreReleaseSemaphore( ghsemEUDC2 );

    return(bRet);
}

/*****************************************************************************\
 * GreEudcLoadLinkW(LPWSTR,COUNT,LPWSTR,COUNT,INT,INT)
 *
 * Establishes a font file as the source of EUDC glyphs for the system.  Any
 * subsequent TextOut or GetTextMetrics related calls will reflect this
 * change immediately.
 *
 * History:
 *  13-01-95 Hideyuki Nagase
 * Rewrote it.
 *  02-10-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/
static
BOOL GreEudcLoadLinkW
(
    const WCHAR * lpBaseFaceName,   // guaranteed to be NULL terminated
    COUNT  cwcBaseFaceName,
    const WCHAR * lpEudcFontPath,   // guaranteed to be NULL terminated
    COUNT  cwcEudcFontPath,
    INT    iPriority,
    INT    iFontLinkType
)
{
    BOOL bRet = TRUE;

    ASSERTGDI(lpEudcFontPath != NULL,"GreEudcLoadLinkW():lpEudcFontPath == NULL\n");
    ASSERTGDI(cwcEudcFontPath != 0,"GreEudcLoadLinkW():cwcEudcFontPath == 0\n");

    FLINKMESSAGE(DEBUG_FONTLINK_LOAD,"GreEudcLoadLinkW\n");

    GreAcquireSemaphore( ghsemEUDC1 );
    
    //
    // if text related API's using EUDC characters are in progess we must
    // wait
    //

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        #if DBG
        if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
        {
            DbgPrint("GreEudcLoadLinkW is waiting.\n");
        }
        #endif

        // When the last text related API using EUDC characters finishes it will
        // release us.

        EngSetLastError(ERROR_LOCK_FAILED);
        GreReleaseSemaphore( ghsemEUDC1 );
        return (FALSE);
    }

    // Is this a request to load system wide eudc ?

    if( lpBaseFaceName == NULL )
    {
        WCHAR awcSystemEudcPath[MAX_PATH+1];
        PPFE  appfeNew[2];

        // Get full path name of the requested font..

        bRet = bAppendSysDirectory( awcSystemEudcPath , lpEudcFontPath, MAX_PATH );

        if (bRet)
        {
            SEMOBJ  so(ghsemPublicPFT);

            // Get and validate PFT user object

            PUBLIC_PFTOBJ  pfto;

            ASSERTGDI(pfto.bValid(),
                      "GreLoadLinkW():could not access the public font table\n");

            // check this font file is loaded as eudc already.

            if( !pfto.pPFFGet(awcSystemEudcPath,
                              wcslen(awcSystemEudcPath) + 1, // cwc
                              1,                             // cFiles
                              NULL,                          // pdv
                              0,                             // cjDV
                              NULL,                          // pppPFF
                              TRUE) )                        // bEudc
            {
                EUDCLOAD EudcLoadData;

                // fill up EUDCLOAD structure

                EudcLoadData.pppfeData  = appfeNew;
                EudcLoadData.LinkedFace = NULL;

                // load font..

                ULONG cFonts;
                PFF   *placeHolder;

                bRet = pfto.bLoadAFont( awcSystemEudcPath,
                                        (PULONG) &cFonts,
                                        PFF_STATE_EUDC_FONT,
                                        &placeHolder,
                                        &EudcLoadData);
            }
             else
            {
                //
                // this font file is already loaded as EUDC..
                //

                #if DBG
                DbgPrint("GreLoadLinkW():%ws is loaded as EUDC already\n",
                         awcSystemEudcPath);
                #endif

                bRet = FALSE;
            }
        }

        if( bRet )
        {
            //
            // now we can load new system wide eudc font..
            // if we have system wide eudc font, deactivate and unload it..
            //

            if( IS_SYSTEM_EUDC_PRESENT() )
            {
                //
                // disable the link of all facename and system wide eudc.
                //

                vUnlinkAllEudcRFONTsAndPFEs(TRUE,FALSE);

                //
                // Unload system wide eudc font
                //

                bUnloadEudcFont( gappfeSysEUDC );
            }

            //
            // set new system wide eudc data to global variable.
            //
            
            gappfeSysEUDC[PFE_NORMAL]   = appfeNew[PFE_NORMAL];
            gappfeSysEUDC[PFE_VERTICAL] = appfeNew[PFE_VERTICAL];

            wcscpy(gawcEUDCPath,awcSystemEudcPath);

            //
            // Update global eudc timestamp.
            //

            ulSystemEUDCTimeStamp++;

            //
            // Finally compute the QuickLookup structure for the system EUDC font
            //

            if(!bComputeQuickLookup( &gqlEUDC, appfeNew[PFE_NORMAL], TRUE ))
            {
                WARNING("GreLoadLinkW:Unable to compute QuickLookUp for system EUDC\n");
            }


            //

            //
            // Update registry data.
            //

            FLINKMESSAGE(DEBUG_FONTLINK_LOAD,"GreLoadLinkW():Eudc Path %ws is Saved\n");

            if( !bWriteUserSystemEUDCRegistry(gawcEUDCPath, wcslen(gawcEUDCPath)+1) )
            {
                WARNING("Unable to write new link to registry.\n");
            }
        }
         else
        {
            //
            // Fail to load ...
            //

            #if DBG
            DbgPrint("GreLoadLinkW():%ws is could not be loaded\n",awcSystemEudcPath);
            #endif
        }
    }
     else
    {
        PFLENTRY pFlEntry;

        //
        // if we got invalid fontlink type, just force change to FONTLINK_USER
        //

        if( (iFontLinkType != FONTLINK_SYSTEM) &&
            (iFontLinkType != FONTLINK_USER  )    )
        {
            iFontLinkType = FONTLINK_USER;
        }

        //
        // this is request for facename link.
        //

        bRet = bAddFlEntry(lpBaseFaceName,lpEudcFontPath,iFontLinkType,iPriority,
                           &pFlEntry);

        if( bRet )
        {
            //
            // check new FLENTRY is allocated or not.
            //

            if( pFlEntry != NULL )
            {
                //
                // if new FLENTRY is allocated, Update base font's PFE.
                // Connect to loaded PFEs.
                //
                vLinkEudcPFEs( pFlEntry );
            }
        }
    }

    GreReleaseSemaphore( ghsemEUDC1 );
    return(bRet);
}

/*****************************************************************************
 * GreEudcUnloadLinkW()
 *
 * Unloads the current system wide EUDC link.  Subsequent TextOut or
 * GetTextMetrics related calls will reflect this immediately.
 *
 * History
 *  26-01-95 Hideyuki Nagase
 * Rewrote it.
 *   4-01-93 Gerrit van Wingerden
 * Wrote it.
 *****************************************************************************/
static
BOOL GreEudcUnloadLinkW
(
    const WCHAR * lpBaseFaceName,
    COUNT  cwcBaseFaceName,
    const WCHAR * lpEudcFontPath,
    COUNT  cwcEudcFontPath
)
{
    BOOL bRet = TRUE;

    FLINKMESSAGE(DEBUG_FONTLINK_UNLOAD, "GreEudcUnloadLinkW()....\n");


    GreAcquireSemaphore( ghsemEUDC1 );

    //
    // if text related API's using EUDC characters are in progess we must
    // wait
    //

    ASSERTGDI(gcEUDCCount >= 0, "gcEUDCCount < 0");

    if (gcEUDCCount > 0)
    {
        #if DBG
        if( gflEUDCDebug & DEBUG_FONTLINK_LOAD )
        {
            DbgPrint("GreEudcLoadLinkW is waiting.\n");
        }
        #endif

        // When the last text related API using EUDC characters finishes it will
        // release us.

        EngSetLastError(ERROR_LOCK_FAILED);
        GreReleaseSemaphore( ghsemEUDC1 );
        return (FALSE);

    }

    //
    // Is this a request to load system wide eudc ?
    //

    if( lpBaseFaceName == NULL )
    {
        //
        // if we have system wide eudc font, deactivate and unload it..
        //

        if( IS_SYSTEM_EUDC_PRESENT() )
        {
            //
            // disable the link of all facename and system wide eudc.
            //

            vUnlinkAllEudcRFONTsAndPFEs(TRUE,FALSE);

            //
            // Unload system wide eudc font
            //

            bUnloadEudcFont( gappfeSysEUDC );

            //
            // set new system wide eudc data to global variable.
            //

            gappfeSysEUDC[PFE_NORMAL]   = NULL;
            gappfeSysEUDC[PFE_VERTICAL] = NULL;

            gawcEUDCPath[0] = 0;

            //
            // Update global eudc timestamp.
            //

            ulSystemEUDCTimeStamp++;

            if( !bWriteUserSystemEUDCRegistry(L"\0",1) )
            {
                WARNING("Unable to write new link to registry.\n");
            }
        }
    }
     else
    {
        ASSERTGDI(lpBaseFaceName != NULL,"GreEudcLoadLinkW():lpBaseFaceName == NULL\n");
        ASSERTGDI(cwcBaseFaceName != 0,"GreEudcLoadLinkW():cwcBaseFaceName == 0\n");

        ASSERTGDI(lpEudcFontPath != NULL,"GreEudcLoadLinkW():lpEudcFontPath == NULL\n");
        ASSERTGDI(cwcEudcFontPath != 0,"GreEudcLoadLinkW():cwcEudcFontPath == 0\n");

        //
        // this is a request for facename link Eudc.
        //

        bRet = bDeleteFlEntry(lpBaseFaceName,lpEudcFontPath,FONTLINK_USER);

        //
        // if above call is failed, try FONTLINK_SYSTEM....
        //

        if( !bRet )
            bRet = bDeleteFlEntry(lpBaseFaceName,lpEudcFontPath,FONTLINK_SYSTEM);
    }

    //
    // Let others use EUDC characters again
    //

    GreReleaseSemaphore( ghsemEUDC1 );
    return(bRet);
}

/*****************************************************************************
 * ULONG NtGdiGetEudcTimeStampEx
 *
 * Shared kernel mode entry point for GetEudcTimeStamp and GetEudcTimeStampEx
 *
 * History
 *  3-28-96 Gerrit van Wingerden [gerritv]
 * Wrote it.
 ****************************************************************************/

extern "C" ULONG NtGdiGetEudcTimeStampEx
(
    LPWSTR lpBaseFaceName,
    ULONG  cwcBaseFaceName,
    BOOL   bSystemTimeStamp
)
{
    WCHAR awcBaseFaceName[LF_FACESIZE+1];
    ULONG ulRet = 0;

    if(bSystemTimeStamp)
    {
        return(ulSystemEUDCTimeStamp);
    }
    else
    if((lpBaseFaceName == NULL) || (cwcBaseFaceName == 0))
    {
        return(ulFaceNameEUDCTimeStamp);
    }

    if(cwcBaseFaceName <= LF_FACESIZE)
    {

        __try
        {
            ProbeForRead(lpBaseFaceName,cwcBaseFaceName*sizeof(WCHAR),sizeof(WCHAR));
            RtlCopyMemory(awcBaseFaceName,lpBaseFaceName,
                          cwcBaseFaceName * sizeof(WCHAR));

            awcBaseFaceName[cwcBaseFaceName] = L'\0';
            ulRet = 0;

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(3100);
        }

        if(ulRet)
        {
            GreAcquireSemaphore( ghsemEUDC1 );

            PFLENTRY pFlEntry;

            if( (pFlEntry = FindBaseFontEntry(awcBaseFaceName)) != NULL )
            {
                ulRet = pFlEntry->ulTimeStamp;
            }
            else
            {
                ulRet = 0;
            }

            GreReleaseSemaphore( ghsemEUDC1 );
        }
    }
    else
    {
        WARNING("NtGdiGetEudcTimeStampEx: Facename too big\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(ulRet);
}




/******************************************************************************
 * VOID vDrawGlyph( BYTE, UINT, GLYPHPOS )
 *
 * This routine draws a single glyph to a monochrome bitmap.  It was stolen
 * from textblt.cxx and modified to be faster since clipping doesn't come in
 * to play in GetStringBitmapW.
 *
 * History:
 *  5-18-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

static const BYTE ajMask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE};

static
VOID vDrawGlyph(
     BYTE     *pjBits, // pointer to base of bitmap bits
     UINT     cjScan,  // size of a scan line
     GLYPHPOS *pgp     // glyph bits and location.
)
{
    GLYPHBITS *pgb = pgp->pgdf->pgb;

    ULONG cx = (ULONG) pgb->sizlBitmap.cx;
    ULONG cy = (ULONG) pgb->sizlBitmap.cy;
    if (cx == 0 || cy == 0)
        return;

    ULONG cjScanSrc = (cx + 7) >> 3;

    PBYTE pjSrcHolder = pgb->aj;

    ULONG xDst = pgp->ptl.x;
    ULONG yDst = pgp->ptl.y;

    PBYTE pjDstHolder  = pjBits;
    pjDstHolder += (yDst * cjScan );
    pjDstHolder += (xDst >> 3);

    // Set the source bits into the mono dib.
    // We can make use of the fact that either xSrcDib or xDstDib is 0.

    PBYTE pjDst;
    PBYTE pjSrc;
    if( !(xDst & 0x7) )
    {
    // Handle the simple case where xDib is byte-alligned

        do
        {
            ULONG cBytes = cx >> 3;

            pjSrc = pjSrcHolder;
            pjDst = pjDstHolder;

            pjSrcHolder += cjScanSrc;
            pjDstHolder += cjScan;

            while (cBytes--)
                *pjDst++ |= *pjSrc++;

            // Do the last partial byte.

            if (cx & 0x7)
                *pjDst |= *pjSrc & ajMask[cx & 0x7];
        } while (--cy);
    }
    else // if (xDstDib)
    {
    // Handle the case where xDstDib is not byte-aligned.

        int cShift = (int) xDst & 0x7;
        do
        {
            ULONG cBytes = ((xDst + cx) >> 3) - (xDst >> 3);

            pjSrc = pjSrcHolder;
            pjDst = pjDstHolder;

            pjSrcHolder += cjScanSrc;
            pjDstHolder += cjScan;

            WORD wSrc = (WORD) (*pjSrc++);
            while (cBytes--)
            {
            *pjDst++ |= (BYTE) (wSrc >> cShift);
            // don't read beyond src limit!
            if (pjSrc == pjSrcHolder)
                wSrc = (wSrc << 8);
            else
                wSrc = (wSrc << 8) | (WORD) (*pjSrc++);
            }

            // Do the last partial byte.
            if ((xDst + cx) & 0x7)
            *pjDst |= (BYTE) (wSrc >> cShift) & ajMask[(xDst+cx) & 0x7];
        } while (--cy);
    }
}

/******************************************************************************
 * VOID vStringBitmapTextOut( STROBJ, BYTE, UINT )
 *
 * This routine draws a STROBJ to a monochrome bitmap.  It is essentially
 * EngTextOut but much faster since it doesn't have to wory about opaqueing,
 * clipping, simulated rects, etc.
 *
 * History:
 *  9-19-95 Hideyuki Nagase [hideyukn]
 * Rewrote it.
 *
 *  5-18-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/
static
VOID vStringBitmapTextOut(
    STROBJ *pstro,  // Pointer to STROBJ.
    BYTE   *pjBits, // Pointer to buffer to store glyph image.
    UINT    cjScan  // Size of buffer.
)
{
    BOOL     bMoreGlyphs;
    GLYPHPOS *pgp = (GLYPHPOS*)NULL;
 
    LONG xAdjust = ( pstro->rclBkGround.left > 0 ) ? 0 : pstro->rclBkGround.left;
    LONG yAdjust = pstro->rclBkGround.top;

    ((ESTROBJ*)pstro)->vEnumStart();

    if( pstro->pgp == (GLYPHPOS *) NULL )
    {
        ULONG cGlyph;
        bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);
    }
    else
    {
        pgp    = pstro->pgp;
        bMoreGlyphs = FALSE;
    }

    ASSERTGDI(bMoreGlyphs == FALSE,"vStringBitmapTextOut() bMoreGlyphs is TRUE.\n");

    // Saw this on FE stress
    // ASSERTGDI(pgp, "vStringBitmapTextOut() STROBJ_bEnum returns NULL pgp.\n");

    // fail textout if pgp == NULL
    if (pgp)
    {
        GLYPHBITS *pgb = pgp[0].pgdf->pgb;

        pgp[0].ptl.x += pgb->ptlOrigin.x - xAdjust;
        pgp[0].ptl.y += pgb->ptlOrigin.y - yAdjust;

        //
        // Blt the glyph into the bitmap
        //
        vDrawGlyph( pjBits, cjScan, &pgp[0] );
    }
}

/******************************************************************************
 * UINT GreGetStringBitmapW
 *
 * This routine does a kindof fast text out ( with restrictions ) to a monochrome
 * bitmap.
 *
 * History:
 *  9-19-95 Hideyuki Nagase [hideyukn]
 * Rewrote it.
 *
 *  5-18-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *****************************************************************************/

UINT GreGetStringBitmapW(
    HDC            hdc,
    LPWSTR         pwsz,
    UINT           cwc,      // should be 1....
    LPSTRINGBITMAP lpSB,
    UINT           cj,
    UINT          *puiOffset // not used...
)
{
// Parameter check, early out...

    if( cwc != 1 )
    {
        WARNING("GreGetStringBitmap only works when char count is 1.\n");
        return(0);
    }

    if( puiOffset != 0 && *puiOffset != 0 )
    {
        WARNING("GreGetStringBitmap only works when offset is 0.\n");
        return(0);
    }

// Lock the DC and set the new attributes.

    DCOBJ dco(hdc);         // Lock the DC.

    if (!dco.bValid())      // Check if it's good.
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

// Get the transform from the DC.

    EXFORMOBJ xo(dco,WORLD_TO_DEVICE);


// we only allow identity transforms for GetStringBitmap

    if( !xo.bIdentity() )
    {
        WARNING("GreGetStringBitmap only works with identity WtoD xforms.\n");
        return(0);
    }


// Locate the font cache.

    RFONTOBJ rfo(dco,FALSE);

    if (!rfo.bValid())
    {
        WARNING("gdisrv!GreGetStringBitmap(): could not lock RFONTOBJ\n");
        return (0);
    }

// GetStringBitmap doesn't support vector fonts.

    if( rfo.bPathFont() )
    {
        WARNING("gdisrv!GetStringBitmap() : vector fonts aren't supported.\n");
        return(0);
    }


// GetStringBitmap doesn't support sny rotations.

    if((dco.pdc->lEscapement() | rfo.ulOrientation() ) != 0)
    {
        WARNING("gdisrv!GreGetStringBitmap(): Text isn't Horizontal.\n" );
        return(0);
    }

// Initialize ESTROBJ. Compute glyph layout positions.

    ESTROBJ to; to.vInitSimple(pwsz,cwc,dco,rfo,0L,0L,NULL);

    if (!to.bValid())
    {
        WARNING("gdisrv!GetStringBitmap() : could not lock ESTROBJ.\n");
        return(0);
    }


// Compute the target string rectangle.

    UINT uiWidth  = (UINT)( to.rclBkGround.right - to.rclBkGround.left );
    UINT uiHeight = (UINT)( to.rclBkGround.bottom - to.rclBkGround.top );


// Offset the width by the C space of the last character and the A space of
// the first character to get the true extent

    GLYPHDATA *pgd;
    EGLYPHPOS    *pg = (EGLYPHPOS*)to.pgpGet();

    pgd = pg->pgd();
    uiWidth +=  FXTOL(pgd->fxA);
    pg = &pg[to.cGlyphsGet()-1];
    pgd = pg->pgd();
    uiWidth +=  FXTOL((pgd->fxD-pgd->fxAB));


// compute width of scanline in bytes ( must be byte alligned )

    UINT  cjScan = (uiWidth + 7) / 8;
    UINT  cjSize = offsetof(STRINGBITMAP,ajBits) + (cjScan * uiHeight);
    PBYTE pjBits = lpSB->ajBits;


// If the user only want the size return now.
// And check the buffer is enough to store glyph image

    if( cj < cjSize ) return( cjSize );

// Clear the target buffer.

    RtlZeroMemory( pjBits, cjScan * uiHeight );

// Fill up its bitmap size...

    lpSB->uiHeight = uiHeight;
    lpSB->uiWidth  = uiWidth;


// adjust the baseline of the Sys EUDC for win 3.1 compatability

    POINTL   ptlBaseLineAdjust = {0,0};
    LONG     lFontType        = EUDCTYPE_BASEFONT;

    PRFONT pLinkedRfont = NULL;

// Is the character linked one ?

    if( to.bLinkedGlyphs() )
    {

    // Setup its font type...

        lFontType = *(LONG *)(to.plPartitionGet());

    // Get corresponding RFONT with current linked font.

        switch (lFontType)
        {
        case EUDCTYPE_SYSTEM_WIDE:
            pLinkedRfont = rfo.prfntSysEUDC();
            break;
        case EUDCTYPE_SYSTEM_TT_FONT:
            pLinkedRfont = rfo.prfntSystemTT();
            break;
        case EUDCTYPE_DEFAULT:
            pLinkedRfont = rfo.prfntDefEUDC();
            break;
        case EUDCTYPE_BASEFONT:
        // it's possible for this to be the case since the EUDC character
        // could have been a singular character or a blank character in which
        // case we will have already have set flags saying we have linked
        // glyphs but in actuality will grab the default glyph from the base font
            break;
        default:
            ASSERTGDI(lFontType >= EUDCTYPE_FACENAME,
                  "GDISRV:GreGetStringBitmapW() Error lFontType\n");
            pLinkedRfont = rfo.prfntFaceName(lFontType - EUDCTYPE_FACENAME);
            break;
        }

    // Is the RFONT is valid ?

        if( pLinkedRfont != NULL )
        {
            RFONTTMPOBJ rfoLink(pLinkedRfont);

            //
            // Compute baseline diffs.
            //
            // *** Base font Height == Linked font Height ***
            //
            //   Base font  EUDC font         Base font  EUDC font
            //
            //              -------
            //    -------   |     |            -------   -------
            //    |     |   |     |   ----->   |     |   |     |
            //    | 15  |   | 20  |            | 15  |   | 15  |
            //    |     |   |     |            |     |   |     |
            //  -------------------- BaseLine ---------------------
            //    |  5  |                      |  5  |   |  5  |
            //    -------                      -------   -------
            //
            // *** Base font Ascent >= Linked font Height ****
            //
            //   Base font  EUDC font         Base font  EUDC font
            //
            //    -------                      -------
            //    |     |                      |     |   -------
            //    |     |   -------   ----->   |     |   |     |
            //    | 20  |   | 10  |            | 20  |   | 15  |
            //    |     |   |     |            |     |   |     |
            //  -------------------- BaseLine ---------------------
            //    |  5  |   |  5  |            |  5  |
            //    -------   -------            -------
            //
            // *** Others ****
            //
            //  TBD.
            //
            if( rfo.fxMaxAscent() >= (rfoLink.fxMaxAscent() - rfoLink.fxMaxDescent()) )
            {
                ptlBaseLineAdjust.y = (rfoLink.fxMaxDescent() >> 4);
            }
             else
            {
                ptlBaseLineAdjust.y = (rfoLink.fxMaxAscent() - rfo.fxMaxAscent()) >> 4;
            }

            //
            // if we need to adjust baseline, force emulation....
            //
            if( ptlBaseLineAdjust.y ) to.pgpSet(NULL);

        }
    }

 // Set current font type.

    to.vFontSet(lFontType);

    RFONTTMPOBJ rfoLink(pLinkedRfont);

    if(pLinkedRfont)
    {
        to.prfntSet( &rfoLink );
    }

 // Set base line adjustment delta.

    to.ptlBaseLineAdjustSet( ptlBaseLineAdjust );

// Draw the glyph

    vStringBitmapTextOut( (STROBJ*)&to, pjBits, cjScan );

    return( cj );
}

BOOL bAdjusBaseLine(RFONTOBJ &rfoBase, RFONTOBJ &rfoLink, POINTL *pptlAdjustBaseLine)
{
    BOOL    bRet = FALSE;

// special case of the bitmap font, the heights are the same

    if ((rfoBase.fxMaxAscent() - rfoBase.fxMaxDescent()) ==
        (rfoLink.fxMaxAscent() - rfoLink.fxMaxDescent()))
    {
        pptlAdjustBaseLine->x  = FXTOLFLOOR((rfoBase.ptfxMaxAscent().x - rfoLink.ptfxMaxAscent().x));
        pptlAdjustBaseLine->y  = FXTOLFLOOR((rfoBase.ptfxMaxAscent().y - rfoLink.ptfxMaxAscent().y));

        if (pptlAdjustBaseLine->y || pptlAdjustBaseLine->x)
            bRet = TRUE;
    }

    return bRet;

}

/*******************************************************************************
 * void AdjustBoundingBox(RFONTOBJ&, RFONTOBJ&, POINTFIX*, ERECTL*)
 *
 * This function adjusts the baseline of the EUDC font in a way that is
 * Win 3.1 compatible according to the following rules:
 *
 *
 *  Base font Height == Linked font Height ***
 *
 *   Base font  EUDC font         Base font  EUDC font
 *
 ******************************************************************************/
static
void AdjustBoundingBox(
    RFONTOBJ &rfoBase,
    RFONTOBJ &rfoLink,
    FIX      *fxAdjustDeltaAsc, 
    FIX      *fxAdjustDeltaDsc,
    POINTFIX *ptfxDeltaAsc,
    POINTFIX *ptfxDeltaDsc
)
{


    FIX     fxDeltaDsc, fxDeltaAsc;

    fxDeltaDsc =  rfoBase.fxMaxDescent() - rfoLink.fxMaxDescent();

    fxDeltaAsc =  -(rfoBase.fxMaxAscent() - rfoLink.fxMaxAscent());

// There is no internal leading in base font, most likely BMP case.
// In this case we will adjust the baseline (the exact height match)
// so that it will not be necessary to adjust the bounding box

    if ((fxDeltaDsc + fxDeltaAsc) == 0)
        return;

    if (fxDeltaDsc < 0)
        fxDeltaDsc = 0;

    if(fxDeltaAsc < 0)
        fxDeltaAsc = 0;

    if(!fxDeltaAsc  && !fxDeltaDsc  )
        return;

// eAu = (0, -1)
// dA = eA * eAu = (x1, y1)
// dD = -eD * eDu = (x2, y2)

    if (fxDeltaDsc > *fxAdjustDeltaDsc)
    {
        *fxAdjustDeltaDsc = fxDeltaDsc;
        ptfxDeltaDsc->x  = -(rfoBase.ptfxMaxDescent().x - rfoLink.ptfxMaxDescent().x);
        ptfxDeltaDsc->y  = -(rfoBase.ptfxMaxDescent().y - rfoLink.ptfxMaxDescent().y);
    }

    if (fxDeltaAsc > *fxAdjustDeltaAsc)
    {
        *fxAdjustDeltaAsc = fxDeltaAsc;
        ptfxDeltaAsc->x  = -(rfoBase.ptfxMaxAscent().x - rfoLink.ptfxMaxAscent().x);
        ptfxDeltaAsc->y  = -(rfoBase.ptfxMaxAscent().y - rfoLink.ptfxMaxAscent().y);
    }

}



VOID ESTROBJ::vEudcOpaqueArea(POINTFIX *aptfxBackground, BOOL bComplexBackground )
{
    FIX         fxDeltaAsc = 0; 
    FIX         fxDeltaDsc = 0;
    POINTFIX    ptfxDeltaAsc = {0, 0};
    POINTFIX    ptfxDeltaDsc = {0, 0};

    for(LONG lFont = EUDCTYPE_BASEFONT ;
             lFont < (EUDCTYPE_FACENAME + (LONG) prfo->uiNumFaceNameLinks()) ;
             lFont++ )
    {
        RFONTTMPOBJ rfoLink;

        switch( lFont )
        {
        case EUDCTYPE_BASEFONT:

            break;

        case EUDCTYPE_SYSTEM_TT_FONT:

            if(cTTSysGlyphs)
            {
                rfoLink.vInit(prfo->prfntSystemTT());
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }
         break;

        case EUDCTYPE_SYSTEM_WIDE:

            if( cSysGlyphs )
            {
                rfoLink.vInit( prfo->prfntSysEUDC() );
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }

            break;

        case EUDCTYPE_DEFAULT:

            if( cDefGlyphs)
            {
                rfoLink.vInit( prfo->prfntDefEUDC() );
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }

            break;


        default:

            if( pacFaceNameGlyphs && pacFaceNameGlyphs[lFont-EUDCTYPE_FACENAME])
            {
                rfoLink.vInit(prfo->prfntFaceName(lFont - EUDCTYPE_FACENAME));
                AdjustBoundingBox(*prfo,rfoLink, &fxDeltaAsc, &fxDeltaDsc, 
                        &ptfxDeltaAsc, &ptfxDeltaDsc);
            }

            break;
        }
    }

    if (fxDeltaAsc || fxDeltaDsc)
    {
        LONG    lDeltaL, lDeltaR, lDeltaT, lDeltaB;
        RECTL   rclInflate = rclBkGround;

    // dLeft = min(x1, x2)
    // dRight = max(x1, x2)
    // dTop = min(y1, y2)
    // dBottom = max(y1, y2)
    

        lDeltaL = FXTOLFLOOR(min(ptfxDeltaAsc.x, ptfxDeltaDsc.x));
        lDeltaR = FXTOLCEILING(max(ptfxDeltaAsc.x, ptfxDeltaDsc.x));
        lDeltaT = FXTOLFLOOR(min(ptfxDeltaAsc.y, ptfxDeltaDsc.y));
        lDeltaB = FXTOLCEILING(max(ptfxDeltaAsc.y, ptfxDeltaDsc.y));

        rclInflate.left    += lDeltaL;
        rclInflate.right   += lDeltaR;
        rclInflate.top     += lDeltaT;
        rclInflate.bottom  += lDeltaB;

        if (rclInflate.top < rclBkGround.top)
            rclBkGround.top = rclInflate.top;
        if (rclInflate.bottom > rclBkGround.bottom)
            rclBkGround.bottom = rclInflate.bottom;
        if (rclInflate.left < rclBkGround.left)
            rclBkGround.left = rclInflate.left;
        if (rclInflate.right > rclBkGround.right)
            rclBkGround.right = rclInflate.right;

    // for the order of points in the bounding paralelogram look at textobj.cxx
    // we go around clockwise ie tl, tr, br, bl

        if (bComplexBackground)
        {
            if (fxDeltaAsc)
            {
                aptfxBackground[0].x += ptfxDeltaAsc.x;
                aptfxBackground[0].y += ptfxDeltaAsc.y;
                aptfxBackground[1].x += ptfxDeltaAsc.x;
                aptfxBackground[1].y += ptfxDeltaAsc.y;
            }
    
            if (fxDeltaDsc)
            {
                aptfxBackground[2].x += ptfxDeltaDsc.x;
                aptfxBackground[2].y += ptfxDeltaDsc.y;
                aptfxBackground[3].x += ptfxDeltaDsc.x;
                aptfxBackground[3].y += ptfxDeltaDsc.y;
            }

        }
    }

}

static
BOOL bOutOfBounds(STROBJ *pstro, RFONTOBJ *prfo)
{
    COUNT cGlyph;
    BOOL bMoreGlyphs;
    GLYPHPOS *pgp;
    BOOL bRet = FALSE;

    if((*((LONG*) &(prfo->pfdx()->eXY)) == 0 && *((LONG*)&(prfo->pfdx()->eYX)) == 0))
    {
    // fast out for horizontal cases
        return(FALSE);
    }

    do
    {
        bMoreGlyphs = STROBJ_bEnum(pstro,&cGlyph,&pgp);

        if(cGlyph)
        {
            LONG xL, xR, yT, yB;
            ULONG ii;
            for (ii=0; ii<cGlyph; ii++)
            {
            // for device font pgb will be NULL so don't do the check

                if(pgp[ii].pgdf->pgb)
                {
                    xL = pgp[ii].ptl.x + pgp[ii].pgdf->pgb->ptlOrigin.x;
                    xR = xL + pgp[ii].pgdf->pgb->sizlBitmap.cx;
                    yT = pgp[ii].ptl.y + pgp[ii].pgdf->pgb->ptlOrigin.y;
                    yB = yT + pgp[ii].pgdf->pgb->sizlBitmap.cy;

                    if( (xL < pstro->rclBkGround.left) ||
                       (xR > pstro->rclBkGround.right) ||
                       (yT < pstro->rclBkGround.top) ||
                       (yB > pstro->rclBkGround.bottom) )
                    {
                        bRet = TRUE;
                        break;
                    }
                }
            }
        }
    } while(bMoreGlyphs);

// reset it for the text out call

    STROBJ_vEnumStart(pstro);

    return(bRet);
}


/******************************************************************************
 * BOOL bProxyDrvTextOut()
 *
 * This routine takes the place of a DrvTextOut in the case when there are EUDC
 * characters in the ESTROBJ.  It partitions the call into mutliple DrvTextOut
 * calls, one for each font int the string.
 *
 * Partitioning information is stored in an array of LONGS in the RFONTOBJ.        
 * The i'th entry in the array tells what font the i'th glyph in the ESTROBJ
 * belongs to.
 *
 * History:
 *  7-14-93 Gerrit van Wingerden [gerritv]
 * Rewrote it to handle multiple face name links and just be better.
 *  2-10-93 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 *****************************************************************************/

// This routine is used to partition calls to the driver if there are EUDC
// characters in the string.

BOOL bProxyDrvTextOut
(
    XDCOBJ&   dco,
    SURFACE  *pSurf,
    ESTROBJ&  to,
    ECLIPOBJ& co,
    RECTL    *prclExtra,
    RECTL    *prclBackground,
    BRUSHOBJ *pboFore,
    BRUSHOBJ *pboOpaque,
    POINTL   *pptlBrushOrg,
    RFONTOBJ& rfo,
    PDEVOBJ   *pdo,
    FLONG     flCaps,
    RECTL    *prclExclude
)
{
    RFONTOBJ *prfoSave;
    LONG *plPartition, *plPartitionEnd;
    COUNT cTotalGlyphs = 0;
    LONG lInflatedMax = 0;
    WCHAR *pwcPartition, *pwcTmp, *pwcSave, *pwcSource;
    ULONG cNumGlyphs = to.cGlyphsGet();
    POINTL ptlAdjustBaseLine;
    BOOL    bSkip = FALSE;

    prfoSave = to.prfo;

    BOOL bRet = TRUE;

    pwcPartition = to.pwcPartitionGet();

// now partition the EUDC glyphs by font

    pwcSave = to.pwszGet();

// set to NULL to force enumeration

    to.pgpSet( NULL );

// This code is only for NT bug #414953
// If the base font is stroke base then we would not allow to render the linked TT font

    if ((rfo.prfnt->flInfo & FM_INFO_TECH_STROKE) &&
         rfo.iGraphicsMode() == GM_COMPATIBLE)
    {
        if ((dco.pdc->lEscapement() != (LONG) rfo.prfnt->ulOrientation))
            bSkip = TRUE;
    }
       
// Turn off acclerators since we'll seriously munge the properties of the string object.
// also clear the ulCharInc value since the tga driver won't work properly if it's
// set

    to.flAccelSet( 0 );
    to.vClearCharInc();

    for(LONG lFont = EUDCTYPE_BASEFONT ;
             lFont < (EUDCTYPE_FACENAME + (LONG) rfo.uiNumFaceNameLinks()) ;
             lFont++ )
    {
        RFONTTMPOBJ rfoLink;
        RFONTOBJ   *prfoLink;
        UINT        ii;
        COUNT       cLinkedGlyphs;

        switch( lFont )
        {
        case EUDCTYPE_BASEFONT:

        // If there aren't any glyphs in the base font just draw the
        // opaque rectangle.  We must draw the opaque rectangle here
        // because the linked glyphs don't neccesarily fit into the
        // the opaque rectangle.  Passing such a rectangle to a driver
        // can cause unexpected results.

            cLinkedGlyphs = to.cSysGlyphsGet() + to.cDefGlyphsGet() +
              to.cTTSysGlyphsGet();

            for(  ii = 0; ii < rfo.uiNumFaceNameLinks(); ii++ )
            {
                cLinkedGlyphs += to.cFaceNameGlyphsGet( ii );
            }

            if( cLinkedGlyphs == cNumGlyphs )
            {

            // Draw the opaque rectangle here if there is one

                ASSERTGDI(prclExclude, "bProxyDrvTextOut: prclExclude is NULL\n");
                if(prclBackground != NULL)
                {
                    co.erclExclude().left =
                      max(prclExclude->left,prclBackground->left);

                    co.erclExclude().right =
                      min(prclExclude->right,prclBackground->right);

                    co.erclExclude().top =
                      max(prclExclude->top,prclBackground->top);
                    co.erclExclude().bottom =
                      min(prclExclude->bottom,prclBackground->bottom);
                }

            // if not clipped, Just paint the rectangle.

                if ((co.erclExclude().left < co.erclExclude().right) &&
                    (co.erclExclude().top < co.erclExclude().bottom) &&
                    prclBackground != NULL )
                {
                    INC_SURF_UNIQ(pSurf);

                    TextOutBitBlt
                    (
                        pSurf,
                        rfo,
                        (SURFOBJ *)  NULL,      // Source surface.
                        (SURFOBJ *)  NULL,      // Mask surface.
                        &co,                    // Clip object.
                        (XLATEOBJ *) NULL,      // Palette translation object.
                        prclBackground,         // Destination rectangle.
                        (POINTL *)  NULL,       // Source origin.
                        (POINTL *)  NULL,       // Mask origin.
                        (BRUSHOBJ *) pboOpaque, // Realized opaque brush.
                        pptlBrushOrg,           // brush origin
                        0x0000f0f0              // PATCOPY
                    );
                }

                co.erclExclude() = *prclExclude;

            // set prclBackground to NULL since we have just drawn it

                prclBackground = NULL;

                continue;
            }

            prfoLink = &rfo;


            FLINKMESSAGE(DEBUG_FONTLINK_TEXTOUT,"Doing base font.\n");
            break;

        case EUDCTYPE_SYSTEM_TT_FONT:

            if(bSkip || (to.cTTSysGlyphsGet() == 0))
            {
                continue;
            }

            rfoLink.vInit(rfo.prfntSystemTT());
            prfoLink = (RFONTOBJ *) &rfoLink;

         break;

        case EUDCTYPE_SYSTEM_WIDE:

            if(bSkip || (to.cSysGlyphsGet() == 0))
            {
                continue;
            }

            rfoLink.vInit( rfo.prfntSysEUDC() );
            prfoLink = (RFONTOBJ *) &rfoLink;

            break;

        case EUDCTYPE_DEFAULT:

            if(bSkip || (to.cDefGlyphsGet() == 0) )
            {
                continue;
            }

            rfoLink.vInit( rfo.prfntDefEUDC() );
            prfoLink = (RFONTOBJ *) &rfoLink;
            break;


        default:

            if( bSkip ||  (to.cFaceNameGlyphsGet( lFont-EUDCTYPE_FACENAME ) == 0) )
            {
                continue;
            }

            rfoLink.vInit(rfo.prfntFaceName(lFont - EUDCTYPE_FACENAME));
            prfoLink = (RFONTOBJ *) &rfoLink;
            break;
        }

    // Loop through all the glyphs in the TextObj using plPartition to
    // and construct a wchar array to match this textobj.

        for( plPartition = to.plPartitionGet(),plPartitionEnd = &plPartition[cNumGlyphs],
             pwcSource = pwcSave, pwcTmp = pwcPartition;
             plPartition < plPartitionEnd;
             plPartition += 1, pwcSource += 1 )
        {
            if( *plPartition == lFont )
            {
                *pwcTmp++ = *pwcSource;
            }
        }

    // Keep track of the total glyphs drawn so far so we know when we are doing
    // the last DrvTextOut.  On the last DrvTextOut draw prclExtra.

        cTotalGlyphs += (COUNT) ( pwcTmp - pwcPartition );

        to.cGlyphsSet( (LONG) ( pwcTmp - pwcPartition ));
        to.pwszSet( pwcPartition );

    // set the font type and reset cGlyphPosCopied to 0

        to.vFontSet( lFont );

        if (lFont != EUDCTYPE_BASEFONT)
        {
            if (bAdjusBaseLine(rfo, rfoLink, &ptlAdjustBaseLine))
            {
                to.ptlBaseLineAdjustSet(ptlAdjustBaseLine);
            }
        }

    // adjust the baseline of the Sys EUDC for win 3.1 compatability

        to.prfntSet( prfoLink );

    // some drivers dink with the BkGround rectangle (like the Cirrus driver )
    // so save a copy here and then restore it later to handle this situation

        to.vSaveBkGroundRect();

    // check this is a path draw or not.

        if( prfoLink->bPathFont() )
        {
            PATHMEMOBJ po;

            if( !po.bValid() )
            {
                SAVE_ERROR_CODE( ERROR_NOT_ENOUGH_MEMORY );
                bRet = FALSE;
            }
            else
            {
                if( !(prfoLink->bReturnsOutlines()) )
                {
                    //
                    // VECTOR FONT CASE
                    //
                    if( !to.bTextToPathWorkhorse(po) ||
                        !po.bSimpleStroke1( flCaps,
                                            pdo,
                                            pSurf,
                                            &co,
                                            pboFore,
                                            pptlBrushOrg,
                                            ( R2_COPYPEN | ( R2_COPYPEN << 8 ))
                                           ))
                    {
                    #if DBG
                        DbgPrint("ProxyDrvTextout:bTextToPath for vector font \
                                  failed(%d).\n", lFont);
                    #endif
                        bRet = FALSE;
                    }
                }
                 else
                {
                    //
                    // OUTLINE FONT CASE
                    //
                    if( !to.bTextToPathWorkhorse(po) ||
                       (( po.cCurves > 1 ) &&
                           !po.bSimpleFill( flCaps,
                                            pdo,
                                            pSurf,
                                            &co,
                                            pboFore,
                                            pptlBrushOrg,
                                            ( R2_COPYPEN | ( R2_COPYPEN << 8 )),
                                            WINDING
                                          )
                        )
                      )
                    {
                    #if DBG
                        DbgPrint("ProxyDrvTextout:bTextToPath for outline font    \
                                  failed(%d).\n",lFont);
                    #endif
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
        // This is bad but we will peform a check to see if the linked glyphs
        // are out of bounds and if so fail the call.  There are several reasons
        // why this may happen (some understood and some not yet understood).  Since
        // we are so close to shipping it was better to do this rather than make
        // riskier fixes for the other problems.  I should point out a few things:
        //
        // 1) We only do this check on rotations that are not multiples of 90.
        //    These cases don't cause problem.  This also means we are only
        //    Slowing done non-common cases.  bOutOfBounds returns TRUE
        //    right away for horizontal text.
        // 2) It is always better to fail in this case since the alternative is
        //    is system crash (of course fixing the underlying problems is ideal.)
        // 3) These cases are not real world (i.e. they won't affect text in
        //    in real world scenarios) since they occur under extremely bizarre
        //    transforms and only in our test apps.
        // 4) I am documenting what I have found about the failure cases so far
        //    and fix these in 5.0

            if(!bOutOfBounds((STROBJ*) &to, prfoLink))
            {
                PFN_DrvTextOut pfnTextOut;
                pfnTextOut = pSurf->pfnTextOut();

                // this code correspond to what is done in GreExtTextOutWLocked()
                // see MSPaint, ClearType bug under 16bits colors #106984

                // If the pointer to the TextOut function points to SpTextOut then
                // we know that AntiAliased text can be handled and we can skip
                // the funny business in the else clause

                if (pfnTextOut == SpTextOut)
                {
                    if (prfoLink->prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X))
                    {
                        pSurf->pdcoAA = &dco;
                    }
                }
                else
                {

                    if
                        (
                            (prfoLink->prfnt->fobj.flFontType & FO_GRAY16) &&
                            (!(dco.flGraphicsCaps() & GCAPS_GRAY16) ||
                              (prfoLink->prfnt->fobj.flFontType & FO_CLEARTYPE_X))
                        )
                    {

                    // Inform SpTextOut that this call came from GreExtTextOutW
                    // for the purpose of rendering anti aliased text on a device
                    // that does not support it. Remember to set this to zero
                    // before releasing the surface to other users.

                        if (pfnTextOut != EngTextOut)
                            pSurf->pdcoAA = &dco;

                        pfnTextOut = SpTextOut;
                    }
                } // if (pfnTextOut == SpTextOut) else

               prfoLink->PreTextOut(dco);

               //
               // WINBUG #214225: re-visit the issue that RFONT cache semaphore
               // is held too long period of time.
               // Release/acquire the base rfont semaphore before/after
               // the DrvTextOut call.
               // 
               {
                   PDEVOBJ po(pSurf->hdev());
                   BOOL  bAcquireSem = FALSE;

                   if (prfoLink != (&rfo) && po.bPrinter() && po.bUMPD())
                   {
                       if (rfo.prfnt->hsemCache != NULL &&
                           GreIsSemaphoreOwnedByCurrentThread(rfo.prfnt->hsemCache))
                       {
                           GreReleaseSemaphore(rfo.prfnt->hsemCache);
                           bAcquireSem = TRUE;
                       }
                   }

                   if(!((*pfnTextOut))
                      ( pSurf->pSurfobj(),
                       (STROBJ *) &to,
                       prfoLink->pfo(),
                       &co,
                       (cTotalGlyphs == cNumGlyphs ) ? prclExtra : NULL,
                       prclBackground,
                       pboFore,
                       pboOpaque,
                       pptlBrushOrg,
                       (R2_COPYPEN | (R2_COPYPEN << 8))
                       ))
                   {
                       #if DBG
                       DbgPrint("ProxyDrvTextout:DrvTextOut for bitmap font failed(%d).\n",
                                lFont);
                       #endif
                       bRet = FALSE;
                   }

                   if (bAcquireSem)
                   {
                       GreAcquireSemaphore(rfo.prfnt->hsemCache);
                   }
               }

               prfoLink->PostTextOut(dco);

                pSurf->pdcoAA = 0;  // clear AA state
            }

            // set this to NULL since we've already drawn it.

            prclBackground = NULL;
        }

        to.vRestoreBkGroundRect();
    }

// TextOut expects gpos and prfo to be correct so reset them

    to.pwszSet( pwcSave );
    to.prfo = prfoSave;

    return(bRet);
}


/******************************Public*Routine*****************************\
* NtGdiEnableEudc
*
* Enable or disable system wide and per-user Eudc information.
*
* History:
*  27-Mar-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\*************************************************************************/

extern "C"
BOOL
APIENTRY
NtGdiEnableEudc(
    BOOL bEnable
)
{
    return(GreEnableEUDC(bEnable));
}


/******************************Public*Routine*****************************\
* NtGdiEudcLoadUnloadLink
*
* Queries system link information
*
* History:
*  27-Mar-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\*************************************************************************/

extern "C"
BOOL
APIENTRY
NtGdiEudcLoadUnloadLink(
    LPCWSTR pBaseFaceName,
    UINT   cwcBaseFaceName,
    LPCWSTR pEudcFontPath,
    UINT   cwcEudcFontPath,
    INT    iPriority,
    INT    iFontLinkType,
    BOOL   bLoadLink)
{
    WCHAR FaceNameBuffer[LF_FACESIZE+1];
    WCHAR *pPathBuffer;
    BOOL bRet = FALSE;

    if(cwcBaseFaceName > LF_FACESIZE || pEudcFontPath == NULL ||
       (cwcEudcFontPath == 0) || (cwcEudcFontPath > (MAX_PATH+LF_FACESIZE - 1)))
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    pPathBuffer = (WCHAR*) AllocFreeTmpBuffer((cwcEudcFontPath+1) * sizeof(WCHAR));

    if(pPathBuffer)
    {
        __try
        {
            if(pBaseFaceName)
            {
                ProbeForRead(pBaseFaceName,cwcBaseFaceName,sizeof(WCHAR));
                RtlCopyMemory(FaceNameBuffer,pBaseFaceName,
                              cwcBaseFaceName*sizeof(WCHAR));

                FaceNameBuffer[cwcBaseFaceName] = (WCHAR) 0;
                pBaseFaceName = FaceNameBuffer;
            }

            ProbeForRead(pEudcFontPath,cwcEudcFontPath,sizeof(WCHAR));
            RtlCopyMemory(pPathBuffer,pEudcFontPath,
                          cwcEudcFontPath*sizeof(WCHAR));

            pPathBuffer[cwcEudcFontPath] = (WCHAR) 0;
            bRet = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(3096);
        }

        if(bRet)
        {
            if(bLoadLink)
            {
                bRet = GreEudcLoadLinkW(pBaseFaceName,
                                        cwcBaseFaceName,
                                        pPathBuffer,
                                        cwcEudcFontPath,
                                        iPriority,
                                        iFontLinkType);
            }
            else
            {
                bRet = GreEudcUnloadLinkW(pBaseFaceName,
                                          cwcBaseFaceName,
                                          pPathBuffer,
                                          cwcEudcFontPath);
            }
        }
        FreeTmpBuffer(pPathBuffer);
    }

    return(bRet);
}

extern "C"
UINT
APIENTRY
NtGdiGetStringBitmapW(
    HDC hdc,
    LPWSTR pwsz,
    UINT cwc,
    BYTE *lpSB,
    UINT cj
    )
{
    WCHAR Character;
    LPSTRINGBITMAP OutputBuffer = NULL;
    UINT Status = 1;

    if(cwc != 1)
    {
        return(FALSE);
    }

    if(cj)
    {
        if(!(OutputBuffer = (LPSTRINGBITMAP) AllocFreeTmpBuffer(cj)))
        {
            Status = 0;
        }
    }

    if(Status)
    {
        __try
        {
            ProbeForRead(pwsz,sizeof(WCHAR), sizeof(WCHAR));
            Character = pwsz[0];
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(3099);
            Status = 0;
        }

        if(Status)
        {
            Status = GreGetStringBitmapW(hdc,
                                         &Character,
                                         1,
                                         (LPSTRINGBITMAP) OutputBuffer,
                                         cj,
                                         0);
        }

        if(Status && OutputBuffer)
        {
            __try
            {
                ProbeForWrite(lpSB,cj,sizeof(BYTE));
                RtlCopyMemory(lpSB,OutputBuffer,cj);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(3100);
                Status = 0;
            }
        }
    }

    if(OutputBuffer)
    {
        FreeTmpBuffer(OutputBuffer);
    }


    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fontddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontddi.cxx
*
* Text and font DDI callback routines.
*
*  Tue 06-Jun-1995 -by- Andre Vachon [andreva]
* update: removed a whole bunch of dead stubs.
*
*  Fri 25-Jan-1991 -by- Bodin Dresevic [BodinD]
* update: filled out all stubs
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* ULONG FONTOBJ_cGetAllGlyphHandles (pfo,phgly)                            *
*                                                                          *
* phgly      Buffer for glyph handles.                                     *
*                                                                          *
* Used by the driver to download the whole font from the graphics engine.  *
*                                                                          *
* Warning:  The device driver must ensure that the buffer is big enough    *
*           to receive all glyph handles for a particular realized font.   *
*                                                                          *
* History:                                                                 *
*  25-Jan-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

ULONG
FONTOBJ_cGetAllGlyphHandles(
    FONTOBJ *pfo,
    PHGLYPH  phg)
{
    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_cGetAllGlyphHandles(): bad pfo\n");

    return(rfto.chglyGetAllHandles(phg));
}

/******************************Public*Routine******************************\
* VOID FONTOBJ_vGetInfo (pfo,cjSize,pfoi)                                  *
*                                                                          *
* cjSize   Don't write more than this many bytes to the buffer.            *
* pfoi     Buffer with FO_INFO structure provided by the driver.           *
*                                                                          *
* Returns the info about the font to the driver's buffer.                  *
*                                                                          *
* History:                                                                 *
*  25-Jan-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

VOID
FONTOBJ_vGetInfo(
    FONTOBJ *pfo,
    ULONG cjSize,
    PFONTINFO pfi)
{
    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_vGetInfo(): bad pfo\n");

    FONTINFO    fi;     // RFONTOBJ will write into this buffer

    rfto.vGetInfo(&fi);

    RtlCopyMemory((PVOID) pfi, (PVOID) &fi, (UINT) cjSize);
}

/******************************Public*Routine******************************\
* PXFORMOBJ FONTOBJ_pxoGetXform (pfo)                                      *
*                                                                          *
* History:                                                                 *
*  25-Mar-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

XFORMOBJ
*FONTOBJ_pxoGetXform(
    FONTOBJ *pfo)
{
    return ((XFORMOBJ *) (PVOID) &(PFO_TO_PRF(pfo))->xoForDDI);
}

/******************************Public*Routine******************************\
* FONTOBJ_pifi                                                             *
*                                                                          *
* Returns pointer to associated font metrics.                              *
*                                                                          *
* History:                                                                 *
*  Wed 04-Mar-1992 10:49:53 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

IFIMETRICS* FONTOBJ_pifi(FONTOBJ *pfo)
{
    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_pifi(): bad pfo\n");

    PFEOBJ pfeo(rfto.ppfe());
    return(pfeo.bValid() ? pfeo.pifi() : (IFIMETRICS*) NULL);
}

/******************************Public*Routine******************************\
*
* APIENTRY FONTOBJ_pfdg
*
* returns pointer to pfdg
*
* History:
*  09-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

FD_GLYPHSET * APIENTRY FONTOBJ_pfdg(FONTOBJ *pfo)
{
    return (PFO_TO_PRF(pfo)->pfdg);
}



/******************************Public*Routine******************************\
* FONTOBJ_cGetGlyphs
*
*
* History:
*  05-Jan-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FONTOBJ_cGetGlyphs (
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cGlyph,     // requested # of hglyphs to be converted to ptrs
    PHGLYPH phg,        // array of hglyphs to be converted
    PVOID   *ppvGlyph    // driver's buffer receiving the pointers
    )
{
    DONTUSE(cGlyph);

    GLYPHPOS gp;
    if(phg)
    	gp.hg = *phg;
    else
    	return 0;

    RFONTTMPOBJ rfto(PFO_TO_PRF(pfo));
    ASSERTGDI(rfto.bValid(), "gdisrv!FONTOBJ_cGetGlyphs(): bad pfo\n");

    if ( !rfto.bInsertGlyphbitsLookaside(&gp, iMode))
        return 0;

    *ppvGlyph = (VOID *)(gp.pgdf);
    return 1;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   FONTOBJ_pvTrueTypeFontFile
*
* Routine Description:
*
*   This routine returns a kernel mode pointer to the start of a
*   font file. Despite the name of the routine, the font need not be
*   in the TrueType format.
*
*   GDI passes this call onto the font driver to do the detailed work.
*   The reason for this is that the file image can have the font file
*   image embedded in it in a non trivial way. An example of this would
*   be the *.ttc format for Far East Fonts. It is not reasonable to
*   expect this routine to be able to parse all file formats so that
*   resposibility is left to the font drivers.
*
* Arguments:
*
*   pfo - a 32-bit pointer to a FONTOBJ structure associated with a font
*       file.
*
*   pcjFile - the address of a 32-bit unsigend number that receives the
*       size of the view of the font file.
*
* Called by:
*
*   Printer Drivers in the context of a call to DrvTextOut
*
* Return Value:
*
*   If successful, this routine will return a kernel mode view of
*   a TrueType font file. If unsuccessful this routine returns NULL.
*
\**************************************************************************/

PVOID FONTOBJ_pvTrueTypeFontFile(
    FONTOBJ *pfo,
     ULONG  *pcjFile
    )
{
    void *pvRet = 0;
    *pcjFile = 0;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
        pvRet = rfo.pvFile( pcjFile );
    }
    return( pvRet );
}


PVOID
FONTOBJ_pvTrueTypeFontFileUMPD(
    FONTOBJ *pfo,
    ULONG   *pcjFile,
    PVOID   *ppBase
    )

{
    *ppBase = NULL;
    *pcjFile = 0;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));

    return rfo.bValid() ? rfo.pvFileUMPD(pcjFile, ppBase) : NULL;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   FONTOBJ_pjOpenTypeTablePointer
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
*   A pointer to a view of the table.
*
\**************************************************************************/

PBYTE FONTOBJ_pjOpenTypeTablePointer (
    FONTOBJ *pfo,
      ULONG  ulTag,
      ULONG *pcjTable
    )
{
    PBYTE pjTable = 0;

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
        pjTable = rfo.pjTable( ulTag, pcjTable );
    }
    return( pjTable );
}

LPWSTR FONTOBJ_pwszFontFilePaths (FONTOBJ *pfo, ULONG *pcwc)
{
    LPWSTR pwsz =  NULL;
    *pcwc = 0;
    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
    // return 0 for memory fonts and temporary fonts added to dc's for printing

        if (!(rfo.prfnt->ppfe->pPFF->flState & (PFF_STATE_MEMORY_FONT | PFF_STATE_DCREMOTE_FONT)))
        {
            pwsz = rfo.prfnt->ppfe->pPFF->pwszPathname_;
            *pcwc = rfo.prfnt->ppfe->pPFF->cwc;
        }
    }
    return pwsz;
}

/******************************Public*Routine******************************\
* FONTOBJ_bQueryGlyphAttrs
*
* History:
*  Thu 21-May-1998 by Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

PFD_GLYPHATTR  APIENTRY FONTOBJ_pQueryGlyphAttrs(
    FONTOBJ *pfo,
    ULONG   iMode
)
{

    RFONTTMPOBJ rfo(PFO_TO_PRF(pfo));
    if ( rfo.bValid() )
    {
        PDEVOBJ pdo( rfo.hdevProducer() );

        if (pdo.bValid() && PPFNVALID(pdo, QueryGlyphAttrs) )
        {

            return pdo.QueryGlyphAttrs(pfo, iMode);
        }
    }

    return( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fontgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontgdi.cxx                                                 *
*                                                                          *
* GDI functions for fonts.                                                 *
*                                                                          *
* Created: 31-Oct-1990 09:37:42                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                                 *
\**************************************************************************/
#pragma warning (disable: 4509)

#include "precomp.hxx"

extern BOOL G_fConsole;


/******************************Public*Routine******************************\
*
* BOOL APIENTRY GreSetFontXform
*
*
* Effects: sets page to device scaling factors that are used in computing
*          notional do device transform for the text. This funciton is
*          called only by metafile component and used when a 16 bit metafile
*          has to be rotated by a nontrivial world transform.
*
* History:
*  30-Nov-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetFontXform
(
HDC    hdc,
FLOATL exScale,
FLOATL eyScale
)
{
    BOOL bRet;

    DCOBJ   dco(hdc);

    if (bRet = dco.bValid())
    {
        dco.pdc->vSet_MetaPtoD(exScale,eyScale);      // Set new value

        //
        // flag that the transform has changed as fas as font component
        // is concerned, since this page to device xform will be used in
        // computing notional to device xform for this font:
        //

        dco.pdc->vXformChange(TRUE);
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* int APIENTRY AddFontResource
*
* The AddFontResource function adds the font resource from the file named
* by the pszFilename parameter to the Windows public font table. The font
* can subsequently be used by any application.
*
* Returns:
*   The number of font resources or faces added to the system from the font
*   file; returns 0 if error.
*
* History:
*  Thu 13-Oct-1994 11:18:27 by Kirk Olynyk [kirko]
* Now it has a single return point. Added timing.
*
*  Tue 30-Nov-1993 -by- Bodin Dresevic [BodinD]
* update: Added permanent flag for the fonts that are not to
* be unloaded at log off time
*
*  Mon 12-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: converted to UNICODE
*
*  05-Nov-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

/*
struct {
    int doprint : 1;
    int dobreak : 1;
} afrDebug = { 1,1 };
*/

int GreAddFontResourceWInternal (
    LPWSTR  pwszFileName,            // ptr. to unicode filename string
    ULONG   cwc,
    ULONG   cFiles,
    FLONG   fl,
    DWORD   dwPidTid,
    DESIGNVECTOR *pdv,
    ULONG         cjDV
    )
{
    ULONG cFonts = 0;
//  ASSERTGDI((fl & (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT)) !=
//             (AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT),
//              "GreAddFontResourceWInternal, fl \n");

//    ASSERTGDI((fl & ~(AFRW_ADD_REMOTE_FONT|AFRW_ADD_LOCAL_FONT
//                        |FR_PRIVATE|FR_NOT_ENUM|FRW_EMB_PID|FRW_EMB_TID)) == 0,
//              "GreAddFontResourceWInternal, bad fl\n");
 /*
    if (afrDebug.doprint)
    {
        KdPrint(("\n"
                 "GreAddFontResourceWInternal\n"
                 "\tpwszFileName %-#x \"%ws\"\n"
                 "\t         cwc %-#x\n"
                 "\t      cFiles %-#x\n"
                 "\t          fl %-#x\n"
                 "\t    dwPidTid %-#x\n"
                 "\t)\n"
                 "\n"
                 , pwszFileName, pwszFileName ? pwszFileName : L""
                 , cwc
                 , cFiles
                 , fl
                 , dwPidTid
                 ));
    }
    if (afrDebug.dobreak)
    {
        KdBreakPoint();
    }
*/
    TRACE_FONT(("Entering GreAddFontResourceWInternal\n\t*pwszFileName=\"%ws\"\n\tfl=%-#x\n", pwszFileName,  fl));
    if ( !pwszFileName )
    {
        WARNING("gdisrv!GreAddFontResourceW(): bad paramerter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        // Current ID needs to match the input dwPidTid if it is embedded font

        if ((fl & FRW_EMB_PID) && (dwPidTid != (DWORD)W32GetCurrentPID()))
        {
            return (cFonts);
        }

        if ((fl & FRW_EMB_TID) && (dwPidTid != (DWORD)W32GetCurrentTID()))
        {
            return (cFonts);
        }

        FLONG flPFF = 0;

        if (fl & AFRW_ADD_LOCAL_FONT)
        {
            flPFF |= PFF_STATE_PERMANENT_FONT;
        }
        if (fl & AFRW_ADD_REMOTE_FONT)
        {
            flPFF |= PFF_STATE_NETREMOTE_FONT;
        }

        PFF *placeholder;

        // need to initialize the private PFT if it is NULL

        if (fl & (FR_PRIVATE|FRW_EMB_TID|FRW_EMB_PID) && (gpPFTPrivate == NULL))
        {
            if (!bInitPrivatePFT())
            {
                return (cFonts);
            }
        }

        PUBLIC_PFTOBJ pfto(fl & (FR_PRIVATE|FRW_EMB_PID|FRW_EMB_TID) ? gpPFTPrivate : gpPFTPublic);

        if (!pfto.bValid() ||
            !pfto.bLoadFonts( pwszFileName, cwc, cFiles, pdv, cjDV,
                                      &cFonts, flPFF, &placeholder, fl, FALSE, NULL ) )
        {
            cFonts = 0;
        }

        if (cFonts)
        {
            GreQuerySystemTime( &PFTOBJ::FontChangeTime );
        }
    }
    TRACE_FONT(("Exiting GreAddFontResourceWInternal\n\treturn value = %d\n", cFonts));
    return((int) cFonts);
}


/******************************Public*Routine******************************\
* int GreGetTextFace (hdc,nCount,lpFaceName,pac)
*
* The GetTextFace function fills the return buffer, lpFaceName, with the
* facename of the font currently mapped to the logical font selected into
* the DC.
*
* [Window 3.1 compatibility]
*     Facename really refers to family name in this case, so family name
*     from the IFIMETRICS is copied rather than face name.
*
* Returns:
*   The number of bytes copied to the buffer.  Returns 0 if error occurs.
*
* History:
*
*  Tue 27-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: conveterted to unicode
*
*  05-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int GreGetTextFaceW
(
    HDC        hdc,
    int        cwch,           // max number of WCHAR's to be returned
    LPWSTR     pwszFaceName,
    BOOL       bAliasName
)
{
    int iRet = 0;
    PWSZ    pwszAlias;

    DCOBJ dcof(hdc);

    if (dcof.bValid())
    {
    // Get PDEV user object.  We also need to make
    // sure that we have loaded device fonts before we go off to the font mapper.
    // This must be done before the semaphore is locked.

        PDEVOBJ pdo(dcof.hdev());
        ASSERTGDI (
            pdo.bValid(),
            "gdisrv!bEnumFonts(): cannot access PDEV\n");

        if (!pdo.bGotFonts())
        {
            pdo.bGetDeviceFonts();
        }

    // Lock down the LFONT.

        LFONTOBJ lfo(dcof.pdc->hlfntNew(), &pdo);

        if (lfo.bValid())
        {
        // Stabilize font table (grab semaphore for public PFT).

            SEMOBJ  so(ghsemPublicPFT);

        // Lock down PFE user object.

            FLONG flSim;
            FLONG flAboutMatch;
            POINTL ptlSim;
            PWSZ pwszUseThis = NULL;
            BOOL bIsFamilyNameAlias;

            PFEOBJ pfeo(lfo.ppfeMapFont(dcof,&flSim,&ptlSim, &flAboutMatch));

            if (!pfeo.bValid())
                return(iRet);

        // Figure out which name should be returned: the facename of the physical
        // font, or the facename in the LOGFONT.  We use the facename in the LOGFONT
        // if the match was due to facename substitution (alternate facename).

            bIsFamilyNameAlias = FALSE;
            if((flAboutMatch & MAPFONT_ALTFACE_USED) && lfo.plfw()->lfFaceName[0])
                pwszUseThis = lfo.plfw()->lfFaceName ;
            else
                pwszUseThis = pfeo.pwszFamilyNameAlias(&bIsFamilyNameAlias);

        // Copy facename to return buffer, truncating if necessary.

            if (pwszFaceName != NULL)
            {
            // If it's length is 0 return 0 because the buffer is
            // not big enough to write the string terminator.

                if (cwch >= 1)
                {
                    if (bAliasName && bIsFamilyNameAlias)
                    {
                        pwszAlias = pwszUseThis;
                        iRet = 0;
                        while(*pwszAlias && _wcsicmp( lfo.plfw()->lfFaceName, pwszAlias))
                        {
                            iRet += (wcslen(pwszAlias) + 1);
                            pwszAlias = pwszUseThis + iRet;
                        }

                        if(*pwszAlias)
                            pwszUseThis = pwszAlias;
                    }

                    iRet = wcslen(pwszUseThis) + 1;

                    if (cwch < iRet)
                    {
                        iRet = cwch;
                    }

                    memcpy(pwszFaceName, pwszUseThis, iRet * sizeof(WCHAR));

                    pwszFaceName[iRet - 1] = L'\0';   // guarantee a terminating NULL

                }
                else
                {
                    WARNING("Calling GreGetTextFaceW with 0 and pointer\n");
                }
            }
            else
            {
            // Return length of family name (terminating NULL included).

                if (bAliasName && bIsFamilyNameAlias)
                {
                    pwszAlias = pwszUseThis;

                    iRet = 0;
                    while(*pwszAlias && _wcsicmp( lfo.plfw()->lfFaceName, pwszAlias))
                    {
                        iRet += (wcslen(pwszAlias) + 1);
                        pwszAlias = pwszUseThis + iRet;
                    }

                    if(*pwszAlias)
                        pwszUseThis = pwszAlias;
                }

                iRet = (wcslen(pwszUseThis) + 1);

            }
        }
        else
        {
            WARNING("gdisrv!GreGetTextFaceW(): could not lock HLFONT\n");
        }
    }
    else
    {
        WARNING1("gdisrv!GreGetTextFaceW(): bad HDC\n");
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL GreGetTextMetricsW (hdc,lpMetrics,pac)
*
* Retrieves IFIMETRICS for the font currently selected into the hdc and
* converts them into Windows-compatible TEXTMETRIC format.  The TEXTMETRIC
* units are in logical coordinates.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  Wed 24-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Reduce size.
*
*  Tue 20-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: converted to unicode version
*
*  19-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GreGetTextMetricsW
(
    HDC          hdc,
    TMW_INTERNAL *ptmi
)
{
    BOOL bRet = FALSE;
    DCOBJ       dcof (hdc);

    if (dcof.bValid())
    {
    // Get and validate RFONT user object
    // (may cause font to become realized)

    #if DBG
        HLFONT hlfntNew = dcof.pdc->hlfntNew();
        HLFONT hlfntCur = dcof.pdc->hlfntCur();
    #endif

        RFONTOBJ rfo(dcof, FALSE);

        if (rfo.bValid())
        {
            bRet = bGetTextMetrics(rfo, dcof, ptmi);
        }
        else
        {
            WARNING("gdisrv!GreGetTextMetricsW(): could not lock HRFONT\n");
        }
    }
    else
    {
        WARNING1("GreGetTextMetricsW failed - invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiRemoveFontResourceW()
*
* Have the engine remove this font resource (i.e., unload the font file).
* The resource will not be removed until all outstanding AddFontResource
* calls for a specified file have been matched by an equal number of
* RemoveFontResouce calls for the same file.
*
* Returns:
*   TRUE if successful, FALSE if error occurs.
*
* History:
*  27-Sept-1996  -by- Xudong Wu [TessieW]
* Embedded/Private fonts stored in Private PFT, add two parameter fl, dwPidTid
* to trace down the font resouce in the Private PFT.
*  Thu 28-Mar-1996 -by- Bodin Dresevic [BodinD]
* update: try/excepts -> ntgdi.c, multiple paths
*  04-Feb-1996 -by- Andre Vachon [andreva]
* rewrote to include try\except.
*  30-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL GreRemoveFontResourceW(
    LPWSTR        pwszPath,
    ULONG         cwc,
    ULONG         cFiles,
    FLONG         fl,
    DWORD         dwPidTid,
    DESIGNVECTOR *pdv,
    ULONG         cjDV
)
{
    PFF *pPFF, **ppPFF;
    // WCHAR szUcPathName[MAX_PATH + 1];
    BOOL bRet = FALSE;

// Check the flag

    ASSERTGDI((fl & ~(FR_PRIVATE|FR_NOT_ENUM|FRW_EMB_PID|FRW_EMB_TID)) == 0,
                "win32k!GreRemoveFontResourceW: bad flag\n");

// for embedded fonts, current PID/TID needs to match input dwPidTid

    if ((fl & FRW_EMB_TID) && (dwPidTid != (DWORD)W32GetCurrentTID()))
    {
        return FALSE;
    }

    if ((fl & FRW_EMB_PID) && (dwPidTid != (DWORD)W32GetCurrentPID()))
    {
        return FALSE;
    }

// Add one to the length to account for internal processing of the
// cCapString routine

    PUBLIC_PFTOBJ pfto(fl & (FR_PRIVATE|FRW_EMB_PID|FRW_EMB_TID) ? gpPFTPrivate : gpPFTPublic);      // access the public font table

    if (!pfto.bValid())
    {
       return FALSE;
    }

    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);     // This is a very high granularity
                                     // and will prevent text output
    TRACE_FONT(("GreRemoveFontResourceW() acquiring ghsemPublicPFT\n"));

    pPFF = pfto.pPFFGet(pwszPath, cwc, cFiles, pdv, cjDV, &ppPFF);

    if (pPFF)
    {
        // bUnloadWorkhorse() guarantees that the public font table
        // semaphore will be released before it returns

        if (bRet = pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, fl))
        {
            GreQuerySystemTime( &PFTOBJ::FontChangeTime );
        }
    }
    else
    {
        TRACE_FONT(("NtGdiRemoveFontResourceW() releasing ghsemPublicPFT\n"));
        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }

    return( bRet );

}


/******************************Public*Routine******************************\
*
* BOOL APIENTRY GreRemoveAllButPermanentFonts()
*
* user is calling this on log off, unloads all but permanent fonts
* Should be called at the time when most of the references to the fonts
* are gone, for all the apps have been shut, so that all deletions proceed
* with no problem
*
* History:
*  30-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreRemoveAllButPermanentFonts()
{
// get and validate PFT user object

#ifdef FE_SB

// disable/unload system wide/facename eudc for current user.
// on win2k only.

// on hydra system, we will wait until the final clean up
// to avoid possible fe mem leak.

    if (G_fConsole)
    {
        GreEnableEUDC(FALSE);
    }

#endif

    BOOL bRet;
    {
        PUBLIC_PFTOBJ pfto;              // access the public font table

    // We really need to pass in the size of the string instead or 0~
    // This function should actually be completely removed and use
    // __bUnloadFont directly from the client.

        bRet = pfto.bUnloadAllButPermanentFonts();
    }

    if( bRet )
    {
        GreQuerySystemTime( &PFTOBJ::FontChangeTime );
    }

    return bRet;
}


/**************************************************************************\
*  Structures and constants for GreGetCharWidth()                          *
\**************************************************************************/

// BUFFER_MAX -- max number of elements in buffers on the frame

#define BUFFER_MAX 32

/******************************Public*Routine******************************\
* GreGetCharWidth                                                          *
*                                                                          *
* The GreGetCharWidth function retrieves the widths of individual          *
* characters in a consecutive group of characters from the                 *
* current font.  For example, if the wFirstChar parameter                  *
* identifies the letter a and the wLastChar parameter                      *
* identifies the letter z, the GetCharWidth function retrieves             *
* the widths of all lowercase characters.  The function stores             *
* the values in the buffer pointed to by the lpBuffer                      *
* parameter.                                                               *
*                                                                          *
* Return Value                                                             *
*                                                                          *
*   The return value specifies the outcome of the function.  It            *
*   is TRUE if the function is successful.  Otherwise, it is               *
*   FALSE.                                                                 *
*                                                                          *
* Comments                                                                 *
*                                                                          *
*   If a character in the consecutive group of characters does             *
*   not exist in a particular font, it will be assigned the                *
*   width value of the default character.                                  *
*                                                                          *
*   By complete fluke, the designers of the API allocated a WORD           *
*   for each character. This allows GPI to interpret the characters        *
*   as being part of the Unicode set. Old apps will still work.            *
*                                                                          *
* History:                                                                 *
*  Thu 24-Sep-1992 14:40:07 -by- Charles Whitmer [chuckwh]                 *
* Made it return an indication when the font is a simulated bitmap font.   *
* This allows WOW to make compatibility fixes.                             *
*                                                                          *
*  Wed 18-Mar-1992 08:58:40 -by- Charles Whitmer [chuckwh]                 *
* Made it use the very simple transform from device to world.  Added the   *
* FLOAT support.                                                           *
*                                                                          *
*  17-Dec-1991 by Gilman Wong [gilmanw]                                    *
* Removed RFONTOBJCACHE--cache access now merged into RFONTOBJ construc.   *
*                                                                          *
* converted to unicode (BodinD)                                            *
*                                                                          *
*  Fri 05-Apr-1991 15:20:39 by Kirk Olynyk [kirko]                         *
* Added wrapper class RFONTOBJCACHE to make sure that the cache is         *
* obtained before and released after getting glyph metric info.            *
*                                                                          *
*  Wed 13-Feb-1991 15:16:06 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/
/**************************************************************************\
* if pwc == NULL use the consecutive range                                 *
*   ulFirstChar, ulFirstChar + 1, ...., ulFirstChar + cwc - 1              *
*                                                                          *
* if pwc != NULL ignore ulFirstChar and use array of cwc WCHARS pointed to *
* by pwc                                                                   *
\**************************************************************************/

BOOL GreGetCharWidthW
(
    HDC    hdc,
    UINT   ulFirstChar,
    UINT   cwc,
    PWCHAR pwcFirst,     // ptr to the input buffer
    FLONG  fl,
    PVOID  lpBuffer
)
{
// we could put these two quantities in the union,
// wcCur is used iff pwcFirst is null, otherwise pwcCur is used

    UINT            wcCur;                 // Unicode of current element
    PWCHAR          pwcCur;                // ptr to the current element in the
                                           // input buffer.
    INT             ii;
    UINT            cBufferElements;        // count of elements in buffers

    EGLYPHPOS      *pgposCur;
    EFLOAT          efDtoW;
    PWCHAR          pwcBuffer;

    LONG *pl = (LONG *) lpBuffer;  // We assume sizeof(LONG)==sizeof(FLOAT).

    WCHAR           awcBuffer[BUFFER_MAX]; // Unicode buffer
    GLYPHPOS        agposBuffer[BUFFER_MAX]; // ptl fields not used

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (lpBuffer == (PVOID)NULL)
        return(FALSE);

    RFONTOBJ rfo(dco,FALSE, (fl & GCW_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);
    if (!rfo.bValid())
    {
        WARNING("gdisrv!GreGetCharWidthW(): could not lock HRFONT\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
    {
        if (pwcFirst)
            rfo.vFixUpGlyphIndices((USHORT *)pwcFirst, cwc);
        else
            rfo.vFixUpGlyphIndices((USHORT *)&ulFirstChar, 1);
    }

    efDtoW = rfo.efDtoWBase_31();          // Cache to reverse transform.

// Windows 3.1 has preserved a bug from long ago in which the extent of
// a bitmap simulated bold font is one pel too large.  We add this in for
// compatibility.  There's also an overhang with bitmap simulated italic
// fonts.

    FIX fxAdjust = 0;

    if (fl & GCW_WIN3)
    {
        fxAdjust = rfo.lOverhang() << 4;
    }

// a little initialization

    if (pwcFirst == (PWCHAR)NULL)
    {
        wcCur = ulFirstChar;
    }
    else
    {
        pwcCur = pwcFirst;
    }

// now do the work

    while (TRUE)
    {
    // fill the buffer

    // <calculate the number of items that will be placed in the buffer>
    // <update wcStart for the next filling of the buffer>
    // <fill the array of characters, awcBuffer,
    //  with a consecutive array of characters>
    // <translate the array of cBuffer codepoints to handles and place
    //  the array of glyph handles on the frame>
    // [Note: It is assumed in this code that characters that are
    //        not supported by the font are assigned the handle
    //        handle of the default character]

        WCHAR *pwc;
        UINT   wc,wcEnd;

        if (pwcFirst == (PWCHAR)NULL)
        {
        // are we done?

            if ((UINT)(wcCur - ulFirstChar) > cwc - 1)
            {
                break;
            }

            cBufferElements = min((cwc - (wcCur - ulFirstChar)),BUFFER_MAX);

            wcEnd = wcCur + cBufferElements;
            for (pwc = awcBuffer, wc = wcCur; wc < wcEnd; pwc++, wc++)
            {
                *pwc = (WCHAR)wc;
            }

            pwcBuffer = awcBuffer;
        }
        else
        {
        // are we done?

            if ((UINT)(pwcCur - pwcFirst) > (cwc - 1))
                break;

            //Sundown: safe to truncate to UINT
            cBufferElements = min((cwc - (UINT)(pwcCur - pwcFirst)),BUFFER_MAX);
            pwcBuffer = pwcCur;
        }

    // pwcBuffer now points to the next chars to be dealt with
    // cBufferElements now contains the number of chars at pwcBuffer


    // empty the buffer
    // Grab cGlyphMetrics pointers

        pgposCur = (EGLYPHPOS *) agposBuffer;

        if (!rfo.bGetGlyphMetrics(
            cBufferElements, // size of destination buffer
            pgposCur,        // pointer to destination buffe
            pwcBuffer,
            &dco))
        {
            return(FALSE);
        }

        if (fl & GCW_INT)
        {
            for (ii=0; ii<(INT) cBufferElements; ii++,pgposCur++)
            {
                *pl++ = lCvt(efDtoW,pgposCur->pgd()->fxD + fxAdjust);
            }
        }
        else
        {
            EFLOAT efWidth;

            for (ii=0; ii<(INT) cBufferElements; ii++,pgposCur++)
            {
                efWidth.vFxToEf(pgposCur->pgd()->fxD);
                efWidth *= efDtoW;
                *pl++ = efWidth.lEfToF();
            }
        }

        if (pwcFirst == (PWCHAR)NULL)
        {
            wcCur += cBufferElements;
        }
        else
        {
            pwcCur += (WCHAR) cBufferElements;
        }
    }
    return(TRUE);
}

BOOL GreFontIsLinked( HDC hdc )
{
    BOOL  bRet = FALSE;
    DCOBJ dco (hdc);

    if (dco.bValid())
    {
        // Realized the font
        RFONTOBJ rfo(dco, FALSE);

        if (rfo.bValid())
        {
            PRFONT   prfnt;
            PFEOBJ  pfeo(rfo.ppfe());

            // Don't change the EUDC
            INCREMENTEUDCCOUNT;

            prfnt = rfo.prfntFont();

            if (pfeo.bValid() && !pfeo.bEUDC())
            {
                if (prfnt->bIsSystemFont)
                {
                    if (gbSystemDBCSFontEnabled)
                        bRet = TRUE;
                }
                else
                {
                    if (IS_SYSTEM_EUDC_PRESENT())
                        bRet = TRUE;
                    else if (bFinallyInitializeFontAssocDefault)
                    {
                        IFIOBJR  ifio(pfeo.pifi(),rfo,dco);
                        BYTE jWinCharSet = (ifio.lfCharSet());

                        if ((jWinCharSet == ANSI_CHARSET) || (jWinCharSet == OEM_CHARSET) || (jWinCharSet == SYMBOL_CHARSET))
                        {
                            if(((jWinCharSet + 2) & 0xf) & fFontAssocStatus)
                                bRet = TRUE;
                        }
                    }

                    if (!bRet && pfeo.pGetLinkedFontEntry() != NULL)
                    {
                        bRet = TRUE;
                    }
                }
            }

            DECREMENTEUDCCOUNT;
        }
    }

    return bRet;
}

/**************************************************************************\
* GreGetCharWidthInfo                                                      *
*                                                                          *
* Get lMaxNegA lMaxNegC and lMinWidthC                                       *
*                                                                          *
* History:                                                                 *
*   09-Feb-1996  -by-  Xudong Wu  [tessiew]                                *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
GreGetCharWidthInfo(
   HDC           hdc,
   PCHWIDTHINFO  pChWidthInfo
)
{
   BOOL    bResult = FALSE; // essential
   DCOBJ   dco(hdc);

   if (dco.bValid())
   {
      RFONTOBJ  rfo(dco, FALSE);

      if (rfo.bValid())
      {
      // only support this for outline fonts for now
      // may remove this requirement later [bodind]

         PDEVOBJ pdo(rfo.hdevProducer());

      // As long as the driver LOOKS like the TrueType driver, we will
      // allow the call to succeed.  Otherwise, we quit right now!
      // In this case, TrueType means supporting the TrueType native-mode
      // outline format.

         if (PPFNVALID(pdo, QueryTrueTypeOutline) )
         {
            if (dco.pdc->bWorldToDeviceIdentity())
            {
               pChWidthInfo->lMaxNegA   = rfo.prfnt->lMaxNegA;
               pChWidthInfo->lMaxNegC   = rfo.prfnt->lMaxNegC;
               pChWidthInfo->lMinWidthD = rfo.prfnt->lMinWidthD;
            }
            else
            {

               EFLOAT   efDtoW;

               efDtoW = rfo.efDtoWBase_31();

            // transform from DEV to World

               pChWidthInfo->lMaxNegA   = lCvt(efDtoW, rfo.prfnt->lMaxNegA << 4);
               pChWidthInfo->lMaxNegC   = lCvt(efDtoW, rfo.prfnt->lMaxNegC << 4);
               pChWidthInfo->lMinWidthD = lCvt(efDtoW, rfo.prfnt->lMinWidthD << 4);
            }

            bResult = TRUE;
         }
      }
      #if DBG
      else
      {
         WARNING("gdisrv!GreGetCharWidthInfo(): could not lock HRFONT\n");
      }
      #endif

   }
   #if DBG
   else
   {
      WARNING("Invalid DC passed to GreGetCharWidthInfo\n");
   }
   #endif

   return bResult;
}


/******************************Public*Routine******************************\
* vConvertLogFontW                                                         *
*                                                                          *
* Converts a LOGFONTW to an EXTLOGFONTW.                                   *
*                                                                          *
* History:                                                                 *
*  Fri 16-Aug-1991 14:02:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID
vConvertLogFontW(
    ENUMLOGFONTEXDVW *pelfexdvw,
    LOGFONTW    *plfw
    )
{
    ENUMLOGFONTEXW *pelfw = &pelfexdvw->elfEnumLogfontEx;
    pelfw->elfLogFont = *plfw;

    pelfw->elfFullName[0]   = 0;
    pelfw->elfStyle[0]      = 0;
    pelfw->elfScript[0]     = 0;

    pelfexdvw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
    pelfexdvw->elfDesignVector.dvNumAxes  = 0;

}


/******************************Public*Routine******************************\
* GreCreateFontIndirectW                                                   *
*                                                                          *
* Unicode extension of CreateFontIndirect                                  *
*                                                                          *
* History:                                                                 *
*  Mon 19-Aug-1991 07:00:33 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

HFONT
GreCreateFontIndirectW(
    LOGFONTW* plfw
    )
{
    ENUMLOGFONTEXDVW  elfw;
    vConvertLogFontW(&elfw,plfw);
    return(hfontCreate(&elfw, LF_TYPE_USER, 0, NULL));
}

/******************************Public*Routine******************************\
* BOOL GreGetCharABCWidthsW                                                *
*                                                                          *
* On input, a set of UNICODE codepoints (WCHARS) is specified in one of    *
* two ways:                                                                *
*                                                                          *
*  1) if pwch is NULL, then there is a consecutive set of codepoints       *
*     [wchFirst, wchFirst+cwch-1], inclusive.                              *
*                                                                          *
*  2) if pwch is non-NULL, then pwch points to a buffer containing cwch    *
*     codepoints (no particular order, duplicates allowed, wchFirst is     *
*     ignored).                                                            *
*                                                                          *
* The function will query the realized font for GLYPHDATA for each         *
* codepoint and compute the A, B, and C widths relative to the character   *
* baseline.  If the codepoint lies outside the supported range of the font,*
* the ABC widths of the default character are substituted.                 *
*                                                                          *
* The ABC widths are returned in LOGICAL UNITS via the pabc buffer.        *
*                                                                          *
* Returns:                                                                 *
*   TRUE if successful, FALSE otherwise.                                   *
*                                                                          *
* History:                                                                 *
*  Wed 18-Mar-1992 11:40:55 -by- Charles Whitmer [chuckwh]                 *
* Made it use the very simple transform from device to world.  Added the   *
* FLOAT support.                                                           *
*                                                                          *
*  21-Jan-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL GreGetCharABCWidthsW
(
    HDC         hdc,            // font realized on this device
    UINT        wchFirst,       // first character (ignored if pwch !NULL)
    COUNT       cwch,           // number of characters
    PWCHAR      pwch,           // pointer to array of WCHAR
    FLONG       fl,             // integer or float version, glyphindex or unicode
    PVOID       pvBuf           // return buffer for ABC widths
)
{

    ABC       *pabc ;           // return buffer for ABC widths
    ABCFLOAT  *pabcf;           // return buffer for ABC widths
    GLYPHDATA *pgd;
    EFLOAT     efDtoW;
    LONG       lA,lAB,lD;
    COUNT      cRet;

    pabc  = (ABC *)      pvBuf;
    pabcf = (ABCFLOAT *) pvBuf;

// Create and validate DC user object.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }


// Early out (nothing to do).

    if (cwch == 0)
        return (TRUE);

// Create and validate RFONT user objecct.

    RFONTOBJ rfo(dco, FALSE, (fl & GCABCW_GLYPH_INDEX) ? RFONT_TYPE_HGLYPH : RFONT_TYPE_UNICODE);
    if (!rfo.bValid())
    {
        WARNING("gdisrv!GreGetCharABCWidthsW(): could not lock HRFONT\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (rfo.prfnt->flType & RFONT_TYPE_HGLYPH)
    {
        if (pwch)
            rfo.vFixUpGlyphIndices((USHORT *)pwch, cwch);
        else
            rfo.vFixUpGlyphIndices((USHORT *)&wchFirst, 1);
    }

    efDtoW = rfo.efDtoWBase_31();          // Cache to reverse transform.

    PDEVOBJ pdo(rfo.hdevProducer());

// Fail if integer case and not TrueType.  In this case, TrueType means
// any font driver that provides the enhanced "TrueType"-like behavior.
// We'll base this on the same criterion as for GetOutlineTextMetrics--i.e.,
// whether or not the DrvQueryTrueTypeOutline function is exported.
//
// We will let any driver provide the FLOAT character ABC widths.

// We will also let GlyphIndex version  of the api work for any fonts

    if (!(fl & GCABCW_GLYPH_INDEX) && (fl & GCABCW_INT) && (!PPFNVALID(pdo, QueryTrueTypeOutline)))
    {
        return (FALSE);
    }

// Use these buffers to process the input set of WCHARs.

    WCHAR awc[BUFFER_MAX];          // UNICODE buffer (use if pwch is NULL)
    GLYPHPOS agp[BUFFER_MAX];       // ptl fields not used

// Process the WCHARs in subsets of BUFFER_MAX number of WCHARs.

    do
    {
        PWCHAR pwchSubset;          // pointer to WCHAR buffer to process
        EGLYPHPOS *pgp = (EGLYPHPOS *) agp;
        EGLYPHPOS *pgpStop;

    // How many to process in this subset?

        COUNT cwchSubset = min(BUFFER_MAX, cwch);

    // Get a buffer full of WCHARs.

        if (pwch != NULL)
        {
        // Use the buffer passed in.

            pwchSubset = pwch;

        // Move pointer to the start of the next subset to process.

            pwch += cwchSubset;
        }

        else
        {
        // Generate our own (contiguous) set of WCHARs in the awc temporary
        // buffer on the stack.

            pwchSubset = awc;
            PWCHAR pwchStop = pwchSubset + cwchSubset;

            while (pwchSubset < pwchStop)
            {
                *pwchSubset = (WCHAR)wchFirst;
                pwchSubset++;
                wchFirst++;
            }
            pwchSubset = awc;
        }


    // Initialize number of elements in agp to process.

        COUNT cpgpSubset = cwchSubset;

    // Compute the ABC widths for each HGLYPH.

        do
        {
        // Grab as many PGLYPHDATA as we can.
        // pwchSubset points to the chars
        // NOTE: This code could be cleaned up some [paulb]

            cRet = cpgpSubset;

            if (!rfo.bGetGlyphMetrics(
                        cpgpSubset, // size of destination buffer
                        pgp,        // pointer to destination buffer
                        pwchSubset,  // chars to xlat
                        &dco
                        ))
            {
                return FALSE;
            }

        // For each PGLYPHDATA returned, compute the ABC widths.

            if (fl & GCABCW_INT)
            {
                for (pgpStop=pgp+cRet; pgp<pgpStop; pgp++)
                {
                    pgd = pgp->pgd();

                    lA  = lCvt(efDtoW,pgd->fxA);
                    lAB = lCvt(efDtoW,pgd->fxAB);
                    lD  = lCvt(efDtoW,pgd->fxD);
                    pabc->abcA = (int)lA;
                    pabc->abcB = (UINT)(lAB - lA);
                    pabc->abcC = (int)(lD - lAB);
                    pabc++;
                }
            }
            else
            {
                EFLOAT efWidth;

                for (pgpStop=pgp+cRet; pgp<pgpStop; pgp++)
                {
                    pgd = pgp->pgd();

                    efWidth = pgd->fxA;
                    efWidth *= efDtoW;
                    *((LONG *) &pabcf->abcfA) = efWidth.lEfToF();

                    efWidth = (pgd->fxAB - pgd->fxA);
                    efWidth *= efDtoW;
                    *((LONG *) &pabcf->abcfB) = efWidth.lEfToF();

                    efWidth = (pgd->fxD - pgd->fxAB);
                    efWidth *= efDtoW;
                    *((LONG *) &pabcf->abcfC) = efWidth.lEfToF();
                    pabcf++;
                }
            }

        // Compute number of elements left in the subset to process.

            cpgpSubset -= cRet;
            pwchSubset += cRet;

        } while (cpgpSubset > 0);

    // Subtract off the number processed.
    // cwch is now the number left to process.

        cwch -= cwchSubset;

    } while (cwch > 0);

    return (TRUE);
}

/******************************Public*Routine******************************\
* bGetNtoWScale                                                            *
*                                                                          *
* Calculates the Notional to World scaling factor for vectors that are     *
* parallel to the baseline direction.                                      *
*                                                                          *
* History:                                                                 *
*  Sat 21-Mar-1992 08:03:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL
bGetNtoWScale(
    EFLOAT *pefScale,   // return address of scaling factor
    DCOBJ& dco,         // defines device to world transformation
    RFONTOBJ& rfo,      // defines notional to device transformation
    PFEOBJ& pfeo        // defines baseline direction
    )
{
    MATRIX    mxNtoW, mxNtoD;
    EXFORMOBJ xoNtoW(&mxNtoW, DONT_COMPUTE_FLAGS);
    EXFORMOBJ xoNtoD(&mxNtoD, DONT_COMPUTE_FLAGS);

    xoNtoD.vSetElementsLToFx(
        rfo.pfdx()->eXX,
        rfo.pfdx()->eXY,
        rfo.pfdx()->eYX,
        rfo.pfdx()->eXX
        );
    xoNtoD.vRemoveTranslation();
    xoNtoD.vComputeAccelFlags();
    {
    //
    // The notional to world transformation is the product of the notional
    // to device transformation and the device to world transformation
    //

        EXFORMOBJ xoDtoW(dco, DEVICE_TO_WORLD);
        if (!xoDtoW.bValid())
        {
            WARNING("gdisrv!GreGetKerningPairs -- xoDtoW is not valid\n");
            return(FALSE);
        }
        if (!xoNtoW.bMultiply(xoNtoD,xoDtoW))
        {
            WARNING("gdisrv!GreGetKerningPairs -- xoNtoW.bMultiply failed\n");
            return(FALSE);
        }
        xoNtoW.vComputeAccelFlags();
    }

    IFIOBJ ifio(pfeo.pifi());
    EVECTORFL evflScale(ifio.pptlBaseline()->x,ifio.pptlBaseline()->y);
//
// normalize then trasform the baseline vector
//
    EFLOAT ef;
    ef.eqLength(*(POINTFL *) &evflScale);
    evflScale /= ef;
    if (!xoNtoW.bXform(evflScale))
    {
        WARNING("gdisrv!GreGetKerningPairs -- xoNtoW.bXform(evflScale) failed\n");
        return(FALSE);
    }
//
// The scaling factor is equal to the length of the transformed Notional
// baseline unit vector.
//
    pefScale->eqLength(*(POINTFL *) &evflScale);
//
// [kirko] This last scaling is a very embarrasing hack.
// If things are the way that I thing that they should be,
// then the calculation of the Notional to Device transformation
// should end here. But nooooooo. It just didn't seem to work.
// I put the extra scaling below it,
// because it seems to give the right number.
// The correct thing to do is understand what sort of numbers are
// being put into the Notional to Device transformations contained
// in the CONTEXTINFO structure in the RFONTOBJ.
//
    pefScale->vTimes16();

    return(TRUE);
}

/******************************Public*Routine******************************\
* GreGetKerningPairs                                                       *
*                                                                          *
* Engine side funcition for GetKerningPairs API. Calls to the font         *
* driver to get the information.                                           *
*                                                                          *
* History:                                                                 *
*  Mon 22-Mar-1993 21:38:26 -by- Charles Whitmer [chuckwh]                 *
* Added exception handling to the reading of the font driver data.         *
*                                                                          *
*  29-Oct-1992 Gilman Wong [gilmanw]                                       *
* Moved driver call out of this function and into PFEOBJ (as part of the   *
* IFI/DDI merge).                                                          *
*                                                                          *
*  Thu 20-Feb-1992 09:52:19 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/


ULONG
GreGetKerningPairs(
    HDC hdc,
    ULONG cPairs,
    KERNINGPAIR *pkpDst
)
{
    COUNT cPairsRet = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
    // Create and validate RFONT user objecct.

        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {
        // Lock down PFE user object.

            PFEOBJ pfeo(rfo.ppfe());

            ASSERTGDI (
                pfeo.bValid(),
                "gdisrv!GreGetKerningPairs(): bad HPFE\n" );

        // Is this a request for the count?
        //
        // When using client-server, (cPairs == 0) is the signal from the
        // client side that the return buffer is NULL and this is a request for
        // the count.
        //
        // However, callers that call directly to the server side may still
        // pass in NULL to request count.  Hence the need for both cases below.

            if ((cPairs == 0) || (pkpDst == (KERNINGPAIR *) NULL))
            {
                cPairsRet = ((ULONG) pfeo.pifi()->cKerningPairs);
            }
            else
            {
                // Get pointer to the kerning pairs from PFEOBJ.
                // Clip number of kerning pairs to not exceed capacity of the buffer.

                FD_KERNINGPAIR *pfdkpSrc;
                cPairsRet = min(pfeo.cKernPairs(&pfdkpSrc), cPairs);

                // Get the Notional to World scaling factor in the baseline direction.
                // Kerning values are scalers in the baseline direction.

                EFLOAT efScale;

                if (bGetNtoWScale(&efScale,dco,rfo,pfeo))
                {
                    // Set up to loop through the kerning pairs.

                    KERNINGPAIR *pkp       = pkpDst;
                    KERNINGPAIR *pkpTooFar = pkpDst + cPairsRet;

                    // Never trust a pkp given to us by a font driver!

                    __try
                    {
                        for ( ; pkp < pkpTooFar; pfdkpSrc += 1, pkp += 1 )
                        {
                            pkp->wFirst      = pfdkpSrc->wcFirst;
                            pkp->wSecond     = pfdkpSrc->wcSecond;
                            pkp->iKernAmount = (int) lCvt(efScale,(LONG) pfdkpSrc->fwdKern);
                        }
                    }

                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        cPairsRet = 0;
                    }
                }
                else
                {
                    WARNING("gdisrv!GreGetKerningPairs(): bGetNtoWScale failed\n");
                    cPairsRet = 0;
                }
            }
        }
        else
        {
            WARNING("gdisrv!GreGetKerningPairs(): could not lock HRFONT\n");
        }
    }
    else
    {
        WARNING("GreGetKerningPairs failed - invalid DC\n");
    }

    return(cPairsRet);
}

//
// A mask of all valid font mapper filtering flags.
//

#define FONTMAP_MASK    ASPECT_FILTERING



/******************************Public*Routine******************************\
* GreGetAspectRatioFilter
*
* Returns the aspect ration filter used by the font mapper for the given
* DC.  If no aspect ratio filtering is used, then a filter size of (0, 0)
* is returned (this is compatible with the Win 3.1 behavior).
*
* Returns:
*   TRUE if sucessful, FALSE otherwise.
*
* History:
*  08-Apr-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GreGetAspectRatioFilter (
    HDC    hdc,
    LPSIZE lpSize
    )
{
    BOOL bRet = FALSE;

// Parameter check.

    if ( lpSize == (LPSIZE) NULL )
    {
        WARNING("gdisrv!GreGetAspectRatioFilter(): illegal parameter\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return bRet;
    }

// Create and validate DC user object.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        WARNING("gdisrv!GreGetAspectRatioFilter(): invalid HDC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return bRet;   // return error
    }

// Create and validate PDEV user object.

    PDEVOBJ pdo(dco.hdev());

    ASSERTGDI (
        dco.bValid(),
        "gdisrv!GreGetAspectRatioFilter(): invalid HPDEV\n"
        );

// If mapper flags set, return device resolution.

    if ( dco.pdc->flFontMapper() & ASPECT_FILTERING )
    {
        lpSize->cx = pdo.ulLogPixelsX();
        lpSize->cy = pdo.ulLogPixelsY();
    }

// Otherwise, return (0,0)--this is compatible with Win 3.1.

    else
    {
        lpSize->cx = 0;
        lpSize->cy = 0;
    }

// Return success.

    bRet = TRUE;
    return bRet;
}

/******************************Public*Routine******************************\
* GreMarkUndeletableFont
*
* Mark a font as undeletable.  Private entry point for USERSRV.
*
* History:
*  Thu 10-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Put undeletable support in the handle manager.
*
*  25-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID GreMarkUndeletableFont(HFONT hfnt)
{
    HmgMarkUndeletable((HOBJ)hfnt, LFONT_TYPE);
}

/******************************Public*Routine******************************\
* GreMarkDeletableFont
*
* Mark a font as deletable.  Private entry point for USERSRV.
*
* Note:
*   This can't be used to mark a stock font as deletable.  Only PDEV
*   destruction can mark a stock font as deletable.
*
* History:
*  Thu 10-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Put undeletable support in the handle manager.
*
*  25-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID GreMarkDeletableFont(HFONT hfnt)
{
// We won't mark it deletable if it's a stock font.

    LFONTOBJ lfo((HLFONT) hfnt);

// Check that hfnt is good, nothing gurantees it's good.  We assert because
// it is a malicious situation if it is bad, but we must check.

    ASSERTGDI(lfo.bValid(), "ERROR user passed invalid hfont");

    if (lfo.bValid())
    {
    // Make sure it's not a stock font, User can't mark those as deletable.

        if (!(lfo.fl() & LF_FLAG_STOCK))
        {
            HmgMarkDeletable((HOBJ)hfnt, LFONT_TYPE);
        }
    }
}


/******************************Public*Routine******************************\
* GetCharSet()
*
* Fast routine to get the char set of the font currently in the DC.
*
* History:
*  23-Aug-1993 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/


DWORD GreGetCharSet
(
    HDC          hdc
)
{
    FLONG    flSim;
    POINTL   ptlSim;
    FLONG    flAboutMatch;
    PFE     *ppfe;

    DCOBJ dco (hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return (DEFAULT_CHARSET << 16); // correct error code
    }

    if (dco.ulDirty() & DIRTY_CHARSET)
    {
    // force mapping

        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "gdisrv!GetCharSet: bad pdev in dc\n");

        if (!pdo.bGotFonts())
            pdo.bGetDeviceFonts();

        LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

        if (!lfo.bValid())
        {
            WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
            return(DEFAULT_CHARSET << 16);
        }
        {
        // Stabilize the public PFT for mapping.

            SEMOBJ  so(ghsemPublicPFT);

        // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
        // a simulation type (ist)
        // also store charset to the DC

            ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch);

            ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
                      "NtGdiGetCharSet, charset is dirty\n");

        }
    }

    return dco.pdc->iCS_CP();
}

extern "C" DWORD NtGdiGetCharSet
(
    HDC          hdc
)
{
    return(GreGetCharSet(hdc));
}



/******************************Public*Routine******************************\
*
* int GreGetTextCharsetInfo
*
*
* Effects: stub to be filled
*
* Warnings:
*
* History:
*  06-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if 0
// this is win95 code inserted here as a comment:

int WINGDIAPI GetTextCharsetInfo( HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags )
{
    UINT charset;
    PFF hff ;
    sfnt_OS2Ptr pOS2;
    int i;

    if (!lpSig)
        return GetTextCharset( hdc );

    if( IsBadWritePtr(lpSig,sizeof(FONTSIGNATURE)) )
    {
    //
    // cant return 0 - thats ANSI_CHARSET!
    //
        return DEFAULT_CHARSET;
    }

    charset = GetTextCharsetAndHff(hdc, &hff);
    if (hff)
    {
        pOS2 = ReadTable( hff, tag_OS2 );
        if (pOS2)
        {
            if (pOS2->Version)
            {
            //
            // 1.0 or higher is TT open
            //
                for (i=0; i<4; i++)
                {
                    lpSig->fsUsb[i] = SWAPL(pOS2->ulCharRange[i]);
                }
                for (i=0; i<2; i++)
                {
                    lpSig->fsCsb[i] = SWAPL(pOS2->ulCodePageRange[i]);
                }
                return charset;
            }
        }
    }

    //
    // raster font/tt but not open/whatever, zero out the field.
    //
    lpSig->fsUsb[0] =
    lpSig->fsUsb[1] =
    lpSig->fsUsb[2] =
    lpSig->fsUsb[3] =
    lpSig->fsCsb[0] =
    lpSig->fsCsb[1] = 0;    // all zero - this font has no hff

    return charset;

}

#endif


/******************************Public*Routine******************************\
*
* int APIENTRY GreGetTextCharsetInfo(
*
* Effects: One of the new win95 multilingual api's
*
* Warnings:
*
* History:
*  17-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int APIENTRY GreGetTextCharsetInfo(
    HDC hdc,
    LPFONTSIGNATURE lpSig,
    DWORD dwFlags)
{
    dwFlags;      // not used

    DWORD  uiCharset = NtGdiGetCharSet(hdc) >> 16;
    if (!lpSig)
        return uiCharset;

// on to get the signature

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
    // Get RFONT user object.  Need this to realize font.

        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {
        // Get PFE user object.

            PFEOBJ pfeo(rfo.ppfe());
            if (pfeo.bValid())
            {
                PTRDIFF dpFontSig = 0;

                if (pfeo.pifi()->cjIfiExtra > offsetof(IFIEXTRA, dpFontSig))
                {
                    dpFontSig = ((IFIEXTRA *)(pfeo.pifi() + 1))->dpFontSig;
                }

                if (dpFontSig)
                {
                    *lpSig = *((FONTSIGNATURE *)
                               ((BYTE *)pfeo.pifi() + dpFontSig));
                }
                else
                {
                    lpSig->fsUsb[0] = 0;
                    lpSig->fsUsb[1] = 0;
                    lpSig->fsUsb[2] = 0;
                    lpSig->fsUsb[3] = 0;
                    lpSig->fsCsb[0] = 0;
                    lpSig->fsCsb[1] = 0;
                }
            }
            else
            {
                WARNING("GetFontData(): could not lock HPFE\n");
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);

            // this is what win95 returns on errors

                uiCharset = DEFAULT_CHARSET;
            }
        }
        else
        {
            WARNING("GetFontData(): could not lock HRFONT\n");

        // this is what win95 returns on errors

            uiCharset = DEFAULT_CHARSET;
        }
    }
    else
    {
        WARNING("GreGetTextCharsetInfo: bad handle for DC\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);

    // this is what win95 returns on errors

        uiCharset = DEFAULT_CHARSET;
    }

    return (int)uiCharset;
}


/******************************Public*Routine******************************\
*
* DWORD GreGetFontLanguageInfo(HDC hdc)
*
*
* Effects: This function returns some font information which, for the most part,
*          is not very interesting for most common fonts. I guess it would be
*          little bit more interesting in case of fonts that require
*          lpk processing, which NT does not support as of version 4.0,
*          or in case of tt 2.0.
*
* History:
*  01-Nov-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




DWORD dwGetFontLanguageInfo(XDCOBJ& dco)
{
    DWORD dwRet = GCP_ERROR;

// Get PDEV user object.  We also need to make
// sure that we have loaded device fonts before we go off to the font mapper.
// This must be done before the semaphore is locked.

    PDEVOBJ pdo(dco.hdev());

    if (!pdo.bValid())
        return dwRet;

    if (!pdo.bGotFonts())
        pdo.bGetDeviceFonts();

// Lock down the LFONT.

    LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);

    if (lfo.bValid())
    {
    // Stabilize font table (grab semaphore for public PFT).

        SEMOBJ  so(ghsemPublicPFT);

    // Lock down PFE user object.

        FLONG flSim;
        FLONG flAboutMatch;
        POINTL ptlSim;

        PFEOBJ pfeo(lfo.ppfeMapFont(dco,&flSim,&ptlSim, &flAboutMatch));

        ASSERTGDI (
            pfeo.bValid(),
            "gdisrv!GreGetTextFaceW(): bad HPFE\n"
            );

    // no failing any more, can set it to zero

        dwRet = 0;

        if (pfeo.pifi()->cKerningPairs)
            dwRet |= GCP_USEKERNING;

    // Also, FLI_MASK bit is "OR"-ed in, don't ask me why.
    // now we have win95 compatible result, whatever it may mean.

        if (pfeo.pifi()->flInfo & (FM_INFO_TECH_TRUETYPE | FM_INFO_TECH_TYPE1))
        {
        // only tt or otf fonts may contain glyphs that are not accessed
        // throught cmap table

            dwRet |= FLI_GLYPHS;
        }
    }
    else
    {
        WARNING("gdisrv!GreGetTextFaceW(): could not lock HLFONT\n");
    }

    return(dwRet);
}


/******************************Public*Routine******************************\
*
* DWORD GreGetFontUnicodeRanges(HDC, LPGLYPHSET);
*
* Effects: expose font's unicode content to the applications
*
* History:
*  09-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




DWORD GreGetFontUnicodeRanges(HDC hdc, LPGLYPHSET pgset)
{

    DWORD dwRet = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
    // Create and validate RFONT user objecct.

        RFONTOBJ rfo(dco, FALSE);
        if (rfo.bValid())
        {
        // Lock down PFE user object.

            PFEOBJ pfeo(rfo.ppfe());

            ASSERTGDI (
                pfeo.bValid(),
                "gdisrv!GreGetFontUnicodeRanges(): bad HPFE\n");

            FD_GLYPHSET * pfdg = pfeo.pfdg();

            if (!pfdg)
            {
                WARNING("gdisrv!GreGetFontUnicodeRanges(): pfdg invalid\n");
                return dwRet;
            }

        // Is this a request for the size of the buffer?

            dwRet = offsetof(GLYPHSET,ranges) + pfdg->cRuns * sizeof(WCRANGE);
            if (pgset)
            {
                pgset->cbThis           = dwRet;
                pgset->cGlyphsSupported = pfdg->cGlyphsSupported;
                pgset->cRanges          = pfdg->cRuns;

                pgset->flAccel          = 0;
                if (pfdg->flAccel & GS_8BIT_HANDLES)
                    pgset->flAccel |= GS_8BIT_INDICES;

                for (DWORD iRun = 0; iRun < pfdg->cRuns; iRun++)
                {
                    pgset->ranges[iRun].wcLow   = pfdg->awcrun[iRun].wcLow;
                    pgset->ranges[iRun].cGlyphs = pfdg->awcrun[iRun].cGlyphs;
                }
            }

            pfeo.vFreepfdg();
        }
        else
        {
            WARNING("gdisrv!GreGetFontUnicodeRanges(): could not lock HRFONT\n");
        }
    }
    else
    {
        WARNING("GreGetFontUnicodeRanges failed - invalid DC\n");
    }

    return(dwRet);
}


#ifdef LANGPACK
BOOL GreGetRealizationInfo( HDC hdc, PREALIZATION_INFO pri )
{
    BOOL bRet = FALSE;
    XDCOBJ dco(hdc);

    if(dco.bValid())
    {
        RFONTOBJ rfo(dco,FALSE);

        if(rfo.bValid())
        {
            bRet = rfo.GetRealizationInfo(pri);
        }
        else
        {
            WARNING("GreRealizationInfo: Invalid DC");
        }

        dco.vUnlockFast();
    }
    else
    {
        WARNING("GreGetRealizationInfo: Invalid DC");
    }

    return(bRet);

}

extern "C" BOOL EngLpkInstalled()
{
    return( gpGdiSharedMemory->dwLpkShapingDLLs != 0 );
}

#endif


/**************************Public*Routine***************************\
*
* BOOL  GreRemoveFontMemResourceEx()
*
* History:
*   09-Jun-1997  Xudong Wu [TessieW]
*  Wrote it.
*
\*******************************************************************/
BOOL  GreRemoveFontMemResourceEx(HANDLE hMMFont)
{
    BOOL    bRet = FALSE;
    PFF     *pPFF, **ppPFF;

    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

    PUBLIC_PFTOBJ pfto(gpPFTPrivate);

    if (pfto.bValid())
    {
        // Sundown safe truncation,  hMMFont is not a real handle
        if (pPFF = pfto.pPFFGetMM((ULONG)(ULONG_PTR)hMMFont, &ppPFF))
        {
            // remove the pPFF from the font table
            // bUnloadWorkhorse should release ghsemPublicPFT

            if (!(bRet = pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, FR_PRIVATE | FR_NOT_ENUM)))
            {
                WARNING("GreRemoveFontMemResourceEx() failed on bUnloadWorkhorse()\n");
            }
        }
        else
        {
            WARNING("GreRemoveFontMemResourceEx(): can't find the PFF\n");
            GreReleaseSemaphoreEx(ghsemPublicPFT);
        }
    }
    else
    {
        WARNING("GreRemoveFontMemResourceEx(): invalid private PFT table\n");
        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fontgdip.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontgdip.cxx
*
* Private font API entry points.
*
* Created: 26-Jun-1991 10:04:34
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
LONG lNormAngle(LONG lAngle);

/******************************Public*Routine******************************\
*
* VOID vSetLOCALFONT(HLFONT hlf, PVOID pvCliData)
*
* Effects:
*  set the pointer to the memory shared between client and
*  kernel
*
* History:
*  18-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vSetLOCALFONT(HLFONT hlf, PVOID pvCliData)
{
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hlf);
    pentry = &gpentHmgr[uiIndex];

    ASSERTGDI(uiIndex < gcMaxHmgr,"hfontcreate pentry > gcMaxHmgr");

    pentry->pUser = pvCliData;
}





/******************************Public*Routine******************************\
* GreSelectFont
*
* Server-side entry point for selecting a font into a DC.
*
* History:
*
*  Mon 18-Mar-1996 -by- Bodin Dresevic [BodinD]
* update: added ref counting in the kernel
*
*  22-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/


HFONT GreSelectFont(HDC hdc, HFONT hlfntNew)
{
    HLFONT hlfntOld = (HLFONT) 0;
    XDCOBJ dco(hdc);
    PLFONT plfnt;

    if (dco.bValid())
    {
    // Let us make sure it is ok to select this new font to a DC,
    // that is make sure that it is not marked deletable

        hlfntOld = (HLFONT)dco.pdc->plfntNew()->hGet();

        if ((HLFONT)hlfntNew != hlfntOld)
        {
        // Lock down the new logfont handle so as to get the pointer out
        // This also increments the reference count of the new font

            plfnt = (PLFONT)HmgShareCheckLock((HOBJ)hlfntNew, LFONT_TYPE);

        // What if this did not work?

            if (plfnt)
            {
            // if marked for deletion, refuse to select it in

                if (!(PENTRY_FROM_POBJ(plfnt)->Flags & HMGR_ENTRY_LAZY_DEL))
                {
                // undo the lock from when the brush was selected

                    DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(dco.pdc->plfntNew());

                // set the new lfont:

                    dco.pdc->plfntNew(plfnt);
                    dco.pdc->hlfntNew((HLFONT)hlfntNew);

                    dco.ulDirtyAdd(DIRTY_CHARSET);

                // same as CLEAR_CACHED_TEXT(pdcattr);

                    dco.ulDirtySub(SLOW_WIDTHS);
                }
                else
                {
                    DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(plfnt);
                    hlfntOld = 0;
                }
            }
            else
            {
                hlfntOld = 0;
            }
        }
        dco.vUnlockFast();
    }

#if DBG
    else
    {
        WARNING1("GreSelectFont passed invalid DC\n");
    }
#endif

// return old HLFONT

    return((HFONT)hlfntOld);
}

/******************************Public*Routine******************************\
* hfontCreate
*
* Creates the file with an LOGFONTW and a type.
*
* History:
*  Sun 13-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

HFONT hfontCreate(ENUMLOGFONTEXDVW * pelfw, LFTYPE lft, FLONG  fl, PVOID pvCliData)
{
    HFONT hfReturn;

    TRACE_FONT(("hfontCreate: ENTERING, font name %ws\n", pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName));

    if (pelfw &&
        pelfw->elfDesignVector.dvNumAxes <= MM_MAX_NUMAXES)
    {
    // We must Allocate - init object - add to hmgr table.
    // Otherwise possible crash if bad app uses newly created handle
    // before init finishes.

        ULONG cjElfw = offsetof(ENUMLOGFONTEXDVW,elfDesignVector) +
                       SIZEOFDV(pelfw->elfDesignVector.dvNumAxes) ;

        PLFONT plfnt = (PLFONT) ALLOCOBJ(offsetof(LFONT,elfw)+cjElfw,LFONT_TYPE,FALSE);

        if (plfnt != NULL)
        {
            plfnt->lft = lft;
            plfnt->fl = fl;
            plfnt->cjElfw_ = cjElfw;
            RtlCopyMemory(&plfnt->elfw, pelfw, cjElfw);
            plfnt->cMapsInCache = 0;

        // Add the upper case version of the facename to the LFONT.

            cCapString
            (
                plfnt->wcCapFacename,
                pelfw->elfEnumLogfontEx.elfLogFont.lfFaceName,
                LF_FACESIZE
            );

        // Normalize the orientation angle.  This saves the mapper from doing it.

            pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation
            = lNormAngle(pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation);

            hfReturn = (HFONT) HmgInsertObject((HOBJ)plfnt,0,LFONT_TYPE);

            if (hfReturn != (HFONT) 0)
            {
                vSetLOCALFONT((HLFONT)hfReturn, pvCliData);
                TRACE_FONT(("hfontCreate: SUCCESS\n"));
                return(hfReturn);
            }

            WARNING("hfontCreate failed HmgInsertObject\n");
            FREEOBJ(plfnt, LFONT_TYPE);
        }
    }
    else
    {
        WARNING("hfontCreate invalid parameter\n");
    }

    TRACE_FONT(("hfontCreate: FAILIURE\n"));

    return((HFONT) 0);
}


/******************************Public*Routine******************************\
* BOOL bDeleteFont
*
* Destroys the LFONT object identified by the handle, hlfnt.
*
* History:
*  Thu 10-Jun-1993 -by- Patrick Haluptzok [patrickh]
* Change deletion to check for other locks.
*
*  26-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bDeleteFont(HLFONT hlfnt, BOOL bForceDelete)
{
    BOOL bRet = TRUE;
    PLFONT plfnt;
    BOOL   bDelete = TRUE;

    TRACE_FONT(("Entering bDeleteFont\n"
                "    hlfnt = %x, bForceDelete = %d\n", hlfnt, bForceDelete));

    HANDLELOCK LfontLock;

    //
    // Old comment from bodind:
    //    Isn't this operation incresing share ref count?
    //
    // This should be investigated.
    //

    LfontLock.bLockHobj((HOBJ)hlfnt, LFONT_TYPE);

    if (LfontLock.bValid())
    {
        POBJ pObj = LfontLock.pObj();
        ASSERTGDI(pObj->cExclusiveLock == 0,
            "deletefont - cExclusiveLock != 0\n");

    // if brush still in use mark for lazy deletion and return true

        if (LfontLock.ShareCount() > 0)
        {
            LfontLock.pentry()->Flags |= HMGR_ENTRY_LAZY_DEL;
            bDelete = FALSE;
        }

    // We always force delete of LOCALFONT client side structure
    // in the client side, therefore we can set the pointer to this
    // structure to zero

        LfontLock.pentry()->pUser = NULL;

    // Done

        LfontLock.vUnlock();
    }
    else
    {
        bRet    = FALSE;
        bDelete = FALSE;
    }

    if (bDelete)
    {
        if ((plfnt = (LFONT *) HmgRemoveObject((HOBJ)hlfnt, 0, 0, bForceDelete, LFONT_TYPE)) != NULL)
        {
            FREEOBJ(plfnt, LFONT_TYPE);
            bRet = TRUE;
        }
        else
        {
            WARNING1("bDeleteFont failed HmgRemoveObject\n");
            bRet = FALSE;
        }
    }

    TRACE_FONT(("Exiting bDeleteFont\n"
                "    return value = %d\n", bRet));
    return(bRet);
}

/******************************Public*Routine******************************\
* GreSetFontEnumeration
*
* Comments:
*   This function is intended as a private entry point for Control Panel.
*
\**************************************************************************/

ULONG APIENTRY NtGdiSetFontEnumeration(ULONG ulType)
{
    return (GreSetFontEnumeration(ulType));
}

ULONG GreSetFontEnumeration(ULONG ulType)
{
    ULONG ulOld;

    if (ulType & ~(FE_FILTER_TRUETYPE | FE_AA_ON  | FE_SET_AA |
                    FE_CT_ON | FE_SET_CT))
    {
        WARNING("GreSetFontEnumeration(): unknown ulType %ld\n");
    }

    ulOld = gulFontInformation;

    if(ulType & FE_SET_AA)
      gulFontInformation = (ulType & FE_AA_ON) | (ulOld & FE_CT_ON) | (ulOld & FE_FILTER_TRUETYPE);
    else if (ulType & FE_SET_CT)
      gulFontInformation = (ulType & FE_CT_ON) | (ulOld & FE_AA_ON) | (ulOld & FE_FILTER_TRUETYPE);
    else
      gulFontInformation = (ulType & FE_FILTER_TRUETYPE) | (ulOld & FE_AA_ON) |  (ulOld & FE_CT_ON);

    return ulOld;
}

ULONG GreSetFontContrast(ULONG ulContrast)
{
    ULONG ulOld;


    ulOld = gulGamma;
    gulGamma = ulContrast;

    return ulOld;
}

ULONG GreGetFontEnumeration(VOID)
{
    return gulFontInformation;
}

ULONG GreGetFontContrast(VOID)
{
    return gulGamma;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fontsub.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontsub.cxx
*
* Support for the [FontSubstitutes] section of WIN.INI (new functionality
* from Windows 3.1).
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

// In Windows 3.1, there is a [FontSubstitutes] section that allows
// face names in LOGFONTs to match other facenames.
//
// For example,
//
//  [FontSubstitutes]
//      Helv=MS Sans Serif
//
// means that a LOGFONT with a lfFacename of "Helv" will match a physical
// font with a facename of either "Helv" or "MS Sans Serif".  That is,
// "Helv" has an alternate match (or substitute match) of "MS Sans Serif".
//
// In Win 3.1, the standard "Helv" and "Tms Rmn" faces have been replaced
// with "MS Sans Serif" and "MS Serif", respectively.  This substitution
// capability provides Win 3.1 with Win 3.0 compatibility for apps that
// use the old name convention.

#include "precomp.hxx"
#include "winuserp.h"

extern "C" VOID vInitFontSubTable();
extern "C" NTSTATUS QueryRegistryFontSubstituteListRoutine(
                                     PWSTR,ULONG,PVOID,ULONG,PVOID,PVOID);

#pragma alloc_text(INIT, vInitFontSubTable)
#pragma alloc_text(INIT, QueryRegistryFontSubstituteListRoutine)

// #define DBG 1

#if DBG
VOID DbgPrintFontSubstitutes();
#endif

// This is a global reference to the font substitution table.  If the table
// is not initialized properly, then this is NULL and should not be
// dereferenced.

PFONTSUB gpfsTable = NULL;;

// Set the initial as 1 for we need to hack for Notes R5

COUNT    gcfsTable = 0;

// count of valid entries of the form face1,ch1=face2,ch2

COUNT    gcfsCharSetTable = 0;
BOOL     gbShellFontCompatible = FALSE;


/******************************Public*Routine******************************\
*
* PWSTR pwszFindComma(PWSTR pwszInput)
*
*
* Effects:   return the pointer to the charset string which is
*            starting immediately after the comma or if no comma is found,
*            return NULL
*
* History:
*  27-Jun-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

static
const WCHAR * pwszFindComma(const WCHAR * pwszInput)
{
    const WCHAR * pwszEnd = pwszInput + LF_FACESIZE;

    for (; (*pwszInput != L'\0') && (pwszInput < pwszEnd); pwszInput++)
    {
        if (*pwszInput == L',')
            return (++pwszInput);
    }
    return NULL;
}



extern "C"

VOID vCheckCharSet(FACE_CHARSET *pfcs, const WCHAR * pwsz); // in mapfile.c


/******************************Public*Routine******************************\
*
* VOID vProcessEntry
*
*
* Effects:  given value name string (or value data string)
*           produce face name string and charset
*
* History:
*  28-Jun-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

static
HRESULT vProcessEntry(const WCHAR * pwszIn, FACE_CHARSET *pfcs, WCHAR * pwszOriginal)
{
    const WCHAR * pwszCharSet;
    INT      cwc;

// now is the time to see if this is one of the entries of the form
// Face1=Face2 (old format), or if this is one of the new entries of the form:
// Face1,charset1=Face2,charset2.

    if (pwszCharSet = pwszFindComma(pwszIn))
    {
        //Sundown: cwc is within range of LF_FASESIZE which is 32
        // safe to truncate
        cwc = (INT)(pwszCharSet - pwszIn);

    // now need to produce and validate charset number from the string
    // that follows the comma

        vCheckCharSet(pfcs, pwszCharSet);
    }
    else
    {
    // mark the field as being left unspecified. In mapping this means
    // do not replace lfCharSet in the logfont when trying the alternate
    // name. In enumeration this means that this field should not be
    // taken into account

        cwc = LF_FACESIZE;
        pfcs->jCharSet = DEFAULT_CHARSET;
        pfcs->fjFlags  = FJ_NOTSPECIFIED;
    }

// now write the string

    cCapString(pfcs->awch, pwszIn, cwc);

// finally save the original facename which is not necessarrily capitalized

    HRESULT hr = S_OK;
    if (pwszOriginal)
    {
        if (pwszCharSet)
        {
            cwc--;
            RtlMoveMemory(pwszOriginal, pwszIn, cwc * sizeof(WCHAR));
            pwszOriginal[cwc] = L'\0';
        }
        else
        {
            hr = StringCchCopyW(pwszOriginal, cwc, pwszIn);
        }
    }
    return hr;
}

extern "C"
NTSTATUS
QueryRegistryFontSubstituteListRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{

    PBYTE pjBuffer;
    FONTSUB fs;

    if (FAILED(vProcessEntry((const WCHAR *) ValueData, &fs.fcsAltFace, NULL)) ||
        FAILED(vProcessEntry(ValueName, &fs.fcsFace, fs.awchOriginal)))
    {
        WARNING("Ignoring invalid font substitute entry\n");
        return STATUS_SUCCESS;
    }

// the following check eliminates the garbage entries that may have possibly
// been entered in win.ini in the font substitution section

    if
    (
       (fs.fcsFace.fjFlags == fs.fcsAltFace.fjFlags)
       &&
       (fs.fcsFace.fjFlags != FJ_GARBAGECHARSET)
    )
    {
        pjBuffer = (PBYTE) PALLOCMEM((gcfsTable+1) * sizeof(FONTSUB),'bsfG');

        if (pjBuffer)
        {
            if (gpfsTable)
            {
                RtlMoveMemory(pjBuffer,
                              gpfsTable,
                              gcfsTable * sizeof(FONTSUB));

                VFREEMEM(gpfsTable);
            }

            gpfsTable = (PFONTSUB) pjBuffer;

        // copy new data that we have verified to be valid

            gpfsTable[gcfsTable] = fs;
            gcfsTable++;
            if (!fs.fcsFace.fjFlags) // if charset is specified
                gcfsCharSetTable++;

            if (!gbShellFontCompatible &&
                ! _wcsicmp(fs.fcsFace.awch, L"MS Shell Dlg") && 
                ! _wcsicmp(fs.fcsAltFace.awch, L"Microsoft Sans Serif")
            )
                gbShellFontCompatible = TRUE;
        }
        else
        {
        // we do not have enough memory - return failiure

            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;

}
/******************************Public*Routine******************************\
* vInitFontSubTable
*
* Initializes the font substitutes table from data in the [FontSubstitutes]
* section of the WIN.INI file.  No error return code is provided since, if
* this is not successful, then the table simply will not exist and the
* global pointer to the table will remain NULL.
*
\**************************************************************************/

extern "C" VOID vInitFontSubTable()
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS Status;

    QueryTable[0].QueryRoutine = QueryRegistryFontSubstituteListRoutine;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    //
    // Initialize to an empty table
    //

    gpfsTable = (PFONTSUB) NULL;
    gcfsTable = 1;
    gcfsCharSetTable = 0;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"FontSubstitutes",
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(Status))
    {
        WARNING("Failiure to get font list\n");
    }

    // by now, the substitution table should exist already, if not because there is nothing in the
    // registry for instance, then we allocate it now and fill the first entry.

    if (!gpfsTable)
    {
        gpfsTable = (PFONTSUB) PALLOCMEM(gcfsTable * sizeof(FONTSUB),'bsfG');
    }

    if (gpfsTable)
    {
        const static WCHAR Default_Sans_Serif[] = L"Default Sans Serif";
        const static WCHAR DEFAULT_SANS_SERIF[] = L"DEFAULT SANS SERIF";
        const static WCHAR MS_SANS_SERIF[] = L"MS SANS SERIF";

        C_ASSERT(sizeof(gpfsTable->awchOriginal) >= sizeof(Default_Sans_Serif));
        C_ASSERT(sizeof(gpfsTable->fcsFace.awch) >= sizeof(DEFAULT_SANS_SERIF));
        C_ASSERT(sizeof(gpfsTable->fcsAltFace.awch) >= sizeof(MS_SANS_SERIF));

        RtlCopyMemory(gpfsTable->awchOriginal, Default_Sans_Serif, sizeof(Default_Sans_Serif));
        RtlCopyMemory(gpfsTable->fcsFace.awch, DEFAULT_SANS_SERIF, sizeof(DEFAULT_SANS_SERIF));
        RtlCopyMemory(gpfsTable->fcsAltFace.awch, MS_SANS_SERIF, sizeof(MS_SANS_SERIF));

        gpfsTable->fcsFace.jCharSet = DEFAULT_CHARSET;
        gpfsTable->fcsFace.fjFlags  = FJ_NOTSPECIFIED;
        gpfsTable->fcsAltFace.jCharSet = DEFAULT_CHARSET;
        gpfsTable->fcsAltFace.fjFlags  = FJ_NOTSPECIFIED;
    }
    else
    {
        gcfsTable = 0;
    }

#if 0 // don't want to do this any more
    DbgPrintFontSubstitutes();
#endif

}


/******************************Public*Routine******************************\
* pfsubAlternateFacename
*
* Search the font substitutes table for an alternative facename for the
* given facename.
*
* Return:
*   Pointer to alt facename, NULL if not found.
*
* History:
*  28-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFONTSUB pfsubAlternateFacename (
    const WCHAR * pwchFacename
    )
{
    PFONTSUB pfs = gpfsTable;
    PFONTSUB pfsEnd = gpfsTable + gcfsTable;
    WCHAR    awchCapName[LF_FACESIZE];

// Want case insensitive search, so capitalize the name.

    cCapString(awchCapName, pwchFacename, LF_FACESIZE);

// Scan through the font substitution table for the key string.

    for (; pfs < pfsEnd; pfs++)
    {
        if
        (
            !wcscmp(awchCapName,pfs->fcsFace.awch) &&
            ((pfs->fcsFace.fjFlags & FJ_NOTSPECIFIED) || (pfs->fcsFace.jCharSet == pfs->fcsAltFace.jCharSet))
        )
        {
        // This routine is only used in font enumeration when facename of
        // the fonts that are wished to be enumerated is specified as input.
        // We only want to enumerate the correct charsets, that is those that
        // are specified on the right hand side (if they are specified at all)

            if (pfs == gpfsTable)
            {
                // check the compatibility flag.
                if (GetAppCompatFlags2(VER40) & GACF2_FONTSUB)
                    return pfs;
            }
            else
                return pfs;
        }
    }

// Nothing found, so return NULL.

    return NULL;
}

/******************************Public*Routine******************************\
*
* pfsubGetFontSub
*
* Effects:
*
* Warnings:
*
* History:
*  05-Feb-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



FONTSUB * pfsubGetFontSub (
    const WCHAR * pwchFacename,   // face name specified in logfont
    BYTE    lfCharset       // charset specified in logfont
    )
{
    PFONTSUB pfs = gpfsTable;
    PFONTSUB pfsEnd = gpfsTable + gcfsTable;
    WCHAR    awchCapName[LF_FACESIZE];

// We will set pfsNameOnly to point to a pfsub entry if for this entry
// the charset is NOT specified and the facename maches the facename
// from the logfont. That is pfsNameOnly can only point to an old style
// substitution of the form facename1=facename2.

    PFONTSUB pfsNameOnly = NULL;

// We will set pfsNameAndCharset to point to a pfsub entry if for this entry
// the charset IS specified and both facename and charset match.
// If both pfsNameAndCharset and pfsNameOnly are nonzero after going through
// the font substitution list, we will return pfsNameAndCharset from
// the function. For example, font substitution table for the Russian locale
// on win95 may have all three of the following entries:
//
// Times=Times New Roman    // old style value
// Times,204=Times New Roman,204
// Times,0=Times New Roman,204
//
// Thus if the application specifies Times,0 or Times,204 in the logfont,
// Times New Roman,204 will be used. If the application asks for Times,161
// it will get Times New Roman,161.


    PFONTSUB pfsNameAndCharset = NULL;

// Want case insensitive search, so capitalize the name.

    cCapString(awchCapName, pwchFacename, LF_FACESIZE);

// Scan through the font substitution table for the key string.

    for (; pfs < pfsEnd; pfs++)
    {
    // Do wcscmp inline for speed:

        if (!wcscmp(awchCapName,pfs->fcsFace.awch))
        {
        // we found a facename match, check if we should match charset
            if (pfs == gpfsTable)
            {
                // check the compatibility flag.
                if (GetAppCompatFlags2(VER40) & GACF2_FONTSUB)
                {
                    pfsNameOnly = pfs;
                    break;
                }
            }
            else
            {
                if (pfs->fcsFace.fjFlags & FJ_NOTSPECIFIED)
                {
                    pfsNameOnly = pfs;
                }
                else // charset is specified, now see if it matches the logfont
                {
                    if (lfCharset == pfs->fcsFace.jCharSet)
                        pfsNameAndCharset = pfs;
                }
            }
        }
    }

    return (pfsNameAndCharset ? pfsNameAndCharset : pfsNameOnly);
}




#if DBG
VOID DbgPrintFontSubstitutes()
{
    PFONTSUB pfs = gpfsTable;
    PFONTSUB pfsEnd = gpfsTable + gcfsTable;

    //
    // Scan through the font substitution table for the key string.
    //

    KdPrint(("[FontSubstitutes]\n"));

    for (; pfs < pfsEnd; pfs++)
        KdPrint(("\t%ws: %ws, %d, fj=0x%x = %ws, %d, fj=0x%x \n",
                  pfs->awchOriginal,
                  pfs->fcsFace.awch,
                  (USHORT)pfs->fcsFace.jCharSet,
                  (USHORT)pfs->fcsFace.fjFlags,
                  pfs->fcsAltFace.awch,
                  (USHORT)pfs->fcsAltFace.jCharSet,
                  (USHORT)pfs->fcsAltFace.fjFlags
                  ));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\globals.c ===
/******************************Module*Header*******************************\
* Module Name: globals.c
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
* This module contains all the global variables used in the graphics engine.
* The extern declarations for all of these variables are in engine.h
*
* One should try to minimize the use of globals since most operations are
* based of a PDEV, and different PDEVs have different characteristics.
*
* Globals should basically be limited to globals locks and other permanent
* data structures that never change during the life of the system.
*
* Created: 20-Jun-1995
* Author: Andre Vachon [andreva]
*
\**************************************************************************/


#include "engine.h"

/**************************************************************************\
*
* SEMAPHORES
*
\**************************************************************************/

//
// Define the Driver Management Semaphore.  This semaphore must be held
// whenever a reference count for an LDEV or PDEV is being modified.  In
// addition, it must be held whenever you don't know for sure that a
// reference count of the LDEV or PDEV you are using is non-zero.
//
// The ghsemDriverMgmt semaphore is used to protect the list of drivers.
// When traversing the list, ghsemDriverMgmt must be held, unless you
// can guarentee that 1) no drivers will be removed and 2) new drivers are
// always inserted at the head of the list.  If these two conditions are met,
// then other processes can grab (make a local copy of) the list head under
// semaphore protection.  This list can be parsed without regard to any new
// drivers that may be pre-pended to the list.  One way to ensure that no
// drivers will be removed is to increment the reference count for each driver
// in the list and then unreference the drivers as they are no longer needed.
// An alternative method to safely parse the list and still allow dirvers to
// be added or removed is as follows:
//      1. grab ghsemDriverMgmt
//      2. obtain pointer to first driver
//      3. reference driver
//      4. release ghsemDriverMgmt
//      5. do some processing
//      6. grab ghsemDriverMgmt
//      7. obtain pointer to next driver
//      8. unreference previous driver
//      9. repeat 2 to 8 until reaching the end of the list
//     10. release ghsemDriverMgmt
//

HSEMAPHORE ghsemDriverMgmt;
HSEMAPHORE ghsemCLISERV;
HSEMAPHORE ghsemRFONTList;
HSEMAPHORE ghsemAtmfdInit;

//
// ghsemPalette synchronizes selecting a palette in and out of DC's and the
// use of a palette without the protection of a exclusive DC lock.
// ResizePalette forces us to protect ourselves because the pointer can
// change under our feet.  So we need to be able to synchronize use of
// the ppal by ghsemPalette and exclusive lock of DC.
//

HSEMAPHORE ghsemPalette;

//
// Define the global PFT semaphore.  This must be held to access any of the
// physical font information.
//

HSEMAPHORE ghsemPublicPFT;
//
// Global semaphore used for spooling
//

HSEMAPHORE ghsemGdiSpool;

// WNDOBJ operations semaphore
HSEMAPHORE ghsemWndobj;

// glyphset of PFE  operations semaphore
HSEMAPHORE ghsemGlyphSet;

#if DBG_CORE
HSEMAPHORE ghsemDEBUG;
#endif

//
// shared devive lock semaphore
//
// ghsemShareDevLock may be acquired for shared access at any time
//
// A thread must be careful when acquiring exclusive accesss.  It must not
// hold exclusive access to dev lock otherwise it may cause deadlock to
// occur.
//

HSEMAPHORE ghsemShareDevLock;

//
// The gAssociationListMutex is used to synchronize access to the
// watchdog code's association list.
//

HFASTMUTEX gAssociationListMutex;

/**************************************************************************\
*
* LIST POINTERS
*
\**************************************************************************/



/**************************************************************************\
*
* Drawing stuff
*
\**************************************************************************/

//
// This is to convert BMF constants into # bits per pel
//

ULONG gaulConvert[7] =
{
    0,
    1,
    4,
    8,
    16,
    24,
    32
};




/**************************************************************************\
*
* Font stuff
*
\**************************************************************************/

//
// initialize to some value that's not equal to a Type1 Rasterizer ID
//
UNIVERSAL_FONT_ID gufiLocalType1Rasterizer = { A_VALID_ENGINE_CHECKSUM, 0 };

//
// System default language ID.
//

USHORT gusLanguageID;

//
// Is the system code page DBCS?
//

BOOL gbDBCSCodePage;

//
// Number of TrueType font files loaded.
//

ULONG gcTrueTypeFonts;

//
// The global font enumeration filter type.  It can be set to:
//  FE_FILTER_NONE      normal operation, no extra filtering applied
//  FE_FILTER_TRUETYPE  only TrueType fonts are enumerated
//

ULONG gulFontInformation;

// for system default charset

BYTE  gjCurCharset;
DWORD gfsCurSignature;

// gbGUISetup is set to TRUE during the system GUI setup
// otherwise FALSE

BOOL gbGUISetup = FALSE;

// Globals used for GDI tracing
#if DBG_TRACE
GDITraceClassMask   gGDITraceClassMask[GDITRACE_TOTAL_CLASS_MASKS] = { 0 };
GDITraceKeyMask     gGDITraceKeyMask[GDITRACE_TOTAL_KEY_MASKS] = { 0 };
GDITraceKeyMask     gGDITraceInternalMask[GDITRACE_TOTAL_KEY_MASKS] = { 0 };
HANDLE              gGDITraceHandle1 = NULL;
HANDLE              gGDITraceHandle2 = NULL;
BOOL                gGDITraceHandleBreak = FALSE;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fontsup.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontsup.cxx
*
* Supplementary services needed by fonts.
*
* Currently consists mostly of UNICODE<->ASCII routines stolen from BodinD's
* Windows bitmap font driver.
*
* Created: 21-Jan-1991 10:14:53
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
*
\**************************************************************************/

#include "precomp.hxx"
#include "grerc.h"

VOID vArctan(EFLOAT, EFLOAT,EFLOAT&, LONG&);
BOOL bValidFont(IFIMETRICS *);

// typedef struct tagTHREADINFO        *PTHREADINFO;

extern "C" DWORD GetAppCompatFlags(PVOID);
extern "C" BOOL InitializeScripts();

#pragma alloc_text(INIT, InitializeScripts)

VOID vIFIMetricsToEnumLogFontW (
    ENUMLOGFONTW  *pelfw,
    IFIMETRICS    *pifi
    )
{

    IFIOBJ ifio(pifi);

    pelfw->elfLogFont.lfHeight         = ifio.lfHeight();
    pelfw->elfLogFont.lfWidth          = ifio.lfWidth();
    pelfw->elfLogFont.lfWeight         = ifio.lfWeight();
    pelfw->elfLogFont.lfItalic         = ifio.lfItalic();
    pelfw->elfLogFont.lfUnderline      = ifio.lfUnderline();
    pelfw->elfLogFont.lfStrikeOut      = ifio.lfStrikeOut();
    pelfw->elfLogFont.lfCharSet        = ifio.lfCharSet();
    pelfw->elfLogFont.lfEscapement     = ifio.lfEscapement();
    pelfw->elfLogFont.lfOrientation    = ifio.lfOrientation();
    pelfw->elfLogFont.lfPitchAndFamily = ifio.lfPitchAndFamily();

// These are special IFIOBJ methods that return Win 3.1 compatible
// enumeration values.

    pelfw->elfLogFont.lfOutPrecision   = ifio.lfOutPrecisionEnum();
    pelfw->elfLogFont.lfClipPrecision  = ifio.lfClipPrecisionEnum();
    pelfw->elfLogFont.lfQuality        = ifio.lfQualityEnum();

//
// Copy the name strings making sure that they are zero terminated
//
    wcsncpy(pelfw->elfLogFont.lfFaceName,ifio.pwszFamilyName(),LF_FACESIZE);
    pelfw->elfLogFont.lfFaceName[LF_FACESIZE-1] = 0;
    wcsncpy(pelfw->elfFullName,ifio.pwszFaceName(),LF_FULLFACESIZE);
    pelfw->elfFullName[LF_FULLFACESIZE-1]       = 0;
    wcsncpy(pelfw->elfStyle,ifio.pwszStyleName(),LF_FACESIZE);
    pelfw->elfStyle[LF_FACESIZE-1]          = 0;

}

VOID vLookupScript(ULONG lfCharSet, WCHAR *pwszScript);


/******************************Public*Routine******************************\
*
*
* Units are in NOTIONAL units since font is not realized.
*
* History:
*  Fri 16-Aug-1991 22:01:17 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID vIFIMetricsToEnumLogFontExDvW (
    ENUMLOGFONTEXDVW * plfw,
    IFIMETRICS    *pifi
    )
{

    vIFIMetricsToEnumLogFontW ((ENUMLOGFONTW *)plfw,pifi);

// lookup script, not ENUMLOGFONTW but is in ENUMLOGFONTEX

    vLookupScript((ULONG)pifi->jWinCharSet, (WCHAR *)plfw->elfEnumLogfontEx.elfScript);

// pick the design vector

    ULONG   cAxes = 0;
    if (pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF       dpDesVec = 0;
        DESIGNVECTOR *pdvSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpDesignVector))
        {
            dpDesVec = ((IFIEXTRA *)(pifi + 1))->dpDesignVector;
            pdvSrc = (DESIGNVECTOR *)((BYTE *)pifi + dpDesVec);
            cAxes  = pdvSrc->dvNumAxes;

            if (cAxes > MM_MAX_NUMAXES)
                cAxes = MM_MAX_NUMAXES;
                
            RtlCopyMemory(&plfw->elfDesignVector, pdvSrc, (SIZE_T)SIZEOFDV(cAxes));
            plfw->elfDesignVector.dvNumAxes = cAxes;
        }
        else
        {
            ASSERTGDI(dpDesVec, "dpDesignVector == 0 for mm instance\n");
            plfw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
            plfw->elfDesignVector.dvNumAxes = 0;
        }
    }
    else
    {
        plfw->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
        plfw->elfDesignVector.dvNumAxes = 0;
    }
}


/******************************Public*Routine******************************\
* BOOL bIFIMetricsToLogFontW2                                              *
*                                                                          *
* Used during font enumeration.                                            *
*                                                                          *
* Fill a LOGFONT structure using the information in a IFIMETRICS           *
* structure.                                                               *
*                                                                          *
* The following fields need to be transformed by the Device to World       *
* transform:                                                               *
*                                                                          *
*       lfHeight    (from pifi->fwdMaxBaselineExt)                         *
*       lfWidth     (from pifi->fwdAveCharWidth)                           *
*                                                                          *
* In the case of scalable fonts, these quantities are first prescaled      *
* into                                                                     *
* device units to be the equivalent of a 24 point font.                    *
* This is for Win 3.1                                                      *
* compatibility with EnumFonts.                                            *
*                                                                          *
* Return:                                                                  *
*   TRUE if successful, FALSE if an error occurs.                          *
*                                                                          *
* History:                                                                 *
*  9-Oct-1991 by Gilman Wong [gilmanw]                                     *
* Added scalable font support.                                             *
*  Wed 14-Aug-1991 13:42:22 by Kirk Olynyk [kirko]                         *
* Changed the LOGFONTA to a LOGFONTW.                                      *
*  02-May-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bIFIMetricsToLogFontW2 (
    DCOBJ       &dco,
    ENUMLOGFONTEXW   *pelfw,
    PIFIMETRICS pifi,
    EFLOATEXT        efScale
    )
{
    IFIOBJ ifio(pifi);

// do all the conversions except for the height and width

    vIFIMetricsToEnumLogFontW((ENUMLOGFONTW *)pelfw,pifi);

    if (ifio.bContinuousScaling())
    {
        pelfw->elfLogFont.lfWidth  = lCvt(efScale, ifio.lfWidth());
        pelfw->elfLogFont.lfHeight = lCvt(efScale, ifio.lfHeight());
    }

//
// At this point the height and width of the logical font are in pixel units
// in device space. We must still transform these to world coordiantes
//
    EXFORMOBJ xoToWorld(dco, DEVICE_TO_WORLD);

    if (!xoToWorld.bValid())
    {
        WARNING("gdisrv!bIFIMetricsToLogFontW2(): EXFORMOBJ constructor failed\n");
        return (FALSE);
    }

// Only if not identity transform do we need to do anything more.

    if (!xoToWorld.bTranslationsOnly())
    {
        EFLOATEXT efA, efB;

        {
        //
        // efB == baseline scaling factor
        //
            EVECTORFL evflB;

            EVECTORFL evflA(ifio.pptlBaseline()->x,ifio.pptlBaseline()->y);
            efB.eqLength(evflA);
            evflB.eqDiv(evflA,efB);

            if (!xoToWorld.bXform(evflB))
            {
                WARNING("gdisrv!bIFIMetricsToLogFontW2(): transform failed\n");
                return (FALSE);
            }
            efB.eqLength(evflB);
        }
        pelfw->elfLogFont.lfWidth = lCvt(efB, pelfw->elfLogFont.lfWidth);

        {
        //
        // efA == ascender scaling factor
        //
            EVECTORFL evflB;

            EVECTORFL evflA(-ifio.pptlBaseline()->y,ifio.pptlBaseline()->x);
            efA.eqLength(evflA);
            evflB.eqDiv(evflA,efA);

            if (!xoToWorld.bXform(evflB))
            {
                WARNING("gdisrv!bIFIMetricsToLogFontW2(): transform failed\n");
                return (FALSE);
            }
            efA.eqLength(evflB);
        }
        pelfw->elfLogFont.lfHeight = lCvt(efA, pelfw->elfLogFont.lfHeight);
    }

    return(TRUE);
}


#ifndef FE_SB  //moved to ifiobjr.hxx
/*********************************Class************************************\
* class IFIOBJR: public IFIOBJ
*
* History:
*  Tue 22-Dec-1992 14:05:24 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

class IFIOBJR : public IFIOBJ
{
public:

    FONTDIFF fd;

    LONG lMaxCharWidth;
    LONG lAveCharWidth;
    LONG lInternalLeading;
    LONG lExternalLeading;
    LONG lDigitizedAspectX;
    LONG lDigitizedAspectY;

    IFIOBJR(const IFIMETRICS *pifi_, RFONTOBJ& rfo_, DCOBJ& dco);

    BYTE tmItalic()
    {
        return((BYTE) ((FM_SEL_ITALIC & fd.fsSelection)?255:0));
    }

    LONG tmMaxCharWidth()
    {
        return(lMaxCharWidth);
    }

    LONG tmAveCharWidth()
    {
        return(lAveCharWidth);
    }

    LONG tmInternalLeading()
    {
        return(lInternalLeading);
    }

    LONG tmExternalLeading()
    {
        return(lExternalLeading);
    }
    LONG tmWeight()
    {
        return((LONG) (fd.usWinWeight));
    }

    FSHORT fsSimSelection()
    {
        return(fd.fsSelection);
    }
    LONG tmDigitizedAspectX()
    {
        return lDigitizedAspectX;
    }
    LONG tmDigitizedAspectY()
    {
        return lDigitizedAspectY;
    }

};


/******************************Member*Function*****************************\
* IFIOBJR::IFIOBJR                                                         *
*                                                                          *
* This is where I place all of the knowlege of how to get the metrics      *
* for simulated for simulated fonts.                                       *
*                                                                          *
* History:                                                                 *
*  Wed 24-Mar-1993 23:32:23 -by- Charles Whitmer [chuckwh]                 *
* Made it respect the proper conventions when copying the FONTDIFF.  A     *
* bold simulation on an italic font is a BoldItalic simulation, etc.       *
*                                                                          *
*  Tue 22-Dec-1992 14:18:11 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

IFIOBJR::IFIOBJR(const IFIMETRICS *pifi_, RFONTOBJ& rfo_, DCOBJ& dco) : IFIOBJ(pifi_)
{
    FONTSIM *pfs = (FONTSIM*) (((BYTE*) pifi) + pifi->dpFontSim);

    switch (rfo_.pfo()->flFontType & (FO_SIM_BOLD+FO_SIM_ITALIC))
    {
    case 0:

        fd.bWeight         = pifi->panose.bWeight  ;
        fd.usWinWeight     = pifi->usWinWeight     ;
        fd.fsSelection     = pifi->fsSelection     ;
        fd.fwdAveCharWidth = pifi->fwdAveCharWidth ;
        fd.fwdMaxCharInc   = pifi->fwdMaxCharInc   ;
        fd.ptlCaret        = pifi->ptlCaret        ;
        break;

    case FO_SIM_BOLD:

    // If base (physical) font is already italic, emboldening yields
    // a bold-italic simulation.

        if (pifi->fsSelection & FM_SEL_ITALIC)
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic));
        else
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBold));
        break;

    case FO_SIM_ITALIC:

    // If base (physical) font is already bold, italicization yields
    // a bold-italic simulation.

        if (pifi->fsSelection & FM_SEL_BOLD)
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic));
        else
            fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpItalic));
        break;

    case FO_SIM_BOLD+FO_SIM_ITALIC:

        fd = *((FONTDIFF*) (((BYTE*) pfs) + pfs->dpBoldItalic));
        break;
    }

    lAveCharWidth     = (LONG) fd.fwdAveCharWidth;
    lMaxCharWidth     = (LONG) fd.fwdMaxCharInc;
    lExternalLeading  = (LONG) fwdExternalLeading();
    lInternalLeading  = (LONG) fwdInternalLeading();

    if (!bContinuousScaling())
    {
        {
            const LONG lx = rfo_.pptlSim()->x;
            if (lx > 1)
            {
                lAveCharWidth *= lx;
                lMaxCharWidth *= lx;
            }
        }


        {
            const LONG ly = rfo_.pptlSim()->y;
            if (ly > 1)
            {
                lExternalLeading *= ly;
                lInternalLeading *= ly;
            }
        }
    }

// [Windows 3.1 compatibility]
// If TrueType font, then we need to substitute the device resolution for
// the aspect ratio.

    if (bTrueType())
    {
        PDEVOBJ pdo(dco.hdev());
        ASSERTGDI(pdo.bValid(), "ctIFIOBJR(): bad HDEV in DC\n");

    // [Windows 3.1 compatibility]
    // Win 3.1 has these swapped.  It puts VertRes in tmDigitizedAspectX
    // and HorzRes in tmDigitizedAspectY.

        lDigitizedAspectX = (LONG) pdo.ulLogPixelsY();
        lDigitizedAspectY = (LONG) pdo.ulLogPixelsX();
    }
    else
    {
    // [Windows 3.1 compatibility]
    // Win 3.1 has these swapped.  It puts VertRes in tmDigitizedAspectX
    // and HorzRes in tmDigitizedAspectY.

        lDigitizedAspectX = pptlAspect()->y * rfo_.pptlSim()->y;
        lDigitizedAspectY = pptlAspect()->x * rfo_.pptlSim()->x;
    }

}

#endif

/******************************Public*Routine******************************\
* BOOL bIFIMetricsToTextMetricW (
*         RFONTOBJ &rfo,
*         DCOBJ &dco,
*        PTEXTMETRICW ptmw,
*         PIFIMETRICS pifi
*     )
*
* Fill a TEXTMETRIC structure based on information from an IFIMETRICS
* structure.
*
* Everything returned in World (or Logical) coordinates.  To that end,
* the following fields must be transformed by either the Notional to
* World transform (for scalable fonts) or the Device to World transform
* (for bitmap fonts):
*
*       tmHeight            (from pifi->fwdMaxBaselineExt)
*       tmMaxCharWidth      (from pifi->fwdMaxCharInc)
*       tmAveCharWidth      (from pifi->fwdAveCharWidth)
*       tmAscent            (from pifi->fwdMaxAscender)
*       tmInternalLeading   (from pifi->fwdInternalLeading)
*       tmExternalLeading   (from pifi->fwdExternalLeading)
*
* Return:
*   TRUE if successful, FALSE if an error occurs.
*
*   totaly stolen from GilmanW
*
* History:
*  9-Oct-1991 by Gilman Wong [gilmanw]
* Added scalable font support.
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bIFIMetricsToTextMetricWStrict(  // strict means unicode values only [bodind]
    RFONTOBJ    &rfo  ,
    DCOBJ       &dco  ,
    TEXTMETRICW *ptmw,
    IFIMETRICS  *pifi
    )
{

    IFIOBJR ifio(pifi,rfo,dco);

//
// At low pixels per Em, the Height and ascender do not scaler linearly
// so we take the results directly from the realization
//
    if (dco.pdc->bWorldToDeviceIdentity())
    {
        ptmw->tmHeight = LONG_FLOOR_OF_FIX(rfo.fxMaxExtent() + FIX_HALF);
        ptmw->tmAscent = LONG_FLOOR_OF_FIX(rfo.fxMaxAscent() + FIX_HALF);
        ptmw->tmOverhang = rfo.lOverhang();

    }
    else
    {
        ptmw->tmHeight = lCvt(rfo.efDtoWAscent_31(),(LONG)rfo.fxMaxExtent());
        ptmw->tmAscent = lCvt(rfo.efDtoWAscent_31(),(LONG)rfo.fxMaxAscent());
        ptmw->tmOverhang = lCvt(rfo.efDtoWBase_31(), rfo.lOverhang() << 4);
    }

    if (!ifio.bContinuousScaling())
    {
        if (dco.pdc->bWorldToDeviceIdentity())
        {
            ptmw->tmMaxCharWidth    = ifio.tmMaxCharWidth();
            ptmw->tmAveCharWidth    = ifio.tmAveCharWidth();
            ptmw->tmInternalLeading = ifio.tmInternalLeading();
            ptmw->tmExternalLeading = ifio.tmExternalLeading();
        }
        else
        {
            ptmw->tmMaxCharWidth
              = lCvt(rfo.efDtoWBase_31(),((LONG) ifio.tmMaxCharWidth()) << 4);
            ptmw->tmAveCharWidth
              = lCvt(rfo.efDtoWBase_31(),((LONG) ifio.tmAveCharWidth()) << 4);
            ptmw->tmInternalLeading
              = lCvt(rfo.efDtoWAscent_31(),((LONG) ifio.tmInternalLeading()) << 4);
            ptmw->tmExternalLeading
              = lCvt(rfo.efDtoWAscent_31(),((LONG) ifio.tmExternalLeading()) << 4);
        }
    }
    else
    {
        if (rfo.lNonLinearIntLeading() == MINLONG)
        {
        // Rather than scaling the notional internal leading, try
        // to get closer to HINTED internal leading by computing it
        // as the difference between the HINTED height and UNHINTED
        // EmHeight.

            ptmw->tmInternalLeading =
                ptmw->tmHeight
                - lCvt(rfo.efNtoWScaleAscender(),ifio.fwdUnitsPerEm());
        }
        else
        {
        // But if the font provider has given us a hinted internal leading,
        // just use it.

            ptmw->tmInternalLeading =
                lCvt(rfo.efDtoWAscent_31(),rfo.lNonLinearIntLeading());
        }

    // Either scale the external leading linearly from N to W, or back
    // transform the device units version returned from the font provider.

        if (rfo.lNonLinearExtLeading() == MINLONG)
        {
            ptmw->tmExternalLeading =
                lCvt(rfo.efNtoWScaleAscender(),ifio.fwdExternalLeading());
        }
        else
        {
            ptmw->tmExternalLeading =
                lCvt(rfo.efDtoWAscent_31(),rfo.lNonLinearExtLeading());
        }

        if (rfo.lNonLinearMaxCharWidth() == MINLONG)
        {
            ptmw->tmMaxCharWidth =
                lCvt(rfo.efNtoWScaleBaseline(), ifio.tmMaxCharWidth());
        }
        else
        {
        // But if the font provider has given us a hinted value, we use it

            ptmw->tmMaxCharWidth =
                lCvt(rfo.efDtoWBase_31(),rfo.lNonLinearMaxCharWidth());
        }

        if (rfo.lNonLinearAvgCharWidth() == MINLONG)
        {
            ptmw->tmAveCharWidth =
                lCvt(rfo.efNtoWScaleBaseline(), ifio.tmAveCharWidth());
        }
        else
        {
        // But if the font provider has given us a hinted value, we use it

            ptmw->tmAveCharWidth =
                lCvt(rfo.efDtoWBase_31(),rfo.lNonLinearAvgCharWidth());
        }
    }

//
// height = ascender + descender, by definition
//
    ptmw->tmDescent = ptmw->tmHeight - ptmw->tmAscent;

//
// The rest of these are not transform dependent.
//
    ptmw->tmWeight     = ifio.tmWeight();
    ptmw->tmItalic     = ifio.tmItalic();
    ptmw->tmUnderlined = ifio.lfUnderline();
    ptmw->tmStruckOut  = ifio.lfStrikeOut();

// Better check the simulation flags for underline and strikeout.

    {
        FLONG flSim = dco.pdc->flSimulationFlags();

    // If simulated, set underline and strike out flags.

        ptmw->tmUnderlined = (flSim & TSIM_UNDERLINE1) ? 0xff : FALSE;
        ptmw->tmStruckOut  = (flSim & TSIM_STRIKEOUT)  ? 0xff : FALSE;
    }

    ptmw->tmFirstChar        =  ifio.wcFirstChar()  ;
    ptmw->tmLastChar         =  ifio.wcLastChar()   ;
    ptmw->tmDefaultChar      =  ifio.wcDefaultChar();
    ptmw->tmBreakChar        =  ifio.wcBreakChar()  ;

// New in win95: depending on charset in the logfont and charsets
// available in the font we return the tmCharset that the mapper has decided
// is the best. At this stage the claim is that mapping has already
// occured and that the charset stored in the dc must not be dirty.

    //ASSERTGDI(!(dco.ulDirty() & DIRTY_CHARSET),
    //          "bIFIMetricsToTextMetricW, charset is dirty\n");
    ptmw->tmCharSet = (BYTE)(dco.pdc->iCS_CP() >> 16);

// [Windows 3.1 compatibility]
// TMPF_DEVICE really means whether the device realized this font or
// GDI realized it.  Under Win 3.1 printer drivers can realize True Type
// fonts.  When the TC_RA_ABLE flag isn't set the driver's realization will
// be chosen and TMPF_DEVICE flag should be set.

// Word97-J has problem to print vertically,
// So we need to get rid of TMPF_DEVICE to make print correctly

    if (ifio.bTrueType())
    {
        PDEVOBJ pdo(dco.hdev());

        ASSERTGDI(pdo.bValid(), "PDEVOBJ constructor failed\n");

        BOOL bWin31Device = (!pdo.bDisplayPDEV() &&
                            !(pdo.flTextCaps() & TC_RA_ABLE ) &&
                            (dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
                            !(gbDBCSCodePage && (GetAppCompatFlags(NULL) & GACF_TTIGNOREDDEVICE)));

    // Note that we check the PDEV directly rather than the DC because
    // DCOBJ::bDisplay() is not TRUE for display ICs (just display DCs
    // which are DCTYPE_DIRECT).

       ptmw->tmPitchAndFamily = ifio.tmPitchAndFamily()
                             | ( (bWin31Device) ? TMPF_DEVICE : 0);
    }
    else
    {
        ptmw->tmPitchAndFamily = ifio.tmPitchAndFamily()
                                 | (rfo.bDeviceFont() ? TMPF_DEVICE : 0)
                                 | (((pifi->flInfo & FM_INFO_TECH_OUTLINE_NOT_TRUETYPE) && !(gbDBCSCodePage && (GetAppCompatFlags(NULL) & GACF_TTIGNOREDDEVICE))) ? (TMPF_VECTOR|TMPF_DEVICE): 0);
    }

    ptmw->tmDigitizedAspectX = ifio.tmDigitizedAspectX();
    ptmw->tmDigitizedAspectY = ifio.tmDigitizedAspectY();

    return(TRUE);
}

/******************************Public*Routine******************************\
* bGetTextMetrics
*
*
* History:
*  5-5-2000 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

BOOL bGetTextMetrics(
    RFONTOBJ    &rfo  ,
    DCOBJ       &dco  ,
    TMW_INTERNAL *ptmi
)
{
    BOOL    bRet = FALSE;
    
    // Get cached TextMetrics if available.

    if (rfo.bValid())
    {
        if( rfo.ptmw() != NULL )
        {
            *ptmi = *(rfo.ptmw());

        // time to fix underscore, strikeout and charset. The point is that
        // bFindRFONT may have found an old realization that corresponded
        // to different values of these parameters in the logfont.

            FLONG flSim = dco.pdc->flSimulationFlags();

            ptmi->tmw.tmUnderlined = (flSim & TSIM_UNDERLINE1) ? 0xff : FALSE;
            ptmi->tmw.tmStruckOut  = (flSim & TSIM_STRIKEOUT)  ? 0xff : FALSE;

        // New in win95: depending on charset in the logfont and charsets
        // available in the font we return the tmCharset
        // that the mapper has decided is the best.
        // At this stage the claim is that mapping has already
        // occured and that the charset stored in the dc must not be dirty.

             ptmi->tmw.tmCharSet = (BYTE)(dco.pdc->iCS_CP() >> 16);
             bRet = TRUE;
        }
        else
        {
        // Get PFE user object from RFONT

             PFEOBJ      pfeo (rfo.ppfe());

             ASSERTGDI(pfeo.bValid(), "ERROR invalid ppfe in valid rfo");
             bRet = (BOOL) bIFIMetricsToTextMetricW(rfo, dco, ptmi, pfeo.pifi());
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* bIFIMetricsToTextMetricW(
*
* tacks on ansi values
*
* History:
*  27-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bIFIMetricsToTextMetricW(
    RFONTOBJ    &rfo  ,
    DCOBJ       &dco  ,
    TMW_INTERNAL *ptmi,
    IFIMETRICS  *pifi
    )
{

    ASSERTGDI(rfo.ptmw() == NULL, "bIFIFMetricToTextMetricsW TEXTMETRIC already cached\n");

    BOOL bRet = bIFIMetricsToTextMetricWStrict(rfo,dco,&ptmi->tmw,pifi);

    ptmi->tmdTmw.chFirst    = pifi->chFirstChar  ;
    ptmi->tmdTmw.chLast     = pifi->chLastChar   ;
    ptmi->tmdTmw.chDefault  = pifi->chDefaultChar;
    ptmi->tmdTmw.chBreak    = pifi->chBreakChar  ;

    if( bRet )
    {
        TMW_INTERNAL *ptmw = (TMW_INTERNAL*) PALLOCMEM(sizeof(TMW_INTERNAL),'wmtG');

        if( ptmw == NULL )
        {
            WARNING("bIFIMetricsToTextMetricW unable to alloc mem for cached TEXTMETRICS\n");
        }
        else
        {
            rfo.ptmwSet( ptmw );
            *ptmw = *ptmi;
        }
    }

    return (bRet);
}



/******************************Public*Routine******************************\
* bIFIMetricsToTextMetricW2
*
* Used during font enumeration.
*
* Fill a NEWTEXTMETRICW structure based on information from an IFIMETRICS
* structure.
*
* The following fields need to be transformed by the Device to World
* transform:
*
*       tmHeight            (from pifi->fwdMaxBaselineExt)
*       tmMaxCharWidth      (from pifi->fwdMaxCharInc)
*       tmAveCharWidth      (from pifi->fwdAveCharWidth)
*       tmAscent            (from pifi->fwdMaxAscender)
*       tmInternalLeading   (from pifi->fwdInternalLeading)
*       tmExternalLeading   (from pifi->fwdExternalLeading)
*
* In the case of scalable fonts, these quantities are first prescaled into
* device units to be the equivalent of a 24 point font.  This is for Win 3.1
* compatibility with EnumFonts.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
*   totaly stolen from GilmanW
*
* History:
*  9-Oct-1991 by Gilman Wong [gilmanw]
* Added scalable font support.
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bIFIMetricsToTextMetricW2 (
    DCOBJ           &dco,
    NTMW_INTERNAL * pntmi,
    PFEOBJ         &pfeo,
    BOOL            bDeviceFont,
    ULONG           iEnumType,
    EFLOATEXT       efScale,
    LONG            tmDigitizedAspectX,
    LONG            tmDigitizedAspectY
    )
{
    PIFIMETRICS     pifi = pfeo.pifi();
    PNEWTEXTMETRICW ptmw = &pntmi->entmw.etmNewTextMetricEx.ntmTm;
    IFIOBJ ifio(pifi);

    // Validate the font before proceeding
    if( !bValidFont(pifi) )
    {
	WARNING("bIFIMetricsToTextMetricW2 called with bad IFIMETRICS\n");
	return FALSE;
    }

// If scalable font, then return following metrics as if font were realized at
// 24 points.

    if (ifio.bContinuousScaling())
    {
        ptmw->tmHeight = lCvt(efScale, ifio.lfHeight());

    // Now we need to adjust the scale factor due to roundoff in the height.
    // This will more closely approximate the NtoW scale computed if ever this
    // font gets selected.

        efScale  = (LONG) ptmw->tmHeight;
        efScale /= (LONG) ifio.lfHeight();

    // Use scaling factor to convert from IFIMETRICS to TEXTMETRIC fields.

        ptmw->tmAscent          = lCvt(efScale, (LONG) ifio.fwdWinAscender());
        ptmw->tmInternalLeading = lCvt(efScale, (LONG) ifio.fwdInternalLeading());
        ptmw->tmExternalLeading = lCvt(efScale, (LONG) ifio.fwdExternalLeading());

        ptmw->tmAveCharWidth    = lCvt(efScale, (LONG) ifio.fwdAveCharWidth());
        ptmw->tmMaxCharWidth    = lCvt(efScale, (LONG) ifio.fwdMaxCharInc());

    } /* if */

// Its a bitmap font, so no prescaling to 24 point needed.

    else
    {
        ptmw->tmHeight           = ifio.lfHeight();
        ptmw->tmAscent           = ifio.fwdWinAscender();
        ptmw->tmInternalLeading  = ifio.fwdInternalLeading();
        ptmw->tmExternalLeading  = ifio.fwdExternalLeading();
        ptmw->tmAveCharWidth     = ifio.fwdAveCharWidth();
        ptmw->tmMaxCharWidth     = ifio.fwdMaxCharInc();

    } /* else */

// Now that all fonts are:
//
//      Bitmap fonts -- in device units
//      Scalable fonts -- artificially scaled to 24 point device
//                        units (a 'la Win 3.1)
//
// put them through the Device to World transform.

    EXFORMOBJ   xoToWorld(dco, DEVICE_TO_WORLD);
    if (!xoToWorld.bValid())
    {
        WARNING("gdisrv!bIFIMetricsToTextMetricW2(): EXFORMOBJ constructor failed\n");
        return (FALSE);
    }

// Only if not identity transform do we need to do anything more.

    if (!xoToWorld.bTranslationsOnly())
    {
        EFLOATEXT efX, efY;

    // efX == horizontal scaling factor (Device to World)

        EVECTORFL evflH(1,0);          // device space unit vector (x-axis)

        if (!xoToWorld.bXform(evflH))
        {
            WARNING("gdisrv!bIFIMetricsToTextMetricW2(): transform failed\n");
            return (FALSE);
        }
        efX.eqLength(evflH);

    // efY == vertical scaling factor (Device to World)

        EVECTORFL evflV(0,1);          // device space unit vector (y-axis)

        if (!xoToWorld.bXform(evflV))
        {
            WARNING("gdisrv!bIFIMetricsToTextMetricW2(): transform failed\n");
            return (FALSE);
        }
        efY.eqLength(evflV);

    // Convert from device to world using scaling factors.

        ptmw->tmHeight = lCvt(efY, (LONG) ptmw->tmHeight);
        ptmw->tmAscent = lCvt(efY, (LONG) ptmw->tmAscent);


        ptmw->tmAveCharWidth = lCvt(efX, (LONG) ptmw->tmAveCharWidth);
        ptmw->tmMaxCharWidth = lCvt(efX, (LONG) ptmw->tmMaxCharWidth);


        ptmw->tmInternalLeading = lCvt(efY, (LONG) ptmw->tmInternalLeading);
        ptmw->tmExternalLeading = lCvt(efY, (LONG) ptmw->tmExternalLeading);

    } /* if */

// these are now passed in, computed in the calling routine

    ptmw->tmDigitizedAspectX = tmDigitizedAspectX;
    ptmw->tmDigitizedAspectY = tmDigitizedAspectY;

// The rest are pretty easy (no transformation of IFIMETRICS needed)

    ptmw->tmDescent          = ptmw->tmHeight - ptmw->tmAscent;
    ptmw->tmWeight           = ifio.lfWeight();
    ptmw->tmItalic           = ifio.lfItalic();
    ptmw->tmUnderlined       = ifio.lfUnderline();
    ptmw->tmStruckOut        = ifio.lfStrikeOut();

    ptmw->tmFirstChar        = ifio.wcFirstChar();
    ptmw->tmLastChar         = ifio.wcLastChar();
    ptmw->tmDefaultChar      = ifio.wcDefaultChar();
    ptmw->tmBreakChar        = ifio.wcBreakChar();

    ptmw->tmCharSet        = ifio.lfCharSet();

// [Windows 3.1 compatibility]
//
// Note that the tmPitchAndFamily is computed slightly differently than
// in bIFIMetricsToTextMetricWStrict.  That's because the enumeration
// does not hack the tmPitchAndFamily to make TrueType fonts look like
// device fonts.  Enumeration does this in the flFontType flags passed
// back to the callback function.  On the other hand, GetTextMetrics, which
// bIFIMetricsToTextMetricWStrict services, does the hack in tmPitchAndFamily.

    ptmw->tmPitchAndFamily = ifio.tmPitchAndFamily()
                             | ((bDeviceFont) ? TMPF_DEVICE : 0)
                             | ((pifi->flInfo & FM_INFO_TECH_OUTLINE_NOT_TRUETYPE) ? (TMPF_VECTOR|TMPF_DEVICE): 0);

// The simulated faces are not enumerated, so this is 0.

    ptmw->tmOverhang       = 0;

// If TrueType, then fill in the new NEWTEXTMETRICW fields.
// Comment wrong: we shall do it for every font

    ptmw->ntmFlags = 0;

    if (!ifio.bBold() && !ifio.bItalic())
        ptmw->ntmFlags |= NTM_REGULAR;
    else
    {
        if (ifio.bItalic())
            ptmw->ntmFlags |= NTM_ITALIC;
        if (ifio.bBold())
            ptmw->ntmFlags |= NTM_BOLD;
    }

    if (pifi->flInfo & FM_INFO_NONNEGATIVE_AC)
        ptmw->ntmFlags |= NTM_NONNEGATIVE_AC;

    if (pifi->flInfo & FM_INFO_TECH_TYPE1)
    {
        if (pifi->flInfo & FM_INFO_TECH_MM)
            ptmw->ntmFlags |= NTM_MULTIPLEMASTER;

        if (pifi->flInfo & FM_INFO_TECH_CFF)
            ptmw->ntmFlags |= NTM_PS_OPENTYPE; // proper, not true type
        else
            ptmw->ntmFlags |= NTM_TYPE1;  // old fashioned t1 screen font
    }

    if (pifi->flInfo & FM_INFO_DSIG)
    {
        ptmw->ntmFlags |= NTM_DSIG;
        if (pifi->flInfo & FM_INFO_TECH_TRUETYPE)
            ptmw->ntmFlags |= NTM_TT_OPENTYPE;
    }

    ptmw->ntmSizeEM     = ifio.fwdUnitsPerEm();
    ptmw->ntmCellHeight = (UINT) ifio.lfHeight();;
    ptmw->ntmAvgWidth   = ifio.fwdAveCharWidth();

    pntmi->tmdNtmw.chFirst    = pifi->chFirstChar  ;
    pntmi->tmdNtmw.chLast     = pifi->chLastChar   ;
    pntmi->tmdNtmw.chDefault  = pifi->chDefaultChar;
    pntmi->tmdNtmw.chBreak    = pifi->chBreakChar  ;

    PTRDIFF dpFontSig = 0;

    if (pfeo.pifi()->cjIfiExtra > offsetof(IFIEXTRA, dpFontSig))
    {
        dpFontSig = ((IFIEXTRA *)(pfeo.pifi() + 1))->dpFontSig;
    }

    if (dpFontSig)
    {
    // this is only going to work in the next release of win95 (win96?)
    // according to DavidMS, and we have right now in SUR

        pntmi->entmw.etmNewTextMetricEx.ntmFontSig = *((FONTSIGNATURE *)
                                  ((BYTE *)pifi + dpFontSig));
    }
    else // do not bother and waste time, will not be used anyway
    {
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[0] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[1] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[2] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsUsb[3] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsCsb[0] = 0;
        pntmi->entmw.etmNewTextMetricEx.ntmFontSig.fsCsb[1] = 0;
    }

    return (TRUE);
}


INT
LOADSTRING(
    HANDLE  hinst,
    UINT    id,
    PWSTR   pwstr,
    INT     bufsize
    )

/*++

Routine Description:

    Loads a string resource from the resource file associated with a
    specified module, copies the string into a buffer, and appends a
    terminating null character.

Arguments:

    hinst   handle to the module containing the string resource
    id      ID of the string to be loaded
    pwstr   points to the buffer to receive the string
    bufsize size of the buffer, in characters.

Return Value:

    Return value is the number of characters copied into the buffer, not
    including the null-terminating character.  If pwst is NULL then it
    just returns the size of the string.


I stole this from the pscript driver [gerritv]


--*/

#define WINRT_STRING    6       // string resource type

{
    ULONG   size;

    // String Tables are broken up into 16 string segments.
    // Find the segment containing the string we are interested in.

    const WCHAR * pwstrBuffer = (PWSTR) EngFindResource(hinst, (id>>4)+1, WINRT_STRING, &size);

    if (pwstrBuffer == NULL ) {

        WARNING("Gre:LOADSTRING failed.\n");
        bufsize = 0;
    } else {

        const WCHAR * pwstrEnd = pwstrBuffer + size / sizeof(WCHAR);
        INT     length = 0;

        // Move past the other strings in this segment.

        id &= 0x0F;

        while (pwstrBuffer < pwstrEnd) {

            // PASCAL style string - first char is length

            length = *pwstrBuffer++;

            if(id-- == 0 ) {
                break;
            }

            pwstrBuffer += length;
        }

        if(!pwstr)
        {
            return(length);
        }

        if (pwstrBuffer < pwstrEnd) {

            // Truncate the string if it's longer than max buffer size

            if (--bufsize > length)
                bufsize = length;
            memcpy(pwstr, pwstrBuffer, bufsize*sizeof(WCHAR));
        } else {

            WARNING("Gre:LOADSTRING Bad string resource.\n");
            bufsize = 0;
        }

    }

    if (pwstr)
    {
        pwstr[bufsize] = L'\0';
    }

    return bufsize;
}

#ifdef _HYDRA_
    DWORD gdwOffset;
#endif

typedef struct _CHSET_SCRIPT
{
    ULONG ulCharSet;
    WCHAR *pwszScript;
} CHSET_SCRIPT;


CHSET_SCRIPT aScripts[NUMBER_OF_SCRIPTS];


/********************************************************************************
 * BOOL InitializeScripts()
 *
 * Initialize script names from resource strings in win32k.sys
 *
 * This function intializes the script names from the string resources compiled
 * into win32k.sys.  The string should be in the following format: xxx:string
 * where xxx is an ascii decimal respresentation of a charset value and string
 * the script that is associated with that charset.
 *
 * History
 *  3-5-95 16:00:54 by Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ********************************************************************************/

extern "C" BOOL InitializeScripts()
{
    HANDLE h;
    BOOL ReturnValue = FALSE;

    if(h = EngLoadModule(L"win32k.sys"))
    {
        UINT u;
        DWORD TotalSizeInWChars = 0;
        PWCHAR pStringBuffer = NULL;

    // first compute the total size of all the strings

        for(u = 0; u < NUMBER_OF_SCRIPTS; u++)
        {
            INT StringSize;

            StringSize = LOADSTRING(h, u, NULL, 0);

            if(!StringSize)
            {
                WARNING("InitializeScripts unable to LOADSTRING\n");
                break;
            }

            TotalSizeInWChars += StringSize + 1;
        }

    // allocate buffer if computation above is successful

        if(u == NUMBER_OF_SCRIPTS)
        {
            pStringBuffer =
              (PWCHAR) PALLOCMEM(TotalSizeInWChars * sizeof(WCHAR),'lscG');
        }

        aScripts[0].pwszScript = NULL;  // don't leave this unitialized

    // if buffer allocated, read each string into buffer

        if(pStringBuffer)
        {
        // next read in each string

            for(u = 0; u < NUMBER_OF_SCRIPTS; u++)
            {
                INT StringSize;

                aScripts[u].pwszScript = pStringBuffer;

                StringSize = LOADSTRING(h, u, pStringBuffer, TotalSizeInWChars) + 1;
                pStringBuffer += StringSize;
                TotalSizeInWChars -= StringSize;

                aScripts[u].ulCharSet = 0;

            // Once we've read in the string, parse the charset component.
            // The string will be in the form "xxx:script", where xxx
            // is the ascii decimal representation of the string

                while(*(aScripts[u].pwszScript) &&
                      *(aScripts[u].pwszScript) != (WCHAR) ':')
                {
                    aScripts[u].ulCharSet *= 10;
                    aScripts[u].ulCharSet +=
                      *(aScripts[u].pwszScript) - (WCHAR) '0';
                    aScripts[u].pwszScript += 1;
#ifdef _HYDRA_
                    if (u == 0)
                        gdwOffset++;
#endif
                }

            // add 1000 to the charset value to be compatible with other code

                aScripts[u].ulCharSet += 1000;

                ASSERTGDI(*aScripts[u].pwszScript == (WCHAR) ':',
                          "InitializeScript missing colon\n");

           // move past the colon

                aScripts[u].pwszScript += 1;
#ifdef _HYDRA_
                if (u == 0)
                    gdwOffset++;
#endif

            }

            ASSERTGDI((TotalSizeInWChars == 0), "InitializeScripts: TotalSize != 0\n");

            ReturnValue = TRUE;
        }

        EngFreeModule(h);

    }
    return(ReturnValue);
}

#ifdef _HYDRA_
/******************************Public*Routine******************************\
* MultiUserGreDeleteScripts
*
* For MultiUserGreCleanup (Hydra) cleanup.
*
* History:
*  09-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID MultiUserGreDeleteScripts()
{
    WCHAR* pszBuffer;

    if (aScripts[0].pwszScript) {

        pszBuffer = aScripts[0].pwszScript;

        pszBuffer -= gdwOffset;

        VFREEMEM(pszBuffer);
    }
}
#endif

/******************************Public*Routine******************************\
* vLookupScript
*
* Copy the script name corresponding to the specified character set.
* Copy the SCRIPT_UNKNOWN string if character set not found in the table.
*
\**************************************************************************/

VOID vLookupScript(ULONG lfCharSet, WCHAR *pwszScript)
{
//MAYBE replace linear search by binary search

    UINT i;
    ULONG ulStrlen;
    lfCharSet += 1000;
    for (i = 0; i < NUMBER_OF_SCRIPTS; i++)
        if (aScripts[i].ulCharSet == lfCharSet)
            break;

    wcscpy(pwszScript, (i<NUMBER_OF_SCRIPTS) ? aScripts[i].pwszScript :
           aScripts[SCRIPT_UNKNOWN].pwszScript);
}


/******************************Public*Routine******************************\
* SIZE_T cjCopyFontDataW
*
* Copies data needed for EnumFonts callback function from the IFIMETRICS
* data of the given font.
*
* Because the font is not realized (notice: no RFONTOBJ& passed in), all
* units remain in NOTIONAL.
*
* Two parameters may influence the family name passed back.  If
* efsty is EFSTYLE_OTHER, then the face name should be substituted for
* the family name.  If pwszFamilyOverride is !NULL, then it should
* replace the family name.  pwszFamilyOverride has precedence over efsty.
* Both of these behaviors are for Win3.1 compatibility.
*
* Note: pefdw is user memory, which might be asynchronously changed
*   at any time.  So, we cannot trust any values read from that buffer.
*
* Returns:
*   The number of bytes copied, 0 if error occurs.
*
* History:
*  9-Oct-1991 by Gilman Wong [gilmanw]
* Added scalable font support.
*  03-Sep-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

SIZE_T cjCopyFontDataW (
    DCOBJ          &dco,
    PENUMFONTDATAW pefdw,
    PFEOBJ         &pfeo,
    ULONG          efsty,              // based on style, may need to change family name to facename
    PWSZ           pwszFamilyOverride, // if this is !NULL, this is used as family name
    ULONG          lfCharSetOverride,
    BOOL           bCharSetOverride,   // tell us if overrides should be used
    ULONG          iEnumType           // enumeration type, tells how to fill the data
    )
{
    PIFIMETRICS    pifi    = pfeo.pifi();
    BOOL           bDevice = pfeo.bDeviceFont();
    EFLOATEXT      efScale;
    ULONG          cjEfdw;
    ULONG          dpNtmi;

    IFIOBJ ifio(pifi);

    LONG tmDigitizedAspectX = ifio.pptlAspect()->y;
    LONG tmDigitizedAspectY = ifio.pptlAspect()->x;

    PDEVOBJ pdo(dco.hdev());

    if (!pdo.bValid())
    {
        WARNING("gdisrv!cjCopyFontDataW(): PDEVOBJ constructor failed\n");
        return ((SIZE_T)0);
    }
    if (!bValidFont(pifi))
    {
	WARNING("cjCopyFontDataW() called with invalid ITIMETRICS\n");
	return ((SIZE_T)0);
    }

    if (bDevice && !ifio.bContinuousScaling())
    {
        tmDigitizedAspectX = pdo.ulLogPixelsX();
        tmDigitizedAspectY = pdo.ulLogPixelsY();
    }

// Calculate the scale factor

    if (ifio.bContinuousScaling())
    {
    // According to the bizzare convention of Win 3.1, scalable fonts are
    // reported at a default physical height
    // notice the inversion in x,y for win31 compat.

        if (ifio.lfOutPrecision() == OUT_OUTLINE_PRECIS)
        {
            tmDigitizedAspectX = pdo.ulLogPixelsY();
            tmDigitizedAspectY = pdo.ulLogPixelsX();
        }

        if (bDevice)
        {
        // on win95 pcl does not scale at all, ie we could use
        // efScale = (LONG)1; for pcl and we would win95 compat.
        // but,since this does not seem to be reasonable, we shall
        // use the same strategy for ps and pcl unless we find an app
        // which is broken because of this incompatibility. [bodind]

            HLFONT     hlfntDef;
            hlfntDef = pdo.hlfntDefault();

            if (!hlfntDef)
            {
                WARNING("gdisrv!cjCopyFontDataW(): PDEVOBJ.hlfntDefault failed\n");
                return ((SIZE_T)0);
            }

            LFONTOBJ lfo(hlfntDef);
            if (!lfo.bValid())
            {
                WARNING("gdisrv!cjCopyFontDataW(): LFONTOBJ constructor failed\n");
                return ((SIZE_T)0);
            }

            if (lfo.plfw()->lfHeight < 0)
            {
            // already in pixels

                efScale = (-lfo.plfw()->lfHeight);
                efScale /= ifio.fwdUnitsPerEm();
            }
            else
            {
                efScale = (LONG)lfo.plfw()->lfHeight;
                efScale /= (LONG) ifio.lfHeight();
            }
        }
        else // screen fonts
        {
        // efScale = Em-Height (pixels) / Em-Height (font units)

            efScale  = (LONG) DEFAULT_SCALABLE_FONT_HEIGHT_IN_POINTS;
            efScale /= (LONG) POINTS_PER_INCH;
            efScale *= (LONG) pdo.ulLogPixelsY();
            efScale /= (LONG) ifio.fwdUnitsPerEm();
        }
    }

// Convert IFIMETRICS into EXTLOGFONTW.

    if (!bIFIMetricsToLogFontW2(dco, &pefdw->elfexw.elfEnumLogfontEx, pifi, (EFLOATEXT)efScale))
        return ((SIZE_T) 0);

// compute the offset to ntmi
// use kernel memory (cjEfdw and dpNtmi) to store these values

    pefdw->cjEfdw = cjEfdw = pfeo.cjEfdwPFE();
    pefdw->dpNtmi = dpNtmi = pfeo.dpNtmi();

// copy out mm info, if any

    NTMW_INTERNAL *pntmi = (NTMW_INTERNAL *)((BYTE *)pefdw + dpNtmi);

    ULONG         cAxes = 0;
    if (pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF       dpDesVec = 0;
        DESIGNVECTOR *pdvSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpDesignVector))
        {
            dpDesVec = ((IFIEXTRA *)(pifi + 1))->dpDesignVector;
            pdvSrc = (DESIGNVECTOR *)((BYTE *)pifi + dpDesVec);
            cAxes  = pdvSrc->dvNumAxes;

            if (cAxes > MM_MAX_NUMAXES)
                cAxes = MM_MAX_NUMAXES;
                
            RtlCopyMemory(&pefdw->elfexw.elfDesignVector, pdvSrc, (SIZE_T)SIZEOFDV(cAxes));
            pefdw->elfexw.elfDesignVector.dvNumAxes = cAxes;
        }
        else
        {
            ASSERTGDI(dpDesVec, "dpDesignVector == 0 for mm instance\n");
            pefdw->elfexw.elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
            pefdw->elfexw.elfDesignVector.dvNumAxes = 0;
        }
    }
    else
    {
        pefdw->elfexw.elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;
        pefdw->elfexw.elfDesignVector.dvNumAxes = 0;
    }



// base font:

    if (pifi->flInfo & FM_INFO_TECH_MM)
    {
        PTRDIFF    dpAXIW = 0;
        AXESLISTW *paxlSrc;

        if (pifi->cjIfiExtra > offsetof(IFIEXTRA, dpAxesInfoW))
        {
            dpAXIW = ((IFIEXTRA *)(pifi + 1))->dpAxesInfoW;
            paxlSrc = (AXESLISTW *)((BYTE*)pifi + dpAXIW);
            RtlCopyMemory(&pntmi->entmw.etmAxesList, paxlSrc, SIZEOFAXIW(cAxes));
        }
        else
        {
            ASSERTGDI(dpAXIW, "AxesInfoW needed for base MM font\n");
            pntmi->entmw.etmAxesList.axlReserved = STAMP_AXESLIST;
            pntmi->entmw.etmAxesList.axlNumAxes  = 0;
        }
    }
    else
    {
        pntmi->entmw.etmAxesList.axlReserved = STAMP_AXESLIST;
        pntmi->entmw.etmAxesList.axlNumAxes  = 0;
    }

// Convert IFIMETRICS into TEXTMETRICSW.

    if (!bIFIMetricsToTextMetricW2(dco,
                                   pntmi,
                                   pfeo,
                                   (BOOL) bDevice,
                                   iEnumType,
                                   (EFLOATEXT)efScale,
                                   tmDigitizedAspectX,
                                   tmDigitizedAspectY))
        return ((SIZE_T) 0);

// let us see if charset override should be used:

    if (bCharSetOverride)
    {
        pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfCharSet = (BYTE)lfCharSetOverride;
        pntmi->entmw.etmNewTextMetricEx.ntmTm.tmCharSet = (BYTE)lfCharSetOverride;
    }

// we used to do this only if (iEnumType == TYPE_ENUMFONTFAMILIESEX)
// but there is no reason to make this distinction, for EnumFonts and
// EnumFontFamilies, the apps will simply not rely on this information
// being there and correct.

    if(bCharSetOverride)
    {
        vLookupScript(lfCharSetOverride, (WCHAR *)pefdw->elfexw.elfEnumLogfontEx.elfScript);
    }
    else
    {
        pefdw->elfexw.elfEnumLogfontEx.elfScript[0] = L'\0'; // empty string
    }

// If pwszFamilyOverride is valid, then use it as the lfFaceName in LOGFONT.

    if ( pwszFamilyOverride != (PWSZ) NULL )
    {
        wcsncpy(
            pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName,
            pwszFamilyOverride,
            LF_FACESIZE
            );
        pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName[LF_FACESIZE-1] = 0;
    }
    else
    {
    // Otherwise, if efsty is EFSTYLE_OTHER, replace family name (lfFaceName)
    // with face name (elfFullName).

        if ( efsty == EFSTYLE_OTHER )
        {
            wcsncpy(
                pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName,
                pefdw->elfexw.elfEnumLogfontEx.elfFullName,
                LF_FACESIZE
                );
            pefdw->elfexw.elfEnumLogfontEx.elfLogFont.lfFaceName[LF_FACESIZE-1] = 0;
        }
    }

// Compute the FontType flags.

    pefdw->flType = 0;

    if (ifio.bTrueType())
    {
    //
    // [Windows 3.1 compatibility]
    // Win 3.1 hacks TrueType to look like device fonts on printers if the
    // text caps for the DC are not TC_RA_ABLE
    //
    // Note that we check the PDEV directly rather than the DC because
    // DCOBJ::bDisplay() is not TRUE for display ICs (just display DCs
    // which are DCTYPE_DIRECT).
    //

        BOOL bWin31Device = (!pdo.bDisplayPDEV() &&
                            !(pdo.flTextCaps() & TC_RA_ABLE ) &&
                            (dco.pdc->iGraphicsMode() == GM_COMPATIBLE));

        pefdw->flType |= (TRUETYPE_FONTTYPE | (bWin31Device ? DEVICE_FONTTYPE : 0));


    }
    else if (ifio.bBitmap())
    {
        pefdw->flType |= RASTER_FONTTYPE;
    }
    else if (pifi->flInfo & FM_INFO_TECH_TYPE1)
    {
    // See if this is an old fashioned pfm,pfb Type1 installation.
    // ATM for Win95 enumerates such fonts as device, and many apps that
    // expect ATM to be installed on the system also expect Type1 fonts to
    // be enumerated as DEVICE_FONTTYPE. These apps often do not show Type1
    // fonts in their menus unless we change flType to DEVICE_FONTTTYPE,
    // even though, strictly speaking, these are screen fonts.

    // for the same reason we set this bit for ps open type fonts

        pefdw->flType |= DEVICE_FONTTYPE;
    }

    if (bDevice)
    {
    // If scalable device font, then ONLY the DEVICE_FONTTYPE bit is set.

        if ( ifio.bContinuousScaling() )
            pefdw->flType = DEVICE_FONTTYPE;

    // Otherwise, the DEVICE_FONTTYPE bit is added to the others.

        else
            pefdw->flType |= DEVICE_FONTTYPE;

    // If scalable printer font AND printer does not set any of the
    // scalability flags in TEXTCAPS, then set the ENUMFONT_SCALE_HACK
    // flag.  Client-side code will enumerate the font back in several
    // different sizes (see Win95 code, drivers\printer\universa\unidrv\
    // enumobj.c, function UniEnumDFonts() for more details).
    //
    // Note that (according to ZhanW in PSD) on Win95, device fonts that
    // support integral scaling are not reported as such.  Instead, each
    // size is returned as if it were a non-scalable font.

        if ( (pdo.ulTechnology() == DT_RASPRINTER) &&
             !(pdo.flTextCaps() & TC_SA_CONTIN) &&
             ifio.bContinuousScaling() )
        {
            pefdw->flType |= ENUMFONT_SCALE_HACK;
        }
    }

    return cjEfdw;
}

/******************************Public*Routine******************************\
*
* SIZE_T cjOTMASize
*
* Similar to cjOTMW, except that 0 is returned if any of the
* bAnsiSize calls fail to compute the length of the hypothetic ansi string.
* pcjowmw is always returned valid
*
* This routine is very general and it should also work for DBCS case.
* Possible optmization:
*  verify that bAnsiSize checks for DBCS and if not DBCS, immediately
*  returns cjUni/2 [bodind]
*
* History:
*  20-Feb-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define bAnsiSize(a,b,c) (NT_SUCCESS(RtlUnicodeToMultiByteSize((a),(b),(c))))


UINT   cjOTMAWSize (
    PIFIMETRICS  pifi,        // compute size of OTM produced by this buffer
    UINT        *pcjotmw
    )
{
    IFIOBJ ifio(pifi);
    ULONG  cjUni, cjAnsi, cjotma;

    BOOL bTmp = TRUE;

// + 4 for terminating zeros

    cjotma   =  sizeof(OUTLINETEXTMETRICA) + 4;
    *pcjotmw = ALIGN4(sizeof(OUTLINETEXTMETRICW)) + 4*sizeof(WCHAR);

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszFamilyName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszFamilyName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszFaceName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszFaceName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszStyleName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszStyleName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

    cjUni = sizeof(WCHAR) * wcslen(ifio.pwszUniqueName());
    bTmp &= bAnsiSize(&cjAnsi,ifio.pwszUniqueName(),cjUni);
    cjotma += cjAnsi;
    *pcjotmw += (UINT)cjUni;

// if any of bAnsiSize calls failed, return zero

    if (!bTmp)
    {
        cjotma = 0;
    }
    return (UINT)cjotma;
}





/******************************Public*Routine******************************\
* cjIFIMetricsToOTM
*
* Converts an IFIMETRICS structure into an OUTLINETEXTMETRICW structure.
* If input buffer size is greater than the offset of the first string
* pointer, it is assumed that ALL the strings are to be copied and that
* the buffer is big enough.
*
* While the OUTLINETEXTMETRICW structure is supposed to contain pointers
* to the strings, this function treats those fields as PTRDIFFs.  The caller
* is responsible for fixing up the structure to contain pointers.  This
* is intended to support copying this structure directly across the client-
* server interface.
*
* Size (including strings) can be computed by calling cjOTMSize.
*
* Note: the beginning of the first string is DWORD aligned immediately
*       following the OUTLINETEXTMETRICW structure in the buffer, but
*       subsequent strings are only WORD aligned.
*
* Warning: this function does not check to see if the buffer size is
*          big enough.  It is ASSUMED, so must be guaranteed by the
*          calling function.
*
* Returns:
*   Size of data copied (in bytes), 0 if an error occurred.
*
*  Wed 27-Jan-1993 -by- Bodin Dresevic [BodinD]
* update: added tmd.ch ... stuff
*
* History:
*  21-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONGSIZE_T cjIFIMetricsToOTMW(
    TMDIFF                  *ptmd,
    OUTLINETEXTMETRICW      *potmw,
    RFONTOBJ                 &rfo,       // need to convert TEXTMETRICS
    DCOBJ                    &dco,       // need to convert TEXTMETRICS
    PIFIMETRICS              pifi,       // input buffer
    BOOL                     bStrings    // copy strings too
    )
{
    ULONGSIZE_T cjRet = 0;
    IFIOBJR ifio(pifi, rfo, dco);

    if (!bValidFont(pifi))
    {
        WARNING("gdisrv!cjIFIMetricsToOTM(): invalid font IFIMETRICS\n");
        return (cjRet);
    }

// Do conversion to fill in TEXTMETRICW field.

    if (!bIFIMetricsToTextMetricWStrict(rfo,dco,&potmw->otmTextMetrics,pifi))
    {
        WARNING("gdisrv!cjIFIMetricsToOTM(): error converting to TEXTMETRIC\n");
        return (cjRet);
    }

    ptmd->chFirst    = pifi->chFirstChar  ;
    ptmd->chLast     = pifi->chLastChar   ;
    ptmd->chDefault  = pifi->chDefaultChar;
    ptmd->chBreak    = pifi->chBreakChar  ;

// If not identity transform, do the transform.

    if ( !rfo.bNtoWIdentity() )
    {
        EFLOAT efBaseline;
        EFLOAT efAscender;

        efBaseline = rfo.efNtoWScaleBaseline(); // cache locally
        efAscender = rfo.efNtoWScaleAscender(); // cache locally

    //
    // CharSlopeRise & CharSlopeRun
    //
        if (efBaseline == efAscender)
        {
        //
        // if the scaling is isotropic then we can use the notional
        // space values of the rise and run
        //
            potmw->otmsCharSlopeRise = (int) ifio.pptlCaret()->y;
            potmw->otmsCharSlopeRun  = (int) ifio.pptlCaret()->x;
        }
        else
        {
            if (efAscender.bIsZero())
            {
                RIP("GDI32!cjIFIMetricsToOTMW -- zero efAscender");
                potmw->otmsCharSlopeRise = (int) ifio.pptlCaret()->y;
                potmw->otmsCharSlopeRun  = (int) ifio.pptlCaret()->x;
            }
            else
            {
                EFLOAT efTemp = efBaseline;
                efTemp.eqDiv(efBaseline,efAscender);
                potmw->otmsCharSlopeRise = (int) ifio.pptlCaret()->y;
                potmw->otmsCharSlopeRun  = (int) lCvt(efTemp, ifio.pptlCaret()->x);

            }
        }

        potmw->otmEMSquare = (UINT) ifio.fwdUnitsPerEm();

        potmw->otmAscent  = (int) lCvt(efAscender, (LONG) ifio.fwdTypoAscender());
        potmw->otmDescent = (int)  lCvt(efAscender, (LONG) ifio.fwdTypoDescender());
        potmw->otmLineGap = (UINT)  lCvt(efAscender, (LONG) ifio.fwdTypoLineGap());

        potmw->otmrcFontBox.top    = (int)lCvt(efAscender, ifio.prclFontBox()->top);
        potmw->otmrcFontBox.left   = (int)lCvt(efBaseline, ifio.prclFontBox()->left);
        potmw->otmrcFontBox.bottom = (int)lCvt(efAscender, ifio.prclFontBox()->bottom);
        potmw->otmrcFontBox.right  = (int)lCvt(efBaseline, ifio.prclFontBox()->right);

        potmw->otmMacAscent = (UINT) lCvt(efAscender, (LONG) ifio.fwdMacAscender());
        potmw->otmMacDescent = (int) lCvt(efAscender, (LONG) ifio.fwdMacDescender());
        potmw->otmMacLineGap = (int) lCvt(efAscender, (LONG) ifio.fwdMacLineGap());

        potmw->otmptSubscriptSize.x   = lCvt(efBaseline, (LONG) ifio.fwdSubscriptXSize());
        potmw->otmptSubscriptSize.y   = lCvt(efAscender, (LONG) ifio.fwdSubscriptYSize());
        potmw->otmptSubscriptOffset.x = lCvt(efBaseline, (LONG) ifio.fwdSubscriptXOffset());
        potmw->otmptSubscriptOffset.y = lCvt(efAscender, (LONG) ifio.fwdSubscriptYOffset());

        potmw->otmptSuperscriptSize.x   = lCvt(efBaseline, (LONG) ifio.fwdSubscriptXSize());
        potmw->otmptSuperscriptSize.y   = lCvt(efAscender, (LONG) ifio.fwdSubscriptYSize());
        potmw->otmptSuperscriptOffset.x = lCvt(efBaseline, (LONG) ifio.fwdSuperscriptXOffset());
        potmw->otmptSuperscriptOffset.y = lCvt(efAscender, (LONG) ifio.fwdSuperscriptYOffset());

        potmw->otmsStrikeoutSize     = (UINT) lCvt(efAscender, (LONG) ifio.fwdStrikeoutSize());
        potmw->otmsStrikeoutPosition = (int) lCvt(efAscender, (LONG) ifio.fwdStrikeoutPosition());

        potmw->otmsUnderscoreSize    = (UINT) lCvt(efAscender, (LONG) ifio.fwdUnderscoreSize());
        potmw->otmsUnderscorePosition = (int) lCvt(efAscender, (LONG) ifio.fwdUnderscorePosition());

        potmw->otmsXHeight     = (UINT) lCvt(efAscender, (LONG) ifio.fwdXHeight());
        potmw->otmsCapEmHeight = (UINT) lCvt(efAscender, (LONG) ifio.fwdCapHeight());
    } /* if */

// Otherwise, copy straight out of the IFIMETRICS

    else
    {
        potmw->otmsCharSlopeRise   = (int) ifio.pptlCaret()->y;
        potmw->otmsCharSlopeRun    = (int) ifio.pptlCaret()->x;

        potmw->otmEMSquare = ifio.fwdUnitsPerEm();

        potmw->otmAscent  = ifio.fwdTypoAscender();
        potmw->otmDescent = ifio.fwdTypoDescender();
        potmw->otmLineGap = (UINT)ifio.fwdTypoLineGap();

        potmw->otmrcFontBox.left    = ifio.prclFontBox()->left;
        potmw->otmrcFontBox.top     = ifio.prclFontBox()->top;
        potmw->otmrcFontBox.right   = ifio.prclFontBox()->right;
        potmw->otmrcFontBox.bottom  = ifio.prclFontBox()->bottom;

        potmw->otmMacAscent  = ifio.fwdMacAscender();
        potmw->otmMacDescent = ifio.fwdMacDescender();
        potmw->otmMacLineGap = ifio.fwdMacLineGap();

        potmw->otmptSubscriptSize.x   = ifio.fwdSubscriptXSize();
        potmw->otmptSubscriptSize.y   = ifio.fwdSubscriptYSize();
        potmw->otmptSubscriptOffset.x = ifio.fwdSubscriptXOffset();
        potmw->otmptSubscriptOffset.y = ifio.fwdSubscriptYOffset();

        potmw->otmptSuperscriptSize.x   = ifio.fwdSuperscriptXSize();
        potmw->otmptSuperscriptSize.y   = ifio.fwdSuperscriptYSize();
        potmw->otmptSuperscriptOffset.x = ifio.fwdSuperscriptXOffset();
        potmw->otmptSuperscriptOffset.y = ifio.fwdSuperscriptYOffset();

        potmw->otmsStrikeoutSize     = ifio.fwdStrikeoutSize();
        potmw->otmsStrikeoutPosition = ifio.fwdStrikeoutPosition();

        potmw->otmsUnderscoreSize     = ifio.fwdUnderscoreSize();
        potmw->otmsUnderscorePosition = ifio.fwdUnderscorePosition();

        potmw->otmsXHeight     = ifio.fwdXHeight();
        potmw->otmsCapEmHeight = ifio.fwdCapHeight();

    } /* else */

// Set the italic angle.  This is in tenths of a degree.

    potmw->otmItalicAngle = ifio.lItalicAngle();

// Calculate the Italics angle.  This is measured CCW from "vertical up"
// in tenths of degrees.  It can be determined from the otmCharSlopeRise
// and the otmCharSlopeRun.

    if
    (
        potmw->otmItalicAngle==0 &&
        !(ifio.pptlCaret()->y > 0 && ifio.pptlCaret()->x == 0)
    )
    {

        EFLOAT efltTheta;
        LONG lDummy;
        EFLOATEXT efX(ifio.pptlCaret()->y);
        EFLOATEXT efY(-ifio.pptlCaret()->x);
        vArctan(efX,efY,efltTheta,lDummy);

    // this way of rounding is less precise than first multiplying efltTheta
    // by 10 and then doing conversion to LONG, but this is win31 precission.
    // They could have as well returned this in degrees rather than in
    // tenths of degrees [bodind]

        potmw->otmItalicAngle = (LONG)lCvt(efltTheta,(LONG)10);

    // convert [0,360) angles to (-180,180] to be consistent with win31

        if (potmw->otmItalicAngle > 1800)
            potmw->otmItalicAngle -= 3600;
    }


// The rest of these do not require transformation of IFIMETRICS info.

    UINT cjotma = cjOTMAWSize(pifi,&potmw->otmSize);

    potmw->otmPanoseNumber  = *ifio.pPanose();
    potmw->otmfsSelection   = ifio.fsSimSelection();
    potmw->otmfsType        = ifio.fsType();

    potmw->otmusMinimumPPEM = ifio.fwdLowestPPEm();

// set offsets to stings to zero if string are not needed

    if (!bStrings)
    {
        potmw->otmpFamilyName = (PSTR) NULL;
        potmw->otmpFaceName   = (PSTR) NULL;
        potmw->otmpStyleName  = (PSTR) NULL;
        potmw->otmpFullName   = (PSTR) NULL;
    }
    else // strings are required
    {
    // This pointer is where we will write the strings.

        PWSZ pwsz = (PWSZ) ((PBYTE) potmw + ALIGN4(sizeof(OUTLINETEXTMETRICW)));

    // Set up pointer as a PTRDIFF, copy the family name.

        potmw->otmpFamilyName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszFamilyName());
        pwsz += wcslen(pwsz) + 1;   // move pointer to next string

    // Set up pointer as a PTRDIFF, copy the face name.

        potmw->otmpFaceName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszFaceName());
        pwsz += wcslen(pwsz) + 1;   // move pointer to next string

    // Set up pointer as a PTRDIFF, copy the style name.

        potmw->otmpStyleName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszStyleName());
        pwsz += wcslen(pwsz) + 1;   // move pointer to next string

    // Set up pointer as a PTRDIFF, copy the full name.

        potmw->otmpFullName = (PSTR) ( (PBYTE) pwsz - (PBYTE) potmw );
        wcscpy(pwsz, ifio.pwszUniqueName());

    // Return length (with strings) This was conveniently cached
    // away in otmSize.

        return(potmw->otmSize);
    }

// Return length (with or without strings) This was conveniently cached
// away in otmSize.

    return sizeof(OUTLINETEXTMETRICW);

}





/******************************Public*Routine******************************\
* BOOL bIFIMetricsToLogFont (
*     PLOGFONT        plf,
*     PIFIMETRICS     pifi
*     )
*
* Fill a LOGFONT structure using the information in a IFIMETRICS structure.
* Units are in NOTIONAL units since font is not realized.
* Called only by control panel private api's.
*
* History:
*  02-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vIFIMetricsToLogFontW (
    PLOGFONTW       plf,
    PIFIMETRICS     pifi
    )
{
    IFIOBJ ifio(pifi);

//     We will override this with a hack here so that all heights are fixed
//     at 24 pels.  This will work because this is the routine that builds
//     the LOGFONTs for GetFontResourceInfo.
//
//     No function other than GetFontResourceInfo should call this function
//     or this hack will screw them over.

// If scalable font, set the em height to 24 pel.

    if (ifio.bContinuousScaling())
    {
        plf->lfHeight = -24;
        plf->lfWidth  = 0;  // don't care, it will be automatically set proportionally
    }

// Its a bitmap font, so Notional units are OK.

    else
    {
        plf->lfHeight = ifio.lfHeight();
        plf->lfWidth  = ifio.lfWidth();
    }

    plf->lfWeight         = ifio.lfWeight();
    plf->lfItalic         = ifio.lfItalic();
    plf->lfUnderline      = ifio.lfUnderline();
    plf->lfStrikeOut      = ifio.lfStrikeOut();
    plf->lfEscapement     = ifio.lfEscapement();
    plf->lfOrientation    = ifio.lfOrientation();

// to ensure round trip:
//  font file name ->
//  logfont returned by GetFontResourceInfoW ->
//     back to the font that lives in this font file

    if (pifi->dpCharSets)
    {
    BYTE *ajCharsets = (BYTE *)pifi + pifi->dpCharSets;
    plf->lfCharSet  = ajCharsets[0]; // guarantees round trip
    }
    else
    {
    plf->lfCharSet  = pifi->jWinCharSet;
    }

    plf->lfOutPrecision   = ifio.lfOutPrecision();
    plf->lfClipPrecision  = ifio.lfClipPrecision();
    plf->lfQuality        = ifio.lfQuality();
    plf->lfPitchAndFamily = ifio.lfPitchAndFamily();

    wcsncpy(plf->lfFaceName, ifio.pwszFamilyName(), LF_FACESIZE);
    plf->lfFaceName[LF_FACESIZE-1] = 0;
}



/******************************Public*Routine******************************\
*
* cjIFIMetricsToETM
*
* History:
*  19-Oct-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vIFIMetricsToETM(
    EXTTEXTMETRIC    *petm,
    RFONTOBJ&         rfo,
    DCOBJ&            dco,
    IFIMETRICS       *pifi
    )
{

    LONG   lHeight;

    IFIOBJR ifio(pifi, rfo, dco);
    // IFIOBJ  ifio(pifi);

    petm->etmSize = sizeof(EXTTEXTMETRIC);

// Windows returns everything in notional units except for etmPointSize
// which is the size in points of the realization in the DC at the time
// Aldus Escap is called so we do that here.

// First get the Em height in device units

    lHeight = LONG_FLOOR_OF_FIX(rfo.fxMaxExtent() + FIX_HALF);

// now get internal leading:

    if (!ifio.bContinuousScaling())
    {
        lHeight -= (LONG)ifio.tmInternalLeading();
    }
    else
    {
        if (rfo.lNonLinearIntLeading() == MINLONG)
        {
        // Set up transform.

            MATRIX      mx;
            EXFORMOBJ   xo(&mx, DONT_COMPUTE_FLAGS | XFORM_FORMAT_LTOFX);
            ASSERTGDI(xo.bValid(), "GreGetETM, xform\n");

            rfo.vSetNotionalToDevice(xo);

            POINTL  ptlHt;
            ptlHt.x = 0;
            ptlHt.y = ifio.fwdUnitsPerEm();
            EVECTORFL evtflHt(ptlHt.x,ptlHt.y);

            xo.bXform(evtflHt);
            EFLOAT  ef;
            ef.eqLength(*(POINTFL *) &evtflHt);

            lHeight = lCvt(ef,1);
        }
        else
        {
        // But if the font provider has given us a hinted internal leading,
        // just use it.

            lHeight -= rfo.lNonLinearIntLeading();
        }
    }

    PDEVOBJ po(dco.hdev());
    ASSERTGDI(po.bValid(), "Invalid PDEV");

    //
    // Next convert to points
    //

    {
        LONG lDenom = (LONG) po.ulLogPixelsY();
        LONGLONG ll = (LONGLONG) lHeight;

        ll = ll * 72 + (LONGLONG) (lDenom / 2);
        if (ll > LONG_MAX)
        {
            lHeight = (LONG) (ll / (LONGLONG) lDenom);
        }
        else
        {
            lHeight = ((LONG) ll) / lDenom;
        }
    }

    //
    // The following line of code is forced upon us by the
    // principle that it is better to be Win 3.1 compatible
    // that it is to be correct
    //

    petm->etmPointSize            = 20 *  (SHORT) lHeight;  // convert to twips
    petm->etmOrientation          = 0  ;
    petm->etmMasterHeight         = ifio.fwdUnitsPerEm();
    petm->etmMinScale             = ifio.fwdLowestPPEm();
    petm->etmMaxScale             = 0x4000;
    petm->etmMasterUnits          = ifio.fwdUnitsPerEm();
    petm->etmCapHeight            = ifio.fwdTypoAscender();
    petm->etmXHeight              = ifio.fwdXHeight();
    petm->etmLowerCaseAscent      = ifio.fwdTypoAscender();
    petm->etmLowerCaseDescent     = - ifio.fwdTypoDescender();
    petm->etmSlant                = (UINT)(- (INT) ifio.lItalicAngle());
    petm->etmSuperScript          = (SHORT) ifio.fwdSuperscriptYOffset();
    petm->etmSubScript            = (SHORT) ifio.fwdSubscriptYOffset();
    petm->etmSuperScriptSize      = (SHORT) ifio.fwdSuperscriptYSize();
    petm->etmSubScriptSize        = (SHORT) ifio.fwdSubscriptYSize();
    petm->etmUnderlineOffset      = (SHORT) ifio.fwdUnderscorePosition();
    petm->etmUnderlineWidth       = (SHORT) ifio.fwdUnderscoreSize();
    petm->etmDoubleUpperUnderlineOffset =
                                  ifio.fwdUnderscorePosition() >> 1;
    petm->etmDoubleLowerUnderlineOffset =
                                  (SHORT)(ifio.fwdUnderscorePosition());
    petm->etmDoubleUpperUnderlineWidth =
        petm->etmDoubleLowerUnderlineWidth =
                                  ifio.fwdUnderscoreSize() >> 1;
    petm->etmStrikeOutOffset      = (SHORT)(ifio.fwdStrikeoutPosition());
    petm->etmStrikeOutWidth       = (SHORT)(ifio.fwdStrikeoutSize());
    petm->etmNKernPairs           = (WORD) pifi->cKerningPairs;
    petm->etmNKernTracks          = 0;

}


/********************************************************************************
 * GreNameEscape(LPWSTR, int, int, LPSTR, int, LPSTR)
 *
 * Named escape functionality for installable font drivers.
 *
 * This function allows an escape to be sent to a font driver.
 *
 * History
 *  3-5-95 16:00:54 by Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ********************************************************************************/

INT
GreNamedEscape(
    LPWSTR pDriver, //  Identifies the file name of the font driver
    int iEscape,    //  Specifies the escape function to be performed.
    int cjIn,       //  Number of bytes of data pointed to by pvIn.
    LPSTR pvIn,     //  Points to the input data.
    int cjOut,      //  Number of bytes of data pointed to by pvOut.
    LPSTR pvOut     //  Points to the structure to receive output.
)
{
    GDIFunctionID(GreNamedEscape);

    WCHAR PathBuffer[MAX_PATH];

    UNICODE_STRING usDriverPath;

    usDriverPath.Length = 0;
    usDriverPath.MaximumLength = MAX_PATH * sizeof(WCHAR);
    usDriverPath.Buffer = PathBuffer;

    RtlAppendUnicodeToString(&usDriverPath,L"\\SystemRoot\\System32\\");
    RtlAppendUnicodeToString(&usDriverPath,pDriver);

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
    PPDEV ppDevList = gppdevList;

    do
    {
        PDEVOBJ pdo((HDEV)ppDevList);

    // first find the driver, make sure the paths match and the
    // driver is really a font driver (that way no one can make
    // a DrvEscape call with a NULL surface to printer driver)

        if (pdo.ppdev->fl & PDEV_FONTDRIVER)
        {
            if ((ppDevList == gppdevATMFD && !_wcsicmp(pDriver, L"atmfd.dll")) ||
                pdo.MatchingLDEVImage(usDriverPath))
            {
                if (PPFNVALID(pdo, Escape))
                {
                // dont make the call while holding the semaphore
        
                    GreReleaseSemaphoreEx(ghsemDriverMgmt);
        
                    return( pdo.Escape)( NULL, (ULONG)iEscape, (ULONG)cjIn, pvIn, (ULONG)cjOut, pvOut );
                }
            }
        }

    } while(ppDevList = ppDevList->ppdevNext);

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\fontmap.cxx ===
/******************************Module*Header*******************************\
* Module Name: fontmap.cxx                                                 *
*                                                                          *
* Routines for mapping fonts.                                              *
*                                                                          *
* Created: 17-Jun-1992 11:12:16                                            *
* Author: Kirk Olynyk [kirko]                                              *
*                                                                          *
* Copyright (c) 1992-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"

extern "C" VOID vInitMapper();
extern "C" NTSTATUS DefaultFontQueryRoutine(IN PWSTR, IN ULONG, IN PVOID,
                                            IN ULONG, IN PVOID, IN PVOID);

#pragma alloc_text(INIT, vInitMapper)
#pragma alloc_text(INIT, DefaultFontQueryRoutine)

// external procedures from draweng.cxx

VOID   vArctan(EFLOAT, EFLOAT,EFLOAT&, LONG&);

// external procedure from FONTSUB.CXX

#ifdef LANGPACK
extern "C" BOOL EngLpkInstalled();
#endif


/*** globals defined in this module ***/

#if DBG
    #define DEBUG_SMALLSUBSTITUTION 0x80
     FLONG gflFontDebug = 0;

    PFE *ppfeBreak = 0;
    LONG lDevFontThresh = FM_DEVICE_FONTS_ARE_BETTER_BELOW_THIS_SIZE;
#endif

static const WCHAR gpwszDefFixedSysFaceName[] = L"FIXEDSYS";

#define WIN31_SMALL_WISH_HEIGHT 2
#define WIN31_SMALL_FONT_HEIGHT 3

PFE *gppfeMapperDefault = PPFENULL;     // set to something meaningfule
                                        // at boot by bInitSystemFont()
                                        // in stockfnt.cxx

// Storage for static globals in MAPPER

PDWORD MAPPER::SignatureTable;     // base of the signature table
PWCHAR MAPPER::FaceNameTable;      // base of the face name table
BYTE   MAPPER::DefaultCharset;     // default charset is equivilent to this


/******************************Public*Routine******************************\
* BYTE jMapCharset()
*
* This routine is stollen from Win95 code (converted from asm).
* It checks if a font supports a requested charset.
*
* History:
*   2-Jul-1997 -by- Yung-Jen Tony Tsai [yungt]
*  17-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BYTE jMapCharset(BYTE lfCharSet, PFEOBJ &pfeo)
{
    BYTE    jCharSet;
    BYTE    jLinkedCharSet;
    BYTE *  ajCharSets;
    BYTE *  ajCharSetsEnd;
    BYTE *  pjCharSets;

    IFIMETRICS *pifi = pfeo.pifi();
    // if only one charset supported in a font, this is the best match to
    // the request that the font can offer.

    // the check for FM_INFO_TECH_TYPE1 is a temporary hack until
    // we add a new field to the IFI metrics for the Type1 font ID's
    // [gerritv] 8-23-95

    if (pifi->dpCharSets == 0)
    {
        return( pifi->jWinCharSet );
    }

    // this is what is meant by default_charset:

    if (lfCharSet == DEFAULT_CHARSET)
    {
        lfCharSet = MAPPER::DefaultCharset;
    }

    // if several charsets are supported, let us check out
    // if the requested one is one of them:

    ajCharSets = (BYTE *)pifi + pifi->dpCharSets;
    ajCharSetsEnd = ajCharSets + MAXCHARSETS;

    for (pjCharSets = ajCharSets; pjCharSets < ajCharSetsEnd; pjCharSets++)
    {
        if (*pjCharSets == lfCharSet)
        {
            return( lfCharSet );
        }
        if (*pjCharSets == DEFAULT_CHARSET) // terminator
        {

    // The charset did not support in base font.
    // We need to check the charset of linked font
    // If there is one, then we get it
    // otherwise, we return BaseFont.ajCharSets[0]
            jCharSet = ajCharSets[0];
            break;
        }
    }


    if (pfeo.pGetLinkedFontEntry())
    {
    // No charset in the base font matches the requested charset.
    // And this base font has lined font.  Then we should check
    // the charsets in the linked font to see if there is a
    // match there as well.

        PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;
        while ( p != pfeo.pGetLinkedFontList() )
        {
            PPFEDATA    ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);
            PFEOBJ      pfeoEudc(ppfeData->appfe[PFE_NORMAL]);

            pifi = pfeoEudc.pifi();

            if (pifi->dpCharSets == 0 && pifi->jWinCharSet == lfCharSet)
            {
                return ( lfCharSet );
            }
        else if (pifi->dpCharSets)
            {
                ajCharSets = (BYTE *)pifi + pifi->dpCharSets;
                ajCharSetsEnd = ajCharSets + MAXCHARSETS;

                for (pjCharSets = ajCharSets; pjCharSets < ajCharSetsEnd; pjCharSets++)
                {
                    if (*pjCharSets == lfCharSet)
                    {
                        return ( lfCharSet );
                    }
                    if (*pjCharSets == DEFAULT_CHARSET) // terminator
                    {

                        break; // End of for loop
                    }
                }
            }
            p = p->Flink;
        }
    }

    return(jCharSet);

}

/******************************Public*Routine******************************\
*  GreGetCannonicalName(
*
*  The input is the zero terminated name of the form
*
*  foo_XXaaaYYbbb...ZZccc
*
*  where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
*        aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
*  letters with abbreviated axes names.
*
*  This face name will be considered equivalent to face name foo
*  with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
*  by number of numeral sequences.
*
*
* Effects:
*
* History:
*  25-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define IS_DIGIT(x)   (((x) >= L'0') && ((x) <= L'9'))
#define GET_DIGIT(X)  ((X) - L'0')
#define WC_UNDERSCORE L'_'


VOID GreGetCannonicalName(
    const WCHAR        *pwszIn,  // foo_XX_YY
    WCHAR        *pwszOut, // Cannonical and capitalized name FOO
    ULONG        *pcAxes,
    DESIGNVECTOR *pdv      // [XX,YY] on out
)
{
// The input is the zero terminated name of the form
//
// foo_XXaaaYYbbb...ZZccc
//
// where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
//       aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
// letters with abbreviated axes names.
//
// This face name will be considered equivalent to face name foo
// with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
// by number of numeral sequences.

    const WCHAR *pwc;
    ULONG cAxes = 0;
    ULONG cwc;

    for
    (
        pwc = pwszIn ;
        (*pwc) && !((*pwc == WC_UNDERSCORE) && IS_DIGIT(pwc[1]));
        pwc++
    )
    {
        // do nothing;
    }

// copy out, zero terminate

// Sundown safe truncation
    cwc = (ULONG)(pwc - pwszIn);
    memcpy(pwszOut, pwszIn, cwc * sizeof(WCHAR));
    pwszOut[cwc] = L'\0';

// If we found at least one WC_UNDERSCORE followed by the DIGIT
// we have to compute DV. Underscore followed by the DIGIT is Adobe's rule

    if ((*pwc == WC_UNDERSCORE) && IS_DIGIT(pwc[1]))
    {
    // step to the next character behind undescore

        pwc++;

        while (*pwc)
        {
        // go until you hit the first digit

            for ( ; *pwc && !IS_DIGIT(*pwc) ; pwc++)
            {
                // do nothing
            }


            if (*pwc)
            {
            // we have just hit the digit

                ULONG dvValue = GET_DIGIT(*pwc);

            // go until you hit first nondigit or the terminator

                pwc++;

                for ( ; *pwc && IS_DIGIT(*pwc); pwc++)
                {
                    dvValue = dvValue * 10 + GET_DIGIT(*pwc);
                }

                pdv->dvValues[cAxes] = (LONG)dvValue;

            // we have just parsed a string of numerals

                cAxes++;
            }
        }
    }

// record the findings

    *pcAxes = cAxes;
    pdv->dvNumAxes = cAxes;
    pdv->dvReserved = STAMP_DESIGNVECTOR;
}





/******************************Member*Function*****************************\
* bInitMapper()
*
* This callback routine reads the default facename entries from the registry.
* The entries have a the following form:
*
* FontMapper
*   FaceName1 = REG_DWORD FontSignature1
*   FaceName2 = REG_DWORD FontSignature2
*   .........
*   Default   = REG_DWORD Charset equivilent to default charset
*
* The FontSignature entry has the following format:
*
*
*         |-----------------Used when fixed pitch is requested
*         ||--------------- Used when FF_ROMAN is requested
*         |||-------------- Used when vertical face is requested
*         |||-------------- Used as first choice for BM font
*         ||||------------- Used as second choice for BM font
*         ||||
*         ||||    |------- Bits 0-7 Charset
*         ||||    |
* YYYYYYYYXXXXYYYYXXXXXXXX
*
* The bits specified by Y's are unused.  Thus determine what face name is
* to be used by default, the mapper will create a signature based on pitch,
* family, charset, etc fields in the LOGFONT and then try to match it against
* the signature/facename pairs in the registry.  Putting these values in
* the registry makes it possible add extra entries for other charsets such
* as Shift-JIS and Big-5.
*
*
* History:
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C"
NTSTATUS
DefaultFontQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PREGREADER RegRead = (PREGREADER) Context;


    if( !_wcsicmp( ValueName, L"DEFAULT" ) )
    {
        // The value "Default" is a special case.
        // It doesn't refer to the facename and instead indicates
        // which charset the default charset is equivilent to.

        DWORD Data = *((DWORD*)ValueData);
        RegRead->DefaultCharset = (BYTE) Data;
    }
    else if( RegRead->NextValue == NULL )
    {
        //  If NextValue is NULL then this is the first pass
        //  of the enumeration and we are just figuring out
        //  the number of entries and size of buffer we
        //  will need.

        RegRead->TableSize += ( wcslen(ValueName) + 1 ) * sizeof(WCHAR);
        RegRead->NumEntries += 1;
    }
    else
    {
        // On this pass we are actually building up a table of
        // signtures and face names to match them.

        if( ValueType == REG_DWORD )
        {
            // move the font signature portion to the high word,
            // the low word will store the offset to the facename

            DWORD Data = (*((DWORD*)ValueData));

            Data |= ( RegRead->NextFaceName - RegRead->FaceNameBase ) << 16;

            *(RegRead->NextValue)++ = Data;

            //  We ignore the last character of the string
            //  if it is a number. This allows us to have
            //  multiple entries for the same face name like
            //  Roman0, Roman1, etc.

            UINT ValueLen = wcslen(ValueName);

            wcscpy( RegRead->NextFaceName, ValueName );

            if( ValueName[ValueLen-1] >= (WCHAR) '0' &&
                ValueName[ValueLen-1] <= (WCHAR) '9' )
            {
                ValueLen -= 1;
                (RegRead->NextFaceName)[ValueLen] = (WCHAR) 0;
            }

            RegRead->NextFaceName += ValueLen+1;

            // Finally update the number of entries

            RegRead->NumEntries += 1;
        }
        else
        {
            WARNING("DefaultFontQueryRoutine:invalid registry entry\n");
            return(!STATUS_SUCCESS);
        }
    }
    return( STATUS_SUCCESS );
}



/******************************Member*Function*****************************\
* vInitMapper()
*
* This funtion reads in the FontSignature/Default facenmame pairs from
* the registry.  The format of these pairs is described in the comment
* for the DefaultFontQueryRoutine function.  vInitMapper() is called once
* when winsrv is initialized.
*
* If there is an error in initialization the mapper can still work but just
* won't fill in default facenames properly and will perform considerably
* slower for requests in which no facename is specified or which an invalid
* facename is specified.
*
* History:
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C" VOID vInitMapper()
{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    DWORD Status;
    REGREADER RegRead;

    QueryTable[0].QueryRoutine = DefaultFontQueryRoutine;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = (PWSTR)NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    RegRead.NumEntries = 0;
    RegRead.TableSize = 0;
    RegRead.NextValue = NULL;

    MAPPER::SignatureTable = NULL;
    MAPPER::FaceNameTable = NULL;

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"FontMapper",
                                    QueryTable,
                                    &RegRead,
                                    NULL );

    if( NT_SUCCESS(Status) )
    {
        MAPPER::SignatureTable = (PDWORD)
            PALLOCMEM(RegRead.NumEntries * sizeof(DWORD) + RegRead.TableSize,'pamG');

        if( MAPPER::SignatureTable == NULL )
        {
            WARNING("vInitMapper:Unable to allocate enough memory\n");
            return;
        }

        // Set all the proper pointers in the REGREAD structure
        // for the next pass of the enumeration to use.

        RegRead.NextValue = MAPPER::SignatureTable;
        RegRead.FaceNameBase = (PWCHAR) &(MAPPER::SignatureTable[RegRead.NumEntries]);
        RegRead.NumEntries = 0;
        RegRead.NextFaceName = RegRead.FaceNameBase;

        // do the second pass of the enumeration

        Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                        L"FontMapper",
                                        QueryTable,
                                        &RegRead,
                                        NULL );
        // we are done

        if( NT_SUCCESS(Status) )
        {
            MAPPER::FaceNameTable = RegRead.FaceNameBase;
            MAPPER::DefaultCharset = RegRead.DefaultCharset;

            return;
        }

        // else fall through to error warning and reset MAPPER::FaceNameTable

        VFREEMEM(MAPPER::SignatureTable);
        MAPPER::SignatureTable = NULL;
    }
    WARNING("vInitMapper:Error enumerating default face names\n");
}


/******************************Member*Function*****************************\
* PWSZ FindFaceName
*
* This routine takes a signature (described above)
* and tries to find a defualt facename that matches it.
* If it doesn't find a match if will return a pointer
* to an empty string.
*
* History:
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

PWSZ FindFaceName( DWORD Signature )
{
    PDWORD SigPtr;

    for( SigPtr = MAPPER::SignatureTable;
         SigPtr < (PDWORD) MAPPER::FaceNameTable;
         SigPtr += 1)
    {
        if( (*SigPtr & 0xFFFF ) == Signature )
        {
            return( MAPPER::FaceNameTable + (*SigPtr >> 16 & 0xFFFF ) );
        }
    }

    //  Return a pointer to an empty string. Nothing will match
    //  this causing us to fall through to a case where do a
    //  mapping which doesnt take face name into account.

    return( (PWSZ) L"" );
}



/******************************Member*Function*****************************\
* MAPPER::MAPPER()                                                         *
*                                                                          *
* History:                                                                 *
*  Tue 29-Dec-1992 09:22:31 by Kirk Olynyk [kirko]                         *
* Added back in the case for small font substitution.                      *
*                                                                          *
*  Fri 18-Dec-1992 22:43:09 -by- Charles Whitmer [chuckwh]                 *
* Slimmed it down by removing lots of structure copies.                    *
*                                                                          *
*  Tue 10-Dec-1991 12:45:41 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

MAPPER::MAPPER
(
      XDCOBJ       *pdcoSrc,         // current DC
      FLONG        *pflSim_,
      POINTL       *pptlSim_,
      FLONG        *pflAboutMatch_,
const ENUMLOGFONTEXDVW *pelfwWishSrc,    // wish list in World Coordinates
      const WCHAR * pwszFaceName_,
      ULONG         ulMaxPenaltySrc, // pruning criteria
      BOOL          bIndexFont_,
      FLONG         flOptions = 0
)
{

    fl            = 0;
    ifio.vSet((IFIMETRICS*) NULL);
    pdco          = pdcoSrc;
    pelfwWish     = pelfwWishSrc;
    pwszFaceName  = pwszFaceName_;

// check if this face name might a long foo_XX_YY name of the instance

    ULONG cAxes;
    flMM = 0;

    GreGetCannonicalName(
        pwszFaceName_,  // foo_XX_YY
        this->awcBaseName, // Cannonical and capitalized name FOO
        &cAxes,
        &this->dvWish);

    ppfeMMInst    = NULL; // no instances found yet that match this instances base font

// if GreGetCannonicalName did not find any axes info in the name,
// but the design vector is specified explicitly we use it.
// If however, cAxes from the name is not zero, we ignore
// whatever may be specified in the design vector explicitely.

    if (cAxes == 0)
    {
        if (pelfwWish->elfDesignVector.dvNumAxes)
        {
            RtlCopyMemory(
                &this->dvWish,
                &pelfwWish->elfDesignVector,
                SIZEOFDV(pelfwWish->elfDesignVector.dvNumAxes)
                );
        }
        else
        {
            awcBaseName[0] = 0;
        }
    }
    else
    {
        flMM |= FLMM_DV_FROM_NAME;
    }

    ulMaxPenalty  =  ulMaxPenaltySrc;
    bIndexFont    = bIndexFont_;

    ASSERTGDI(pdco && pelfwWish,"Bad call to MAPPER\n");

    // to begin with use the lfCharSet value from the logfont, this may
    // be latter replaced by the value from [font substitutes]

    jMapCharSet = pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet;

    {
        pflAboutMatch  = pflAboutMatch_;
        *pflAboutMatch = 0;

        ppfeBest       = (PFE*) NULL;
        ulBestTime     = ULONG_MAX;
        pflSimBest     = pflSim_;
        pptlSimBest    = pptlSim_;

        *pflSimBest    = 0;
        pptlSimBest->x = 1;
        pptlSimBest->y = 1;
    }

    // Is it a display DC or it's moral equivilent?

    fl |= pdco->bPrinter() ? 0 : FM_BIT_DISPLAY_DC;

    // Set the GM_COMPATIBLE bit.
    //
    // If we are playing a metafile , world to page transform may be set
    // even if the graphics mode is COMPATIBLE, in which case the mapping
    // will occur the same way as it would in the advanced mode case
    // [bodind].

    if
    (
        (pdco->pdc->iGraphicsMode() == GM_COMPATIBLE) &&
        (pdco->pdc->bWorldToPageIdentity() || !pdco->pdc->bUseMetaPtoD())
    )
    {
        fl |= FM_BIT_GM_COMPATIBLE;
    }
    else
    {
        // If you are in advanced mode, then ignore the windows
        // hack for stock fonts

        flOptions &= ~FM_BIT_PIXEL_COORD;
    }

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfQuality == PROOF_QUALITY)
    {
        fl |= FM_BIT_PROOF_QUALITY;
    }

    //  The windows short circuit mapper doesn't get called
    //  when an a NULL facename is requested.  In this case
    //  windows goes to the long mapper where a true type font
    //  will win over a raster font for some reason if the weight
    //  requested is FW_BOLD or FW_NORMAL.  We on the other
    //  hand will give out a raster font in this case which
    //  causes CA Super Project to break.  We mark this case
    //  here and fail bFindBitmapFont font when it occurs. [gerritv]

    if( ( pelfwWish->elfEnumLogfontEx.elfLogFont.lfWeight == FW_NORMAL ) ||
        ( pelfwWish->elfEnumLogfontEx.elfLogFont.lfWeight == FW_BOLD ) )
    {
        fl |= FM_BIT_WEIGHT_NOT_FAST_BM;
    }

    //  If the requested facename is Ms Shell Dlg then we wont
    //  worry about charset. This is a hack to make the shell
    //  work with other versions of Ms Sans Serif
    //  such as Greek [gerritv]

    if( pwszFaceName[0] ==  U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[1] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[2] ==  U_SPACE                  &&
        pwszFaceName[3] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[4] ==  U_LATIN_CAPITAL_LETTER_H &&
        pwszFaceName[5] ==  U_LATIN_CAPITAL_LETTER_E &&
        pwszFaceName[6] ==  U_LATIN_CAPITAL_LETTER_L &&
        pwszFaceName[7] ==  U_LATIN_CAPITAL_LETTER_L &&
        pwszFaceName[8] ==  U_SPACE                  &&
        pwszFaceName[9] ==  U_LATIN_CAPITAL_LETTER_D &&
        pwszFaceName[10] == U_LATIN_CAPITAL_LETTER_L &&
        pwszFaceName[11] == U_LATIN_CAPITAL_LETTER_G &&
        pwszFaceName[12] == U_NULL
      )
    {
        fl |= FM_BIT_MS_SHELL_DLG;
    }
    else if
    (
        // If the requested facename is 'system' then Windows 3.1
        // compatibilty requires that we treat this case specially

        pwszFaceName[0] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[1] ==  U_LATIN_CAPITAL_LETTER_Y &&
        pwszFaceName[2] ==  U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[3] ==  U_LATIN_CAPITAL_LETTER_T &&
        pwszFaceName[4] ==  U_LATIN_CAPITAL_LETTER_E &&
        pwszFaceName[5] ==  U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[6] ==  U_NULL
    )
    {
        // record the fact that 'SYSTEM' has been requested

        fl |= FM_BIT_SYSTEM_REQUEST;

        // If the request was for a fixed pitch font, then the
        // application really wants 'FIXEDSYS' instead

        if ((pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & 0xF) == FIXED_PITCH)
        {
            pwszFaceName = gpwszDefFixedSysFaceName;
        }
    }
    else if
    (
        pwszFaceName[0] == U_LATIN_CAPITAL_LETTER_T &&
        pwszFaceName[1] == U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[2] == U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[3] == U_SPACE                  &&
        pwszFaceName[4] == U_LATIN_CAPITAL_LETTER_R &&
        pwszFaceName[5] == U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[6] == U_LATIN_CAPITAL_LETTER_N &&
        pwszFaceName[7] == U_NULL
    )
    {
        fl |= FM_BIT_TMS_RMN_REQUEST;
    }
    else if
    (
        // If the user requests symbol then he can goof up
        // the character set. This was put in to allow
        // "Spyglass Plot" to work See Bug #18228

        pwszFaceName[0] == U_LATIN_CAPITAL_LETTER_S &&
        pwszFaceName[1] == U_LATIN_CAPITAL_LETTER_Y &&
        pwszFaceName[2] == U_LATIN_CAPITAL_LETTER_M &&
        pwszFaceName[3] == U_LATIN_CAPITAL_LETTER_B &&
        pwszFaceName[4] == U_LATIN_CAPITAL_LETTER_O &&
        pwszFaceName[5] == U_LATIN_CAPITAL_LETTER_L
    )
    {
        fl |= FM_BIT_CHARSET_ACCEPT;
    }
// If user requests vertical font. We have to map this logical font to vertical
// Physical font
    else if
    (
        pwszFaceName[0] == U_COMMERCIAL_AT
    )
    {
        fl |= FM_BIT_VERT_FACE_REQUEST;
    }

    // Copy over the requested sizes.  We will transform them to device
    // coordinates later if needed.

    lDevWishHeight = pelfwWish->elfEnumLogfontEx.elfLogFont.lfHeight;

    lDevWishWidth  = ABS( pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth );

    {
        // Lock the PDEV to get some important information

        PDEVOBJ pdo((HDEV)pdco->pdc->ppdev());

        ulLogPixelsX = pdo.ulLogPixelsX();
        ulLogPixelsY = pdo.ulLogPixelsY();

        fl |= (pdo.flTextCaps() & TC_RA_ABLE)       ? FM_BIT_DEVICE_RA_ABLE   : 0;
        fl |= (pdo.flTextCaps() & TC_CR_90)         ? FM_BIT_DEVICE_CR_90_ALL : 0;
        fl |= (pdo.cFonts())                        ? FM_BIT_DEVICE_HAS_FONTS : 0;
        fl |= (pdo.ulTechnology() == DT_PLOTTER)    ? FM_BIT_DEVICE_PLOTTER   : 0;
        fl |= (pdo.ulTechnology() == DT_CHARSTREAM) ? FM_BIT_DEVICE_ONLY      : 0;

        ASSERTGDI(
            !((pdo.ulTechnology() == DT_PLOTTER) &&
                           (pdo.flTextCaps() & TC_RA_ABLE)),
            "winsrv!I didn't anticipate a plotter "
            "that can handle bitmap fonts\n"
        );

        if (lDevWishHeight == 0)
        {
            //  "If lfHeight is zero, a reasonable default size is
            //  substituted." [SDK Vol 2].  Fortunately, the
            //  device driver is kind enough to suggest a nice
            //  height (in pixels).  We shall put this suggestion
            //  into lDefaultDeviceHeight
            //
            //  NOTE:
            //
            //  I have assumed that the suggested font height, as
            //  given in lDefaultDeviceHeight is in pixel units

            lDevWishHeight = pdo.pdevinfoNotDynamic()->lfDefaultFont.lfHeight;

            // Inform bCalculateWishCell that the height needs no transform.

            fl |= FM_BIT_HEIGHT;
        }
        // At this point the PDEVOBJ passes out of scope and unlocks the PDEV
    }
    if (lDevWishHeight < 0)
    {
        fl |= FM_BIT_USE_EMHEIGHT;
        lDevWishHeight *= -1;
    }

    // Cache the wish weight and assign default weight if
    // no weight specified.  (This way we don't have to
    // compute this each time in msCheckFont.  And we
    // can't modify pelfwWish directly because it is
    // declared "const").

    lWishWeight = (LONG) pelfwWish->elfEnumLogfontEx.elfLogFont.lfWeight;

    if( lWishWeight == FW_DONTCARE )
    {
        // if FW_DONTCARE then we compute penalities
        // slightly differently so we keep track of this

        fl |= FM_BIT_FW_DONTCARE ;

        lWishWeight = FW_NORMAL;
    }

    // If the caller did not provide a face name, we provide a default.

    if (pwszFaceName[0] == (WCHAR) 0)
    {
        bGetFaceName();
    }

    fl |= (flOptions & FM_ALLOWED_OPTIONS) | FM_BIT_STILL_ALIVE;
}

/******************************Member*Function*****************************\
* BOOL bGetFaceName()                                                      *
*                                                                          *
* Gets a face name when there is none                                      *
*                                                                          *
* Comments                                                                 *
*                                                                          *
*   you got here because no facename was provided by                       *
*   the user.  At this point we shall select the font                      *
*   based upon its height and pitch and family.  First                     *
*   we examine the height in device space.  If the                         *
*   height has been calculated already then the                            *
*   FM_BIT_HEIGHT bit will have been set and no                            *
*   calculation is needed.  Otherwise we must                              *
*   calculate the requested height in pixel unit.  We                      *
*   do this by calling off to                                              *
*   MAPPER::bCaluculateWishCell().  If this returns                        *
*   with FALSE then the transformation was not                             *
*   appropriate to a bitmap font and we can choose                         *
*   only from TrueType defaults.  If                                       *
*   MAPPER::bCalculateWishCell returns true then                           *
*   this->lDevWishHeight has been calculated.  At that                     *
*   point we must see if it is in the range where the                      *
*   'small' fonts should be used, otherwise we must                        *
*   default to the TrueType fonts.                                         *
*                                                                          *
* Returns:                                                                 *
*   The only situation for this function to return FALSE is if the         *
*   FM_BIT_DISABLE_TT_NAMES bit is set in the MAPPER state.  When this     *
*   bit is set, the function may fail to find a suitable new facename      *
*   (because the catch-all of the TT core facenames is turned off).        *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  Thu 2-Jun-1994 16:42:11 by Gerrit van Wingerden [gerritv]               *
* Rewrote it to get default facenames from the registry                    *
*  Thu 11-Mar-1993 14:09:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL MAPPER::bGetFaceName()
{
    BYTE Charset;

    // if the default charset is specified then use the
    // registry entry to determine what it really means

    Charset = (jMapCharSet == DEFAULT_CHARSET) ?
                MAPPER::DefaultCharset : jMapCharSet;

    fl |= FM_BIT_CALLED_BGETFACENAME;

    // compute the signature of the desired font

    DWORD Signature = (DWORD) Charset;

    if(( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (LOGFONT_PITCH_SET) ) == FIXED_PITCH )
    {
        Signature |= DFS_FIXED_PITCH;
    }

    if(( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (FF_SET) ) == FF_ROMAN )
    {
        // the font family is only important for variable pitch fonts

        Signature |= DFS_FF_ROMAN;
    }
    else
    if(( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (LOGFONT_PITCH_SET) ) == DEFAULT_PITCH &&
       ( pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (FF_SET) ) == FF_MODERN )
    {
        // Windows95 may sometimes chooses Courier instead of Courier New

        Signature |= DFS_FIXED_PITCH;
    }

    if( fl & FM_BIT_VERT_FACE_REQUEST )
    {
        Signature |= DFS_VERTICAL;
    }

    //  In the case of the ANSI character set, we need to
    //  consider the possibility of using one of the small
    //  bitmap fonts.  If this search is unsuccessful, we
    //  will fall into the default case, which chooses an
    //  appropriate TrueType font from the core set.
    //
    //  The following set of conditions check to see if
    //  the requested height is so small so as to make
    //  TrueType fonts look awful.  The only way to know
    //  is to calculate the wish cell by calling to
    //  bCalculateWishCell().
    //
    //  bCalculateWishCell() will return FALSE if the font
    //  request is not suitable for a bitmap font.  It
    //  turns out that this condition may be too
    //  stringent.  Win 3.1 compatibility forces us to
    //  choose "Courier New" as the default small fixed
    //  pitch font.  Thus, it is possible that
    //  bCalculateWishCell() would reject "Courier New" on
    //  the false premise that the transform is
    //  incompatible with all small fonts because they
    //  should be bitmap fonts.  In any case, I will go
    //  with the follwing conditions until I am proven
    //  wrong.  It is my belief that in such a case,
    //  "Courier New" will be picked up in the else
    //  clause.

    if
    (
        ( Charset == ANSI_CHARSET                                 ) &&
        (fl  & FM_BIT_DEVICE_RA_ABLE                              ) &&
        ((fl & FM_BIT_CELL) ? TRUE : bCalculateWishCell()         ) &&
        ((fl & FM_BIT_ORIENTATION) ? TRUE : bCalcOrientation()    ) &&
        (
            iOrientationDevice == 0 * ORIENTATION_90_DEG ||
            iOrientationDevice == 1 * ORIENTATION_90_DEG ||
            iOrientationDevice == 2 * ORIENTATION_90_DEG ||
            iOrientationDevice == 3 * ORIENTATION_90_DEG
        )
    )
    {
        // Note: If we break out of this switch, we will fall into
        // the TT case below.  We are writing it this way so that
        // we can bail out of the "small font" case and into the TT
        // case if we have to.

        PWSZ pwszBitmap;

        pwszBitmap = FindFaceName( Signature | DFS_BITMAP_A );

        // Try the first choice

        if ( bFindBitmapFont(pwszBitmap) )
        {
            pwszFaceName = pwszBitmap;
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("MAPPER::bGetFaceName() --> \"%ws\"\n", pwszFaceName);
            }
            #endif
            return( TRUE );
        }

        // The first choice doesn't cut it, try the second choice

        pwszBitmap = FindFaceName( Signature | DFS_BITMAP_B );

        if ( bFindBitmapFont(pwszBitmap) )
        {
            pwszFaceName = pwszBitmap;
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("MAPPER::bGetFaceName() --> \"%ws\"\n", pwszFaceName);
            }
            #endif
            return( TRUE );
        }

        // If we get to here, we couldn't find a suitable raster
        // small font.  If the FM_BIT_DISABLE_TT_NAMES flag is
        // set, return error.  Otherwise, fall into the TT facename
        // substitution code below in the default case.

        if (fl & FM_BIT_DISABLE_TT_NAMES)
        {
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("MAPPER::bGetFaceName() failed\n");
            }
            #endif
            return( FALSE );
        }
    }

    // find the face name

    PWSZ pwszTemp = FindFaceName( Signature );
    if (*pwszTemp || !(fl & FM_BIT_FACENAME_MATCHED))
    {
        // If a new name was found then it should be used. On the
        // other hand, if a new name was not found then we must check
        // to see if the face name as specified in the LOGFONT was
        // ever found in the font tables. If the original face name
        // was found then we should use it again, but this time
        // allow character set mismatches. If the original name was
        // not found in the font table then return a string of zero
        // length causing the font mapper to fall into the emergency
        // procedure.

        pwszFaceName = pwszTemp;
    }
    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("MAPPER::bGetFaceName() --> \"%ws\"\n", pwszFaceName);
    }
    #endif

    return( TRUE );
}

/******************************Public*Routine******************************\
* BOOL MAPPER::bFindBitmapFont                                             *
*                                                                          *
* The purpose of this function is to determine whether a bitmap font       *
* with the given facename and EXACTLY the wish height exists.  The         *
* purpose is to support Windows 3.1 compatible "small font" behavior.      *
* The Win 3.1 short circuit mapper (written by DavidW) forces mapping to   *
* the either of the standard small fonts ("Small fonts" and "MS Serif")    *
* only if the exact height requested exists.                               *
*                                                                          *
* Returns:                                                                 *
*   TRUE if font found, otherwise FALSE.                                   *
*                                                                          *
* History:                                                                 *
*  21-Apr-1993 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL MAPPER::bFindBitmapFont(PWSZ pwszFindFace)
{
    PFELINK     *ppfel;
    HASHBUCKET  *pbkt;
    FONTHASHTYPE fht;
    BOOL bRet = FALSE;


    // we need to fail at certain weights to insure Win 3.1 compatibility

    if( fl & FM_BIT_WEIGHT_NOT_FAST_BM )
    {
        return( FALSE );
    }

    // We are only going to check the family table.
    // This is a very specialized search, so if its
    // not there it shouldn't be anywhere!

    PUBLIC_PFTOBJ pfto;
    FHOBJ fho(&pfto.pPFT->pfhFamily);
    if (!fho.bValid())
    {
        return( bRet );
    }
    fht = fho.fht();

    pbkt = fho.pbktSearch(pwszFindFace,(UINT*)NULL);

    if (!pbkt)
    {
        FONTSUB* pfsub = pfsubAlternateFacename(pwszFindFace);

    // only check "old style substitutions"

        if (pfsub && (pfsub->fcsAltFace.fjFlags & FJ_NOTSPECIFIED))
        {
            pbkt = fho.pbktSearch((PWSZ)pfsub->fcsAltFace.awch,(UINT*)NULL);
        }
    }

    if (!pbkt)
    {
        return( bRet );
    }

    // Scan the PFE list for an exact height match.

    for (ppfel = pbkt->ppfelEnumHead; ppfel; ppfel = ppfel->ppfelNext)
    {
        PFEOBJ pfeo(ppfel->ppfe);
        IFIOBJ ifio(pfeo.pifi());

        if (ifio.bBitmap())
        {
            LONG lH;

            lH = (fl & FM_BIT_USE_EMHEIGHT) ?
                     (LONG) ifio.fwdUnitsPerEm() : ifio.lfHeight();
            if
            (
                lDevWishHeight == lH ||
                (      lDevWishHeight == WIN31_SMALL_WISH_HEIGHT
                    && lH == WIN31_SMALL_FONT_HEIGHT
                )
            )
            {
                if (lDevWishWidth == 0 || lDevWishWidth == ifio.lfWidth())
                {
                    return( TRUE );
                }
            }
        }
    }

    return( bRet );
}

/******************************Member*Function*****************************\
* BOOL MAPPER::bCalcOrientation()                                          *
*                                                                          *
* History:                                                                 *
*  Tue 23-Mar-1993 22:24:19 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL MAPPER::bCalcOrientation()
{
    INT s11,s12,s21,s22;

    if (fl & FM_BIT_GM_COMPATIBLE)
    {
        // Taken from bGetNtoD_Win31()

        iOrientationDevice = pelfwWish->elfEnumLogfontEx.elfLogFont.lfEscapement;
        if (iOrientationDevice != 0)
        {
            if ( (pdco->pdc->bWorldToPageIdentity()) &&
                 (!(pdco->pdc->bPageToDeviceScaleIdentity())) &&
                 (pdco->pdc->efM11().lSignum() !=
                  pdco->pdc->efM22().lSignum()) )
            {
                iOrientationDevice = -iOrientationDevice;
            }
        }
        fl |= FM_BIT_ORIENTATION;
        return( TRUE );
    }
    else if (pdco->pdc->bWorldToDeviceIdentity() || (fl & FM_BIT_PIXEL_COORD))
    {
        iOrientationDevice = pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation;
        fl |= FM_BIT_ORIENTATION;
        return( TRUE );
    }

    EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

    s11 = (INT) xo.efM11().lSignum();
    s12 = (INT) xo.efM12().lSignum();
    s21 = (INT) xo.efM21().lSignum();
    s22 = (INT) xo.efM22().lSignum();

    if (pdco->pdc->bYisUp())
    {
        s21 = -s21;
        s22 = -s22;
    }

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation % 900)
    {
        return( FALSE );
    }

    if
    (
          (s11 - s22)       // Signs on diagonal must match.
        | (s12 + s21)       // Signs off diagonal must be opposite.
        | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
    )
    {
        return( FALSE );
    }

    iOrientationDevice =
        pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation
        + (s12 &  900)
        + (s11 & 1800)
        + (s21 & 2700);

    if (iOrientationDevice >= 3600)
        iOrientationDevice -= 3600;

    fl |= FM_BIT_ORIENTATION;
    return( TRUE );
}

/******************************Member*Function*****************************\
* MAPPER::bCalculateWishCell                                               *
*                                                                          *
* Calculates either the 'ascent' vector or 'width' vector of the font      *
* in device space units. Then the equivalent 'height' and/or width         *
* is filled in the the MAPPER::elfWishDevice fields. The height and width  *
* are defined to be positive.                                              *
*                                                                          *
* Also computes the wished for orientation in device coordinates.          *
* This is needed whenever the cell is needed!                              *
*                                                                          *
* We use three flags which have the following meaning when set, and should *
* be used for no other purpose.                                            *
*                                                                          *
*   FM_BIT_CELL        Informs the world that bCalculateWishCell has       *
*                          been called in the past, and successfully       *
*                          transformed the height, width, and orientation  *
*                          to device space.   (OUTPUT)                     *
*                                                                          *
*   FM_BIT_BAD_WISH_CELL   A flag internal to this function to tell it     *
*                          that it has been called already and the         *
*                          calculation failed.  (INTERNAL)                 *
*                                                                          *
*   FM_BIT_HEIGHT          Informs this function that the height is        *
*                          already in device space.  (INPUT)               *
*                                                                          *
* History:                                                                 *
*  Fri 18-Dec-1992 02:51:39 -by- Charles Whitmer [chuckwh]                 *
* Rewrote.  Utilizing the assumption that it only gets called for raster   *
* fonts, I was able to delete hundreds of lines of complex code!           *
*                                                                          *
*  Mon 30-Dec-1991 14:35:22 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

LONG lNormAngle(LONG);

BOOL MAPPER::bCalculateWishCell()
{
    INT s11,s12,s21,s22;

    LONG lAngle = lNormAngle(pelfwWish->elfEnumLogfontEx.elfLogFont.lfOrientation);

    // If we've failed here before, it's no better now!

    if (fl & FM_BIT_BAD_WISH_CELL)
    {
        return( FALSE );
    }

    // Make sure we haven't been called before!

    ASSERTGDI
    (
        (fl & FM_BIT_CELL) == 0,
        "gdi!MAPPER::bCalculateWishCell: Useless call!\n"
    );

    // Handle the trivial case.

    if (pdco->pdc->bWorldToDeviceIdentity() || (fl & FM_BIT_PIXEL_COORD))
    {
        iOrientationDevice = lAngle;
        fl |= (FM_BIT_CELL | FM_BIT_HEIGHT | FM_BIT_WIDTH);
        return( TRUE );
    }

    // Locate our transform and examine the matrix.

    EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

    s11 = (INT) xo.efM11().lSignum();
    s12 = (INT) xo.efM12().lSignum();
    s21 = (INT) xo.efM21().lSignum();
    s22 = (INT) xo.efM22().lSignum();

    // Change to an equivalent transform where the y axis goes down.
    // We remove a sign change from the matrix components that hit y.

    if (pdco->pdc->bYisUp())
    {
        s21 = -s21;
        s22 = -s22;
    }

    // If we are in GM_ADVANCED mode, make sure the orientation and transform
    // are consistent with a bitmap font.  In GM_COMPATIBLE mode, just ignore
    // it all.  Note that iOrientationDevice remains undefined in GM_COMPATIBLE
    // mode.

    if (!(fl & FM_BIT_GM_COMPATIBLE) && !(fl & FM_BIT_ORIENTATION))
    {
        //  Reject random orientations.  Even under simple
        //  scaling transforms, they don't transform well.
        //  (Assuming we're mapping to a raster font.)

        if (lAngle % 900)
        {
          #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint(
                "\tMAPPER::bCalculateWishCell detected a bad orientation\n");
            }
          #endif
            fl |= FM_BIT_BAD_WISH_CELL;
            return( FALSE );
        }

        // Examine the transform to see if it's a simple multiple of 90
        // degrees rotation and perhaps some scaling.

        // Check for parity flipping transforms which are not allowed.
        // (That would require reflecting a bitmap, something we don't
        // consider likely.)  Also look for complex transforms.

        // If any of the terms we OR together are non-zero,
        // it's a bad transform.

        if (
            (s11 - s22)         // Signs on diagonal must match.
            | (s12 + s21)       // Signs off diagonal must be opposite.
            | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
           )
        {
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                DbgPrint("\tMAPPER::bCalculateWishCell "
                    "detected a bad trasform -- returning FALSE");
                DbgPrint("{%d,%d,%d,%d}\n",s11,s12,s21,s22);
            }
            #endif
            fl |= FM_BIT_BAD_WISH_CELL;
            return( FALSE );
        }

        // Since we've normalized to a space where (0 -1) represents
        // a vector with a 90 degree orientation (like MM_TEXT) note
        // that the matrix that rotates us by positive 90 degrees is:
        //
        //            [ 0 -1 ]
        //     (0 -1) [      ] = (-1 0)
        //            [ 1  0 ]
        //
        // I.e. the one with M  < 0.  Knowing this, the rest is easy!
        //                    12

        iOrientationDevice =
              lAngle
            + (s12 &  900)
            + (s11 & 1800)
            + (s21 & 2700);

        // Note that only the single 0xFFFFFFFF term contributes above.

        if (iOrientationDevice >= 3600)
            iOrientationDevice -= 3600;

        fl |= FM_BIT_ORIENTATION;
    }

    // Transform the height to device coordinates.

    if (!(fl & FM_BIT_HEIGHT))
    {
        // lDevWishHeight = lCvt(s22 ? xo.efM22() : xo.efM21(),lDevWishHeight);

        if (s22)
            lDevWishHeight = lCvt(xo.efM22(),lDevWishHeight);
        else
            lDevWishHeight = lCvt(xo.efM21(),lDevWishHeight);

        if (lDevWishHeight < 0)
            lDevWishHeight = -lDevWishHeight;
        lDevWishHeight = LONG_FLOOR_OF_FIX(lDevWishHeight + FIX_HALF);
    }

    // Transform the width to device coordinates.

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth && !(fl & FM_BIT_WIDTH))
    {
        // lDevWishWidth = lCvt(s11 ? xo.efM11() : xo.efM12(),lDevWishWidth);

        if (s11)
            lDevWishWidth = lCvt(xo.efM11(),lDevWishWidth);
        else
            lDevWishWidth = lCvt(xo.efM12(),lDevWishWidth);

        if (lDevWishWidth < 0)
            lDevWishWidth = -lDevWishWidth;
        lDevWishWidth = LONG_FLOOR_OF_FIX(lDevWishWidth + FIX_HALF);
    }
    fl |= (FM_BIT_CELL | FM_BIT_HEIGHT | FM_BIT_WIDTH);
    return( TRUE );
}

/******************************Member*Function*****************************\
* MAPPER::bNearMatch                                                       *
*                                                                          *
* History:                                                                 *
*  24-Sept-1196  -by-  Xudong Wu  [TesieW]                                 *
* Add checking on Private/Embedded fonts                                   *
*  Tue 28-Dec-1993 09:39:24 by Kirk Olynyk [kirko]                         *
* Changed the way msCheckFamily works for the case when the physical       *
* font has FF_DONTCARE for the family                                      *
*  Fri 18-Dec-1992 23:19:09 -by- Charles Whitmer [chuckwh]                 *
* Simplified a lot of stuff and then pulled all the routines in line.      *
* We were spending an extra 12 instructions per part checked by having     *
* them out of line, which adds up to about half the time in this routine!  *
*  Tue 10-Dec-1991 11:33:28 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

extern PW32PROCESS gpidSpool; // global


int MAPPER::bNearMatch(PFEOBJ &pfeo, BYTE *pjCharSet, BOOL bEmergency)
{
    int iRet = FALSE;       // return value
    ULONG ul;               // Temp variable.
    BYTE jAsk, jHav;
    PFE *ppfeNew = pfeo.ppfeGet();

    // Clear the per-font status bits

    fl &= ~(FM_BIT_NO_MAX_HEIGHT | FM_BIT_SYSTEM_FONT);

    if (pfeo.ppfeGet() == gppfeMapperDefault)
    {
        fl |= FM_BIT_SYSTEM_FONT;
    }

    ifio.vSet(pfeo.pifi());
    if (pfeo.bDead())
    {
        // The font is in a "ready to die" state.  That is, the engine is
        // ready to delete the font, but has had to delay it until all
        // outstanding references (via RFONTs) has disappeared.  Meanwhile,
        // we must not allow enumeration or mapping to this font.

        #if DBG
        if (gflFontDebug & DEBUG_MAPPER)
        {
            DbgPrint(
        "msCheckFont is returning FM_REJECT because pfeo.bDead() is true\n");
        }
        #endif

        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

    // private pfe NOT added by the current process.
    // spooler has the right to access all the fonts

    if (!pfeo.bEmbPvtOk() && (gpidSpool != (PW32PROCESS)W32GetCurrentProcess()))
    {
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

    // Skip the PFE_UFIMATCH fonts since they are added to the public font table temporarily
    // for remote printing. These PFEs should be mapped only by bFoundForcedMatch() calls.

    if (pfeo.bUFIMatchOnly())
    {
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

    // spooler has the right to access all the fonts

    if (pfeo.bPrivate() && (gpidSpool != (PW32PROCESS)W32GetCurrentProcess()))
    {
        // The font is embedded then it can only be seen if the call is
        // Win 3.1 compatible (i.e. called by ppfeGetAMatch), the
        // embedded bit is set in the caller's logical font, and the clients
        // PID or TID matches that embeded in the *.fot file.

        if (pfeo.bEmbedOk())
        {
            if (!(pelfwWish->elfEnumLogfontEx.elfLogFont.lfClipPrecision & CLIP_EMBEDDED))
            {
                #if DBG
                if (gflFontDebug & DEBUG_MAPPER)
                {
                    DbgPrint("msCheckFont is returning FM_REJECT\n");
                    DbgPrint("because the font is embedded\n\n");
                }
                #endif

                ulPenaltyTotal = FM_REJECT;
                return( iRet );
            }
        }
    }

    ulPenaltyTotal   = 0;

    // Assume be default that the font that is chosen will no have
    // any bold or italic simulations

    flSimulations    = 0;

    // Assume by default that if we happen to choose a bitmap font, there
    // will be no streching in either the height-direction or width-direction

    ptlSimulations.x = 1;
    ptlSimulations.y = 1;

    // At this point, the code used to have the following nice structure.  For
    // performance reasons, I pulled the code of each of these routines inline.
    // Even so, the functionality of each of the following sections should
    // remain clean and distinct.  [chuckwh]
    //
    //    if
    //    (
    //        (msCheckPitchAndFamily()) == MSTAT_NEAR &&
    //        (msCheckHeight()        ) == MSTAT_NEAR &&
    //        (msCheckAspect()        ) == MSTAT_NEAR &&
    //        (msCheckItalic()        ) == MSTAT_NEAR &&
    //        (msCheckWeight()        ) == MSTAT_NEAR &&
    //        (msCheckOutPrecision()  ) == MSTAT_NEAR &&
    //        (msCheckWidth()         ) == MSTAT_NEAR &&
    //        (msCheckOrientation(pfeo.iOrientation())) == MSTAT_NEAR
    //    )
    //    {
    //        return( MSTAT_NEAR );
    //    }
    //    return( MSTAT_FAR );

  MSBREAKPOINT("msCheckForMMFont");

    if ((fl & FM_BIT_BASENAME_MATCHED) && !(pfeo.pifi()->flInfo & FM_INFO_TECH_MM))
    {
        CHECKPRINT("CheckForMMFont", FM_REJECT );
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

// if glyph index font is required, but this font does not support it, reject it

  MSBREAKPOINT("msCheckForGlyphIndexFont");
    if (bIndexFont && !ppfeNew->pgiset)
    {
        CHECKPRINT("CheckForGlyphIndexFont", FM_REJECT );
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

  MSBREAKPOINT("msCheckPitch");
    {
        jHav = (BYTE) (ifio.lfPitchAndFamily() & LOGFONT_PITCH_SET);
        jAsk =
          (BYTE) (pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & LOGFONT_PITCH_SET);
        ul = 0;
        if (jAsk != DEFAULT_PITCH)
        {
            if (jAsk == FIXED_PITCH)
            {
                if (jHav & VARIABLE_PITCH)
                {
                    ul = FM_WEIGHT_PITCHFIXED;
                }
            }
            else if (!(jHav & VARIABLE_PITCH))
            {
                ul = FM_WEIGHT_PITCHVARIABLE;
            }
        }
        else if (jHav & FIXED_PITCH)
        {
            ul = FM_WEIGHT_DEFAULTPITCHFIXED;
        }
        if (ul)
        {
            CHECKPRINT("Pitch",ul);
            ulPenaltyTotal += ul;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckFamily");
    {
        jHav = (BYTE)(ifio.lfPitchAndFamily() & FF_SET);
        jAsk = (BYTE)(pelfwWish->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & FF_SET);
        if (jAsk == FF_DONTCARE)
        {
            if (jMapCharSet == SYMBOL_CHARSET)
            {
                // If the application asked for the symbol character set
                // and did not specify a family preference
                // then we should arrange it so that the choice of fonts
                // is family neutral so I set the asked for family
                // to be equal to the family of the current candidate
                // font.

                jAsk = (BYTE)(ifio.lfPitchAndFamily() & FF_SET);
            }
            else
            {
                // If the application did not specify a family preference
                // then we shall pick one for it. Normally we choose
                // Swiss except for the case where the application
                // asked for "Tms Rmn" where we ask for a Roman (serifed)
                // font.

                if (jHav != FF_DONTCARE)
                {
                    //  I have decide to excecute this family proxy
                    //  request only in the case where the font doesn't
                    //  have a family of FF_DONTCARE.  The reason for this
                    //  is interesting.  Consider the case where a font,
                    //  for what ever reason, chooses to have FF_DONTCARE
                    //  for the family.  Of course this is a bug but what
                    //  can we do.  Anyway, an application enumerates the
                    //  fonts and gets back a logical font with
                    //  FF_DONTCARE for the family.  Then suppose the
                    //  application takes that font and uses it to create
                    //  a font of its own (this is what the ChooseFont
                    //  common dialog box does all the time).  Then we
                    //  have the situation, where the logical font and the
                    //  intended font both have FF_DONTCARE for their
                    //  chosen family.  If the statement below where
                    //  excecuted, the family request would be changed to
                    //  something that does not match the physical font.
                    //  Trouble will occur if there is another font around
                    //  with the same face name or family name.  You may
                    //  not get the font you wanted because we have
                    //  erroneously added a family mismatch penalty.  (See
                    //  Bug #4912)
                    //
                    //  Tue 28-Dec-1993 09:38:29 by Kirk Olynyk [kirko]

                    jAsk = (BYTE)((fl & FM_BIT_TMS_RMN_REQUEST) ? FF_ROMAN : FF_SWISS);
                }
            }
        }
        if (jAsk != jHav)
        {
            ul = 0;
            if (jHav)
            {
                if
                (
                    // Win 3.1 dogma -- Are jAsk and jHav on opposite sides of
                    // the FF_MODERN barrier? if so, a familiy match
                    // isn't likely

                    ((jAsk <= FF_MODERN) && (jHav  > FF_MODERN)) ||
                    ((jAsk  > FF_MODERN) && (jHav <= FF_MODERN))
                )
                {
                    ul += FM_WEIGHT_FAMILYUNLIKELY;
                }
                ul += FM_WEIGHT_FAMILY;
            }
            else
            {
                ul = FM_WEIGHT_FAMILYUNKNOWN;
            }
            if (ul)
            {
                CHECKPRINT("Family",ul);
                ulPenaltyTotal += ul;
                if (bNoMatch(ppfeNew))
                {
                    return( iRet );
                }
            }
        }
    }

  MSBREAKPOINT("msCheckCharSet");

    {
        if( (jMapCharSet != DEFAULT_CHARSET) &&
            (!( fl & FM_BIT_MS_SHELL_DLG ) ))
        {
            *pjCharSet = jMapCharset(jMapCharSet, pfeo);

            if (jMapCharSet != *pjCharSet)
            {
                if( fl & FM_BIT_CHARSET_ACCEPT )
                {
                    CHECKPRINT("CharSet",FM_WEIGHT_CHARSET);
                    ulPenaltyTotal += FM_WEIGHT_CHARSET;
                    if (bNoMatch(ppfeNew))
                    {
                        return( iRet );
                    }
                }
                else
                {
                    CHECKPRINT("CharSet", FM_REJECT );
                    ulPenaltyTotal = FM_REJECT;
                    return( iRet );
                }
            }
        }
        else
        {
        // we still want to call jMapCharset, except, we do not want to give a
        // big weight to the charset, the app does not care. We still want to give
        // a small preference to the one that matches MAPPER::DefaultCharSet

            *pjCharSet = jMapCharset(jMapCharSet, pfeo);

            if ((jMapCharSet == DEFAULT_CHARSET) && !(fl & FM_BIT_MS_SHELL_DLG))
            {
                if (MAPPER::DefaultCharset != *pjCharSet)
                {
                    CHECKPRINT("CharSet",1);
                    ulPenaltyTotal += 2;
                    if (bNoMatch(ppfeNew))
                    {
                        return( iRet );
                    }
                }
            }
        }

    }

  MSBREAKPOINT("msCheckFamilyName");

    if (bEmergency)
    {
    // we only check facename in case we are in vEmergency() loop,
    // else, face name match is guaranteed.

        BOOL bAliasMatch;

        if (!pfeo.bCheckFamilyName(pwszFaceName,0, &bAliasMatch))
        {
        // no facename match, add penalty

            CHECKPRINT("FamilyName",FM_WEIGHT_FACENAME);
            ulPenaltyTotal += FM_WEIGHT_FACENAME;
        }
        else
        {
            if (bAliasMatch)
            {
            // add a small penalty for matching alias, not the real name

                CHECKPRINT("Alias Match",FM_WEIGHT_DEVICE_ALIAS);
                ulPenaltyTotal += FM_WEIGHT_DEVICE_ALIAS;
            }
        }

        if (bNoMatch(ppfeNew))
        {
            return( iRet );
        }
    }

  MSBREAKPOINT("msCheckVertAttr");
    {
    // If requested font is vertlcal face font, We have to map it to vertical
    // face font
        if ( fl & FM_BIT_VERT_FACE_REQUEST )
        {
            if ( *ifio.pwszFamilyName() != U_COMMERCIAL_AT )
            {
                CHECKPRINT("VertAttr",FM_REJECT);
                ulPenaltyTotal = FM_REJECT;
                return(iRet);
            }
        }
        else
        if (*ifio.pwszFamilyName() == U_COMMERCIAL_AT)
        {
        // if the user hasn't requested a @face font then don't map to one

            CHECKPRINT("VertAttr",FM_REJECT);
            ulPenaltyTotal = FM_REJECT;
            return(iRet);
        }
    }

    MSBREAKPOINT("msCheckHeight");
    if (!ifio.bContinuousScaling())
    {
        if (!(fl & FM_BIT_CELL) && !bCalculateWishCell())
        {
            // The transform is incompatible with a raster font.

            ulPenaltyTotal = FM_REJECT;
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER)
            {
                if (fl & FM_BIT_BAD_WISH_CELL)
                {
                    DbgPrint("\t\tFM_BIT_BAD_WISH_CELL\n");
                }
            }
            #endif
            CHECKPRINT("Height", FM_REJECT);
            return( iRet );
        }

        //    Raster fonts shall be used only in the case when
        //    the transformation from World to Device
        //    coordinates is a simple scale, and the orientation
        //    angle is along either the x or y-axis.
        //
        //    The physical height to compare against is either
        //    the cell height or em-height depending upon the
        //    sign of the LOGFONT::lfHeight field passed in by
        //    the application
        //
        //    differences of over a pixel are the only ones that
        //    count so, we count pixels instead of angstroms
        //
        //    Don't reject for the height penalty if the
        //    requested char set and physical font's char set
        //    are both symbol, or if the requested font is the
        //    system font since the system font is special.

        LONG
        lDevHeight =
            (fl & FM_BIT_USE_EMHEIGHT) ? ifio.fwdUnitsPerEm() : ifio.lfHeight();

        if  (
                lDevHeight < lDevWishHeight &&
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_HEIGHT_SCALING_CRITERIA(lDevWishHeight,lDevHeight)
            )
        {
            LONG lTemp = WIN31_BITMAP_HEIGHT_SCALING(lDevWishHeight,lDevHeight);

            ptlSimulations.y = min(WIN31_BITMAP_HEIGHT_SCALING_MAX,lTemp);
        }
        else
        {
            ptlSimulations.y = 1;
        }

        ul = 0;
        if (ptlSimulations.y > 1)
        {
            // Check to see if the height scaling is too gross according to
            // the Win31 criteria

            if (!(fl & FM_BIT_NO_MAX_HEIGHT))
            {
                if (WIN31_BITMAP_HEIGHT_SCALING_BAD(ptlSimulations.y,lDevHeight))
                {
                  #if DBG
                    // needed by CHECKPRINT macro
                    ulPenaltyTotal = FM_REJECT;
                  #endif
                    CHECKPRINT("Height (scaling too big)",FM_REJECT);
                    return( iRet );
                }
            }

            lDevHeight *= ptlSimulations.y;
            ul += (ULONG) ptlSimulations.y * FM_WEIGHT_INT_SIZE_SYNTH;

            // This next statement is found in the Win 3.1 code. Ours is not to
            // question why.

            ul |= (ULONG) (ptlSimulations.y-1)*WIN31_BITMAP_WIDTH_SCALING_MAX;
        }

        if (lDevWishHeight >= lDevHeight)
        {
            ul += FM_WEIGHT_HEIGHT * ((ULONG) (lDevWishHeight - lDevHeight));
        }
        else
        {
            //    Under Win 3.1 the only non-scalable device fonts
            //    we run into are those from the printer UniDriver.
            //    Unfortunately, this driver has a very different
            //    idea of how font mapping is done.  It allows the
            //    realized font to be one pel larger than the
            //    request with no penalty, but otherwise the penalty
            //    is fairly prohibitive.  I am not simulating that
            //    exactly here (since it would be impossible), but I
            //    do allow the off by one miss, and then impose a 20
            //    pel penalty.  I believe this will reduce by
            //    another order of magnitude the number of font
            //    mapping differences that remain.  [chuckwh]
            //    6/12/93.

            if
            (
              (fl & (FM_BIT_DEVICE_FONT+FM_BIT_GM_COMPATIBLE))
              == (FM_BIT_DEVICE_FONT+FM_BIT_GM_COMPATIBLE)
            )
            {
                if (lDevHeight - lDevWishHeight > 1)
                {
                  ul += FM_WEIGHT_HEIGHT *
                        (
                          (ULONG)
                          (
                           lDevHeight
                           - lDevWishHeight
                           + 5 * FM_PHYS_FONT_TOO_LARGE_FACTOR
                          )
                        );
                }
            }
            else
            {
                ul += FM_WEIGHT_HEIGHT *
                      (
                        (ULONG)
                        (
                         lDevHeight
                         - lDevWishHeight
                         + FM_PHYS_FONT_TOO_LARGE_FACTOR
                        )
                      );
            }
        }

        if (ul)
        {
            CHECKPRINT("Height",ul);
            ulPenaltyTotal += ul;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
            if
            (
                ul >= FM_WEIGHT_FACENAME                            &&
                !(fl & (FM_BIT_NO_MAX_HEIGHT | FM_BIT_SYSTEM_FONT))
            )
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckAspect");
    // 1. Check if aspect ratio filtering is turned on.
    // 2. Do not check aspect ratio if not raster.
    // 3. Win 3.1 says that the system font cannot be rejected
    //    on the basis of the aspect ratio test
    // 4. Win 3.1 style aspect ratio test.  In Win 3.1, the X and Y
    //    resolutions are checked, not the actual aspect ratio.
    // 5. [GilmanW] 10-Jun-1992
    //    For 100% Windows 3.1 compatibility we should not check the true
    //    aspect ratio.
    //
    //    But as KirkO says, lets leave it for now, as long as we comment
    //    it.  So, unless you are KirkO or GilmanW, please don't remove
    //    this comment.

    if
    (
            (pdco->pdc->flFontMapper() & ASPECT_FILTERING)
         && (ifio.lfOutPrecision() == OUT_RASTER_PRECIS)
         && !(fl & FM_BIT_SYSTEM_FONT)
         && (
             (ulLogPixelsX != (ULONG) ifio.pptlAspect()->x)
             || (ulLogPixelsY != (ULONG) ifio.pptlAspect()->y)
            )
         && (
             (ulLogPixelsX * (ULONG) ifio.pptlAspect()->y)
             != (ulLogPixelsY * (ULONG) ifio.pptlAspect()->x)
            )
    )
    {
        CHECKPRINT("Aspect", FM_REJECT);
        ulPenaltyTotal = FM_REJECT;
        return( iRet );
    }

  MSBREAKPOINT("msCheckItalic");
    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfItalic)
    {
        // if you get here then the application wants an italicized font
        // if the non simulated font is italicized already then
        // then the penalty is zero.

        if (!ifio.bNonSimItalic())
        {
            if (ifio.bSimItalic())
            {
                flSimulations |= FO_SIM_ITALIC;
                ul = FM_WEIGHT_ITALICSIM;
            }
            else
            {
                ul = FM_WEIGHT_ITALIC;
            }
            CHECKPRINT("Italic",ul);
            ulPenaltyTotal += ul;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }
    else
    {
        // The application doesn't want italicization,
        // the normal font is its best shot

        if (ifio.bNonSimItalic())
        {
            CHECKPRINT("Italic",FM_WEIGHT_ITALIC);
            ulPenaltyTotal += FM_WEIGHT_ITALIC;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckWeight");
    {
        LONG lPen;

        lPen  = ifio.lfNonSimWeight() - lWishWeight;

        if (fl & FM_BIT_FW_DONTCARE)
        {
            lPen = NT_FAST_DONTCARE_WEIGHT_PENALTY(ABS( lPen ));

            CHECKPRINT("Weight", (DWORD) lPen );
            ulPenaltyTotal += (DWORD) lPen;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
        else if (lPen != 0)
        {
            if (lPen < 0)
            {
               // non simulated font isn't bold enough -> try a simulation

                lPen = -lPen;

                if(  (WIN31_BITMAP_EMBOLDEN_CRITERIA(lPen)) &&
                     (ifio.pvSimBold() != NULL) )
                {
                    flSimulations |= FO_SIM_BOLD;
                    lPen -= FM_WEIGHT_SIMULATED_WEIGHT;
                }
            }

            lPen = NT_FAST_WEIGHT_PENALTY(lPen);

            CHECKPRINT("Weight",(DWORD) lPen );
            ulPenaltyTotal += (DWORD) lPen;
            if (bNoMatch(ppfeNew))
            {
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckOutPrecision");

    if (!(fl & FM_BIT_DEVICE_FONT))
    {
        // If the device is a plotter then it can't do bitmap fonts
        //
        // If you get to here we are considering the suitability of
        // a non-device font for the current device. The only case
        // where this could be a problem is if the font is a raster
        // font and the device cannot handle raster fonts.
        //
        // I have assume that a plotter can never handle a raster font.
        // Other than that the a raster font is rejected if the device
        // does not set the TC_RA_ABLE bit and the font does not tell
        // you to ignore the TC_RA_ABLE bit.

        // bodind:
        // we need to eliminate raster fonts on non square resolution printers
        // you can not get any type of wysiwig with these

        if (ifio.lfOutPrecision() == OUT_RASTER_PRECIS)
        {
            if
            (
                (fl & FM_BIT_DEVICE_PLOTTER) || (pdco->flGraphicsCaps() & GCAPS_NUP) ||
                !(((fl & FM_BIT_DEVICE_RA_ABLE) && (ulLogPixelsX == ulLogPixelsY)) 
                    || ifio.bIGNORE_TC_RA_ABLE())
            )
            {
                ulPenaltyTotal = FM_REJECT;
                CHECKPRINT("OutPrecision", FM_REJECT);
                return( iRet );
            }
        }

        // We also want to reject non-True Type fonts if the
        // msCheckOutPrecision has
        // been set to OUT_TT_ONLY_PRECIS.  [gerritv]

        if (
             (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision == OUT_TT_ONLY_PRECIS) &&
             (ifio.lfOutPrecision() != OUT_OUTLINE_PRECIS)
        )
        {
            ulPenaltyTotal = FM_REJECT;
            CHECKPRINT("OutPrecision: font isn't True Type", FM_REJECT);
            return( iRet );
        }

        // new value, reject non ps fonts

        if (
             (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision == OUT_PS_ONLY_PRECIS) &&
             !(ifio.pifi->flInfo & FM_INFO_TECH_TYPE1))
        {
            ulPenaltyTotal = FM_REJECT;
            CHECKPRINT("OutPrecision: font isn't PostScript font", FM_REJECT);
            return( iRet );
        }
    }

    // If OUT_TT_PRECIS is used,
    // the mapper gives the slight preference to screen outline font over the
    // device font, everything else being equal. The example of
    // this sitation is arial font, which exists as screen tt font
    // as well as pcl printer device font. If the lfCharSet = 0,
    // weight etc all match, using OUT_SCREEN_OUTLINE_PRECIS would allow applications
    // to choose arial screen (tt) font over arial device.
    // This is important because arial tt will typically have a larger
    // character set and the apps will want to take advantage of it.
    // The difference between this flag and OUT_TT_ONLY_PRECIS is
    // that the latter one forces outline font on screen but does not
    // give preference to outline font over device font on device.
    // Another example might be Helvetica Type 1 font, and screen version
    // may have more glyphs than the small Helvetica built
    // into pscript printers. This of course assumes atm driver installed.
    // Also, setting this flag would pick tt symbol over bitmap symbol.

    if (
         ((pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision == OUT_SCREEN_OUTLINE_PRECIS)
         // the following line will ensure that when user are not specifying lfOutPrecision, 
         // TrueType will be prefered when Lpk is installed. 
         // this will ensure correct font to be choosen in Arabic/Hebrew/Shaping printing
         // while still allowing application to specify exactely what lfOutPrecision they want
         // by selecting lfOutPrecision OUT_RASTER_PRECIS, OUT_DEVICE_PRECIS or OUT_PS_ONLY_PRECIS
            || ( EngLpkInstalled() && 
               (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision != OUT_RASTER_PRECIS) &&
               (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision != OUT_DEVICE_PRECIS) &&
               (pelfwWish->elfEnumLogfontEx.elfLogFont.lfOutPrecision != OUT_PS_ONLY_PRECIS))

        // gdi will map to tt, driver will do device font substitution when it
        // finds appropriate, i.e. when glyphs needed for printout exist
        // the device font that is being substituted

            || (pdco->flGraphicsCaps() & GCAPS_SCREENPRECISION)
         ) &&
         ((fl & FM_BIT_DEVICE_FONT) || (ifio.lfOutPrecision() != OUT_OUTLINE_PRECIS))
    )
    {
        CHECKPRINT("lfOutPrecision",(DWORD) FM_WEIGHT_FAVOR_TT);
        ulPenaltyTotal += FM_WEIGHT_FAVOR_TT;
        if (bNoMatch(ppfeNew))
        {
            return( iRet );
        }
    }

  MSBREAKPOINT("msCheckWidth");
    if (!ifio.bArbXforms() && !ifio.bAnisotropicScalingOnly())
    {
        // If the physical font is scalable. I make the bold assumption
        // that any width can be achieved through linear transformation.
        // This untrue but I will try to get away with this.
        //
        // [kirko] I believe that the correct thing to do is to compare
        // the ratio of the height to with of the request and compare it
        // with the ratio of the height to width of the font in design
        // space. Then assign a penalty based upon the difference.

        LONG lDevWidth = ifio.lfWidth();
        ptlSimulations.x = 1;

        if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth != 0)
        {
            if (!(fl & FM_BIT_CELL) && !bCalculateWishCell())
            {
                // The transform is incompatible with a raster font.

                ulPenaltyTotal = FM_REJECT;
                #if DBG
                if (gflFontDebug & DEBUG_MAPPER)
                {
                    if (fl & FM_BIT_BAD_WISH_CELL)
                    {
                        DbgPrint("\t\tFM_BIT_BAD_WISH_CELL\n");
                    }
                }
               #endif
                CHECKPRINT("Width", FM_REJECT);
                return( iRet );
            }

            if
            (
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_WIDTH_SCALING_CRITERIA(lDevWishWidth, lDevWidth)
            )
            {
               // set ptlSimulations.x

                LONG lTemp = WIN31_BITMAP_WIDTH_SCALING(lDevWishWidth,lDevWidth);

                ptlSimulations.x = min(WIN31_BITMAP_WIDTH_SCALING_MAX, lTemp);
            }
            else if (ifio.bIsotropicScalingOnly())
            {
                // For simple scaling fonts, the scaling is determined by the
                // ratio of the font space height to the device space height
                // request.

                ASSERTGDI(ifio.lfHeight(),"msCheckWidth finds lfHeight == 0\n");
                {
                    lDevWidth *= lDevWishHeight;
                    lDevWidth /= ifio.lfHeight();
                }
            }
            else
            {
                // nothing needs to be done
            }

            ul = 0;
            if (ptlSimulations.x > 1)
            {
                lDevWidth *= ptlSimulations.x;
                ul +=   (ULONG) ptlSimulations.x
                      * FM_WEIGHT_INT_SIZE_SYNTH;

                // Win 3.1 compatibility dictates the next statement

                ul |= (ULONG) (ptlSimulations.x - 1);

            }
            ul +=   FM_WEIGHT_FWIDTH
                  * (ULONG) ABS(lDevWishWidth - lDevWidth);

            if (ul)
            {
                CHECKPRINT("Width",ul);
                ulPenaltyTotal += ul;
                if (bNoMatch(ppfeNew))
                {
                    return( iRet );
                }
            }
        }
        else
        {
            // If you get to here then the application has specified a width
            // of zero.
            //
            // If the application asks for proof quality then no simulations
            // are allowed. No width penalty is assessed in the case where
            // the applicaition does not specify a width.

            if (ifio.bIntegralScaling() && !(fl & FM_BIT_PROOF_QUALITY))
            {
                // since no width has been specified we must do aspect
                // ratio matching Win 3.1 style [gerritv]

                ul = 0;
                ULONG ulDevAspect, ulFontAspect, ulFontAspectSave;

                // Since FontAspects and DevAspects will usually be one we will
                // introduce some fast cases to avoid extraneous multiplies and
                // divides

                BOOL bSpeedup = FALSE;

                if (ifio.pptlAspect()->x == ifio.pptlAspect()->y)
                {
                    if (ulLogPixelsX == ulLogPixelsY)
                    {
                        // this is the common case under which
                        // we can avoid many multiplies and divides.

                        bSpeedup = TRUE;
                    }

                }

                if (!bSpeedup)
                {
                    // this is taken straight from the Win 3.1 code

                    ulDevAspect = ( ulLogPixelsY * 100 ) / ulLogPixelsX;
                    ulFontAspectSave = ( ( ifio.pptlAspect()->x * 100 ) /
                                           ifio.pptlAspect()->y );
                    ulFontAspect = ulFontAspectSave / ptlSimulations.y;
                }

                if ((!bSpeedup) || (ptlSimulations.y != 1))
                {
                    if ( (bSpeedup) ||
                         WIN31_BITMAP_ASPECT_BASED_SCALING(ulDevAspect,ulFontAspect) )
                    {
                        // divide with rounding

                        if (bSpeedup)
                        {
                            ptlSimulations.x = ptlSimulations.y;
                        }
                        else
                        {
                            if( ulFontAspect == 0 )
                            {
                                ulPenaltyTotal = FM_REJECT;
                                return( iRet );
                            }
                            ptlSimulations.x = ulDevAspect / ulFontAspect;
                        }

                        // enforce maximum scalling factor

                        ptlSimulations.x =
                          min( WIN31_BITMAP_WIDTH_SCALING_MAX, ptlSimulations.x );

                        ul +=
                         WIN31_BITMAP_WIDTH_SCALING_PENALTY((ULONG)ptlSimulations.x);

                    }
                    else
                    {
                        ASSERTGDI(ptlSimulations.x == 1, "ptlSimulations.x != 1\n");
                    }

                    if
                    (
                        (!bSpeedup) || (ptlSimulations.x != ptlSimulations.y)
                    )
                    {
                        if( ptlSimulations.y == 0 )
                        {
                            ulPenaltyTotal = FM_REJECT;
                            return( iRet );
                        }
                        ulFontAspect = ulFontAspectSave *
                                       ptlSimulations.x / ptlSimulations.y;

                        ULONG ulTemp = (ULONG) ABS((LONG)(ulDevAspect - ulFontAspect));

                        ul += WIN31_BITMAP_ASPECT_MISMATCH_PENALTY( ulTemp );
                    }

                    if (ul)
                    {
                        CHECKPRINT("Width",ul);
                        ulPenaltyTotal += ul;
                        if (bNoMatch(ppfeNew))
                        {
                            return( iRet );
                        }
                    }
                }
                else
                {
                    // do nothing: no scaling means no penalty
                }
            }
        }
    }

  MSBREAKPOINT("msCheckScaling");
    if
    (
        (ptlSimulations.x > 1 || ptlSimulations.y > 1)
    )
    {
        // Following Win 3.1 we penalize if there is a scaling at all.  And there
        // is an additional penalty if the scaling of the height and width
        // directions are not the same.

        #if DBG
        ULONG ulTemp = ulPenaltyTotal;
        #endif

        // Penalize for scaling at all

        ulPenaltyTotal += FM_WEIGHT_SIZESYNTH;

        // Penalize even more if the scaling is anisotropic.
        // Win 3.1 uses the hard coded factor of 100 and so do we!

        if (ptlSimulations.x > ptlSimulations.y)
        {
            ulPenaltyTotal += (ULONG)
                FM_WEIGHT_FUNEVENSIZESYNTH * MULDIV(100, ptlSimulations.x, ptlSimulations.y);
        }
        else if ( ptlSimulations.x < ptlSimulations.y )
        {
            ulPenaltyTotal += (ULONG)
                FM_WEIGHT_FUNEVENSIZESYNTH * MULDIV(100, ptlSimulations.y, ptlSimulations.x);
        }

        CHECKPRINT("msCheckScaling",ulPenaltyTotal-ulTemp);
        if (bNoMatch(ppfeNew))
        {
            return( iRet );
        }
    }

  MSBREAKPOINT("msCheckOrientation");
    if (!ifio.bArbXforms())
    {
        // Either this matches or it doesn't. The penalty is either
        // maximally prohibitive or it is zero.
        //
        // Discussion:
        //
        // All vector fonts are assumed to be OK
        //
        // Raster Font are OK (1) The requested baseline
        // direction agrees with the direction of the raster
        // font (2) The transformation from world to device
        // coordinates is the combination of a scale and a
        // rotation by a multiple of 90 degrees.  This means
        // that we will reject if a reflection exists or if
        // there is shear.
        //
        // I shall make the assumption that raster fonts can be
        // used only in the case where the notional to device
        // transformation is a simple scale followed by a rotation
        // that is a multiple of 90 degrees.  This means that the
        // baseline in device space is along either the x-axis or
        // y-axis.  Moreover, the acender direction must be
        // perpendicular to the baseline.  There are a lot of
        // cases where this could happen.  For example, suppose
        // that the original orientation was alpha, and their was
        // a world to device transformation that was 90 degrees
        // minus alpha.  The resulting orientation would be along
        // one of the axes.  However, I will not check for such a
        // coincidence.  I will allow only cases where the
        // original orientation in world coordinates is a multiple
        // of 90 degrees, and the world to device transformation
        // is a simple combination of scales and rotations by 90
        // degrees.
        //
        // The orientation should have been computed when we
        // checked heights above.
        //
        // Under Win 3.1 we cannot reject a font because of orientation
        // mismatch if it the device is the screen

        if (!((fl & FM_BIT_GM_COMPATIBLE) && (fl & FM_BIT_DISPLAY_DC)))
        {
            ul = 1;

            if ((fl & FM_BIT_ORIENTATION) || bCalcOrientation())
            {
                ul = (ULONG) iOrientationDevice - pfeo.iOrientation();

                if (ul && (fl & FM_BIT_DEVICE_CR_90_ALL) && (fl & FM_BIT_DEVICE_FONT))
                {
                    if (ul > (ULONG) iOrientationDevice)
                    {
                        ul = (ULONG) (- (LONG) ul);
                    }
                    ul = ul % ORIENTATION_90_DEG;
                }

                if (ul && ifio.b90DegreeRotations())
                {
                    if (ul > (ULONG) iOrientationDevice)
                    {
                        ul = (ULONG) (- (LONG) ul);
                    }
                    ul = ul % ORIENTATION_90_DEG;
                }
            }
            if ( ul )
            {
                ulPenaltyTotal = FM_REJECT;
                CHECKPRINT("Orientation",FM_REJECT);
                return( iRet );
            }
        }
    }

  MSBREAKPOINT("msCheckAlias");
    {
        // Checks to see if the font is really an alias for a device font.
        //
        // Discussion:
        //
        // In the Win/WFW3.1 architecture, the device drivers get
        // a chance to do font mapping.  Some device drivers, like
        // the PostScript driver and the HP PCL drivers, allow
        // some of the device fonts to be aliased to other names.
        // For example, while the PostScript printer might
        // physically have a "Helvetica" font, the driver allows
        // "Helv", "Arial", and "Swiss" to be mapped to it (with
        // only a small penalty).  More precisely, "Helv" et.  al
        // are in the "Helvetica" equivalence class.
        //
        // We do not want such a font to be returned without error.
        // Otherwise, if we return this as an exact match, we will not
        // be able to map to REAL fonts that may exist in the engine.
        // For example, since "Arial" is in the equivalence class for
        // "Helvetica", without a penalty we may return "Helvetica" as
        // an exact match.  This shorts out the mapper before it can
        // get to the TrueType "Arial" that REALLY exists as an engine
        // font.  Therefore, we will impose a slight penalty for
        // aliased fonts.
        //
        //
        // If the FM_BIT_EQUIV_NAME bit is set, the font list we are
        // looking at is really an aliased font name for a device font.

        if (fl & FM_BIT_EQUIV_NAME)
        {
            ulPenaltyTotal += FM_WEIGHT_DEVICE_ALIAS;
            if ( bNoMatch(ppfeNew) )
            {
                return( iRet );
            }
        }
    }

// The last thing we do is always design vector.
// If everything else matchhes exactly but the design vector
// we will record the pfe and have the atm driver create the instance
// corresponding to this design vector.

  MSBREAKPOINT("msCheckDesignVector");

    {
        DESIGNVECTOR *pdv, *pdvWish;

        if (fl & FM_BIT_BASENAME_MATCHED)
        {
        // the name takes precedance, ie if we have explicit dv == [UU,VV]
        // as well as dv specified through font's family
        // name of the form foo_XX_YY, we ignore dv in ENUMLOGFONTEXDV
        // and use the one specified by the name, [XX,YY] in this case.

            pdvWish = &dvWish;
        }
        else
        {
            pdvWish = (DESIGNVECTOR *)&pelfwWish->elfDesignVector;
        }

        if (pdvWish->dvNumAxes)
        {
            pdv = ifio.pdvDesVect();

            if
            (
                pdv  && pdv->dvNumAxes                 &&
                (pdvWish->dvNumAxes == pdv->dvNumAxes) &&
                (ulPenaltyTotal <= 35000)
            )
            {
                ppfeMMInst = ppfeNew;
            }

            if
            (
                !pdv                                   ||
                (pdvWish->dvNumAxes != pdv->dvNumAxes) ||
                memcmp(pdvWish->dvValues, pdv->dvValues, pdv->dvNumAxes*sizeof(LONG))
            )
            {

                CHECKPRINT("DesignVector",FM_REJECT);
                ulPenaltyTotal = FM_REJECT;
                return(iRet);
            }


        }
    }

    // We are all done!

    return( TRUE );
}

/******************************Member*Function*****************************\
* IFIOBJ::lfOrientation                                                    *
*                                                                          *
* Returns the Orientation (angle of the baseline in tenths of degrees      *
* measured counter clockwise from the x-axis) in device space.             *
*                                                                          *
* History:                                                                 *
*  Thu 17-Dec-1992 16:22:56 -by- Charles Whitmer [chuckwh]                 *
* Changed the easy case to wierd bit manipulation.                         *
*                                                                          *
*  Tue 24-Sep-1991 10:54:24 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

LONG IFIOBJ::lfOrientation()
{
    INT sx = SIGNUM(pifi->ptlBaseline.x);
    INT sy = SIGNUM(pifi->ptlBaseline.y);

    if ((sx^sy)&1)      // I.e. if exactly one of them is zero...
    {
    // Return the following angles:
    //
    //   sx = 00000001 :    0
    //   sy = 00000001 :  900
    //   sx = FFFFFFFF : 1800
    //   sy = FFFFFFFF : 2700

        return( (sx & 1800) | (sy & 2700) | ((-sy) & 900) );
    }

   // Do the hard case.

    LONG lDummy;

    EFLOATEXT efltX(pifi->ptlBaseline.x);
    EFLOATEXT efltY(pifi->ptlBaseline.y);

    EFLOAT efltTheta;
    vArctan(efltX, efltY, efltTheta, lDummy);

    *(EFLOATEXT*) &efltTheta *= (LONG) 10;

    return( efltTheta.bEfToL(lDummy) ? lDummy : 0 );
}

/******************************Public*Routine******************************\
* MAPPER::bFoundExactMatch()                                               *
*                                                                          *
* This routine searches for a match to an extended logical font.           *
* It is assumed that the face name has infinite weight. Therefore          *
* the face name is searched for in the hash table that is provided by      *
* the caller. If the name is found, then the best match is searched for    *
* among the elements of the linked list of PFE's containing the same       *
* face name.                                                               *
*                                                                          *
* If the name is found, then the MAPFONT_FOUND_NAME flag is set in         *
* pflAboutMatch.  If the name was found by using facename substitution     *
* (ie., alternate facename), then the MAPFONT_ALTNAME_USED flag is also    *
* set.                                                                     *
*                                                                          *
* The return value of the function report whether the match was exact.     *
* This information is actually redundant. It could be retrived by          *
* looking at mapper.ulPenaltyTotal                                         *
*                                                                          *
* Important Operating Principles                                           *
*                                                                          *
*   1. The value pointed to pppfeRet is modified only if i) an the name    *
*      is matched, and ii) the match is better than any found previously   *
*                                                                          *
* History:                                                                 *
*  Fri 18-Dec-1992 04:57:29 -by- Charles Whitmer [chuckwh]                 *
* Rewrote it for performance.  One major change is that I only take the    *
* winning PFE and move it to the front of the list, rather than            *
* continually shuffling the list.  This cuts down overhead and should      *
* have about the same effect.                                              *
*                                                                          *
*  Wed 22-Apr-1992 10:47:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/


BOOL
MAPPER::bFoundExactMatch(
    FONTHASH **ppfh
    )
{
    PFELINK *ppfelBest = NULL, *ppfel;

    HASHBUCKET  *apbkt[3];
    BYTE         ajCharSet[3];

    FONTHASHTYPE fht;
    int i,iBest;
    BOOL bRet = FALSE;
    BYTE jCharSet = DEFAULT_CHARSET;

    // This is returned as the *pflAboutMatch in the MAPPER class if and only
    // if we find a better match.  So we store it temporarily in this local
    // rather than set it directly.

    *pflAboutMatch &= ~MAPFONT_FOUND_NAME;

    FHOBJ fho(ppfh);
    if (!fho.bValid())
    {
        return( bRet );
    }
    fht = fho.fht();

    // Note well: mapper.pwszFaceName must ALWAYS be CAPITALIZED!

    const WCHAR * pwszTarg = this->pwszFaceName;

    // Attempt to locate the name.

#define I_ORIGINAL  0
#define I_ALTERNATE 1
#define I_BASE 2

    apbkt[I_ORIGINAL] = apbkt[I_ALTERNATE] = apbkt[I_BASE] = NULL;
    ajCharSet[I_ORIGINAL]  =
    ajCharSet[I_BASE] =
    ajCharSet[I_ALTERNATE] = (BYTE)pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet;

    FONTSUB* pfsub = pfsubGetFontSub(pwszTarg,
                       (BYTE)pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet);

    if (pfsub)
    {
    // charsets specified or not in the substitution entry ?

        if (pfsub->fcsAltFace.fjFlags & FJ_NOTSPECIFIED)
        {
        // old style substitution, no charsets are specified
        // First search for the facename on the left hand side,
        // if not found search for the one on the right hand side.
        // In both cases use the original charset in the logfont.

            apbkt[I_ORIGINAL] = fho.pbktSearch(pwszTarg,(UINT*)NULL);
            apbkt[I_ALTERNATE] = fho.pbktSearch((PWSZ)pfsub->fcsAltFace.awch,(UINT*)NULL);
        }
        else
        {
        // charsets are specified in the font substitution entry.

        // When the charset requested in the logfont matches the one on
        // the left hand side of the substitution, we shall actually go
        // for the alternate facename and charset, without even looking
        // if the font with facename and charset specified on the left
        // hand side is installed on the system.
        // This is win95 behavior which actually makes some sense.

            apbkt[I_ALTERNATE] = fho.pbktSearch((PWSZ)pfsub->fcsAltFace.awch,(UINT*)NULL);
            ajCharSet[I_ALTERNATE] = pfsub->fcsAltFace.jCharSet;
        }
    }
    else
    {
        apbkt[I_ORIGINAL] = fho.pbktSearch(pwszTarg,(UINT*)NULL);
    }

// now search for the bucket corresponding to the cannonical name if any
// We will only do this for FAMILY i.e menu names, not for face names:

    if (awcBaseName[0] && (fht == FHT_FAMILY))
        apbkt[I_BASE] = fho.pbktSearch(this->awcBaseName,(UINT*)NULL, NULL, FALSE);

    if (!apbkt[I_ORIGINAL] && !apbkt[I_ALTERNATE] && !apbkt[I_BASE])
    {
        return( bRet );
    }

    // If we get to here,  we were able to find a hash bucket
    // of the correct name.

    *pflAboutMatch |= MAPFONT_FOUND_NAME;
    fl |= FM_BIT_FACENAME_MATCHED;

    // Scan the PFE list for the best match.

    for (i = 0; i < 3; i++)
    {
        if (!apbkt[i])
        {
            continue;
        }

        vResetCharSet(ajCharSet[i]);

        if (apbkt[i]->fl & HB_EQUIV_FAMILY)
        {
            fl |= FM_BIT_EQUIV_NAME;
        }
        else
        {
            fl &= ~FM_BIT_EQUIV_NAME;
        }

        if (i == I_BASE)
        {
            fl |= FM_BIT_BASENAME_MATCHED;
        }
        else
        {
            fl &= ~FM_BIT_BASENAME_MATCHED;
        }

        for
        (
            ppfelBest = NULL, ppfel = apbkt[i]->ppfelEnumHead;
            ppfel;
            ppfel = ppfel->ppfelNext
        )
        {
            #if DBG
            if (gflFontDebug & DEBUG_MAPPER && ppfel->ppfe == ppfeBreak)
            {
                DbgPrint("    **** breaking on ppfel = %-#8lx\n\n", ppfel);
                DbgBreakPoint();
            }
            #endif

            PFEOBJ pfeo(ppfel->ppfe);

            if (this->bNearMatch(pfeo,&jCharSet))
            {
                DUMP_CHOSEN_FONT(pfeo);
                iBest     = i;

                // remember the good one

                ppfelBest = ppfel;

                // remember the simulation information for the best font
                // choice to this time

                vSetBest(ppfel->ppfe, fl & FM_BIT_DEVICE_FONT, jCharSet);

                if (this->ulPenaltyTotal == 0)
                {
                    //  If the match was exact, return immediately unless
                    //  there this is a true type font and there are
                    //  rasterfonts of the same face name.  In this case
                    //  we must give the rasterfonts a chance since in the
                    //  event of a tie, the raster font must win to be Win
                    //  3.1 compatibile!

                    if( !( apbkt[i]->cRaster ) ||
                              ( pfeo.flFontType() & RASTER_FONTTYPE ))
                    {
                        bRet = TRUE;
                        break;
                    }

                    // we need to give the raster fonts a chance we do this
                    // by setting ulPenaltyTotal to 1.
                    // This way only an exact match will beat us out.

                    this->ulPenaltyTotal = 1;
                }

                // prune the search

                this->ulMaxPenalty = this->ulPenaltyTotal;
            }
            else
            {
                DUMP_REJECTED_FONT(pfeo);
            }

        }
        if (bRet == TRUE)
        {
            break;
        }
    }
    // Return a good one if we found it.

    if (ppfelBest)
    {
        // We found a better match, so better change the about flags.

        if (iBest == I_ALTERNATE || fht == FHT_FACE)
        {
            *pflAboutMatch |= MAPFONT_ALTFACE_USED;
        }

        //  record code page, needed for correct code page to
        //  unicode translation In case of single charset
        //  font, we always cheat and represent the font
        //  glyphset using ansi to unicode conversion using
        //  the current ansi code page, even though the
        //  underlining font may contain a symbol or an oem
        //  code page.  But we do not care, we just need to
        //  make the round trip a->u->a works for these fonts.
        //  Also we want the client side cacheing of char
        //  widths for GTE and GCW to work for these fonts.
    // there are two exceptions to this rule: 1) the default ansi code page is
    // not SBCS since this doesn't guarantee roundtrupe conversion and
    // 2) the charset of the font is DBCS

        ULONG ulCodePage;

    // the best charset so far is remembered in pflAboutMatch

        BYTE  jBestCharSet = (BYTE)(*pflAboutMatch >> 24);

        if
        (
            (jBestCharSet != OEM_CHARSET)             ||
            ppfelBest->ppfe->pifi->dpCharSets         ||
            (ppfelBest->ppfe->flPFE & PFE_DEVICEFONT) ||
            IS_ANY_DBCS_CHARSET(jBestCharSet)
        )
        {
            ulCodePage = ulCharsetToCodePage(jBestCharSet);
        }
        else
        {
        // just use 1252 if the default CP is not SBCS

            ulCodePage = (gbDBCSCodePage) ? 1252 : CP_ACP;
        }
        *pflAboutMatch |= (ulCodePage << 8);
    }
    fl &= ~FM_BIT_EQUIV_NAME;
    return( bRet );
}



/****************************************************************************
* MAPPER::bFoundForcedMatch( PUNIVERSAL_FONT_ID pufi )
*
* This routine forces mapping to a PFE identified by a UFI.  It will compute
* simulations to be performed on the font as well.

*  History:
*   Oct-21-97   by Xudong Wu  [tessiew]
*  Disable the ufi matching for device fonts
*   5/11/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/


BOOL MAPPER::bFoundForcedMatch(UNIVERSAL_FONT_ID *pufi)
{
    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("MAPPER::bFoundForcedMatch: " );
        DbgPrint("CheckSum = %x Index = %d\n", pufi->CheckSum, pufi->Index );
    }
    #endif
    PFE *ppfe;

    // for device font, the ufi on the print server side
    // might not match the one on the client side
    // so we don't use the ufi-match on device fonts any more

    if(UFI_DEVICE_FONT(pufi))
    {
        ppfe = NULL;
    }
    else if(UFI_TYPE1_FONT(pufi))
    {
        DEVICE_PFTOBJ pftoDevice;
        FONTHASH **ppfh = (FONTHASH**) NULL;
        PFF *pPFF;

        if (pPFF = pftoDevice.pPFFGet(pdco->hdev()))
        {
            PFFOBJ pffo(pPFF);

            if (pffo.bValid())
            {
                ppfh = &pffo.pPFF->pfhFamily;
            }
        }

        if (ppfh == (FONTHASH**) NULL)
        {
            WARNING1("MAPPER::bFoundForcedMatch() -- invalid FONTHASH\n");
            return( FALSE );
        }

        // Prepare to enumerate through all the device fonts

        ENUMFHOBJ fho(ppfh);
        for (ppfe = fho.ppfeFirst(); ppfe; ppfe = fho.ppfeNext())
        {
            PFEOBJ pfeo(ppfe);

            if (UFI_SAME_FACE(pfeo.pUFI(), pufi))
            {
                if( pfeo.bDead() )
                {
                    WARNING("MAPPER::bFoundForcedMatch mapped to dead PFE\n");
                }
                else
                {
                    break;
                }
            }
        }
    }
    else
    {
        ppfe = ppfeGetPFEFromUFI(pufi,
                                 FALSE, // public font table
                                 TRUE); // check process

    }

    if ( ppfe == NULL )
    {
        WARNING1("MAPPER::bFoundForcedMatch unable to find forced match\n");
        return( FALSE );
    }

    // If we are here we found the right PFE,
    // now we need to compute ptlSim and flSim.

    ptlSimulations.x = 1;
    ptlSimulations.y = 1;
    flSimulations = 0;

    PFEOBJ pfeo(ppfe);

    ifio.vSet( pfeo.pifi() );

    // first compute any possible height simulations

    if (!ifio.bContinuousScaling())
    {
        LONG
        lDevHeight =
            (fl & FM_BIT_USE_EMHEIGHT) ? ifio.fwdUnitsPerEm() : ifio.lfHeight();
        if  (
                lDevHeight < lDevWishHeight &&
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_HEIGHT_SCALING_CRITERIA(lDevWishHeight,lDevHeight)
            )
        {
            LONG lTemp = WIN31_BITMAP_HEIGHT_SCALING(lDevWishHeight,lDevHeight);

            ptlSimulations.y = min(WIN31_BITMAP_HEIGHT_SCALING_MAX,lTemp);
        }
        else
        {
            ptlSimulations.y = 1;
        }
    }

    // next check for italic simulations

    if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfItalic)
    {
    // if you get here then the application wants an italicized font

        if (!ifio.bNonSimItalic() && ifio.bSimItalic())
        {
            flSimulations |= FO_SIM_ITALIC;
        }
    }

    // bold simulations

    LONG lPen;

    lPen = ifio.lfNonSimWeight() - lWishWeight;

    if( !(fl & FM_BIT_FW_DONTCARE) && (lPen < 0 ) )
    {

         // non simulated font isn't bold enough -> try a simulation

        lPen = -lPen;

        if(  (WIN31_BITMAP_EMBOLDEN_CRITERIA(lPen)) &&
             (ifio.pvSimBold() != NULL) )
        {
            flSimulations |= FO_SIM_BOLD;
        }
    }

    // width simulations

    if (!ifio.bArbXforms() && !ifio.bAnisotropicScalingOnly())
    {
        LONG lDevWidth = ifio.lfWidth();
        ptlSimulations.x = 1;

        if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfWidth != 0)
        {
            if( !(fl & FM_BIT_CELL) )
            {
                bCalculateWishCell();
            }

            if
            (
                ifio.bIntegralScaling() &&
                !(fl & FM_BIT_PROOF_QUALITY) &&
                WIN31_BITMAP_WIDTH_SCALING_CRITERIA(lDevWishWidth, lDevWidth)
            )
            {
               // set ptlSimulations.x

                LONG lTemp = WIN31_BITMAP_WIDTH_SCALING(lDevWishWidth,lDevWidth);

                ptlSimulations.x = min(WIN31_BITMAP_WIDTH_SCALING_MAX, lTemp);
            }
        }
        else
        {
            if (ifio.bIntegralScaling() && !(fl & FM_BIT_PROOF_QUALITY))
            {
                // since no width has been specified we must do aspect
                // ratio matching Win 3.1 style [gerritv]

                ULONG ulDevAspect, ulFontAspect, ulFontAspectSave;

                // Since FontAspects and DevAspects will usually be one we will
                // introduce some fast cases to avoid extraneous multiplies and
                // divides

                BOOL bSpeedup = FALSE;

                if (ifio.pptlAspect()->x == ifio.pptlAspect()->y)
                {
                    if (ulLogPixelsX == ulLogPixelsY)
                    {
                        // this is the common case under which
                        // we can avoid many multiplies and divides.

                        bSpeedup = TRUE;
                    }
                }

                if (!bSpeedup)
                {
                    // this is taken straight from the Win 3.1 code

                    ulDevAspect = ( ulLogPixelsY * 100 ) / ulLogPixelsX;

                    ulFontAspectSave = ( ( ifio.pptlAspect()->x * 100 ) /
                                           ifio.pptlAspect()->y );

                    ulFontAspect = ulFontAspectSave / ptlSimulations.y;
                }

                if ((!bSpeedup) || (ptlSimulations.y != 1))
                {
                    if
                    (
                         (bSpeedup) ||
                         WIN31_BITMAP_ASPECT_BASED_SCALING(ulDevAspect,ulFontAspect)
                    )
                    {
                        // divide with rounding

                        if (bSpeedup)
                        {
                            ptlSimulations.x = ptlSimulations.y;
                        }
                        else
                        {
			    if (ulFontAspect == 0)
			    {
				WARNING1("MAPPER::bFoundForcedMatch "
				    "ulFontAspect == 0\n");
				return( FALSE );
			    }
                            ptlSimulations.x = ulDevAspect / ulFontAspect;
                        }

                        // enforce maximum scalling factor

                        ptlSimulations.x =
                          min( WIN31_BITMAP_WIDTH_SCALING_MAX, ptlSimulations.x );
                    }
                    else
                    {
                        ASSERTGDI(ptlSimulations.x == 1, "ptlSimulations.x != 1\n");
                    }
                }
            }
        }
    }

// need to do this here because vSetBest will update ptlSim and pflSim
// Another important point to note here is that the charset and code page
// needed for ansi to unicode conversion will remain uninitialized.
// I think that this is ok because for metafile spooled printing the text is
// always going to recorded as unicode so that this conversion will never
// have to be performed [bodind]

    vSetBest( ppfe, TRUE, DEFAULT_CHARSET );

    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("MAPPER::bFoundForcedMatch: ppfeBest = %-#x\n", ppfeBest );
    }
    #endif
    return( TRUE );
}



/******************************Public*Routine******************************\
* ppfeGetAMatch                                                            *
*                                                                          *
* Returns the best fit to a wish defined by the application.               *
*                                                                          *
* History:                                                                 *
*  Wed 11-Dec-1991 09:32:11 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

PFE *ppfeGetAMatch (
    XDCOBJ&        dco,         // The DC defines all the relevant
                                // transformations and physical
                                // sizes to be used to determine
                                // the suitablity of a font

    ENUMLOGFONTEXDVW  *pelfwWishSrc,  // defines the font that is wished
                                // for by the application

    const WCHAR * pwszFaceName,         // The sought name.

    ULONG ulMaxPenalty,         // a cutoff for the sum of all the
                                // individual penalties of each of the
                                // fields of the LOGFONT structure.
                                // If the sum of all the penalties
                                // associated with a physical font
                                // is greater than this cutoff, then
                                // the phyisical font is rejected
                                // as a potential match.

    FLONG fl,                   // This is a set of flags defining
                                // how mapping is to proceed and/or
                                // various parameters are to be
                                // interpreted. The flags that are
                                // supported are:
                                //
                                // FM_BIT_PIXEL_COORD
                                //
                                //  If this flag is not present, then the
                                //  dimensionful quantities in the
                                //  logical font are in world coordinates.
                                //  If this flag is present then the
                                //  dimensionful (length like) quantities
                                //  in the logical font are in pixel
                                //  coordinates (one unit = one pixel).
                                //  This bit is set only for stock
                                //  fonts, which are defined by the device
                                //  driver and are to be transformation
                                //  independent.

    FLONG *pflSim,              // a place to put the simulation
                                // flags.

    POINTL *pptlSim,            // this recieves the height- and width-
                                // scaling factor for bitmap fonts

    FLONG *pflAboutMatch,       // This returns information about how
                                // the match was achieved.  Flags
                                // supported are:
                                //
                                // MAPFONT_FOUND_NAME
                                //
                                //  This flag indicates that a facename
                                //  was found by the mapper.
                                //
                                // MAPFONT_ALTFACE_USED
                                //
                                //  This flag indicates that the facename
                                //  found was an alternate or substitute
                                //  facename.
    BOOL   bIndexFont_          //  font MUST support ETO_GLYPH_INDEX
)
{
    ASSERTGDI(!(fl & ~FM_BIT_PIXEL_COORD),"GDISRV!ppfeGetAMatch -- invalid fl\n");

    PPFEGETAMATCH_DEBUG_MACRO_1;

    MAPPER
        mapper(
            &dco
          , pflSim
          , pptlSim
          , pflAboutMatch
          , pelfwWishSrc
          , pwszFaceName
          , ulMaxPenalty
          , bIndexFont_
          , fl
            );

    // Currently there is no way for the MAPPER constructor
    // to fail.  In the future it may be able to fail and we
    // will need to check here.

    ASSERTGDI(mapper.bValid(),"GDISRV!ppfeGetAMatch -- invalid mapper\n");

    #if DBG
    if (gflFontDebug & DEBUG_DUMP_FHOBJ)
    {
        if (mapper.bDeviceFontsExist())
        {
            DEVICE_PFTOBJ pftoDevice;
            PFFOBJ pffo(pftoDevice.pPFFGet(dco.pdc->hdev()));
            if (pffo.bValid())
            {
                FHOBJ fhoFamily(&pffo.pPFF->pfhFamily);
                FHOBJ fhoFace(&pffo.pPFF->pfhFace);

                DbgPrint("\n\n\tDumping Device Family Names\n");
                fhoFamily.vPrint((VPRINT) DbgPrint);

                DbgPrint("\n\n\tDumping Device Face Names\n");
                fhoFace.vPrint((VPRINT) DbgPrint);
            }
        }
        else
        {
            DbgPrint("\n\tTHERE ARE NO DEVICE FONTS!\n\n");
        }
        PUBLIC_PFTOBJ pfto;
        FHOBJ fhoFamily(&pfto.pPFT->pfhFamily);
        FHOBJ fhoFace(&pfto.pPFT->pfhFace);

        DbgPrint("\n\n\tDumping Engine Family Names\n");
        fhoFamily.vPrint((VPRINT) DbgPrint);
        DbgPrint("\n\n\tDumping Engine Face   Names\n");
        fhoFace.vPrint((VPRINT) DbgPrint);
    }
    #endif

    UNIVERSAL_FONT_ID ufi;
    if( dco.pdc->bForcedMapping( &ufi ) )
    {
        // If we got here we are playing back an EMF spoolfile
        // which was generated on a remote machine.  We must do
        // forced mapping based on UFI's

        if( mapper.bFoundForcedMatch(&ufi) )
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
        else
        {
            WARNING1("ppfeGetAMatch: bFoundForceMatch "
                     "failed to find a match");
        }
    }

    // check the Private PFT before device and public PFT if gpPFTPrivate != NULL
    // We do not want to go through small font hack for private fonts.

    if (gpPFTPrivate && gpPFTPrivate->cFiles)
    {
        PUBLIC_PFTOBJ pftoPrivate(gpPFTPrivate);
        mapper.vNotDeviceFonts();   // put mapper in "check engine fonts" state

        if
        (
             mapper.bFoundExactMatch(&pftoPrivate.pPFT->pfhFamily) ||
             mapper.bFoundExactMatch(&pftoPrivate.pPFT->pfhFace)
        )
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
    }

    // check the device fonts first (if they exist)

    DEVICE_PFTOBJ pftoDevice;
    if (mapper.bDeviceFontsExist())
    {
        PFF *pPFF;

        // put mapper in "check device fonts" state

        mapper.vDeviceFonts();

        if (pPFF = pftoDevice.pPFFGet(dco.hdev()))
        {
            PFFOBJ pffo(pPFF);
            if (pffo.bValid())
            {
                if
                (
                    mapper.bFoundExactMatch(&pffo.pPFF->pfhFamily) ||
                    mapper.bFoundExactMatch(&pffo.pPFF->pfhFace)
                )
                {
                    PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
                }
            }
            if( mapper.bDeviceOnly() )
            {
                //
                // If the device insists that we use only its fonts then
                // we will do so. If the application requested a device
                // font then we will map to that font and that font
                // is contained in mapper.ppfeRet(). Otherwise, if the
                // application asked for a face name that is not contained
                // in the list of device fonts, then the current value
                // of mapper.ppfeRet() will be NULL. In that case we
                // will simply map to an arbitrary device font without
                // regard to the size requested by the application.
                // Caveat Emptor.
                //

                PFE *ppfeRet;

                ppfeRet = mapper.ppfeRet();

                if (ppfeRet == 0 || ppfeRet->pPFF != pPFF)
                {
                    *pflSim = 0;
                    *pflAboutMatch = 0;
                    pptlSim->x = pptlSim->y = 1;

                    FONTHASH **ppfh = &pffo.pPFF->pfhFamily;
                    ENUMFHOBJ fho(ppfh);
                    ppfeRet = fho.ppfeFirst();
                }

                PPFEGETAMATCH_DEBUG_RETURN( ppfeRet );
            }
        }
    }

    // If an exact match was not found check the Engine fonts

    PUBLIC_PFTOBJ pftoPublic;
    mapper.vNotDeviceFonts();   // put mapper in "check engine fonts" state
    if
    (
         mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFamily) ||
         mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFace)
    )
    {
        PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
    }

    // If you get here, and ppfeRet != 0 then then lfFaceName
    // has been matched by either the device or gdi.  In either
    // case, we terminate the search and return the best match
    // found.  This is somewhat incompatible with Windows 3.1
    // which considers FaceName less important that pitch
    // and family.  Windows 3.1 would continue the search over
    // all available fonts in order to get a better match.

    if (mapper.ppfeRet())
    {
        PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
    }

    // At this point we know that no exact match will be found
    // amongst the fonts installed on the system at this time.
    // We shall therefore try to see if this was a request for mm instance
    // for an mm font whose other instance is installed and create the
    // requested instance dynamically.
    // In the future we may exted this function to go out and search for the
    // font that has not been addfontresource'ed at this time
    // (perhaps by calling to font drivers, or maybe not)
    // and install it dynamically.

    PFE *ppfeRet = mapper.ppfeSynthesizeAMatch(pflSim, pflAboutMatch, pptlSim);

    if (ppfeRet)
    {
        PPFEGETAMATCH_DEBUG_RETURN(ppfeRet);
    }

    // If you get to here then the face name has not been found
    // in either the Device or GDI fonts. A font of a different
    // face name will have to be substituted. Try to match to a
    // Device font, but the match better be a good one!

    if (!(dco.flGraphicsCaps() & GCAPS_SCREENPRECISION))
    {
        if (mapper.bDeviceFontsExist())
        {
            mapper.vAttemptDeviceMatch();
            if (mapper.ppfeRet())
            {
                PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
            }
        }
    }
    // Well ... we are left with attempting to match to GDI fonts.
    // Since the original request face name was a flop,
    // I will attempt a suitable GDI FaceName.

    if( !(mapper.bCalled_bGetFaceName()))
    {
        #if DBG
        if (gflFontDebug & DEBUG_MAPPER)
            DbgPrint("\n\tAttempting to match to an"
                 " engine font of a different name\n");
        #endif
        mapper.bGetFaceName();
        mapper.vReset();
        mapper.vNotDeviceFonts();   // put mapper in "check engine fonts" state
        if
        (
            mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFamily) ||
            mapper.bFoundExactMatch(&pftoPublic.pPFT->pfhFace)
        )
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
        if (mapper.ppfeRet())
        {
            PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
        }
    }

    // Up until now we've reject fonts whose charset doesn't
    // match the requested charset even though the facename
    // matches.  At this point we allow for the possibility
    // of chosing a font whose charset doesn't match.  However,
    // we will make the penalty so high that for such a font that
    // if any other font exists whose charset does match,
    // it will alwats beat the font whose charset doesn't match.


    mapper.vAcceptDiffCharset();


    // We are in big trouble now! To recount the story to this point.
    // We have failed to match the facename against either the device
    // or engine fonts. Then we failed to match against any device font
    // even though we ignored the name. Finally, we could not match
    // default facenames against the GDI fonts.
    // Now we call the emergency routine that gets a font, any font.

    mapper.vEmergency();

    // Either vEmergency() got a font or it didn't. It doesn't matter,
    // we have no choice but to return at this point.

    PPFEGETAMATCH_DEBUG_RETURN(mapper.ppfeRet());
}
/******************************Member*Function*****************************\
* MAPPER::vAttemptDeviceMatch()                                            *
*                                                                          *
* Considers every device font and tries to find the best match.            *
* Facenames are ignored.                                                   *
*                                                                          *
* History:                                                                 *
*  Thu 11-Mar-1993 15:44:59 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID MAPPER::vAttemptDeviceMatch()
{
    FONTHASH **ppfh      = (FONTHASH**) NULL;
    PFE       *ppfeRet   = (PFE*)       NULL;
    PFE       *ppfe;
    BYTE       jCharSet = DEFAULT_CHARSET;

    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        DbgPrint("\n\tMAPPER::vAtteptDeviceMatch()\n");
    }
    #endif

    // If the application asked for symbol then I will only allow GDI
    // to do font substitution. This request will probably end with
    // WingDings

    if (jMapCharSet == SYMBOL_CHARSET)
    {
        return;
    }

    DEVICE_PFTOBJ pftoDevice;
    PFF *pPFF;
    if (pPFF = pftoDevice.pPFFGet(pdco->hdev()))
    {
        PFFOBJ pffo(pPFF);

        if (pffo.bValid())
        {
            ppfh = &pffo.pPFF->pfhFamily;
        }
    }

    if (ppfh == (FONTHASH**) NULL)
    {
        RIP("MAPPER::vAttemptDeviceMatch() -- invalid FONTHASH\nReturning NULL");
        return;
    }

    // Set a very stringent pruning criteria!

    vReset(FM_WEIGHT_ITALIC-1);

    // reset the mapping information

    fl |= FM_BIT_DEVICE_FONT;

    // Prepare to enumerate through all the device fonts

    ENUMFHOBJ fho(ppfh);
    for (ppfe = fho.ppfeFirst(); ppfe; ppfe = fho.ppfeNext())
    {
        PFEOBJ pfeo(ppfe);

        if (this->bNearMatch(pfeo,&jCharSet))
        {
            DUMP_CHOSEN_FONT(pfeo);

            if (this->ulPenaltyTotal == 0)
            {
            // this is a slimey hack to get some excel scenario to work the same
            // way it does on NT as it does on Win 95.  In this scenario excel
            // is asking for Ms Sans Serif on an HP Laser 4Si.  On Win 95 this
            // maps to Arial.  However, on NT we map to Univers or some other
            // font before we can even look at Arial as a result what used to
            // print on 3 pages now prints on 6.  Since the scenario is used for
            // benchmarking this is undesireable. To fix this we penalize
            // any fonts that are not Arial so that we will at least look at Arial
            // and then choose it.

            // bad news, some customers rely on the first device font matched by bNearMatch()
            // for printing. Without the hack, it picks the first match and returns. With the
            // hack, it picks the last device font matched by bNearMatch() and returns.
            // in oder to make sure that the apps will still get the first device font matched by
            // bNearMatch(), we only update the ppfeBest if this->ulPenaltyTotal < this->ulMaxPenalty.

                if(_wcsicmp( pfeo.pwszFamilyName(), L"Arial"))
                {
                    this->ulPenaltyTotal += 1;
                }
                else
                {
                    vSetBest(ppfe, TRUE, jCharSet);
                    return;
                }
            }

            // keep the first device font that we picked

            if (this->ulPenaltyTotal < this->ulMaxPenalty)
            {
                vSetBest(ppfe, TRUE, jCharSet);
                this->ulMaxPenalty = this->ulPenaltyTotal;    // prune the search
            }
        }
        else
        {
            DUMP_REJECTED_FONT(pfeo);
        }
    }

    if (this->ppfeBest)
    {
        // record code page, needed for correct
        // code page to unicode translation

        *pflAboutMatch |= (ulCharsetToCodePage((UINT) (*pflAboutMatch >> 24)) << 8);
    }

    // If we still don't have a device font and this is the generic
    // printer driver then just take the first device font.
}

/******************************Public*Routine******************************\
* MAPPER::vEmergency                                                       *
*                                                                          *
*   Go through the Engine fonts without regard to name ...                 *
*                                                                          *
* History:                                                                 *
*  Fri 05-Mar-1993 08:44:38 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID MAPPER::vEmergency()
{
    PFE *ppfe;
    BYTE jCharSet = DEFAULT_CHARSET;
    BYTE jMatchCharset = DEFAULT_CHARSET;

    #if DBG
    if (gflFontDebug & DEBUG_MAPPER)
    {
        WARNING("\n\tMAPPER::vEmergency\n");
    }
    #endif

    PUBLIC_PFTOBJ pftoPublic;
    vReset();
    fl &= ~FM_BIT_DEVICE_FONT;

    ENUMFHOBJ fho(&pftoPublic.pPFT->pfhFamily);
    for
    (
        ppfe = fho.ppfeFirst();
        ppfe;
        ppfe = fho.ppfeNext()
    )
    {
        PFEOBJ pfeo(ppfe);
        if (this->bNearMatch(pfeo,&jCharSet, TRUE)) // called from vEmergency
        {
            DUMP_CHOSEN_FONT(pfeo);
            vSetBest(ppfe, FALSE, jCharSet);

        // bNearMatch modifies jCharSet even if it doesn't find a match
        // so subsquent calls to bNearMatch could change jCharSet to
        // something else.  Save a copy for use down below.

            jMatchCharset = jCharSet;

            if (this->ulPenaltyTotal == 0)
            {
                *pflAboutMatch |= (ulCharsetToCodePage((UINT) jCharSet) << 8);
                return;
            }
            this->ulMaxPenalty = this->ulPenaltyTotal;    // prune the search
        }
        else
        {
            DUMP_REJECTED_FONT(pfeo);
        }
    }

    // We can actually improve it here.
    // If the device is not a plotter, then we can actually
    // give it any bitmap font.
    // We could attempt to match against any bitmap font.

    if (!this->ppfeBest)
    {
        this->ppfeBest = gppfeMapperDefault;
        this->ulBestTime = gppfeMapperDefault->ulTimeStamp;
    }

    // record the code page, needed for correct
    // code page to unicode translation

    *pflAboutMatch |= (ulCharsetToCodePage((UINT) jMatchCharset) << 8);
}



/******************************Public*Routine******************************\
*
* PFE * MAPPER::ppfeSynthesizeAMatch (FLONG *pflSim, FLONG *pflAboutMatch, POINTL *pptlSim)
*
*
* Effects: if no exact instance is found, install one on the fly
*
* History:
*  30-Jan-1998 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



PFE * MAPPER::ppfeSynthesizeAMatch (FLONG *pflSim, FLONG *pflAboutMatch, POINTL *pptlSim)
{
    PFE *ppfeRet = NULL;

    DESIGNVECTOR *pdvWish;           // dv of the instance we wish to load
    ULONG         cjDV;
    ULONG  cFonts = 0;                   // number of fonts faces loaded

// let us get the pdv:

    if (flMM & FLMM_DV_FROM_NAME) // we got the axes from the name
    {
    // the name takes precedance, ie if we have explicit dv == [UU,VV]
    // as well as dv specified through font's family
    // name of the form foo_XX_YY, we ignore dv in ENUMLOGFONTEXDV
    // and use the one specified by the name, [XX,YY] in this case.

        pdvWish = &dvWish;
    }
    else
    {
        pdvWish = (DESIGNVECTOR *)&pelfwWish->elfDesignVector;
    }

    cjDV = SIZEOFDV(pdvWish->dvNumAxes);

// for now we do this only if another instance is already loaded

    if (ppfeMMInst)
    {
    // get to the PFF of the other instance, need file path data

        PFFOBJ pffMMInst(ppfeMMInst->pPFF) ;

        PFF *pPFF; // placeholder for the returned PFF

        if (pffMMInst.bValid())
        {
        // need to initialize the private PFT if it is NULL, these on the fly
        // instances are always added to private table

            if (gpPFTPrivate == NULL)
            {
                if (!bInitPrivatePFT())
                {
                    return ppfeRet;
                }
            }

        // temp instances go to private table

            PUBLIC_PFTOBJ pfto(gpPFTPrivate);

            if (!pffMMInst.bMemFont())
            {
                if (!pfto.bLoadFonts( pffMMInst.pwszPathname(),
                                      pffMMInst.cSizeofPaths(),
                                      pffMMInst.cNumFiles(),
                                      pdvWish, cjDV,
                                      &cFonts,
                      PFF_STATE_SYNTH_FONT, // flPFF
                                      &pPFF,
                                      (FR_PRIVATE | FR_NOT_ENUM), // always
                                      TRUE,    // skip the check if already loaded
                                      NULL ) ) // peudc
                {
                    cFonts = 0;
                }

                if (cFonts)
                {
                    GreQuerySystemTime( &PFTOBJ::FontChangeTime );
                }
            }

        }
        else // memory fonts
        {
            RIP("MEMORY FONT CASE NOT IMPLEMENTED\n");
        }

    // now need to get to the pfe of the font that we just added:

        if (cFonts)
        {
            PFFOBJ pffoNewInst(pPFF);

            if (pffoNewInst.bValid())
            {
                if (cFonts == 1)
                {
                    ppfeRet = pffoNewInst.ppfe(0);
                }
                else
                {
                // this is either an mm font which has a weight axis,
                // so that normal and bold faces are returned or this is a
                // also a FE mm font, in which case there may be
                // horiz and vertical variances as well. Therefore, in this case
                // we shall have to do mini-mapping process in order to decide which
                // face to return among those returned by by DrvLoadFontFile.

                    ULONG iFound = 0;
                    ULONG iFace = 0;
                    LONG  lMinSoFar = LONG_MAX;

                    for (iFace = 0; iFace < cFonts; iFace++)
                    {
                        IFIMETRICS *pifi = pffoNewInst.ppfe(iFace)->pifi;

                        IFIOBJ ifio(pifi);

                        LONG lDiff = (LONG)pifi->usWinWeight - lWishWeight;
                        if (lDiff < 0)
                            lDiff = -lDiff;

                    // <= on the next line is important because foo and @foo have the same weight

                        if (lDiff <= lMinSoFar)
                        {
                            lMinSoFar = lDiff;

                        // If requested font is vertlcal face font, We have to map it to vertical
                        // face font

                            if (fl & FM_BIT_VERT_FACE_REQUEST)
                            {
                                if (*ifio.pwszFamilyName() == U_COMMERCIAL_AT)
                                {
                                    iFound = iFace;
                                }
                            }
                            else
                            {
                                if (*ifio.pwszFamilyName() != U_COMMERCIAL_AT)
                                {
                                    iFound = iFace;
                                }
                            }
                        }
                    }

                    ppfeRet = pffoNewInst.ppfe(iFound);
                }

            // now that we know that we are returning ok we need to
            // fill in other output fields:

                *pflSim = 0;

        IFIOBJ ifio(ppfeRet->pifi);

        // next check for italic simulations

                if (pelfwWish->elfEnumLogfontEx.elfLogFont.lfItalic)
                {
        // if you get here then the application wants an italicized font

                    if (!ifio.bNonSimItalic() && ifio.bSimItalic())
                    {
                        *pflSim |= FO_SIM_ITALIC;
                    }
        }

        // bold simulations

        LONG lPen;

        lPen = ifio.lfNonSimWeight() - lWishWeight;

        if (!(fl & FM_BIT_FW_DONTCARE) && (lPen < 0 ))
        {
        // non simulated font isn't bold enough -> try a simulation

            lPen = -lPen;

            if(  (WIN31_BITMAP_EMBOLDEN_CRITERIA(lPen)) &&
             (ifio.pvSimBold() != NULL) )
            {
            *pflSim |= FO_SIM_BOLD;
            }
        }

                UINT CharSet = pelfwWish->elfEnumLogfontEx.elfLogFont.lfCharSet;

                *pflAboutMatch = (FLONG)(CharSet << 24);
                *pflAboutMatch |= (ulCharsetToCodePage(CharSet) << 8);
                pptlSim->x = pptlSim->y = 1;
            }
        }
    }
    return ppfeRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\greold.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-1999 Microsoft Corporation

Module Name:

    wingdi.h

Abstract:

    Procedure declarations, constant definitions and macros for the GDI
    component.

--*/

#define CBM_CREATEDIB   0x02L   /* create DIB bitmap */
#define DMDUP_LAST      DMDUP_HORIZONTAL
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE
#define DMMEDIA_LAST          DMMEDIA_GLOSSY
#define DMDITHER_LAST       DMDITHER_GRAYSCALE

typedef ULONG   COUNT;

// Old fields that Chicago won't support that we can't publically
// support anymore

#define HS_SOLIDCLR         6
#define HS_DITHEREDCLR      7
#define HS_SOLIDTEXTCLR     8
#define HS_DITHEREDTEXTCLR  9
#define HS_SOLIDBKCLR       10
#define HS_DITHEREDBKCLR    11
#define HS_API_MAX          12

#define DIB_PAL_INDICES     2 /* No color table indices into surf palette */

// End of stuff we yanked for Chicago compatability

#define SWAPL(x,y,t)        {t = x; x = y; y = t;}

#define ERROR_BOOL  (BOOL) -1L

#include <winddi.h>


/*********************************Struct***********************************\
* struct ENUMFONTDATA
*
* Information for the callback function used by EnumFonts.
*
*   lf      LOGFONT structure corresponding to one of the enumerated fonts.
*
*   tm      The corresponding TEXTMETRIC structure for the LOGFONT above.
*
*   flType  Flags are set as follows:
*
*               DEVICE_FONTTYPE is set if font is device-based (as
*               opposed to IFI-based).
*
*               RASTER_FONTTYPE is set if font is bitmap type.
*
* History:
*  21-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


#if defined(JAPAN)
#define NATIVE_CHARSET        SHIFTJIS_CHARSET
#define NATIVE_CODEPAGE       932
#define NATIVE_LANGUAGE_ID    411
#define DBCS_CHARSET          NATIVE_CHARSET
#elif defined(KOREA)
#define NATIVE_CHARSET        HANGEUL_CHARSET
#define NATIVE_CODEPAGE       949
#define NATIVE_LANGUAGE_ID    412
#define DBCS_CHARSET          NATIVE_CHARSET
#elif defined(TAIWAN)
#define NATIVE_CHARSET        CHINESEBIG5_CHARSET
#define NATIVE_CODEPAGE       950
#define NATIVE_LANGUAGE_ID    404
#define DBCS_CHARSET          NATIVE_CHARSET
#elif defined(PRC)
#define NATIVE_CHARSET        GB2312_CHARSET
#define NATIVE_CODEPAGE       936
#define NATIVE_LANGUAGE_ID    804
#define DBCS_CHARSET          NATIVE_CHARSET
#endif

#if defined(DBCS)
#define IS_DBCS_CHARSET( CharSet )     ( ((CharSet) == DBCS_CHARSET) ? TRUE : FALSE )
#define IS_ANY_DBCS_CHARSET( CharSet ) ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                                         ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                                         ((CharSet) == JOHAB_CHARSET)       ? TRUE :    \
                                         ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                                         ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )

#define IS_DBCS_CODEPAGE( CodePage )     (((CodePage) == NATIVE_CODEPAGE) ? TRUE : FALSE )
#define IS_ANY_DBCS_CODEPAGE( CodePage ) (((CodePage) == 932) ? TRUE :    \
                                          ((CodePage) == 949) ? TRUE :    \
                                          ((CodePage) == 1361) ? TRUE :    \
                                          ((CodePage) == 950) ? TRUE :    \
                                          ((CodePage) == 936) ? TRUE : FALSE )
#endif // DBCS



/*********************************Struct***********************************\
* struct ENUMFONTDATAW
*
* Information for the callback function used by EnumFontsW
*
*   lfw     LOGFONTW structure corresponding to one of the enumerated fonts.
*
*   tmw     The corresponding TEXTMETRICW structure for the LOGFONTW above.
*
*   flType  Flags are set as follows:
*
*               DEVICE_FONTTYPE is set if font is device-based (as
*               opposed to IFI-based).
*
*               RASTER_FONTTYPE is set if font is bitmap type.
*
* History:
*  Wed 04-Sep-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



//
// Function prototypes
//

BOOL  bDeleteSurface(HSURF hsurf);
BOOL  bSetBitmapOwner(HBITMAP hbm,LONG lPid);
BOOL  bSetBrushOwner(HBRUSH hbr,LONG lPid);
BOOL  bSetPaletteOwner(HPALETTE hpal, LONG lPid);
BOOL  bSetLFONTOwner(HFONT hlfnt, LONG pid);

BOOL  bDeleteRegion(HRGN hrgn);
BOOL  bSetRegionOwner(HRGN hrgn,LONG lPid);
LONG iCombineRectRgn(HRGN hrgnTrg,HRGN hrgnSrc,PRECTL prcl,LONG iMode);

BOOL bGetFontPathName
(
LPWSTR *ppwszPathName,     // place to store the result, full path of the font file
PWCHAR awcPathName,         // ptr to the buffer on the stack, must be MAX_PATH in length
LPWSTR pwszFileName         // file name, possibly  bare name that has to be tacked onto the path
);

BOOL UserGetHwnd(HDC hdc, HWND *phwnd, PVOID *ppwo, BOOL bCheckStyle);
VOID UserAssociateHwnd(HWND hwnd, PVOID pwo);



// private flags in low bits of hdc returned from GreCreateDCW

#define GRE_DISPLAYDC   1
#define GRE_PRINTERDC   2
#define GRE_OWNDC 1


HDC hdcCloneDC(HDC hdc,ULONG iType);

BOOL  bSetDCOwner(HDC hdc,LONG lPid);
DWORD sidGetObjectOwner(HDC hdc, DWORD objType);
BOOL  bSetupDC(HDC hdc,FLONG fl);

#define SETUPDC_CLEANDC         0x00000040
#define SETUPDC_RESERVE         0x00000080

BOOL APIENTRY GreConsoleTextOut
(
  HDC        hdc,
  POLYTEXTW *lpto,
  UINT       nStrings,
  RECTL     *prclBounds
);

#define UTO_NOCLIP 0x0001

// Server entry point for font enumeration.

// Sundown: change from ULONG to ULONG_PTR in places used as handles/pointers
ULONG_PTR APIENTRY ulEnumFontOpen(
    HDC hdc,                    // device to enumerate on
    BOOL bEnumFonts,            // flag indicates old style EnumFonts()
    FLONG flWin31Compat,        // Win3.1 compatibility flags
    COUNT cwchMax,              // maximum name length (for paranoid CSR code)
    LPWSTR pwszName);           // font name to enumerate

BOOL APIENTRY bEnumFontChunk(
    HDC             hdc,        // device to enumerate on
    ULONG_PTR        idEnum,
    COUNT           cefdw,      // (in) capacity of buffer
    COUNT           *pcefdw,    // (out) number of ENUMFONTDATAs returned
    PENUMFONTDATAW  pefdw);     // return buffer

BOOL APIENTRY bEnumFontClose(
    ULONG_PTR   idEnum);            // enumeration id

// Server entry points for adding/removing font resources.

BOOL APIENTRY bUnloadFont(
    LPWSTR   pwszPathname,
    ULONG    iResource);


// Private Control Panel entry point to configure font enumeration.

BOOL  APIENTRY GreArc(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GreArcTo(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GreChord(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GreEllipse(HDC,int,int,int,int);
ULONG APIENTRY GreEnumObjects(HDC, int, ULONG, PVOID);
BOOL  APIENTRY GreExtFloodFill(HDC,int,int,COLORREF,UINT);
BOOL  APIENTRY GreFillRgn(HDC,HRGN,HBRUSH);
BOOL  APIENTRY GreFloodFill(HDC,int,int,COLORREF);
BOOL  APIENTRY GreFrameRgn(HDC,HRGN,HBRUSH,int,int);
BOOL  APIENTRY GreMaskBlt(HDC,int,int,int,int,HDC,int,int,HBITMAP,int,int,DWORD,DWORD);
BOOL  APIENTRY GrePlgBlt(HDC,LPPOINT,HDC,int,int,int,int,HBITMAP,int,int,DWORD);
BOOL  APIENTRY GrePie(HDC,int,int,int,int,int,int,int,int);
BOOL  APIENTRY GrePaintRgn(HDC,HRGN);
BOOL  APIENTRY GreRectangle(HDC,int,int,int,int);
BOOL  APIENTRY GreRoundRect(HDC,int,int,int,int,int,int);
BOOL  APIENTRY GreAngleArc(HDC,int,int,DWORD,FLOATL,FLOATL);
BOOL  APIENTRY GrePlayJournal(HDC,LPWSTR,ULONG,ULONG);
BOOL  APIENTRY GrePolyPolygon(HDC,LPPOINT,LPINT,int);
BOOL  APIENTRY GrePolyPolyline(HDC, CONST POINT *,LPDWORD,DWORD);

BOOL  APIENTRY GrePolyPatBlt(HDC,DWORD,PPOLYPATBLT,DWORD,DWORD);

BOOL  APIENTRY GrePolyBezierTo(HDC,LPPOINT,DWORD);
BOOL  APIENTRY GrePolylineTo(HDC,LPPOINT,DWORD);
BOOL  APIENTRY GreGetTextExtentExW (HDC, LPWSTR, COUNT, ULONG, COUNT *, PULONG, LPSIZE, FLONG);


int   APIENTRY GreGetTextFaceW(HDC,int,LPWSTR, BOOL);

#define ETO_MASKPUBLIC  ( ETO_OPAQUE | ETO_CLIPPED )    // public (wingdi.h) flag mask

BOOL  APIENTRY GrePolyTextOutW(HDC, POLYTEXTW *, UINT, DWORD);

BOOL  APIENTRY GreSetAttrs(HDC hdc);
BOOL  APIENTRY GreSetFontXform(HDC,FLOATL,FLOATL);

BOOL  APIENTRY GreBeginPath(HDC);
BOOL  APIENTRY GreCloseFigure(HDC);
BOOL  APIENTRY GreEndPath(HDC);
BOOL  APIENTRY GreAbortPath(HDC);
BOOL  APIENTRY GreFillPath(HDC);
BOOL  APIENTRY GreFlattenPath(HDC);
HRGN  APIENTRY GrePathToRegion(HDC);
BOOL  APIENTRY GrePolyDraw(HDC,LPPOINT,LPBYTE,ULONG);
BOOL  APIENTRY GreSelectClipPath(HDC,int);
int   APIENTRY GreSetArcDirection(HDC,int);
int   APIENTRY GreGetArcDirection(HDC);
BOOL  APIENTRY GreSetMiterLimit(HDC,FLOATL,FLOATL *);
BOOL  APIENTRY GreGetMiterLimit(HDC,FLOATL *);
BOOL  APIENTRY GreStrokeAndFillPath(HDC);
BOOL  APIENTRY GreStrokePath(HDC);
BOOL  APIENTRY GreWidenPath(HDC);

BOOL     APIENTRY GreAnimatePalette(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
BOOL     APIENTRY GreAspectRatioFilter(HDC, LPSIZE);
BOOL     APIENTRY GreCancelDC(HDC);
int      APIENTRY GreChoosePixelFormat(HDC, UINT, CONST PIXELFORMATDESCRIPTOR *);
BOOL     APIENTRY GreCombineTransform(XFORML *, XFORML *, XFORML *);

HDC      APIENTRY GreCreateDCW(LPWSTR, LPWSTR, LPWSTR, LPDEVMODEW, BOOL);
HBRUSH   APIENTRY GreCreateDIBPatternBrush(HGLOBAL, DWORD);
HBRUSH   APIENTRY GreCreateDIBPatternBrushPt(LPVOID, DWORD);
HBITMAP  APIENTRY GreCreateDIBitmap(HDC, LPBITMAPINFOHEADER, DWORD, LPBYTE, LPBITMAPINFO, DWORD);
HRGN     APIENTRY GreCreateEllipticRgn(int, int, int, int);


HBRUSH   APIENTRY GreCreateHatchBrush(ULONG, COLORREF);
HPEN     APIENTRY GreCreatePen(int, int, COLORREF,HBRUSH);
HPEN     APIENTRY GreExtCreatePen(ULONG, ULONG, ULONG, ULONG, ULONG_PTR, ULONG_PTR, ULONG, PULONG, ULONG, BOOL, HBRUSH);
HPEN     APIENTRY GreCreatePenIndirect(LPLOGPEN);
HRGN     APIENTRY GreCreatePolyPolygonRgn(CONST POINT *, CONST INT *, int, int);
HRGN     APIENTRY GreCreatePolygonRgn(CONST POINT *, int, int);
HRGN     APIENTRY GreCreateRoundRectRgn(int, int, int, int, int, int);
BOOL     APIENTRY GreCreateScalableFontResourceW(FLONG, LPWSTR, LPWSTR, LPWSTR);

int      APIENTRY GreDescribePixelFormat(HDC hdc,int ipfd,UINT cjpfd,PPIXELFORMATDESCRIPTOR ppfd);

int      APIENTRY GreDeviceCapabilities(LPSTR, LPSTR, LPSTR, int, LPSTR, LPDEVMODE);
int      APIENTRY GreDrawEscape(HDC,int,int,LPSTR);
BOOL     APIENTRY GreEqualRgn(HRGN, HRGN);
int      APIENTRY GreExtEscape(HDC,int,int,LPSTR,int,LPSTR);
BOOL     APIENTRY GreGetAspectRatioFilter(HDC, LPSIZE);
BOOL     APIENTRY GreGetBitmapDimension(HBITMAP, LPSIZE);
int      APIENTRY GreGetBkMode(HDC);
DWORD    APIENTRY GreGetBoundsRect(HDC, LPRECT, DWORD);
BOOL     APIENTRY GreGetCharWidthW(HDC hdc, UINT wcFirstChar, UINT cwc, PWCHAR pwc, FLONG fl, PVOID lpBuffer);
BOOL     APIENTRY GreFontIsLinked(HDC hdc);

BOOL     APIENTRY GreGetCharABCWidthsW(
            HDC,           // hdc
            UINT,          // wcFirst
            COUNT,         // cwc
            PWCHAR,        // pwc to buffer with chars to convert
            FLONG,         //
            PVOID);        // abc or abcf

BOOL     APIENTRY GreGetCharWidthInfo(HDC hdc,  PCHWIDTHINFO pChWidthInfo);

int      APIENTRY GreGetAppClipBox(HDC, LPRECT);
BOOL     APIENTRY GreGetCurrentPosition(HDC, LPPOINT);
int      APIENTRY GreGetGraphicsMode(HDC hdc);
COLORREF APIENTRY GreGetNearestColor(HDC, COLORREF);
UINT     APIENTRY GreGetNearestPaletteIndex(HPALETTE, COLORREF);


UINT     APIENTRY GreGetPaletteEntries(HPALETTE, UINT, UINT, LPPALETTEENTRY);
DWORD    APIENTRY GreGetPixel(HDC, int, int);
int      APIENTRY GreGetPixelFormat(HDC);
UINT     APIENTRY GreGetTextAlign(HDC);
BOOL     APIENTRY GreGetWorldTransform(HDC, XFORML *);
BOOL     APIENTRY GreGetTransform(HDC, DWORD, XFORML *);
BOOL     APIENTRY GreSetVirtualResolution(HDC, int, int, int, int);
HRGN     APIENTRY GreInquireRgn(HDC hdc);
BOOL     APIENTRY GreInvertRgn(HDC, HRGN);
BOOL     APIENTRY GreModifyWorldTransform(HDC ,XFORML *, DWORD);
BOOL     APIENTRY GreMoveTo(HDC, int, int, LPPOINT);
int      APIENTRY GreOffsetClipRgn(HDC, int, int);
BOOL     APIENTRY GreOffsetViewportOrg(HDC, int, int, LPPOINT);
BOOL     APIENTRY GreOffsetWindowOrg(HDC, int, int, LPPOINT);
BOOL     APIENTRY GrePolyBezier (HDC, LPPOINT, ULONG);
BOOL     APIENTRY GrePtVisible(HDC, int, int);
BOOL     APIENTRY GreRectVisible(HDC, LPRECT);

BOOL     APIENTRY GreResetDC(HDC, LPDEVMODEW);
BOOL     APIENTRY GreResizePalette(HPALETTE, UINT);
BOOL     APIENTRY GreScaleViewportExt(HDC, int, int, int, int, LPSIZE);
BOOL     APIENTRY GreScaleWindowExt(HDC, int, int, int, int, LPSIZE);
HPALETTE APIENTRY LockCSSelectPalette(HDC, HPALETTE, BOOL);

HPEN     APIENTRY GreSelectPen(HDC,HPEN);
LONG     APIENTRY GreSetBitmapBits(HBITMAP, ULONG, PBYTE, PLONG);
BOOL     APIENTRY GreSetBitmapDimension(HBITMAP, int, int, LPSIZE);
DWORD    APIENTRY GreSetBoundsRect(HDC, LPRECT, DWORD);
UINT     APIENTRY GreSetDIBColorTable(HDC, UINT, UINT, RGBQUAD *);
int      APIENTRY GreSetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int, int, DWORD, DWORD, LPBYTE, LPBITMAPINFO, DWORD);
int      APIENTRY GreSetGraphicsMode(HDC hdc, int iMode);
int      APIENTRY GreSetMapMode(HDC, int);
DWORD    APIENTRY GreSetMapperFlags(HDC, DWORD);
UINT     APIENTRY GreSetPaletteEntries(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
COLORREF APIENTRY GreSetPixel(HDC, int, int, COLORREF);
BOOL     APIENTRY GreSetPixelV(HDC, int, int, COLORREF);
BOOL     APIENTRY GreSetPixelFormat(HDC, int);
BOOL     APIENTRY GreSetRectRgn(HRGN, int, int, int, int);
UINT     APIENTRY GreSetSystemPaletteUse(HDC, UINT);
UINT     APIENTRY GreSetTextAlign(HDC, UINT);
HPALETTE APIENTRY GreCreateHalftonePalette(HDC hdc);
HPALETTE APIENTRY GreCreateCompatibleHalftonePalette(HDC hdc);
BOOL     APIENTRY GreSetTextJustification(HDC, int, int);
BOOL     APIENTRY GreSetViewportExt(HDC, int, int, LPSIZE);
BOOL     APIENTRY GreSetWindowExt(HDC, int, int, LPSIZE);
BOOL     APIENTRY GreSetWorldTransform(HDC, XFORML *);
int      APIENTRY GreStretchDIBits(HDC, int, int, int, int, int, int, int, int, LPBYTE, LPBITMAPINFO, DWORD, DWORD);
BOOL     APIENTRY GreSystemFontSelected(HDC, BOOL);
BOOL     APIENTRY GreSwapBuffers(HDC hdc);
BOOL     APIENTRY GreUnrealizeObject(HANDLE);
BOOL     APIENTRY GreUpdateColors(HDC);

// Prototypes for wgl and OpenGL calls

HGLRC    APIENTRY GreCreateRC(HDC);
BOOL     APIENTRY GreMakeCurrent(HDC, HGLRC);
BOOL     APIENTRY GreDeleteRC(HGLRC);
BOOL     APIENTRY GreSwapBuffers(HDC);
BOOL     APIENTRY GreGlAttention(VOID);
BOOL     APIENTRY GreShareLists(HGLRC, HGLRC);
BOOL     APIENTRY glsrvDuplicateSection(ULONG, HANDLE);
void     APIENTRY glsrvThreadExit(void);
BOOL     bSetRCOwner(HGLRC hglrc,LONG lPid);


// these should disappear as should all other functions that contain references
// to ansi strings

BOOL  APIENTRY GreGetTextExtent(HDC,LPSTR,int,LPSIZE,UINT);
BOOL  APIENTRY GreExtTextOut(HDC,int,int,UINT,LPRECT,LPSTR,int,LPINT);
BOOL  APIENTRY GreTextOut(HDC,int,int,LPSTR,int);

// these stay

VOID vGetFontList(VOID *pvBuffer, COUNT *pNumFonts, UINT *pSize);
BOOL  GreMatchFont(LPWSTR pwszBareName, LPWSTR pwszFontPathName);

// used in clean up at log-off time




// these are for font linking

BOOL  GreEnableEUDC(BOOL);

// this is for font association

UINT GreGetFontAssocStatus();

BOOL     APIENTRY GreStartPage(HDC);
BOOL     APIENTRY GreEndPage(HDC);
int      APIENTRY GreStartDoc(HDC, DOCINFOW *);
BOOL     APIENTRY GreEndDoc(HDC);
BOOL     APIENTRY GreAbortDoc(HDC);

// Prototypes for GDI local helper functions.  These are only available on
// the client side.

HPALETTE    GdiConvertPalette(HPALETTE hpal);
HFONT       GdiConvertFont(HFONT hfnt);
HBRUSH      GdiConvertBrush(HBRUSH hbrush);
HDC         GdiGetLocalDC(HDC hdcRemote);
HDC         GdiCreateLocalDC(HDC hdcRemote);
BOOL        GdiReleaseLocalDC(HDC hdcLocal);
HBITMAP     GdiCreateLocalBitmap();
HBRUSH      GdiCreateLocalBrush(HBRUSH hbrushRemote);
HRGN        GdiCreateLocalRegion(HRGN hrgnRemote);
HFONT       GdiCreateLocalFont(HFONT hfntRemote);
HPALETTE    GdiCreateLocalPalette(HPALETTE hpalRemote);
ULONG       GdiAssociateObject(ULONG hLocal,ULONG hRemote);
VOID        GdiDeleteLocalObject(ULONG h);
BOOL        GdiSetAttrs(HDC);
HANDLE      SelectFontLocal(HDC, HANDLE);
HANDLE      SelectBrushLocal(HDC, HANDLE);
HFONT       GdiGetLocalFont(HFONT);
HBRUSH      GdiGetLocalBrush(HBRUSH);
HBITMAP     GdiGetLocalBitmap(HBITMAP);
HDC         GdiCloneDC(HDC hdc, UINT iType);
BOOL        GdiPlayScript(PULONG pulScript,ULONG cjScript,PULONG pulEnv,ULONG cjEnv,PULONG pulOutput,ULONG cjOutput,ULONG cLimit);
BOOL        GdiPlayDCScript(HDC hdc,PULONG pulScript,ULONG cjScript,PULONG pulOutput,ULONG cjOutput,ULONG cLimit);
BOOL        GdiIsMetaFileDC(HDC hdc);

// Return codes from server-side ResetDC

#define RESETDC_ERROR   0
#define RESETDC_FAILED  1
#define RESETDC_SUCCESS 2

// Private calls for USER

int  APIENTRY GreGetClipRgn(HDC, HRGN);
BOOL APIENTRY GreSrcBlt(HDC, int, int, int, int, int, int);
BOOL APIENTRY GreCopyBits(HDC,int,int,int,int,HDC,int,int);
VOID APIENTRY GreSetClientRgn(PVOID, HRGN, LPRECT);
ULONG APIENTRY GreSetROP2(HDC hdc,int iROP);

// Private calls for metafiling

DWORD   APIENTRY GreGetRegionData(HRGN, DWORD, LPRGNDATA);
HRGN    APIENTRY GreExtCreateRegion(XFORML *, DWORD, LPRGNDATA);
int     APIENTRY GreExtSelectMetaRgn(HDC, HRGN, int);
BOOL    APIENTRY GreMonoBitmap(HBITMAP);
HBITMAP APIENTRY GreGetObjectBitmapHandle(HBRUSH, UINT *);


typedef struct _DDALIST
{
   LONG yTop;
   LONG yBottom;
   LONG axPairs[2];
} DDALIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\gradfill.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"

/**************************************************************************\
*   gulDither32 - 4-4 dither matrix
*
*
* History:
*
*    1/31/1997 Mark Enstrom [marke]
*
\**************************************************************************/

ULONG gulDither32[] =
{
    0x00000000,
    0x00008000,
    0x00002000,
    0x0000a000,

    0x0000c000,
    0x00004000,
    0x0000e000,
    0x00006000,

    0x00003000,
    0x0000b000,
    0x00001000,
    0x00009000,

    0x0000f000,
    0x00007000,
    0x0000d000,
    0x00005000
};


/**************************************************************************\
*
*   Dither information for 8bpp. This is customized for dithering to
*   the halftone palette [6,6,6] color cube.
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define DITHER_8_MASK_Y 0x0F
#define DITHER_8_MASK_X 0x0F

BYTE gDitherMatrix16x16Halftone[256] = {
  3, 28,  9, 35,  4, 30, 11, 36,  3, 29, 10, 35,  5, 30, 11, 37,
 41, 16, 48, 22, 43, 17, 49, 24, 42, 16, 48, 22, 43, 18, 50, 24,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 32,  0, 26,  8, 34,  2, 27,
 44, 19, 38, 12, 46, 20, 40, 14, 45, 19, 38, 13, 46, 21, 40, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  6, 31, 12, 38,  4, 30, 10, 36,
 44, 18, 50, 24, 42, 16, 48, 23, 44, 18, 50, 25, 42, 17, 49, 23,
  8, 34,  2, 28,  7, 32,  0, 26,  9, 34,  2, 28,  7, 33,  1, 26,
 47, 21, 40, 15, 45, 20, 39, 13, 47, 22, 41, 15, 46, 20, 39, 14,
  3, 29,  9, 35,  5, 30, 11, 37,  3, 28,  9, 35,  4, 30, 11, 36,
 41, 16, 48, 22, 43, 17, 49, 24, 41, 15, 47, 22, 43, 17, 49, 23,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 31,  0, 25,  7, 33,  1, 27,
 45, 19, 38, 13, 46, 21, 40, 14, 44, 19, 38, 12, 46, 20, 39, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  5, 31, 11, 37,  3, 29, 10, 35,
 44, 18, 50, 25, 42, 17, 49, 23, 43, 18, 50, 24, 42, 16, 48, 23,
  9, 34,  2, 28,  7, 33,  1, 26,  8, 34,  2, 27,  7, 32,  0, 26,
 47, 21, 41, 15, 45, 20, 39, 13, 47, 21, 40, 15, 45, 19, 39, 13
 };

BYTE gDitherMatrix16x16Default[256] = {
    8, 72, 24, 88, 12, 76, 28, 92,  9, 73, 25, 89, 13, 77, 29, 93,
  104, 40,120, 56,108, 44,124, 60,105, 41,121, 57,109, 45,125, 61,
   16, 80,  0, 64, 20, 84,  4, 68, 17, 81,  1, 65, 21, 85,  5, 69,
  112, 48, 96, 32,116, 52,100, 36,113, 49, 97, 33,117, 53,101, 37,
   14, 78, 30, 94, 10, 74, 26, 90, 15, 79, 31, 95, 11, 75, 27, 91,
  110, 46,126, 62,106, 42,122, 58,111, 47,126, 63,107, 43,123, 59,
   22, 86,  6, 70, 18, 82,  2, 66, 23, 87,  7, 71, 19, 83,  3, 67,
  118, 54,102, 38,114, 50, 98, 34,119, 55,103, 39,115, 51, 99, 35,
    9, 73, 25, 89, 13, 77, 29, 93,  8, 72, 24, 88, 12, 76, 28, 92,
  105, 41,121, 57,109, 45,125, 61,104, 40,120, 56,108, 44,124, 60,
   17, 81,  1, 65, 21, 85,  5, 69, 16, 80,  0, 64, 20, 84,  4, 68,
  113, 49, 97, 33,117, 53,101, 37,112, 48, 96, 32,116, 52,100, 36,
   15, 79, 31, 95, 11, 75, 27, 91, 14, 78, 30, 94, 10, 74, 26, 90,
  111, 47,126, 63,107, 43,123, 59,110, 46,126, 62,106, 42,122, 58,
   23, 87,  7, 71, 19, 83,  3, 67, 22, 86,  6, 70, 18, 82,  2, 66,
  119, 55,103, 39,115, 51, 99, 35,118, 54,102, 38,114, 50, 98, 34
  };

//
// identity translate vector for use in non palmanaged 8bpp surfaces
//

/**************************************************************************\
* vTranslateIdentity
*
*   identity translate vector for use in non-palmanaged 8bpp surfaces
*
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE vTranslateIdentity[256] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
    };

/**************************************************************************\
* HalftoneSaturationTable
*
*   This table maps a 8 bit pixel plus a dither error term in the range
*   of 0 to 51 onto a 8 bit pixel. Overflow of up to 31 is considered
*   saturated (255+51 = 255). The level 51 (0x33) is used to map pixels
*   and error values to the halftone palette
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE HalftoneSaturationTable[256 + 128] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE DefaultSaturationTable[256 + 128] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE Saturation16_5[64] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

BYTE Saturation16_6[128] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
    0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

/******************************Public*Routine******************************\
* vGradientFill32BGRA
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill32BGRA(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;
    LONGLONG lldAdX = ptData->lldAdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue,clrAlpha;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;
        clrAlpha.ullColor = pEdge->llAlpha;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX         = (PULONG)pDst + xScanLeft;
            pulDstScanRight = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
                clrAlpha.ullColor += lldAdX * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = (clrAlpha.b[7] << 24) |
                           (clrRed.b[7]   << 16) |
                           (clrGreen.b[7] << 8)  |
                           (clrBlue.b[7]);

                pulDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
                clrAlpha.ullColor += lldAdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill32RGB
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill32RGB(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX =
                           (clrBlue.b[7]  << 16) |
                           (clrGreen.b[7] << 8)  |
                           (clrRed.b[7]);

                pulDstX++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill32Bitfields
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill32Bitfields(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    XEPALOBJ *ppalDstSurf = ptData->ppalDstSurf;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pulDstX < pulDstScanRight)
            {
                ULONG ulTemp =
                           (clrRed.b[7]       )   |
                           (clrGreen.b[7] <<  8)  |
                           (clrBlue.b[7]  << 16);

                *pulDstX = ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

                pulDstX++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/**************************************************************************\
* vGradientFill24BGR
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill24BGR(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     yScanBottom;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = clrBlue.b[7];
                *(pDstX+1) = clrGreen.b[7];
                *(pDstX+2) = clrRed.b[7];

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/**************************************************************************\
* vGradientFill24RGB
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vGradientFill24BGR
*
\**************************************************************************/

VOID
vGradientFill24RGB(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     yScanBottom;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = clrRed.b[7];
                *(pDstX+1) = clrGreen.b[7];
                *(pDstX+2) = clrBlue.b[7];

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill24Bitfields
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vGradientFill32Bitfields
*
\**************************************************************************/

VOID
vGradientFill24Bitfields(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    XEPALOBJ *ppalDstSurf = ptData->ppalDstSurf;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pbDstX;
        PBYTE pbDstScanRight,pbDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pbDstX           = (PBYTE)pDst + xScanLeft*3;
            pbDstScanRight   = (PBYTE)pDst + xScanRight*3;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pbDstX < pbDstScanRight)
            {
                ULONG ulTemp =
                           (clrRed.b[7]       )   |
                           (clrGreen.b[7] <<  8)  |
                           (clrBlue.b[7]  << 16);

                ulTemp = ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

                *pbDstX      = ((PBYTE)&ulTemp)[0];
                *(pbDstX+1)  = ((PBYTE)&ulTemp)[1];
                *(pbDstX+2)  = ((PBYTE)&ulTemp)[2];

                pbDstX += 3;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}
/******************************Public*Routine******************************\
* vGradientFill16_565
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill16_565(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG       lDelta = pSurfDst->lDelta();
    LONG       yScan  = ptData->y0;
    LONG       yScanBottom;
    PBYTE      pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE   pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;
        PULONG pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_6[((clrGreen.ul[1] >> (8+2)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                *pusDstX = rgb565(iRed,iGreen,iBlue);

                xScanLeft++;
                pusDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}


/******************************Public*Routine******************************\
* vGradientFill16_555
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill16_555(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;

        PULONG  pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_5[((clrGreen.ul[1] >> (8+3)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                *pusDstX = rgb555(iRed,iGreen,iBlue);

                xScanLeft++;
                pusDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill16Bitfields
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill16Bitfields(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XEPALOBJ *ppalDstSurf = ptData->ppalDstSurf;
    PULONG   pulDither;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_5[((clrGreen.ul[1] >> (8+3)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                ULONG ulTemp = (iRed   << (    3)) |
                               (iGreen << (8  +3)) |
                               (iBlue  << (8+8+3));

                *pusDstX = (USHORT)ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                xScanLeft++;
                pusDstX++;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/**************************************************************************\
* GRAD_PALETTE_MATCH
*
*
* Arguments:
*
*   palIndex  - return surface palette index
*   pjVector  - translation from DC to surface palette. Identity for non
*               palette managed
*   pxlate555 - rgb555 to palette index table
*   r,g,b     - byte colors
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define GRAD_PALETTE_MATCH(palIndex,pjVector,pxlate555,r,g,b)             \
                                                                          \
palIndex = pxlate555[((r & 0xf8) << 7) |                                  \
                     ((g & 0xf8) << 2) |                                  \
                     ((b & 0xf8) >> 3)];                                  \
                                                                          \
palIndex = pjVector[palIndex];

/******************************Public*Routine******************************\
* vGradientFill8
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill8(
   SURFACE *pSurfDst,
   PTRIANGLEDATA ptData
   )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XLATEOBJ *pxlo  = ptData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;

    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    //
    // either use default palette or halftone palette dither
    //

    if (((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).bIsHalftone())
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("vGradientFill8:Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // scan from top to bottom of triangle scan lines
    //

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX,pjDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + xScanLeft;
            pjDstScanRight    = pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // gradient fill scan with dither
            //

            while (pjDstX < pjDstScanRight)
            {
                BYTE  jIndex;

                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X));

                ULONG iRed   = pSaturationTable[clrRed.b[7]   + jDitherMatrix];
                ULONG iGreen = pSaturationTable[clrGreen.b[7] + jDitherMatrix];
                ULONG iBlue  = pSaturationTable[clrBlue.b[7]  + jDitherMatrix];

                GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                *pjDstX = jIndex;

                xScanLeft++;
                pjDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill4
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill4(
    SURFACE *pSurfDst,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XLATEOBJ *pxlo  = ptData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + (xScanLeft/2);
            iDstX             = xScanLeft & 1;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // fill scan line with dither
            //

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X));

                ULONG iRed   = pSaturationTable[clrRed.b[7]   + jDitherMatrix];
                ULONG iGreen = pSaturationTable[clrGreen.b[7] + jDitherMatrix];
                ULONG iBlue  = pSaturationTable[clrBlue.b[7]  + jDitherMatrix];

                BYTE  jIndex;

                GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                //
                // write nibble
                //

                if (iDstX)
                {
                    iDstX = 0;
                    *pjDstX = (*pjDstX & 0xf0) | jIndex;
                    pjDstX++;
                }
                else
                {
                    *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
                    iDstX = 1;
                }

                xScanLeft++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vGradientFill1
*
*   Fill scan lines of triangle structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   ptData   - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vGradientFill1(
   SURFACE *pSurfDst,
   PTRIANGLEDATA ptData
   )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = ((PBYTE)pSurfDst->pvScan0() + lDelta * yScan);
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    XLATEOBJ *pxlo  = ptData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector         = vTranslateIdentity;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    LONGLONG lldRdX = ptData->lldRdX;
    LONGLONG lldGdX = ptData->lldGdX;
    LONGLONG lldBdX = ptData->lldBdX;

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // must have palette xlate
    //

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        LONG    ScanRight;
        LONG    ScanLeft;
        LONG    xScan;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX         = pDst + (xScanLeft/8);
            iDstX          = xScanLeft & 7;

            //
            // skip clipped out portion of scan line whille
            // running color gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X)));

                ULONG iRed   = clrRed.b[7];
                ULONG iGreen = clrGreen.b[7];
                ULONG iBlue  = clrBlue.b[7];

                //
                // add dither and saturate. 1bpp non-optimized (overflow will not be noticable in a dither
                // case it would at higher color depth
                //

                iRed   = iRed   + jDitherMatrix;

                if (iRed >= 255)
                {
                    iRed = 255;
                }
                else
                {
                    iRed = 0;
                }

                iGreen = iGreen + jDitherMatrix;

                if (iGreen >= 255)
                {
                    iGreen = 255;
                }
                else
                {
                    iGreen = 0;
                }

                iBlue  = iBlue  + jDitherMatrix;

                if (iBlue >= 255)
                {
                    iBlue = 255;
                }
                else
                {
                    iBlue = 0;
                }


                BYTE  jIndex;

                //
                // pjVector is known to be identity, so could make new macro for
                // palette_match_1 if perf ever an issue
                //

                GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                LONG iShift = 7 - iDstX;
                BYTE OrMask = 1 << iShift;
                BYTE AndMask  = ~OrMask;

                jIndex = jIndex << iShift;

                *pjDstX = (*pjDstX & AndMask) | jIndex;

                iDstX++;

                if (iDstX == 8)
                {
                    iDstX = 0;
                    pjDstX++;
                }

                xScanLeft++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

//
//  Gradient fill rectangle routines
//
//
//  Gradient Rectangles us 8.48 fixed point color
//  as oppesed to triangles that use 8.56
//
//
//
//
//
//
//
//
//
//
//
//
//

/******************************Public*Routine******************************\
* vFillGRectDIB32BGRA
*
*   Fill gradient rect from structure
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32BGRA(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrA;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pjDst     = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;
        PULONG   pulBuffer = (PULONG)AllocFreeTmpBuffer(4 * pgData->szDraw.cx);

        if (pulBuffer)
        {
            clrR.ullColor = pgData->llRed;
            clrG.ullColor = pgData->llGreen;
            clrB.ullColor = pgData->llBlue;
            clrA.ullColor = pgData->llAlpha;

            LONGLONG lldRdX   = pgData->lldRdX;
            LONGLONG lldGdX   = pgData->lldGdX;
            LONGLONG lldBdX   = pgData->lldBdX;
            LONGLONG lldAdX   = pgData->lldAdX;

            //
            // adjust gradient fill for clipped portion
            //

            if (pgData->xScanAdjust > 0)
            {
                clrR.ullColor += lldRdX * (pgData->xScanAdjust);
                clrG.ullColor += lldGdX * (pgData->xScanAdjust);
                clrB.ullColor += lldBdX * (pgData->xScanAdjust);
                clrA.ullColor += lldAdX * (pgData->xScanAdjust);
            }

            //
            // draw 1 scan line
            //

            PULONG pulDstX  =  pulBuffer;
            PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;

            while (pulDstX != pulEndX)
            {
                *pulDstX = (ULONG)(((clrA.b[6]) << 24) |
                                   ((clrR.b[6]) << 16) |
                                   ((clrG.b[6]) << 8)  |
                                   ((clrB.b[6])));

                clrR.ullColor += lldRdX;
                clrG.ullColor += lldGdX;
                clrB.ullColor += lldBdX;
                clrA.ullColor += lldAdX;

                pulDstX++;
            }

            //
            // replicate
            //

            PULONG pulDstY = (PULONG)pjDst + pgData->ptDraw.x;
            PULONG pulEndY = (PULONG)((PBYTE)pulDstY + lDelta * cyClip);

            while (pulDstY != pulEndY)
            {
                memcpy(pulDstY,pulBuffer,4*pgData->szDraw.cx);
                pulDstY = (PULONG)((PBYTE)pulDstY + lDelta);
            }

            FreeTmpBuffer(pulBuffer);
        }
    }
    else
    {
        clrR.ullColor = pgData->llRed;
        clrG.ullColor = pgData->llGreen;
        clrB.ullColor = pgData->llBlue;
        clrA.ullColor = pgData->llAlpha;

        LONGLONG lldRdY = pgData->lldRdY;
        LONGLONG lldGdY = pgData->lldGdY;
        LONGLONG lldBdY = pgData->lldBdY;
        LONGLONG lldAdY = pgData->lldAdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor += lldRdY * (pgData->yScanAdjust);
            clrG.ullColor += lldGdY * (pgData->yScanAdjust);
            clrB.ullColor += lldBdY * (pgData->yScanAdjust);
            clrA.ullColor += lldAdY * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(((clrA.b[6]) << 24) |
                               ((clrR.b[6]) << 16) |
                               ((clrG.b[6]) << 8)  |
                               ((clrB.b[6])));

            RtlFillMemoryUlong(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRdY;
            clrG.ullColor += lldGdY;
            clrB.ullColor += lldBdY;
            clrA.ullColor += lldAdY;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB32RGB
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32RGB(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrA;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pjDst     = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;
        PULONG   pulBuffer = (PULONG)AllocFreeTmpBuffer(4 * pgData->szDraw.cx);

        if (pulBuffer)
        {
            LONGLONG lldRed   = pgData->lldRdX;
            LONGLONG lldGreen = pgData->lldGdX;
            LONGLONG lldBlue  = pgData->lldBdX;

            //
            // adjust gradient fill for clipped portion
            //

            if (pgData->xScanAdjust > 0)
            {
                clrR.ullColor += lldRed   * (pgData->xScanAdjust);
                clrG.ullColor += lldGreen * (pgData->xScanAdjust);
                clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
            }

            //
            // draw 1 scan line to temp buffer
            //

            PULONG pulDstX  =  pulBuffer;
            PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;

            while (pulDstX != pulEndX)
            {
                *pulDstX = (ULONG)(
                           ((clrR.b[6]))        |
                           ((clrG.b[6]) << 8) |
                           ((clrB.b[6]) << 16));

                clrR.ullColor += lldRed;
                clrG.ullColor += lldGreen;
                clrB.ullColor += lldBlue;

                pulDstX++;
            }

            //
            // replicate
            //

            PULONG pulDstY = (PULONG)pjDst + pgData->ptDraw.x;
            PULONG pulEndY = (PULONG)((PBYTE)pulDstY + lDelta * cyClip);

            while (pulDstY != pulEndY)
            {
                memcpy(pulDstY,pulBuffer,4*pgData->szDraw.cx);
                pulDstY = (PULONG)((PBYTE)pulDstY + lDelta);
            }

            FreeTmpBuffer(pulBuffer);
        }
    }
    else
    {
        LONGLONG     lldRed   = pgData->lldRdY;
        LONGLONG     lldGreen = pgData->lldGdY;
        LONGLONG     lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(
                       ((clrR.b[6])      ) |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6]) << 16));

            RtlFillMemoryUlong(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }
}

/**************************************************************************\
* vFillGRectDIB32Bitfields
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    2/18/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vFillGRectDIB32Bitfields(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG      lDelta = pSurfDst->lDelta();
    LONG      cyClip = pgData->szDraw.cy;
    XEPALOBJ *ppalDstSurf   = pgData->ppalDstSurf;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PULONG pulDstX  =  (PULONG)pDst + pgData->ptDraw.x;
        PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;
        PULONG pulScanX =  pulDstX;
        PBYTE  pScan    = (PBYTE)pulDstX;

        while (pulDstX != pulEndX)
        {
            ULONG ulPix = (ULONG)(
                       ((clrR.b[6]  ))      |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6] ) << 16));

            *pulDstX = ppalDstSurf->ulGetMatchFromPalentry(ulPix);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pulDstX++;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pulScanX,4*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(
                       ((clrR.b[6]))      |
                       ((clrG.b[6]) << 8) |
                       ((clrB.b[6]) << 16));

            ul = ppalDstSurf->ulGetMatchFromPalentry(ul);

            RtlFillMemoryUlong(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }
}


/**************************************************************************\
* vFillGRectDIB24Bitfields
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vFillGRectDIB32Bitfields
*
\**************************************************************************/
VOID
vFillGRectDIB24Bitfields(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG      lDelta = pSurfDst->lDelta();
    LONG      cyClip = pgData->szDraw.cy;
    XEPALOBJ *ppalDstSurf   = pgData->ppalDstSurf;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PBYTE pbDstX  =  pDst + pgData->ptDraw.x*3;
        PBYTE pbEndX  =  pbDstX + pgData->szDraw.cx*3;
        PBYTE pbScanX =  pbDstX;
        PBYTE  pScan    = pbDstX;

        while (pbDstX != pbEndX)
        {
            ULONG ulPix = (ULONG)(
                       ((clrR.b[6]  ))      |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6] ) << 16));

            ulPix = ppalDstSurf->ulGetMatchFromPalentry(ulPix);

            *pbDstX     = ((PBYTE)&ulPix)[0];
            *(pbDstX+1) = ((PBYTE)&ulPix)[1];
            *(pbDstX+2) = ((PBYTE)&ulPix)[2];

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pbDstX += 3;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pbScanX,3*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            PBYTE pTemp = pDst;
            PBYTE pEnd  = pDst + 3 * pgData->szDraw.cx;

            ULONG ul = (ULONG)(
                       ((clrR.b[6]))      |
                       ((clrG.b[6]) << 8) |
                       ((clrB.b[6]) << 16));

            ul = ppalDstSurf->ulGetMatchFromPalentry(ul);

            while(pTemp != pEnd) 
            {
                *pTemp     = ((PBYTE)&ul)[0];
                *(pTemp+1) = ((PBYTE)&ul)[1];
                *(pTemp+2) = ((PBYTE)&ul)[2];

                pTemp += 3;
            }

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }
}
/******************************Public*Routine******************************\
* vFillGRectDIB24BGR
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB24BGR(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        PBYTE  pBuffer = (PBYTE)AllocFreeTmpBuffer(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            if (pBuffer)
            {
                PBYTE  pDstX  =  pBuffer;
                PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;

                while (pDstX != pLast)
                {
                    *pDstX     =  (clrB.b[6]);
                    *(pDstX+1) =  (clrG.b[6]);
                    *(pDstX+2) =  (clrR.b[6]);

                    clrR.ullColor += lldRed;
                    clrG.ullColor += lldGreen;
                    clrB.ullColor += lldBlue;

                    pDstX+=3;
                }

                //
                // Replicate the scan line. It would be much better to write the scan line
                // out to a memory buffer for drawing to a device surface
                //

                PBYTE  pDst   = (PBYTE)pSurfDst->pvScan0() +
                                            lDelta * pgData->ptDraw.y +
                                            3 * pgData->ptDraw.x;

                while (cyClip--)
                {
                    memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                    pDst += lDelta;
                }

                FreeTmpBuffer(pBuffer);
            }
        }
    }
    else
    {
        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;

            while (pTemp != pEnd)
            {
                *pTemp     = clrB.b[6];
                *(pTemp+1) = clrG.b[6];
                *(pTemp+2) = clrR.b[6];
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            //
            // inc pointer to next scan line
            //

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB24RGB
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    08/28/2000 Pravin Santiago [pravins]. Adapted from vFillGrectDIB24BGR
*
\**************************************************************************/

VOID
vFillGRectDIB24RGB(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG    lDelta = pSurfDst->lDelta();
    LONG    cyClip = pgData->szDraw.cy;

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);
        }

        PBYTE  pBuffer = (PBYTE)AllocFreeTmpBuffer(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            if (pBuffer)
            {
                PBYTE  pDstX  =  pBuffer;
                PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;

                while (pDstX != pLast)
                {
                    *pDstX     =  (clrR.b[6]);
                    *(pDstX+1) =  (clrG.b[6]);
                    *(pDstX+2) =  (clrB.b[6]);

                    clrR.ullColor += lldRed;
                    clrG.ullColor += lldGreen;
                    clrB.ullColor += lldBlue;

                    pDstX+=3;
                }

                //
                // Replicate the scan line. It would be much better to write the scan line
                // out to a memory buffer for drawing to a device surface
                //

                PBYTE  pDst   = (PBYTE)pSurfDst->pvScan0() +
                                            lDelta * pgData->ptDraw.y +
                                            3 * pgData->ptDraw.x;

                while (cyClip--)
                {
                    memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                    pDst += lDelta;
                }

                FreeTmpBuffer(pBuffer);
            }
        }
    }
    else
    {
        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust);
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;

            while (pTemp != pEnd)
            {
                *pTemp     = clrR.b[6];
                *(pTemp+1) = clrG.b[6];
                *(pTemp+2) = clrB.b[6];
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            //
            // inc pointer to next scan line
            //

            pDst += lDelta;
        }
    }
}
/******************************Public*Routine******************************\
* vFillGRectDIB16_565
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_565(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG lldxRed   = pgData->lldRdX;
    LONGLONG lldxGreen = pgData->lldGdX;
    LONGLONG lldxBlue  = pgData->lldBdX;

    LONGLONG lldyRed   = pgData->lldRdY;
    LONGLONG lldyGreen = pgData->lldGdY;
    LONGLONG lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScan;
        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);


        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        xScan           = pgData->ptDraw.x + xDitherOrg;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_6[((clrG.ul[1] >> (2)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            *pusDstX = rgb565(iRed,iGreen,iBlue);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan++;

        pDst += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_555
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vFillGRectDIB16_555(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;

    while(yScan < yScanBottom)
    {
        PUSHORT   pusDstX;
        PUSHORT   pusDstScanRight,pusDstScanLeft;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        LONG      xScan;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        xScan           = pgData->ptDraw.x + pgData->ptDitherOrg.x;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {

            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_5[((clrG.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            *pusDstX = rgb555(iRed,iGreen,iBlue);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan  ++;
        pDst   += lDelta;
    }
}

/**************************************************************************\
* vFillGRectDIB16Bitfields
*
*   Run gradient at 16bpp and use 555 dither
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    2/18/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16Bitfields(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG  lldxRed   = pgData->lldRdX;
    LONGLONG  lldxGreen = pgData->lldGdX;
    LONGLONG  lldxBlue  = pgData->lldBdX;

    LONGLONG  lldyRed   = pgData->lldRdY;
    LONGLONG  lldyGreen = pgData->lldGdY;
    LONGLONG  lldyBlue  = pgData->lldBdY;

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    PULONG   pulDither;

    XEPALOBJ *ppalDstSurf = pgData->ppalDstSurf;

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScan;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        xScan           = pgData->ptDraw.x + pgData->ptDitherOrg.x;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_5[((clrG.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            //
            // convert to 8 bit RGB for translation to bitfields
            //

            ULONG ulTemp = (iRed   << (    3)) |
                           (iGreen << (8  +3)) |
                           (iBlue  << (8+8+3));

            *pusDstX = (USHORT)ppalDstSurf->ulGetMatchFromPalentry(ulTemp);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB8
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB8(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    XLATEOBJ *pxlo = pgData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;

    //
    // either use default palette or halftone palette dither
    //

    if (((XEPALOBJ) (((XLATE *) pxlo)->ppalDstDC)).bIsHalftone())
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
            pDitherMatrix    = gDitherMatrix16x16Default;
            pSaturationTable = DefaultSaturationTable;
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    xDitherOrg = pgData->ptDitherOrg.x;
    LONG    yDitherOrg = pgData->ptDitherOrg.y;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        PBYTE   pjDstScanRight;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        pjDstX   = pDst + pgData->ptDraw.x;

        LONG     xScan       = pgData->ptDraw.x;
        LONG     xScanRight  = xScan + pgData->szDraw.cx;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan + yDitherOrg) & DITHER_8_MASK_Y))];

        while (xScan < xScanRight)
        {
            //
            // calculate x component of dither
            //

            BYTE jDitherMatrix = *(pDitherLevel + ((xScan + xDitherOrg) & DITHER_8_MASK_X));

            ULONG  iRed   = pSaturationTable[clrR.b[6] + jDitherMatrix];
            ULONG  iGreen = pSaturationTable[clrG.b[6] + jDitherMatrix];
            ULONG  iBlue  = pSaturationTable[clrB.b[6] + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            *pjDstX = jIndex;

            pjDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB4
*
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB4(
    SURFACE          *pSurfDst,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pSurfDst->lDelta();
    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG lldxRed   = pgData->lldRdX;
    LONGLONG lldxGreen = pgData->lldGdX;
    LONGLONG lldxBlue  = pgData->lldBdX;

    LONGLONG lldyRed   = pgData->lldRdY;
    LONGLONG lldyGreen = pgData->lldGdY;
    LONGLONG lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    XLATEOBJ *pxlo = pgData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;

    //
    // determine DC to surface palette translate
    //

    if (((XLATE *) pxlo)->flPrivate & XLATE_PAL_MANAGED)
    {
        if (((XLATE *) pxlo)->ppalDstDC == ppalDefault)
        {
            pjVector = &defaultTranslate.ajVector[0];
        }
        else
        {
            if (((XLATE *) pxlo)->flPrivate & XLATE_USE_CURRENT)
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransCurrent->ajVector[0];
            }
            else
            {
                pjVector = &((XLATE *) pxlo)->ppalDstDC->ptransFore->ajVector[0];
            }
        }
    }
    else
    {
        pjVector = vTranslateIdentity;
    }

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan + yDitherOrg) & DITHER_8_MASK_Y))];

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x/2;

        LONG     xScan       = pgData->ptDraw.x;
        LONG     xScanRight  = xScan + pgData->szDraw.cx;

        while (xScan < xScanRight)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix;


            jDitherMatrix = *(pDitherLevel + ((xScan + xDitherOrg) & DITHER_8_MASK_X));

            ULONG iRed   = pSaturationTable[clrR.b[6] + jDitherMatrix];
            ULONG iGreen = pSaturationTable[clrG.b[6] + jDitherMatrix];
            ULONG iBlue  = pSaturationTable[clrB.b[6] + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            if (xScan & 1)
            {
                *pjDstX = (*pjDstX & 0xf0) | jIndex;
                pjDstX++;
            }
            else
            {
                *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
            }

            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB1
*
*   Fill gradient rect
*
* Arguments:
*
*   pSurfDst - destination surface
*   pgData   - gradient rect data
*
* Return Value:
*
*   None
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB1(
   SURFACE          *pSurfDst,
   PGRADIENTRECTDATA pgData
   )
{
    LONG     lDelta = pSurfDst->lDelta();

    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;

    LONG     yScan  = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    PBYTE    pDst   = (PBYTE)pSurfDst->pvScan0() + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values. PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    XLATEOBJ *pxlo  = pgData->pxlo;
    PBYTE    pxlate = NULL;
    PBYTE    pjVector         = vTranslateIdentity;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;

    //
    // get/build rgb555 to palette table
    //

    pxlate = XLATEOBJ_pGetXlate555(pxlo);

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue;

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust);
        lleGreen += lldyGreen * (pgData->yScanAdjust);
        lleBlue  += lldyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    ixDst;

        LONG    cx = cxClip;
        LONG    xScanLeft  = pgData->ptDraw.x;
        LONG    xScanRight = xScanLeft + cx;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan + yDitherOrg) & DITHER_8_MASK_Y))];

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust);
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust);
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust);
        }

        pjDstX = pDst + pgData->ptDraw.x/8;
        ixDst  = pgData->ptDraw.x & 7;

        while (xScanLeft < xScanRight)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft + xDitherOrg) & DITHER_8_MASK_X)));

            ULONG   iRed   = (ULONG)(clrR.b[6]);
            ULONG   iGreen = (ULONG)(clrG.b[6]);
            ULONG   iBlue  = (ULONG)(clrB.b[6]);

            //
            // add dither and saturate. 1bpp non-optimized
            //

            iRed   = iRed   + jDitherMatrix;

            if (iRed >= 255)
            {
                iRed = 255;
            }
            else
            {
                iRed = 0;
            }

            iGreen = iGreen + jDitherMatrix;

            if (iGreen >= 255)
            {
                iGreen = 255;
            }
            else
            {
                iGreen = 0;
            }

            iBlue  = iBlue  + jDitherMatrix;

            if (iBlue >= 255)
            {
                iBlue = 255;
            }
            else
            {
                iBlue = 0;
            }

            BYTE  jIndex;

            //
            // pjVector is known to be identity, so could make new macro for
            // palette_match_1 if perf ever an issue
            //

            GRAD_PALETTE_MATCH(jIndex,pjVector,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            LONG iShift  = 7 - ixDst;
            BYTE OrMask = 1 << iShift;
            BYTE AndMask  = ~OrMask;

            jIndex = jIndex << iShift;

            *pjDstX = (*pjDstX & AndMask) | jIndex;

            ixDst++;

            if (ixDst == 8)
            {
                ixDst = 0;
                pjDstX++;
            }

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;

            xScanLeft++;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\helpers.cxx ===
/******************************Module*Header*******************************\
* Module Name: HELPERS.CXX                                                *
*                                                                         *
* Hydra routines                                                          *
* For Display drivers                                                     *
*                                                                         *
* Copyright (c) 1997-1999 Microsoft                                            *
\**************************************************************************/

#include "precomp.hxx"
extern "C" {

#include "pw32kevt.h"

#include <ctxdd.h>

}

#include <winDDIts.h>

#if !defined(_GDIPLUS_)

/******************************Public*Routine******************************\
* EngGetTickCount
*
* Return the system tick count
*
\**************************************************************************/


DWORD APIENTRY
EngGetTickCount()
{
    return( NtGetTickCount());
}



/******************************Public*Routine******************************\
* EngFileWrite
*
* Write to File Object
*
\**************************************************************************/

VOID APIENTRY
EngFileWrite( HANDLE hFileObject, PVOID Buffer, ULONG BufferSize, PULONG pBytesWritten )
{
    NTSTATUS Status;

    Status = CtxWriteFile( (PFILE_OBJECT)hFileObject, Buffer, BufferSize, NULL, NULL, NULL );

    if ( !NT_SUCCESS(Status) )
        *pBytesWritten = 0;
    else
        *pBytesWritten = BufferSize;
}

/******************************Public*Routine******************************\
* EngFileIoControl
*
* IoControl to File Object
*
\**************************************************************************/
DWORD
APIENTRY
EngFileIoControl(
    HANDLE hFileObject,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    Status = CtxDeviceIoControlFile(
                                     (PFILE_OBJECT)hFileObject,
                                     dwIoControlCode,
                                     lpInBuffer,
                                     nInBufferSize,
                                     lpOutBuffer,
                                     nOutBufferSize,
                                     FALSE,
                                     NULL,
                                     &Iosb,
                                     NULL );
    *lpBytesReturned = (DWORD) Iosb.Information;

    return Status;
}

#endif // !defined(_GDIPLUS_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\guids.c ===
/******************************Module*Header*******************************\
* Module Name: guids.c
*
* This file contains the actual data declarations for all GUIDs used by
* GDI and device drivers.
*
* Created: 15-Feb-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

#define GUID_DEFS_ONLY
#define INITGUID
#include <guiddef.h>
#include <ddrawint.h>
#include <dxmini.h>
#include <dvp.h>
#include <agp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\grerc.h ===
/*********************************************************************************
 * grerc.h
 *
 * This file contains definitions for the font script names stored in the grerc
 * resource file.
 *
 * History:0
 *  3-6-95 22:30:00 Gerrit van Wingerden [gerritv]
 * Wrote it. 
 *
 * Copyright (c) 1995-1999 Microsoft Corporation
 ********************************************************************************/

#define SCRIPT_WESTERN           0 
#define SCRIPT_SYMBOL            1
#define SCRIPT_MAC               2 
#define SCRIPT_JAPANESE          3 
#define SCRIPT_HANGEUL           4 
#define SCRIPT_HANGEUL_JOHAB     5 
#define SCRIPT_CHINESE_GB2312    6 
#define SCRIPT_CHINESE_BIG5      7 
#define SCRIPT_GREEK             8 
#define SCRIPT_TURKISH           9 
#define SCRIPT_VIETNAMESE        10
#define SCRIPT_HEBREW            11
#define SCRIPT_ARABIC            12
#define SCRIPT_BALTIC            13
#define SCRIPT_CYRILLIC          14
#define SCRIPT_THAI              15
#define SCRIPT_CENTRAL_EUROPE    16
#define SCRIPT_OEM_DOS           17
#define SCRIPT_UNKNOWN           18

#define NUMBER_OF_SCRIPTS        SCRIPT_UNKNOWN + 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\hmgr.h ===
/******************************Module*Header*******************************\
* Module Name: hmgr.h
*
* This file contains all the prototypes for the handle mangager.
*
* Added nifty header: 29-Jun-1991 16:31:46
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

//#include "hmgshare.h"

//          <-fulltype->
//   <---full unique--->
// +-+------+-+--+-----+----------------+
// |u|unique|s|al|type |     index      |
// +-+------+-+--+-----+----------------+
//  ^        ^ ^^
//  +user    | ||
//           | ||
//           | ++alternate type for client (pen, metafile, dibsection)
//           |
//           +stock object
//
// USER       - bit(s) reserved for USER, not used for comparing identical handles
//
// TYPE       - types used by GRE
// ALTTYPE    - extra type bits used by client
// STOCK      - bit indicating stockobject
// FULLTYPE   - all bits related to type that are per object (includes STOCK bit)
//
// UNIQUE     - bits that are incremented for each instance of the handle
// FULLUNIQUE - bits used for comparing identical handles.  This includes FULLTYPE
//
// INDEX      - index into server side handle table
//
// The handle index points into a big array of entries.  This index is
// broken down into 'page' and 'entry' fields.
// This is to prevent having to have the entire handle table created at
// once.  If all the handles in a page are in use and no free handles are
// available, a new page is faulted in for use.

// all the commented defines below live in ntgdistr.h.

#define LOTYPE_BITS         (TYPE_BITS + ALTTYPE_BITS)
#define FULLTYPE_BITS       (TYPE_BITS + ALTTYPE_BITS + STOCK_BITS)
#define FULLUNIQUE_BITS     (TYPE_BITS + ALTTYPE_BITS + STOCK_BITS + UNIQUE_BITS)
#define NONINDEX_BITS       (32 - INDEX_BITS)

#define INDEX_SHIFT         0
#define UNIQUE_SHIFT        (STOCK_SHIFT + STOCK_BITS)
#define LOTYPE_SHIFT        (TYPE_SHIFT)
#define FULLTYPE_SHIFT      (TYPE_SHIFT)
#define FULLUNIQUE_SHIFT    (TYPE_SHIFT)

//MASKS contain the bits of the handle used for the paricular field

#define NONINDEX_MASK(shift,cbits)  ( ((1 << (cbits)) - 1)  << (shift) )

#define INDEX_MASK          ((1 << INDEX_BITS) - 1)
#define TYPE_MASK           (NONINDEX_MASK(TYPE_SHIFT,      TYPE_BITS))
#define ALTTYPE_MASK        (NONINDEX_MASK(ALTTYPE_SHIFT,   ALTTYPE_BITS))
#define STOCK_MASK          (NONINDEX_MASK(STOCK_SHIFT,     STOCK_BITS))
#define UNIQUE_MASK         (NONINDEX_MASK(UNIQUE_SHIFT,    UNIQUE_BITS))
#define LOTYPE_MASK         (NONINDEX_MASK(LOTYPE_SHIFT,    LOTYPE_BITS))
#define FULLTYPE_MASK       (NONINDEX_MASK(FULLTYPE_SHIFT,  FULLTYPE_BITS))

// NOTE that UNIQUE_INCREMENT is based on the uniqueness beeing a short, not a full handle

#define UNIQUE_INCREMENT    (1 << (UNIQUE_SHIFT - INDEX_BITS))

#define MODIFY_HMGR_TYPE(h,t)          ((HANDLE)((ULONG_PTR)(h) | (t)))

#define HmgIfromH(h)          (ULONG)((ULONG_PTR)(h) & INDEX_MASK)
#define HmgUfromH(h)          ((USHORT) (((ULONG_PTR)(h) & FULLUNIQUE_MASK) >> TYPE_SHIFT))
#define HmgObjtype(h)         ((OBJTYPE)(((ULONG_PTR)(h) & TYPE_MASK)       >> TYPE_SHIFT))
#define HmgStockObj(hobj)     ((ULONG_PTR)(hobj) & STOCK_MASK)

// given a usUnique and a type, modify it to contain a new type

#define USUNIQUE(u,t) (USHORT)((u & (UNIQUE_MASK >> INDEX_BITS)) | \
                               (t << (TYPE_SHIFT - INDEX_BITS)))

//
// WOW has a dependency on the index portion of returned 32-bit GDI
// handles being greater than (COLOR_ENDCOLORS >> 2)
// (COLOR_ENDCOLORS is defined in winuserp.h).
//
// This dependency allows WOW to distinguish between a 16-bit HBRUSH
// and a COLOR_* constant.
//
// Therefore, we will will reserve the first few entries of the handle
// table, disallowing the use of any index less than HMGR_HANDLE_BASE.
//
//                                        hideyukn, 1997.Oct.27
//

#define HMGR_HANDLE_BASE  0x000a

ULONG       FASTCALL HmgQueryLock(HOBJ hobj);
BOOL        FASTCALL HmgSetLock(HOBJ hobj, ULONG cLock);
ULONG       FASTCALL HmgQueryAltLock(HOBJ hobj);
BOOL                 HmgCreate();
HOBJ                 HmgAlloc(ULONGSIZE_T,OBJTYPE,USHORT);
POBJ                 HmgReplace(HOBJ,POBJ,FLONG,LONG,OBJTYPE);
VOID                 HmgFree(HOBJ);

POBJ        FASTCALL HmgLock(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgLockAllOwners(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareLock(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareCheckLock(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareLockIgnoreStockBit(HOBJ,OBJTYPE);
POBJ        FASTCALL HmgShareCheckLockIgnoreStockBit(HOBJ,OBJTYPE);

BOOL                 HmgSetOwner(HOBJ,W32PID,OBJTYPE);
BOOL                 HmgSwapHandleContents(HOBJ,ULONG,HOBJ,ULONG,OBJTYPE);
BOOL                 HmgSwapLockedHandleContents(HOBJ,ULONG,HOBJ,ULONG,OBJTYPE);
POBJ        FASTCALL HmgReferenceCheckLock(HOBJ h,OBJTYPE ot, BOOL bDebugPrint);
HOBJ        FASTCALL HmgNextOwned(HOBJ,W32PID);
POBJ        FASTCALL HmgSafeNextObjt(HOBJ hobj, OBJTYPE objt);
BOOL                 HmgValidHandle(HOBJ, OBJTYPE);
HOBJ        FASTCALL HmgSafeNextOwned(HOBJ,W32PID);
BOOL        FASTCALL HmgMarkUndeletable(HOBJ,OBJTYPE);
BOOL        FASTCALL HmgMarkDeletable(HOBJ,OBJTYPE);
HOBJ                 HmgInsertObject(PVOID,FLONG,OBJTYPE);
PVOID                HmgRemoveObject(HOBJ,LONG,LONG,BOOL,OBJTYPE);
OBJTYPE *            HmgSetNULLType(HOBJ,LONG,LONG,OBJTYPE);
HOBJ                 HmgModifyHandleType(HOBJ  h);
BOOL                 HmgLockAndModifyHandleType(HOBJ h);

PVOID                HmgAllocateSecureUserMemory();
PDC_ATTR             HmgAllocateDcAttr();
POBJECTATTR          HmgAllocateObjectAttr();
VOID                 HmgFreeDcAttr(PDC_ATTR);
VOID                 HmgFreeObjectAttr(POBJECTATTR);
BOOL                 bPEBCacheHandle(HANDLE,HANDLECACHETYPE,POBJECTATTR,PENTRY);
BOOL                 bLoadProcessHandleQuota();



HOBJ                 HmgIncUniqueness(HOBJ  hobj, OBJTYPE objt);
VOID        FASTCALL HmgIncrementShareReferenceCount(POBJ);
ULONG       FASTCALL HmgDecrementShareReferenceCount(POBJ);
VOID                 HmgShareUnlock(POBJ pobj);
BOOL        FASTCALL HmgInterlockedCompareAndSwap(PULONG,ULONG,ULONG);

PVOID                HmgForceRemoveObject(HOBJ hobj,BOOL bIgnoreUndeletable, OBJTYPE objt);

BOOL                 HmgIncProcessHandleCount(W32PID,OBJTYPE);
VOID                 HmgDecProcessHandleCount(W32PID);

#define HMGR_ALLOC_LOCK         0x0001
#define HMGR_ALLOC_ALT_LOCK     0x0002
#define HMGR_NO_ZERO_INIT       0x0004
#define HMGR_MAKE_PUBLIC        0x0008

#define MAXIMUM_POOL_ALLOC (PAGE_SIZE * 10000)

// Global Handle Manager data.

extern HSEMAPHORE ghsemHmgr;
extern ENTRY     *gpentHmgr;
extern HOBJ       ghFreeHmgr;
extern ULONG      gcMaxHmgr;
extern PLARGE_INTEGER gpLockShortDelay;
extern ULONG gCacheHandleEntries[GDI_CACHED_HADNLE_TYPES];
extern LONG  gProcessHandleQuota;

// DirectDraw Handle Manager data: externed here for debugger extensions

extern ULONG      gcSizeDdHmgr;
extern ENTRY     *gpentDdHmgr;
extern HOBJ       ghFreeDdHmgr;
extern ULONG      gcMaxDdHmgr;

//
// SAMEHANDLE and DIFFHANDLE have moved to wingdip.h so other server-side
// components can safely compare engine handles.  They validate all but USER bits
//

#define SAMEINDEX(H,K) (((((ULONG_PTR) (H)) ^ ((ULONG_PTR) (K))) & INDEX_MASK) == 0)

/*********************************MACRO************************************\
*  INC_EXCLUSIVE_REF_CNT - increment object's exclusive reference count
*  DEC_EXCLUSIVE_REF_CNT - decrement object's exclusive reference count
*
*  Note that the InterlockedIncrement/Decrement treats the cExclusiveLock
*  as a ULONG. cExclusiveLock is declared as a USHORT and the increment 
*  overlaps with the BASEOBJECT::BaseFlags. If the BaseFlags were ever changed,
*  this code may have to be changed to use an InterlockedCompareExchange loop.
*  See BASEOBJECT declaration.
*
*
* Arguments:
*
*   pObj - pointer to object
*
* Return Value:
*
*   None
*
\**************************************************************************/

#define INC_EXCLUSIVE_REF_CNT(pObj) InterlockedIncrement((LONG *)& (((POBJ) pObj)->cExclusiveLock))
#define DEC_EXCLUSIVE_REF_CNT(pObj) InterlockedDecrement((LONG *)& (((POBJ) pObj)->cExclusiveLock))

/********************************MACRO*************************************\
* INC_SHARE_REF_CNT - do an interlocked increment of the
*   shared reference count of the given object.
*
* DEC_SHARE_REF_CNT - do an interlocked decrement of the
*   shared reference count of the given object.
*
* Arguments:
*
*   pObj - pointer to OBJECT
*
* Return Value:
*
*   HmgIncrementShareReferenceCount : None
*   HmgDecrementShareReferenceCount : Original shared reference count
*
\**************************************************************************/

#define PENTRY_FROM_POBJ(pObj)                                          \
    (&gpentHmgr[(UINT)HmgIfromH(((POBJ)(pObj))->hHmgr)])


#define INC_SHARE_REF_CNT(pObj)                                         \
    HmgIncrementShareReferenceCount((POBJ) (pObj))


#define DEC_SHARE_REF_CNT(pObj)                                         \
    HmgDecrementShareReferenceCount((POBJ) (pObj))



/*********************************MACRO************************************\
*
* DEC_SHARE_REF_CNT_LAZY0 - Interlocked decrement the shared reference
*   count of the given object. If the original count was 1, and the
*   object's TO_BE_DELETED flag is set, then call the object deletion
*   routine
*
* Arguments:
*
*   pObj - pointer to object
*
* Return Value:
*
*   None
*
\**************************************************************************/

#define DEC_SHARE_REF_CNT_LAZY0(pObj)                              \
{                                                                  \
    PBRUSHATTR pBrushattr = ((PBRUSH)pObj)->pBrushattr();          \
                                                                   \
    if (1 == (DEC_SHARE_REF_CNT(pObj) & 0xffff))                   \
    {                                                              \
        if ((pBrushattr->AttrFlags) & ATTR_TO_BE_DELETED)          \
        {                                                          \
            bDeleteBrush ((HBRUSH) pObj->hHmgr,FALSE);             \
        }                                                          \
    }                                                              \
}

/*********************************MACRO************************************\
*
* DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT
*   count of the given object. If the original count was 1, and the
*   object's TO_BE_DELETED flag is set, then call the object deletion
*   routine
*
* Arguments:
*
*   pObj - pointer to object
*
* Return Value:
*
*   None
*
\**************************************************************************/


#define DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(pObj)                          \
{                                                                         \
  if (1 == (DEC_SHARE_REF_CNT(pObj) & 0xffff))                            \
  {                                                                       \
    if (PENTRY_FROM_POBJ(pObj)->Flags & HMGR_ENTRY_LAZY_DEL)  \
    {                                                                     \
      bDeleteFont ((HLFONT) pObj->hHmgr,FALSE);                           \
    }                                                                     \
  }                                                                       \
}


#define DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(pObj)                       \
{                                                                         \
  DEC_SHARE_REF_CNT(pObj);                                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\htblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: htblt.cxx
*
* Contains routine to halftone a bitmap.  This path is used when a
* StretchBlt or PlgBlt is called with StretchBltMode == HALFTONE.
*
* Created: 18-Nov-1991 16:06:47
* Author: Wendy Wu [wendywu]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if ((PRIMARY_ORDER_ABC != PRIMARY_ORDER_123)             || \
     (PRIMARY_ORDER_ACB != PRIMARY_ORDER_132)             || \
     (PRIMARY_ORDER_BAC != PRIMARY_ORDER_213)             || \
     (PRIMARY_ORDER_BCA != PRIMARY_ORDER_231)             || \
     (PRIMARY_ORDER_CAB != PRIMARY_ORDER_312)             || \
     (PRIMARY_ORDER_CBA != PRIMARY_ORDER_321))
#error * PRIMARY_ORDER different in winddi.h and ht.h *
#endif

/*****************************Private*Function*****************************\
* bSetHTSrcSurfInfo
*
* Initialise the HTSURFACEINFO structure.  The structure is alloacted
* elsewhere,  we simply fill it in given the nature of the surface
* required for drawing.  Used by source surface only.
*
* History:
*  18-Nov-1991 -by- Wendy Wu [wendywu]
* Stole from gdi\printers\rasdd\stretch.c.
\**************************************************************************/

BOOL bSetHTSrcSurfInfo(
SURFOBJ         *pSurfObj,
XEPALOBJ         palSrc,
HTSURFACEINFO   *pHTSurfInfo,
XLATEOBJ        *pxlo
)
{
    COUNT cMaxPalEntries;
    BYTE  cBytesPerEntry;
    BOOL  bBitFields;

    ASSERTGDI(palSrc.bValid(),"bhtBlt: invalid src pal\n");
    bBitFields = palSrc.bIsBitfields();

    switch (pSurfObj->iBitmapFormat)
    {
    case BMF_1BPP:
        cBytesPerEntry = sizeof(ULONG);
        cMaxPalEntries = 2;
        break;

    case BMF_4BPP:
        cBytesPerEntry = sizeof(ULONG);
        cMaxPalEntries = 16;
        break;

    case BMF_8BPP:
        cBytesPerEntry = sizeof(ULONG);
        cMaxPalEntries = 256;
        break;

    case BMF_16BPP:
        cBytesPerEntry = 2;
        cMaxPalEntries = 3;
        bBitFields = TRUE;
        break;

    case BMF_24BPP:
        cBytesPerEntry = 3;
        cMaxPalEntries = 0;
        break;

    case BMF_32BPP:
        cBytesPerEntry = 4;
        cMaxPalEntries = 3;
        bBitFields = TRUE;
        break;

    default:
        WARNING("This bitmap format is not implemented");
        return(FALSE);
    }

    //
    // The halftone now taking ScanLineDelta rather than compute the scanline
    // delta by itself, because many driver fake the pvBits, pvScan0 and
    // scanline delta for creating smaller surface and that sometime cause
    // halftone to break, to do this we passed to halftone ScanLineDelta and
    // (from lDelta in SURFOBJ) and pvScan0.
    //

    HTSURFACEINFO   HTSurfInfo;

    HTSurfInfo.hSurface               = (ULONG_PTR)pSurfObj;
    HTSurfInfo.SurfaceFormat          = (BYTE)pSurfObj->iBitmapFormat;
    HTSurfInfo.ScanLineAlignBytes     = BMF_ALIGN_DWORD;
    HTSurfInfo.Width                  = pSurfObj->sizlBitmap.cx;
    HTSurfInfo.Height                 = pSurfObj->sizlBitmap.cy;
    HTSurfInfo.ScanLineDelta          = pSurfObj->lDelta;
    HTSurfInfo.pPlane                 = (LPBYTE)pSurfObj->pvScan0;

    HTSurfInfo.Flags = (USHORT)((pSurfObj->fjBitmap & BMF_TOPDOWN) ?
                                                HTSIF_SCANLINES_TOPDOWN : 0);

    COUNT cPalEntries = bBitFields ? 3 : palSrc.cEntries();

    if (cPalEntries > cMaxPalEntries)
        cPalEntries = cMaxPalEntries;

    if (HTSurfInfo.pColorTriad = (PCOLORTRIAD)PALLOCNOZ(
                    cPalEntries * sizeof(ULONG) + sizeof(COLORTRIAD),'cthG'))
    {
        PCOLORTRIAD pColorTriad = HTSurfInfo.pColorTriad;

        pColorTriad->Type = COLOR_TYPE_RGB;
        pColorTriad->pColorTable = (LPBYTE)pColorTriad + sizeof(COLORTRIAD);
        pColorTriad->PrimaryOrder = PRIMARY_ORDER_RGB;
        // May not be needed by halftoning code, but just to be sure
        pColorTriad->PrimaryValueMax = 0;

        if (palSrc.bIsBGR())
            pColorTriad->PrimaryOrder = PRIMARY_ORDER_BGR;

        if (bBitFields)
        {
        // 16 or 32BPP.

            pColorTriad->BytesPerPrimary = 0;
            pColorTriad->BytesPerEntry = cBytesPerEntry;
            pColorTriad->ColorTableEntries = 3;

            ULONG *pulColors = (ULONG *)pColorTriad->pColorTable;
            if (palSrc.bIsBitfields())
            {
                pulColors[0] = palSrc.flRed();
                pulColors[1] = palSrc.flGre();
                pulColors[2] = palSrc.flBlu();
            }
            else
            {
            // BMF_32BPP, it's not BITFIELD so default to 888

                pulColors[1] = 0x00ff00;
                if (palSrc.bIsBGR())
                {
                    pulColors[0] = 0xff0000;
                    pulColors[2] = 0x0000ff;
                }
                else
                {
                    pulColors[0] = 0x0000ff;
                    pulColors[2] = 0xff0000;
                }
            }
        }
        else
        {
            pColorTriad->BytesPerPrimary = 1;
            pColorTriad->BytesPerEntry = cBytesPerEntry;
            pColorTriad->ColorTableEntries = cPalEntries;
            pColorTriad->PrimaryValueMax = 255;

            if (cPalEntries != 0)
            {
            // Not 24BPP or 32BPP
                // Bug #418345
                // If the source palette is monochrome, then we need to
                // use the foreground and background colors of the DC
                // which have been previously stored for us in the
                // translation object.
                XLATE* pxlate = (XLATE*) pxlo;

                if(palSrc.bIsMonochrome() &&
                   (pxlate->flPrivate & XLATE_FROM_MONO))
                {

                    ULONG *pulColors = (ULONG *)pColorTriad->pColorTable;

                    // WINBUG #235687 bhouse 1-19-2000 DIBINDEX values not handled properly by halftone
                    // When given a monochrome palette with a monochrome translate
                    // we need to be sure to also translate DIBINDEX values appropriately

                    pulColors[0] = ulColorRefToRGB(pxlate->ppalDst, pxlate->ppalDstDC, pxlate->iForeDst);
                    pulColors[1] = ulColorRefToRGB(pxlate->ppalDst, pxlate->ppalDstDC, pxlate->iBackDst);

                }
                else
                {
                    palSrc.ulGetEntries(0, cPalEntries,
                        (PPALETTEENTRY)pColorTriad->pColorTable,FALSE);
                }
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    *pHTSurfInfo = HTSurfInfo;

    return(TRUE);
}

/*****************************Private*Function*****************************\
* bSetHTSurfInfo
*
* Initialise the HTSURFACEINFO structure for destination and mask.
*
* History:
*  14-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL bSetHTSurfInfo(
SURFOBJ         *pSurfObj,
HTSURFACEINFO   *pHTSurfInfo,   // Where data is placed
LONG            iFormatHT)
{
    HTSURFACEINFO   HTSurfInfo;

    //
    // The halftone now taking ScanLineDelta rather than compute the scanline
    // delta by itself, because many driver fake the pvBits, pvScan0 and
    // scanline delta for creating smaller surface and that sometime cause
    // halftone to break, to do this we passed to halftone ScanLineDelta and
    // (from lDelta in SURFOBJ) and pvScan0.
    //

    HTSurfInfo.hSurface               = (ULONG_PTR)pSurfObj;
    HTSurfInfo.SurfaceFormat          = (BYTE)iFormatHT;
    HTSurfInfo.ScanLineAlignBytes     = BMF_ALIGN_DWORD;
    HTSurfInfo.Width                  = pSurfObj->sizlBitmap.cx;
    HTSurfInfo.Height                 = pSurfObj->sizlBitmap.cy;
    HTSurfInfo.ScanLineDelta          = pSurfObj->lDelta;
    HTSurfInfo.pPlane                 = (LPBYTE)pSurfObj->pvScan0;
    HTSurfInfo.Flags = (USHORT)((pSurfObj->fjBitmap & BMF_TOPDOWN) ?
                                                HTSIF_SCANLINES_TOPDOWN : 0);
    HTSurfInfo.pColorTriad = NULL;
    *pHTSurfInfo = HTSurfInfo;

    return(TRUE);
}

/******************************Public*Routine******************************\
* ppalGetFromXlate
*
* The halftoning algorithm needs to know the source palette.  Unfortunately
* the system wasn't designed to preserve that information, but with some
* work we can do it.  This routine starts the process of finding the source
* palette in more of the cases.  This routine will probably be modified
* greatly to get 100% accuracy.  We would need to construct a palette from
* the table of indices given based on the DST palette or DST DC palette (if
* pal managed) and return it.  If this routine starts manufacturing palettes
* it would need to inc the ref count on ones it doesn't create and then when
* done dec the count and delete if 0.  However this would require the rest
* of palette world to use this convention and it all would take a week of
* work.
*
* History:
*  18-Feb-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PPALETTE ppalGetFromXlate(SURFACE *pSurfSrc, SURFACE *pSurfDst,
                          XLATE *pxlo, UINT iPal, BOOL bFirstTime)
{
    ASSERTGDI((iPal == XO_SRCPALETTE) || (iPal == XO_DESTPALETTE), "ERROR invalid type requested");

    //
    // See if the source palette is lying in the source surface like
    // it usually is.
    //

    PPALETTE ppalReturn;

    if (iPal == XO_SRCPALETTE)
    {
        ppalReturn = pSurfSrc->ppal();
    }
    else
    {
        ppalReturn = pSurfDst->ppal();
    }

    if (ppalReturn == NULL)
    {
        //
        // Check xlate is passed in is not NULL and it's really valid.
        // Global ident xlate is not valid, it's just a shell with the
        // accelerators filled in.
        //

        if (pxlo != NULL)
        {
            if (iPal == XO_SRCPALETTE)
            {
                ppalReturn = pxlo->ppalSrc;
            }
            else
            {
                ppalReturn = pxlo->ppalDst;
            }
        }

        if (ppalReturn == NULL)
        {
            //
            // Let's try and grab it out of the PDEV now.
            //

            if (iPal == XO_SRCPALETTE)
            {
                PDEVOBJ po(pSurfSrc->hdev());

                if (po.bValid() && po.bIsPalManaged())
                {
                    if (pSurfSrc->iFormat() == po.iDitherFormat())
                    {
                        ppalReturn = po.ppalSurf();
                    }
                }
            }
            else
            {
                PDEVOBJ po(pSurfDst->hdev());

                if (po.bValid() && !po.bIsPalManaged())
                {
                    if (pSurfDst->iFormat() == po.iDitherFormat())
                    {
                        ppalReturn = po.ppalSurf();
                    }
                }
            }

            if (ppalReturn == NULL)
            {
                if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                {
                    //
                    // Well if we can't figure it out from the source
                    // and it's identity just get it from the destination
                    //

                    if (bFirstTime)
                        ppalReturn = ppalGetFromXlate(pSurfSrc, pSurfDst, pxlo, iPal == XO_SRCPALETTE ? XO_DESTPALETTE : XO_SRCPALETTE, FALSE);
                }
            }
        }
    }

    return(ppalReturn);
}

/******************************Public*Function*****************************\
* EngHTBlt
*
* Stretch/PlgBlt with halftone mode.
*
* History:
*  19-Nov-1991 -by- Wendy Wu [wendywu]
* Adapted from gdi\printers\rasdd\stretch.c.
\**************************************************************************/

int EngHTBlt
(
IN  SURFOBJ         *psoDst,
IN  SURFOBJ         *psoSrc,
IN  SURFOBJ         *psoMask,
IN  CLIPOBJ         *pco,
IN  XLATEOBJ        *pxlo,
IN  COLORADJUSTMENT *pca,
IN  PPOINTL          pptlBrushOrg,
IN  PRECTL           prclDest,
IN  PRECTL           prclSrc,
IN  PPOINTL          pptlMask,
IN  ULONG            uFlags,
IN  BLENDOBJ        *pBlendObj)
{
    PSURFACE pSurfDst  = SURFOBJ_TO_SURFACE(psoDst);
    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMask = SURFOBJ_TO_SURFACE(psoMask);

    HTSURFACEINFO   HTDest;
    HTSURFACEINFO   HTSrc;
    HTSURFACEINFO   HTMask;
    COLORTRIAD      clrtri;
    BYTE            aclr[256];
    LONG            cjDstWidth;

    PDEVOBJ poDst(pSurfDst->hdev());

    if (!poDst.bValid())
        return(HTBLT_NOTSUPPORTED);

// Halftoning will relay on driver's halftone palette and output format,
// even the target surface is not device surface. so that during halftoning,
// we need to prevent happen dynamic mode chage, if the device is display.
// thus we hold devlock here.

    DEVLOCKOBJ dlo;

    if (poDst.bDisplayPDEV())
        dlo.vLock(poDst);
    else
        dlo.vInit();

// iFormatDst:   The format of the destination bitmap.  This is also used for
//               shadow bitmap creation if destination is not an engine bitmap.
// iFormatHT:    The halftone format that we'll pass to HT_HalftoneBitmap.
// iFormatHTPal: The halftone format that we'll use to determine what kind
//               of halftone palette to create.

    ULONG iFormatDst, iFormatHT, iFormatHTPal;

// Determine the halftone and destination bitmap formats.
// If the destination is a DIB, we'll write directly to it unless the halftone
// palette is different from the dest palette.  So the halftone format has
// to be the same as the destination format.
// If the destination is not a DIB, we'll halftone to a shadow bitmap.
// The format of this bitmap can be different from the device format and
// is depending on the halftone format in GDIINFO.

    if (psoDst->iType == STYPE_BITMAP)
    {
        switch(pSurfDst->iFormat())
        {
        case BMF_1BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 31) & ~31) >> 3;
            iFormatHT = iFormatDst = BMF_1BPP;
            iFormatHTPal = HT_FORMAT_1BPP;
            break;
        case BMF_4BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 7) & ~7) >> 1;
            iFormatDst = BMF_4BPP;
            if (poDst.GdiInfo()->ulHTOutputFormat == HT_FORMAT_4BPP)
            {
                iFormatHT = BMF_4BPP;
                iFormatHTPal = HT_FORMAT_4BPP;
            }
            else
            {
                iFormatHT = BMF_4BPP_VGA16;
                iFormatHTPal = HT_FORMAT_4BPP_IRGB;
            }
            break;
        case BMF_8BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 3) & ~3);
            iFormatHT = BMF_8BPP_VGA256;
            iFormatDst = BMF_8BPP;
            iFormatHTPal = HT_FORMAT_8BPP;
            break;
        case BMF_16BPP:
            cjDstWidth = ((psoDst->sizlBitmap.cx + 1) & ~1) << 1;
            iFormatHT = BMF_16BPP_555;
            iFormatDst = BMF_16BPP;
            iFormatHTPal = HT_FORMAT_16BPP;
            break;
        case BMF_24BPP:
            cjDstWidth = (((psoDst->sizlBitmap.cx * 3) + 3) & ~3);
            iFormatHT = BMF_24BPP;
            iFormatDst = BMF_24BPP;
            iFormatHTPal = HT_FORMAT_24BPP;
            break;
        case BMF_32BPP:
            cjDstWidth = (((psoDst->sizlBitmap.cx << 2) + 3) & ~3);
            iFormatHT = BMF_32BPP;
            iFormatDst = BMF_32BPP;
            iFormatHTPal = HT_FORMAT_32BPP;
            break;
        default:
            return(HTBLT_NOTSUPPORTED);
        }
    }
    else
    {
        iFormatHTPal = poDst.GdiInfo()->ulHTOutputFormat;
        switch(iFormatHTPal)
        {
        case HT_FORMAT_1BPP:
            iFormatHT = iFormatDst = BMF_1BPP;
            break;
        case HT_FORMAT_4BPP:
            iFormatHT = iFormatDst = BMF_4BPP;
            break;
        case HT_FORMAT_4BPP_IRGB:
            iFormatHT = BMF_4BPP_VGA16;
            iFormatDst = BMF_4BPP;
            break;
        case HT_FORMAT_8BPP:
            iFormatHT = BMF_8BPP_VGA256;
            iFormatDst = BMF_8BPP;
            break;
        case HT_FORMAT_16BPP:
            iFormatHT = BMF_16BPP_555;
            iFormatDst = BMF_16BPP;
            break;
        case HT_FORMAT_24BPP:
            iFormatHT = BMF_24BPP;
            iFormatDst = BMF_24BPP;
            break;
        case HT_FORMAT_32BPP:
            iFormatHT = BMF_32BPP;
            iFormatDst = BMF_32BPP;
            break;
        default:
            return(HTBLT_NOTSUPPORTED);
        }
    }

    ERECTL  erclTrim(0, 0, psoSrc->sizlBitmap.cx, psoSrc->sizlBitmap.cy);
    erclTrim *= *prclSrc;
    if (erclTrim.bEmpty())
        return(HTBLT_SUCCESS);

    //
    // Initialize halftone structure and get ready.
    //

    if ((poDst.pDevHTInfo() == NULL) && !poDst.bEnableHalftone(pca))
        return(HTBLT_ERROR);

    SURFACE  *pSurfTempSrc;
    SURFMEM  dimoSrc;

    //
    // Synchronize with the source device driver.
    //

    if ( pSurfSrc->flags() & HOOK_SYNCHRONIZE)
    {
        PDEVOBJ po( pSurfSrc->hdev());
        po.vSync(psoSrc,NULL,0);
    }

    if ((psoSrc->iType == STYPE_BITMAP) &&
        (psoSrc->iBitmapFormat != BMF_4RLE) &&
        (psoSrc->iBitmapFormat != BMF_8RLE))
    {
        pSurfTempSrc = pSurfSrc;
    }
    else
    {

        // Get the bits from the device.
        // Find out the format to use by looking at the preferred format in
        // the surface's pdev devinfo structure.  We want to keep the original
        // color as much as possible since the halftone routine does a better
        // job in converting colors.

        DEVBITMAPINFO dbmiSrc;

        dbmiSrc.cxBitmap = psoSrc->sizlBitmap.cx;
        dbmiSrc.cyBitmap = psoSrc->sizlBitmap.cy;
        dbmiSrc.hpal     = (HPALETTE) 0;
        dbmiSrc.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;
        switch (psoSrc->iBitmapFormat)
        {
        case BMF_4RLE:
            dbmiSrc.iFormat = BMF_4BPP;
            break;
        case BMF_8RLE:
            dbmiSrc.iFormat = BMF_8BPP;
            break;
        default:
            dbmiSrc.iFormat  = psoSrc->iBitmapFormat;
            break;
        }

        if (!dimoSrc.bCreateDIB(&dbmiSrc, (PVOID) NULL))
        {
            WARNING("dimoSrc.bCreateDIB failed in EngHTBlt\n");
            return(HTBLT_ERROR);
        }

        // Copy the bits, dispatch off dst's ldev which is the engine.

        if (!EngCopyBits(dimoSrc.pSurfobj(),
                         psoSrc,
                         (CLIPOBJ *) NULL,
                         &xloIdent,
                         &erclTrim,
                         (POINTL *)&erclTrim))
        {
            WARNING("EngHTBlt:CopyBits failes\n");
            return(HTBLT_ERROR);
        }

        pSurfTempSrc = dimoSrc.ps;
    }

    //
    // Get the source palette.
    //

    PPALETTE ppalS = ppalGetFromXlate(pSurfSrc, pSurfDst, (XLATE *) pxlo, XO_SRCPALETTE, TRUE);

    if (ppalS == NULL)
    {
        WARNING("EngHTBlt could not find Source palette to use\n");
        return(HTBLT_NOTSUPPORTED);
    }

    XEPALOBJ palSrc(ppalS);

    //
    // Dest surface palette will be invalid only if it's a 256 color bitmap.
    //

    XEPALOBJ palDstSurf(ppalGetFromXlate( pSurfSrc, pSurfDst, (XLATE *) pxlo, XO_DESTPALETTE, TRUE));

//  Let's see if halftone palette is the same as the destination palette.

    BOOL bNoXlate;
    PALMEMOBJ palHTDst;
    XEPALOBJ *ppalHT = (XEPALOBJ *)NULL;

    if (iFormatHTPal != poDst.GdiInfo()->ulHTOutputFormat)
    {
        if (!palHTDst.bCreateHTPalette(iFormatHTPal, poDst.GdiInfo()))
        {
            return(HTBLT_ERROR);
        }
        ppalHT = (XEPALOBJ *)&palHTDst;
        bNoXlate = palHTDst.bEqualEntries(palDstSurf);
    }
    else
    {
        bNoXlate = poDst.bHTPalIsDevPal();
    }

// Prepare for HT_HalftoneBitmap call.

    BITBLTPARAMS    BitbltParams;
    ABINFO          AbInfo;

    if(uFlags == BBPF_DO_ALPHA_BLEND)
    {
        BLENDFUNCTION BlendFunction = pBlendObj->BlendFunction;
        if(BlendFunction.BlendOp == AC_SRC_OVER)
        {
            AbInfo.Flags = 0;
            AbInfo.pDstPal = 0;
            AbInfo.cDstPal = 0;

            AbInfo.ConstAlphaValue = BlendFunction.SourceConstantAlpha;

            if(BlendFunction.AlphaFormat == AC_SRC_ALPHA &&
               BlendFunction.SourceConstantAlpha == 255)
            {
                // Per pixel Alpha : Need palette info.
                if(!bIsSourceBGRA(pSurfSrc))
                    return HTBLT_ERROR;
                AbInfo.Flags |= ABIF_SRC_ALPHA_IS_PREMUL;
                //if(iFormatDst == BMF_32BPP)
                //    AbInfo.Flags |= ABIF_BLEND_DEST_ALPHA;
            }
            else
            {
                AbInfo.Flags |= ABIF_USE_CONST_ALPHA_VALUE;
            }

            // Set Destination palette values for Halftone.
            if(palDstSurf.bValid())
            {
                AbInfo.pDstPal = (LPPALETTEENTRY)palDstSurf.apalColorGet();
                AbInfo.cDstPal = (WORD)palDstSurf.cEntries();
                if(palDstSurf.bIsBGR() ||
                   ((palDstSurf.bIsBitfields())      &&
                    (palDstSurf.flRed() == 0xff0000) &&
                    (palDstSurf.flGre() == 0xff00)   &&
                    (palDstSurf.flBlu() == 0xff)))
                    AbInfo.Flags |= ABIF_DSTPAL_IS_RGBQUAD;
            }

            BitbltParams.pABInfo = &AbInfo;
        }
        else
            uFlags = 0;
    }
    //
    // Remove pAbort, since it never used and delete by ht.h
    //

    BitbltParams.rclSrc = *prclSrc;
    BitbltParams.rclDest = *prclDest;
    BitbltParams.Flags = (USHORT)uFlags;
    BitbltParams.ptlBrushOrg = *pptlBrushOrg;
    BitbltParams.DestPrimaryOrder = (BYTE)poDst.GdiInfo()->ulPrimaryOrder;

// Set ICM flags for halftoning

    ULONG lIcmMode = pxlo ? ((XLATE *) pxlo)->lIcmMode : DC_ICM_OFF;

    // 1) IF application ICM, BBPF_ICM_ON is ON.
    // 2) IF other ICM and not device caribrate, BBPF_ICM_ON is ON.

    if((IS_ICM_OUTSIDEDC(lIcmMode)) ||
       (!IS_ICM_DEVICE_CALIBRATE(lIcmMode) && (IS_ICM_HOST(lIcmMode) || (IS_ICM_DEVICE(lIcmMode)))))
    {
        ICMDUMP(("EngHTBlt(): ICM with Halftone (Dynamic Bit On)\n"));

        // Some kind of ICM (ICM on Application, Graphics Engine or Device)
        // is enabled, so tell halftoning code to disable thier color adjustment.

        BitbltParams.Flags |= BBPF_ICM_ON;
    }
    else
    {
        ICMDUMP(("EngHTBlt(): ICM with Halftone (Dynamic Bit Off)\n"));
    }


// Get the relevant information about the destination bitmap.

    SURFACE *pSurfTempDst = pSurfDst;
    SURFMEM dimoDst;

// Create a temporary bitmap if
// 1) the destination bitmap is not an engine bitmap. or
// 2) the bitmap width is not equal to the stride, because the halftone
//    code assumes they are equivalent, or
// 3) the destination is not 8bpp (we have special case for this) and
//    the halftone palette is different from the destination palette, or
// 4) the surfaces are overlapping

    BOOL bCreateShadowBitmap = FALSE;
    BYTE iDComplexity = (pco == (CLIPOBJ *) NULL) ? DC_TRIVIAL
                                                  : pco->iDComplexity;

// After the following "if" block, pcoNew should be used for clipping instead
// of pco.  We implement single rect clipping through banding in halftone.

// if DC_COMPLEX, create a shadow bitmap to avoid calling HT_Bitmap many times

    CLIPOBJ *pcoNew = pco;

    if ((psoDst->iType != STYPE_BITMAP) ||
        (psoDst->lDelta != cjDstWidth)  ||
        ((iFormatDst != BMF_8BPP) && !bNoXlate) ||
        (iDComplexity == DC_COMPLEX)||
        ((psoDst == psoSrc) && bIntersect(prclSrc, prclDest)))
    {
        bCreateShadowBitmap = TRUE;

        PRECTL prcl = prclDest;
        if (iDComplexity != DC_TRIVIAL)
        {
        // Clipping is not DC_TRIVIAL, use rclBounds as dest rect.

            prcl = &pco->rclBounds;

        // Clipping is done through banding if DC_RECT, do not clip
        // in CopyBits.

            if (iDComplexity == DC_RECT)
                pcoNew = NULL;

        // Do not enumerate clipping when calling halftone by marking
        // complexity to DC_TRIVIAL.

            iDComplexity = DC_TRIVIAL;
        }

    // Banding rect has to be well ordered and confined in the surface area.

        LONG lDxDst, lDyDst;
        SIZEL sizlDst = pSurfDst->sizl();
        LONG lLeft, lRight, lTop, lBottom;

    // Do the x part.

        if (prcl->right > prcl->left)
        {
            lLeft = prcl->left;
            lRight = prcl->right;
        }
        else
        {
            lLeft = prcl->right;
            lRight = prcl->left;
        }

        if (lLeft < 0L)
            lLeft = 0L;

        if (lRight > sizlDst.cx)
            lRight = sizlDst.cx;

        if ((lDxDst = (lRight - lLeft)) <= 0L)
            return(HTBLT_SUCCESS);

        BitbltParams.rclBand.left = lLeft;
        BitbltParams.rclBand.right = lRight;

    // Do the y part.

        if (prcl->bottom > prcl->top)
        {
            lTop = prcl->top;
            lBottom = prcl->bottom;
        }
        else
        {
            lTop = prcl->bottom;
            lBottom = prcl->top;
        }

        if (lTop < 0)
            lTop = 0;

        if (lBottom > sizlDst.cy)
            lBottom = sizlDst.cy;

        if ((lDyDst = (lBottom - lTop)) <= 0L)
            return(HTBLT_SUCCESS);

        BitbltParams.rclBand.top = lTop;
        BitbltParams.rclBand.bottom = lBottom;
        BitbltParams.Flags |= BBPF_HAS_BANDRECT;

    // Create the shadow bitmap.

        DEVBITMAPINFO dbmiDst;

        dbmiDst.cxBitmap = lDxDst;
        dbmiDst.cyBitmap = lDyDst;
        dbmiDst.hpal = 0;
        dbmiDst.fl = pSurfDst->bUMPD() ? UMPD_SURFACE : 0;
        dbmiDst.iFormat = iFormatDst;

        if (!dimoDst.bCreateDIB(&dbmiDst, (PVOID) NULL))
        {
            WARNING("dimoDst.bCreateDIB failed in EngHTBlt\n");
            return(HTBLT_ERROR);
        }

        pSurfTempDst = dimoDst.ps;
    }

    //
    // We need to xlate from halftone palette to dest surface palette if
    // the halftone palette is different from the destination palette.
    //

    EXLATEOBJ xloHTToDst, xloDstToHT;
    XLATEOBJ  *pxloHTToDst = &xloIdent, *pxloDstToHT = &xloIdent;

    DEVICEHALFTONEINFO *pDevHTInfo = (DEVICEHALFTONEINFO *)poDst.pDevHTInfo();

    if (!bNoXlate)
    {
        XEPALOBJ palDstDC;
        EPALOBJ  palHT((HPALETTE)pDevHTInfo->DeviceOwnData);
        ASSERTGDI(palHT.bValid(),"EngHTBlt: invalid HT pal\n");

        if (ppalHT == (XEPALOBJ *)NULL)
        {
            ppalHT = &palHT;
        }

        if ((pxlo == NULL) ||
            (((XLATE *) pxlo)->ppalDstDC == NULL))
        {
            palDstDC.ppalSet(ppalDefault);
        }
        else
        {
            palDstDC.ppalSet(((XLATE *) pxlo)->ppalDstDC);
        }

        if (!xloHTToDst.bInitXlateObj(
                            NULL,
                            DC_ICM_OFF,
                            *ppalHT,
                            palDstSurf,
                            palDstDC,
                            palDstDC,
                            0,
                            0x00FFFFFF,
                            0x00FFFFFF
                            ))
        {
            WARNING("EngHTBlt: bInitXlateObj HT to Dst failed\n");
            return(HTBLT_ERROR);
        }

        pxloHTToDst = xloHTToDst.pxlo();

    // Init the Dst pal to HT pal xlateobj so we can do CopyBits from
    // the destination surface to the halftone buffer.

        if ((pSurfMask || uFlags == BBPF_DO_ALPHA_BLEND) && bCreateShadowBitmap)
        {
            if (!xloDstToHT.bInitXlateObj(
                                    NULL,
                                    DC_ICM_OFF,
                                    palDstSurf,
                                    *ppalHT,
                                    palDstDC,
                                    palDstDC,
                                    0,
                                    0x00FFFFFF,
                                    0x00FFFFFF
                                    ))
            {
                WARNING("EngHTBlt: bInitXlateObj Dst to HT failed\n");
                return(HTBLT_ERROR);
            }

            pxloDstToHT = xloDstToHT.pxlo();
        }
    }

// If there is a source mask, copy the destination bits to the buffer
// so we can do CopyBits later on.  This is fater than creating a
// stretched mask and BitBlt with the created masks.

// Synchronize with the destination device driver.

    poDst.vSync(psoDst,NULL,0);

    if ((pSurfMask || uFlags == BBPF_DO_ALPHA_BLEND) && bCreateShadowBitmap)
    {
        ERECTL  ercl(0, 0, pSurfTempDst->sizl().cx, pSurfTempDst->sizl().cy);

    // Inc target surface uniqueness

        INC_SURF_UNIQ(pSurfTempDst);

        if (!(*PPFNGET(poDst,CopyBits, pSurfDst->flags()))
                      (
                      pSurfTempDst->pSurfobj(),         // Target surf
                      psoDst,                           // Source surf
                      (CLIPOBJ *)NULL,                  // ClipObj
                      pxloDstToHT,                      // XlateObj
                      (RECTL *)&ercl,                   // Dest rect
                      (POINTL *)&BitbltParams.rclBand   // Src offset
                      ))
        {
        // CopyBits failed.  We'll paint the background white.

            if (!EngBitBlt(pSurfTempDst->pSurfobj(),    // Target surf
                           (SURFOBJ *)NULL,             // Source surf
                           (SURFOBJ *)NULL,             // Mask surf
                           (CLIPOBJ *)NULL,             // ClipObj
                           NULL,                        // XlateObj
                           (RECTL *)&ercl,              // Dest rect
                           (POINTL *)NULL,              // Src offset
                           (POINTL *)NULL,              // Mask offset
                           (BRUSHOBJ *)NULL,            // BrushObj
                           (POINTL *)NULL,              // Brush origin
                           0xFFFF))                     // Rop
            {
                return(HTBLT_ERROR);
            }
        }
    }

    HTSrc.pColorTriad = (PCOLORTRIAD)NULL;      // assume not allocate
    BOOL bRet = FALSE;

    if (bSetHTSrcSurfInfo(pSurfTempSrc->pSurfobj(), palSrc, &HTSrc, pxlo) &&
        bSetHTSurfInfo(pSurfTempDst->pSurfobj(), &HTDest, iFormatHT) &&
        (!pSurfMask || bSetHTSurfInfo(pSurfMask->pSurfobj(), &HTMask, psoMask->iBitmapFormat)))
    {
        PHTSURFACEINFO pMask = (PHTSURFACEINFO)NULL;
        if (pSurfMask)
        {
            BitbltParams.ptlSrcMask = *pptlMask;
            pMask = &HTMask;
        }

        if (!(poDst.GdiInfo()->flHTFlags & HT_FLAG_OUTPUT_CMY))
            BitbltParams.Flags |= BBPF_USE_ADDITIVE_PRIMS;

    // 8BPP halftone does color translations.  So pass the xlate along.

        if (iFormatDst == BMF_8BPP)
        {
            HTDest.pColorTriad = &clrtri;
            clrtri.Type = COLOR_TYPE_RGB;
            clrtri.BytesPerPrimary = 1;
            clrtri.BytesPerEntry = 1;
            clrtri.PrimaryOrder = COLOR_TYPE_RGB;
            clrtri.PrimaryValueMax = 255;
            clrtri.ColorTableEntries = 256;;
            clrtri.pColorTable = aclr;
            COUNT iLimit = MIN(256,pxloHTToDst->cEntries);

            for(COUNT i = 0; i < iLimit; i++)
            {
                aclr[i] = (BYTE)(*(pxloHTToDst->pulXlate + i));
            }
            pxloHTToDst = &xloIdent;
        }

    // HT_HalftoneBitmap will return number of scans being drawn.

        switch (iDComplexity)
        {
        case DC_RECT:
            BitbltParams.Flags |= BBPF_HAS_DEST_CLIPRECT;
            BitbltParams.rclClip = pcoNew->rclBounds;

        case DC_TRIVIAL:
            bRet = (HT_HalftoneBitmap(pDevHTInfo,
                                      (PHTCOLORADJUSTMENT)pca,
                                      (PHTSURFACEINFO)&HTSrc,
                                      pMask,
                                      (PHTSURFACEINFO)&HTDest,
                                      (PBITBLTPARAMS)&BitbltParams) >= 0L);

            break;

        default:        // DC_COMPLEX
            BitbltParams.Flags |= BBPF_HAS_DEST_CLIPRECT;
            ((ECLIPOBJ *) pcoNew)->cEnumStart(FALSE,CT_RECTANGLES,
                                              CD_ANY,CLIPOBJ_ENUM_LIMIT);
            bRet = TRUE;

            BOOL bMore;
            CLIPENUMRECT clenr;
            do {
                bMore = ((ECLIPOBJ *) pcoNew)->bEnum(sizeof(clenr),
                                                     (PVOID) &clenr);

                for (ULONG iRT = 0; iRT < clenr.c; iRT++)
                {
                    BitbltParams.rclClip = clenr.arcl[iRT];

                    bRet &= (HT_HalftoneBitmap(pDevHTInfo,
                                               (PHTCOLORADJUSTMENT)pca,
                                               (PHTSURFACEINFO)&HTSrc,
                                               pMask,
                                               (PHTSURFACEINFO)&HTDest,
                                               (PBITBLTPARAMS)&BitbltParams) >= 0L);
                }
            } while (bMore && bRet);
            break;
        }

        if (bCreateShadowBitmap && bRet)
        {
            // Dispatch the call.  Give it no mask.

            EPOINTL eptl(0,0);

            // Inc target surface uniqueness

            INC_SURF_UNIQ(pSurfDst);

            if (psoDst->iType != STYPE_BITMAP)
            {
                bRet = (*PPFNGET(poDst,CopyBits, pSurfDst->flags())) (
                            psoDst,
                            pSurfTempDst->pSurfobj(),
                            pcoNew,
                            pxloHTToDst,
                            &BitbltParams.rclBand,
                            (POINTL *)&eptl);
            }
            else
            {
                bRet = EngCopyBits(
                            psoDst,
                            pSurfTempDst->pSurfobj(),
                            pcoNew,
                            pxloHTToDst,
                            &BitbltParams.rclBand,
                            (POINTL *)&eptl);


            }
        }
    }

    if (HTSrc.pColorTriad)
        VFREEMEM((LPSTR)HTSrc.pColorTriad);

    return(bRet ? HTBLT_SUCCESS : HTBLT_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\icmapi.cxx ===
/******************************Module*Header*******************************\
* Module Name:
*
*   icmapi.cxx
*
* Abstract
*
*   This module implements Integrated Color match API support
*
* Author:
*
*   Mark Enstrom    (marke) 9-27-93
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C" {
    ULONG GreGetBitmapBitsSize(CONST BITMAPINFO *pbmi); // in ntgdi.c
    BOOL  bInitICM();
}

#pragma alloc_text(INIT, bInitICM)

PCOLORSPACE  gpStockColorSpace;
HCOLORSPACE  ghStockColorSpace;

UINT         giIcmGammaRange;

#if DBG_ICM

ULONG        IcmDebugLevel = 0;

#endif

#define sRGB_PROFILENAME        L"sRGB Color Space Profile.icm"

LOGCOLORSPACEW gcsStockColorSpace = {
                           LCS_SIGNATURE,
                           0x400,
                           sizeof(LOGCOLORSPACEW),
                           LCS_CALIBRATED_RGB,
                           LCS_GM_IMAGES,
                           {
                            {0x000006b91,0x000003db8,0x00000070e},
                            {0x000005793,0x00000a9ba,0x000001bf4},
                            {0x0000038aa,0x00000188e,0x000012888}
                           },
                           0x23333,  // 2.2
                           0x23333,  // 2.2
                           0x23333,  // 2.2
                           0};

#define MAX_COLORTABLE     256

//
// iIcmControlFlags
//
#define ICM_CONTROL_WIN95_COLORSPACE 0x00010000 // Win95 compatible colorspace

//
// Misc. macros
//
#define ALIGN_DWORD(nBytes)   (((nBytes) + 3) & ~3)

//
// ICM supports output color mode (originally come from ICM.H)
//
#define BM_RGBTRIPLETS   0x0002
#define BM_xRGBQUADS     0x0008
#define BM_xBGRQUADS     0x0010
#define BM_CMYKQUADS     0x0020
#define BM_KYMCQUADS     0x0305

//
// ICM modes list
//
// if (IS_HOST_ICM(pdca->lIcmMode))
// {
//     if (pdca->hcmXform)
//     {
//         if (IS_CMYK_COLOR(pdca->lIcmMode))
//         {
//             Host ICM ON, CMYK color mode.
//             With CMYK color mode, we should have valid color transform.
//         }
//         else
//         {
//             Host ICM ON, RGB color mode.
//         }
//     }
//     else
//     {
//         Host ICM ON, RGB color mode,
//         But no color translation because src == dst color space.
//     }
// }
// else if (IS_DEVICE_ICM(pdca->lIcmMode))
// {
//     Device ICM ON.
// }
// else if (IS_OUTSIDEDC_ICM(pdca->lIcmMode))
// {
//     Application ICM ON.
// }
//

/******************************Public*Routine******************************\
* GreCreateColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

HCOLORSPACE
GreCreateColorSpace(
    PLOGCOLORSPACEEXW pLogColorSpaceEx
    )
{
    ICMAPI(("GreCreateColorSpace\n"));

    HCOLORSPACE hRet = NULL;
    PCOLORSPACE pColorSpace;

    //
    // Check the validation of this color space.
    //
    if ((pLogColorSpaceEx->lcsColorSpace.lcsSignature != LCS_SIGNATURE)    ||
        (pLogColorSpaceEx->lcsColorSpace.lcsVersion   != 0x400)            ||
        (pLogColorSpaceEx->lcsColorSpace.lcsSize      != sizeof(LOGCOLORSPACEW)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    //
    // Allocate COLORSPACE object.
    //
    pColorSpace = (PCOLORSPACE) ALLOCOBJ(sizeof(COLORSPACE), ICMLCS_TYPE, FALSE);

    if (pColorSpace == (PCOLORSPACE)NULL)
    {
        WARNING("bCreateColorSpace failed memory allocation\n");
    }
    else
    {
        //
        // Register LOGCOLORSPACE handle.
        //
        hRet = (HCOLORSPACE)HmgInsertObject(
                                    pColorSpace,
                                    HMGR_ALLOC_ALT_LOCK,
                                    ICMLCS_TYPE);

        if (hRet)
        {
            //
            // Copy LOGCOLORSPACE into COLORSPACE object.
            //
            pColorSpace->lcsSignature(pLogColorSpaceEx->lcsColorSpace.lcsSignature);
            pColorSpace->lcsVersion(pLogColorSpaceEx->lcsColorSpace.lcsVersion);
            pColorSpace->lcsSize(pLogColorSpaceEx->lcsColorSpace.lcsSize);
            pColorSpace->lcsCSType(pLogColorSpaceEx->lcsColorSpace.lcsCSType);
            pColorSpace->lcsIntent(pLogColorSpaceEx->lcsColorSpace.lcsIntent);
            pColorSpace->vSETlcsEndpoints(&(pLogColorSpaceEx->lcsColorSpace.lcsEndpoints));
            pColorSpace->lcsGammaRed(pLogColorSpaceEx->lcsColorSpace.lcsGammaRed);
            pColorSpace->lcsGammaGreen(pLogColorSpaceEx->lcsColorSpace.lcsGammaGreen);
            pColorSpace->lcsGammaBlue(pLogColorSpaceEx->lcsColorSpace.lcsGammaBlue);
            pColorSpace->vSETlcsFilename((PWCHAR)&(pLogColorSpaceEx->lcsColorSpace.lcsFilename[0]),MAX_PATH);

            pColorSpace->lcsExFlags(pLogColorSpaceEx->dwFlags);

            //
            // Decrement color space handle which increment at creation time.
            //
            DEC_SHARE_REF_CNT(pColorSpace);

            ICMMSG(("GreCreateColorSpace():Object %x: ref. count = %d\n",
                                                hRet,HmgQueryAltLock((HOBJ)hRet)));
        }
        else
        {
            FREEOBJ(pColorSpace,ICMLCS_TYPE);
        }
    }

    return(hRet);
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   NtGdiCreateColorSpace
*
* Routine Description:
*
*   Create a color space object - stub
*
* Arguments:
*
*   pLogColorSpace - Logical Color space passed in. This will be used as the
*   user-mode visible protion of this object
*
* Return Value:
*
*   Handle to ColorSpace object or NULL on failure
*
\**************************************************************************/

HANDLE
APIENTRY
NtGdiCreateColorSpace(
    PLOGCOLORSPACEEXW pLogColorSpaceEx
    )
{
    ICMAPI(("NtGdiCreateColorSpace\n"));

    HANDLE hRet = NULL;
    BOOL   bStatus = TRUE;

    LOGCOLORSPACEEXW tmpLcsEx;

    __try
    {
        ProbeForRead(pLogColorSpaceEx,sizeof(LOGCOLORSPACEEXW),sizeof(ULONG));
        RtlCopyMemory(&tmpLcsEx,pLogColorSpaceEx,sizeof(LOGCOLORSPACEEXW));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bStatus = FALSE;
    }

    if (bStatus)
    {
        hRet = (HANDLE)GreCreateColorSpace(&tmpLcsEx);
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* bDeleteColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDeleteColorSpace(
    HCOLORSPACE hColorSpace
    )
{
    ICMAPI(("bDeleteColorSpace\n"));

    BOOL        bRet = FALSE;

    PCOLORSPACE pColorSpace;

    if (DIFFHANDLE(hColorSpace,ghStockColorSpace))
    {
        ICMMSG(("bDeleteColorSpace():Object %x: ref. count = %d\n",
                                   hColorSpace,HmgQueryAltLock((HOBJ)hColorSpace)));

        //
        // Try to remove handle from hmgr. This will fail if the color space
        // is locked down on any threads or if it has been marked global or
        // un-deleteable.
        //
        pColorSpace = (PCOLORSPACE)HmgRemoveObject(
                                    (HOBJ)hColorSpace,
                                     0,
                                     0,
                                     TRUE,
                                     ICMLCS_TYPE);

        if (pColorSpace != (PCOLORSPACE)NULL)
        {
            FREEOBJ(pColorSpace,ICMLCS_TYPE);
            bRet = TRUE;
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            WARNING("Couldn't remove COLORSPACE object");
        }
    }
    else
    {
        //
        // Under Win31 deleting stock objects returns True.
        //
        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiDeleteColorSpace
*
* Routine Description:
*
*   Delete a color space object
*
* Arguments:
*
*   hColorSpace - Handle of Logical Color Space to delete
*
* Return Value:
*
*   BOOL status
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiDeleteColorSpace(
    HANDLE hColorSpace
    )
{
    ICMAPI(("NtGdiDeleteColorSpace\n"));

    //
    // Delete ColorSpace
    //
    return(bDeleteColorSpace((HCOLORSPACE)hColorSpace));
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   NtGdiSetColorSpace
*
* Routine Description:
*
*   Set Color Space for DC
*
* Arguments:
*
*   hdc         - handle of dc
*   hColorSpace - handle of color space
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiSetColorSpace(
    HDC         hdc,
    HCOLORSPACE hColorSpace
    )
{
    BOOL bReturn = FALSE;

    ICMAPI(("NtGdiSetColorSpace\n"));

    //
    // validate the DC
    //
    XDCOBJ   dco(hdc);

    if (dco.bValid())
    {
        //
        // is it a different colorspace
        //
        if (DIFFHANDLE(hColorSpace,dco.pdc->hColorSpace()))
        {
            //
            // now validate HColorSpace
            //
            COLORSPACEREF ColorSpaceSel(hColorSpace);

            if (ColorSpaceSel.bValid())
            {
                //
                // dec ref count of old color space.
                //
                DEC_SHARE_REF_CNT((PCOLORSPACE)dco.pdc->pColorSpace());

                ICMMSG(("NtGdiSetColorSpace():Old Object %x: ref. count = %d\n",
                         dco.pdc->hColorSpace(),HmgQueryAltLock((HOBJ)dco.pdc->hColorSpace())));

                //
                // set color space handle in dc
                //
                dco.pdc->hColorSpace(hColorSpace);
                dco.pdc->pColorSpace(ColorSpaceSel.pColorSpace());

                //
                // up the ref count of the selected color space.
                //
                INC_SHARE_REF_CNT(ColorSpaceSel.pColorSpace());

                ICMMSG(("NtGdiSetColorSpace():New Object %x: ref. count = %d\n",
                         dco.pdc->hColorSpace(),HmgQueryAltLock((HOBJ)dco.pdc->hColorSpace())-1));
                         /* -1: because of COLORSPACEREF locks this, then actuall number is N-1 */

                //
                // We are succeed to select.
                //
                bReturn = TRUE;
            }
            else
            {
                //
                // keep color space as same as current.
                //
            }
        }
        else
        {
            //
            // Same handle has been selected.
            //
            bReturn = TRUE;
        }

        dco.vUnlockFast();
    }

    return(bReturn);
}

#ifdef _IA64_

//
// There is a compiler bug that shows up in this function. 
// Disable optimization until it is fixed.
//

#pragma optimize( "", off )
#endif

/******************************Public*Routine******************************\
* GreSetICMMode()
*
* History:
*
* Write it:
*    27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreSetICMMode(
    HDC   hdc,
    ULONG nCommand,
    ULONG iReqData
    )
{
    ICMMSG(("GreSetICMMode\n"));

    BOOL bRet = TRUE;

    XDCOBJ dco(hdc);

    if(!dco.bValid())
    {
        WARNING("GreSetICMMode(): Invalid DC\n");
        return (FALSE);
    }

    DEVLOCKOBJ dlo;

    if (dlo.bLock(dco))
    {
        ULONG NewReqMode, OldReqMode;
        ULONG NewMode,OldMode;
        ULONG NewColorType, OldColorType;
        PDEVOBJ po(dco.hdev());

        //
        // Check target surface
        //
        SURFACE *pSurface = dco.pSurface();

        //
        // Get current ICM destination color type
        //
        NewColorType = OldColorType = GET_COLORTYPE(dco.pdc->lIcmMode());

        //
        // Get current ICM mode.
        //
        NewMode = OldMode = ICM_MODE(dco.pdc->lIcmMode());

        //
        // Get previous requested mode.
        //
        NewReqMode = OldReqMode = REQ_ICM_MODE(dco.pdc->lIcmMode());

        switch (nCommand)
        {
            case ICM_SET_MODE:

                ICMMSG(("GreSetICMMode():Update ICM mode -> %x\n",iReqData));

                //
                // iReqData should be one of these.
                //
                switch (iReqData)
                {
                case REQ_ICM_OFF:

                    //
                    // Turn off ICM.
                    //
                    // (should preserve alt mode)
                    //
                    NewReqMode = REQ_ICM_OFF;
                    NewMode    = (ICM_ALT_MODE(dco.pdc->lIcmMode()) | DC_ICM_OFF);
                    break;

                case REQ_ICM_HOST:
                case REQ_ICM_DEVICE:
                case REQ_ICM_OUTSIDEDC:

                    //
                    // Update new requested mode.
                    //
                    NewReqMode = iReqData;

                    //
                    // Figure out ICM mode from requested mode.
                    //
                    NewMode = ICM_REQ_TO_MODE(NewReqMode);

                    //
                    // We don't allow "ICM on Device" with non-DDB surface.
                    //
                    if (IS_ICM_DEVICE_REQUESTED(NewReqMode))
                    {
                        if (po.bValid())
                        {
                            //
                            // ICM on Device is requested, check driver's capacity.
                            //
                            if (po.flGraphicsCaps() & GCAPS_ICM)
                            {
                                //
                                // DC is device DC. (not, info or memory)
                                //
                                if (dco.dctp() != DCTYPE_MEMORY)
                                {
                                    //
                                    // OK, we can enable device ICM.
                                    //
                                }
                                else
                                {
                                    ICMMSG(("NtGdiSetIcmMode():DC is memory DC, but device icm requested\n"));

                                    //
                                    // Enable host ICM instead.
                                    //
                                    NewMode = DC_ICM_HOST;
                                }
                            }
                            else
                            {
                                WARNING("GreSetICMMode(): ICM on Device is requested, but driver could not.\n");

                                //
                                // Oh!, device driver does *not* support ICM on device or driver.
                                // Turn on ICM on HOST.
                                //
                                NewMode = DC_ICM_HOST;
                            }
                        }
                        else
                        {
                            //
                            // we will keep current mode. and return false.
                            //
                            bRet = FALSE;
                        }
                    }

                    if (bRet)
                    {
                       //
                       // Should preserve alt mode through ICM mode change.
                       //
                       NewMode |= ICM_ALT_MODE(dco.pdc->lIcmMode());
                    }

                    break;

                default:

                    //
                    // Unknown request mode.
                    //
                    bRet = FALSE;
                }

                break;

            case ICM_SET_CALIBRATE_MODE:

                ICMMSG(("GreSetICMMode():Update ICM device calibrate -> %x\n",iReqData));

                if (iReqData)
                {
                    NewMode |= DC_ICM_DEVICE_CALIBRATE;
                }
                else
                {
                    NewMode &= ~DC_ICM_DEVICE_CALIBRATE;
                }

                break;

            case ICM_SET_COLOR_MODE:
            case ICM_CHECK_COLOR_MODE:

                ICMMSG(("GreSetICMMode():Update ICM colortype -> %x\n",iReqData));

                //
                // iReqData should be one of these.
                //
                switch (iReqData)
                {
                case BM_xRGBQUADS:
                case BM_xBGRQUADS:

                    // Clear lazy color correction.
                    //
                    // NewMode &= ~DC_ICM_LAZY_CORRECTION;
                    //
                    // Note: bitmap might have color which expected to corrected later.

                    //
                    // Set color type as RGB.
                    //
                    NewColorType = DC_ICM_RGB_COLOR;

                    break;

                case BM_CMYKQUADS:
                case BM_KYMCQUADS:

                    if (po.bValid())
                    {
                        //
                        // Set color type as CMYK.
                        //
                        NewColorType = DC_ICM_CMYK_COLOR;

                        //
                        // Check device driver could handle CMYK color or not
                        //
                        if (po.flGraphicsCaps() & GCAPS_CMYKCOLOR)
                        {
                            //
                            // We don't allow "CMYK color" with non-DDB surface.
                            //
                            if (dco.dctp() != DCTYPE_MEMORY)
                            {
                                //
                                // We can go with CMYK color.
                                //
                            }
                            else
                            {
                                ICMMSG(("NtGdiSetIcmMode():Enable lazy color correction\n"));

                                //
                                // Memory DC can only hold RGB based color,
                                // so RGB to CMYK color translation will happen when
                                // apps does BitBlt onto real device surface from this
                                // compatible surface.
                                //
                                NewMode |= DC_ICM_LAZY_CORRECTION;
                                NewColorType = DC_ICM_RGB_COLOR;
                            }
                        }
                        else
                        {
                            //
                            // Driver could not handle, ICM could not turn on.
                            //
                            WARNING("GreSetICMMode(): Device driver could not handle CMYK color\n");

                            //
                            // we will keep current code. and return false.
                            //
                            bRet = FALSE;
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }

                    break;

                default:

                    ICMMSG(("GreSetICMMode():Unknown color type\n"));

                    //
                    // Unknown color mode.
                    //
                    bRet = FALSE;
                }

                break;

            default :

                ICMMSG(("GreSetICMMode():Unknown command\n"));
                bRet = FALSE;
                break;
        }

        if (bRet && (nCommand != ICM_CHECK_COLOR_MODE))
        {
            if ((OldMode != NewMode) || (OldReqMode != NewReqMode) || (OldColorType != NewColorType))
            {
                //
                // Update ICM mode. (we will keep original request mode and colortype).
                //
                // kernel side.
                //
                dco.pdc->lIcmMode(NewColorType|NewReqMode|NewMode);

                // and, client side (need to preserve usermode only flags).
                //
                ULONG UserModeFlag = (dco.pdc->lIcmModeClient() & DC_ICM_USERMODE_FLAG);

                dco.pdc->lIcmModeClient(NewColorType|NewReqMode|NewMode|UserModeFlag);

                if (OldMode != NewMode)
                {
                    SURFACE  *pSurfDest = dco.pSurface();
                    XEPALOBJ  palDestDC(dco.ppal());

                    if (palDestDC.bValid())
                    {
                        //
                        // update all drawing state
                        //
                        palDestDC.vUpdateTime();

                        if (pSurfDest != NULL)
                        {
                            XEPALOBJ palDestSurf(pSurfDest->ppal());

                            if (palDestSurf.bValid())
                            {
                                //
                                // update palette.
                                //
                                palDestSurf.vUpdateTime();
                            }
                        }
                    }
                }

                ICMMSG(("NtGdiSetIcmMode():ICM mode were changed to %x\n",dco.pdc->lIcmMode()));
            }
            else
            {
                ICMMSG(("NtGdiSetIcmMode():ICM mode were NOT changed!\n"));
            }
        }
    }
    else
    {
        //
        // Fail to enable ICM for fullscreen DC.
        //
    }

    dco.vUnlockFast();

    return(bRet);
}

#ifdef _IA64_
#pragma optimize( "", on )
#endif

/******************************Public*Routine******************************\
* NtGdiSetIcmMode
*
* ICM mode changed, update all times
*
* History:
*
* Write it:
*    27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL WINAPI
NtGdiSetIcmMode(
    HDC   hdc,
    ULONG nCommand,
    ULONG ulMode
    )
{
    ICMMSG(("NtGdiSetIcmMode\n"));

    return(GreSetICMMode(hdc,nCommand,ulMode));
}

/******************************Public*Routine******************************\
* GreCreateColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE
GreCreateColorTransform(
    HDC              hdc,
    LPLOGCOLORSPACEW pLogColorSpaceW,
    PVOID            pvSrcProfile,
    ULONG            cjSrcProfile,
    PVOID            pvDstProfile,
    ULONG            cjDstProfile,
    PVOID            pvTrgProfile,
    ULONG            cjTrgProfile
    )
{
    HANDLE hRet = NULL;

    ICMAPI(("GreCreateColorTransform\n"));

    //
    // Check the validation of this color space.
    //
    if ((pLogColorSpaceW->lcsSignature != LCS_SIGNATURE)    ||
        (pLogColorSpaceW->lcsVersion   != 0x400)            ||
        (pLogColorSpaceW->lcsSize      != sizeof(LOGCOLORSPACEW)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (NULL);
    }

    XDCOBJ dcoDst(hdc);

    if (dcoDst.bValid())
    {
        if (!dcoDst.pdc->bInFullScreen())
        {
            COLORTRANSFORMOBJ CXFormObj;

            //
            // Create new color transform object.
            //
            hRet = CXFormObj.hCreate(dcoDst,
                                     pLogColorSpaceW,
                                     pvSrcProfile,
                                     cjSrcProfile,
                                     pvDstProfile,
                                     cjDstProfile,
                                     pvTrgProfile,
                                     cjTrgProfile);

            if (!hRet)
            {
                WARNING("GreCreateColorTransform fail to allocate object\n");
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        else
        {
            WARNING("GreCreateColorTransform(): hdc is full screen\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING("GreCreateColorTransform(): hdc is invalid\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return (hRet);
}

/******************************Public*Routine******************************\
* NtGdiCreateColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE WINAPI
NtGdiCreateColorTransform(
    HDC              hdc,
    LPLOGCOLORSPACEW pLogColorSpaceW,
    PVOID            pvSrcProfile,
    ULONG            cjSrcProfile,
    PVOID            pvDestProfile,
    ULONG            cjDestProfile,
    PVOID            pvTargetProfile,
    ULONG            cjTargetProfile
    )
{
    HANDLE           hColorTransform = NULL;

    LOGCOLORSPACEW   KmLogColorSpaceW;

    HANDLE           hSecureSource = NULL;
    HANDLE           hSecureDestination = NULL;
    HANDLE           hSecureTarget = NULL;

    PVOID            pKmSrcProfile = NULL;
    PVOID            pKmDstProfile = NULL;
    PVOID            pKmTrgProfile = NULL;

    BOOL             bError = FALSE;

    ICMAPI(("NtGdiCreateColorTransform\n"));

    __try
    {
        if (pLogColorSpaceW)
        {
            //
            // Copy LOGCOLORSPACE
            //
            ProbeForRead(pLogColorSpaceW,sizeof(LOGCOLORSPACEW),sizeof(ULONG));
            RtlCopyMemory(&KmLogColorSpaceW,pLogColorSpaceW,sizeof(LOGCOLORSPACEW));
        }
        else
        {
            //
            // We need LOGCOLORSPACE, at least.
            //
            return (NULL);
        }

        //
        // Lock down client side mapped files.
        //
        if (pvSrcProfile && cjSrcProfile)
        {
            ProbeForRead(pvSrcProfile,cjSrcProfile,sizeof(BYTE));

            hSecureSource = MmSecureVirtualMemory(pvSrcProfile,cjSrcProfile,PAGE_READONLY);

            if (hSecureSource)
            {
                pKmSrcProfile = pvSrcProfile;
            }
            else
            {
                WARNING("NtGdiCreateColorTransform():Fail to lock source profile\n");
                bError = TRUE;
            }
        }

        if (pvDestProfile && cjDestProfile)
        {
            ProbeForRead(pvDestProfile,cjDestProfile,sizeof(BYTE));

            hSecureDestination = MmSecureVirtualMemory(pvDestProfile,cjDestProfile,PAGE_READONLY);

            if (hSecureDestination)
            {
                pKmDstProfile = pvDestProfile;
            }
            else
            {
                WARNING("NtGdiCreateColorTransform():Fail to lock destination profile\n");
                bError = TRUE;
            }
        }

        if (pvTargetProfile && cjTargetProfile)
        {
            ProbeForRead(pvTargetProfile,cjTargetProfile,sizeof(BYTE));

            hSecureTarget = MmSecureVirtualMemory(pvTargetProfile,cjTargetProfile,PAGE_READONLY);

            if (hSecureTarget)
            {
                pKmTrgProfile = pvTargetProfile;
            }
            else
            {
                WARNING("NtGdiCreateColorTransform():Fail to lock target profile\n");
                bError = TRUE;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiCreateColorTransform(): Fail to lock usermode parameters\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        bError = TRUE;
    }

    if (!bError)
    {
        //
        // Create Color Transform.
        //
        hColorTransform = GreCreateColorTransform(hdc,
                                                  &KmLogColorSpaceW,
                                                  pKmSrcProfile,
                                                  cjSrcProfile,
                                                  pKmDstProfile,
                                                  cjDestProfile,
                                                  pKmTrgProfile,
                                                  cjTargetProfile);

        if (!hColorTransform)
        {
            WARNING("GreCreateColorTransform() failed\n");
        }
    }

    if (hSecureSource)
    {
        MmUnsecureVirtualMemory(hSecureSource);
    }

    if (hSecureDestination)
    {
        MmUnsecureVirtualMemory(hSecureDestination);
    }

    if (hSecureTarget)
    {
        MmUnsecureVirtualMemory(hSecureTarget);
    }

    return (hColorTransform);
}

/******************************Public*Routine******************************\
* GreDeleteColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
*  Feb.21.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreDeleteColorTransform(
    HDC    hdc,
    HANDLE hColorTransform
    )
{
    ICMAPI(("GreDeleteColorTransform\n"));

    BOOL bRet = FALSE;

    //
    // Lock DC, call driver to delete color transform.
    // if the driver doesn't support this call, this is an
    // error
    //
    XDCOBJ dcoDst(hdc);

    //
    // Validate the destination DC.
    //
    if (dcoDst.bValid())
    {
        if (dcoDst.pdc->bInFullScreen())
        {
            WARNING("GreCreateColorTransform(): hdc is full screen\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }
        else
        {
            COLORTRANSFORMOBJ CXFormObj(hColorTransform);

            if (CXFormObj.bValid())
            {
                //
                // Delete it
                //
                bRet = CXFormObj.bDelete(dcoDst);
            }
        }

        dcoDst.vUnlock();
    }
    else
    {
        WARNING1("ERORR GreGdiDeleteColorTransform called on invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiDeleteColorTransform
*
* Arguments:
*
* Return Value:
*
* History:
*
*    5-Aug-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
NtGdiDeleteColorTransform(
    HDC     hdc,
    HANDLE  hColorTransform
    )
{
    ICMAPI(("NtGdiDeleteColorTransform\n"));

    return (GreDeleteColorTransform(hdc,hColorTransform));
}

/******************************Public*Routine******************************\
* GreCheckBitmapBits
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreCheckBitmapBits(
    HDC            hdc,
    HANDLE         hColorTransform,
    DEVBITMAPINFO *pdbmi,
    PVOID          pvBits,
    PBYTE          paResults)
{
    ICMAPI(("GreCheckBitmapBits\n"));

    BOOL bRet = FALSE;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        DEVLOCKOBJ dlo;

        if (dlo.bLock(dco))
        {
            PDEVOBJ po(dco.hdev());

            if (po.bValid())
            {
                if (PPFNVALID(po, IcmCheckBitmapBits))
                {
                    //
                    // We need to pass driver's transform handle to driver.
                    //
                    COLORTRANSFORMOBJ CXFormObj(hColorTransform);

                    if (CXFormObj.bValid())
                    {
                        SURFMEM   SurfDimoTemp;

                        SurfDimoTemp.bCreateDIB(pdbmi,pvBits);

                        if (SurfDimoTemp.bValid())
                        {
                            //
                            // Call device driver.
                            //
                            bRet = (*PPFNDRV(po, IcmCheckBitmapBits))(
                                             po.dhpdev(),
                                             CXFormObj.hGetDeviceColorTransform(),
                                             SurfDimoTemp.pSurfobj(),
                                             paResults);
                        }
                    }
                }
                else
                {
                    WARNING("GreCheckBitmapBits called on device that does not support call\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                }
            }
        }

        dco.vUnlockFast();
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiCheckBitmapBits
*
* Arguments:
*
* Return Value:
*
* History:
*
* Write it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL WINAPI
NtGdiCheckBitmapBits(
    HDC       hdc,
    HANDLE    hColorTransform,
    PVOID     pvBits,
    ULONG     bmFormat,
    DWORD     dwWidth,
    DWORD     dwHeight,
    DWORD     dwStride,
    PBYTE     paResults)
{
    ICMAPI(("NtGdiCheckBitmapBits\n"));

    ULONG  ulBytesPerPixel;
    ULONG  ulSizeInByte;
    ULONG  ulSizeForResult;

    HANDLE hSecureBits = NULL;
    HANDLE hSecureRets = NULL;

    DEVBITMAPINFO dbmi;

    BOOL   bRet = TRUE;

    //
    // limitted support.
    //
    if (
        (bmFormat != BM_RGBTRIPLETS) || (dwHeight != 1)
       )
    {
        WARNING("NtGdiCheckBitmapBits(): Format is not supported, yet\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // So, far, we only support RGBTRIPLE format, and n x 1 bitmap.
    //
    ulBytesPerPixel = sizeof(RGBTRIPLE);
    ulSizeInByte    = ALIGN_DWORD(dwWidth * ulBytesPerPixel);
    ulSizeForResult = dwWidth;

    //
    // dwStride should be equal to ulSizeInByte,
    // because we should only has 1 height bitmap.
    //
    if (dwStride != ulSizeInByte)
    {
        WARNING("NtGdiCheckBitmapBits(): Format is not supported, yet\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // Fill up DEVBITMAPINFO
    //
    dbmi.iFormat  = BMF_24BPP;
    dbmi.cxBitmap = dwWidth;
    dbmi.cyBitmap = dwHeight;
    dbmi.cjBits   = ulSizeInByte;
    dbmi.hpal     = NULL;
    dbmi.fl       = 0;

    //
    // Lock down user mode memory for bitmap and result buffer
    //
    __try
    {
        ProbeForRead(pvBits,ulSizeInByte,sizeof(DWORD));
        ProbeForRead(paResults,ulSizeForResult,sizeof(BYTE));

        hSecureBits = MmSecureVirtualMemory(pvBits, ulSizeInByte, PAGE_READONLY);
        hSecureRets = MmSecureVirtualMemory(paResults, ulSizeForResult, PAGE_READWRITE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("NtGdiCheckBitmapBits():Error in capture usermode memory\n");

        bRet = FALSE;
    }

    if (bRet && hSecureBits && hSecureRets)
    {
        bRet = GreCheckBitmapBits(hdc,hColorTransform,
                                  &dbmi,pvBits,
                                  (PBYTE)paResults);
    }

    if (hSecureBits)
    {
        MmUnsecureVirtualMemory(hSecureBits);
    }

    if (hSecureRets)
    {
        MmUnsecureVirtualMemory(hSecureRets);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiColorCorrectPalette
*
*   If this is a query operation then:
*       If the DC has ICM enabled NON_DEVICE and
*       the palette is not already color corrected then
*           Get the logical palette entries and return to app in array provided
*
*
*   If this is a set operation and the DC has ICM_NON_DEVICE and the palette
*   is ok then set the palette entries.
*
*   If this is a set operation and the DC is DEVICE then do nothing
*       --Maybe call device driver if it exports ICM calls
*
*
*  NOTE: if hpalette is moved to dcattr, then this routine can be
*      eliminated and done byt get/set palette entries from user mode
*
* Arguments:
*
* Return Value:
*
* History:
*
*    15-Aug-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
APIENTRY
NtGdiColorCorrectPalette(
    HDC             hdc,
    HPALETTE        hpal,
    ULONG           FirstEntry,
    ULONG           NumberOfEntries,
    PALETTEENTRY   *ppalEntry,
    ULONG           Command)
{
    ICMAPI(("NtGdiColorCorrectPalette\n"));

    DCOBJ   dcoDst(hdc);
    EPALOBJ pal((HPALETTE) hpal);

    ULONG ulRet = 0;

    if (dcoDst.bValid() && pal.bValid())
    {
        if ((NumberOfEntries == 0) ||
            (NumberOfEntries > pal.cEntries()) ||
            (FirstEntry > pal.cEntries()) ||
            ((FirstEntry + NumberOfEntries) > pal.cEntries()))
        {
            WARNING("NtGdiColorCorrectPalette(): Invalid parameter\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(ulRet);
        }

        if (IS_ICM_HOST(dcoDst.pdc->lIcmMode()))
        {
            if (Command == ColorPaletteQuery)
            {
                //
                // check palette for already colorcorrected flag
                //
                __try
                {
                    ProbeForWrite(ppalEntry,sizeof(PALETTEENTRY) * NumberOfEntries,sizeof(PALETTEENTRY));

                    //
                    // Get palette entries.
                    //
                    ulRet = pal.ulGetEntries(FirstEntry, NumberOfEntries, ppalEntry, FALSE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiColorCorrectPalette():Error in GetEntries\n");
                    ulRet = 0;
                }
            }
            else if (Command == ColorPaletteSet)
            {
                __try
                {
                    ProbeForRead(ppalEntry,sizeof(PALETTEENTRY) * NumberOfEntries,sizeof(PALETTEENTRY));

                    //
                    // Set palette entries.
                    //
                    ulRet = pal.ulSetEntries(FirstEntry, NumberOfEntries, ppalEntry);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiColorCorrectPalette():Error in SetEntries\n");
                    ulRet = 0;
                }
            }
        }
        else
        {
            WARNING("NtGdiColorCorrectPalette(): Invalid ICM mode\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        }
    }
    else
    {
        WARNING("NtGdiColorCorrectPalette(): Invalid hdc or hpal\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* GreGetDeviceGammaRampInternal
*
* History:
*
* Wrote it:
*  28.Jun.2000 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreGetDeviceGammaRampInternal(
    HDEV   hdev,
    LPVOID lpGammaRamp
    )
{
    BOOL bRet = FALSE;
    PDEVOBJ po(hdev);

    //
    // GetDeviceGammaRamp is only for display device.
    //
    if (po.bValid() && po.bDisplayPDEV())
    {
        //
        // Check color depth is not less than 8 bpp (need 256 color at least)
        //
        if ((po.iDitherFormat() == BMF_8BPP)  ||
            (po.iDitherFormat() == BMF_16BPP) ||
            (po.iDitherFormat() == BMF_24BPP) ||
            (po.iDitherFormat() == BMF_32BPP))
        {
            //
            // Check this PDEV has thier own GammaTable or not.
            //
            if (po.bHasGammaRampTable())
            {
                ICMMSG(("GreGetDeviceGammaRamp(): Use PDEV's GammaRamp Table\n"));

                //
                // Copy from PDEV's GammaRamp buffer.
                //
                RtlCopyMemory(lpGammaRamp,po.pvGammaRampTable(),MAX_COLORTABLE * sizeof(WORD) * 3);
            }
            else
            {
                ICMMSG(("GreGetDeviceGammaRamp(): Use default GammaRamp Table\n"));

                //
                // Fill up with ident. GammaRamp
                //
                LPWORD lpRed   = (LPWORD)lpGammaRamp;
                LPWORD lpGreen = (LPWORD)lpGammaRamp + MAX_COLORTABLE;
                LPWORD lpBlue  = (LPWORD)lpGammaRamp + MAX_COLORTABLE + MAX_COLORTABLE;

                //
                // Indent. GammaRamp is 0x0000 -> 0xFF00 for each R,G and B.
                // And LOBYTE is 0, only HIBYTE has value from 0 to 0xFF.
                //
                for (UINT i = 0; i < MAX_COLORTABLE; i++)
                {
                    lpRed[i] = lpGreen[i] = lpBlue[i] = (WORD)(i << 8);
                }
            }

            //
            // Filled up the buffer, return TRUE.
            //
            bRet = TRUE;
        }
        else
        {
            ICMMSG(("GreGetDeviceGammaRamp(): Surface is less than 8 bpp\n"));
        }
    }
    else
    {
        ICMMSG(("GreGetDeviceGammaRamp(): DC might not be display\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* GreGetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreGetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    ICMAPI(("GreGetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // DC should not be info or meta DC.
        //
        if (dco.dctp() == DCTYPE_DIRECT)
        {
            DEVLOCKOBJ dlo;

            if (dlo.bLock(dco))
            {
                bRet = GreGetDeviceGammaRampInternal(dco.hdev(),lpGammaRamp);
            }
        }

        dco.vUnlockFast();
    }

    if (!bRet)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiGetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
NtGdiGetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    ICMAPI(("NtGdiGetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    if (lpGammaRamp)
    {
        HANDLE hSecure = NULL;
        BOOL   bError  = FALSE;

        __try
        {
            ProbeForWrite(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, sizeof(WORD));
            hSecure = MmSecureVirtualMemory(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, PAGE_READWRITE);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiGetDeviceGammaRamp: Fail to capture usermode buffer\n");
            bError = TRUE;
        }

        if ((bError == FALSE) && hSecure)
        {
            bRet = GreGetDeviceGammaRamp(hdc,lpGammaRamp);
        }

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreSetDeviceGammaRampInternal
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
*   2.Nov.1998 -by- Scott MacDonald [smac] Split it into two functions
\**************************************************************************/

BOOL
GreSetDeviceGammaRampInternal(
    HDEV    hdev,
    LPVOID  lpGammaRamp,
    BOOL    bDoRangeCheck
    )
{
    ICMAPI(("GreSetDeviceGammaRampInternal\n"));

    BOOL bRet = FALSE;
    PDEVOBJ po(hdev);

    //
    // GetDeviceGammaRamp is only for display device.
    //
    if (po.bValid() && po.bDisplayPDEV())
    {
        BOOL bUsePalette = FALSE;
        BOOL bValidBPP = FALSE;

        //
        // Check color depth is not less than 8 bpp (need 256 color at least)
        //
        if ((po.iDitherFormat() == BMF_8BPP)  ||
            (po.iDitherFormat() == BMF_16BPP) ||
            (po.iDitherFormat() == BMF_24BPP) ||
            (po.iDitherFormat() == BMF_32BPP))
        {
            if ((PPFNVALID(po, IcmSetDeviceGammaRamp)) &&
                (po.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP))
            {
                //
                // Driver supports DrvSetDeviceGammaRamp()
                //
                bValidBPP = TRUE;
            }
            else
            {
                //
                // Driver does not suppprt it, but we can sinulate it
                // with palette only for 8 bpp case.
                //
                if ((po.iDitherFormat() == BMF_8BPP) && po.bIsPalManaged())
                {
                    //
                    // For 8 bpp surface, we can adjust color via
                    // palette on device if palettalized device.
                    //
                    bUsePalette = TRUE;
                    bValidBPP = TRUE;
                }
            }
        }
        else
        {
            //
            // Can not set GammaRamp for 1/4 bpp surface
            //
        }

        //
        // PDEV's bpp is suite for set GammaRamp ?
        //
        if (bValidBPP)
        {
            BOOL bNeedCallDriver = TRUE;
            BOOL bDefaultGammaRamp = !bDoRangeCheck;
            BOOL bSameGammaRamp = FALSE;

            if (po.bHasGammaRampTable())
            {
                //
                // If this PDEV is already has GammaRamp table, we will check
                // this is same as the table what we are going to set.
                //
                if (RtlCompareMemory(po.pvGammaRampTable(),
                                     lpGammaRamp,
                                     MAX_COLORTABLE * sizeof(WORD) * 3)
                    == (MAX_COLORTABLE * sizeof(WORD) * 3))
                {
                    //
                    // Same
                    //
                    bSameGammaRamp = TRUE;
                }
            }

            if (bSameGammaRamp)
            {
                ICMMSG(("GreSetDeviceGammaRamp(): Same GammaRamp is already selected\n"));

                //
                // Same GammaRamp is already selected, nothing need to do.
                //
                bRet = TRUE;
            }
            else
            {
                //
                // Scan the input GammaRamp to check within the range.
                //
                LPWORD lpRed   = (LPWORD)lpGammaRamp;
                LPWORD lpGreen = (LPWORD)lpGammaRamp + MAX_COLORTABLE;
                LPWORD lpBlue  = (LPWORD)lpGammaRamp + MAX_COLORTABLE + MAX_COLORTABLE;

                INT    iRange = (INT)(giIcmGammaRange);

                //
                // if we encounter any Gamma outside range, break!
                //
                for (UINT i = 0; ((i < MAX_COLORTABLE) && (bNeedCallDriver == TRUE)); i++)
                {
                    UINT iAveGamma = i;

                    UINT iRed   = (UINT)(lpRed[i]   >> 8);
                    UINT iGreen = (UINT)(lpGreen[i] >> 8);
                    UINT iBlue  = (UINT)(lpBlue[i]  >> 8);

                    INT iRangeMax = (INT)(iAveGamma + iRange);
                    INT iRangeMin = (INT)(iAveGamma - iRange);

                    ICMMSG(("iRangeMax = %x:iRangeMix = %x:iRed = %x:iGreen = %x:iBlue = %x\n",
                             iRangeMax,     iRangeMin,(INT)iRed,(INT)iGreen,(INT)iBlue));

                    if ((((INT)iRed   < iRangeMin) || ((INT)iRed   > iRangeMax) ||
                        ((INT)iGreen < iRangeMin) || ((INT)iGreen > iRangeMax) ||
                        ((INT)iBlue  < iRangeMin) || ((INT)iBlue  > iRangeMax)) &&
                        bDoRangeCheck)
                    {
                        //
                        // The Gamma is out of range, don't need call driver
                        //
                        bNeedCallDriver = FALSE;
                    }

                    //
                    // Check if the GammaRamp is ident. or not.
                    //
                    if (bDefaultGammaRamp &&
                        ((lpRed[i]   != (iAveGamma << 8)) ||
                         (lpGreen[i] != (iAveGamma << 8)) ||
                         (lpBlue[i]  != (iAveGamma << 8))))
                    {
                        ICMMSG(("GreSetDeviceGammaRamp():Not ident. GammaRamp\n"));

                        bDefaultGammaRamp = FALSE;
                    }
                }

                if (bNeedCallDriver)
                {
                    if (bUsePalette && bDefaultGammaRamp)
                    {
                        //
                        // If we will use palette, and GammaRamp are going to changed to
                        // default, we don't need to have GammaRamp table.
                        //
                        if (po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Default GammaRamp (need update palette)\n"));

                            //
                            // The specified GammaRamp is ident., don't need to keep it.
                            //
                            po.bHasGammaRampTable(FALSE);
                            VFREEMEM(po.pvGammaRampTable());
                            po.pvGammaRampTable(NULL);
                        }
                        else
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Default GammaRamp (no palette call)\n"));

                            //
                            // If we don't have GammaRamp table in PDEV, it means
                            // we are in defult already. So don't need to call driver
                            // (= don't need to update palette.)
                            //
                            bNeedCallDriver = FALSE;
                        }
                    }
                    else
                    {
                        //
                        // Check this PDEV has thier own GammaTable or not.
                        //
                        if (!po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp(): Allocate GammaRamp Table\n"));

                            //
                            // Allocate GammaRamp table for this PDEV
                            //
                            LPVOID pv = (LPVOID) PALLOCNOZ(MAX_COLORTABLE * sizeof(WORD) * 3,'mciG');

                            if (pv)
                            {
                                //
                                // Mark this PDEV has GammaTable.
                                //
                                po.pvGammaRampTable(pv);
                                po.bHasGammaRampTable(TRUE);
                            }
                            else
                            {
                                WARNING("GreSetDeviceGammaRamp():Fail to allocate GammaRamp table\n");

                                //
                                // Error, we don't need to call driver.
                                //
                                bNeedCallDriver = FALSE;
                            }
                        }
                    }

                    if (bNeedCallDriver)
                    {
                        if (po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Updating GammaRamp Table in PDEV...\n"));

                            //
                            // Save new GammaRamp into PDEV.
                            //
                            RtlCopyMemory(po.pvGammaRampTable(),lpGammaRamp,
                                          MAX_COLORTABLE * sizeof(WORD) * 3);
                        }

                        //
                        // Update GammaRamp on device using PDEV's GammaRamp Table.
                        //
                        bRet = UpdateGammaRampOnDevice(po.hdev(),TRUE);

                        if (bDefaultGammaRamp && po.bHasGammaRampTable())
                        {
                            ICMMSG(("GreSetDeviceGammaRamp():Default GammaRamp is setted (non-palette)\n"));

                            //
                            // The specified GammaRamp is ident., don't need to keep it.
                            //
                            po.bHasGammaRampTable(FALSE);
                            VFREEMEM(po.pvGammaRampTable());
                            po.pvGammaRampTable(NULL);
                        }
                    }
                    else
                    {
                        //
                        // Fail... couldn't call driver and return false.
                        //
                        bRet = FALSE;
                    }
                }
                else
                {
                    ICMMSG(("GreSetDeviceGammaRamp(): GammaRamp is out of range\n"));
                }
            }
        }
        else
        {
            ICMMSG(("GreSetDeviceGammaRamp(): Surface/Driver does not support loadable GammaRamp\n"));
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* GreSetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreSetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp,
    BOOL    bDoRangeCheck
    )
{
    ICMAPI(("GreSetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    XDCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // DC should not be info or meta DC.
        //
        if (dco.dctp() == DCTYPE_DIRECT)
        {
            DEVLOCKOBJ dlo;

            if (dlo.bLock(dco))
            {
                bRet = GreSetDeviceGammaRampInternal(dco.hdev(),
                                                     lpGammaRamp,
                                                     bDoRangeCheck);
            }
        }

        dco.vUnlockFast();
    }

    if (!bRet)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* NtGdiSetDeviceGammaRamp
*
* History:
*
* Wrote it:
*   1.Apr.1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
NtGdiSetDeviceGammaRamp(
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    ICMAPI(("NtGdiSetDeviceGammaRamp\n"));

    BOOL bRet = FALSE;

    if (lpGammaRamp)
    {
        HANDLE hSecure = NULL;
        BOOL   bError  = FALSE;

        __try
        {
            ProbeForRead(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, sizeof(WORD));
            hSecure = MmSecureVirtualMemory(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, PAGE_READONLY);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiSetDeviceGammaRamp: Fail to capture usermode buffer\n");
            bError = TRUE;
        }

        if ((bError == FALSE) && hSecure)
        {
            bRet = GreSetDeviceGammaRamp(hdc,lpGammaRamp,TRUE);
        }

        if (hSecure)
        {
            MmUnsecureVirtualMemory(hSecure);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* cjGetLogicalColorSpace
*
* Arguments:
*
* Return Value:
*
* History:
*
*    9/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

INT
cjGetLogicalColorSpace(
    HANDLE hColorSpace,
    INT    cjBuffer,
    LPVOID lpvBuffer
    )
{
    ICMAPI(("cjGetLogicalColorSpace\n"));

    INT cRet = 0;

    if (cjBuffer >= sizeof(LOGCOLORSPACEW) && (lpvBuffer != NULL))
    {
        COLORSPACEREF ColorSpace((HCOLORSPACE)hColorSpace);

        if (ColorSpace.bValid())
        {
            LPLOGCOLORSPACEW lpLogColorSpace = (LPLOGCOLORSPACEW)lpvBuffer;

            lpLogColorSpace->lcsSignature = ColorSpace.pColorSpace()->lcsSignature();
            lpLogColorSpace->lcsVersion   = ColorSpace.pColorSpace()->lcsVersion();
            lpLogColorSpace->lcsSize      = ColorSpace.pColorSpace()->lcsSize();
            lpLogColorSpace->lcsCSType    = ColorSpace.pColorSpace()->lcsCSType();
            lpLogColorSpace->lcsIntent    = ColorSpace.pColorSpace()->lcsIntent();

            ColorSpace.pColorSpace()->vGETlcsEndpoints(&lpLogColorSpace->lcsEndpoints);

            lpLogColorSpace->lcsGammaRed  = ColorSpace.pColorSpace()->lcsGammaRed();
            lpLogColorSpace->lcsGammaGreen= ColorSpace.pColorSpace()->lcsGammaGreen();
            lpLogColorSpace->lcsGammaBlue = ColorSpace.pColorSpace()->lcsGammaBlue();

            ColorSpace.pColorSpace()->vGETlcsFilename((PWCHAR)&lpLogColorSpace->lcsFilename[0],MAX_PATH);

            if (cjBuffer >= sizeof(LOGCOLORSPACEEXW))
            {
                PLOGCOLORSPACEEXW lpLogColorSpaceEx = (PLOGCOLORSPACEEXW)lpvBuffer;

                lpLogColorSpaceEx->dwFlags = ColorSpace.pColorSpace()->lcsExFlags();

                cRet = sizeof(LOGCOLORSPACEEXW);
            }
            else
            {
                cRet = sizeof(LOGCOLORSPACEW);
            }
        }
    }

    return cRet;
}

/******************************Public*Routine******************************\
* GreIcmQueryBrushBitmap
*
* Arguments:
*
* Return Value:
*
* History:
*
* Rewrite it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreIcmQueryBrushBitmap(
    HDC          hdc,
    HBRUSH       hbrush,
    PBITMAPINFO  pbmiDIB,
    PVOID        pvBits,
    ULONG       *pulBits,
    DWORD       *piUsage,
    BOOL        *pbAlreadyTran
)
{
    BOOL    bRet = FALSE;

    DWORD   iUsage = DIB_RGB_COLORS;
    BOOL    bAlreadyTran = FALSE;
    PBYTE   pDIBits = NULL;

    ULONG   ulSizeInfo = sizeof(BITMAPINFO) + ((MAX_COLORTABLE - 1) * sizeof(RGBQUAD));

    ICMAPI(("GreIcmQueryBrushBitmap\n"));

    if ((pbmiDIB == NULL) || (piUsage == NULL) || (pbAlreadyTran == NULL) || (pulBits == NULL))
    {
        return FALSE;
    }

    XDCOBJ  dcoDst(hdc);

    if (dcoDst.bValid())
    {
        //
        // ICM must be on, non-device mode only
        //
        if (dcoDst.pdc->bIsHostICM())
        {
            BRUSHSELOBJ bro((HBRUSH) hbrush);

            if (bro.bValid())
            {
                //
                // must be a DIB brush
                //
                if (bro.flAttrs() & BR_IS_DIB)
                {
                    //
                    // if brush was created with DIB_PAL_COLORS then
                    // ICM translation is not needed.
                    //
                    if ((iUsage = bro.iUsage()) == DIB_RGB_COLORS)
                    {
                        //
                        // see if translated DIB already exists
                        //
                        PBRUSH pbr = bro.pbrush();

                        if (pbr->hFindIcmDIB(dcoDst.pdc->hcmXform()) != NULL)
                        {
                            ICMMSG(("GreIcmQueryBrushBitmap() Find !\n"));

                            bAlreadyTran = TRUE;
                        }
                        else
                        {
                            ICMMSG(("GreIcmQueryBrushBitmap() Not Find, then create it!\n"));

                            bAlreadyTran = FALSE;

                            //
                            // Initialize BITMAPINFO header.
                            //
                            RtlZeroMemory(pbmiDIB,ulSizeInfo);
                            pbmiDIB->bmiHeader.biSize = sizeof(BITMAPINFO);

                            //
                            // get bits per pixel, could use this to determine if color table is needed
                            //
                            bRet = GreGetDIBitsInternal(hdc,
                                                        bro.hbmPattern(),
                                                        0,0,NULL,
                                                        pbmiDIB,
                                                        DIB_RGB_COLORS,
                                                        0,ulSizeInfo);

                            if (bRet)
                            {
                                ULONG cjBits = GreGetBitmapBitsSize(pbmiDIB);

                                if (cjBits == 0)
                                {
                                    //
                                    // Empty or overflow..
                                    //
                                    bRet = FALSE;
                                }
                                else if (pvBits == NULL)
                                {
                                    //
                                    // Caller want to know the size of bitmap.
                                    //
                                    *pulBits = cjBits;

                                    bRet = TRUE;
                                }
                                else if (cjBits <= *pulBits)
                                {
                                    //
                                    // We have enough memory to get bitmap bits.
                                    //
                                    bRet = GreGetDIBitsInternal(hdc,
                                                                bro.hbmPattern(),
                                                                0,
                                                                ABS(pbmiDIB->bmiHeader.biHeight),
                                                                (LPBYTE) pvBits,
                                                                pbmiDIB,
                                                                DIB_RGB_COLORS,
                                                                cjBits,
                                                                ulSizeInfo);

                                    //
                                    // Put used size.
                                    //
                                    *pulBits = cjBits;
                                }
                                else
                                {
                                    WARNING("GreIcmQueryBrushBitmap: the buffer is not enough\n");
                                }
                            }
                            else
                            {
                                WARNING("GreIcmQueryBrushBitmap: failed to GetDIBits\n");
                            }
                        }
                    }
                    else
                    {
                        ICMMSG(("GreIcmQueryBrushBitmap: brush is not DIB_RGB_COLORS\n"));
                    }
                }
                else
                {
                    ICMMSG(("GreIcmQueryBrushBitmap: brush is not DIBPATTERN\n"));
                }
            }
            else
            {
                WARNING("GreIcmQueryBrushBitmap: invalid brush\n");
            }
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING("GreIcmQueryBrushBitmap: invalid DC\n");
    }

    *piUsage = iUsage;
    *pbAlreadyTran = bAlreadyTran;

    return (bRet);
}

/******************************Public*Routine******************************\
* GreIcmSetBrushBitmap
*
* Arguments:
*
* Return Value:
*
* History:
*
* Rewrite it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
GreIcmSetBrushBitmap(
    HDC          hdc,
    HBRUSH       hbrush,
    PBITMAPINFO  pbmiDIB,
    PVOID        pvBits
)
{
    BOOL bRet = FALSE;

    ULONG ulSizeInfo = sizeof(BITMAPINFO) + ((MAX_COLORTABLE - 1) * sizeof(RGBQUAD));

    ICMAPI(("GreIcmSetBrushBitmap\n"));

    XDCOBJ  dcoDst(hdc);

    if (dcoDst.bValid())
    {
        //
        // ICM must be on, non-device mode only
        //
        if (dcoDst.pdc->bIsHostICM())
        {
            BRUSHSELOBJ bro((HBRUSH) hbrush);

            if (bro.bValid())
            {
                //
                // must be a DIB brush
                //
                if (bro.flAttrs() & BR_IS_DIB)
                {
                    //
                    // Create a new DIB for this brush based on
                    // the DC's hcmXform. The client must already
                    // have translated this DIB
                    //
                    PBRUSH pbr = bro.pbrush();

                    //
                    // try to create a new DIB
                    //
                    HBITMAP hDIB = GreCreateDIBitmapReal(
                                                  hdc,
                                                  CBM_INIT | CBM_CREATEDIB,
                                                  (PBYTE)pvBits,
                                                  pbmiDIB,
                                                  DIB_RGB_COLORS,
                                                  ulSizeInfo,
                                                  0x007fffff,
                                                  NULL,
                                                  0,
                                                  NULL,
                                                  CDBI_INTERNAL,
                                                  0,
                                                  NULL);

                    if (hDIB)
                    {
                        //
                        // Keep translate DIB in cache.
                        //
                        bRet = pbr->bAddIcmDIB(dcoDst.pdc->hcmXform(),hDIB);
                    }
                }
                else
                {
                    ICMMSG(("GreIcmSetBrushBitmap: brush is not DIBPATTERN\n"));
                }
            }
            else
            {
                WARNING("GreIcmSetBrushBitmap: invalid brush\n");
            }
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING("GreIcmSetBrushBitmap: invalid DC\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtGdiIcmBrushInfo
*
* Arguments:
*
* Return Value:
*
* History:
*
* Rewrite it:
*   27-Jan-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
NtGdiIcmBrushInfo(
    HDC          hdc,
    HBRUSH       hbrush,
    PBITMAPINFO  pbmiDIB,
    PVOID        pvBits,
    ULONG       *pulBits,
    DWORD       *piUsage,
    BOOL        *pbAlreadyTran,
    ULONG        Command
    )
{
    BOOL   bRet = TRUE;

    HANDLE hSecureHeader = NULL;
    HANDLE hSecureBits = NULL;

    ULONG  cjHeader = (sizeof(BITMAPINFO) + ((MAX_COLORTABLE - 1) * sizeof(RGBQUAD)));
    ULONG  cjBits = 0;

    switch (Command)
    {
    case IcmQueryBrush:
    {
        BOOL   bAlreadyTran = FALSE;
        DWORD  iUsage = DIB_RGB_COLORS;

        __try
        {
            //
            // Capture user mode memories.
            //
            ProbeForWrite(pbmiDIB,cjHeader,sizeof(DWORD));
            hSecureHeader = MmSecureVirtualMemory(pbmiDIB,cjHeader,PAGE_READWRITE);

            if ((pvBits != NULL) && hSecureHeader)
            {
                //
                // Caller needs bitmap bits
                //
                ProbeForRead(pulBits,sizeof(ULONG),sizeof(ULONG));
                cjBits = *pulBits;

                ProbeForWrite(pvBits,cjBits,sizeof(DWORD));
                hSecureBits = MmSecureVirtualMemory(pvBits,cjBits,PAGE_READWRITE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiIcmBrushInfo - IcmQueryBrush failed copy usermode parameter\n");
            bRet = FALSE;
        }

        if (bRet && hSecureHeader && ((pvBits == NULL) || hSecureBits))
        {
            //
            // Get DIB brush bits.
            //
            bRet = GreIcmQueryBrushBitmap(hdc,
                                          hbrush,
                                          pbmiDIB,
                                          pvBits,
                                          &cjBits,
                                          &iUsage,
                                          &bAlreadyTran);
        }

        if (bRet)
        {
            __try
            {
                ProbeForWrite(pulBits,sizeof(ULONG),sizeof(ULONG));
                *pulBits = cjBits;

                if (pbAlreadyTran)
                {
                    ProbeForWrite(pbAlreadyTran,sizeof(BOOL), sizeof(BOOL));
                    *pbAlreadyTran = bAlreadyTran;
                }

                if (piUsage)
                {
                    ProbeForWrite(piUsage,sizeof(DWORD), sizeof(DWORD));
                    *piUsage = iUsage;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                 WARNING("NtGdiIcmBrushInfo failed copy usermode parameter\n");
                 bRet = FALSE;
            }
        }

        break;
    }

    case IcmSetBrush:
    {
        __try
        {
            //
            // Lock down header memory.
            //
            ProbeForRead(pbmiDIB,cjHeader,sizeof(DWORD));
            hSecureHeader = MmSecureVirtualMemory(pbmiDIB,cjHeader,PAGE_READWRITE);

            ProbeForRead(pulBits,sizeof(ULONG),sizeof(ULONG));
            cjBits = *pulBits;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("NtGdiIcmBrushInfo - IcmSetBrush failed copy usermode parameter\n");
            bRet = FALSE;
        }

        if (bRet && hSecureHeader)
        {
            //
            // Compute bitmap size.
            //
            ULONG cjBitsNeeded = GreGetBitmapBitsSize(pbmiDIB);

            if ((cjBitsNeeded == 0) || (cjBitsNeeded > cjBits))
            {
                WARNING1("NtGdiIcmBrushInfo - IcmSetBrush bitmap size is wrong\n");
                bRet = FALSE;
            }
            else
            {
                __try
                {
                    //
                    // Lock Bits.
                    //
                    ProbeForRead(pvBits,cjBitsNeeded,sizeof(DWORD));
                    hSecureBits = MmSecureVirtualMemory(pvBits,cjBitsNeeded,PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("NtGdiIcmBrushInfo - IcmSetBrush failed lock pvBits\n");
                    bRet = FALSE;
                }

                if (bRet && hSecureBits)
                {
                    //
                    // Set brush DIB bits.
                    //
                    bRet = GreIcmSetBrushBitmap(hdc,
                                                hbrush,
                                                pbmiDIB,
                                                pvBits);
                }
            }
        }

        break;
    }

    default:

        WARNING("NtGdiIcmBrushInfo(): unknown command\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }

    //
    // Unlock user mode memory if locked.
    //
    if (hSecureHeader)
    {
        MmUnsecureVirtualMemory(hSecureHeader);
    }

    if (hSecureBits)
    {
        MmUnsecureVirtualMemory(hSecureBits);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* bInitIcm
*
*   Init ICM information
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    9/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

extern "C" BOOL bInitICM()
{
    ICMAPI(("bInitIcm\n"));

    BOOL bRet = TRUE;

    //
    // Read ICM configuration.
    //
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    NTSTATUS NtStatus;

    ULONG iIcmControlFlag = 0;

    //
    // read icm global configuration.
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = (RTL_QUERY_REGISTRY_DIRECT |
                           RTL_QUERY_REGISTRY_REQUIRED);
    QueryTable[0].Name = (PWSTR)L"GdiIcmControl";
    QueryTable[0].EntryContext = (PVOID) &iIcmControlFlag;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = 0;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = (PWSTR)NULL;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"ICM",
                                      QueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING1("Error reading GdiIcmControl (Optional, Not Error)\n");
        iIcmControlFlag = 0L;
    }

    //
    // NOTE: After sRGB.icm become really default.
    //
    if (!(iIcmControlFlag & ICM_CONTROL_WIN95_COLORSPACE))
    {
        //
        // Configure default colorspace to sRGB.
        //
        gcsStockColorSpace.lcsCSType = LCS_sRGB;

        //
        // Set sRGB color profile name.
        //
        wcscpy(gcsStockColorSpace.lcsFilename,sRGB_PROFILENAME);
    }

    //
    // Next, try to read GammaRange
    //

    //
    // Initialize with default value.
    //
    giIcmGammaRange = 0x80; // Plus/Minus 128 is allowable by default.

    QueryTable[0].Name = (PWSTR)L"GdiIcmGammaRange";
    QueryTable[0].EntryContext = (PVOID) &giIcmGammaRange;

    NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                      L"ICM",
                                      QueryTable,
                                      NULL,
                                      NULL);

    if(!NT_SUCCESS(NtStatus))
    {
        WARNING1("Error reading GdiIcmGammaRange (Optional, Not Error)\n");
        giIcmGammaRange = 0x80; // Plus/Minus 128 is allowable by default.
    }

    //
    // Validate the value
    //
    if (giIcmGammaRange > 256)
    {
        giIcmGammaRange = 256;
    }

    #if HIDEYUKN_DBG
    DbgPrint("GDI:IcmControlFlag = %x\n",iIcmControlFlag);
    DbgPrint("GDI:IcmGammaRange  = %x\n",giIcmGammaRange);
    #endif

    //
    // Create Logical Color Space StockObject.
    //
    LOGCOLORSPACEEXW LogColorSpaceExW;

    LogColorSpaceExW.lcsColorSpace = gcsStockColorSpace;
    LogColorSpaceExW.dwFlags       = 0;

    HCOLORSPACE hColorSpace = GreCreateColorSpace(&LogColorSpaceExW);

    if (hColorSpace)
    {
        //
        // Set Owner of color space.
        //
        HmgSetOwner((HOBJ)hColorSpace, OBJECT_OWNER_PUBLIC, ICMLCS_TYPE);

        //
        // Mark the object is undeletable
        //
        HmgMarkUndeletable((HOBJ)hColorSpace,ICMLCS_TYPE);

        //
        // Set this colorspace to stock object.
        //
        bSetStockObject(hColorSpace,PRIV_STOCK_COLORSPACE);

        //
        // Keep stcok object to global
        //
        ghStockColorSpace = (HCOLORSPACE)GreGetStockObject(PRIV_STOCK_COLORSPACE);

        //
        // Lock color space to increment ref. count. (never become zero !)
        //
        gpStockColorSpace = (PCOLORSPACE)HmgShareLock((HOBJ)ghStockColorSpace,ICMLCS_TYPE);

        //
        // Initialize default DC_ATTR and DCLEVEL.
        //
        DcAttrDefault.hColorSpace  = ghStockColorSpace;
        dclevelDefault.pColorSpace = gpStockColorSpace;

        if (gpStockColorSpace == NULL)
        {
            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\icmobj.cxx ===
/*******************************Module*Header*******************************\
* Module Name:
*
*   icmobj.cxx
*
* Abstract
*
*   This module contains object support for COLORTRANSFORM objects and ICM
*   Objects
*
* Author:
*
*  Feb.23.1997 -by- Hideyuki Nagase [hideyukn]
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* COLORTRANSFORMOBJ::hCreate()
*
* History:
*
* Write it:
*    23-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

HANDLE
COLORTRANSFORMOBJ::hCreate(
    XDCOBJ&         dco,
    LOGCOLORSPACEW *pLogColorSpaceW,
    PVOID           pvSource,
    ULONG           cjSource,
    PVOID           pvDestination,
    ULONG           cjDestination,
    PVOID           pvTarget,
    ULONG           cjTarget
    )
{
    HANDLE hObject = NULL;

    PCOLORTRANSFORM pNewCXform = NULL;

    ICMAPI(("COLORTRANSFORM::hCreate()\n"));

    HDEV hdev = dco.hdev();

    //
    // This object should not have any existing realization.
    //
    ASSERTGDI(_pColorTransform == NULL,"COLORTRANSFORMOBJ::hCreate() object is exist\n");

    PDEVOBJ po(hdev);

    if (po.bValid())
    {
        //
        // Allocate ColorTransform object.
        //
        pNewCXform = (PCOLORTRANSFORM) ALLOCOBJ(sizeof(COLORTRANSFORM),ICMCXF_TYPE, FALSE);

        if (pNewCXform)
        {
            //
            // Register COLORTRANSFORM handle.
            //
            hObject = (HCOLORSPACE)HmgInsertObject(
                                        pNewCXform,
                                        HMGR_ALLOC_ALT_LOCK,
                                        ICMCXF_TYPE);

            if (hObject)
            {
                HANDLE hDeviceColorTransform = NULL;

                //
                // Set new object to this COLORTRANSFORMNOBJ
                //
                _pColorTransform = pNewCXform;

                //
                // Lock device
                //
                DEVLOCKOBJ devLock(po);

                //
                // Create driver's transform.
                //
                if (PPFNVALID(po,IcmCreateColorTransform))
                {
                    //
                    // Call device driver to obtain handle of device driver.
                    //
                    hDeviceColorTransform = (*PPFNDRV(po, IcmCreateColorTransform)) (
                                                          po.dhpdev(),
                                                          pLogColorSpaceW,
                                                          pvSource, cjSource,
                                                          pvDestination, cjDestination,
                                                          pvTarget, cjTarget,
                                                          0 /* dwReserved */);
                }
                else
                {
                    WARNING("CreateColorTransform called on device that does not support call\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                }

                if (hDeviceColorTransform)
                {
                    ICMMSG(("CreateColorTransform(): Succeed to get handle from driver\n"));

                    //
                    // Set the handle to COLORTRANSFORM object.
                    //
                    vSetDeviceColorTransform(hDeviceColorTransform);

                    //
                    // Insert this pColorTransform to this DC.
                    //
                    dco.bAddColorTransform(hObject);
                }
                else
                {
                    ICMMSG(("CreateColorTransform(): Fail to get handle from driver\n"));

                    //
                    // Mark this object does not have driver's realization.
                    //
                    vSetDeviceColorTransform(NULL);

                    //
                    // We are fail to get driver's handle, delete this.
                    //
                    bDelete(dco);

                    //
                    // Invalidate hObject and pColorTransform.
                    //  (these are deleted in above bDelete())
                    //
                    hObject = NULL;
                    pNewCXform = NULL;
                }
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        }

        if ((hObject == NULL) && (pNewCXform != NULL))
        {
            FREEOBJ(pNewCXform,ICMCXF_TYPE);
        }
    }

    return (hObject);
}

/******************************Public*Routine******************************\
* COLORTRANSFORMOBJ::bDelete()
*
* History:
*
* Write it:
*    23-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL
COLORTRANSFORMOBJ::bDelete(XDCOBJ& dco,BOOL bProcessCleanup)
{
    BOOL bRet = FALSE;

    PCOLORTRANSFORM pDeleteXCForm;

    ICMAPI(("COLORTRANSFORM::bDelete()\n"));

    if (bValid())
    {
        BOOL bCanBeRemoved;

        //
        // Get colortransform object handle.
        //
        HANDLE hObject = _pColorTransform->hColorTransform();

        //
        // Unlock it. (this was locked in constructor).
        //
        DEC_SHARE_REF_CNT(_pColorTransform);

        //
        // Remote from object table.
        //
        bCanBeRemoved = (BOOL)(ULONG_PTR)HmgRemoveObject((HOBJ)(hObject),0,0,TRUE,ICMCXF_TYPE);

        if (bCanBeRemoved)
        {
            HANDLE hDeviceColorTransform;

            //
            // Yes, we can remove object from object table, try to delete driver's realization.
            //
            ICMMSG(("DeleteColorTransform(): Succeed to remove object from table\n"));

            //
            // Get device driver's handle.
            //
            hDeviceColorTransform = hGetDeviceColorTransform();

            if (hDeviceColorTransform)
            {
                //
                // Initialize PDEV object with owner.
                //
                PDEVOBJ po(dco.hdev());

                if (po.bValid())
                {
                    if (po.bUMPD() && bProcessCleanup)
                    {
                        ICMMSG(("DeleteColorTransform():Will not callout to user mode since UMPD.\n"));

                        //
                        // Overwrite driver transform as NULL.
                        //
                        vSetDeviceColorTransform(NULL);
                    }
                    else
                {
                    DEVLOCKOBJ devLock(po);

                    //
                    // Delete driver's realization.
                    //
                    if (PPFNVALID(po,IcmDeleteColorTransform))
                    {
                        //
                        // Call device driver to free driver's handle
                        //
                        if ((*PPFNDRV(po, IcmDeleteColorTransform))(
                                               po.dhpdev(),
                                               hDeviceColorTransform))
                        {
                            ICMMSG(("DeleteColorTransform():Succeed to IcmDeleteColorTransform()\n"));

                            //
                            // This object does not have driver realization anymore.
                            //
                            vSetDeviceColorTransform(NULL);
                        }
                        else
                        {
                            WARNING("DeleteColorTransform():Fail to IcmDeleteColorTransform()\n");
                        }
                    }
                    else
                    {
                        WARNING("DeleteColorTransform called on device that does not support call\n");
                        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    }
                }
            }
            }
            else
            {
                ICMMSG(("DeleteColorTransform(): There is no driver handle\n"));
            }

            //
            // We could delete object allocation if there is no driver's realization.
            //
            if (hGetDeviceColorTransform() == NULL)
            {
                //
                // Remove this pColorTransform from DC.
                //
                dco.bRemoveColorTransform(hObject);

                //
                // Free it.
                //
                FREEOBJ(_pColorTransform,ICMCXF_TYPE);

                //
                // Invalidate pointer.
                //
                _pColorTransform = NULL;

                //
                // Yes, everything fine!
                //
                bRet = TRUE;
            }
        }
        else
        {
            ICMMSG(("DeleteColorTransform(): Fail to remove object from table\n"));
        }

        //
        // If we could not remove this object from object table, or could not
        // delete object (including driver's realization)
        //
        if ((!bCanBeRemoved) || (!bRet))
        {
            //
            // can not delete now. somebody will using...
            //
            WARNING("COLORTRANSFORMOBJ::vDelete(): Fail to Delete object, lazy deletion may happen\n");

            //
            // Back reference counter (deconstuctor will decrement this).
            //
            INC_SHARE_REF_CNT(_pColorTransform);

            //
            // Anyway, we will delete later at cleanup.
            //
            bRet = TRUE;
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* XDCOBJ::bAddColorTransform()
*
* History:
*
* Write it:
*    27-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL XDCOBJ::bAddColorTransform(HANDLE hCXform)
{
    CXFLIST *pCXFListThis;

    //
    // Allocate new cell of CXFLIST
    //
    pCXFListThis = (CXFLIST *) PALLOCMEM(sizeof(CXFLIST),'ddaG');

    if (pCXFListThis)
    {
        //
        // Fill up CXFLIST structure
        //
        pCXFListThis->hCXform = hCXform;
        pCXFListThis->pNext   = pdc->pCXFList;

        //
        // Insert this into top of list.
        //
        pdc->pCXFList = pCXFListThis;

        return (TRUE);
    }
    else
    {
        ICMMSG(("XDCOBJ::bAddColorTransform() Failed\n"));
        return (FALSE);
    }
}

/******************************Public*Routine******************************\
* XDCOBJ::bRemoveColorTransform()
*
* History:
*
* Write it:
*    27-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL XDCOBJ::bRemoveColorTransform(HANDLE hCXform)
{
    if (pdc->pCXFList)
    {
        PCXFLIST pPrev, pThis;

        pPrev = pThis = pdc->pCXFList;

        while (pThis)
        {
            if (pThis->hCXform == hCXform)
            {
                //
                // This is the cell, we need to remove.
                //
                if (pPrev == pThis)
                {
                    //
                    // We are going to remove first cell. then need to
                    // update root.
                    //
                    pdc->pCXFList = pThis->pNext;
                }
                else
                {
                    //
                    // Remove this from list.
                    //
                    pPrev->pNext = pThis->pNext;
                }

                //
                // Invalidate root.
                //
                VFREEMEM(pThis);

                return (TRUE);
            }

            //
            // Move to next cell
            //
            pPrev = pThis;
            pThis = pThis->pNext;
        }
    }
    else
    {
        ICMMSG(("bRemoveColorTransform():There is no colortransform()\n"));
    }

    return (FALSE);
}

/******************************Public*Routine******************************\
* XDCOBJ::vCleanupColorTransform()
*
* History:
*
* Write it:
*    27-Feb-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID XDCOBJ::vCleanupColorTransform(BOOL bProcessCleanup)
{
    if (pdc->pCXFList)
    {
        PCXFLIST pLast, pThis;

        pThis = pdc->pCXFList;

        while (pThis)
        {
            COLORTRANSFORMOBJ CXformObj(pThis->hCXform);

            pLast = pThis;

            if (CXformObj.bValid())
            {
                //
                // Delete this color transform
                //
                if (CXformObj.bDelete(*this,bProcessCleanup))
                {
                    ICMMSG(("vCleanupColorTransform():Delete colortransform in this DC\n"));
                }
                else
                {
                    ICMMSG(("vCleanupColorTransform():Fail to delete colortransform in this DC\n"));
                }
            }

            //
            // we don't need to walk through the list, because above COLORTRANSFORMOBJ.bDelete()
            // will re-chain this list, then we just pick up the cell on the top of list everytime.
            //
            pThis = pdc->pCXFList;

            //
            // But if still new pThis is eqaul to pLast, this means we might fail to
            // delete object or un-chain list, then just un-chain this forcely.
            //
            if (pThis == pLast)
            {
                //
                // Skip pThis.
                //
                pThis = pThis->pNext;

                //
                // Update root too,
                //
                pdc->pCXFList = pThis;
            }
        }
    }
    else
    {
        // ICMMSG(("vCleanupColorTransform():There is no color transform in this DC\n"));
    }
}

/******************************Public*Routine******************************\
* XEPALOBJ::CorrectColors()
*
* History:
*
* Write it:
*    29-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

VOID XEPALOBJ::CorrectColors(PPALETTEENTRY ppalentry, ULONG cEntries)
{
    ICMMSG(("XEPALOBJ::CorrectColors\n"));

    PDEVOBJ po(hdevOwner());

    if (po.bValid())
    {
        if (po.bHasGammaRampTable())
        {
            ICMMSG(("XEPALOBJ::CorrectColors(): Do Gamma Correction\n"));
            ICMMSG(("XEPALOBJ::CorrectColors(): GammaRamp Owner HDEV = %x\n",po.hdev()));

            PGAMMARAMP_ARRAY pGammaRampArray = (PGAMMARAMP_ARRAY)(po.pvGammaRampTable());

            for (ULONG i = 0; i < cEntries; i++)
            {
                //
                // Adjust colors based on GammaRamp table.
                //
                ppalentry->peRed   = (pGammaRampArray->Red[ppalentry->peRed])     >> 8;
                ppalentry->peGreen = (pGammaRampArray->Green[ppalentry->peGreen]) >> 8;
                ppalentry->peBlue  = (pGammaRampArray->Blue[ppalentry->peBlue])   >> 8;

                //
                // next palette entry
                //
                ppalentry++;
            }
        }
        else
        {
            ICMMSG(("XEPALOBJ::CorrectColors(): PDEV does not have Gamma Table\n"));
        }
    }
    else
    {
        ICMMSG(("XEPALOBJ::CorrectColors(): PDEV is invalid\n"));
    }
}

/******************************Public*Routine******************************\
* UpdateGammaRampOnDevice()
*
* History:
*
* Write it:
*    29-Apr-1997 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

BOOL UpdateGammaRampOnDevice(HDEV hdev,BOOL bForceUpdate)
{
    BOOL bRet = FALSE;

    ICMMSG(("UpdateGammaRampOnDevice()\n"));

    PDEVOBJ po(hdev);

    if (po.bValid())
    {
        ICMMSG(("UpdateGammaRampOnDevice():Set GammaRamp to HDEV = %x\n",po.hdev()));

        if ((po.iDitherFormat() == BMF_8BPP)  ||
            (po.iDitherFormat() == BMF_16BPP) ||
            (po.iDitherFormat() == BMF_24BPP) ||
            (po.iDitherFormat() == BMF_32BPP))
        {
            //
            // Driver might provide the entry point.
            //
            if ((PPFNVALID(po, IcmSetDeviceGammaRamp)) &&
                (po.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP))
            {
                //
                // PDEV should have GammaRampTable
                //
                if (po.bHasGammaRampTable())
                {
                    ICMMSG(("UpdateGammaRampOnDevice():Call SetDeviceGammaRamp()\n"));

                    //
                    // Call device driver to set new GammaRamp.
                    //
                    bRet = (*PPFNDRV(po, IcmSetDeviceGammaRamp))(po.dhpdev(),
                                                                 IGRF_RGB_256WORDS,
                                                                 po.pvGammaRampTable());
                }
            }
            else
            {
                //
                // if the drive does not support, we will simulate it only for 8bpp case.
                //
                if ((po.iDitherFormat() == BMF_8BPP) && (po.bIsPalManaged()))
                {
                    ICMMSG(("UpdateGammaRampOnDevice(): Call SetPalette()\n"));

                    //
                    // Check:
                    // 1) Are we going to reset pallete forcely ? (ex. back to default GammaRamp)
                    // 2) Or, Adjust Palette based on GammaRamp in PDEV.
                    //
                    if (bForceUpdate || po.bHasGammaRampTable())
                    {
                        //
                        // Get palette on device surface.
                        //
                        XEPALOBJ palSurf(po.ppalSurf());

                        ASSERTGDI(palSurf.bIsIndexed(),"UpdateGammaRampOnDevice(): Palette is not indexed\n");

                        //
                        // Mark this palette need to Gamma correction
                        // (if this is not default GammaRamp, default GammaRamp case
                        //  PDEV does not have table.)
                        //
                        palSurf.bNeedGammaCorrection(po.bHasGammaRampTable());

                        //
                        // And put owner of PDEV which has GammaRamp table.
                        // (if they already has some value in there, we will
                        //  overwrite it, but actually it should be same or
                        //  uninitialized.)
                        //
                        palSurf.hdevOwner(po.hdev());

                        ICMMSG(("UpdateGammaRampOnDevice():Set GammaRamp to HDEV = %x\n",po.hdev()));

                        //
                        // Update palettes based on new GammaRamp.
                        //
                        // (Color will be adjusted in PALOBJ_cGetColors())
                        //
                        GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
                        GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);
                        {
                            SEMOBJ so(po.hsemPointer());

                            if (!po.bDisabled())
                            {
                                ASSERTGDI(PPFNVALID(po,SetPalette),"ERROR palette is not managed");

                                bRet = (*PPFNDRV(po, SetPalette))(po.dhpdev(),
                                                                  (PALOBJ *) &palSurf,
                                                                  0, 0, palSurf.cEntries());
                            }
                        }
                        GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
                        GreReleaseSemaphoreEx(po.hsemDevLock());
                    }
                }
                else
                {
                    ICMMSG(("UpdateGammaRampOnDevice():Driver doesn't have DrvSetDeviceGammaRamp()\n"));
                }
            }
        }
        else
        {
            //
            // Can not set GammaRamp for 1/4 bpp surface
            //
            ICMMSG(("UpdateGammaRampOnDevice():GammaRamp does not support on 1/4 bpp\n"));
        }

        if (!bRet)
        {
            ICMMSG(("UpdateGammaRampOnDevice(): device driver returns error\n"));
        }
    }
    else
    {
        ICMMSG(("UpdateGammaRampOnDevice(): HDEV is invalid\n"));
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* GetColorManagementCaps()
*
* History:
*
* Write it:
*    24-Feb-1998 -by- Hideyuki Nagase [hideyukn]
\**************************************************************************/

ULONG GetColorManagementCaps(PDEVOBJ& po)
{
    ULONG fl = CM_NONE;

    PDEVINFO pDevInfo = po.pdevinfoNotDynamic();

    //
    // Check CM_GAMMA_RAMP - it will be enabled when
    //
    //  0) Only for display device.
    //  1) DitherFormat is 8bpp. (GDI simulate regardless driver capabilities)
    //  2) Driver can do it.
    //
    if (po.bDisplayPDEV())
    {
        if ((pDevInfo->iDitherFormat == BMF_8BPP) ||
            (po.flGraphicsCaps2NotDynamic() & GCAPS2_CHANGEGAMMARAMP))
        {
            fl |= CM_GAMMA_RAMP;
        }
    }

    //
    // Check CM_CMYK_COLOR when driver can understand.
    //
    if (po.flGraphicsCapsNotDynamic() & GCAPS_CMYKCOLOR)
    {
        fl |= CM_CMYK_COLOR;
    }

    //
    // Check CM_DEVICE_ICM when driver can do.
    //
    if (po.flGraphicsCapsNotDynamic() & GCAPS_ICM)
    {
        fl |= CM_DEVICE_ICM;
    }

    return fl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\hmgrapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: hmgrapi.cxx
*
* Handle manager API entry points
*
* Created: 08-Dec-1989 23:03:03
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1989-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

//
// Synchronization of the handle manager
//

HSEMAPHORE ghsemHmgr;


PDEVCAPS gpGdiDevCaps = NULL;

//
// Points to shared memory including handle table and cfont cache
//

PGDI_SHARED_MEMORY gpGdiSharedMemory;

//
// Points to handle array
//

ENTRY      *gpentHmgr=NULL;

//
// Free List of handles
//

HOBJ       ghFreeHmgr;

//
// Max handle alloced so far
//

ULONG      gcMaxHmgr;

//
// Look aside list headers and maximum allowed entry-size array

PPAGED_LOOKASIDE_LIST pHmgLookAsideList[MAX_TYPE + 1];
ULONG laSize[MAX_TYPE + 1];
#define HMG_LAL_TAG '0alG'

//
//
//

extern "C"
{
    HFASTMUTEX ghfmMemory;
}


PVOID  gpHmgrSharedHandleSection;

//
// 10 millisecond wait value
//
// We only have a pointer to it since it must be allocated out of Non-paged
// pool
//

PLARGE_INTEGER gpLockShortDelay;

//
// Hydra session flag
//
// Note that this only has bearing on whether process is a hydra session
// or not.  It is possible to not be a hydra session, but still be a
// a hydra server (check gIsTerminalServer for that information).
//
// Value is TRUE if not a hydra session.
// Value is FALSE if a hydra session.
//

extern BOOL G_fConsole;

//
// Short term temporary buffer that can be used to put large
// objects for which we have no place in the stack.
//
// The value should only be used through the Alloc\FreeTmpBuffer functions
//

#define TMP_GLOBAL_BUFFER_SIZE 0x1000


PVOID *gpTmpGlobalFree;
PVOID  gpTmpGlobal = NULL;

// Number of DCATTR blocks in 1 page
#define ULNUMDC ((PAGE_SIZE)/sizeof(DC_ATTR))

// Number of OBJECTATTR blocks in 1 page
#define ULNUMBRUSH ((PAGE_SIZE)/sizeof(OBJECTATTR))

typedef struct _DCAFLISTENTRY
{
    LIST_ENTRY listEntry;
    ULONG      cFree;
    PDC_ATTR*  a[ULNUMDC];

} DCAFLISTENTRY, *PDCAFLISTENTRY;

typedef struct _OBAFLISTENTRY
{
    LIST_ENTRY listEntry;
    ULONG      cFree;
    POBJECTATTR*  a[ULNUMBRUSH];

} OBAFLISTENTRY, *POBAFLISTENTRY;

//
// Prototype for a handy debugging routine.
//

#if DBG

    extern "C"
    VOID
    HmgPrintBadHandle(
        HOBJ    hobj,
        OBJTYPE objt
        );

#else

    #define HmgPrintBadHandle(hobj, objt)

#endif

//
// During initialization, some things which are really really bad
// (like not being able to allocate the handle manager table) and
// we RIP because we cannot proceed and its completely unexpected.
//
// However, on a Hydra system, some of these are things we need
// to expect.  So what would be a RIP on a non-Hydra system can
// be treated as a WARNING on a Hydra system
//

#if DBG
    #define NONHYDRA_RIP(a) \
    {                       \
        if (G_fConsole)     \
            RIP(a);         \
        else                \
            WARNING(a);     \
    }
#else
    #define NONHYDRA_RIP(a)
#endif

/**************************************************************************\
 *
 * Fast tempporary memory allocator
 *
\**************************************************************************/


PVOID
AllocFreeTmpBuffer(
    ULONG size)
{
    PVOID tmpPtr = NULL;

    if (size <= TMP_GLOBAL_BUFFER_SIZE)
    {
        tmpPtr = (PVOID) InterlockedExchangePointer((PVOID *)gpTmpGlobalFree, 0);
    }

    if (!tmpPtr)
    {
        tmpPtr = AllocThreadBufferWithTag(size,'pmTG');
    }

    return tmpPtr;
}

VOID
FreeTmpBuffer(
    PVOID pv)
{
    if (pv == gpTmpGlobal)
    {
         ASSERTGDI(*gpTmpGlobalFree == NULL, "GRE: gpTmpGlobalFree is inconsistent\n");
         *gpTmpGlobalFree = pv;
    }
    else
    {
        FreeThreadBufferWithTag(pv);
    }
}


/**************************************************************************\
 *
 * Thread specific memory allocator. Memory is added to tracking list in
 * the thread and cleaned up if its still in the list when the thread dies.
 *
\**************************************************************************/
PVOID
AllocThreadBufferWithTag(
    ULONG size,
    ULONG tag)
{
    PVOID tmpPtr = NULL;

    if (size < MAXULONG - sizeof(LIST_ENTRY))
    {
        tmpPtr = PALLOCNOZ(size + sizeof(LIST_ENTRY),tag);

        if (tmpPtr)
        {
            PW32THREAD pThread = W32GetCurrentThread();

            ASSERTGDI(pThread, "GRE: AllocThreadBuffer W32Thread is NULL\n");

            if (pThread)
            {
                PLIST_ENTRY pEntry = (PLIST_ENTRY)tmpPtr;

                InsertHeadList(&pThread->GdiTmpAllocList, pEntry);

                tmpPtr = (PVOID)(pEntry + 1);
            }
        }
    }

    return tmpPtr;
}

VOID
FreeThreadBufferWithTag(
    PVOID pv)
{
    PW32THREAD pThread = W32GetCurrentThread();

    ASSERTGDI(pThread, "GRE: FreeThreadBuffer W32Thread is NULL\n");

    if (pThread)
    {
        PLIST_ENTRY pFree = (PLIST_ENTRY)pv;

        RemoveEntryList(pFree-1);

        VFREEMEM(pFree-1);
    }
}

/**************************************************************************\
 *
 * Performance, hit rate, memory size statistics
 *
\**************************************************************************/

#if DBG
#define GDI_PERF 1
#endif

#if GDI_PERF

extern "C"
{
// these must be extern "C" so the debugger extensions can see them

    ULONG HmgCurrentNumberOfObjects[MAX_TYPE + 1];
    ULONG HmgMaximumNumberOfObjects[MAX_TYPE + 1];
    ULONG HmgCurrentNumberOfLookAsideObjects[MAX_TYPE + 1];
    ULONG HmgMaximumNumberOfLookAsideObjects[MAX_TYPE + 1];
    ULONG HmgNumberOfObjectsAllocated[MAX_TYPE + 1];
    ULONG HmgNumberOfLookAsideHits[MAX_TYPE + 1];

    ULONG HmgCurrentNumberOfHandles[MAX_TYPE + 1];
    ULONG HmgMaximumNumberOfHandles[MAX_TYPE + 1];
    ULONG HmgNumberOfHandlesAllocated[MAX_TYPE + 1];
};

#endif

/*****************************Exported*Routine*****************************\
* HmgCreate()
*
* Initializes a new handle manager.
*
* History:
*
*  Mon 14-Apr-1997 -by- Dan Almosnino [danalm]
* Modified Lookaside initialization to use DaveC S-Lists
* and set the allowable object size on the list based on memory model
*
*  Wed 29-Apr-1992 -by- Patrick Haluptzok [patrickh]
* Change to mutex for exclusion, init event here.
*
*  Mon 21-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Reserve memory for the handle table so unlock doesn't need semaphore.
*
*  Mon 08-Jul-1991 -by- Patrick Haluptzok [patrickh]
* make 0 an invalid handle
*
*  Sun 20-Jun-1991 -by- Patrick Haluptzok [patrickh]
* The hheap has gone away, the correct error codes are logged.
*
*  30-Nov-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL HmgCreate()
{

    ULONG ulType;
    ULONG Size;
    BOOL  LargeSystemSize = FALSE;

#if 0

    KdPrint(("                MASK      CBITS  SHIFT\n"));
    KdPrint(("INDEX      = 0x%8.8lx, %3d   %3d \n",INDEX_MASK     ,INDEX_BITS     ,INDEX_SHIFT));
    KdPrint(("TYPE       = 0x%8.8lx, %3d   %3d \n",TYPE_MASK      ,TYPE_BITS      ,TYPE_SHIFT ));
    KdPrint(("ALTTYPE    = 0x%8.8lx, %3d   %3d \n",ALTTYPE_MASK   ,ALTTYPE_BITS   ,ALTTYPE_SHIFT ));
    KdPrint(("STOCK      = 0x%8.8lx, %3d   %3d \n",STOCK_MASK     ,STOCK_BITS     ,STOCK_SHIFT ));
    KdPrint(("UNIQUE     = 0x%8.8lx, %3d   %3d \n",UNIQUE_MASK    ,UNIQUE_BITS    ,UNIQUE_SHIFT ));
    KdPrint(("LOTYPE     = 0x%8.8lx, %3d   %3d \n",LOTYPE_MASK    ,LOTYPE_BITS    ,LOTYPE_SHIFT ));
    KdPrint(("FULLTYPE   = 0x%8.8lx, %3d   %3d \n",FULLTYPE_MASK  ,FULLTYPE_BITS  ,FULLTYPE_SHIFT ));
    KdPrint(("FULLUNIQUE = 0x%8.8lx, %3d   %3d \n",FULLUNIQUE_MASK,FULLUNIQUE_BITS,FULLUNIQUE_SHIFT ));
    KdPrint(("\n"));

#endif

    //
    // Initialize exclusion stuff.
    //

    if ((ghsemHmgr = GreCreateSemaphore()) == NULL)
        return FALSE;

    //
    // Initialize the handle manager allocation database.
    //

    ghFreeHmgr  = 0;                // No free handles
    gcMaxHmgr   = HMGR_HANDLE_BASE; // Initialize with handle index base

    //
    // Initialize the allocation of lookaside lists for selected objects.
    //
    // Initialize the maximum allowed entry-size for each object to zero

    if (MmMediumSystem <= MmQuerySystemSize())
            LargeSystemSize = TRUE;

    for (ulType = 0; ulType < MAX_TYPE + 1; ulType++)
    {
        laSize[ulType] = 0;
    }

    // Now Initialize the Lookaside lists

    Size = (LargeSystemSize == TRUE)? HMG_DC_MAX : HMG_DC_SIZE;
    if (HmgInitializeLookAsideList(DC_TYPE, Size, HMG_LAL_TAG, HMG_DC_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_RGN_MAX : HMG_RGN_SIZE);
    if (HmgInitializeLookAsideList(RGN_TYPE, Size, HMG_LAL_TAG, HMG_RGN_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_SURF_MAX : HMG_SURF_SIZE);
    if (HmgInitializeLookAsideList(SURF_TYPE, Size, HMG_LAL_TAG, HMG_SURF_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_PAL_MAX : HMG_PAL_SIZE);
    if (HmgInitializeLookAsideList(PAL_TYPE, Size, HMG_LAL_TAG, HMG_PAL_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_BRUSH_MAX : HMG_BRUSH_SIZE);
    if (HmgInitializeLookAsideList(BRUSH_TYPE, Size, HMG_LAL_TAG, HMG_BRUSH_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_LFONT_MAX : HMG_LFONT_SIZE);
    if (HmgInitializeLookAsideList(LFONT_TYPE, Size, HMG_LAL_TAG, HMG_LFONT_OBJECTS) == FALSE)
           return FALSE;

    Size = (ULONG)((LargeSystemSize == TRUE)? HMG_RFONT_MAX : HMG_RFONT_SIZE);
    if (HmgInitializeLookAsideList(RFONT_TYPE, Size, HMG_LAL_TAG, HMG_RFONT_OBJECTS) == FALSE)
           return FALSE;

    //
    //
    // Init mutex
    //
    // allocate and initialize memory fast mutex from non-paged pool
    //

    ghfmMemory = GreCreateFastMutex();

    if (ghfmMemory == NULL)
    {
        NONHYDRA_RIP("HmgCreate failed to create ghfmMemory");
        return(FALSE);
    }

    //
    // Create section for shared GDI handle table
    //

#if defined(_GDIPLUS_)
    {
        //
        // NOTE: _GDIPLUS_ is some work in progress code.
        //
        //
        // This should probably be a reserve-and-commit
        // We ceed to fix clean-up case, too
        //

        gpGdiSharedMemory = (GDI_SHARED_MEMORY*)
                            PALLOCMEM(sizeof(GDI_SHARED_MEMORY), ' thG');

        if (gpGdiSharedMemory == NULL)
        {
            RIP("Invalid handle table.");
        }
    }
#else
    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UnicodeString;
        LARGE_INTEGER MaximumSize;
        HANDLE hHmgrSharedHandleTable;

        ACCESS_MASK DesiredAccess =  SECTION_MAP_READ |
                                     SECTION_MAP_WRITE;

        ULONG SectionPageProtection = PAGE_READWRITE;

        ULONG AllocationAttributes = SEC_COMMIT |
                                     SEC_NO_CHANGE;


        MaximumSize.HighPart = 0;
        MaximumSize.LowPart  = sizeof(GDI_SHARED_MEMORY);

        ASSERTGDI((gpHmgrSharedHandleSection == NULL),
                  "gpHmgrSharedHandleSection MUST be NULL");

        Status = Win32CreateSection(&gpHmgrSharedHandleSection,
                                    DesiredAccess,
                                    NULL,
                                    &MaximumSize,
                                    SectionPageProtection,
                                    AllocationAttributes,
                                    NULL,
                                    NULL,
                                    TAG_SECTION_HMGR);

        if (!NT_SUCCESS(Status))
        {
            KdPrint(("Error in HmgCreate: Win32CreateSection returns %lx\n",Status));
            NONHYDRA_RIP("Can't continue without shared handle section");
            return(FALSE);
        }
        else
        {
            SIZE_T ViewSize = 0;

#ifdef _HYDRA_
            //
            // MmMapViewInSessionSpace is internally promoted to
            // MmMapViewInSystemSpace on non-Hydra systems.
            //
            // Win32MapViewInSessionSpace is included for tracking
            // Section objects. It's promoted to MmMapViewInSessionSpace
            // after the tracking code.
            //
            Status = Win32MapViewInSessionSpace(
                        gpHmgrSharedHandleSection,
                        (PVOID*)&gpGdiSharedMemory,
                        &ViewSize);
#else
            Status = MmMapViewInSystemSpace(
                        gpHmgrSharedHandleSection,
                        (PVOID*)&gpGdiSharedMemory,
                        &ViewSize);
#endif



            if (!NT_SUCCESS(Status))
            {
                KdPrint(("Error in HmgCreate: MmMapViewInSystemSpace returns %lx\n",Status));
                NONHYDRA_RIP("Can't continue without shared handle section");
                return(FALSE);
            }
        }
    }
#endif

    gpentHmgr = gpGdiSharedMemory->aentryHmgr;
    gpGdiDevCaps = &(gpGdiSharedMemory->DevCaps);

    //
    // Allocate the handle table and commit the initial allocation.
    //
    // N.B. Committed memory is demand zero.
    //
    //

    if (gpentHmgr == NULL) {
        NONHYDRA_RIP("Hmgr-bInit failed to reserve the handle table memory\n");
        return(FALSE);
    }

    //
    // allocate and initialize the timeout lock for the handle manager.
    //

    gpLockShortDelay = (PLARGE_INTEGER) GdiAllocPoolNonPaged(sizeof(LARGE_INTEGER),
                                                              'iniG');

    if (gpLockShortDelay == NULL) {
        NONHYDRA_RIP("Hmgr-could not allocate memory for delay lock\n");
        return(FALSE);
    }

    gpLockShortDelay->LowPart = (ULONG) -100000;
    gpLockShortDelay->HighPart = -1;

    //
    // Create a short term temporary buffer that can be used to put large
    // objects for which we have no place in the stack.
    //
    // We actually have to allocate the pointer to the buffer in non-paged
    // pool so that we can do an Interlocked exchange safely on it
    //

    gpTmpGlobal     = (PVOID)PALLOCNOZ(TMP_GLOBAL_BUFFER_SIZE, 'blgG');
    gpTmpGlobalFree = (PVOID *)GdiAllocPoolNonPaged(sizeof(PVOID),
                                                     'iniG');

    if ((gpTmpGlobal == NULL) ||
        (gpTmpGlobalFree == NULL))
    {
        NONHYDRA_RIP("Can't allocate process list entry");
        return(FALSE);
    }

    *gpTmpGlobalFree = gpTmpGlobal;

    return(TRUE);
}


/******************************Public*Routine******************************\
* InitializeLookAsideList
*
* Initializes a LookAside List for a selected object
* Uses DaveC's S-Lists
*
* History:
*  14-Apr-1997 -by- Dan Almosnino danalm
*  Wrote it
\**************************************************************************/

PVOID StubGdiAlloc(
    POOL_TYPE PoolType,
    SIZE_T uBytes,
    ULONG iTag)
{
    return GdiAllocPool((ULONG)uBytes, iTag);

    UNREFERENCED_PARAMETER(PoolType);
}

// Does anyone want to change this to #define ? if so please do so after win2000.
//
// #define StubGdiFree(p)   GdiFreePool((p))

VOID StubGdiFree(
    PVOID p)
{
    GdiFreePool(p);
}

BOOL
HmgInitializeLookAsideList(
    ULONG ulType,
    ULONG Size,
    ULONG dwTag,
    USHORT Number
    )
{

#if !defined(_GDIPLUS_)

    ULONG Flags = 0;

    // Modify tag using type.

    dwTag += ulType << 24;

    // Set the maximum allowed entry-size for this object

    laSize[ulType] = Size;

    // Allocate space for the List headers from Non-Paged pool (Otherwise bugcheck occurs
    // if Kernel tries to access them for modification of list-depth if they are paged out)

    pHmgLookAsideList[ulType] = (PPAGED_LOOKASIDE_LIST)GdiAllocPoolNonPagedNS(
                                                        sizeof(PAGED_LOOKASIDE_LIST),
                                                        dwTag);

    if (pHmgLookAsideList[ulType] == (PPAGED_LOOKASIDE_LIST)NULL)
    {
        WARNING1("HmgCreate failed to allocate memory for pHmgLookAsideList\n");
        return(FALSE);
    }

    // Now Initialize the Lookaside list

#ifdef _HYDRA_
    if (gIsTerminalServer) {
       Flags |= gSessionPoolMask;
    }
#endif

    ExInitializePagedLookasideList(pHmgLookAsideList[ulType],
                                   StubGdiAlloc,
                                   StubGdiFree,
                                   Flags,
                                   Size,
                                   dwTag,
                                   Number);

#endif

    return (TRUE);
}


/******************************Public*Routine******************************\
* IncProcessHandleCount - inc process handle count if under limit or
*   flag specifies no check.
*
* Arguments:
*
* Return Value:
*
*   TRUE if count is incremented.
*
* History:
*
*    30-Apr-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
HmgIncProcessHandleCount(
    W32PID  w32pid,
    OBJTYPE objt
    )
{
    BOOL bRet = TRUE;

#if !defined(_GDIPLUS_)

    //
    // maintain handle count but don't limit quota
    // for DCs
    // --> changed it to limit quota for DCs.  The fact that
    // USER create DCs for menu's and borders on behalf of the
    // app should not be that bad to prevent us from limiting DCs
    // end user can always use 'close' or task manager to kill a bad app.
    // If we don't limit DCs, the whole system will be affected.
    // [lingyunw]
    //

    if ((w32pid != OBJECT_OWNER_PUBLIC) && (w32pid != OBJECT_OWNER_NONE))
    {
        //
        // is the PID the current PID
        //

        if (w32pid == W32GetCurrentPID())
        {
            PW32PROCESS pw32Current = W32GetCurrentProcess();

            //
            // if the w32 process is not NULL then use
            // the current value, otherwise the process
            // has no W32PROCESS, so don't track handle quota
            //

            if (pw32Current)
            {
                //
                // increment handle count unless call specifies check quota and
                // process is already at or above limit.
                //

                if (pw32Current->GDIHandleCount >= gProcessHandleQuota)
                {
                    WARNING1("GDI Handle Limit reached\n");
                    bRet = FALSE;
                }
                else
                {
                    InterlockedIncrement(&pw32Current->GDIHandleCount);
                }
            }
        }
        else
        {
            PW32PROCESS pw32;
            PEPROCESS Process;
            NTSTATUS Status;

            Status = PsLookupProcessByProcessId(LongToHandle(w32pid), &Process);
            if (NT_SUCCESS(Status)) {
                if (pw32 = (PW32PROCESS)(PsGetProcessWin32Process(Process))) {
                    if (pw32->GDIHandleCount >= gProcessHandleQuota)
                    {
                        WARNING1("GDI Handle Limit reached\n");
                        bRet = FALSE;
                    }
                    else
                    {
                        InterlockedIncrement(&pw32->GDIHandleCount);
                    }
                }
                ObDereferenceObject(Process);
            }
            else
            {
                WARNING1("HmgIncProcessGDIHandleCount: Couldn't find PID owner\n");
            }
        }
    }

#endif

    return(bRet);
}


/******************************Public*Routine******************************\
* HmgDecProcessHandleCount - dec process handle count
*
* Arguments:
*
*   none
*
* Return Value:
*
*   nont
*
* History:
*
*    6-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
HmgDecProcessHandleCount(
    W32PID w32pid
)
{

#if !defined(_GDIPLUS_)

    if ((w32pid != OBJECT_OWNER_PUBLIC) && (w32pid != OBJECT_OWNER_NONE))
    {
        if (w32pid == W32GetCurrentPID())
        {
            PW32PROCESS pw32Current = W32GetCurrentProcess();

            if (pw32Current) {
                //
               // use current process
                //

                InterlockedDecrement(&pw32Current->GDIHandleCount);

                if (pw32Current->GDIHandleCount < 0)
                {
                    WARNING("GDI process handle count: decremented below zero");
                }
            }
        }
        else
        {
            PW32PROCESS pw32;
            PEPROCESS Process;
            NTSTATUS Status;

            Status = PsLookupProcessByProcessId(LongToHandle(w32pid), &Process);
            if (NT_SUCCESS(Status)) {
                if (pw32 = (PW32PROCESS)(PsGetProcessWin32Process(Process))) {

                    InterlockedDecrement(&pw32->GDIHandleCount);
                    if (pw32->GDIHandleCount < 0)
                    {
                        WARNING("GDI process handle count: decremented below zero");
                    }
                }
                ObDereferenceObject(Process);
            }
            else
            {
                WARNING1("HmgDeccProcessGDIHandleCount: Couldn't find PID owner\n");
            }
        }
    }

#endif

}

/******************************Public*Routine******************************\
* HmgValidHandle
*
* Returns TRUE if the handle is valid, FALSE if not.
*
* Note we don't need to lock the semaphore, we aren't changing anything,
* we are just peeking in.
*
* History:
*  08-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
HmgValidHandle(
    HOBJ hobj,
    OBJTYPE objt)
{
    PENTRY  pentTmp;
    UINT uiIndex = (UINT) (UINT) HmgIfromH(hobj);

    if ((uiIndex < gcMaxHmgr) &&
        ((pentTmp = &gpentHmgr[uiIndex])->Objt == objt) &&
        (pentTmp->FullUnique == HmgUfromH(hobj)))
    {
        ASSERTGDI(pentTmp->einfo.pobj != (POBJ) NULL, "ERROR how can it be NULL");
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* HmgInsertObject
*
* This inserts an object into the handle table, returning the handle
* associated with the pointer.
*
* History:
*  13-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HOBJ
HmgInsertObject(
    PVOID pv,
    FLONG flags,    // flags can be a combination of the following :
                    //  HMGR_MAKE_PUBLIC    - Allow object to be lockable by
                    //                        any process
                    //  HMGR_ALLOC_LOCK     - Do an HmgLock on the object and
                    //                        return a pointer instead of handle
                    //  HMGR_ALLOC_ALT_LOCK - Do an HmgShareLock on the object
                    //                        and return a pointer instead of
                    //                        handle
    OBJTYPE objt)
{
    ASSERTGDI(pv != (PVOID) NULL, "Invalid address");
    ASSERTGDI(objt != (OBJTYPE) DEF_TYPE, "objt is bad");

    HOBJ h = 0;

    BOOL bHandleQuota = TRUE;
    W32PID W32Pid = W32GetCurrentPID();
#if defined(_WIN64)
    PW32THREAD pW32Thread = W32GetCurrentThread();
    PRINTCLIENTID *pClientID = pW32Thread ? (PRINTCLIENTID*)pW32Thread->pClientID : 0;
    W32Pid = pClientID ? pClientID->clientPid : W32Pid;
#endif

    //
    // need the HMGR lock held while getting the handle
    //

    {
        MLOCKFAST mo;

        if (!(flags & HMGR_MAKE_PUBLIC))
        {
            //
            // Inc handle count for non-public objects. DC objects
            // can be allocated above process limit
            //

            bHandleQuota = HmgIncProcessHandleCount(W32Pid,objt);
        }

        if (bHandleQuota)
        {
            h = hGetFreeHandle((OBJTYPE) objt);

            if (h == 0)
            {
                WARNING1("HmgInsert failed hGetFreeHandle\n");

                //
                // decrement handle count in case of failure
                //

                if (!(flags & HMGR_MAKE_PUBLIC))
                {
                    HmgDecProcessHandleCount(W32Pid);
                }
            }
            else
            {
                // WINBUG #345863 3-17-2001 jasonha Hold ghsemHmgr thru out insert
                ((ENTRYOBJ *) &(gpentHmgr[HmgIfromH(h)]))->vSetup((POBJ) pv, objt, (FSHORT) flags);
                ((OBJECT *) pv)->hHmgr = (HANDLE) h;
            }
        }
        else
        {
            WARNING1("HmgInsertObject failed due to handle quota\n");
        }
    }

    return(h);
}

/******************************Public*Routine******************************\
* HmgRemoveObject
*
* Removes an object from the handle table if certain conditions are met.
*
* History:
*  13-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

PVOID
HmgRemoveObject(
    HOBJ hobj,
    LONG cExclusiveLock,
    LONG cShareLock,
    BOOL bIgnoreUndeletable,
    OBJTYPE objt)
{
    POBJ pobj;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
        //
        // Must acquire hmgr lock before handle lock
        //

        GreAcquireHmgrSemaphore();

        //
        // lock handle
        //

        PENTRY pentTmp = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentTmp,TRUE);

        if (HandleLock.bValid())
        {
            //
            // verify objt and unique
            //

            if ((pentTmp->Objt == objt) &&
                (pentTmp->FullUnique == HmgUfromH(hobj)))
            {
                pobj = pentTmp->einfo.pobj;

                if ((pobj->cExclusiveLock == (USHORT)cExclusiveLock) &&
                    (pobj->ulShareCount   == (ULONG)cShareLock))
                {
                    if (bIgnoreUndeletable || (!(pentTmp->Flags & HMGR_ENTRY_UNDELETABLE)))
                    {
                        //
                        // The undeletable flag is not set or else we are ignoring it.
                        //

                        #if GDI_PERF
                        HmgCurrentNumberOfHandles[objt]--;
                        #endif

                        //
                        // set the handle in the object to NULL
                        // to prevent/catch accidental decrement of the
                        // shared reference count
                        //

                        pobj->hHmgr = NULL;

                        //
                        // free the handle
                        //

                        ((ENTRYOBJ *) pentTmp)->vFree(uiIndex);

                    }
                    else
                    {
                        WARNING1("HmgRemove failed object is undeletable\n");
                        pobj = NULL;
                    }
                }
                else
                {
                    //
                    // object is busy
                    //

//                     WARNING1("HmgRemove failed - object busy elsewhere\n");
                     pobj = NULL;
                }
            }
            else
            {
                WARNING1("HmgRemove: bad objt or unique\n");
                pobj = NULL;
            }

            HandleLock.vUnlock();
        }
        else
        {
            WARNING1("HmgRemove: failed to lock handle\n");
            pobj = NULL;
        }

        //
        // free hmgr lock
        //

        GreReleaseHmgrSemaphore();
    }
    else
    {
        WARNING1("HmgRemove failed invalid index\n");
        pobj = NULL;
    }

    return((PVOID)pobj);
}

/******************************Public*Routine******************************\
* HmgReplace
*
* Change the object pointer.  Note this is callable only under very precise
* circumstances:
*
* 1> When the object is exclusively locked.
*
* History:
*  Tue 14-Dec-1993 -by- Patrick Haluptzok [patrickh]
* Seperate out lock counts from object structure.
*
*  18-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

POBJ HmgReplace(
    HOBJ    hobj,
    POBJ    pobjNew,
    FLONG   flags,
    LONG    cLock,
    OBJTYPE objt)
{
    //
    // We assume everything is valid, that the handle being replaced is exclusively
    // locked and valid.
    //
    // Note that currently "exclusively locked" can mean that we call this under
    // OBJLOCK control which doesn't set the cExclusiveLock
    //

    POBJ pobj = NULL;

    UINT uiIndex = (UINT) HmgIfromH(hobj);

    ASSERTGDI(uiIndex != 0, "HmgReplace invalid handle 0");
    ASSERTGDI(uiIndex < gcMaxHmgr, "HmgReplace invalid handle");

    PENTRY pentTmp = &gpentHmgr[uiIndex];

    ASSERTGDI(pentTmp->Objt == objt, "HmgReplace invalid object type");
    ASSERTGDI(pentTmp->FullUnique == HmgUfromH(hobj), "HmgReplace invalid uniqueness");
    ASSERTGDI((OBJECTOWNER_PID(pentTmp->ObjectOwner) == OBJECT_OWNER_PUBLIC) ||
              (OBJECTOWNER_PID(pentTmp->ObjectOwner) == W32GetCurrentPID()), "HmgReplace invalid PID owner");
    HANDLELOCK  HandleLock(pentTmp,TRUE);

    if (HandleLock.bValid())
    {
        //
        // Return the old value.  We have to be under the mutex here since the
        // counts live in the objects and if we do the switch while someone is
        // looking at the old object and the old object gets deleted after this
        // call before the original thread gets to run again he may fault or
        // wrongly succeed to lock it down.
        //

        pobj = pentTmp->einfo.pobj;
        pentTmp->einfo.pobj = pobjNew;

        HandleLock.vUnlock();
    }

    return((POBJ) pobj);
}

/******************************Public*Routine******************************\
* AllocateObject
*
* Allocates an object through a look a side buffer if possible else just
* allocates out of the heap.
*
* History:
*  14-Apr-1997 -by- Dan Almosnino danalm
* Modify to use DaveC's S-Lists mechanism for Lookaside Lists
*  12-Oct-1993 -by- Patrick Haluptzok patrickh
* Based on DaveC's HmgAlloc look-aside code
\**************************************************************************/

//
// This struct and the following union can be thrown away
// when someone fixes the BASEOBJECT cExclusiveLock and BaseFlags sharing
// the same DWORD.
//
struct SplitLockAndFlags {
  USHORT c_cExclusiveLock;
  USHORT c_BaseFlags;
};

union SplitOrCombinedLockAndFlags {
  SplitLockAndFlags S;
  ULONG W;
};


PVOID
AllocateObject(
    ULONG cBytes,
    ULONG ulType,
    BOOL bZero)
{

    PVOID pvReturn = NULL;

    ASSERTGDI(ulType != DEF_TYPE, "AllocateObject ulType is bad");
    ASSERTGDI(cBytes >= sizeof(BASEOBJECT), "AllocateObject cBytes is bad");

    //
    // Debug check to avoid assert in ExAllocatePool
    //

    #if DBG

        if (cBytes >= (PAGE_SIZE * 10000))
        {
            WARNING("AllocateObject: cBytes >= 10000 pages");
            return(NULL);
        }

    #endif


    //
    // If the object type has a lookaside list and the list contains a
    // free entry and the requested size is less than or equal to the
    // lookaside list size, then attempt to allocate memory from the
    // lookaside list.
    //

#if !defined(_GDIPLUS_)

    if (laSize[ulType] >= (ULONG)cBytes)
    {

        if((pvReturn = ExAllocateFromPagedLookasideList(pHmgLookAsideList[ulType])) != NULL)
        {

            if (bZero)
            {
                RtlZeroMemory(pvReturn, (UINT) cBytes);
            }
            else
            {
                //
                // At least the BASEOBJECT should be initialized.
                //

                RtlZeroMemory(pvReturn, (UINT) sizeof(BASEOBJECT));
            }

            //
            // This code is really hideous.
            // This is one of a very few places where it is necessary to know
            // that the BaseFlags entry in BASEOBJECT is actually the upper
            // 16 bits of the DWORD containing the cExclusiveLock.
            // If the layout of BASEOBJECT ever changes separating the cExclusiveLock
            // and the BaseFlags then this code _WILL_ break.
            //
            // The InterlockedExchange is required because it inserts appropriate
            // memory barriers on Alpha preventing other processors from seeing
            // the write delayed.
            //
            // Using the InterlockedExchange here is probably not necessary
            // Before anyone else can access this data it has to be put in the
            // Handle table and the code that does that should have the appropriate
            // mb instruction. However, just to be safe...
            //

            SplitOrCombinedLockAndFlags M;
            M.S.c_cExclusiveLock = ((BASEOBJECT *)pvReturn)->cExclusiveLock;
            M.S.c_BaseFlags = ((BASEOBJECT *)pvReturn)->BaseFlags | HMGR_LOOKASIDE_ALLOC_FLAG;
            InterlockedExchange( (LONG *)& (((BASEOBJECT *)pvReturn)->cExclusiveLock), M.W );

            //
            // This is the code without the InterlockedExchange.
            // If BaseFlags is removed from the DWORD containing the cExclusiveLock, the code
            // can be restored to this (provided all code that puts the object
            // in the handle table uses the HANDLELOCK):
            //
            //((BASEOBJECT *)pvReturn)->BaseFlags |= HMGR_LOOKASIDE_ALLOC_FLAG; //Set Base Object Lookaside Flag
            //

#if GDI_PERF
            HmgNumberOfLookAsideHits[ulType] += 1;
            HmgCurrentNumberOfLookAsideObjects[ulType] += 1;

            if (HmgCurrentNumberOfLookAsideObjects[ulType] > HmgMaximumNumberOfLookAsideObjects[ulType])
            {
                HmgMaximumNumberOfLookAsideObjects[ulType] = HmgCurrentNumberOfLookAsideObjects[ulType];
            }
#endif

        }

    }

#endif

    if (pvReturn == NULL)
    {
        //
        // The attempted allocation from Look-Aside failed
        // (or the object is too big for the lookaside).
        // Attempt to allocate the object from the heap.
        //

        ULONG ulTag = '00hG';
        ulTag += ulType << 24;

        // Inject the Session Id into the tag
        //  Sessions with Id's from 0 to 78 will use an ascii character
        //  from '0' to '~', respectively.  Sessions with higher Id's will
        //  all have a ' '.
        ULONG ulSessionId = PsGetCurrentProcessSessionId();
        if (ulSessionId > '~' - '0')
        {
            ulSessionId = ' ' - '0';
        }
        ulTag += ulSessionId << 16;

        //
        // Note: not necessary to clear the HMGR_LOOKASIDE_ALLOC_FLAG
        // in BaseFlags since the BASEOBJECT is always zero-initialized.
        //

        if (bZero)
        {
            pvReturn = PALLOCMEM(cBytes, ulTag);
        }
        else
        {
            pvReturn = PALLOCNOZ(cBytes, ulTag);

            //
            // At least the BASEOBJECT should be initialized.
            //

            if (pvReturn)
            {
                RtlZeroMemory(pvReturn, (UINT) sizeof(BASEOBJECT));
            }
        }

        //
        // If the allocation failed again, then set the extended
        // error status and return an invalid handle.
        //

        if (!pvReturn)
        {
            KdPrint(("GDISRV:AllocateObject failed alloc of %lu bytes\n", (cBytes)));
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

    }

#if GDI_PERF

    //
    // Increment the object performance counters.
    //

    HmgCurrentNumberOfObjects[ulType] += 1;
    HmgNumberOfObjectsAllocated[ulType] += 1;

    if (HmgCurrentNumberOfObjects[ulType] > HmgMaximumNumberOfObjects[ulType])
    {
        HmgMaximumNumberOfObjects[ulType] = HmgCurrentNumberOfObjects[ulType];
    }

#endif

    return(pvReturn);
}

/******************************Public*Routine******************************\
* HmgAlloc
*
* Allocate an object from Handle Manager.
*
* WARNING:
* --------
*
* If the object is share-lockable via an API, you MUST use HmgInsertObject
* instead.  If the object is only exclusive-lockable via an API, you MUST
* either use HmgInsertObject or specify HMGR_ALLOC_LOCK.
*
* (This is because if you use HmgAlloc, a malicious multi-threaded
* application could guess the handle and cause it to be dereferenced
* before you've finished initializing it, possibly causing an access
* violation.)
*
* History:
*  23-Sep-1991 -by- Patrick Haluptzok patrickh
* Rewrite to be flat, no memory management under semaphore.
*
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ
HmgAlloc(
    ULONGSIZE_T cb,
    OBJTYPE objt,
    FSHORT  fs) // fs can be a combination of the following:
                //  HMGR_NO_ZERO_INIT   - Don't zero initialize
                //  HMGR_MAKE_PUBLIC    - Allow object to be lockable by
                //                        any process
                //  HMGR_ALLOC_LOCK     - Do an HmgLock on the object and
                //                        return a pointer instead of handle
                //  HMGR_ALLOC_ALT_LOCK - Do an HmgShareLock on the object
                //                        and return a pointer instead of
                //                        handle
{
    HOBJ Handle;
    PVOID pv;

    ASSERTGDI(objt != (OBJTYPE) DEF_TYPE, "HmgAlloc objt is bad");
    ASSERTGDI(cb >= 8, "ERROR hmgr writes in first 8 bytes");

    //
    // Allocate a pointer.
    //

    pv = AllocateObject(cb, (ULONG) objt, ((fs & HMGR_NO_ZERO_INIT) == 0));

    if (pv != (PVOID) NULL)
    {
        BOOL bHandleQuota = TRUE;
        W32PID W32Pid = W32GetCurrentPID();
#if defined(_WIN64)
        PW32THREAD pW32Thread = W32GetCurrentThread();
        PRINTCLIENTID *pClientID = pW32Thread ? (PRINTCLIENTID*)pW32Thread->pClientID : 0;
        W32Pid = pClientID ? pClientID->clientPid : W32Pid;
#endif

        //
        // Allocate a handle.  We need the mutex to access the free list
        //

        GreAcquireHmgrSemaphore();

        if (!(fs & HMGR_MAKE_PUBLIC))
        {
            //
            // increment handle quota on non public objects. DC objects
            // can be allocated over a process quota limit.
            //

            bHandleQuota = HmgIncProcessHandleCount(W32Pid, objt);
        }

        if (bHandleQuota)
        {
            Handle = hGetFreeHandle(objt);

            if (Handle != (HOBJ) 0)
            {
                //
                // Store a pointer to the object in the entry corresponding to the
                // allocated handle and initialize the handle data.
                //

                ((ENTRYOBJ *) &(gpentHmgr[HmgIfromH(Handle)]))->vSetup((POBJ) pv, objt, fs);

                //
                // Store the object handle at the beginning of the object memory.
                //

                ((OBJECT *)pv)->hHmgr = (HANDLE)Handle;

                GreReleaseHmgrSemaphore();

                return ((fs & (HMGR_ALLOC_ALT_LOCK | HMGR_ALLOC_LOCK))
                            ? (HOBJ)pv
                            : Handle);
            }
            else
            {
                //
                // decrement process handle count if not public
                // (while lock is still held)
                //

                if (!(fs & HMGR_MAKE_PUBLIC))
                {
                    HmgDecProcessHandleCount(W32Pid);
                }

                //
                // We just failed a handle allocation.  Release the memory.
                //

                GreReleaseHmgrSemaphore();
                FreeObject(pv,(ULONG) objt);

            }
        }
        else
        {
            WARNING("Failed HmgAlloc due to handle quota\n");
            GreReleaseHmgrSemaphore();
            FreeObject(pv,(ULONG) objt);
        }
    }

    return((HOBJ) 0);
}

/******************************Public*Routine******************************\
* FreeObject
*
* Frees the object from where it was allocated.
*
* History:
*
*  14-Apr-1997 -by- Dan Almosnino danalm
* Modified to use DaveC's S-List mechanism for Lookaside lists
*
*  12-Oct-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID FreeObject(PVOID pvFree, ULONG ulType)
{

#if GDI_PERF

    HmgCurrentNumberOfObjects[ulType] -= 1;

#endif

// Find if the object originates from a lookaside allocation,
// if so, return it to the free list.

    if( ((BASEOBJECT *)pvFree)->BaseFlags & HMGR_LOOKASIDE_ALLOC_FLAG )
    {

#if !defined(_GDIPLUS_)

        ExFreeToPagedLookasideList(pHmgLookAsideList[ulType],pvFree);

#endif

#if GDI_PERF

        HmgCurrentNumberOfLookAsideObjects[ulType] -= 1;

#endif

    }
    else
    {
        // If the object memory was allocated from the general heap, then
        // release the memory to the heap.

        VFREEMEM(pvFree);
    }

}

/******************************Public*Routine******************************\
* HmgFree
*
* Free an object from the handle manager.
*
* History:
*  23-Sep-1991 -by- Patrick Haluptzok patrickh
* Rewrite to be flat, no memory management under semaphore.
*
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID HmgFree(HOBJ hobj)
{
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    POBJ pobjTmp;
    OBJTYPE objtTmp;

    ASSERTGDI(uiIndex != 0, "ERROR HmgFree invalid 0 handle");

    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentTmp = &gpentHmgr[uiIndex];

        //
        // Acquire the handle manager lock and decrement the count of objects of
        // the specfied type.
        //

        GreAcquireHmgrSemaphore();

        //
        // lock handle
        //

        HANDLELOCK HandleLock(pentTmp,FALSE);

        if (HandleLock.bValid())
        {
            #if GDI_PERF
                HmgCurrentNumberOfHandles[pentTmp->Objt]--;
            #endif

            pobjTmp = pentTmp->einfo.pobj;
            objtTmp = pentTmp->Objt;

            //
            // Free the object handle
            //

            ((ENTRYOBJ *) pentTmp)->vFree(uiIndex);

            HandleLock.vUnlock();
        }

        GreReleaseHmgrSemaphore();

        if (pobjTmp)
        {
            FreeObject((PVOID)pobjTmp, (ULONG) objtTmp);
        }
    }
    else
    {
        WARNING1("HmgFree: bad handle index");
    }
}


/******************************Public*Routine******************************\
* HmgSetOwner - set new object owner
*
* Arguments:
*   hobj        - handle of object
*   objt        - type of object
*   usCurrent   - OBJECT_OWNER flag for current owner
*   pw32Current - PW32PROCESS of current owner if not current w32process
*   usNew       - OBJECT_OWNER flag for new owner
*   pw32New     - PW32PROCESS of new owner if not current w32process
*
* Return Value:
*
*   Status
*
* History:
*
*    15-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
HmgSetOwner(
    HOBJ        hobj,
    W32PID      W32PidNew,
    OBJTYPE     objt
    )
{
    PENTRY pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    BOOL bStatus = FALSE;
    W32PID W32PidCurrent;
#if defined(_WIN64)
    KERNEL_PVOID  pclientID;
    PW32THREAD pW32thread;
    BOOL bWOW64 = FALSE;
#endif
    if (W32PidNew == OBJECT_OWNER_CURRENT)
    {
        W32PidNew = W32GetCurrentPID();
    }

    if (uiIndex < gcMaxHmgr)
    {
        pentTmp = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentTmp,FALSE);

        if (HandleLock.bValid())
        {
            //
            // verify objt and unique
            //

            if ((pentTmp->Objt == objt) && (pentTmp->FullUnique == HmgUfromH(hobj)))
            {

                POBJ pobj = pentTmp->einfo.pobj;
#if defined(_WIN64)
                pW32thread = W32GetCurrentThread();

                //
                // Set the handle owner pid to the wow64 print client pid if
                // the the PRINTCLIENTID pointer in W32TREAD is non zero.
                // In this case, we are doing WOW64 printing via LPC.
                //

                pclientID = pW32thread ? pW32thread->pClientID : 0;
                if(pclientID)
                    bWOW64 = TRUE;
#endif
                if ((pobj->cExclusiveLock == 0) ||
                    (pobj->Tid == (PW32THREAD)PsGetCurrentThread())
#if defined(_WIN64)
                    ||
                    (bWOW64)
#endif
                   )
                {

                    bStatus = TRUE;

                    //
                    // determine current W32PID
                    //

                    W32PidCurrent =  HandleLock.Pid();
#if defined(_WIN64)
                    if (bWOW64)
                    {
                        W32PidNew = ((PRINTCLIENTID*)pclientID)->clientPid;
                    }
#endif
                    if (W32PidCurrent != W32PidNew)
                    {
                        bStatus = HmgIncProcessHandleCount(W32PidNew,objt);

                        if (bStatus)
                        {
                            HmgDecProcessHandleCount(W32PidCurrent);

                            //
                            // set new owner
                            //

                            HandleLock.Pid(W32PidNew);
                        }
                        else
                        {
                            WARNING1("HmgSetOwner: Failed to set owner due to handle quota\n");
                        }
                    }
                }
                else
                {
                    WARNING1("HmgSetOwner, Object is exclusively locked\n");
                }
            }
            else
            {
                WARNING1("HmgSetOwner, object type or unique mismach\n");
            }

            HandleLock.vUnlock();
        }
    }
    else
    {
        WARNING1("HmgSetOwner: bad index\n");
    }

    return(bStatus);
}

/*****************************Exported*Routine*****************************\
* GreGetObjectOwner
*
*   Get the owner of an object
*
* Arguments:
*
*   hobj    - handle to object
*   objt    - handle type for verification
*
* History:
*
* 27-Apr-1994 -by- Johnc
* Dupped from SetOwner.
\**************************************************************************/

W32PID
GreGetObjectOwner(
    HOBJ hobj,
    DWORD objt)
{
    W32PID pid = OBJECT_OWNER_ERROR;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentTmp = &gpentHmgr[uiIndex];

        if ((pentTmp->Objt == objt) && (pentTmp->FullUnique == HmgUfromH(hobj)))
        {
            pid = OBJECTOWNER_PID(pentTmp->ObjectOwner);
        }
        else
        {
            WARNING1("GreGetObjectOwner failed - object type of unique mismatch\n");
        }

    }
    else
    {
        WARNING1("GreGetObjectOwner failed - invalid handle index\n");
    }

    return(pid);
}

/******************************Public*Routine******************************\
*
* HmgSwapHandleContents locks both handles and verifies lock counts.
* The handle contents for each element are then swapped.
*
* Arguments:
*
*   hobj1   - handle to object 1
*   cShare1 - share count object 1 must have after handle is locked
*   hobj2   - handle to object 2
*   cShare1 - share count object 2 must have after handle is locked
*   objt    - type that both handles must be
*
* Return Value:
*
*   BOOL status
*
* History:
*
*    24-Jul-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
HmgSwapHandleContents(
    HOBJ    hobj1,
    ULONG   cShare1,
    HOBJ    hobj2,
    ULONG   cShare2,
    OBJTYPE objt)
{
    //
    // acquire hmgr resource for this operation to
    // make sure we don't deadlock with two threads
    // trying to swap the same handles in reverse
    // order
    //

    MLOCKFAST mo;

    return(
             HmgSwapLockedHandleContents(
                        hobj1,
                        cShare1,
                        hobj2,
                        cShare2,
                        objt)
          );

}

/******************************Public*Routine******************************\
*
* HmgSwapLockedHandleContents locks both handles and verifies lock counts.
* The handle contents for each element are then swapped. HmgrResource must
* be owned to prevent deadlock.
*
* Arguments:
*
*   hobj1   - handle to object 1
*   cShare1 - share count object 1 must have after handle is locked
*   hobj2   - handle to object 2
*   cShare1 - share count object 2 must have after handle is locked
*   objt    - type that both handles must be
*
* Return Value:
*
*   BOOL status
*
* History:
*
*    24-Jul-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
HmgSwapLockedHandleContents(
    HOBJ    hobj1,
    ULONG   cShare1,
    HOBJ    hobj2,
    ULONG   cShare2,
    OBJTYPE objt)
{

    UINT uiIndex1 = (UINT) HmgIfromH(hobj1);
    UINT uiIndex2 = (UINT) HmgIfromH(hobj2);
    BOOL bResult = FALSE;

    ASSERTGDI(objt != (OBJTYPE) DEF_TYPE, "Bad type");

    //
    // Acquire handle lock on both objects
    //

    PENTRY pentry1 = &gpentHmgr[uiIndex1];

    PENTRY pentry2 = &gpentHmgr[uiIndex2];

    HANDLELOCK HandleLock1(pentry1,FALSE);

    if (HandleLock1.bValid())
    {
        HANDLELOCK HandleLock2(pentry2,FALSE);
        if (HandleLock2.bValid())
        {
            //
            // Verify share lock counts and object types
            //

            if ((HandleLock1.ShareCount() == (USHORT)cShare1) && (pentry1->Objt == objt))
            {
                if ((HandleLock2.ShareCount() == (USHORT)cShare2) && (pentry2->Objt == objt))
                {
                    POBJ pobjTemp;
                    PVOID   pvTmp;

                    //
                    // swap pobj in handle table
                    //

                    pobjTemp            = pentry1->einfo.pobj;
                    pentry1->einfo.pobj = pentry2->einfo.pobj;
                    pentry2->einfo.pobj = pobjTemp;

                    //
                    // swap puser in handle table
                    //

                    pvTmp          = pentry1->pUser;
                    pentry1->pUser = pentry2->pUser;
                    pentry2->pUser = pvTmp;

                    //
                    // swap BASEOBJECTS
                    //

                    BASEOBJECT obj;

                    obj = *pentry1->einfo.pobj;
                    *pentry1->einfo.pobj = *pentry2->einfo.pobj;
                    *pentry2->einfo.pobj = obj;

                    //
                    // unswap the BASEOBJECT.BaseFlags
                    //
                    // The BaseFlags field contains information about how
                    // the object was allocated (and therefore, how it must
                    // be deallocated).  Thus, it represents state associated
                    // with the actual memory, not the object, and should not
                    // be swapped.
                    //
                    // See comments regarding BASEOBJECT in inc\hmgshare.h
                    // for more details.  Also, there is swapping code in
                    // RGNOBJ::bSwap (rgnobj.cxx).
                    //

                    USHORT usTemp;

                    usTemp = pentry1->einfo.pobj->BaseFlags;
                    pentry1->einfo.pobj->BaseFlags = pentry2->einfo.pobj->BaseFlags;
                    pentry2->einfo.pobj->BaseFlags = usTemp;

                    bResult = TRUE;
                }
                else
                {
                    WARNING1("HmgSwapHandleContents: wrong share count or objt for hobj2");
                }
            }
            else
            {
                WARNING1("HmgSwapHandleContents: wrong share count or objt for hobj1");
            }

            HandleLock2.vUnlock();
        }

        HandleLock1.vUnlock();
    }

    return(bResult);
}

/*****************************Exported*Routine*****************************\
* HOBJ HmgNextOwned(hmgr, hobj, pid)
*
* Report the next object owned by specified process
*
* History:
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ
FASTCALL
HmgNextOwned(
    HOBJ hobj,
    W32PID pid)
{
    MLOCKFAST mo;

    return(HmgSafeNextOwned(hobj, pid));
}

/*****************************Exported*Routine*****************************\
* HOBJ HmgSafeNextOwned
*
* Report the next object owned by specified process
*
* History:
*  Sat 11-Dec-1993 -by- Patrick Haluptzok [patrickh]
* Remove function wrapper.
*
*  08-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ
FASTCALL
HmgSafeNextOwned(
    HOBJ hobj,
    W32PID pid)
{

    PENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxHmgr)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (pentTmp->bOwnedBy(pid))
        {
            return((HOBJ) MAKE_HMGR_HANDLE(uiIndex, pentTmp->FullUnique));
        }

        //
        // Advance to next object
        //

        uiIndex++;

    }

    //
    // No objects found
    //

    return((HOBJ) 0);
}

/*****************************Exported*Routine*****************************\
* HOBJ HmgSafeNextObjt
*
* Report the next object of a certain type.
*
* History:
*  Tue 19-Apr-1994 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

POBJ
FASTCALL
HmgSafeNextObjt(
    HOBJ hobj,
    OBJTYPE objt)
{

    PENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxHmgr)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (pentTmp->Objt == objt)
        {
            return(pentTmp->einfo.pobj);
        }

        //
        // Advance to next object
        //

        uiIndex++;
    }

    //
    // no objects found
    //

    return((POBJ) 0);
}

/*******************************Routine************************************\
* HmgLockAllOwners
*
* Description:
*
*   Acquire an exclusive lock on an object.  Note that this routine is
*   different than HmgLock in that the PID owner doesn't need to match the
*   current PID.  This is useful in GreRestoreDC where we need to get a lock
*   on the saved DC in order to to copy its information to the primary DC, but
*   don't want to fail if the process has already reached its handle quota
*   because this saved DC is about to be deleted anyway.  See bug #223129
*   for details.
*
*   WARNING:  Do not call this routine outside of the above scenario unless
*       there's a very good reason!
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgLockAllOwners(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ pobj = (POBJ)NULL;
    UINT uiIndex = (UINT)HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        //
        // Passing FALSE as the second argument to the HANDLELOCK constructor
        // allows us to obtain a lock regardless of the PID owner of the object.
        //
        HANDLELOCK HandleLock(pentry,FALSE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt != objt) || (pentry->FullUnique != HmgUfromH(hobj)))
            {
                HmgPrintBadHandle(hobj, objt);
            }
            else
            {
                pobj = pentry->einfo.pobj;

                if ((pobj->cExclusiveLock == 0) || (pobj->Tid == (PW32THREAD)PsGetCurrentThread()))
                {
                    pobj->cExclusiveLock++;
                    pobj->Tid = (PW32THREAD)PsGetCurrentThread();
                }
                else
                {
                    WARNING1("HmgLock: object already locked by another thread");
                    pobj = (POBJ)NULL;
                }
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}



#if !defined(_X86_) || defined(_GDIPLUS_)
/*******************************Routine************************************\
* HmgLock
*
* Description:
*
*   Acquire an exclusive lock on an object, PID owner must match current PID
*   or be a public.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgLock(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ pobj = (POBJ)NULL;
    UINT uiIndex = (UINT)HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,TRUE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt != objt) || (pentry->FullUnique != HmgUfromH(hobj)))
            {
                HmgPrintBadHandle(hobj, objt);
            }
            else
            {
                pobj = pentry->einfo.pobj;

                if ((pobj->cExclusiveLock == 0) || (pobj->Tid == (PW32THREAD)PsGetCurrentThread()))
                {
                    pobj->cExclusiveLock++;
                    pobj->Tid = (PW32THREAD)PsGetCurrentThread();
                }
                else
                {
                    WARNING1("HmgLock: object already locked by another thread");
                    pobj = (POBJ)NULL;
                }
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/*******************************Routine************************************\
* HmgShareCheckLock
*
* Description:
*
*   Acquire a share lock on an object, PID owner must match current PID
*   or be a public.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgShareCheckLock(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];
        HANDLELOCK HandleLock(pentry,TRUE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/*******************************Routine************************************\
* HmgShareLock
*
* Description:
*
*   Acquire a share lock on an object, don't check PID owner
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ FASTCALL
HmgShareLock(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);
        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

#endif

/*******************************Routine************************************\
* HmgShareCheckLockIgnoreStockBit
*
* Description:
*
*   Acquire a share lock on an object, PID owner must match current PID
*   or be a public. We ignore the stock bit.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgShareCheckLockIgnoreStockBit(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];
        HANDLELOCK HandleLock(pentry,TRUE);

        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) &&
                ((pentry->FullUnique & ~FULLUNIQUE_STOCK_MASK) ==
                 (HmgUfromH(hobj) & ~FULLUNIQUE_STOCK_MASK)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/*******************************Routine************************************\
* HmgShareLockIgnoreStockBit
*
* Description:
*
*   Acquire a share lock on an object, don't check PID owner. Ignore stock
*   bit.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ FASTCALL
HmgShareLockIgnoreStockBit(
    HOBJ hobj,
    OBJTYPE objt
    )
{
    POBJ   pobj = (POBJ)NULL;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    if (uiIndex < gcMaxHmgr)
    {
        PENTRY pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);
        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) &&
                ((pentry->FullUnique & ~FULLUNIQUE_STOCK_MASK) ==
                 (HmgUfromH(hobj) & ~FULLUNIQUE_STOCK_MASK)))
            {
                pobj = pentry->einfo.pobj;
                pobj->ulShareCount++;
            }
            else
            {
                HmgPrintBadHandle(hobj, objt);
            }
            HandleLock.vUnlock();
        }
        else
        {
            HmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        HmgPrintBadHandle(hobj, objt);
    }
    return(pobj);
}

/******************************Public*Routine******************************\
* HmgShareUnlock
*
*   Make this a macro once it is debugged
*
* Arguments:
*
*   pobj - pointer to share-locked object
*
* Return Value:
*
*   None
*
\**************************************************************************/

VOID
HmgShareUnlock(
    POBJ pobj
    )
{
    PENTRY pentry;

    //
    // decrement shared reference count to object, Handle checks
    // are not done.
    //

    UINT uiIndex = (UINT) HmgIfromH(pobj->hHmgr);

    pentry = &gpentHmgr[uiIndex];

    HANDLELOCK HandleLock(pentry,FALSE);

    if (HandleLock.bValid())
    {
        //
        // decrement use count
        //

        pobj->ulShareCount--;

        HandleLock.vUnlock();
    }
}

/*******************************Routine************************************\
* HmgReferenceCheckLock
*
* Description:
*
*   The routine validates the hanlde passed in and returns a pointer to
*   the object. This routine must only be called when the HmgrReource is
*   held and the pointer to the object is only valid while the Resource
*   is held. No unlock is neccessary since the object is not reference-
*   counted.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
\**************************************************************************/

POBJ
FASTCALL
HmgReferenceCheckLock(
    HOBJ hobj,
    OBJTYPE objt,
    BOOL bDebugPrint
    )
{
    PENTRY pentry;
    POBJ   pobj = (POBJ)NULL;

    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
        {
            pobj = pentry->einfo.pobj;
        }
        else
        {
            if (bDebugPrint)
            {
                HmgPrintBadHandle(hobj, objt);
            }
        }
    }
    else
    {
        if (bDebugPrint)
        {
           HmgPrintBadHandle(hobj, objt);
        }
    }
    return(pobj);
}

#if !defined(_X86_) || defined(_GDIPLUS_)

/******************************Public*Routine******************************\
* HmgIncrementShareReferenceCount
*
*   interlocked increment shared reference count
*
* Arguments:
*
*   pObj    - pointer to valid object
*
* Return Value:
*
*   none
*
* History:
*
*    6-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
FASTCALL
HmgIncrementShareReferenceCount(
    POBJ pObj
    )
{
    HANDLELOCK HandleLock(PENTRY_FROM_POBJ(pObj), FALSE);

    if (HandleLock.bValid())
    {
        pObj->ulShareCount++;
        HandleLock.vUnlock();
    }
    else
    {
        HmgPrintBadHandle((HOBJ)pObj->hHmgr, PENTRY_FROM_POBJ(pObj)->Objt);
    }
}

/******************************Public*Routine******************************\
* HmgDecrementShareReferenceCount
*
*   interlocked increment shared reference count
*
* Arguments:
*
*   pObj    - pointer to valid object
*
* Return Value:
*
*   previous lock count
*
* History:
*
*    6-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
FASTCALL
HmgDecrementShareReferenceCount(
    POBJ pObj
    )
{
    ULONG ulOrigShareCount=0;
    HANDLELOCK HandleLock(PENTRY_FROM_POBJ(pObj), FALSE);

    if (HandleLock.bValid())
    {
        ulOrigShareCount = pObj->ulShareCount;
        pObj->ulShareCount--;
        HandleLock.vUnlock();
    }
    else
    {
        HmgPrintBadHandle((HOBJ)pObj->hHmgr, PENTRY_FROM_POBJ(pObj)->Objt);
    }

    return ulOrigShareCount;
}

#endif

/******************************Public*Routine******************************\
* HmgMarkDeletable
*
* Mark an object as deletable.
*
* History:
*  11-Jun-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
FASTCALL
HmgMarkDeletable(
    HOBJ hobj,
    OBJTYPE objt)
{
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    BOOL bStatus = FALSE;

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);
        if (HandleLock.bValid())
        {

            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pentry->Flags &= ~HMGR_ENTRY_UNDELETABLE;
                bStatus = TRUE;
            }
            else
            {
                WARNING1("HmgMarkDeletable: bad objt or unique");
            }
            HandleLock.vUnlock();
        }
        else
        {
            WARNING1("HmgMarkDeletable failed: not object owner\n");
        }
    }
    else
    {
      WARNING1("HmgMarkDeletable failed: index out of range\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* HmgMarkUndeletable
*
* Mark an object as undeletable.
*
* History:
*  11-Jun-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL
FASTCALL
HmgMarkUndeletable(HOBJ hobj, OBJTYPE objt)
{
    PENTRY pentry;
    UINT uiIndex = (UINT) HmgIfromH(hobj);
    BOOL bStatus = FALSE;

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,TRUE);
        if (HandleLock.bValid())
        {
            if ((pentry->Objt == objt) && (pentry->FullUnique == HmgUfromH(hobj)))
            {
                pentry->Flags |= HMGR_ENTRY_UNDELETABLE;
                bStatus = TRUE;
            }
            else
            {
                WARNING1("HmgMarkUndeletable: bad objt or unique");
            }
            HandleLock.vUnlock();
        }
        else
        {
            WARNING1("HmgMarkUndeletable failed: not object owner\n");
        }
    }
    else
    {
        WARNING1("HmgMarkUndeletable failed: index out of range\n");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* BOOL HmgSetLock
*
* Set the lock count of the object.
* This is currently used by process cleanup code to reset object lock count.
*
* History:
*  Wed May 25 15:24:33 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/




BOOL FASTCALL HmgSetLock(HOBJ hobj, ULONG cLock)
{
    PENTRY pentTmp;
    UINT uiIndex = (UINT) HmgIfromH(hobj);

    if (uiIndex < gcMaxHmgr)
    {
      pentTmp = &gpentHmgr[uiIndex];
      if (pentTmp->FullUnique == HmgUfromH(hobj))
      {
        POBJ pobj = pentTmp->einfo.pobj;

        //
        // This code is really hideous.
        // This is one of a very few places where it is necessary to know
        // that the BaseFlags entry in BASEOBJECT is actually the upper
        // 16 bits of the DWORD containing the cExclusiveLock.
        // If the layout of BASEOBJECT ever changes separating the cExclusiveLock
        // and the BaseFlags then this code _WILL_ break.
        //
        // Also this code only works because nobody actually sets BaseFlags after
        // object allocation. If this fact ever changes then this code needs to
        // be changed to an InterlockedCompareExchange loop and should probably be
        // protected by the HandleLock. Also the BaseFlags modification code
        // would then also require an InterlockedCompareExchange too.
        //
        // The only reason we actually entertain this mess is because this code
        // is only ever used in cleanup. It's bad enough that the code stomps the
        // lock without checking it anyway.
        //
        // The InterlockedExchange is required because it inserts appropriate
        // memory barriers on Alpha preventing other processors from seeing
        // the write delayed.
        //

        SplitOrCombinedLockAndFlags M;

        //
        // get a pointer to the cExclusiveLock, make it a ULONG * and then
        // dereference it getting 32bits from the beginning of the 16bit
        // cExclusiveLock. This will include the BaseFlags which we know won't
        // change (see above and BASEOBJECT).
        //

        M.W = *(ULONG *)&(pobj->cExclusiveLock);
        M.S.c_cExclusiveLock = (USHORT)cLock;
        InterlockedExchange((LONG *)&(pobj->cExclusiveLock), M.W);

      }
      else
      {
        pentTmp = (PENTRY) NULL;
        WARNING1("HmgSetLock failed - Uniqueness does not match\n");
      }
    }
    else
    {
      pentTmp = (PENTRY) NULL;
      WARNING1("HmgSetLock failed - invalid handle index or object type\n");
    }

    return((BOOL) (ULONG_PTR)pentTmp);
}

/******************************Public*Routine******************************\
* HmgQueryLock
*
* This returns the number of times an object has been Locked.
*
* Expects: A valid handle.  The handle should be validated and locked
*          before calling this.
*
* Returns: The number of times the object has been locked.
*
* History:
*  28-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG FASTCALL HmgQueryLock(HOBJ hobj)
{
    UINT uiIndex = (UINT) HmgIfromH(hobj);

// Note we don't need to grab the semaphore because this call assumes the
// handle has already been locked down and we are just reading memory.

    ASSERTGDI(uiIndex < gcMaxHmgr, "HmgQueryLock invalid handle");

    return(gpentHmgr[uiIndex].einfo.pobj->cExclusiveLock);
}

/******************************Public*Routine******************************\
* HmgQueryAltLock
*
* This returns the number of times an object has been Alt-Locked.
*
* Expects: A valid handle.  The handle should be validated and locked
*          before calling this.
*
* Returns: The number of times the object has been locked.
*
* History:
*  28-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG FASTCALL HmgQueryAltLock(HOBJ hobj)
{
    UINT uiIndex = (UINT) HmgIfromH(hobj);

// Note we don't need to grab the semaphore because this call assumes the
// handle has already been locked down and we are just reading memory.

    ASSERTGDI(uiIndex < gcMaxHmgr, "HmgQueryAltLock invalid handle");

    return((ULONG) gpentHmgr[uiIndex].einfo.pobj->ulShareCount);
}

/******************************Public*Routine******************************\
* HOBJ hGetFreeHandle()
*
* Get the next available handle.
*
* History:
*  Mon 21-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make pent commit memory as needed, add logging of error codes.
*
*  Sun 20-Oct-1991 -by- Patrick Haluptzok [patrickh]
* add uniqueness to the handle when getting it.
*
*  12-Dec-1989 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

HOBJ hGetFreeHandle(
    OBJTYPE objt
    )
{

#if GDI_PERF
    HmgCurrentNumberOfHandles[objt]++;
    HmgNumberOfHandlesAllocated[objt]++;

    if (HmgCurrentNumberOfHandles[objt] > HmgMaximumNumberOfHandles[objt])
        HmgMaximumNumberOfHandles[objt]++;
#endif

    LONG_PTR uiIndex;

    if (ghFreeHmgr != (HOBJ) 0)
    {
        PENTRYOBJ  pentTmp;

        uiIndex = HmgIfromH(ghFreeHmgr);
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];
        ghFreeHmgr = pentTmp->einfo.hFree;

        pentTmp->FullUnique = USUNIQUE(pentTmp->FullUnique,objt);

        uiIndex = (LONG_PTR)MAKE_HMGR_HANDLE(uiIndex,pentTmp->FullUnique);
        return((HOBJ) uiIndex);
    }

    if (gcMaxHmgr >= MAX_HANDLE_COUNT)
    {
        WARNING("Hmgr hGetFreeHandle failed to grow\n");
        return ((HOBJ) 0);
    }

    //
    // Allocate a new handle table entry and set the uniqueness value.
    //
    // N.B. All newly committed memory is zeroed.
    //

    uiIndex = USUNIQUE(UNIQUE_INCREMENT,objt);
    gpentHmgr[gcMaxHmgr].FullUnique = (USHORT) uiIndex;
    uiIndex = (LONG_PTR)MAKE_HMGR_HANDLE(gcMaxHmgr,uiIndex);
    gcMaxHmgr++;
    return((HOBJ) uiIndex);
}

/******************************Public*Routine******************************\
* HmgModifyHandleUniqueness()
*
* The handle passed in has already been updated to the new handle.
*
* This routine adds bits to the uniquess, updating both the handle entry
* and and the handle in the object it self.  This routine assumes that it is
* safe to be playing with the handle.  This means that the handle is locked
* or it is during initialization and setting the stock bit.
*
*
* History:
*  18-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HOBJ HmgModifyHandleType(
    HOBJ  h
    )
{
    PENTRY pent    = &gpentHmgr[HmgIfromH(h)];
    USHORT usUnique = HmgUfromH(h);

    ASSERTGDI((((ULONG_PTR)pent->einfo.pobj->hHmgr ^ (ULONG_PTR)h) & (UNIQUE_MASK | TYPE_MASK)) == 0,
                                           "HmgModifyHandleType bad handle\n");

    ASSERTGDI((pent->einfo.pobj->cExclusiveLock > 0) ||
              (pent->einfo.pobj->ulShareCount > 0) ||
              HmgStockObj(h),
              "HmgModifyHandleType not safe\n");

    pent->FullUnique = usUnique;
    pent->einfo.pobj->hHmgr = h;
    return(h);
}


/******************************Public*Routine******************************\
* HmgLockAndModifyHandleType()
*
* The handle passed in has already been updated to the new handle.
*
* The Handle is locked assuming owned by OBJECT_OWNER_CURRENT
* or ObJECT_OWNER_PUBLIC.
*
* Then this routine adds bits to the uniquess, updating both the handle entry
* and and the handle in the object it self.
*
* History:
*  31-Oct-2000 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

BOOL HmgLockAndModifyHandleType(
    HOBJ  h
    )
{
    PENTRY pent    = &gpentHmgr[HmgIfromH(h)];

    HANDLELOCK HandleLock(pent,TRUE);

    if (HandleLock.bValid())
    {
        HmgModifyHandleType(h);

        HandleLock.vUnlock();

        return(TRUE);
    }
    return(FALSE);
}
/******************************Public*Routine******************************\
* HmgIncUniqueness()
*
* Modify the handle uniqueness
*
* This is implemented for the brush/pen caching and lazy deletion to make sure:
*
*  a)a handle will not be cached twice (changing the handle uniqueness gurantees this)
*
*  b)a handle will not be cached if it is a lazy deletion (cShareLock == 0)
*
* History:
*  8-May-1995 -by-  Lingyun Wang [lingyunw]
*
\**************************************************************************/

HOBJ
HmgIncUniqueness(
    HOBJ  hobj,
    OBJTYPE objt
    )
{
    PENTRY pentry;
    USHORT usUnique = HmgUfromH(hobj);
    POBJ   pobj;
    UINT   uiIndex= (UINT) HmgIfromH(hobj);
    HOBJ   hNew = NULL;

    if (uiIndex < gcMaxHmgr)
    {
        pentry = &gpentHmgr[uiIndex];

        HANDLELOCK HandleLock(pentry,FALSE);

        if (HandleLock.bValid())
        {
            //
            // validate objt and uniqueness, increment unique if correct
            //

            if (
                 (pentry->FullUnique == usUnique) &&
                 (OBJECTOWNER_PID(pentry->ObjectOwner) == W32GetCurrentPID()) &&
                 ((pentry = &gpentHmgr[uiIndex])->Objt == objt)
               )
            {
                pentry->FullUnique += UNIQUE_INCREMENT;

                hNew = (HOBJ)MAKE_HMGR_HANDLE(uiIndex, pentry->FullUnique);

                pentry->einfo.pobj->hHmgr = hNew;
            }
            HandleLock.vUnlock();
        }
    }

    return(hNew);
}

/******************************Public*Routine******************************\
* int NtGdiGetStats(HANDLE,int,int,PVOID,UINT)
*
* This function returns information from the handle manager about
* the gdi objects that are existing.
*
* Parameters:
*    hProcess - handle to the process to query for information about
*    iIndex   - type of information to return
*    iPidType - whether to query for just the process pointed
*               to by hProcess, or ALL gdi objects or PUBLIC gdi objects
*    pResults - Pointer to the buffer to fill the data into
*    cjResultSize - Size of the buffer to fill
*
* The user buffer is expected to be zero'd. Memory trashing
* may occur if the size parameter is incorrect.
*
* returns: Success state
*
* History:
*  Wed 7-Jun-1995 -by- Andrew Skowronski [t-andsko]
* Wrote it.
\**************************************************************************/

#define OBJECT_OWNER_IGNORE (0x0001)

NTSTATUS APIENTRY
NtGdiGetStats(
    HANDLE  hProcess,
    int     iIndex,
    int     iPidType,
    PVOID   pResults,
    UINT    cjResultSize
    )
{
    DWORD   *   pdwRes = (DWORD *) pResults;    //Pointer to the result buffer
    W32PID      pid;
    PENTRY      pHmgEntry;                      //Pointer to current entry in the handle manager table
    ULONG       ulLoop;
    NTSTATUS    iRet   = STATUS_SUCCESS;

    //
    // Check permissions flag
    //

#if !defined(_GDIPLUS_)

    if (!( RtlGetNtGlobalFlags() & FLG_POOL_ENABLE_TAGGING))
    {
          iRet = STATUS_ACCESS_DENIED;
    }

#endif

    //
    // Validate buffer size
    //

    switch(iIndex)
    {
        case (GS_NUM_OBJS_ALL) :
            if (cjResultSize < ((MAX_TYPE+1)*sizeof(ULONG)))
                iRet = STATUS_BUFFER_TOO_SMALL;
            break;

#if DBG
        case (GS_HANDOBJ_CURRENT) :
        case (GS_HANDOBJ_MAX)     :
        case (GS_HANDOBJ_ALLOC)   :
        case (GS_LOOKASIDE_INFO)  :
            if (cjResultSize < ((MAX_TYPE+1)*sizeof(ULONG)*2))
                iRet = STATUS_BUFFER_TOO_SMALL;
            break;
#else
        // This info is not available in non-checked builds
        case (GS_HANDOBJ_CURRENT) :
        case (GS_HANDOBJ_MAX)     :
        case (GS_HANDOBJ_ALLOC)   :
        case (GS_LOOKASIDE_INFO)  :
            break;
#endif

        default :
            iRet = STATUS_NOT_IMPLEMENTED;
            break;
    }

    if (NT_SUCCESS(iRet))
    {
        __try
        {
            ProbeForWrite(pResults, cjResultSize, sizeof(UCHAR));

            switch(iIndex)
            {
                case (GS_NUM_OBJS_ALL) :

                    //
                    // Determine the search key.
                    //

                    if (iPidType == (int) OBJECT_OWNER_CURRENT)
                    {
                        pid = (W32PID) ((ULONG) ((ULONG_PTR)hProcess & PID_BITS));
                    }
                    else
                    {
                        //
                        // This takes care of OBJECT_OWNER_PUBLIC
                        // and OBJECT_OWNER_IGNORE
                        //

                        pid = (W32PID) iPidType;
                    }

                    //
                    // Scan through the handle manager table and
                    // pick out the relevant objects
                    //

                    for (ulLoop = 0; ulLoop < gcMaxHmgr; ulLoop++)
                    {
                        pHmgEntry = &(gpentHmgr[ulLoop]);

                        if ((pid == OBJECT_OWNER_IGNORE) ||
                            (pid == OBJECTOWNER_PID(pHmgEntry->ObjectOwner)))
                        {
                            //
                            // Now, depending on the iIndex value we
                            // analyse the results
                            //

                            switch (iIndex)
                            {
                                case (GS_NUM_OBJS_ALL) :
                                    pdwRes[pHmgEntry->Objt]++;
                                    break;
                                default :
                                    iRet = STATUS_NOT_IMPLEMENTED;
                                    break;
                            }
                        }
                    }
                    break;

#if DBG
                case (GS_HANDOBJ_CURRENT) :
                    RtlCopyMemory(pdwRes,
                                  HmgCurrentNumberOfHandles,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgCurrentNumberOfObjects,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

                case (GS_HANDOBJ_MAX)     :
                    RtlCopyMemory(pdwRes,
                                  HmgMaximumNumberOfHandles,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgMaximumNumberOfObjects,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

                case (GS_HANDOBJ_ALLOC)   :
                    RtlCopyMemory(pdwRes,
                                  HmgNumberOfHandlesAllocated,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgNumberOfObjectsAllocated,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

                case (GS_LOOKASIDE_INFO)  :
                    RtlCopyMemory(pdwRes,
                                  HmgNumberOfLookAsideHits,
                                  (MAX_TYPE+1)*sizeof(ULONG));

                    RtlCopyMemory(&(pdwRes[MAX_TYPE + 1]),
                                  HmgNumberOfObjectsAllocated,
                                  (MAX_TYPE+1)*sizeof(ULONG));
                    break;

#else
                // This info is not available in non-checked builds
                case (GS_HANDOBJ_CURRENT) :
                case (GS_HANDOBJ_MAX)     :
                case (GS_HANDOBJ_ALLOC)   :
                case (GS_LOOKASIDE_INFO)  :
                    break;
#endif
                default :
                    iRet = STATUS_NOT_IMPLEMENTED;
                    break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            iRet = STATUS_ACCESS_VIOLATION;
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* HmgAllocateSecureUserMemory
*
*   Allocate and lock 1 page, add as free DC_ATTRs
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    15-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PVOID
HmgAllocateSecureUserMemory(HANDLE *phSecure)
{
    PVOID pvRet = NULL;
    NTSTATUS NtStatus;

    //
    // allocate 1 page of user mode memory
    //

    SIZE_T ViewSize = PAGE_SIZE;

    NtStatus = ZwAllocateVirtualMemory(
                            NtCurrentProcess(),
                            &pvRet,
                            0L,
                            &ViewSize,
                            MEM_COMMIT | MEM_RESERVE,
                            PAGE_READWRITE
                            );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // secure virtual memory
        //

        HANDLE hSecure = *phSecure = MmSecureVirtualMemory(pvRet, ViewSize, PAGE_READWRITE);

        if (hSecure != NULL)
        {
            RtlZeroMemory((PVOID)pvRet,ViewSize);
        }
        else
        {
            //
            // free memory
            //

            ZwFreeVirtualMemory(
                        NtCurrentProcess(),
                        (PVOID*)&pvRet,
                        &ViewSize,
                        MEM_RELEASE);

            pvRet = NULL;
        }
    }

    return(pvRet);
}


/******************************Public*Routine******************************\
* HmgFreeSecureUserMemory
*
*   unlock 1 page, and free it
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    30-Oct-2001 -by- Pravin Santiago[pravins]
*
\**************************************************************************/

VOID
HmgFreeAllocateSecureUserMemory(PVOID pvAttr, HANDLE hSecure)
{
    SIZE_T ViewSize = PAGE_SIZE;

    MmUnsecureVirtualMemory(hSecure);
    ZwFreeVirtualMemory(NtCurrentProcess(),
                        &pvAttr,
                        &ViewSize,
                        MEM_RELEASE);

    return;
}
/******************************Public*Routine******************************\
* HmgAllocateDcAttr
*
*   Look first for free DC_ATTR block on thread, else look on process
*   free list. If none is available, try to allocate user-mode memory.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   pDC_ATTR or NULL
*
* History:
*
*    24-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

PDC_ATTR
HmgAllocateDcAttr()
{
    PW32THREAD  pThread = W32GetCurrentThread();
    PDC_ATTR    pDCAttr = NULL;

#if defined(_GDIPLUS_)

    pDCAttr = (DC_ATTR*) PALLOCMEM(sizeof(DC_ATTR), 'zzzG');

#else

    //
    // look on thread for free dcattr
    //

    if (pThread->pgdiDcattr)
    {
        pDCAttr = (PDC_ATTR)pThread->pgdiDcattr;
        pThread->pgdiDcattr = NULL;
    }
    else
    {
        PW32PROCESS Process = W32GetCurrentProcess();

        GreAcquireHmgrSemaphore();

        //
        // look on process list for free dcattr, if none are
        // available then allocate 1 page of memory and add
        // to list.
        //

        PDC_ATTR      *pdcaFreeList = 0;
        PDCAFLISTENTRY pFreeList = 0;

        // If the free list empty try to allocate one:

        if (Process->pDCAttrList == NULL)
        {
            ASSERTGDI(IsListEmpty(&Process->GDIDcAttrFreeList),
                      "HmgAllocateDcAttr pDCAttrList is NULL but GDIDcAttrFreeList is not empty\n");
            HANDLE hSecure;

            PDC_ATTR pdca = (PDC_ATTR)HmgAllocateSecureUserMemory(&hSecure);

            if (pdca != (PDC_ATTR)NULL)
            {
                ULONG ulIndex;

                pFreeList = (PDCAFLISTENTRY)PALLOCNOZ(sizeof(DCAFLISTENTRY),
                                                     'fcdG');

                if (pFreeList == 0)
                {
                    HmgFreeAllocateSecureUserMemory(pdca, hSecure);
                    GreReleaseHmgrSemaphore();
                    return 0;
                }

                InsertHeadList(&Process->GDIDcAttrFreeList,
                               (PLIST_ENTRY)pFreeList);

                pFreeList->cFree = ULNUMDC;

                pdcaFreeList = (PDC_ATTR *)(&pFreeList->a[0]);

                //
                // set the new free list pointing to the new dcattrs allocated
                // in user mode memory.
                //

                Process->pDCAttrList = (PVOID)&pdca[ULNUMDC-1];

                for (ulIndex=0;ulIndex<ULNUMDC;ulIndex++)
                {
                    pdcaFreeList[ulIndex] = &pdca[ulIndex];
                }
            }
        }

        if (Process->pDCAttrList != NULL)
        {
            ASSERTGDI(!IsListEmpty(&Process->GDIDcAttrFreeList),
                      "HmgAllocateDcAttr pDCAttrList != NULL but GDIDcAttrFreeList is empty\n");

            pFreeList = (PDCAFLISTENTRY)Process->GDIDcAttrFreeList.Flink;

            pdcaFreeList = (PDC_ATTR *)(&pFreeList->a[0]);

            ASSERTGDI(Process->pDCAttrList == (PVOID)(pdcaFreeList[pFreeList->cFree-1]),
                      "HmgAllocateDcAttr pdcAttrList and pdcaFreeList entries dont match\n");
            //
            // get dcattr and remove from list
            //

            pDCAttr = (PDC_ATTR)Process->pDCAttrList;

            pFreeList->cFree--;

            // If pFreeList has no more free entries remove it from the process
            // free list. Else adjust the free list pointer to next available
            // attr.

            if (pFreeList->cFree == 0)
            {
                RemoveEntryList((PLIST_ENTRY)pFreeList);

                VFREEMEM(pFreeList);

                // If the process free list is not empty, update free list
                // pointer to the next available entry. Else set it to NULL.

                if (!IsListEmpty(&Process->GDIDcAttrFreeList))
                {
                    pFreeList = (PDCAFLISTENTRY)Process->GDIDcAttrFreeList.Flink;
                    ASSERTGDI(pFreeList->cFree == ULNUMDC,
                              "HmgAllocateDcAttr: next available free list does not have cFree of ULNUMDC\n");

                    pdcaFreeList = (PDC_ATTR *)(&pFreeList->a[0]);

                    Process->pDCAttrList = (PVOID) (pdcaFreeList[pFreeList->cFree-1]);
                }
                else
                {
                    Process->pDCAttrList = 0;
                }
            }
            else
            {
                Process->pDCAttrList = (PVOID) (pdcaFreeList[pFreeList->cFree-1]);
            }
        }

        GreReleaseHmgrSemaphore();
    }

#endif

    return(pDCAttr);
}

/******************************Public*Routine******************************\
* HmgAllocateBrushAttr
*
*   Look on thread for free brushattr, else look on process free
*   list. If none is available, allocate a dcattr and divide it
*   up.
*
* Arguments:
*
*   none
*
* Return Value:
*
*   pbrushattr or NULL
*
* History:
*
*    28-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

POBJECTATTR
HmgAllocateObjectAttr()
{
    PW32THREAD    pThread = W32GetCurrentThread();
    POBJECTATTR   pobjattr = NULL;

#if defined(_GDIPLUS_)

    pobjattr = (OBJECTATTR*) PALLOCMEM(sizeof(OBJECTATTR), 'zzzG');

#else

    //
    // quick check on thread for free OBJECTATTR
    //

    if (pThread->pgdiBrushAttr)
    {
        pobjattr = (POBJECTATTR)pThread->pgdiBrushAttr;
        pThread->pgdiBrushAttr = NULL;
    }
    else
    {
        PW32PROCESS Process = W32GetCurrentProcess();

        GreAcquireHmgrSemaphore();

        //
        // look on process list for free dcattr, if none are
        // available then allocate 1 page of memory and add
        // to list.
        //

        POBJECTATTR *pobaFreeList = 0;
        POBAFLISTENTRY pFreeList = 0;

        if (Process->pBrushAttrList == NULL)
        {
            ASSERTGDI(IsListEmpty(&Process->GDIBrushAttrFreeList),
                      "HmgAllocateObjectAttr pBrushAttrList is NULL but GDIBrushAttrFreeList is not empty\n");
            HANDLE hSecure;

            POBJECTATTR psbr = (POBJECTATTR)HmgAllocateSecureUserMemory(&hSecure);

            if (psbr != (POBJECTATTR)NULL)
            {
                ULONG ulIndex;

                // No free list available. Allocate one which can handle
                // ulNumBrush entries.

                pFreeList = (POBAFLISTENTRY)PALLOCNOZ(sizeof(OBAFLISTENTRY),
                                                      'fabG');

                if (pFreeList == 0)
                {
                    HmgFreeAllocateSecureUserMemory(psbr, hSecure);
                    GreReleaseHmgrSemaphore();
                    return 0;
                }

                InsertHeadList(&Process->GDIBrushAttrFreeList,
                               (PLIST_ENTRY)pFreeList);

                pFreeList->cFree = ULNUMBRUSH;

                pobaFreeList = (POBJECTATTR *)(&pFreeList->a[0]);

                //
                // init process list, then create a linked list of all
                // the new dcattrs on the process list
                //

                Process->pBrushAttrList = (PVOID)&psbr[ULNUMBRUSH-1];

                for (ulIndex=0;ulIndex<ULNUMBRUSH;ulIndex++)
                {
                    pobaFreeList[ulIndex] = &psbr[ulIndex];
                }

            }
        }

        if (Process->pBrushAttrList != NULL)
        {
            ASSERTGDI(!IsListEmpty(&Process->GDIBrushAttrFreeList),
                      "HmgAllocateObjectAttr pBrushAttrList != NULL but GDIBrushAttrFreeList is empty\n");

            pFreeList = (POBAFLISTENTRY)Process->GDIBrushAttrFreeList.Flink;

            pobaFreeList = (POBJECTATTR*)(&pFreeList->a[0]);

            ASSERTGDI(Process->pBrushAttrList == (PVOID)(pobaFreeList[pFreeList->cFree-1]),
                      "HmgAllocateObjectAttr pBrushAttrList and pobjFreeList entries dont match\n");

            //
            // get dcattr and remove from list
            //

            pobjattr = (POBJECTATTR)Process->pBrushAttrList;

            pFreeList->cFree--;

            // If pFreeList has no more free entries remove it from the process
            // free list. Else adjust the free list pointer to next available
            // attr.

            if (pFreeList->cFree == 0)
            {
                RemoveEntryList((PLIST_ENTRY)pFreeList);

                VFREEMEM(pFreeList);

                // If the process free list is not empty, update free list
                // pointer to the next available entry. Else set it to NULL.

                if (!IsListEmpty(&Process->GDIBrushAttrFreeList))
                {
                    pFreeList = (POBAFLISTENTRY)Process->GDIBrushAttrFreeList.Flink;
                    ASSERTGDI(pFreeList->cFree == ULNUMBRUSH,
                              "HmgAllocateObjextAttr: next available free list does not have cFree of ULNUMBRUSH\n");

                    pobaFreeList = (POBJECTATTR*)(&pFreeList->a[0]);

                    Process->pBrushAttrList = (PVOID) (pobaFreeList[pFreeList->cFree-1]);
                }
                else
                {
                    Process->pBrushAttrList = 0;
                }
            }
            else
            {
                Process->pBrushAttrList = (PVOID) (pobaFreeList[pFreeList->cFree-1]);
            }
        }

        GreReleaseHmgrSemaphore();
    }

#endif

    return(pobjattr);
}

/******************************Public*Routine******************************\
* HmgFreeDcAttr
*
*   Free the dcattr, try to put it on w32thread, if no space then push onto
*   w32process
*
* Arguments:
*
*   pdcattr
*
* Return Value:
*
*   none
*
* History:
*
*    28-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
HmgFreeDcAttr(
    PDC_ATTR pdca
    )
{
    PW32THREAD  pThread = W32GetCurrentThread();

#if defined(_GDIPLUS_)

    VFREEMEM(pdca);

#else

    if ((pdca != NULL) && (pThread != NULL))
    {

        //
        // try to place on thread
        //

        if (pThread->pgdiDcattr == NULL)
        {
             pThread->pgdiDcattr = pdca;
        }
        else
        {
            PW32PROCESS Process = W32GetCurrentProcess();

            //
            // Need to check if W32 process pointer is valid.  There are
            // circumstances in which the process can die without setting
            // the W32 process.
            //

            if (Process != NULL)
            {
                GreAcquireHmgrSemaphore();

                //
                // We have to allocate a new free List Entry or add to the one
                // we already have.

                PDCAFLISTENTRY pFreeList = 0;
                PDC_ATTR       *pdcaFreeList = 0;

                if (IsListEmpty(&Process->GDIDcAttrFreeList) ||
                    ((PDCAFLISTENTRY)Process->GDIDcAttrFreeList.Flink)->cFree == ULNUMDC)
                {
                    pFreeList = (PDCAFLISTENTRY)PALLOCNOZ(sizeof(DCAFLISTENTRY),
                                                          'fcdG');

                    if (pFreeList == 0)
                    {
                        GreReleaseHmgrSemaphore();
                        return;
                    }

                    InsertHeadList(&Process->GDIDcAttrFreeList,
                                   (PLIST_ENTRY)pFreeList);

                    pFreeList->cFree = 0;

                }
                else
                {
                    pFreeList = (PDCAFLISTENTRY)Process->GDIDcAttrFreeList.Flink;
                }

                pdcaFreeList = (PDC_ATTR *)(&pFreeList->a[0]);
                // place on process single linked list

                pFreeList->cFree++;

                pdcaFreeList[pFreeList->cFree-1] = pdca;

                Process->pDCAttrList = pdca;

                GreReleaseHmgrSemaphore();
            }
        }
    }

#endif

}

/******************************Public*Routine******************************\
* HmgFreeObjectAttr
*
*   Free the objattr, try to put it on w32thread, if no space then
*   check other part(s) of block that make up a dcattr. If they are
*   free then place whole dcattr back on dcattr list.
*
* Arguments:
*
*   pobjattr
*
* Return Value:
*
*   none
*
* History:
*
*    28-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
HmgFreeObjectAttr(
    POBJECTATTR pobjattr
    )
{
    PW32THREAD  pThread = W32GetCurrentThread();

#if defined(_GDIPLUS_)

    VFREEMEM(pobjattr);

#else

    if ((pobjattr != NULL) && (pThread != NULL))
    {
        //
        // try to place on thread
        //

        if (pThread->pgdiBrushAttr == NULL)
        {
             pThread->pgdiBrushAttr = pobjattr;
        }
        else
        {
            PW32PROCESS Process = W32GetCurrentProcess();

            //
            // Need to check if W32 process pointer is valid.  There are
            // circumstances in which the process can die without setting
            // the W32 process.
            //

            if (Process != NULL)
            {
                GreAcquireHmgrSemaphore();

                //
                // We have to allocate a new free List Entry or add to the one
                // we alread have.

                POBAFLISTENTRY pFreeList = 0;
                POBJECTATTR    *pobaFreeList = 0;

                if (IsListEmpty(&Process->GDIBrushAttrFreeList) ||
                    ((POBAFLISTENTRY)Process->GDIBrushAttrFreeList.Flink)->cFree == ULNUMBRUSH)
                {
                    pFreeList = (POBAFLISTENTRY)PALLOCNOZ(sizeof(OBAFLISTENTRY),
                                                          'fabG');
                    if (pFreeList == 0)
                    {
                        GreReleaseHmgrSemaphore();
                        return;
                    }

                    InsertHeadList(&Process->GDIBrushAttrFreeList,
                                   (PLIST_ENTRY)pFreeList);

                    pFreeList->cFree = 0;

                }
                else
                {
                    pFreeList = (POBAFLISTENTRY)Process->GDIBrushAttrFreeList.Flink;
                }

                pobaFreeList = (POBJECTATTR*)(&pFreeList->a[0]);

                //
                // place on process single linked list
                //

                pFreeList->cFree++;

                pobaFreeList[pFreeList->cFree-1] = pobjattr;

                Process->pBrushAttrList = pobjattr;

                GreReleaseHmgrSemaphore();
            }
        }
    }

#endif

}

/******************************Public*Routine******************************\
* GreIncQuotaCount GreDecQuotaCount
*
* This is called by user Inc or Dec cursor bitmaps against the creating process
*
* Notice that cursor bitmaps are marked as PUBLIC by USER but charged against
* the creating process's handle quota
*
* History:
* 2/10/98 - by Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID GreIncQuotaCount(PW32PROCESS pW32)
{
    InterlockedIncrement(&pW32->GDIHandleCount);
}

VOID GreDecQuotaCount(PW32PROCESS pW32)
{
    InterlockedDecrement(&pW32->GDIHandleCount);
}

/******************************Public*Routine******************************\
* HmgPrintBadHandle
*
*   Simple routine that prints out a warning when a handle manager
*   lock fails due to a bad handle.
*
\**************************************************************************/

#if DBG

CONST CHAR* aszType[] = {
    "hdef",         // DEF_TYPE
    "HDC",          // DC_TYPE
    "hunused",      // DD_DIRECTDRAW_TYPE
    "hunused",      // DD_SURFACE_TYPE
    "HRGN",         // RGN_TYPE
    "HBITMAP",      // SURF_TYPE
    "HCLIENT",      // CLIENTOBJ_TYPE
    "hpath",        // PATH_TYPE
    "HPALETTE",     // PAL_TYPE
    "HCOLORSPACE",  // ICMLCS_TYPE
    "HFONT",        // LFONT_TYPE
    "hrfont",       // RFONT_TYPE
    "hpfe",         // PFE_TYPE
    "hpft",         // PFT_TYPE
    "hicmcxf",      // ICMCXF_TYPE
    "HSPRITE",      // SPRITE_TYPE
    "HBRUSH",       // BRUSH_TYPE
    "hunused",      // D3D_HANDLE_TYPE
    "hunused",      // DD_VIDEOPORT_TYPE
    "hspace",       // SPACE_TYPE
    "hunused",      // DD_MOTIONCOMP_TYPE
    "HENHMETAFILE", // META_TYPE
    "hefstate",     // EFSTATE_TYPE
    "hunused",      // BMFD_TYPE
    "hunused",      // VTFD_TYPE
    "hunused",      // TTFD_TYPE
    "hunused",      // RC_TYPE
    "hunused",      // TEMP_TYPE
    "HDRVOBJ",      // DRVOBJ_TYPE
    "hunused",      // DCIOBJ_TYPE
    "hspool",       // SPOOL_TYPE
    "hunused",      //
};

VOID
HmgPrintBadHandle(
    HOBJ    hobj,
    OBJTYPE objt
    )
{
    static CHAR *szSystem = "System";
    static CHAR *szUnknown = "???";
    CHAR        *pszImage;

    {
        PETHREAD    pet;
        PEPROCESS   pep;

        if (pep = PsGetCurrentProcess())
        {
            pszImage = (CHAR *)PsGetProcessImageFileName(pep);
            if (*pszImage == '\0')
            {
                pszImage = szSystem;
            }
        }
        else
        {
            pszImage = szUnknown;
        }
    }

    KdPrint(("GDI: %s or DLL gave bad handle 0x%p as an %s.\n",
        pszImage, hobj, aszType[objt]));

    // Private debug code to catch invalid hpath handle in DC
    // 6/24/98 - davidx

    if (hobj != NULL && objt == PATH_TYPE)
    {
        RIP("Private debug breakpoint. Please contact ntgdi.");
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\invcmap.cxx ===
/*****************************************************************************
 *
 *  Inverse color map code, from Graphics Gems II.
 *
 *  this code builds a inverse map table, used for color mapping a
 *  hi color (bpp > 8) image down to 4bpp or 8bpp
 *
 *  a inverse table is a 32K table that mapps a RGB 555 value (a WORD) to
 *  a palette index (a BYTE)
 *
 *  public functions:
 *      MakeITable      - makes a inverse table to any palette
 *
 *  non-public functions:
 *      inv_cmap        - work horse for MakeITable
 *      MakeITableVGA   - makes a inverse table to the VGA colors
 *      MakeITable256   - makes a inverse table to a uniform 6 level palette
 *
 *  Created: Feb 20 1994, ToddLa
 *
 * Copyright (c) 1994-1999 Microsoft Corporation
 *****************************************************************************/

#include "precomp.hxx"

#ifdef WIN32
    #define _huge
    #undef GlobalAllocPtr
    #undef GlobalFreePtr
    #define GlobalAllocPtr(f, cb)   (LPVOID)GlobalAlloc(((f) & ~GMEM_MOVEABLE) | GMEM_FIXED, cb)
    #define GlobalFreePtr(p)        GlobalFree((HGLOBAL)(p))
#endif

typedef DWORD _huge *PDIST;
typedef BYTE  FAR  *PIMAP;

typedef struct {BYTE r,g,b,x;} RGBX;

void inv_cmap( int colors, RGBX FAR *colormap, int bits,
        PDIST dist_buf, PIMAP rgbmap );

BOOL MakeITableMono(PIMAP lpITable);
BOOL MakeITable256(PIMAP lpITable);
BOOL MakeITableVGA(PIMAP lpITable);
BOOL MakeITableDEF(PIMAP lpITable);

PBYTE gpDefITable = NULL;

/*****************************************************************************
 *
 *  MakeITable
 *
 *      build a 32k color inverse table to a palette
 *
 *  lpITable points to a 32K table to hold inverse table
 *  prgb     points to the palette RGBs to build table from.
 *  nColors  number of RGBs
 *
 *  if prgb is NULL build a special inverse table, to a fixed color table
 *
 *      nColors = 2  build to mono colors (black,white)
 *      nColors = 16 build to VGA colors.
 *      nColors = 20 build to GDI DEFAULT_PALETTE
 *      nColors = 216 build to 6*6*6 colors.
 *
 *****************************************************************************/

BOOL MakeITable(PIMAP lpITable, RGBX FAR *prgb, int nColors)
{
    PDIST   lpDistBuf;
    PIMAP   iTable = lpITable;

    //
    //  handle special color tables.
    //
    if (prgb == NULL)
    {
        switch (nColors)
        {
            case 2:
                return MakeITableMono(lpITable);
            case 16:
                return MakeITableVGA(lpITable);
            case 20:
                return MakeITableDEF(lpITable);
            case 256:
                return MakeITable256(lpITable);
            default:
                return FALSE;
        }
    }

    //
    // We need to grab the global palette semaphore here
    // because inv_cmap is not thread-safe (it uses all
    // kinds of global variables)
    //

    BOOL    result = FALSE;
    SEMOBJ semo(ghsemPalette);

    //
    // Check if palette is default palette.  If it is, use the
    // cached default palette iTable.  Create cache as appropriate.
    //

    if(nColors >= 20)
    {
        int         i;
        ULONG *     pulDef = (ULONG *) logDefaultPal.palPalEntry;
        ULONG *     pulSrc = (ULONG *) prgb;

        for(i = 0; i < nColors; i++)
            if(pulSrc[i] != pulDef[i%20])
                break;

        if(i == nColors)
        {
            if(gpDefITable != NULL)
            {
                RtlCopyMemory(lpITable, gpDefITable, 32768);
                return TRUE;
            }
            
            iTable = (PBYTE)PALLOCNOZ(32768,'tidG');

            if(iTable == NULL)
                iTable = lpITable;

            nColors = 20;
        }
    
    }
    
    //
    // not a special table
    //
    lpDistBuf = (PDIST)PALLOCNOZ(32768l * sizeof(DWORD),'pmtG');

    if (lpDistBuf != NULL)
    {
        inv_cmap(nColors,prgb,5,lpDistBuf, iTable);
        VFREEMEM(lpDistBuf);
        result = TRUE;

        if(iTable != lpITable)
        {
            RtlCopyMemory(lpITable, iTable, 32768);
            gpDefITable = iTable;
        }
    }
    else
    {
        if(iTable != lpITable)
            VFREEMEM(iTable);
    }

    return result;
}

/*****************************************************************************
 *
 *  MakeITable256
 *
 *      build a 32k color inverse table to a 3-3-2 palette
 *
 *****************************************************************************/

BOOL MakeITable256(PIMAP lpITable)
{
    PIMAP pb;
    int   r,g,b;

    pb = lpITable;

    for (r=0;r<32;r++)
        for (g=0;g<32;g++)
            for (b=0;b<32;b++)
                *pb++ = (((r & 0x1c) << 3)| (g & 0x1c) | ((b & 0x18) >> 3));

    return TRUE;
}

//;-----------------------------------------------------------------------------
//; vga_map
//;                                                                            ;
//; Subdividing the RGB color cube twice along each axis yields 64 smaller     ;
//; cubes.  A maximum of three VGA colors, and often only one VGA color,       ;
//; match (Euclidean distance) into each of the subdivided cubes.  Therefore,  ;
//; this adaptive Eudclidean match is must faster than the traditional         ;
//; Euclidean match.                                                           ;
//;                                                                            ;
//; Note:  This table was built according to the VGA palette.  The             ;
//; indices it returns will not be appropriate for all devices.  Use a         ;
//; VgaTranslateMap to produce the final physical color index.                 ;
//; (Example: GDI has indices 7 and 8 reversed.  To use this code in GDI,      ;
//; enable the VgaTranslateMap and swap indices 7 and 8.)                      ;
//;                                                                            ;
//; The index to this map is computed as follows given a 24-bit RGB.           ;
//;                                                                            ;
//;       index = ((Red & 0xC0) >> 2)     |                                    ;
//;               ((Green & 0xC0) >> 4)   |                                    ;
//;               ((Blue & 0xC0) >> 6);                                        ;
//;                                                                            ;
//; Each entry is a word made up of four nibbles.  The first nibble always     ;
//; contains a valid GDI VGA color index.  The second and third nibbles        ;
//; contain valid GDI VGA color indices if they are non-zero.                  ;
//; The fourth nibble is an optimization for sub-cubes 42 and 63.              ;
//;                                                                            ;
//; History:                                                                   ;
//; 23-February-1994      -by-    Raymond E. Endres [rayen]                    ;
//; Wrote it.                                                                  ;
//;-----------------------------------------------------------------------------

static WORD vga_map[] = {

        0x0000,             // Index 0      r=0 g=0 b=0
        0x0004,             //              r=1 g=0 b=0
        0x0004,             //              r=2 g=0 b=0
        0x000C,             //              r=3 g=0 b=0
        0x0002,             //              r=0 g=1 b=0
        0x0006,             //              r=1 g=1 b=0
        0x0006,             //              r=2 g=1 b=0
        0x00C6,             //              r=3 g=1 b=0

        0x0002,             // Index 8      r=0 g=2 b=0
        0x0006,             //              r=1 g=2 b=0
        0x0006,             //              r=2 g=2 b=0
        0x00E6,             //              r=3 g=2 b=0
        0x000A,             //              r=0 g=3 b=0
        0x00A6,             //              r=1 g=3 b=0
        0x00E6,             //              r=2 g=3 b=0
        0x000E,             //              r=3 g=3 b=0

        0x0001,             // Index 16     r=0 g=0 b=1
        0x0005,             //              r=1 g=0 b=1
        0x0005,             //              r=2 g=0 b=1
        0x00C5,             //              r=3 g=0 b=1
        0x0003,             //              r=0 g=1 b=1
        0x0008,             //              r=1 g=1 b=1
        0x0008,             //              r=2 g=1 b=1
        0x0C78,             //              r=3 g=1 b=1

        0x0003,             // Index 24     r=0 g=2 b=1
        0x0008,             //              r=1 g=2 b=1
        0x0078,             //              r=2 g=2 b=1
        0x0E78,             //              r=3 g=2 b=1
        0x00A3,             //              r=0 g=3 b=1
        0x0A78,             //              r=1 g=3 b=1
        0x0E78,             //              r=2 g=3 b=1
        0x0E78,             //              r=3 g=3 b=1

        0x0001,             // Index 32     r=0 g=0 b=2
        0x0005,             //              r=1 g=0 b=2
        0x0005,             //              r=2 g=0 b=2
        0x00D5,             //              r=3 g=0 b=2
        0x0003,             //              r=0 g=1 b=2
        0x0008,             //              r=1 g=1 b=2
        0x0078,             //              r=2 g=1 b=2
        0x0D78,             //              r=3 g=1 b=2

        0x0003,             // Index 40     r=0 g=2 b=2
        0x0078,             //              r=1 g=2 b=2
        0x0078,             //              r=2 g=2 b=2     1
        0x0078,             //              r=3 g=2 b=2
        0x00B3,             //              r=0 g=3 b=2
        0x0B78,             //              r=1 g=3 b=2
        0x0078,             //              r=2 g=3 b=2
        0x00F7,             //              r=3 g=3 b=2

        0x0009,             // Index 48     r=0 g=0 b=3
        0x0095,             //              r=1 g=0 b=3
        0x00D5,             //              r=2 g=0 b=3
        0x000D,             //              r=3 g=0 b=3
        0x0093,             //              r=0 g=1 b=3
        0x0978,             //              r=1 g=1 b=3
        0x0D78,             //              r=2 g=1 b=3
        0x0D78,             //              r=3 g=1 b=3

        0x00B3,             // Index 56     r=0 g=2 b=3
        0x0B78,             //              r=1 g=2 b=3
        0x0078,             //              r=2 g=2 b=3
        0x00F7,             //              r=3 g=2 b=3
        0x000B,             //              r=0 g=3 b=3
        0x0B78,             //              r=1 g=3 b=3
        0x00F7,             //              r=2 g=3 b=3
        0x00F7              //              r=3 g=3 b=3     1
};

static RGBX VGAColors[] = {
    00, 00, 00, 00,
    16, 00, 00, 00,
    00, 16, 00, 00,
    16, 16, 00, 00,
    00, 00, 16, 00,
    16, 00, 16, 00,
    00, 16, 16, 00,
    24, 24, 24, 00,
    16, 16, 16, 00,
    31, 00, 00, 00,
    00, 31, 00, 00,
    31, 31, 00, 00,
    00, 00, 31, 00,
    31, 00, 31, 00,
    00, 31, 31, 00,
    31, 31, 31, 00
};

/*****************************************************************************
 *
 *  MapVGA
 *
 *****************************************************************************/

__inline BYTE MapVGA(BYTE r, BYTE g, BYTE b)
{
    int i;

    //
    // build index into vga_map (r,g,b in range of 0-31)
    //
    i = ((b & 0x18) >> 3) | ((g & 0x18) >> 1) | ((r & 0x18) << 1);

    //
    // lookup in our "quick map" table
    //
    i = (int)vga_map[i];

    if (i & 0xFFF0)
    {
        //
        // more than one color is close, do a eclidian search of
        // at most three colors.
        //
        int e1,e,n,n1;

        e1 = 0x7fffffff;

        while (i)
        {
            n = i & 0x000F;

            e = ((int)VGAColors[n].r - r) * ((int)VGAColors[n].r - r) +
                ((int)VGAColors[n].g - g) * ((int)VGAColors[n].g - g) +
                ((int)VGAColors[n].b - b) * ((int)VGAColors[n].b - b) ;

            if (e < e1)
            {
                n1 = n;
                e1 = e;
            }

            i = i >> 4;
        }

        return (BYTE)n1;
    }
    else
    {
        //
        // one one color matchs, we are done
        //
        return (BYTE)(i & 0x000F);
    }
}

/*****************************************************************************
 *
 *  MakeITableVGA
 *
 *      build a 32k color inverse table to the VGA colors
 *
 *****************************************************************************/

BOOL MakeITableVGA(PIMAP lpITable)
{
    PIMAP pb;
    BYTE  r,g,b;

    pb = lpITable;

    for (r=0;r<32;r++)
        for (g=0;g<32;g++)
            for (b=0;b<32;b++)
                *pb++ = (BYTE)MapVGA(r,g,b);

    return TRUE;
}

/*****************************************************************************
 *
 *  MakeITableDEF
 *
 *      build a 32k color inverse table to the DEFAULT_PALETTE
 *      just builds a VGA ITable then bumps up values above 7
 *
 *****************************************************************************/

BOOL MakeITableDEF(PIMAP pb)
{
    int i;

    MakeITableVGA(pb);

    for (i=0;i<0x8000;i++)
        if (pb[i] >= 8)
            pb[i] += 240;

    return TRUE;
}

/*****************************************************************************
 *
 *  MakeITableMono
 *
 *      build a 32k color inverse table to black/white
 *
 *****************************************************************************/

BOOL MakeITableMono(PIMAP lpITable)
{
    PIMAP pb;
    BYTE  r,g,b;

    pb = lpITable;

    for (r=0;r<32;r++)
        for (g=0;g<32;g++)
            for (b=0;b<32;b++)
                *pb++ = (g/2 + (r+b)/4) > 15;

    return TRUE;
}


/*****************************************************************
 * TAG( inv_cmap )
 *
 * Compute an inverse colormap efficiently.
 * Inputs:
 *  colors:     Number of colors in the forward colormap.
 *  colormap:   The forward colormap.
 *  bits:       Number of quantization bits.  The inverse
 *          colormap will have (2^bits)^3 entries.
 *  dist_buf:   An array of (2^bits)^3 long integers to be
 *          used as scratch space.
 * Outputs:
 *  rgbmap:     The output inverse colormap.  The entry
 *          rgbmap[(r<<(2*bits)) + (g<<bits) + b]
 *          is the colormap entry that is closest to the
 *          (quantized) color (r,g,b).
 * Assumptions:
 *  Quantization is performed by right shift (low order bits are
 *  truncated).  Thus, the distance to a quantized color is
 *  actually measured to the color at the center of the cell
 *  (i.e., to r+.5, g+.5, b+.5, if (r,g,b) is a quantized color).
 * Algorithm:
 *  Uses a "distance buffer" algorithm:
 *  The distance from each representative in the forward color map
 *  to each point in the rgb space is computed.  If it is less
 *  than the distance currently stored in dist_buf, then the
 *  corresponding entry in rgbmap is replaced with the current
 *  representative (and the dist_buf entry is replaced with the
 *  new distance).
 *
 *  The distance computation uses an efficient incremental formulation.
 *
 *  Distances are computed "outward" from each color.  If the
 *  colors are evenly distributed in color space, the expected
 *  number of cells visited for color I is N^3/I.
 *  Thus, the complexity of the algorithm is O(log(K) N^3),
 *  where K = colors, and N = 2^bits.
 */

/*
 * Here's the idea:  scan from the "center" of each cell "out"
 * until we hit the "edge" of the cell -- that is, the point
 * at which some other color is closer -- and stop.  In 1-D,
 * this is simple:
 *  for i := here to max do
 *      if closer then buffer[i] = this color
 *      else break
 *  repeat above loop with i := here-1 to min by -1
 *
 * In 2-D, it's trickier, because along a "scan-line", the
 * region might start "after" the "center" point.  A picture
 * might clarify:
 *       |    ...
 *               | ...  .
 *              ...     .
 *           ... |      .
 *          .    +      .
 *           .          .
 *            .         .
 *             .........
 *
 * The + marks the "center" of the above region.  On the top 2
 * lines, the region "begins" to the right of the "center".
 *
 * Thus, we need a loop like this:
 *  detect := false
 *  for i := here to max do
 *      if closer then
 *          buffer[..., i] := this color
 *          if !detect then
 *              here = i
 *              detect = true
 *      else
 *          if detect then
 *              break
 *              
 * Repeat the above loop with i := here-1 to min by -1.  Note that
 * the "detect" value should not be reinitialized.  If it was
 * "true", and center is not inside the cell, then none of the
 * cell lies to the left and this loop should exit
 * immediately.
 *
 * The outer loops are similar, except that the "closer" test
 * is replaced by a call to the "next in" loop; its "detect"
 * value serves as the test.  (No assignment to the buffer is
 * done, either.)
 *
 * Each time an outer loop starts, the "here", "min", and
 * "max" values of the next inner loop should be
 * re-initialized to the center of the cell, 0, and cube size,
 * respectively.  Otherwise, these values will carry over from
 * one "call" to the inner loop to the next.  This tracks the
 * edges of the cell and minimizes the number of
 * "unproductive" comparisons that must be made.
 *
 * Finally, the inner-most loop can have the "if !detect"
 * optimized out of it by splitting it into two loops: one
 * that finds the first color value on the scan line that is
 * in this cell, and a second that fills the cell until
 * another one is closer:
 *      if !detect then     {needed for "down" loop}
 *      for i := here to max do
 *      if closer then
 *          buffer[..., i] := this color
 *          detect := true
 *          break
 *  for i := i+1 to max do
 *      if closer then
 *          buffer[..., i] := this color
 *      else
 *          break
 *
 * In this implementation, each level will require the
 * following variables.  Variables labelled (l) are local to each
 * procedure.  The ? should be replaced with r, g, or b:
 *      cdist:          The distance at the starting point.
 *  ?center:    The value of this component of the color
 *      c?inc:          The initial increment at the ?center position.
 *  ?stride:    The amount to add to the buffer
 *          pointers (dp and rgbp) to get to the
 *          "next row".
 *  min(l):     The "low edge" of the cell, init to 0
 *  max(l):     The "high edge" of the cell, init to
 *          colormax-1
 *  detect(l):      True if this row has changed some
 *                  buffer entries.
 *      i(l):           The index for this row.
 *      ?xx:            The accumulated increment value.
 *      
 *      here(l):        The starting index for this color.  The
 *                      following variables are associated with here,
 *                      in the sense that they must be updated if here
 *                      is changed.
 *      ?dist:          The current distance for this level.  The
 *                      value of dist from the previous level (g or r,
 *                      for level b or g) initializes dist on this
 *                      level.  Thus gdist is associated with here(b)).
 *      ?inc:           The initial increment for the row.
 *
 *      ?dp:            Pointer into the distance buffer.  The value
 *                      from the previous level initializes this level.
 *      ?rgbp:          Pointer into the rgb buffer.  The value
 *                      from the previous level initializes this level.
 *
 * The blue and green levels modify 'here-associated' variables (dp,
 * rgbp, dist) on the green and red levels, respectively, when here is
 * changed.
 */

static int bcenter, gcenter, rcenter;
static long gdist, rdist, cdist;
static long cbinc, cginc, crinc;
static PDIST gdp;
static PDIST rdp;
static PDIST cdp;
static PIMAP grgbp;
static PIMAP rrgbp;
static PIMAP crgbp;
static int gstride, rstride;
static long x, xsqr, colormax;
static int cindex;

int redloop(void);
int greenloop( int restart );
int blueloop( int restart );
void maxfill( PDIST buffer, long side);

/* Track minimum and maximum. */
#define MINMAX_TRACK

void
inv_cmap(int colors, RGBX FAR *colormap, int bits,
        PDIST dist_buf, PIMAP rgbmap )
{
    int nbits = 8 - bits;

    colormax = 1 << bits;
    x = 1 << nbits;
    xsqr = 1 << (2 * nbits);

    /* Compute "strides" for accessing the arrays. */
    gstride = (int) colormax;
    rstride = (int) (colormax * colormax);

    maxfill( dist_buf, colormax );

    for ( cindex = 0; cindex < colors; cindex++ )
    {
    /*
     * Distance formula is
     * (red - map[0])^2 + (green - map[1])^2 + (blue - map[2])^2
     *
     * Because of quantization, we will measure from the center of
     * each quantized "cube", so blue distance is
     *  (blue + x/2 - map[2])^2,
     * where x = 2^(8 - bits).
     * The step size is x, so the blue increment is
     *  2*x*blue - 2*x*map[2] + 2*x^2
     *
     * Now, b in the code below is actually blue/x, so our
     * increment will be 2*(b*x^2 + x^2 - x*map[2]).  For
     * efficiency, we will maintain this quantity in a separate variable
     * that will be updated incrementally by adding 2*x^2 each time.
     */
    /* The initial position is the cell containing the colormap
     * entry.  We get this by quantizing the colormap values.
     */
        rcenter = colormap[cindex].r >> nbits;
        gcenter = colormap[cindex].g >> nbits;
        bcenter = colormap[cindex].b >> nbits;

        rdist = colormap[cindex].r - (rcenter * x + x/2);
        gdist = colormap[cindex].g - (gcenter * x + x/2);
        cdist = colormap[cindex].b - (bcenter * x + x/2);
    cdist = rdist*rdist + gdist*gdist + cdist*cdist;

        crinc = 2 * ((rcenter + 1) * xsqr - (colormap[cindex].r * x));
        cginc = 2 * ((gcenter + 1) * xsqr - (colormap[cindex].g * x));
        cbinc = 2 * ((bcenter + 1) * xsqr - (colormap[cindex].b * x));

    /* Array starting points. */
    cdp = dist_buf + rcenter * rstride + gcenter * gstride + bcenter;
    crgbp = rgbmap + rcenter * rstride + gcenter * gstride + bcenter;

    (void)redloop();
    }
}

/* redloop -- loop up and down from red center. */
int
redloop()
{
    int detect;
    int r, i = cindex;
    int first;
    long txsqr = xsqr + xsqr;
    static long rxx;

    detect = 0;

    /* Basic loop up. */
    for ( r = rcenter, rdist = cdist, rxx = crinc,
      rdp = cdp, rrgbp = crgbp, first = 1;
      r < (int) colormax;
      r++, rdp += rstride, rrgbp += rstride,
      rdist += rxx, rxx += txsqr, first = 0 )
    {
    if ( greenloop( first ) )
        detect = 1;
    else if ( detect )
        break;
    }

    /* Basic loop down. */
    for ( r = rcenter - 1, rxx = crinc - txsqr, rdist = cdist - rxx,
      rdp = cdp - rstride, rrgbp = crgbp - rstride, first = 1;
      r >= 0;
      r--, rdp -= rstride, rrgbp -= rstride,
      rxx -= txsqr, rdist -= rxx, first = 0 )
    {
    if ( greenloop( first ) )
        detect = 1;
    else if ( detect )
        break;
    }

    return detect;
}

/* greenloop -- loop up and down from green center. */
int
greenloop( int restart )
{
    int detect;
    int g, i = cindex;
    int first;
    long txsqr = xsqr + xsqr;
    static int here, min, max;
#ifdef MINMAX_TRACK
    static int prevmax, prevmin;
    int thismax, thismin;
#endif
    static long ginc, gxx, gcdist;     /* "gc" variables maintain correct */
    static PDIST gcdp;                 /*  values for bcenter position, */
    static PIMAP gcrgbp;               /*  despite modifications by blueloop */
                                       /*  to gdist, gdp, grgbp. */
    if ( restart )
    {
    here = gcenter;
    min = 0;
    max = (int) colormax - 1;
    ginc = cginc;
#ifdef MINMAX_TRACK
    prevmax = 0;
    prevmin = (int) colormax;
#endif
    }

#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif
    detect = 0;

    /* Basic loop up. */
    for ( g = here, gcdist = gdist = rdist, gxx = ginc,
      gcdp = gdp = rdp, gcrgbp = grgbp = rrgbp, first = 1;
      g <= max;
      g++, gdp += gstride, gcdp += gstride, grgbp += gstride, gcrgbp += gstride,
      gdist += gxx, gcdist += gxx, gxx += txsqr, first = 0 )
    {
    if ( blueloop( first ) )
    {
        if ( !detect )
        {
        /* Remember here and associated data! */
        if ( g > here )
        {
            here = g;
            rdp = gcdp;
            rrgbp = gcrgbp;
            rdist = gcdist;
            ginc = gxx;
#ifdef MINMAX_TRACK
            thismin = here;
#endif
        }
        detect = 1;
        }
    }
    else if ( detect )
    {
#ifdef MINMAX_TRACK
        thismax = g - 1;
#endif
        break;
    }
    }

    /* Basic loop down. */
    for ( g = here - 1, gxx = ginc - txsqr, gcdist = gdist = rdist - gxx,
      gcdp = gdp = rdp - gstride, gcrgbp = grgbp = rrgbp - gstride,
      first = 1;
      g >= min;
      g--, gdp -= gstride, gcdp -= gstride, grgbp -= gstride, gcrgbp -= gstride,
      gxx -= txsqr, gdist -= gxx, gcdist -= gxx, first = 0 )
    {
    if ( blueloop( first ) )
    {
        if ( !detect )
        {
        /* Remember here! */
        here = g;
        rdp = gcdp;
        rrgbp = gcrgbp;
        rdist = gcdist;
        ginc = gxx;
#ifdef MINMAX_TRACK
        thismax = here;
#endif
        detect = 1;
        }
    }
    else if ( detect )
    {
#ifdef MINMAX_TRACK
        thismin = g + 1;
#endif
        break;
    }
    }

#ifdef MINMAX_TRACK
    /* If we saw something, update the edge trackers.  For now, only
     * tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( detect )
    {
    if ( thismax < prevmax )
        max = thismax;

    prevmax = thismax;

    if ( thismin > prevmin )
        min = thismin;

    prevmin = thismin;
    }
#endif

    return detect;
}

/* blueloop -- loop up and down from blue center. */
int
blueloop( int restart )
{
    int detect;
    register PDIST dp;
    register PIMAP rgbp;
    register long bdist, bxx;
    register int b, i = cindex;
    register long txsqr = xsqr + xsqr;
    register int lim;
    static int here, min, max;
#ifdef MINMAX_TRACK
    static int prevmin, prevmax;
    int thismin, thismax;
#endif /* MINMAX_TRACK */
    static long binc;

    if ( restart )
    {
    here = bcenter;
    min = 0;
    max = (int) colormax - 1;
    binc = cbinc;
#ifdef MINMAX_TRACK
    prevmin = (int) colormax;
    prevmax = 0;
#endif /* MINMAX_TRACK */
    }

    detect = 0;
#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif

    /* Basic loop up. */
    /* First loop just finds first applicable cell. */
    for ( b = here, bdist = gdist, bxx = binc, dp = gdp, rgbp = grgbp, lim = max;
      b <= lim;
      b++, dp++, rgbp++,
      bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
    {
        /* Remember new 'here' and associated data! */
        if ( b > here )
        {
        here = b;
        gdp = dp;
        grgbp = rgbp;
        gdist = bdist;
        binc = bxx;
#ifdef MINMAX_TRACK
        thismin = here;
#endif
        }
        detect = 1;
        break;
    }
    }
    /* Second loop fills in a run of closer cells. */
    for ( ;
      b <= lim;
      b++, dp++, rgbp++,
      bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
    {
        *dp = bdist;
        *rgbp = (BYTE) i;
    }
    else
    {
#ifdef MINMAX_TRACK
        thismax = b - 1;
#endif
        break;
    }
    }

    /* Basic loop down. */
    /* Do initializations here, since the 'find' loop might not get
     * executed.
     */
    lim = min;
    b = here - 1;
    bxx = binc - txsqr;
    bdist = gdist - bxx;
    dp = gdp - 1;
    rgbp = grgbp - 1;
    /* The 'find' loop is executed only if we didn't already find
     * something.
     */
    if ( !detect )
    for ( ;
          b >= lim;
          b--, dp--, rgbp--,
          bxx -= txsqr, bdist -= bxx )
    {
            if ( *dp > (DWORD)bdist )
        {
        /* Remember here! */
        /* No test for b against here necessary because b <
         * here by definition.
         */
        here = b;
        gdp = dp;
        grgbp = rgbp;
        gdist = bdist;
        binc = bxx;
#ifdef MINMAX_TRACK
        thismax = here;
#endif
        detect = 1;
        break;
        }
    }
    /* The 'update' loop. */
    for ( ;
      b >= lim;
      b--, dp--, rgbp--,
      bxx -= txsqr, bdist -= bxx )
    {
        if ( *dp > (DWORD)bdist )
    {
        *dp = bdist;
        *rgbp = (BYTE) i;
    }
    else
    {
#ifdef MINMAX_TRACK
        thismin = b + 1;
#endif
        break;
    }
    }


    /* If we saw something, update the edge trackers. */
#ifdef MINMAX_TRACK
    if ( detect )
    {
    /* Only tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( thismax < prevmax )
        max = thismax;

    if ( thismin > prevmin )
        min = thismin;

    /* Remember the min and max values. */
    prevmax = thismax;
    prevmin = thismin;
    }
#endif /* MINMAX_TRACK */

    return detect;
}

void maxfill(PDIST buffer, long side)
{
    register unsigned long maxv = (unsigned long)~0L;
    register long i;
    register PDIST bp;

    for ( i = colormax * colormax * colormax, bp = buffer;
      i > 0;
      i--, bp++ )
    *bp = maxv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\lfntobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: lfntobj.cxx
*
* Non-inline methods for logical font objects.
*
* Created: 30-Oct-1990 09:32:48
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "winsta.h"

extern PW32PROCESS gpidSpool;

extern "C" USHORT gProtocolType;
#define IsRemoteConnection() (gProtocolType != PROTOCOL_CONSOLE)

/******************************Public*Routine******************************\
* GreSetLFONTOwner
*
* Set the owner of the LFONT
*
\**************************************************************************/

BOOL
GreSetLFONTOwner(
    HLFONT hlfnt,
    W32PID  lPid)
{
    if (lPid == OBJECT_OWNER_CURRENT)
    {
        lPid = W32GetCurrentPID();
    }

    return(HmgSetOwner((HOBJ)hlfnt, lPid, LFONT_TYPE));
}

/******************************Public*Routine******************************\
* LFONTOBJ::LFONTOBJ (HLFONT hlfnt, PDEVOBJ * ppdo)
*
* Constructor for a logical font user object.
*
* This constructor is a little trickier than most because the handle coming
* in may reference one of the "aliased" stock fonts.  These stock fonts, rather
* than representing a single "wish list" of attributes, represent a set of
* such lists.  Which member of the set is being referenced is determined by
* the calling application's default display or PDEV (i.e., we ask the PDEV
* for the real HLFONT handle).
*
* The strategy is the constructor locks the handle passed in and checks the
* type.  If its not an aliased LFONT, then we're done.  If it is an aliased
* font, the aliased HLFONT handle is released and a PDEVOBJ is queried for
* the appropriate HFLONT handle to lock.
*
* History:
*  Thu 23-Sep-1993 -by- Patrick Haluptzok [patrickh]
* SSS
*
*  30-Oct-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LFONTOBJ::LFONTOBJ (HLFONT hlfnt, PDEVOBJ* ppdo)
{
    plfnt = (PLFONT) HmgShareLock((HOBJ)hlfnt, LFONT_TYPE);

    //
    // Check for aliased LFONT.
    //

    if ((plfnt != NULL) && (plfnt->fl & LF_FLAG_ALIASED))
    {
        HDEV hDev = UserGetHDEV();

        //
        // This is an aliased font.  Save type.
        //

        LFTYPE lftSave = plfnt->lft;

        // Release the aliased LFONT.

        DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(plfnt);

        plfnt = NULL;

        PDEVOBJ pdo(hDev);

        if (!ppdo)
        {
            ppdo = &pdo;
        }

        if (ppdo->bValid())
        {
            //
            // Grab appropriate HLFONT from the PDEV.
            //

            switch (lftSave)
            {

            case LF_TYPE_DEVICE_DEFAULT:
                hlfnt = ppdo->hlfntDefault();
                break;

            case LF_TYPE_ANSI_FIXED:
                hlfnt = ppdo->hlfntAnsiFixed();
                break;

            case LF_TYPE_ANSI_VARIABLE:
                hlfnt = ppdo->hlfntAnsiVariable();
                break;

            default:
                RIP("LFONTOBJ has invalid type for aliased font");
            }

            plfnt = (PLFONT) HmgShareLock((HOBJ)hlfnt, LFONT_TYPE);
        }
    }
}

/******************************Public*Routine******************************\
* LFONTOBJ::ppfeMapFont
*
* Note:
*   RFONTOBJ constructor, which is the only function (so far) to call
*   this, grabs the ghsemPublicPFT semaphore prior to calling this to
*   make PFT tree stable before scanning it during mapping.
*
* Returns:
*   Handle to a realized font (HRFONT) that is a close or exact match to
*   this logical font.  HRFONT_INVALID returned if an error occurs.
*
* History:
*  24-Sept-1996  -by-  Xudong Wu  [TessieW]
* If a suitable pfe found in map cache, we still need to check whether the
* current process has the right to map the font.
*
*  11-Dec-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFE *LFONTOBJ::ppfeMapFont (
    XDCOBJ& dco,
    FLONG  *pflSim,
    POINTL *pptlSim,
    FLONG  *pflAboutMatch,
    BOOL    bIndexFont
    )
{
    int i; // index into mapcache array
    MAPCACHE*  mapcache = plfnt->mapcache;
    PFE*           ppfe = PPFENULL;  // return value
    MATRIX&        matrix = dco.pdc->mxWorldToDevice();
    HDEV           hdev = dco.hdev();
    ULONG iBitmapFormat = 0;    // important in anti-aliased case
    FLONG        flGray = 0;

    #if DBG
    if (gflFontDebug & DEBUG_PPFEMAPFONT)
    {
        KdPrint(("Font Mapping: \"%ws\" hlfnt = %p hdc = %p\n",plfnt->wcCapFacename, hlfnt(),dco.hdc()));
        KdBreakPoint();
    }
    #endif


// If we are in a path bracket, we never look in the map cache (the mapping
// is also never put in the cache).  We'll just run the font mapper.  We
// could cache path bracketed font mappings, but we would have to add a flag
// or type to the MAPCACHE structure and add an extra comparison inside the
// mapcache scanning loop.  Since we currently consider text in paths to be
// the exception rather than the rule, we have decided not eat the cost of
// of the extra compare in the pathological case rather than in the common
// case.

    if (!dco.pdc->bActive())
    {
        // If anitaliasing is requested and possible then set FO_GRAY16 in flGray

        BYTE jQual = plfw()->lfQuality;
        if (dco.bDisplay() || dco.dctp() == DCTYPE_MEMORY)
        {
            if
            (
                ((gulFontInformation & FE_AA_ON) && jQual != NONANTIALIASED_QUALITY) ||
                (jQual == ANTIALIASED_QUALITY) || (jQual == CLEARTYPE_QUALITY) || (jQual == CLEARTYPE_NATURAL_QUALITY)
            )
            {
		// WINBUG 152724 07/31/2000 claudebe
		// Terminal server now allow more than 256 colors. Text antialiazing rendered on the server is very slow.
		// We decided for Whistler to turn off text antialiazing under terminal client session.
		// For Blackcomb we will provide the terminal server team with a text antialiazing library that they can use on the 				// client to generate text antialiazing on the client.
 
                if  (!IsRemoteConnection() && (dco.pdc->bHasSurface()))
                {
                    // Acquire the handle manager lock while we look at the
                    // surface to protect against dynamic mode changing.

                    MLOCKFAST mo;

                    switch ( iBitmapFormat = dco.pdc->pSurface()->so.iBitmapFormat )
                    {
                    case BMF_16BPP:
                    case BMF_24BPP:
                    case BMF_32BPP:

                        flGray = FO_GRAY16; // request antialiased font
                        if ( jQual == CLEARTYPE_NATURAL_QUALITY )
                            flGray |= FO_CLEARTYPENATURAL_X | FO_CLEARTYPE_X;
                        else if ((jQual == CLEARTYPE_QUALITY) || (gulFontInformation & FE_CT_ON))
                            flGray |= FO_CLEARTYPE_X;

                        break;

                    default:

                        break;
                    }
                }
            }
        }

        // Scan the map cache for a suitable mapping.
        // Skip the cache if it is glyph index.

        if (!bIndexFont)
        {
            for ( i = 0; i < plfnt->cMapsInCache; i += 1)
            {
            // For a mapping to be suitable, the device must match AND
            // the transforms (neglecting translation) must match.
            // There are more restrictions for antialiased text (see below)

                if ( (hdev == mapcache[i].hdev)          &&
                     (mapcache[i].efM11 == matrix.efM11) &&
                     (mapcache[i].efM12 == matrix.efM12) &&
                     (mapcache[i].efM21 == matrix.efM21) &&
                     (mapcache[i].efM22 == matrix.efM22)
                   )
                {
                   // We found it.  Check that it's still valid.

                    HPFECOBJ pfecobj(mapcache[i].hpfec);
                    PFEOBJ pfeo(pfecobj.GetPFE(mapcache[i].iFont));
                    if ( !pfeo.bValid() )
                    {
                        WARNING1("Invalid ppfe in mapping cache\n");
                    }
                    else
                    {
                        // The cached notional to device transform is unchanged.
                        // The cached mapping is good if:
                        //
                        //
                        // A. the application is requesting antialiased text and
                        // the cached text was also requested to be antialiased
                        // Moreover, in the antialiased case, the bitmap format
                        // must be the same.

                        //                       or
                        //
                        // B. the application is not requesting antialiasing
                        // and the cached text was not requested to be antialiased

                        // Need to check whether the current process has the right
                        // to mapping the font.

                        if (pfeo.bEmbPvtOk() || (gpidSpool == (PW32PROCESS)W32GetCurrentProcess()))
                        {
                            if ( flGray )   // requesting antialiased text?
                            {   // yes
                                if ((mapcache[i].flSim & (FO_GRAY16 | FO_CLEARTYPE_X)) == flGray)
                                {   // yes
                                    if (iBitmapFormat == mapcache[i].iBitmapFormat) // same format?
                                    {   // yes
                                        ppfe = pfeo.ppfeGet();      // cached mapping is good
                                    }
                                }
                            }
                            else if ( !(mapcache[i].flSim & FO_GRAY16) )
                            {
                                ppfe = pfeo.ppfeGet();
                            }
                        }
                    }
                    if ( ppfe ) // cached mapping good?
                    {   // yes -- update simulation flags
                        *pflSim        = mapcache[i].flSim;
                        pptlSim->x     = mapcache[i].ptlSim.x;
                        pptlSim->y     = mapcache[i].ptlSim.y;
                        *pflAboutMatch = mapcache[i].flAboutMatch;
                        break;
                    }
                    else
                    {   // cached mapping is not good
                        // Remove the mapping so we don't run into it again.

                        if ( (i+1) < plfnt->cMapsInCache )
                        {
                            RtlMoveMemory
                            (
                                (PVOID) &mapcache[i],
                                (PVOID) &mapcache[i+1],
                                (UINT) (((PBYTE) &mapcache[plfnt->cMapsInCache]) - ((PBYTE) &mapcache[i+1]))
                            );
                        }

                        plfnt->cMapsInCache -= 1;   // correct the map count

                        // current position is no longer a rejected candidate,
                        // so go back one index

                        i -= 1;
                    }
                }
            }
        }
    }
    if ( !ppfe )
    {
        // Call the font mapper with the Win 3.1 compatible weighting and max
        // penalties.  If the LOGFONT is a stock object, transforms are ignored
        // (i.e., the LOGFONT is implied to be in pixel coordinates (MM_TEXT)).
        //
        // The result is stuffed into the map cache if we are not in a
        // path bracket.
        //
        // Note. ppfeGetAMatch() modifies sets FO_SIM_BOLD and FO_SIM_ITALIC
        //       in *pflSim as is necessary -- it does not set FO_GRAY16
        //       which is set in this routine after this call.

        ppfe = ppfeGetAMatch(
                   dco,
                   pelfw(),
                   plfnt->wcCapFacename,
                   ULONG_MAX-1,
                   (plfnt->fl & LF_FLAG_STOCK) ? FM_BIT_PIXEL_COORD : 0,
                   pflSim,
                   pptlSim,
                   pflAboutMatch,
                   bIndexFont
               );
        PFEOBJ pfeo(ppfe);
        if ( !pfeo.bValid() )
        {
            RIP("Bad return value from ppfeGetAMatch\n");
        }
        else if (!dco.pdc->bActive())
        {
            ASSERTGDI( !(*pflSim & FO_GRAY16), "ppfeGetAMatch erroneously set FO_GRAY16\n");

            // If the application is requesting antialiased text and the font is
            // capable then we set the FO_GRAY16 bit in *pflSim. Note that this
            // does not guarantee that the font driver will antialiase the text
            // only that GDI will suggest to the font driver that the font
            // be antialiased.

            if (flGray && (pfeo.pifi()->flInfo & FM_INFO_4BPP))
            {
                *pflSim |= FO_GRAY16;

                if
                (
                //  (dco.flGraphicsCaps2() & GCAPS2_CLEARTYPE_X) && // commented out only for now
                    (dco.bDisplay() || (dco.dctp() == DCTYPE_MEMORY)) &&
                    dco.pdc->bHasSurface()                            &&
                    (pfeo.pifi()->flInfo & FM_INFO_TECH_TRUETYPE)     && // to be removed if ps fonts start supporting ClearType
                    (pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality != ANTIALIASED_QUALITY) &&
                    ((pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality == CLEARTYPE_QUALITY) || 
                     (pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality == CLEARTYPE_NATURAL_QUALITY) || 
					 ((gulFontInformation & FE_CT_ON) && (gulFontInformation & FE_AA_ON)))
                )
                {
                	if(pelfw()->elfEnumLogfontEx.elfLogFont.lfQuality == CLEARTYPE_NATURAL_QUALITY)
                    	*pflSim |= FO_CLEARTYPENATURAL_X | FO_CLEARTYPE_X;
                	else
                    	*pflSim |= FO_CLEARTYPE_X;
                }
            }

            // Not in cache, so do the map and put it in the cache
            // if it is not glyph index.

            if (!bIndexFont)
            {
                // Check to see if we are past the max. number of cached mappings.
                // If the limit is exceeded, flush the cache by resetting the
                // the count.

                if (i >= MAXCACHEENTRIES)
                {
                    i = plfnt->cMapsInCache = 0;
                }

                // Update cache information for the new mapping.

                mapcache[i].hpfec         = pfeo.hpfecGet();
                mapcache[i].iFont         = pfeo.iFont();
                mapcache[i].hdev          = hdev;
                mapcache[i].flSim         = *pflSim;
                mapcache[i].ptlSim.x      = pptlSim->x;
                mapcache[i].ptlSim.y      = pptlSim->y;
                mapcache[i].efM11         = matrix.efM11;
                mapcache[i].efM12         = matrix.efM12;
                mapcache[i].efM21         = matrix.efM21;
                mapcache[i].efM22         = matrix.efM22;
                mapcache[i].flAboutMatch  = *pflAboutMatch;
                mapcache[i].iBitmapFormat = iBitmapFormat;
                plfnt->cMapsInCache      += 1;
            }
        }
    }

// if successfull, update the charset and code page info in the dc:

    if (ppfe)
    {
    // new font mapping may have occurred as a result of w->d xform change,
    // GraphicsMode change. Also when this routine is called from
    // RFONTOBJ::bInit, the new mapping may have occured as a result of
    // asking for pathobj instead of bitmap realization. In other words
    // It is not necessary at this point to have DIRTY_CHARSET bit set,
    // (which only happens when a new logfont is selected in the DC).
    // Any of these factors could cause the change of the font selected
    // in the dc and therefore also of the corresponding CodePage i.e. CharSet.

    #if 0
        if (!(dco.ulDirty() & DIRTY_CHARSET))
        {
            if (dco.pdc->iCS_CP() != (*pflAboutMatch >> 8))
            {
                DbgPrint("ppfe: 0x%p, iCS_CP: 0x%lx, flAboutMatch: 0x%p\n",
                          ppfe, dco.pdc->iCS_CP(), *pflAboutMatch);
                RIP("ppfeMapFont, dco.pdc->iCS_CP is bogus\n");
            }
        }
    #endif

#ifdef FE_SB

    // If font association is turned on for this character set then we need
    // to force the code page to ANSI so that ANSI apps can get a the DBCS
    // in the font via ANSI api's.  We do this unless the user has set the
    // override bit in the LOGFONT.

        if(fFontAssocStatus &&
           !(plfw()->lfClipPrecision & CLIP_DFA_DISABLE))
        {
            UINT Charset = (*pflAboutMatch >> 24) & 0xFF;

            if((Charset == ANSI_CHARSET && fFontAssocStatus & ANSI_ASSOC) ||
               (Charset == OEM_CHARSET && fFontAssocStatus & OEM_ASSOC))

            //   (Charset == OEM_CHARSET && fFontAssocStatus & OEM_ASSOC)   ||
            //  we might want to keep the codepage as CP_SYMBOL??????
            //  (Charset == SYMBOL_CHARSET && fFontAssocStatus & SYMBOL_ASSOC))

            {
                USHORT AnsiCodePage, OemCodePage;
                RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

                *pflAboutMatch = (*pflAboutMatch & 0xFF0000FF) | (AnsiCodePage << 8);

            }
        }
#endif

        dco.pdc->iCS_CP(*pflAboutMatch >> 8);

    // clean the DIRTY_CHARSET bit

        dco.ulDirtySub(DIRTY_CHARSET);
    }

    return (ppfe);
}

#if DBG
/******************************Public*Routine******************************\
* VOID LFONTOBJ::vDump ()
*
* Debugging code.
*
* History:
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID LFONTOBJ::vDump ()
{
    DbgPrint("\nContents of LFONT, HLFONT = 0x%lx\n", hlfnt());

    if (hlfnt() == STOCKOBJ_SYSFONT)
        DbgPrint("S Y S T E M   F O N T \n");
    if (hlfnt() == STOCKOBJ_SYSFIXEDFONT)
        DbgPrint("S Y S T E M   F I X E D   F O  N T \n");
    if (hlfnt() == STOCKOBJ_OEMFIXEDFONT)
        DbgPrint("O E M   F I X E D   F O N T \n");
    if (hlfnt() == STOCKOBJ_DEFAULTDEVFONT)
        DbgPrint("D E V I C E   D E F A U L T   F O N T \n");
    if (hlfnt() == STOCKOBJ_ANSIFIXEDFONT)
        DbgPrint("A N S I   F I X E D   F O N T \n");
    if (hlfnt() == STOCKOBJ_ANSIVARFONT)
        DbgPrint("A N S I   V A R I A B L E   F O N T \n");
    if (hlfnt() == STOCKOBJ_DEFAULTGUIFONT)
        DbgPrint("D E F A U L T   G U I   F O N T \n");

    DbgPrint("LOGFONT \n");
    DbgPrint("    lfHeight   = %d\n", plfnt->elfw.elfLogFont.lfHeight);
    DbgPrint("    lfWidth    = %d\n", plfnt->elfw.elfLogFont.lfWidth);
    DbgPrint("    lfFaceName = %ws\n", plfnt->elfw.elfLogFont.lfFaceName);
    DbgPrint("\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\init.cxx ===
/******************************Module*Header*******************************\
* Module Name: init.cxx
*
* Engine initialization
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "verifier.hxx"
#include "winsta.h"

extern "C" USHORT gProtocolType;


BOOLEAN gIsTerminalServer;

extern BOOL         G_fConsole;
extern BOOL         G_fDoubleDpi;


extern "C" BOOL bInitPALOBJ();         // palobj.cxx
extern "C" VOID vInitXLATE();          // ylateobj.cxx
extern "C" BOOL bInitBMOBJ();          // surfeng.cxx
extern "C" BOOL InitializeScripts();   // fontsup.cxx
extern "C" BOOL bInitICM();            // icmapi.cxx
extern "C" BOOL bInitFontTables();     // pftobj.cxx
extern "C" BOOL bInitStockFonts(VOID); // stockfnt.cxx
extern "C" VOID vInitFontSubTable();   // fontsub.cxx
extern "C" BOOL bInitBRUSHOBJ();       // brushobj.cxx
extern "C" VOID vInitMapper();         // fontmap.cxx

extern USHORT GetLanguageID();


// Prototypes from font drivers.

extern "C" BOOL BmfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" BOOL ttfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" BOOL vtfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" BOOL atmfdEnableDriver(ULONG iEngineVersion,ULONG cj, PDRVENABLEDATA pded);

extern "C" NTSTATUS FontDriverQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);

extern "C" BOOL bRegisterFontServer(VOID);
extern "C" BOOL bUserModeFontDrivers(VOID);

#ifdef LANGPACK
extern "C" NTSTATUS LpkShapeQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);
#endif

//
// Prototypes from halftone
//

extern "C" BOOL PASCAL EnableHalftone(VOID);
extern "C" VOID PASCAL DisableHalftone(VOID);

//
// Hydra prototypes
//
extern "C" BOOL MultiUserGreCleanupInit();
extern "C" BOOL GreEngLoadModuleTrackInit();

//
// Functions are located in INIT segment
//
#pragma alloc_text(INIT, InitializeGre)
#pragma alloc_text(INIT, FontDriverQueryRoutine)
#ifdef LANGPACK
#pragma alloc_text(INIT, LpkShapeQueryRoutine)
#endif
#pragma alloc_text(INIT, bLoadProcessHandleQuota)
#pragma alloc_text(INIT, bRegisterFontServer)

/**************************************************************************\
 *
\**************************************************************************/

#if defined(i386) && !defined(_GDIPLUS_)
extern "C" PVOID GDIpLockPrefixTable;
extern "C" PVOID __safe_se_handler_table[]; /* base of safe handler entry table */
extern "C" BYTE  __safe_se_handler_count;   /* absolute symbol whose address is
                                           the count of table entries */

//
// Specify address of kernel32 lock prefixes
//
extern "C" IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    sizeof(_load_config_used),  // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    0,                          // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    (ULONG) &GDIpLockPrefixTable,  // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0,         // Reserved
    0,                          // & security_cookie
    (ULONG)__safe_se_handler_table,
    (ULONG)&__safe_se_handler_count
    };
#endif

LONG gProcessHandleQuota;

#if defined (_X86_)
    BOOL gbMMXProcessor = FALSE;
#endif

extern "C" VOID vConvertCodePageToCharSet(WORD src, DWORD *pfsRet, BYTE *pjRet);

VOID vGetJpn98FixPitch();

/******************************Public*Routine******************************\
* bEnableFontDriver
*
* Enables an internal, statically-linked font driver.
*
\**************************************************************************/

BOOL bEnableFontDriver(PFN pfnFdEnable, ULONG fl)
{
    //
    // Load driver.
    //

    PLDEV pldev;

    pldev = ldevLoadInternal(pfnFdEnable, LDEV_FONT);

    //
    // Validate the new LDEV
    //

    if (pldev)
    {
        //
        // Create the PDEV for this (the PDEV won't have anything in it
        // except the dispatch table.
        //

        PDEVOBJ po(pldev,
                   NULL,                // PDEVMODEW pdriv,
                   NULL,                // PWSZ pwszLogAddr,
                   NULL,                // PWSZ pwszDataFile,
                   NULL,                // PWSZ pwszDeviceName,
                   NULL,                // HANDLE hSpool,
                   NULL                 // PREMOTETYPEONENODE pRemoteTypeOne,
                   );

        if (po.bValid())
        {
            //
            // Was it the TrueType driver?  We need to keep a global handle to
            // it to support the Win 3.1 TrueType-specific calls.
            //

            if (fl & FNT_TT_DRV )
            {
                gppdevTrueType = (PPDEV) po.hdev();
            }

            if (fl & FNT_OT_DRV)
            {
                gppdevATMFD = (PPDEV) po.hdev();
                gufiLocalType1Rasterizer.CheckSum = TYPE1_RASTERIZER;
                gufiLocalType1Rasterizer.Index = 0x1;
            }

            FntCacheHDEV((PPDEV) po.hdev(), fl);

            po.ppdev->fl |= PDEV_FONTDRIVER;
            
            return(TRUE);
        }
    }

    WARNING("bLoadFontDriver failed\n");
    return(FALSE);
}

/******************************Public*Routine******************************\
* bDoubleDpi
*
* Read the registry to determine if we should implement our double-the-DPI
* hack.  This functionality was intended as a simple mechanism for the
* release of Windows 2000 for applications developers to test their 
* applications for conformance with upcoming high-DPI (200 DPI) displays.
* The problem is that currently only 75 to 100 DPI displays are available,
* but we know the high DPI displays are coming soon.
*
* So we implement this little hack that doubles the effective resolution
* of the monitor, and down-samples to the display.  So if your monitor does
* 1024x768, we make the system think it's really 2048x1536.
*
* Hopefully, this hacky functionality can be removed for the release after
* Windows 2000, as it's fairly unusable for anything other than simple
* test purposes.
*
\**************************************************************************/

BOOL bDoubleDpi(BOOL fConsole)
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;
    DWORD                       dwDoubleDpi;

    dwDoubleDpi = 0;

    ///For this to success, it must be console session(session 0)
    ///Connected locally to physical console.
    
    if (fConsole && (gProtocolType == PROTOCOL_CONSOLE))
    {
        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                             L"Control\\GraphicsDrivers");
    
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
    
        status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);
    
        if (NT_SUCCESS(status))
        {
            RtlInitUnicodeString(&UnicodeString, L"DoubleDpi");
    
            Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"DoubleDpi") +
                     sizeof(DWORD);
    
            Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, ' ddG');
    
            if (Information)
            {
                status = ZwQueryValueKey(hkRegistry,
                                           &UnicodeString,
                                           KeyValueFullInformation,
                                           Information,
                                           Length,
                                           &Length);
    
                if (NT_SUCCESS(status))
                {
                    dwDoubleDpi = *(LPDWORD) ((((PUCHAR)Information) +
                                    Information->DataOffset));
                }
    
                VFREEMEM(Information);
            }
    
            ZwCloseKey(hkRegistry);
        }
    }

    return(dwDoubleDpi == 1);
}

void vCheckTimeZoneBias()
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\TimeZoneInformation");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, L"ActiveTimeBias");

        Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"ActiveTimeBias") +
                 sizeof(DWORD);

        Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, 'pmtG');

        if (Information)
        {
            status = ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length);

            if (!NT_SUCCESS(status))
            {
                gbGUISetup = TRUE;
            }

            VFREEMEM(Information);
        }

        ZwCloseKey(hkRegistry);
    }
    else
    {
        gbGUISetup = TRUE;
    }
}

/******************************Public*Routine******************************\
* InitializeGreCSRSS
*
* Initialize the client-server subsystem portion of GDI. 
*
\**************************************************************************/

extern "C" BOOL InitializeGreCSRSS()
{

    // Init DirectX graphics driver

    if (!NT_SUCCESS(DxDdStartupDxGraphics(0,NULL,0,NULL,NULL,gpepCSRSS)))
    {
        WARNING("GRE: could not enable DirectDraw\n");
        return(FALSE);
    }

    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    USHORT AnsiCodePage, OemCodePage;

    // Init the font drivers

    gppdevTrueType = NULL;
    gppdevATMFD = NULL;
    gcTrueTypeFonts = 0;
    gulFontInformation = 0;
    gusLanguageID = GetLanguageID();

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

    vConvertCodePageToCharSet(
        AnsiCodePage,
        &gfsCurSignature,
        &gjCurCharset);

    gbDBCSCodePage = (IS_ANY_DBCS_CODEPAGE(AnsiCodePage)) ? TRUE : FALSE;

    InitFNTCache();

    vCheckTimeZoneBias();

    //
    // NOTE: we are disabling ATM and vector font drivers for _GDIPLUS_ work
    //

    #ifndef _GDIPLUS_

    QueryTable[0].QueryRoutine = FontDriverQueryRoutine;
    QueryTable[0].Flags = 0; // RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = (PWSTR)NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    // Enumerate and initialize all the font drivers.

    RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT | RTL_REGISTRY_OPTIONAL,
                           (PWSTR)L"Font Drivers",
                           &QueryTable[0],
                           NULL,
                           NULL);

    if (!bEnableFontDriver((PFN) atmfdEnableDriver, FNT_OT_DRV))
    {
        WARNING("GDISRV.DLL could not enable ATMFD stub\n");
    	return(FALSE);
    }
    
    // also creates ghsemVTFD semaphore
    if (!bEnableFontDriver((PFN) vtfdEnableDriver, FNT_VT_DRV))
    {
        WARNING("GDISRV.DLL could not enable VTFD\n");
        return(FALSE);
    }

    #endif // !_GDIPLUS_

    // We need to get the fix pitch registry first
    // This is only JPN platform
    vGetJpn98FixPitch();

	// also creates ghsemBMFD semaphore
    if (!bEnableFontDriver((PFN) BmfdEnableDriver, FNT_BMP_DRV))
    {
        WARNING("GDISRV failed to enable BMFD\n");
        return(FALSE);
    }

    if (!bEnableFontDriver((PFN) ttfdEnableDriver, FNT_TT_DRV))
    {
        WARNING("GDISRV.DLL could not enable TTFD\n");
        return(FALSE);
    }
    //
    // Init global public PFT
    //

    if (!bInitFontTables())
    {
        WARNING("Could not start the global font tables\n");
        return(FALSE);
    }

    //
    // Initialize LFONT
    //

    TRACE_FONT(("GRE: Initializing Stock Fonts\n"));

    if (!bInitStockFonts())
    {
        WARNING("Stock font initialization failed\n");
        return(FALSE);
    }

    TRACE_FONT(("GRE: Initializing Font Substitution\n"));

    // Init font substitution table

    vInitFontSubTable();

    // Load default face names for the mapper from the registry

    vInitMapper();

    if (!bInitializeEUDC())
    {
        WARNING("EUDC initialization failed\n");
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* InitializeGre
*
* Initialize the Graphics Engine.  This call is made once by USER.
*
* History:
*  Thu 29-Oct-1992 -by- Patrick Haluptzok [patrickh]
* Remove wrappers, unnecesary semaphore use, bogus variables, cleanup.
*
*  10-Aug-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

LONG CountInit = 1;

extern "C" BOOL gbRemoteSession; // as in ntuser\kernel\globals.c

extern "C" BOOLEAN InitializeGre(
    VOID)
{
#ifdef LANGPACK
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
#endif

    G_fConsole = (BOOL)!gbRemoteSession;

    G_fDoubleDpi = bDoubleDpi(G_fConsole);

    //
    // We only want to initialize once.  We can detect transition to 0.
    //

    if (InterlockedDecrement(&CountInit) != 0)
    {
        return(TRUE);
    }

#if defined(_GDIPLUS_)
    gIsTerminalServer = FALSE;
#else
    gIsTerminalServer = !!(SharedUserData->SuiteMask & (1 << TerminalServer));
#endif

    if (!MultiUserGreCleanupInit())
        {
            WARNING("InitializeGre: failed to initialize cleanup support\n");
            return(FALSE);
        }

    //
    // Initialize the GRE DriverVerifier support (see verifier.cxx).
    //

    VerifierInitialization();

    //
    // Note that GreEngLoadModuleTrackInit must be called AFTER gIsTerminalServer is set
    // (though it's called regardless of its value), so that the memory allocations will
    // be placed on the hydra tracking list if necessary.

    if (!GreEngLoadModuleTrackInit())
    {
        WARNING("InitializeGre: failed to initialize EngLoadModule tracking\n");
        return(FALSE);
    }

#if TRACE_SURFACE_ALLOCS
    //
    // Initialize SURFACE tracing if requested in registry
    //

    TRACED_SURFACE::vInit();
#endif

    //
    // load registry process quota information
    //


    bLoadProcessHandleQuota();

    //
    // Initialize lots of random stuff including the handle manager.
    //

    if (!HmgCreate())
    {
        WARNING("HMGR failed to initialize\n");
        return(FALSE);
    }

    //
    // Initialize REGION time stamp
    //

    REGION::ulUniqueREGION = 1;

    #if DBG_CORE
        if ((ghsemDEBUG = GreCreateSemaphore())==NULL)
        {
            WARNING("win32k: unable to initialize ghsemDEBUG\n");
            return(FALSE);
        }
    #endif

    #if defined(USE_NINEGRID_STATIC)
        if ((gNineGridSem = GreCreateSemaphore())==NULL)
        {
            WARNING("Win32k: unable to initialize gNineGridSem\n");
            return(FALSE);
        }
    #endif
    
    //
    // Create the LDEV\PDEV semaphore.
    //

    if ((ghsemDriverMgmt = GreCreateSemaphore()) == NULL)
    {
        WARNING("win32k: unable to create driver mgmt semaphore\n");
        return(FALSE);
    }

    //
    // Init the font drivers
    //

    if (!bInitPathAlloc())
    {
        WARNING("Pathalloc Initialization failed\n");
        return(FALSE);
    }

    // Create the RFONT list semaphore.

    ghsemRFONTList = GreCreateSemaphore();
    if (ghsemRFONTList == NULL)
    {
        WARNING("win32k: unable to create ghsemRFONTList\n");
        return FALSE;
    }

    ghsemCLISERV = GreCreateSemaphore();
    if (ghsemCLISERV == NULL)
    {
        WARNING("win32k: unabel to create ghsemCLISERV\n");
        return( FALSE );
    }

    if ((ghsemAtmfdInit = GreCreateSemaphore()) == NULL)
    {
        WARNING("win32k: unable to create driver mgmt semaphore\n");
        return(FALSE);
    }

    // Create the WNDOBJ semaphore.

    ghsemWndobj = GreCreateSemaphore();
    if (ghsemWndobj == NULL)
    {
        WARNING("win32k: unable to create ghsemWndobj\n");
        return FALSE;
    }

    // Create the RFONT list semaphore.

    ghsemGdiSpool = GreCreateSemaphore();
    if(ghsemGdiSpool == NULL)
    {
      WARNING("win32k: unable to create ghsemGdiSpool\n");
      return FALSE;
    }

    // Create the mode change semaphore.

    if ((ghsemShareDevLock = GreCreateSemaphore()) == NULL)
    {
        WARNING("win32k: unable to create mode change semaphore\n");
        return(FALSE);
    }

    // Create the association list mutex.

    if ((gAssociationListMutex = GreCreateFastMutex()) == NULL)
    {
        WARNING("win32k: unable to create association list mutex\n");
        return(FALSE);
    }

    // Create a null region as the default region


    hrgnDefault = GreCreateRectRgn(0, 0, 0, 0);
    if (hrgnDefault == (HRGN) 0)
    {
        WARNING("hrgnDefault failed to initialize\n");
        return(FALSE);
    }

    {
        RGNOBJAPI ro(hrgnDefault,TRUE);
        if(!ro.bValid()) {
          WARNING("invalid hrgnDefault\n");
          return FALSE;
        }

        prgnDefault = ro.prgnGet();
    }

    // Create a monochrome 1x1 bitmap as the default bitmap


    if (!bInitPALOBJ())
    {
        WARNING("bInitPALOBJ failed !\n");
        return(FALSE);
    }

    vInitXLATE();

    if (!bInitBMOBJ())
    {
        WARNING("bInitBMOBJ failed !\n");
        return(FALSE);
    }

    // initialize the script names

    if(!InitializeScripts())
    {
        WARNING("Could not initialize the script names\n");
        return(FALSE);
    }

    //
    // Start up the brush component
    //

    if (!bInitBRUSHOBJ())
    {
        WARNING("Could not init the brushes\n");
        return(FALSE);
    }

    if (!bInitICM())
    {
        WARNING("Could not init ICM\n");
        return(FALSE);
    }

    //
    // Enable statically linked halftone library
    //

    if (!EnableHalftone())
    {
        WARNING("GRE: could not enable halftone\n");
        return(FALSE);
    }

    //
    // determine if processor supports MMX
    //

    #if defined (_X86_)

        gbMMXProcessor = bIsMMXProcessor();

    #endif

    TRACE_INIT(("GRE: Completed Initialization\n"));

    #ifdef _GDIPLUS_

    gpepCSRSS = PsGetCurrentProcess();
    InitializeGreCSRSS();

    #endif

#ifdef LANGPACK
    QueryTable[0].QueryRoutine = LpkShapeQueryRoutine;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = (PWSTR)NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;
    
    gpGdiSharedMemory->dwLpkShapingDLLs = 0;

    RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT | RTL_REGISTRY_OPTIONAL,
                           (PWSTR)L"LanguagePack",
                           &QueryTable[0],
                           NULL,
                           NULL);
#endif

    gpGdiSharedMemory->timeStamp = 1;

    return(TRUE);
}

extern "C" BOOL TellGdiToGetReady()
{
    ASSERTGDI(gpepCSRSS, "gpepCSRSS\n");

    return InitializeGreCSRSS();
}

#ifdef LANGPACK
extern "C"
NTSTATUS
LpkShapeQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    if( ValueType == REG_DWORD ) {
        gpGdiSharedMemory->dwLpkShapingDLLs |= (1<<(*((DWORD*)ValueData)));
    }

    return( STATUS_SUCCESS );
}
#endif


extern "C"
NTSTATUS
FontDriverQueryRoutine
(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PLDEV pldev;
    WCHAR FontDriverPath[MAX_PATH+1];

    wcscpy(FontDriverPath, L"\\SystemRoot\\System32\\");

// guard against some malicious person putting a huge value in here to hose us

    if((ValueLength / sizeof(WCHAR) <
        MAX_PATH - (sizeof(L"\\SystemRoot\\System32\\") / sizeof(WCHAR))) &&
       (ValueType == REG_SZ))
    {
        wcscat(FontDriverPath, (PWSTR) ValueData);

        if (_wcsicmp(L"\\SystemRoot\\System32\\atmdrvr.dll", FontDriverPath) == 0 ||
            _wcsicmp(L"\\SystemRoot\\System32\\atmfd.dll", FontDriverPath) == 0)
        {
            //skip old atm font driver (4.0) or (5.0) because it is loaded through stub
            //WARNING("FontDriverQueryRoutine: system has a old version of ATM driver\n");
        }
        else
        {
            pldev = ldevLoadDriver(FontDriverPath, LDEV_FONT);

            if (pldev)
            {
                // Create the PDEV for this (the PDEV won't have anything in it
                // except the dispatch table.


                PDEVOBJ po(pldev,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL);

                if (po.bValid())
                {
                    po.ppdev->fl |= PDEV_FONTDRIVER;

                    FntCacheHDEV((PPDEV) po.hdev(), FNT_DUMMY_DRV);

                    return(TRUE);

                }
                else
                {
                    WARNING("win32k.sys could not initialize installable driver\n");
                }
            }
            else
            {
                WARNING("win32k.sys could not initialize installable driver\n");
            }
        }
    }

    return( STATUS_SUCCESS );
}


/******************************Public*Routine******************************\
* Read process handle quota
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status
*
* History:
*
*    3-May-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bLoadProcessHandleQuota()
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;
    NTSTATUS          NtStatus;
    HANDLE            hKey;
    BOOL              bRet = FALSE;

    RtlInitUnicodeString(&UnicodeString,
                    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows");

    //
    //  Open a registry key
    //

    InitializeObjectAttributes(&ObjectAttributes,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL);

    NtStatus = ZwOpenKey(&hKey,
                         KEY_ALL_ACCESS,
                         &ObjectAttributes);

    if (NT_SUCCESS(NtStatus))
    {
        UNICODE_STRING  UnicodeValue;
        ULONG           ReturnedLength;
        UCHAR           DataArray[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
        PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)DataArray;

        RtlInitUnicodeString(&UnicodeValue,
                              L"GDIProcessHandleQuota");

        NtStatus = ZwQueryValueKey(hKey,
                                   &UnicodeValue,
                                   KeyValuePartialInformation,
                                   pKeyInfo,
                                   sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD),
                                   &ReturnedLength);

        if (NT_SUCCESS(NtStatus))
        {
            gProcessHandleQuota = *(PLONG)(&pKeyInfo->Data[0]);
        } else {
            gProcessHandleQuota = DEFAULT_HANDLE_QUOTA;
        }

        bRet = TRUE;
        ZwCloseKey(hKey);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#


SRCBASE=ntos\w32

PUBLICINCS=

TARGET_H_DIRECTORY=$(TARGET_DIRECTORY)

PRIVATEINCS= $(NTGDI_PATH)\gre\hmgr.h                \
             $(NTGDI_PATH)\gre\patblt.hxx            \
             $(NTGDI_PATH)\gre\xformobj.hxx          \
             $(NTGDI_PATH)\gre\engine.hxx            \
             $(NTGDI_PATH)\gre\epointfl.hxx          \
             $(NTGDI_PATH)\gre\rfntobj.hxx

$(O)\geninc.cxx:                                                            \
		       ..\$(TARGET_DIRECTORY)\geninc.m4                     \
		       ..\$(TARGET_H_DIRECTORY)\geninc.m4
    set PASS0ONLY=
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) -DNTGDI_PATH=$(NTGDI_PATH) < ..\$(TARGET_DIRECTORY)\geninc.m4              \
                            > $@


$(O)\gdi$(TARGET_DIRECTORY).$(ASM_INCLUDE_SUFFIX):			     \
		       $(O)\geninc.cxx                                       \
		       $(PUBLICINCS)					     \
		       $(PRIVATEINCS)					     \
		       $(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
# Create the destination if it doesn't exit.
# Possible if compiling for axp64.
    if not exist $(O) mkdir $(O)
    nmake $(O)\geninc.obj USE_MSVCRT=1 NTNOPCH=1 FORCENATIVEOBJECT=1
    genxx $(O)\geninc.obj -s$(ASM_INCLUDE_SUFFIX) -o$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\mapfile2.cxx ===
/******************************Module*Header*******************************\
* Module Name: mapfile2.c
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#ifdef _HYDRA_
#include "muclean.hxx"
#endif

extern BOOL G_fConsole;
extern PW32PROCESS gpidSpool;

typedef enum _MAP_MODE {
    ModeKernel,
    ModeFD
} MAP_MODE;

typedef enum _FONT_IMAGE_TYPE {
    RemoteImage = 1,
    MemoryImage = 2
} FONT_IMAGE_TYPE;

BOOL bCreateSection(IN PWSTR, OUT FILEVIEW*, IN INT, BOOL *pbIsFAT);
VOID vUnmapFileFD(FILEVIEW*);
BOOL bMapRoutine(FONTFILEVIEW *pffv, FILEVIEW *pfv, MAP_MODE Mode, BOOL bIsFAT);
extern "C" HFASTMUTEX ghfmMemory;

#define SZDLHEADER ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets[1]))

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   cMapRemoteFonts
*
*       This procedure creates a virtual memory section in which we store
*       a copy of the spooler's data buffer. I shall refer to this copy
*       as the "spooler section". The pointer to the associated section
*       object is saved for later use. A view of the spooler section is
*       mapped into the user-mode address space of the calling procedure
*       (the spooler process). All the information about the spooler
*       section and its mappings is stored in a FONTFILEVIEW
*       strucutue supplied by the caller.
*
*   Parameters:
*
*       ppHeader - address of a variable that gives and receives a
*                  pointer to a DOWNLOADFONTHEADER structure.
*                  Upon entry, this is a pointer to a view of the spooler
*                  section that is valid in the context of the calling
*                  process (the spooler process).
*
*                  Upon error the value placed at this address is zero.
*
*       cjBuffer - a 32 bit variable that contains the size of the
*                  spooler image. In the case of MemoryImage fonts
*                  this size is actually larger than the size of the buffer
*                  by SZDLHEADER bytes.
*
*       pFontFileView - a pointer to a FONTFILEVIEW structure that
*                   points to incomming receive the information about
*                   the copy of the spooler image.
*
*                   Upon error this structure consists of all zero's.
*
*                   Upon a successful completion of this procedure,
*                   pFontFileView->gtfv.pvView will point to the first
*                   font in the spooler buffer and
*                   pFontFileView->gtfv.cjView will be equal to the
*                   size of the spooler buffer starting at pvView.
*                   That is, cjView is equal to cjBuffer minus
*                   the size of the spooler header.
*
*                   The fields of the FONTFILEVIEW structure that are
*                   affected are:
*
*           SpoolerBase - points to the base of a view of the spooler
*                         view of the spooler section. pHeader is
*                         valid only in the context of the this process
*                         (the spooler process)
*
*           fv.pvView - points to the first font file in the spooler
*                       view of the spooler section. This view of
*                       the spooler section is valid only in the
*                       context of the calling process.
*
*           fv.cjView - a 32-bit varaible that contains the size of
*                       header information is subtracted off. Another
*                       way to say this is: cjView is the offset of
*                       the end of the spooler section from the start
*                       of the image of the first font file.
*
*           ulRegionSize - equal to the entire size of the spooler
*                          section including the header information.
*
*           fv.pSection - pointer to the section object controling the
*                         spooler section. This is a kernel mode
*                         address and thus is accessable by any process
*                         in kernel mode.
*
*           SpoolerPid - the process id of the calling process. This is
*                        the id of the process that has valid access
*                        to pHeader, and fv.pvView.
*
*       ImageType - One of RemoteImage or MemoryImage. In
*                   the case of a remote font image, the image starts
*                   with a variable length DOWNLOADFONTHEADER structure
*                   followed by a series of file images at offsets
*                   specified in the header. In this case cjBuffer is
*                   equal to the size of the spooler image in bytes. This
*                   includes the size of the header, the files, and all
*                   necessary padding. In the case of a memory font image,
*                   the image is of a single font file; no header, no
*                   padding. In this case cjBuffer is equal to the size
*                   of the image plus SZDLHEADER. Here cjBuffer is equal
*                   to the size of the section to be produced which will
*                   start with a header, generated here, followed by
*                   a single font file image.
*
*   Called by:
*
*       NtGdiAddRemoteFontToDC
*
\**************************************************************************/

extern "C" ULONG cMapRemoteFonts(
   DOWNLOADFONTHEADER **ppHeader,       // IN OUT pointer to spooler buffer
                                        //        mapped into CSRSS address sapce
                COUNT  cjBuffer,        // IN size of spooler buffer in bytes
         FONTFILEVIEW *pFontFileView,   // OUT pointer to mapped file information
      FONT_IMAGE_TYPE  ImageType        // {Remote, Memory}
         )

{
              NTSTATUS  NtStatus;
                 PVOID  pSection, pView;
         LARGE_INTEGER  MaximumSize;
         LARGE_INTEGER  SectionOffset;
                 SIZE_T ViewSize;
                 ULONG  TempSize, NumFiles;
                  BOOL  bRet;
                  BOOL  bSpooledType1 = FALSE;

    DOWNLOADFONTHEADER *pHeader, *pCopy;

    // Copy the address of the spooler data into pHeader for safe keeping

    pHeader = *ppHeader;

    // Set the (return value) of the address of the copy of the spooler
    // data to zero. This indicates error.

    *ppHeader = 0;

#define  MAX_FONTFILE 0x10000000

// claudebe 6/24/99, the new surrogate enabled MungLui is blowing the previous limit of 0x80000000 

    ASSERTGDI(cjBuffer <=  MAX_FONTFILE, "cjBuffer > MAX_FONTFILE");

    // return 0 if cjBuffer is bogus

    if ((cjBuffer > MAX_FONTFILE) || (cjBuffer < sizeof(DOWNLOADFONTHEADER)))
    {
        return 0;
    }

    // Initialize these variables to zero to prevent unintended access
    // in the clean up code at the end of this routine. We also zero
    // out the FONTFILEVIEW structure, not only to indicate error, but
    // this will save us explicitly zeroing fields that we do not touch
    // in this routine.

    pSection  = 0;
    pView     = 0;

    if (pFontFileView == 0)
    {
        return(0);
    }

    RtlZeroMemory(pFontFileView, sizeof(*pFontFileView));

    if (ImageType == RemoteImage)
    {
        __try
        {
            ProbeForRead(pHeader, sizeof(DOWNLOADFONTHEADER), sizeof(ULONG));
            NumFiles = pHeader->NumFiles;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("cMapRemoteFonts: invalid pointer pHeader\n");
            return (0);
        }

        // do some checks to ensure that these numbers are not entirely bogus.
        // Eg. in reality we never have more than 3 files per font, the total
        // sum of their sizes should not exceed MAX_FONTFILE (32MB for now);
        // ClaudeBe 6/24/99, limit extended to 256 MB 

        ASSERTGDI(NumFiles <= 3, "NumFiles not reasonable\n");

        if (NumFiles > 3)
        {
            return 0;
        }

        // The upper limit on the size of the spooler section is 256Mb

        if (0x10000000 < cjBuffer)
        {
            return(0);
        }

        if (!IS_USER_ADDRESS(pHeader))
        {
            return(0);
        }

        // If this a pfm,pfb image spooled from the NT 4.0 client,
        // NumFiles will be set to zero and Type1ID will be set to
        // ufi hash value. In this case we have to set the NumFiles to 2:

        if (NumFiles == 0)
        {
            bSpooledType1 = TRUE;
            NumFiles = 2;
        }
    }
    else
    {
        // for MemoryImage, NumFiles should be 1

        NumFiles = 1;
    }

    // Set TempSize to be equal to the size of the stuff preceeding
    // the first font file. This is the size of the header information
    // if you wish

    TempSize = ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets[NumFiles]));

    // return 0 if the TempSize is bigger than cjBuffer

    if (cjBuffer < TempSize)
    {
        return 0;
    }

    // Create a section where we will store a copy of the spooler data

    MaximumSize.QuadPart = (LONGLONG) cjBuffer;

    NtStatus =
      Win32CreateSection(
            &pSection          , // SectionObject
            SECTION_ALL_ACCESS , // DesiredAccess
            0                  , // ObjectAttributes
            &MaximumSize       , // MaximumSize
            PAGE_READWRITE     , // SectionPageProtection
            SEC_COMMIT         , // AllocationAttributes
            0                  , // FileHandle
            0                  , // FileObject
            TAG_SECTION_REMOTEFONT
            );

    if (!NT_SUCCESS(NtStatus))
    {
        return(0);
    }

    // Map a view of the spooler section into the user mode address space
    // of the current process (this spooler process)

    SectionOffset.QuadPart = 0;
    ViewSize = cjBuffer;

    ASSERTGDI(pView == 0, "pView != 0\n");

    // Temporarily map a view of the section into the user mode address space
    // of the spooler process. This will allow us to copy the data from
    // the spool file to the section. After we are done we will close
    // this mapping and open a mapping into the user mode address space
    // of the CSRSS process.

    NtStatus =
        MmMapViewOfSection(
            pSection             , // SectionToMap,
            PsGetCurrentProcess(), // spooler process
            &pView               , // CapturedBase,
            0                    , // ZeroBits,
            ViewSize             , // CommitSize,
            &SectionOffset       , // SectionOffset,
            &ViewSize            , // CapturedViewSize,
            ViewUnmap            , // InheritDisposition,
            SEC_NO_CHANGE        , // AllocationType,
            PAGE_READWRITE         // Allow writing on this view
            );

    if (!NT_SUCCESS(NtStatus))
    {
        Win32DestroySection(pSection);
        return(0);
    }

    // this operation is a suspect for copying into 0-th page of csrss:

    ASSERTGDI(pView, "pView == 0\n");

    // Change pHeader to point at the copy

    DOWNLOADFONTHEADER  *pTmp = pCopy = (DOWNLOADFONTHEADER*) pView;

    if (ImageType == MemoryImage)
    {
        // pHeader is a buffer of size cjBuffer - SZDLHEADER
        // advance the pointer to the right position

        cjBuffer -= SZDLHEADER;
        pView = (PBYTE)pView + SZDLHEADER;

        // fill out the fields in DOWNLOADFONTHEADER for memory fonts

        __try
        {
            ProbeAndWriteUlong( &pTmp->Type1ID, 0);
            ProbeAndWriteUlong( &pTmp->NumFiles, NumFiles);
            ProbeAndWriteUlong( &pTmp->FileOffsets[0], cjBuffer);
            bRet = TRUE;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("cMapRemoteFonts: exception occured for memory image\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }

        if (bRet == FALSE)
        {
            NtStatus = MmUnmapViewOfSection(PsGetCurrentProcess(), (PVOID)pCopy);

            if (!NT_SUCCESS(NtStatus))
            {
                WARNING("Could not unmap the current process view of the memory font\n");
            }
            Win32DestroySection(pSection);
            return(0);
        }
    }

    // Copy the spooler data into this view of the spooler section

    __try
    {
        ProbeForRead(pHeader, cjBuffer, sizeof(BYTE));
        RtlCopyMemory(pView, pHeader, cjBuffer);
        bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("cMapRemoteFonts: exception occured\n");
        EngSetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }

    // fix the spooled (from NT 4.0) Type1 font case:

    if (bSpooledType1)
    {
        __try
        {
            ProbeAndWriteUlong( &pTmp->Type1ID, 0);
            ProbeAndWriteUlong( &pTmp->NumFiles, NumFiles);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("cMapRemoteFonts: exception occured\n");
            EngSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
    }

    // We have OR have not successfully completed copying the data
    // from the file to the section. In either case we no longer
    // need this view of the section
    // so we will unmap the spooler view at this time

    NtStatus = MmUnmapViewOfSection(PsGetCurrentProcess(), (PVOID)pCopy);

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Could not unmap the current process view of the memory font\n");
        KdPrint(("Could not unmap the current process view of the memory font\n"));

        Win32DestroySection(pSection);
        return(0);
    }

    if (bRet == FALSE)
    {
        Win32DestroySection(pSection);
        return(0);
    }

    // Now we will map a view into the user mode address space
    // of the CSRSS process. Remember that this view cannot
    // be seen by the current process.

    pView = 0;
    ViewSize = 0;
    SectionOffset.QuadPart = 0;

    NtStatus =
        MmMapViewOfSection(
            pSection             , // SectionToMap,
            gpepCSRSS            , // CSRSS process
            &pView               , // CapturedBase,
            0                    , // ZeroBits,
            ViewSize             , // CommitSize,
            &SectionOffset       , // SectionOffset,
            &ViewSize            , // CapturedViewSize,
            ViewUnmap            , // InheritDisposition,
            SEC_NO_CHANGE        , // AllocationType,
            PAGE_READONLY          // No writing on this view
            );

    if (!NT_SUCCESS(NtStatus))
    {
        Win32DestroySection(pSection);
        return(0);
    }

    ASSERTGDI((ULONG_PTR)pView > 0x100000,
                   "cmap remote fonts: csrss view smaller than 1MB \n");

    // Reset pCopy to point to a view of the section in the context
    // of the CSRSS process. CAUTION - you cannot access any data
    // off of pCopy or pView after this point.

    pCopy = (DOWNLOADFONTHEADER*) pView;

    if (ImageType == MemoryImage)
    {
        // reset the size and pointer

        cjBuffer += SZDLHEADER;
        pView = pCopy;
    }

    // Set the FONTFILEVIEW
    //
    //      SpoolerBase points at the base of the copy.
    //      pvView points to the first font image.
    //      cjView is the size of the section with starting
    //      at the first font image.
    //      ulRegionSize is set to the size of the entire view.

    pFontFileView->SpoolerBase  = pCopy;
    pFontFileView->fv.pvViewFD  = (char*) pCopy + TempSize;
    pFontFileView->fv.cjView    = cjBuffer - TempSize;
    pFontFileView->ulRegionSize = ViewSize;

// We have to set FD ref count to 1, KM ref count to zero [bodind]

    pFontFileView->cKRefCount    = 0;
    pFontFileView->cRefCountFD   = 1;

    pFontFileView->fv.pSection  = pSection;
    pFontFileView->SpoolerPid   = W32GetCurrentPID();   // this could be the pid of the spooler
                                                        // or the pid of the current process which is loading a memory font

    *ppHeader = pCopy;          // Valid in CSRSS process only.

    return(NumFiles);
}

/******************************Public*Routine******************************\
*
*   vUnmapRemoteFonts
*
*       This is a remote font so delete the memory for the view.
*
*   CAUTION
*
*       This code is intimately linked with NtGdiAddRemoteFontToDC()
*       so any changes here should be synchronized there.
*
*       The pool memory starts with a DOWNLOADFONTHEADER followed by the
*       file image pointed to by pvView. We must pass the pointer to the
*       beginning of the pool allocation to the free routine.
*
*
*   Spooler data format for Engine fonts
*
*
*    DOWNLOADFONTHEADER         PADDING
*         |                       |
*   |           |- FILE OFFSETS-|   |
*   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
*   |         0 | 1 | 2 | 3 | N | x | font image #0 | font image #1 |...
*   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
*                                   ^
*                                   pvView points to first font image
*
*
*   Parameters:
*
*       pFontFileView - a 32-bit variable that contains a pointer to a
*                       FONTFILEVIEW structure that describes the very
*                       first font file image in the spooler data.
*
*   Return Value:
*
*        none
*
*   Called by:
*
*     NtGdiAddRemoteFontsToDC
*     FreeFileView
*
\**************************************************************************/

extern "C" void vUnmapRemoteFonts(FONTFILEVIEW *pFontFileView)
{
    if (pFontFileView == 0)
    {
        return;
    }

    ASSERTGDI(pFontFileView->SpoolerPid == W32GetCurrentPID() ||
              gpidSpool == (PW32PROCESS)W32GetCurrentProcess(),
        "vUnmapRemoteFonts: wrong process freeing remote font data\n");

    // We initialize the cRefCountFD to 1 in cMapRemoteFonts() function

    if (pFontFileView->cRefCountFD)
    {
        pFontFileView->cRefCountFD -= 1;
    }

    if (pFontFileView->cRefCountFD == 0)
    {
        if (pFontFileView->fv.pSection)
        {
            if (pFontFileView->SpoolerBase)
            {
                MmUnmapViewOfSection(gpepCSRSS, pFontFileView->SpoolerBase);
                pFontFileView->SpoolerBase = NULL;
            }
            Win32DestroySection(pFontFileView->fv.pSection);
            pFontFileView->fv.pSection = 0;
        }
    }
}

/******************************Public*Routine******************************\
*
* bCreateFontFileView
*
\**************************************************************************/

BOOL  bCreateFontFileView(
          FONTFILEVIEW   *pFontFileViewIn,  // kernel mode address
    DOWNLOADFONTHEADER   *pHeader,          // CSRSS address of spool section
                 COUNT    cjBuffer,
          FONTFILEVIEW ***papfv,
                 ULONG    NumFiles
)
{
    FONTFILEVIEW **apfv, *pFontFileView, FontFileView;
    NTSTATUS  NtStatus;
    ULONG  offset;
    COUNT cjHeader;
    BOOL  bRet = TRUE;

    //
    // In order to see the data pointed to by pHeader we must attach
    // to the address space of the CSRSS process
    //

    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

    //
    // engine fonts
    //

    apfv = 0;
    FontFileView = *pFontFileViewIn;

    cjHeader = ALIGN8(offsetof(DOWNLOADFONTHEADER,FileOffsets[NumFiles]));

    if (cjBuffer <= cjHeader)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        KeDetachProcess();
        return FALSE;
    }

    //
    // The lowest part of the block of memory pointed to by apfv
    // will be occupied by NumFiles pointers to FONTFILEVIEW structures.
    // The FONTFILEVIEW structures pointed to by these pointers follow
    // at the first 8-byte aligned address after the array of pointers.
    //
/*********************************************************************************
*                                                                                *
*     Structure of data pointed to by `apfv'                                     *
*                                                                                *
* pointer   data  +----------------------------+                                 *
*                 |                            V                                 *
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+ *
* |apfv ... | p | p | p |   |FONTFILEVIEW|   |FONTFILEVIEW|   |FONTFILEVIEW|   | *
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+ *
*   |       ^ |             ^                                                    *
*   +-------+ +-------------+                                                    *
*                                                                                *
*            |               |                                                   *
*            |<-- offset --->|                                                   *
*                                                                                *
*********************************************************************************/

    //
    // `offset' is the count of bytes from the beginning of the allocated
    // memory to where the array of FONTFILEVIEW structures starts. An array
    // of FONTFILEVIEW pointers preceeds.
    //

    offset = ALIGN8(sizeof(FONTFILEVIEW*) * NumFiles);

    apfv = (FONTFILEVIEW**) PALLOCMEM(sizeof(FONTFILEVIEW) * NumFiles + offset, 'vffG');

    if (apfv == 0)
    {
        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        KeDetachProcess();
        return FALSE;
    }

    //
    // Only initiaze these values for one file view in the
    // array.  This file view will be used to free the entire
    // block of memory containing all the files.
    //

    FONTFILEVIEW **ppFontFileView = apfv;

    pFontFileView  = (FONTFILEVIEW*) ((char*) apfv + offset);

    //
    // FileOffset[i] = offset of File[i+1] from begining of first
    //                 font file view
    //
    // Size[i] = FileOffset[i] - FileOffset[i-1];
    //

    //
    // copy the FONTFILEVIEW structure initialized by vMapSpoolerFontFiles
    // into the first positon in the array
    //

    *pFontFileView = FontFileView;

    //
    // Set pchView to point to the first FONTFILEVIEW structure in the
    // array
    //

    char *pchView = (char*) FontFileView.fv.pvViewFD;

    //
    // pchLast points to illegal memory. This step relies on
    // vMapRemotFonts to place in cjView the size of the view as
    // though it were based at the start of the first file.
    //

    char *pchLast = pchView + FontFileView.fv.cjView;

    ULONG Offset       = 0;
    ULONG *pOffset     = &(pHeader->FileOffsets[0]);
    ULONG *pOffsetLast = pOffset + NumFiles;

    for (; pOffset < pOffsetLast; pOffset++)
    {
        ULONG NextOffset = *pOffset;
        ULONG cjView     = NextOffset - Offset;
        Offset = ALIGN4(NextOffset);
        // the offset alignement must correspond to \ntgdi\client\ufi.c WriteFontToSpoolFile()
        // if there is a need for different alignement, then we would need to map each file separately
        ASSERTGDI(Offset == NextOffset, "bCreateFontFileView ALIGN difference between client and server");


        if (pchLast < pchView + cjView)
        {
            bRet = FALSE;
            break;
        }

        pFontFileView->fv.pvViewFD = pchView;
        pFontFileView->fv.cjView   = cjView;

        //
        // move pchView to point at the next font image
        //

        pchView += cjView;

        *ppFontFileView = pFontFileView;

        ppFontFileView++;
        pFontFileView++;

    }

    if (!bRet)
    {
        VFREEMEM(apfv);
    }
    else
    {
        *papfv = apfv;
    }

    KeDetachProcess();

    return (bRet);
}

/******************************Public*Routine******************************\
*
*   NtGdiAddRemoteFontToDC
*
* This routine is called by the spooler process, at playback time, to
* add remote fonts to a printer DC. The font files in question are for
* the use of the associated print job only. No other application can
* have access. In order to prevent mischevious application on the server
* from picking up font to which it has not right, we have chosen to not
* copy the file images contained in the spool file to separate font file
* on the disk. This means that the spooler process cannot use
* AddFontResource to allow the DC access to the fonts.
* Instead, we have introduced this private entry point for the spooler.
*
*     Parameters:
*
*         hdc - handle to DC to which remote font is to be added
*
*         pvBuffer - pointer to a DOWNLOADFONTHEADER that details
*                    the location of the font files contained
*                    withing this buffer.
*
*         cjBuffer - is the size of the buffe, in bytes, pointed
*                    to by pvBuffer
*
*     Return Value:
*
*         TRUE if successful, FALSE if not.
*
*     Remarks:
*
* In the process of loading the fonts to the spooler DC, we create
* an array of FONTFILEVIEW structures. The lowest part of the block
* of memory pointed to by apfv will be occupied by NumFiles pointers
* to FONTFILEVIEW structures. The FONTFILEVIEW structures pointed to
* by these pointers follow at the first 8-byte aligned address after
* the array of pointers.
*
*         Structure of data pointed to by `apfv'
*
* pointer   data  +----------------------------+
*                 |                            V
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+
* |apfv ... | p | p | p |   |FONTFILEVIEW|   |FONTFILEVIEW|   |FONTFILEVIEW|   |
* +---+     +---+---+---+---+---+---+----+---+---+---+----+---+---+---+----+---+
*   |       ^ |             ^
*   +-------+ +-------------+
*
*            |               |
*            |<-- offset --->|
*
\**************************************************************************/

extern "C" BOOL APIENTRY NtGdiAddRemoteFontToDC(
      HDC hdc      , // handle to DC to which remote font is to be added
    PVOID pvBuffer , // pointer to spool font file image
    COUNT cjBuffer , // size of spool font file image
    PUNIVERSAL_FONT_ID pufi     //orignal ufi for subsetted font, used for remote printing only
)
{
          FONTFILEVIEW FontFileView, **apfv, *pFontFileView;
    DOWNLOADFONTHEADER *pHeader;
              NTSTATUS  NtStatus;
                 ULONG  offset;
                 ULONG  NumFiles;
                  BOOL  bRet;
                  BOOL  bMappedSpoolerFont;
     UNIVERSAL_FONT_ID  ufiTmp;
     UNIVERSAL_FONT_ID *pufiTmp = pufi;

    __try
    {
        if (pufiTmp)
        {
            ufiTmp = ProbeAndReadStructure(pufiTmp, UNIVERSAL_FONT_ID);
            pufiTmp = &ufiTmp;
        }
        bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (!bRet)
        return bRet;

    bRet = FALSE;
    XDCOBJ dco(hdc);

    if (!dco.bValid())
    {
        return bRet;
    }

    apfv = 0;
    pFontFileView = NULL;

    pHeader = (DOWNLOADFONTHEADER*) pvBuffer;

    NumFiles = cMapRemoteFonts(&pHeader, cjBuffer, &FontFileView, RemoteImage);

    if (pHeader == 0)
    {
        goto exit_point;
    }
    bRet = TRUE;
    pFontFileView = &FontFileView;

    if (NumFiles)
    {
    // engine fonts

        if (bRet = bCreateFontFileView(&FontFileView, pHeader, cjBuffer, &apfv, NumFiles))
        {
            PUBLIC_PFTOBJ pfto;

            bRet = pfto.bLoadRemoteFonts(dco, apfv, NumFiles, 0, pufiTmp);
        }
    }

exit_point:

    if (!bRet)
    {
        if (pFontFileView)
        {
            vUnmapRemoteFonts(pFontFileView);
        }
        if (apfv)
        {
            VFREEMEM(apfv);
        }
    }
    dco.vUnlockFast();

    return (bRet);
}

/******************************Public*Routine******************************\
*
* GreAddFontMemResourceEx
*
* This function uses same routines that NtGdiAddRemoteToDC()
* uses to create the file view structrues before it can load
* the font into the system. Memory fonts are always added as
* private to the private font tale.
*
\**************************************************************************/

HANDLE GreAddFontMemResourceEx(
    PVOID   pvBuffer,
    ULONG   cjBuffer,
    DESIGNVECTOR  *pdv,
    DWORD   cjDV,
    DWORD   *pNumFonts
)
{
    FONTFILEVIEW    **apfv, FontFileView;
    DOWNLOADFONTHEADER  *pHeader;
    ULONG NumFiles;

    HANDLE  hMMFont = 0;
    BOOL    bOK = FALSE;

    apfv = 0;
    pHeader = (DOWNLOADFONTHEADER*) pvBuffer;

    // in order to use the same routines used by remote fonts, we need to
    // attach a DOWNLOADFONTHEADER structure in fron of the font image

    cjBuffer += SZDLHEADER;

    NumFiles = cMapRemoteFonts(&pHeader, cjBuffer, &FontFileView, MemoryImage);

    if (pHeader != 0)
    {
        ASSERTGDI(NumFiles == 1, "GreAddFontMemResourceEx() NumFiles != 1\n");

        if (bCreateFontFileView(&FontFileView, pHeader, cjBuffer, &apfv, 1))
        {
            if (gpPFTPrivate || bInitPrivatePFT())
            {
                PUBLIC_PFTOBJ pfto(gpPFTPrivate);
                ULONG   cFonts;

                bOK = TRUE;
                // if hLoadMemFonts fail to load a bad font, apfv is already released
                // inside hLoadMemFonts at FreeFileView and doesn't need to be freed
                // below, see Windows bug 770114
                if (hMMFont = pfto.hLoadMemFonts(apfv, pdv, cjDV, &cFonts))
                {
                    *pNumFonts = cFonts;
                }
            }
        }
        else
        {
            vUnmapRemoteFonts(&FontFileView);
        }
    }

    if (!bOK && apfv)
    {
        VFREEMEM(apfv);
    }

    return hMMFont;
}

/******************************Public*Routine******************************\
*
*   FreeFileView
*
*       This routine is called to free the copy of the spooler data,
*       if it exists.
*
*  Parameters:
*
*       apfv - pointer to an array of FONTFILEVIEW pointers.
*              The number of pointers in the array is given by cFiles.
*
*       cFiles - a 32-bit variable containing the number of pointers in
*                the array pointed to by apfv.
*
* Return Value:
*
*   None.
*
* Called by:
*
*       PFFOBJ::pPFFC_Delete
*
\**************************************************************************/

extern "C" void FreeFileView(PFONTFILEVIEW apfv[], ULONG cFiles)
{
    FONTFILEVIEW *pfv, **ppfv;

    for (ppfv = apfv; ppfv < apfv + cFiles; ppfv++)
    {
        pfv = *ppfv;

        if (pfv->ulRegionSize)
        {
            vUnmapRemoteFonts(pfv);
        }
    }
    VFREEMEM(apfv);
}


/******************************Public*Routine******************************\
*
* BOOL EngMapFontFileInternal
*
*    This is called by font drivers to return a buffer containing the
*    raw bytes for a font file, given a handle passed to DrvLoadFontFile.
*    The handle is really a pointer to the PFF for this file.
*
* Parameters:
*
*       iFile - Supplies a 32-bit identifier of the font file. This is
*               the value supplied in DrvLoadFontFile.
*
*       ppjBuf - Supplies a pointer to a variable that will receive the
*                address of the base of the view of the file.
*
*       pcjBuf - Supplies a pointer to a variable that will receive the
*                size of the view of the file.
*       bFontDrv - if this is called by font driver.
*
* Return Values:
*
*       TRUE if successufl, FALSE if not.
*
* Called by:
*
*       PUBLIC_PFTOBJ::bLoadFonts
*       NtGdiAddRemoteFontToDC
*       GreMakeFontDir
*
* History:
*  20-Jan-1995 -by- Gerrit van Wingerden
*
\**************************************************************************/

BOOL EngMapFontFileInternal(
     ULONG_PTR  iFile ,
    PULONG *ppjBuf,
     ULONG *pcjBuf,
     BOOL  bFontDrv
)
{
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;
    BOOL bMapIt,bRet;
    FILEVIEW fv;

    RtlZeroMemory(&fv, sizeof(fv));

    bRet   = TRUE;
    bMapIt = TRUE;

    GreAcquireFastMutex(ghfmMemory);
        if (pffv->fv.pvKView)
        {
            bMapIt = FALSE;
            pffv->cKRefCount += 1;
        }
        else if (!pffv->pwszPath)
        {
            RIP("fv.pvKView==0 && pwszPath==0\n");
        }
        else if (pffv->fv.pSection)
        {
            NTSTATUS NtStatus;
            SIZE_T ViewSize;
            LARGE_INTEGER SectionOffset;

            SectionOffset.QuadPart = 0;
            ViewSize = 0;

#if defined(_GDIPLUS_)

            NtStatus = MapViewInProcessSpace(
                            pffv->fv.pSection,
                            &pffv->fv.pvKView,
                            &ViewSize);

#elif defined(_HYDRA_)
            // MmMapViewInSessionSpace is internally promoted to
            // MmMapViewInSystemSpace on non-Hydra systems.

            NtStatus= Win32MapViewInSessionSpace(
                         pffv->fv.pSection,
                         &pffv->fv.pvKView,
                         &ViewSize);
#else
            NtStatus = MmMapViewInSystemSpace(
                           pffv->fv.pSection,
                           &pffv->fv.pvKView,
                           &ViewSize);
#endif


            if (bRet = NT_SUCCESS(NtStatus))
            {
#ifdef _HYDRA_
#if DBG
                if (!G_fConsole)
                {
                    DebugGreTrackAddMapView(pffv->fv.pvKView);
                }
#endif
#endif

                pffv->cKRefCount = 1;
            }
            bMapIt = FALSE;
        }
    GreReleaseFastMutex(ghfmMemory);

    if (bMapIt)
    {
        BOOL    bMapOK, bIsFAT;

        // If the call is from the font driver, the current thread
        // is attached to the CSRSS process. By attaching it to the
        // CSRSS, the thread loses its user security context which
        // prevents the thread to open a network font file.

        if (bFontDrv)
            KeDetachProcess();

        bMapOK = bMapFile(pffv->pwszPath, &fv, 0, &bIsFAT);

        if (bFontDrv)
            KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

        if (!bMapOK)
        {
            bRet = FALSE;
        }
        else
        {
            BOOL bKeepIt;

            GreAcquireFastMutex(ghfmMemory);
                pffv->cKRefCount += 1;
                if (pffv->fv.pvKView)
                {
                    bKeepIt = FALSE;    // file mapped by another thread
                }
                else
                {
                    bRet = bKeepIt = bMapRoutine(pffv, &fv, ModeKernel, bIsFAT);
                }
            GreReleaseFastMutex(ghfmMemory);

            if (!bKeepIt)
            {
                vUnmapFile(&fv);
            }
        }
    }

    if (bRet)
    {
        //
        // it's okay to access these without grabbing the MUTEX since we've
        // incremented the reference count;
        //

        if (ppjBuf)
        {
            *ppjBuf = (ULONG*) pffv->fv.pvKView;
        }
        if (pcjBuf)
        {
            *pcjBuf = pffv->fv.cjView;
        }
    }

    return(bRet);

}

/***********************Public*Routine*********************\
*
* BOOL EngMapFontFile
*
* History:
*  20-Jan-1995 -by- Gerrit van Wingerden
*
\**********************************************************/

BOOL EngMapFontFile(
     ULONG_PTR  iFile ,
    PULONG *ppjBuf,
     ULONG *pcjBuf
)
{
    return (EngMapFontFileInternal(iFile, ppjBuf, pcjBuf, FALSE));
}


/******************************Public*Routine******************************\
*
*  EngUnmapFontFile
*
*   This is called by font drivers to unmap a file mapped by a previous
*   call to EngMapFontFile.
*
*  Parameters:
*
*      iFile - is the font identifier as returned by EngMapFontFile.
*
*  Return Value:
*
*      None.
*
*  Called by:
*
*    PUBLIC_PFTOBJ::bLoadFonts
*    GreMakeFontDir
*
\**************************************************************************/

void EngUnmapFontFile(ULONG_PTR iFile)
{
    FILEVIEW fv;
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;

    fv.pvKView = NULL;

    GreAcquireFastMutex(ghfmMemory);

    if (pffv->cKRefCount)
    {
        pffv->cKRefCount -= 1;

        if (pffv->cKRefCount == 0)
        {
            if (pffv->pwszPath)
            {
                fv = pffv->fv; // copy pvKView, pvViewFD and pSection;

                pffv->fv.pvKView = 0;

                if (pffv->fv.pvViewFD == 0)
                {
                    pffv->fv.pSection = 0;
                }
            }
        }
    }

    GreReleaseFastMutex(ghfmMemory);

    if (fv.pvKView)
    {
        vUnmapFile(&fv);
    }
}

/******************************Public*Routine******************************\
* BOOL bMapFile
*
* Similar to PosMapFile except that it takes unicode file name
*
* If iFileSize is -1 then the file is module is mapped for read/write.  If
* iFileSize is > 0 then the file is extended or truncated to be iFileSize
* bytes in size and is mapped for read/write.
*
* History:
*  21-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bMapFile(PWSTR pwszFileName, FILEVIEW  *pfvw, INT iFileSize, BOOL *pbIsFAT)
{
    FILEVIEW fv;
    NTSTATUS NtStatus;
    BOOL ReturnValue;
    SIZE_T ViewSize;

    ReturnValue = FALSE;

    if (bCreateSection(pwszFileName, &fv, iFileSize, pbIsFAT))
    {
        ViewSize = 0;

#if defined(_GDIPLUS_)

        NtStatus = MapViewInProcessSpace(fv.pSection, &fv.pvKView, &ViewSize);

#elif defined(_HYDRA_)
        // MmMapViewInSessionSpace is internally promoted to
        // MmMapViewInSystemSpace on non-Hydra systems.

        NtStatus = Win32MapViewInSessionSpace(fv.pSection, &fv.pvKView, &ViewSize);
#else
        NtStatus = MmMapViewInSystemSpace(fv.pSection, &fv.pvKView, &ViewSize);
#endif
        if (NT_SUCCESS(NtStatus))
        {

#ifdef _HYDRA_
#if DBG
                if (!G_fConsole)
                {
                    DebugGreTrackAddMapView (fv.pvKView);
                }
#endif
#endif
            *pfvw = fv;
            ReturnValue = TRUE;
        }
        else
        {
            DEREFERENCE_FONTVIEW_SECTION(fv.pSection);
        }
    }

    return(ReturnValue);
}

/******************************Public*Routine******************************\
*
* vCopyDESIGNVECTOR
*
\**************************************************************************/

extern "C" VOID vCopyDESIGNVECTOR(DESIGNVECTOR *pDst, DESIGNVECTOR *pSrc)
{
    RtlCopyMemory(pDst, pSrc, SIZEOFDV(pSrc->dvNumAxes));
}


/******************************Public*Routine******************************\
*
* EngMapFontFileFDInternal
*
\**************************************************************************/

BOOL EngMapFontFileFDInternal(
     ULONG_PTR  iFile ,
    PULONG *ppjBuf,
     ULONG *pcjBuf,
     BOOL  bFontDrv
)
{
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;
    BOOL bMapIt,bRet;
    FILEVIEW fv;

    RtlZeroMemory(&fv, sizeof(fv));

    bRet   = TRUE;
    bMapIt = TRUE;

    GreAcquireFastMutex(ghfmMemory);
        if (pffv->fv.pvViewFD)
        {
            bMapIt = FALSE;
            pffv->cRefCountFD += 1;
        }
        else if (!pffv->pwszPath)
        {
            GreReleaseFastMutex(ghfmMemory);
            return(FALSE);
        }
        else if (pffv->fv.pSection)
        {
            NTSTATUS NtStatus;
            SIZE_T ViewSize;
            LARGE_INTEGER SectionOffset;

            SectionOffset.QuadPart = 0;
            ViewSize = 0;

#if defined(_GDIPLUS_)

            NtStatus = MapViewInProcessSpace(pffv->fv.pSection, &pffv->fv.pvViewFD, &ViewSize);
#else

            NtStatus = MmMapViewOfSection(
                           pffv->fv.pSection , // SectionToMap,
                           gpepCSRSS         , // spooler process
                           &pffv->fv.pvViewFD, // CapturedBase,
                           0                 , // ZeroBits,
                           ViewSize          , // CommitSize,
                           &SectionOffset    , // SectionOffset,
                           &ViewSize         , // CapturedViewSize,
                           ViewUnmap         , // InheritDisposition,
                           SEC_NO_CHANGE     , // AllocationType,
                           PAGE_READONLY       // Protect
                           );
#endif

            if (bRet = NT_SUCCESS(NtStatus))
            {
                pffv->cRefCountFD = 1;
            }
            bMapIt = FALSE;
        }
    GreReleaseFastMutex(ghfmMemory);

    if (bMapIt)
    {
        // If the call is from the font driver, the current thread
        // is attached to the CSRSS process. By attaching it to the
        // CSRSS, the thread loses its user security context which
        // prevents the thread to open a network font file.

        BOOL    bCreateOK, bIsFAT;

        if (bFontDrv)
            KeDetachProcess();

        bCreateOK = bCreateSection(pffv->pwszPath, &fv, 0, &bIsFAT);

        if (bFontDrv)
            KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

        if (!bCreateOK)
        {
            bRet = FALSE;
        }
        else
        {
            BOOL bKeepIt;
            NTSTATUS NtStatus;
            SIZE_T ViewSize = 0;
            PVOID pvView, pSection;
            LARGE_INTEGER SectionOffset = {0,0};

#if defined(_GDIPLUS_)

            NtStatus = MapViewInProcessSpace(fv.pSection, &fv.pvViewFD, &ViewSize);

#else

            NtStatus = MmMapViewOfSection(
                           fv.pSection   , // SectionToMap,
                           gpepCSRSS     , // spooler process
                           &fv.pvViewFD  , // CapturedBase,
                           0             , // ZeroBits,
                           ViewSize      , // CommitSize,
                           &SectionOffset, // SectionOffset,
                           &ViewSize     , // CapturedViewSize,
                           ViewUnmap     , // InheritDisposition,
                           SEC_NO_CHANGE , // AllocationType,
                           PAGE_READONLY   // Protect
                           );
#endif

            if (!NT_SUCCESS(NtStatus))
            {
                DEREFERENCE_FONTVIEW_SECTION(fv.pSection);
                return(FALSE);
            }

            GreAcquireFastMutex(ghfmMemory);
                pffv->cRefCountFD += 1;
                if (pffv->fv.pvViewFD)
                {
                    bKeepIt = FALSE;
                }
                else
                {
                    bRet = bKeepIt = bMapRoutine(pffv, &fv, ModeFD, bIsFAT);
                }
            GreReleaseFastMutex(ghfmMemory);

            if (!bKeepIt)
            {
                vUnmapFileFD(&fv);
            }
        }
    }

    if (bRet)
    {

        ASSERTGDI((ULONG_PTR)pffv->fv.pvViewFD > 0x100000,
                   "csrss view smaller than 1MB \n");

        if (ppjBuf)
        {
            *ppjBuf = (ULONG*) pffv->fv.pvViewFD;
        }
        if (pcjBuf)
        {
            *pcjBuf = pffv->fv.cjView;
        }
    }

    return(bRet);
}


/************************Public*Routine**********************\
*
* EngMapFontFileFD
*
\************************************************************/

BOOL EngMapFontFileFD(
     ULONG_PTR  iFile,
    PULONG *ppjBuf,
     ULONG *pcjBuf
)
{
    return (EngMapFontFileFDInternal(iFile, ppjBuf, pcjBuf, TRUE));
}


/******************************Public*Routine******************************\
*
* vUnmapFileFD
*
\**************************************************************************/

VOID vUnmapFileFD(FILEVIEW *pFileView)
{
#if defined(_GDIPLUS_)
    UnmapViewInProcessSpace(pFileView->pvViewFD);
#else
    MmUnmapViewOfSection(gpepCSRSS, pFileView->pvViewFD);
#endif

    if (pFileView->pvKView == 0)
    {
        DEREFERENCE_FONTVIEW_SECTION(pFileView->pSection);
    }

    pFileView->bLastUpdated = FALSE;
}

/******************************Public*Routine******************************\
*
* EngUnmapFontFileFD
*
\**************************************************************************/

void EngUnmapFontFileFD(ULONG_PTR iFile)
{
    FILEVIEW fv;
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) iFile;

    fv.pvViewFD = NULL;

    GreAcquireFastMutex(ghfmMemory);

    if (pffv->cRefCountFD)
    {
        pffv->cRefCountFD -= 1;

        if (pffv->cRefCountFD == 0)
        {
            if (pffv->pwszPath)
            {
            // This path is never taken for remote fonts
            // so this routine does not unmap remote fonts

                fv = pffv->fv;  // copy pvKView, pvViewFD and pSection;

                if (pffv->fv.pvViewFD)
                {
                    pffv->fv.pvViewFD = 0;

                    if (pffv->fv.pvKView == 0)
                    {
                        pffv->fv.pSection = 0;
                    }
                }
            }
        }
    }

    GreReleaseFastMutex(ghfmMemory);

    if (fv.pvViewFD)
    {
        vUnmapFileFD(&fv);
    }
}

/******************************Public*Routine******************************\
*
* bCreateSection
*
\**************************************************************************/

BOOL bCreateSection(PWSTR pwszFileName, FILEVIEW *pFileView, INT iFileSize, BOOL *pbIsFAT)
{
    #if defined(_GDIPLUS_)

    return CreateMemoryMappedSection(pwszFileName, pFileView, iFileSize);

    #else // !_GDIPLUS_

    UNICODE_STRING            UnicodeString;
    OBJECT_ATTRIBUTES         ObjectAttributes;
    NTSTATUS                  NtStatus;
    HANDLE                    FileHandle = 0;
    IO_STATUS_BLOCK           IoStatusBlock;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    FILE_BASIC_INFORMATION    FileBasicInfo;
    LARGE_INTEGER             DesiredSize;
    FILEVIEW                  FileView;

    RtlZeroMemory(pFileView, sizeof(FILEVIEW));
    RtlZeroMemory(&FileView, sizeof(FILEVIEW));

    RtlInitUnicodeString(&UnicodeString, pwszFileName);

    BOOLEAN oldErrorState = IoSetThreadHardErrorMode(FALSE);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        0);

    if (iFileSize)
    {
        NtStatus = IoCreateFile(
                       &FileHandle,
                       FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       0,
                       FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ
                           | FILE_SHARE_WRITE
                           | FILE_SHARE_DELETE,
                       FILE_OPEN_IF,
                       FILE_SYNCHRONOUS_IO_ALERT,
                       0,
                       0,
                       CreateFileTypeNone,
                       NULL,
                       IO_FORCE_ACCESS_CHECK |     // Ensure the user has access to the file
                       IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                       IO_CHECK_CREATE_PARAMETERS);
    }
    else
    {
        // Here is the code for reference NtOpenFile 
        // File locates it at ..\ntos\io\open.c
        // 
        NtStatus = IoCreateFile(
                       &FileHandle,
                       FILE_GENERIC_READ 
                        | FILE_GENERIC_EXECUTE
                        | SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       0,
                       FILE_ATTRIBUTE_NORMAL,
                       FILE_SHARE_READ,
                       FILE_OPEN,       // Flag for file open.
                       FILE_SYNCHRONOUS_IO_ALERT,
                       0,
                       0,
                       CreateFileTypeNone,
                       NULL,
                       IO_FORCE_ACCESS_CHECK |     // Ensure the user has access to the file
                       IO_NO_PARAMETER_CHECKING |  // All of the buffers are kernel buffers
                       IO_CHECK_CREATE_PARAMETERS);

    }

    IoSetThreadHardErrorMode(oldErrorState);

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    NtStatus = ZwQueryInformationFile(
                   FileHandle,
                   &IoStatusBlock,
                   &FileStandardInfo,
                   sizeof(FILE_STANDARD_INFORMATION),
                   FileStandardInformation);

    if (!NT_SUCCESS(NtStatus))
    {
        ZwClose(FileHandle);
        return(FALSE);
    }

    // Get the time stamp

    NtStatus = ZwQueryInformationFile(
                   FileHandle,
                   &IoStatusBlock,
                   &FileBasicInfo,
                   sizeof(FileBasicInfo),
                   FileBasicInformation);

    if (!NT_SUCCESS(NtStatus))
    {
        ZwClose(FileHandle);
        return(FALSE);
    }

    FileView.LastWriteTime = FileBasicInfo.LastWriteTime;
    FileView.bLastUpdated = TRUE;

    if (pbIsFAT)
    {
        struct
        {
            FILE_FS_ATTRIBUTE_INFORMATION Info;
            WCHAR   Buffer[MAX_PATH];
        } FileFsAttrInfoBuffer;

        *pbIsFAT = FALSE;

        NtStatus = ZwQueryVolumeInformationFile(
                       FileHandle,
                       &IoStatusBlock,
                       &FileFsAttrInfoBuffer.Info,
                       sizeof(FileFsAttrInfoBuffer),
                       FileFsAttributeInformation);
    
        if (!NT_SUCCESS(NtStatus))
        {
            ZwClose(FileHandle);
            return(FALSE);
        }
    
        if (!_wcsnicmp((LPWSTR)FileFsAttrInfoBuffer.Info.FileSystemName, L"FAT", 3))
        {
            *pbIsFAT = TRUE;
        }
    }
    
    // Note that we must call ZwSetInformation even in the case where iFileSize
    // is -1.  By doing so we force the file time to change.  It turns out that
    // just mapping a file for write (and writing to the section) is not enough
    // to cause the file time to change.

    if (iFileSize)
    {
        if (iFileSize > 0)
        {
            DesiredSize.LowPart = (ULONG) iFileSize;
        }
        else
        {
            DesiredSize.LowPart = FileStandardInfo.EndOfFile.LowPart;
        }

        DesiredSize.HighPart = 0;

        //
        // set the file length to the requested size
        //

        NtStatus = ZwSetInformationFile(
                       FileHandle,
                       &IoStatusBlock,
                       &DesiredSize,
                       sizeof(DesiredSize),
                       FileEndOfFileInformation);

        if (!NT_SUCCESS(NtStatus))
        {
            ZwClose(FileHandle);
            return(FALSE);
        }

        //
        // set FileStandardInfo and fall through to the case where we called
        // ZwQueryInfo to get the file size
        //

        FileStandardInfo.EndOfFile.LowPart = (ULONG) DesiredSize.LowPart;
        FileStandardInfo.EndOfFile.HighPart = 0;
    }

    if (FileStandardInfo.EndOfFile.HighPart)
    {
        ZwClose(FileHandle);
        return(FALSE);
    }

    FileView.cjView = FileStandardInfo.EndOfFile.LowPart;

    InitializeObjectAttributes(
        &ObjectAttributes,
        0,
        OBJ_KERNEL_HANDLE,
        0,
        0);

    NtStatus = ZwWin32CreateSection(
                   &FileView.pSection,
                   SECTION_ALL_ACCESS,
                   &ObjectAttributes,
                   &FileStandardInfo.EndOfFile,
                   (iFileSize) ? PAGE_READWRITE : PAGE_EXECUTE_READ,
                   SEC_COMMIT,
                   FileHandle,
                   0,
                   TAG_SECTION_CREATESECTION);

    ZwClose(FileHandle);

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    RtlCopyMemory(pFileView, &FileView, sizeof(FileView));

    return(TRUE);

    #endif // !_GDIPLUS_
}


/******************************Public*Routine******************************\
* vUnmapFile
*
* Unmaps file whose view is based at pv
*
* Called by:
*
*   EngMapFontFile
*   EngUnmapFontFile
*   GetTypeOneFontList
*
*  14-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vUnmapFile(PFILEVIEW pfv)
{
    NTSTATUS NtStatus;

#if defined(_GDIPLUS_)

    NtStatus = UnmapViewInProcessSpace(pfv->pvKView);

#elif defined(_HYDRA_)
    // MmUnmapViewInSessionSpace is internally promoted to
    // MmUnmapViewInSystemSpace on non-Hydra systems.

    NtStatus = Win32UnmapViewInSessionSpace(pfv->pvKView);
#else
    MmUnmapViewInSystemSpace(pfv->pvKView);
#endif

#if DBG && defined(_HYDRA_)
    if ((!G_fConsole) && (NT_SUCCESS(NtStatus)))
    {
        DebugGreTrackRemoveMapView(pfv->pvKView);
    }
#endif

    if (pfv->pvViewFD == 0)
    {
        DEREFERENCE_FONTVIEW_SECTION(pfv->pSection);
    }
    
    pfv->bLastUpdated = FALSE;
}

/******************************Public*Routine******************************\
* GetModuleHandleAndIncrementRefcount
*
*   This function searches through the GreEngLoadModuleAllocList to see
*   if a module has been loaded already, and if so it returns a handle
*   to that module (and increments the reference count).
*
* Arguments:
*
*     pwsz -- The name of the module
*
* Return Value:
*
*     a FILEVIEW pointer if the module has been loaded already, NULL
*     otherwise.
*
* History:
*
*    21-Apr-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

HANDLE
GetModuleHandleAndIncrementRefcount(
    PWSZ pwsz
    )
{
    HANDLE hRet=NULL;

    if (GreEngLoadModuleAllocListLock) GreAcquireSemaphore(GreEngLoadModuleAllocListLock);

    PLIST_ENTRY pNextEntry = GreEngLoadModuleAllocList.Flink;

    //
    // Loop through the loaded modules looking for pwsz
    //

    while ((pNextEntry != &GreEngLoadModuleAllocList) && !(hRet))
    {
        PWSZ pwszModuleName = (PWSZ) (((PBYTE) pNextEntry) + sizeof(ENGLOADMODULEHDR) -
            ((PENGLOADMODULEHDR)pNextEntry)->cjSize);

        if (_wcsicmp(pwsz, pwszModuleName) == 0)
        {
            ((PENGLOADMODULEHDR)pNextEntry)->cRef++;
            hRet = (HANDLE) (((PBYTE) pNextEntry) + sizeof(ENGLOADMODULEHDR));
        }

        pNextEntry = pNextEntry->Flink;
    }

    if (GreEngLoadModuleAllocListLock) GreReleaseSemaphore(GreEngLoadModuleAllocListLock);

    return hRet;
}



/******************************Public*Routine******************************\
*
* LoadModuleWorkHorse
*
* Note that all allocations are tracked through a linked list maintained
* via the ENGLOADMODULEHDR fields.  This enables us to do just one allocation
* per file even if called multiple times.  The diagram below shows the layout
* of the data structures in memory.
*
*
*
*                  Buffer
* pBaseAlloc --> +------------------+<-|
*                | Module name      |  |
*    pelmNew --> +------------------+  |-cjSize (length of module name
*                | ENGLOADMODULEHDR |  |         plus ENGLOADMODULE header)
*        pfv --> +------------------+<-|
*                | FILEVIEW         |
*                |                  |
*                +------------------+
*
*
* Note that it is theoretically possible for two modules with the same name
* to be mapped twice (to two different virtual addresses), because we don't
* grab the GreEngLoadModuleAllocListLock until late in the code (so if two
* threads enter this function and both pass the search stage before either
* grabs the lock, both would independently get different entries for this
* module).  There are two possible ways to remedy this:
* 1) Grab the lock before the search -- the problem is that this will force
*    us to keep the lock during the call to bMapFile which can take a while
* 2) Search twice, the second time being after the call to bMapFile (and after
*    we obtain the lock).  This is quite ugly, and would force us to free the
*    memory allocated by bMapFile in the scenario described above.
*
* So because neither solution is particularly attractive, we allow the same
* module to be placed multiple times in the list.  In practice this should
* happen very rarely, and shouldn't lead to any major problems (except
* for a minor waste of resources).
*
*
\**************************************************************************/

HANDLE LoadModuleWorkHorse(PWSZ pwsz, INT iSize)
{
    UNICODE_STRING usPath;
    BYTE *pBaseAlloc;
    FILEVIEW *pfv;
    HANDLE hRet = 0;
    ULONGSIZE_T cj = sizeof(FILEVIEW);
    ULONG cjStringLength;

    //
    // NULL names are bad.
    //

    if (wcslen(pwsz) == 0)
    {
        return NULL;
    }

    //
    // First check if this is mapped into kernel memory already
    //

    if (iSize == 0) // Only share on EngLoadModule calls because iSize may not be the same
    {
        if ((hRet = GetModuleHandleAndIncrementRefcount(pwsz)) != NULL)
        {
            return hRet;
        }
    }

    //
    // Get the name of the module length string.  Round up to a multiple of
    // 8 bytes so that the buffer we return will be 8-byte aligned (ENGLOADMODULEHDR is
    // already 8-byte aligned).
    //

    cjStringLength = (wcslen(pwsz) + 1) * sizeof(WCHAR);
    cjStringLength = ((cjStringLength + 7) & (~7));

    //
    // Increase the size of the allocation by the size of the ENGLOADMODULEHDR header
    // plus the length of the string.
    //

    cj += sizeof(ENGLOADMODULEHDR) + cjStringLength;

    if (MakeSystemRelativePath(pwsz, &usPath, FALSE))
    {
        if (pBaseAlloc = (BYTE *) PALLOCMEM(cj, 'lifG'))
        {
            ENGLOADMODULEHDR *pelmNew = (ENGLOADMODULEHDR *) (pBaseAlloc + cjStringLength);
            pfv = (FILEVIEW *) (pelmNew + 1);

            if (bMapFile(usPath.Buffer, pfv, iSize, NULL))
            {
                hRet = pfv;

                //
                // Copy the filename into the buffer
                //

                if (iSize==0)
                {
                    //
                    // EngLoadModule -- share with other calls
                    //

                    wcscpy((PWSZ)pBaseAlloc, pwsz);
                }
                else
                {
                    //
                    // EngLoadModuleForWrite -- don't share because of possible buffer size mismatches
                    // It is possible to code this so that writeable modules would be shared
                    // as well (store size in the ENGLOADMODULEHDR), but I don't think this case
                    // will happen very frequently so the benefit of doing this is very small.
                    //

                    wcscpy((PWSZ)pBaseAlloc, L"");
                }


                //
                // Setup the ENGLOADMODULEHDR
                //

                pelmNew->cRef = 1;
                pelmNew->cjSize = sizeof(ENGLOADMODULEHDR) + cjStringLength;

                //
                // Now add to the tracking list
                //

                if (GreEngLoadModuleAllocListLock) GreAcquireSemaphore(GreEngLoadModuleAllocListLock);

                InsertTailList(&GreEngLoadModuleAllocList, &(pelmNew->list));

                if (GreEngLoadModuleAllocListLock) GreReleaseSemaphore(GreEngLoadModuleAllocListLock);
            }
            else
            {
                VFREEMEM(pBaseAlloc);
            }
        }
        VFREEMEM(usPath.Buffer);
    }

    return(hRet);
}

/*******************************************************************************
*  EngLoadModuleForWrite
*
*  History:
*   4/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

HANDLE EngLoadModuleForWrite(PWSZ pwsz, ULONG cjSizeOfModule)
{
    return(LoadModuleWorkHorse(pwsz, cjSizeOfModule ? cjSizeOfModule : -1));
}

/*******************************************************************************
*  EngLoadModule
*
*  History:
*   4/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

HANDLE EngLoadModule(PWSZ pwsz)
{
    return(LoadModuleWorkHorse(pwsz, 0));
}

/****************************************************************************
*  EngFreeModule()
*
*  History:
*   4/27/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

VOID EngFreeModule(HANDLE h)
{
    ULONG cRef;

    if (h)
    {
        ENGLOADMODULEHDR *pelmVictim = (ENGLOADMODULEHDR *) h;
        pelmVictim--;  // Now it points to the real ENGLOADMODULEHDR

        //
        // Enforce synchronization on the linked list
        //

        if (GreEngLoadModuleAllocListLock) GreAcquireSemaphore(GreEngLoadModuleAllocListLock);

        pelmVictim->cRef--; // Decrement reference count

        //
        // Remove resource if necessary.  Cache cRef in a local variable in case it gets
        // modified by another thread after we exit the critical section.
        //

        if ((cRef=pelmVictim->cRef) == 0)
        {
            RemoveEntryList(&(pelmVictim->list));
        }

        //
        // Restore IRQL level as soon as possible
        //

        if (GreEngLoadModuleAllocListLock) GreReleaseSemaphore(GreEngLoadModuleAllocListLock);

        //
        // If removing resource still need to unmap file and free headers memory
        //

        if (cRef == 0)
        {
            //
            // Dereference section and unmap the file
            //
                vUnmapFile((FILEVIEW *)h);
            //
            // Free allocated memory
            //

            VFREEMEM (((PBYTE) h) - pelmVictim->cjSize);
        }
    }
}

/****************************************************************************
*  PVOID EngMapModule( HANDLE, PULONG )
*
*  History:
*   5/25/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

PVOID EngMapModule(HANDLE h, PULONG pSize)
{
    *pSize=((PFILEVIEW)h)->cjView;
    return(((PFILEVIEW)h)->pvKView);
}

/******************************Public*Routine******************************\
* BOOL EngMapFile
*
* Create or Open a file and map it into system space.  The file is extended or
* truncated according to the cjSize passed in.  If cjSize == 0, the file size
* is unchanged.  The view is always mapped on the entire file.
*
* Parameters
*     IN pwsz    - Name of the file to be mapped.
*                  Filename has to be fully qualified.  ex. L"\\??\\c:\\test.dat"
*     IN cjSize  - Size of the file.
*     OUT iFile  - identifier of the mapped file
*
* Return Value
*     Pointer to the memory view.
*
* History:
*  4-Nov-1996 -by- Lingyun Wang [LingyunW]
*  19-Nov-1998 -by- Lingyun Wang [lingyunw] changed interface
*
* Wrote it.
\**************************************************************************/

PVOID EngMapFile(PWSZ pwsz, ULONG cjSize, ULONG_PTR *piFile)
{
    FILEVIEW *pfv;
    PVOID ReturnValue = 0;

    if (pfv = (FILEVIEW*) PALLOCMEM(sizeof(FILEVIEW), 'lifG'))
    {
        if (bMapFile(pwsz, pfv, cjSize ? cjSize : -1, NULL))
        {
            *piFile = (ULONG_PTR)pfv;
            ReturnValue = pfv->pvKView;
        }
        else
        {
            *piFile = 0;
            VFREEMEM(pfv);
        }
    }
    return(ReturnValue);
}

/******************************Public*Routine******************************\
* BOOL EngUnmapFile
*
* Unmap a view of file in system space
**
* Return Value
*     TRUE
*     FALSE
*
* History:
*  4-Nov-1996 -by- Lingyun Wang [LingyunW]
* Wrote it.
\**************************************************************************/

BOOL EngUnmapFile(ULONG_PTR iFile)
{
    NTSTATUS NtStatus;
    FILEVIEW *pfv = (FILEVIEW *)iFile;

    if (iFile)
    {
         #if defined(_GDIPLUS_)

             NtStatus = UnmapViewInProcessSpace(pfv->pvKView);

         #elif defined(_HYDRA_)
             // MmUnmapViewInSessionSpace is internally promoted to
             // MmUnmapViewInSystemSpace on non-Hydra systems.

             NtStatus = Win32UnmapViewInSessionSpace(pfv->pvKView);
         #else
             MmUnmapViewInSystemSpace(pfv->pvKView);
         #endif

         #if DBG && defined(_HYDRA_)
             if ((!G_fConsole) && (NT_SUCCESS(NtStatus)))
             {
                 DebugGreTrackRemoveMapView(pfv->pvKView);
             }
         #endif

         DEREFERENCE_FONTVIEW_SECTION(pfv->pSection);

         VFREEMEM(pfv);

         return(NT_SUCCESS(NtStatus));

    }
    else
    {
         return (FALSE);
    }

}



/******************************Public*Routine******************************\
* BOOL bIsOneHourDifference()
*
*
* History:
*  15-April-1999 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/

// one tick is 100ns, us = 10 tick, s = 10*1000*1000 tick
// 1hr = 10*1000*1000*60*60

#define ONEHOUR   (10i64*1000i64*1000i64*60i64*60i64)

BOOL bIsOneHourDifference(FILEVIEW *pNew, FILEVIEW *pOld)
{
    LONGLONG   llDifference = pNew->LastWriteTime.QuadPart - pOld->LastWriteTime.QuadPart;

    if(llDifference < 0) llDifference = -llDifference;

    return (llDifference == ONEHOUR ? TRUE : FALSE);
}

/******************************Public*Routine******************************\
*
* bShouldMap // the font file
*
\**************************************************************************/

BOOL bShouldMap(FILEVIEW *pNew, FILEVIEW *pOld, BOOL bIsFAT)
{

    BOOL bMapRet = FALSE;

    if (pOld->LastWriteTime.QuadPart != 0) // file had been mapped in the past
    {
        if (pOld->cjView == pNew->cjView)
        {
        // we consider the new and the old times the "same" if they
        // are literally the same or if on the FAT system they differ by
        // 1 hour which we think is likely the result of the daylight
        // time saving change:

            if
            (
              (pOld->LastWriteTime.QuadPart == pNew->LastWriteTime.QuadPart) ||             
              (bIsFAT && bIsOneHourDifference(pNew, pOld))
              || gbGUISetup
            )
            {
                bMapRet = TRUE;
            }
        }
    }
    else // first time we are attempting to map this file
    {
        bMapRet = TRUE;
    }

    return(bMapRet);
}

/******************************Public*Routine******************************\
*
* bMapRoutine
*
\**************************************************************************/

BOOL bMapRoutine(FONTFILEVIEW *pffv, FILEVIEW *pfv, MAP_MODE Mode, BOOL bIsFAT)
{
    BOOL bKeepIt = bShouldMap(pfv, &pffv->fv, bIsFAT);

    if (bKeepIt)
    {
    //
    // This is the first time that this file has been mapped
    // OR  the file has not really changed since it was mapped
    // last time, however, because the time zone changed and
    // because of the bug in the
    // FAT file system, LastWriteTime is now reported different.

        if (Mode == ModeFD)
        {
            pffv->fv.pvViewFD = pfv->pvViewFD;
        }
        else
        {
            pffv->fv.pvKView = pfv->pvKView;
        }

        pffv->fv.cjView        = pfv->cjView;
        pffv->fv.LastWriteTime = pfv->LastWriteTime;
        pffv->fv.pSection      = pfv->pSection;
        pffv->fv.bLastUpdated  = TRUE;
    }
    else
    {
    // if the size or the time of the last write has changed
    // then someone has switched the file or tampered with it
    //  while we had it unlocked. We will fail the call.

        if (Mode == ModeFD)
        {
            pffv->cRefCountFD -= 1;
            pffv->fv.pvViewFD  = 0;
        }
        else
        {
            pffv->cKRefCount -= 1;   // Restore FONTFILEVIEW
            pffv->fv.pvKView  = 0;   // to original state
        }
        
        pffv->fv.bLastUpdated  = FALSE;
    }
    return(bKeepIt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\mapfile.c ===
/******************************Module*Header*******************************\
* Module Name: mapfile.c
*
* Created: 25-Jun-1992 14:33:45
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "engine.h"
#include "ntnls.h"
#include "stdlib.h"

#include "ugdiport.h"

extern HFASTMUTEX ghfmMemory;

ULONG LastCodePageTranslated = 0;  // I'm assuming 0 is not a valid codepage
PVOID LastNlsTableBuffer = NULL;
CPTABLEINFO LastCPTableInfo;
UINT NlsTableUseCount = 0;

ULONG ulCharsetToCodePage(UINT);

/******************************Public*Routine******************************\
*
* vSort, N^2 alg, might want to replace by qsort
*
* Effects:
*
* Warnings:
*
* History:
*  25-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vSort(
    WCHAR *pwc,  // input buffer with a sorted array of cChar supported WCHAR's
     BYTE *pj,   // input buffer with original ansi values
      INT  cChar
    )
{
    INT i;

    for (i = 1; i < cChar; i++)
    {
    // upon every entry to this loop the array 0,1,..., (i-1) will be sorted

        INT j;
        WCHAR wcTmp = pwc[i];
        BYTE  jTmp  = pj[i];

        for (j = i - 1; (j >= 0) && (pwc[j] > wcTmp); j--)
        {
            pwc[j+1] = pwc[j];
            pj[j+1] = pj[j];
        }
        pwc[j+1] = wcTmp;
        pj[j+1]  = jTmp;
    }
}

/******************************Public*Routine******************************\
*
* cComputeGlyphSet
*
*   computes the number of contiguous ranges supported in a font.
*
*   Input is a sorted array (which may contain duplicates)
*   such as 1 1 1 2 3 4 5 7 8 9 10 10 11 12 etc
*   of cChar unicode code points that are
*   supported in a font
*
*   fills the FD_GLYPSET structure if the pgset buffer is provided
*
* History:
*  25-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

INT cComputeGlyphSet(
    WCHAR         *pwc,       // input buffer with a sorted array of cChar supported WCHAR's
    BYTE          *pj,        // input buffer with original ansi values
    INT           cChar,
    INT           cRuns,     // if nonzero, the same as return value
    FD_GLYPHSET  *pgset      // output buffer to be filled with cRanges runs
    )
{
    INT     iRun, iFirst, iFirstNext;
    HGLYPH  *phg, *phgEnd = NULL;
    BYTE    *pjTmp;

    if (pgset != NULL)
    {
        pgset->cjThis  = SZ_GLYPHSET(cRuns,cChar);

    // BUG, BUG

    // this line may seem confusing because 256 characters still fit in a byte
    // with values [0, 255]. The reason is that tt and ps fonts, who otherwise
    // would qualify as an 8 bit report bogus last and first char
    // (win31 compatibility) which confuses our engine.
    // tt and ps drivers therefore, for the purpose of computing glyphsets
    // of tt symbol fonts and ps fonts set firstChar to 0 and LastChar to 255.
    // For now we force such fonts through more general 16bit handle case
    // which does not rely on the fact that chFirst and chLast are correct

        pgset->flAccel = (cChar != 256) ? GS_8BIT_HANDLES : GS_16BIT_HANDLES;
        pgset->cRuns   = cRuns;

    // init the sum before entering the loop

        pgset->cGlyphsSupported = 0;

    // glyph handles are stored at the bottom, below runs:

        phg = (HGLYPH *) ((BYTE *)pgset + (offsetof(FD_GLYPHSET,awcrun) + cRuns * sizeof(WCRUN)));
    }

// now compute cRuns if pgset == 0 and fill the glyphset if pgset != 0

    for (iFirst = 0, iRun = 0; iFirst < cChar; iRun++, iFirst = iFirstNext)
    {
    // find iFirst corresponding to the next range.

        for (iFirstNext = iFirst + 1; iFirstNext < cChar; iFirstNext++)
        {
            if ((pwc[iFirstNext] - pwc[iFirstNext - 1]) > 1)
                break;
        }

        if (pgset != NULL)
        {
            pgset->awcrun[iRun].wcLow    = pwc[iFirst];

            pgset->awcrun[iRun].cGlyphs  =
                (USHORT)(pwc[iFirstNext-1] - pwc[iFirst] + 1);

            pgset->awcrun[iRun].phg      = phg;

        // now store the handles, i.e. the original ansi values

            phgEnd = phg + pgset->awcrun[iRun].cGlyphs;

            for (pjTmp = &pj[iFirst]; phg < phgEnd; phg++,pjTmp++)
            {
                *phg = (HGLYPH)*pjTmp;
            }

            pgset->cGlyphsSupported += pgset->awcrun[iRun].cGlyphs;
        }
    }

#if DBG
    if (pgset != NULL)
        ASSERTGDI(iRun == cRuns, "gdisrv! iRun != cRun\n");
#endif

    return iRun;
}

/******************************Public*Routine******************************\
*
* cUnicodeRangesSupported
*
* Effects:
*
* Warnings:
*
* History:
*  25-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

INT cUnicodeRangesSupported (
      INT  cp,         // code page, not used for now, the default system code page is used
      INT  iFirstChar, // first ansi char supported
      INT  cChar,      // # of ansi chars supported, cChar = iLastChar + 1 - iFirstChar
    WCHAR *pwc,        // input buffer with a sorted array of cChar supported WCHAR's
    BYTE  *pj
    )
{
    BYTE jFirst = (BYTE)iFirstChar;
    INT i;

    USHORT AnsiCodePage, OemCodePage;

    ASSERTGDI((iFirstChar < 256) && (cChar <= 256),
              "gdisrvl! iFirst or cChar\n");

    //
    // fill the array with cCharConsecutive ansi values
    //

    for (i = 0; i < cChar; i++)
    {
        pj[i] = (BYTE)iFirstChar++;
    }

    // If the default code page is DBCS then use 1252, otherwise use
    // use the default code page
    //

    if (IS_ANY_DBCS_CODEPAGE(cp))
    {
    // Suppose we have a system without correspoding DBCS codepage installed.
    // We would still like to load this font.  But we will do so as CP 1252.
    // To do that try to translate one character using DBCS codepage and see if it
    // suceeds.

        if(EngMultiByteToWideChar(cp,&pwc[0],2,&pj[0],1) == -1)
        {
            WARNING("DBCS Codepage not installed using 1252\n");
            cp = 1252;
        }

        for(i = 0; i < cChar; i++)
        {
        // this is a shift-jis charset so we need special handling

            INT Result = EngMultiByteToWideChar(cp,&pwc[i],2,&pj[i],1);
#if DBG
            if (Result == -1) WARNING("gdisrvl! EngMultiByteToWideChar failed\n");
#endif

            if ((Result == -1) || (pwc[i] == 0 && pj[i] != 0))
            {
            // this must have been a DBCS lead byte so just return 0xFFFF or a failure
            // failure of EngMultiByteToWideChar could be cause by low memory condition

                pwc[i] = 0xFFFF;
            }
        }
    }
    else
    {
        INT Result;
        if ((cp == CP_ACP) || (cp == CP_OEMCP))
        {
            RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

            if(IS_ANY_DBCS_CODEPAGE(AnsiCodePage))
            {
                AnsiCodePage = 1252;
            }
        }
        else
        {
            AnsiCodePage = (USHORT)cp;
        }

        Result = EngMultiByteToWideChar(AnsiCodePage,
                                        pwc,
                                        (ULONG)(cChar * sizeof(WCHAR)),
                                        (PCH) pj,
                                        (ULONG) cChar);

        ASSERTGDI(Result != -1, "gdisrvl! EngMultiByteToWideChar failed\n");
    }

    // now subtract the first char from all ansi values so that the
    // glyph handle is equal to glyph index, rather than to the ansi value

    for (i = 0; i < cChar; i++)
    {
        pj[i] -= (BYTE)jFirst;
    }

    // now sort out pwc array and permute pj array accordingly

    vSort(pwc,pj, cChar);

    //
    // compute the number of ranges
    //

    return cComputeGlyphSet (pwc,pj, cChar, 0, NULL);
}

/******************************Private*Routine******************************\
* pcpComputeGlyphset,
*
* Computes the FD_GLYPHSET struct based on chFirst and chLast.  If such a
* FD_GLYPHSET already exists in our global list of FD structs it updates
* the ref count for this FD_GLYPHSET in the global list points pcrd->pcp->pgset
* to it.  Otherwise it makes a new FD_GLYPHSET entry in the global list
* and points pcrd->pcp->pgset to it.
*
*  Thu 03-Dec-1992 -by- Bodin Dresevic [BodinD]
* update: redid them to make them usable in vtfd
*
* History:
*  24-July-1992 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
*
\**************************************************************************/


CP_GLYPHSET *pcpComputeGlyphset(
    CP_GLYPHSET **pcpHead,  // head of the list
           UINT   uiFirst,
           UINT   uiLast,
           BYTE   jCharset
    )
{
    CP_GLYPHSET *pcpTmp;
    CP_GLYPHSET *pcpRet = NULL;

// First we need to see if a FD_GLYPHSET already exists for this first and
// last range.

    for( pcpTmp = *pcpHead;
         pcpTmp != NULL;
         pcpTmp = pcpTmp->pcpNext )
    {
        if((pcpTmp->uiFirstChar == uiFirst) &&
           (pcpTmp->jCharset == jCharset) &&
           (pcpTmp->uiLastChar == uiLast))
            break;
    }
    if( pcpTmp != NULL )
    {
    //
    // We found a match.
    //
        pcpTmp->uiRefCount +=1;

    //
    // We should never have so many references as to wrap around but if we ever
    // do we must fail the call.
    //
        if( pcpTmp->uiRefCount == 0 )
        {
            WARNING("BMFD!Too many references to glyphset\n");
            pcpRet = NULL;
        }
        else
        {
            pcpRet = pcpTmp;
        }
    }
    else
    {
    //
    // We need to allocate a new CP_GLYPHSET
    // For SYMBOL_CHARSET, it also needs to cover xf020 to xf0ff unicode range

        BYTE  aj[2*256-32];
        WCHAR awc[2*256-32];
        INT   cNumRuns;
        BOOL  isSymbol = FALSE;
        UINT  i,j;

        UINT  uiCodePage = (UINT)ulCharsetToCodePage(jCharset);
        UINT  cGlyphs = uiLast - uiFirst + 1;

    // use CP_ACP for SYMBOL_CHARSET

        if (uiCodePage == 42)
        {
            uiCodePage = CP_ACP;
            isSymbol = TRUE;
        }

        cNumRuns = cUnicodeRangesSupported(
            uiCodePage,
            uiFirst,
            cGlyphs,
            awc,aj);

        if (isSymbol)
        {
        // add range subset of a range [f020, f0ff]

            for (i = uiFirst, j = cGlyphs; i< (uiFirst+cGlyphs); i++)
            {
            // if i < 0x20, we do not report the glyph in f020-f0ff range, it has been reported already in the current code page range

                if (i >= 0x20)
                {
                    awc[j] = 0xf000 + i;
                    aj[j] = i - uiFirst;
                    j++;
                }
            }

        // make sure we resort if needed

            if (awc[cGlyphs-1] > 0xf020)
                vSort(awc,aj,j);

            if (cGlyphs != j)
            {
                cNumRuns++;
                cGlyphs = j;
            }
        }

        if ( (pcpTmp =  (CP_GLYPHSET*)
                (PALLOCNOZ((SZ_GLYPHSET(cNumRuns,cGlyphs) +
                               offsetof(CP_GLYPHSET,gset)),
                           'slgG'))
            ) == (CP_GLYPHSET*) NULL)
        {
            WARNING("BMFD!pcpComputeGlyphset memory allocation error.\n");
            pcpRet = NULL;
        }
        else
        {
            pcpTmp->uiRefCount = 1;
            pcpTmp->uiFirstChar = uiFirst;
            pcpTmp->uiLastChar = uiLast;
            pcpTmp->jCharset = jCharset;

        // Fill in the Glyphset structure

            cComputeGlyphSet(awc,aj, cGlyphs, cNumRuns, &pcpTmp->gset);

        // Insert at beginning of list

            pcpTmp->pcpNext = *pcpHead;
            *pcpHead = pcpTmp;

        // point CVTRESDATA to new CP_GLYPHSET

            pcpRet = pcpTmp;
        }
    }

    return pcpRet;
}

/***************************************************************************
 * vUnloadGlyphset( PCP pcpTarget )
 *
 * Decrements the ref count of a CP_GLYPHSET and unloads it from the global
 * list of CP_GLYPHSETS if the ref count is zero.
 *
 * IN
 *  PCP pcpTarget pointer to CP_GLYPHSET to be unloaded or decremented
 *
 *  History
 *
 *  Thu 03-Dec-1992 -by- Bodin Dresevic [BodinD]
 * update: redid them to make them usable in vtfd
 *
 *  7-25-92 Gerrit van Wingerden [gerritv]
 *  Wrote it.
 *
 ***************************************************************************/

VOID vUnloadGlyphset(
    CP_GLYPHSET **pcpHead,
    CP_GLYPHSET *pcpTarget
    )
{
    CP_GLYPHSET *pcpLast, *pcpCurrent;

    if( *pcpHead == NULL )
    {
        WARNING1("vUnloadGlyphset called with NULL Head\n");
        return;
    }

    pcpCurrent = *pcpHead;
    pcpLast = NULL;

//
// Find the right CP_GLYPSHET
//
    while( 1 )
    {
        ASSERTGDI( pcpCurrent != NULL, "CP_GLYPHSET list problem.\n" );
        if(  pcpCurrent == pcpTarget )
            break;
        pcpLast = pcpCurrent;
        pcpCurrent = pcpCurrent->pcpNext;
    }

    if( --pcpCurrent->uiRefCount == 0 )
    {
    //
    // We need to deallocate and remove from list
    //
        if( pcpLast == NULL )
            *pcpHead = pcpCurrent->pcpNext;
        else
            pcpLast->pcpNext = pcpCurrent->pcpNext;

        VFREEMEM(pcpCurrent);
    }
}


PVOID __nw(unsigned int ui)
{
    DONTUSE(ui);
    RIP("Bogus __nw call");
    return(NULL);
}

VOID __dl(PVOID pv)
{
    DONTUSE(pv);
    RIP("Bogus __dl call");
}

// the definition of this variable is in ntgdi\inc\hmgshare.h

CHARSET_ARRAYS

/******************************Public*Routine******************************\
*
* ULONG ulCharsetToCodePage(UINT uiCharSet)
*
*
* Effects: figure out which code page to unicode translation table
*          should be used for this realization
*
* History:
*  31-Jan-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG ulCharsetToCodePage(UINT uiCharSet)
{
    int i;

    if (uiCharSet != OEM_CHARSET)
    {
        for (i = 0; i < NCHARSETS; i++)
        {
            if (charsets[i] == uiCharSet)
                return codepages[i];
        }

    // in case of some random charset
    // (this is likely an old bm or vecrot font) we will just use the current
    // global code page translation table. This is enough to ensure
    // the correct round trip: ansi->unicode->ansi

    // if CP_ACP is a DBCS code page then we better use 1252 to ensure
    // proper rountrip conversion

        return( gbDBCSCodePage ? 1252 : CP_ACP);

    }
    else // to make merced compiler happy
    {
        return CP_OEMCP;
    }

}

// inverse function

VOID vConvertCodePageToCharSet(WORD src, DWORD *pfsRet, BYTE *pjRet)
{
    UINT i;


    *pjRet = ANSI_CHARSET;
    *pfsRet = FS_LATIN1;

    for (i = 0; i < nCharsets; i++)
    {
        if ( codepages[i] == src )
        {
           // cs.ciACP      = src ;
           // cs.ciCharset  = charsets[i] ;

           *pfsRet = fs[i];
           *pjRet = (BYTE)charsets[i] ;

            break;
        }
    }
}

/****************************************************************************
 * LONG EngParseFontResources
 *
 * This routine takes a handle to a mapped image and returns an array of
 * pointers to the base of all the font resources in that image.
 *
 * Parameters
 *
 * HANDLE hFontFile -- Handle (really a pointer) to a FONTFILEVIEW
 *        image in which the fonts are to be found.
 * ULONG BufferSize -- Number of entries that ppvResourceBases can hold.
 * PVOID *ppvResourceBases -- Buffer to hold the array of pointers to font
 *        resources.  If NULL then only the number of resources is returned,
 *        and this value is ignored.
 *
 * Returns
 *
 * Number of font resources in the image or 0 if error or none.
 *
 * History
 *   7-3-95 Gerrit van Wingerden [gerritv]
 *   Wrote it.
 *
 ****************************************************************************/

PVOID EngFindResourceFD(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize);


ULONG cParseFontResources(
    HANDLE  hFontFile,
    PVOID  **ppvResourceBases)
{
    PIMAGE_DOS_HEADER pDosHeader;
    NTSTATUS Status;
    ULONG_PTR IdPath[ 1 ];
    INT i;
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PVOID pvImageBase;
    INT cEntries = 0;

    // Fail call if this is a bogus DOS image without an NE header.

    pDosHeader = (PIMAGE_DOS_HEADER)((PFONTFILEVIEW)hFontFile)->fv.pvViewFD;
    if (pDosHeader->e_magic == IMAGE_DOS_SIGNATURE &&
        (ULONG)(pDosHeader->e_lfanew) > ((PFONTFILEVIEW)hFontFile)->fv.cjView) {
        TRACE_FONT(("cParseFontResources: Cant map bogus DOS image files for fonts\n"));
        return 0;
    }

    // the LDR routines expect a one or'd in if this file mas mapped as an
    // image

    pvImageBase = (PVOID) (((ULONG_PTR) ((PFONTFILEVIEW) hFontFile)->fv.pvViewFD)|1);

    // Later on we'll call EngFindResource which expects a handle to FILEVIEW
    // struct.  It really just grabs the pvView field from the structure so
    // make sure that pvView field is the same place in both FILEVIEW and
    // FONTFILEVIEW structs


    IdPath[0] = 8;  // 8 is RT_FONT

    Status = LdrFindResourceDirectory_U(pvImageBase,
                                        IdPath,
                                        1,
                                        &ResourceDirectory);

    if (NT_SUCCESS( Status ))
    {
        // For now we'll assume that the only types of FONT entries will be Id
        // entries.  If for some reason this turns out not to be the case we'll
        // have to add more code (see windows\base\module.c) under the FindResource
        // function to get an idea how to do this.

        ASSERTGDI(ResourceDirectory->NumberOfNamedEntries == 0,
                  "EngParseFontResources: NamedEntries in font file.\n");

        *ppvResourceBases = (PVOID *) EngAllocMem(FL_ZERO_MEMORY,ResourceDirectory->NumberOfIdEntries * sizeof(PVOID *),'dfmB');

        if (*ppvResourceBases)
        {

            PVOID *ppvResource = *ppvResourceBases;

            cEntries = ResourceDirectory->NumberOfIdEntries;

            try
            {
                ResourceDirectoryEntry =
                  (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);

                for (i=0; i < cEntries ; ResourceDirectoryEntry++, i++ )
                {

                    DWORD dwSize;

                    *ppvResource = EngFindResourceFD(hFontFile,
                                                   ResourceDirectoryEntry->Id,
                                                   8, // RT_FONT
                                                   &dwSize );

                    if( *ppvResource++ == NULL )
                    {
                        WARNING("EngParseFontResources: EngFindResourceFailed\n");
                        cEntries = -1;
                        break;
                    }
                }

            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                cEntries = 0;
            }
        }
    }

    return(cEntries);

}

/*****************************************************************************\
* MakeSystemRelativePath
*
* Takes a path in X:\...\system32\.... format and makes it into
* \SystemRoot\System32 format so that KernelMode API's can recognize it.
*
* This will ensure security by forcing any image being loaded to come from
* the system32 directory.
*
* The AppendDLL flag indicates if the name should get .dll appended at the end
* (for display drivers coming from USER) if it's not already there.
*
\*****************************************************************************/

BOOL MakeSystemRelativePath(
    LPWSTR pOriginalPath,
    PUNICODE_STRING pUnicode,
    BOOL bAppendDLL
    )
{
    LPWSTR pOriginalEnd;
    ULONG OriginalLength = wcslen(pOriginalPath);
    ULONG cbLength = OriginalLength * sizeof(WCHAR) +
                     sizeof(L"\\SystemRoot\\System32\\");
    ULONG tmp;

    tmp = (sizeof(L".DLL") / sizeof (WCHAR) - 1);

    //
    // Given append = TRUE, we check if we really need to append.
    // (printer drivers with .dll come through LDEVREF which specifies TRUE)
    //

    if (bAppendDLL)
    {
        if ((OriginalLength >= tmp) &&
            (!_wcsnicmp(pOriginalPath + OriginalLength - tmp,
                       L".DLL",
                       tmp)))
        {
            bAppendDLL = FALSE;
        }
        else
        {
            cbLength += tmp * sizeof(WCHAR);
        }
    }

    pUnicode->Length = 0;
    pUnicode->MaximumLength = (USHORT) cbLength;

    if (pUnicode->Buffer = PALLOCNOZ(cbLength, 'liFG'))
    {
        //
        // First parse the input string for \System32\.  We parse from the end
        // of the string because some weirdo could have \System32\Nt\System32
        // as his/her root directory and this would throw us off if we scanned
        // from the front.
        //
        // It should only (and always) be printer drivers that pass down
        // fully qualified path names.
        //

        tmp = (sizeof(L"\\system32\\") / sizeof(WCHAR) - 1);


        for (pOriginalEnd = pOriginalPath + OriginalLength - tmp;
             pOriginalEnd >= pOriginalPath;
             pOriginalEnd --)
        {
            if (!_wcsnicmp(pOriginalEnd ,
                          L"\\system32\\",
                          tmp))
            {
                //
                // We found the system32 in the string.
                // Lets update the location of the string.
                //

                pOriginalPath = pOriginalEnd + tmp;

                break;
            }
        }

        //
        // Now put \SystemRoot\System32\ at the front of the name and append
        // the rest at the end
        //

        RtlAppendUnicodeToString(pUnicode, L"\\SystemRoot\\System32\\");
        RtlAppendUnicodeToString(pUnicode, pOriginalPath);

        if (bAppendDLL)
        {
            RtlAppendUnicodeToString(pUnicode, L".dll");
        }

        return (TRUE);
    }

    return (FALSE);
}

/*****************************************************************************\
* MakeSystemDriversRelativePath
*
* Takes a path in X:\...\system32\.... format and makes it into
* \SystemRoot\System32\Drivers format so that KernelMode API's can recognize it.
*
* This will ensure security by forcing any image being loaded to come from
* the system32 directory.
*
* The AppendDLL flag indicates if the name should get .dll appended at the end
* (for display drivers coming from USER) if it's not already there.
*
\*****************************************************************************/

BOOL MakeSystemDriversRelativePath(
    LPWSTR pOriginalPath,
    PUNICODE_STRING pUnicode,
    BOOL bAppendDLL
    )
{
    LPWSTR pOriginalEnd;
    ULONG OriginalLength = wcslen(pOriginalPath);
    ULONG cbLength = OriginalLength * sizeof(WCHAR) +
                     sizeof(L"\\SystemRoot\\System32\\Drivers");
    ULONG tmp;

    tmp = (sizeof(L".DLL") / sizeof (WCHAR) - 1);

    //
    // Given append = TRUE, we check if we really need to append.
    // (printer drivers with .dll come through LDEVREF which specifies TRUE)
    //

    if (bAppendDLL)
    {
        if ((OriginalLength >= tmp) &&
            (!_wcsnicmp(pOriginalPath + OriginalLength - tmp,
                       L".DLL",
                       tmp)))
        {
            bAppendDLL = FALSE;
        }
        else
        {
            cbLength += tmp * sizeof(WCHAR);
        }
    }

    pUnicode->Length = 0;
    pUnicode->MaximumLength = (USHORT) cbLength;

    if (pUnicode->Buffer = PALLOCNOZ(cbLength, 'liFG'))
    {
        //
        // First parse the input string for \System32\Drivers. We parse from the end
        // of the string because some weirdo could have \System32\Nt\System32
        // as his/her root directory and this would throw us off if we scanned
        // from the front.
        //
        // It should only (and always) be printer drivers that pass down
        // fully qualified path names.
        //

        tmp = (sizeof(L"\\system32\\Drivers") / sizeof(WCHAR) - 1);


        for (pOriginalEnd = pOriginalPath + OriginalLength - tmp;
             pOriginalEnd >= pOriginalPath;
             pOriginalEnd --)
        {
            if (!_wcsnicmp(pOriginalEnd ,
                          L"\\system32\\Drivers",
                          tmp))
            {
                //
                // We found the system32 in the string.
                // Lets update the location of the string.
                //

                pOriginalPath = pOriginalEnd + tmp;

                break;
            }
        }

        //
        // Now put \SystemRoot\System32\Drivers\ at the front of the name and append
        // the rest at the end
        //

        RtlAppendUnicodeToString(pUnicode, L"\\SystemRoot\\System32\\Drivers\\");
        RtlAppendUnicodeToString(pUnicode, pOriginalPath);

        if (bAppendDLL)
        {
            RtlAppendUnicodeToString(pUnicode, L".dll");
        }

        return (TRUE);
    }

    return (FALSE);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetFilePath
*
\**************************************************************************/

BOOL EngGetFilePath(HANDLE h, WCHAR (*pDest)[MAX_PATH+1])
{
    wchar_t *pSrc = ((PFONTFILEVIEW) h)->pwszPath;

    if ( pSrc )
    {
        wcscpy((wchar_t*) pDest, pSrc );
    }
    return( pSrc != 0 );
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetFileChangeTime
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

BOOL EngGetFileChangeTime(
    HANDLE          h,
    LARGE_INTEGER   *pChangeTime)
{

    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_BASIC_INFORMATION fileBasicInfo;
    PVOID sectionObject = NULL;
    PFONTFILEVIEW pffv = (PFONTFILEVIEW) h;
    ULONG viewSize;

    if(pffv->pwszPath)
    {
        if (pffv->fv.bLastUpdated)
        {
            *pChangeTime = pffv->fv.LastWriteTime;
            bResult = TRUE;
        }
        else
        {
            RtlInitUnicodeString(&unicodeString,
                                 pffv->pwszPath
                                 );


            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       (HANDLE) NULL,
                                       (PSECURITY_DESCRIPTOR) NULL);

            ntStatus = ZwCreateFile(&fileHandle,
                                    FILE_READ_ATTRIBUTES,
                                    &objectAttributes,
                                    &ioStatusBlock,
                                    0,
                                    FILE_ATTRIBUTE_NORMAL,
                                    0,
                                    FILE_OPEN_IF,
                                    FILE_SYNCHRONOUS_IO_ALERT,
                                    0,
                                    0);


            if(NT_SUCCESS(ntStatus))
            {
                ntStatus = ZwQueryInformationFile(fileHandle,
                                                  &ioStatusBlock,
                                                  &fileBasicInfo,
                                                  sizeof(FILE_BASIC_INFORMATION),
                                                  FileBasicInformation);

                if (NT_SUCCESS(ntStatus))
                {
                    *pChangeTime = fileBasicInfo.LastWriteTime;
                    bResult = TRUE;
                }
                else
                {
                    WARNING("EngGetFileTime:QueryInformationFile failed\n");
                }

                ZwClose(fileHandle);

            }
            else
            {
                WARNING("EngGetFileTime:Create/Open file failed\n");
            }
        }
    }
    else
    {
    // This is a remote font.  In order for ATM to work we must always return
    // the same time for a remote font.  One way to do this is to return a zero
    // time for all remote fonts.

        pChangeTime->HighPart = pChangeTime->LowPart = 0;
        bResult = TRUE;
    }

    return(bResult);
}

/*******************************************************************************
*  EngFindResource
*
*   This function returns a size and ptr to a resource in a module.
*
*  History:
*   4/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

PVOID pvFindResource(
    PVOID  pView,
    PVOID  pViewEnd,
    int    iName,
    int    iType,
    PULONG pulSize)
{
    NTSTATUS Status;
    PVOID p,pRet;
    ULONG_PTR IdPath[ 3 ];

    IdPath[0] = (ULONG_PTR) iType;
    IdPath[1] = (ULONG_PTR) iName;
    IdPath[2] = (ULONG_PTR) 0;

// add one to pvView to let LdrFindResource know that this has been mapped as a
// datafile

    Status = LdrFindResource_U( pView,
                                IdPath,
                                3,
                                (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                              );

    if( !NT_SUCCESS( Status ) )
    {

        WARNING("EngFindResource: LdrFindResource_U failed.\n");
        return(NULL);
    }

    pRet = NULL;

    Status = LdrAccessResource( pView,
                                (PIMAGE_RESOURCE_DATA_ENTRY) p,
                                &pRet,
                                pulSize );

    if( !NT_SUCCESS( Status ) )
    {
        WARNING("EngFindResource: LdrAccessResource failed.\n" );
    }

    return( pRet < pViewEnd ? pRet : NULL );

}

PVOID EngFindResourcePlainOrFD(
    PVOID  pvViewBase,
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize
    )
{
    PVOID pView,pViewEnd;

    pView = (PVOID) (((ULONG_PTR) pvViewBase)+1);
    pViewEnd = (PVOID) ((PBYTE)pvViewBase + ((PFILEVIEW) h)->cjView);

    return pvFindResource(pView, pViewEnd, iName, iType, pulSize);
}

PVOID EngFindResource(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize)
{
    return EngFindResourcePlainOrFD(((PFILEVIEW) h)->pvKView, h, iName, iType, pulSize);
}

PVOID EngFindResourceFD(
    HANDLE h,
    int    iName,
    int    iType,
    PULONG pulSize)
{
    return EngFindResourcePlainOrFD(((PFILEVIEW) h)->pvViewFD, h, iName, iType, pulSize);
}


/******************************Public*Routine******************************\
*
* VOID vCheckCharSet(USHORT * pusCharSet)
*
*
* Effects: validate charset in font sub section of the registry
*
* History:
*  27-Jun-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCheckCharSet(FACE_CHARSET *pfcs, const WCHAR * pwsz)
{
    UINT           i;
    UNICODE_STRING String;
    ULONG          ulCharSet = DEFAULT_CHARSET;

    pfcs->jCharSet = DEFAULT_CHARSET;
    pfcs->fjFlags  = 0;

    String.Buffer = (WCHAR*)pwsz;
    String.MaximumLength = String.Length = wcslen(pwsz) * sizeof(WCHAR);

// read the value and compare it against the allowed set of values, if
// not found to be correct return default

    if (RtlUnicodeStringToInteger(&String, 10, &ulCharSet) == STATUS_SUCCESS)
    {
        if (ulCharSet <= 255)
        {
            pfcs->jCharSet = (BYTE)ulCharSet;

            for (i = 0; i < nCharsets; i++)
            {
                if (ulCharSet == charsets[i])
                {
                // both jCharSet and fjFlags are set correctly, can exit

                    return;
                }
            }
        }
    }

// If somebody entered the garbage in the Font Substitution section of "win.ini"
// we will mark this as a "garbage charset" by setting the upper byte in the
// usCharSet field. I believe that it is Ok to have garbage charset in the
// value name, that is on the left hand side of the substitution entry.
// This may be whatever garbage the application is passing to the
// system. But the value on the right hand side, that is in value data, has to
// be meaningfull, for we need to know which code page translation table
// we should use with this font.

    pfcs->fjFlags |= FJ_GARBAGECHARSET;
}

/******************************Public*Routine******************************\
*
*   EngComputeGlyphSet
*
\**************************************************************************/

FD_GLYPHSET *EngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    )
{
           BYTE *cbuf;
            INT  cRuns;
          ULONG  ByteCount;
          WCHAR *wcbuf;
    FD_GLYPHSET *pGlyphSet = 0;

    if ( 0 <= cChars && cChars < 65536 )
    {
        wcbuf = (WCHAR *) PALLOCMEM(cChars * (sizeof(WCHAR) + sizeof(BYTE)),'slgG');
        if ( wcbuf )
        {
            cbuf = (BYTE *) &wcbuf[cChars];

            cRuns = cUnicodeRangesSupported(
                        nCodePage,
                        nFirstChar,
                        cChars,
                        wcbuf,
                        cbuf);

            ByteCount = SZ_GLYPHSET(cRuns, cChars);

        // Allocate via EngAllocMem instead of PALLOCMEM because driver
        // will free via EngAllocFree.

            pGlyphSet = (FD_GLYPHSET*) EngAllocMem(0, ByteCount,'slgG');

            if ( pGlyphSet )
            {
                cComputeGlyphSet(
                    wcbuf,
                    cbuf,
                    cChars,
                    cRuns,
                    pGlyphSet
                    );
            }
            VFREEMEM( wcbuf );
        }
    }

    return( pGlyphSet );
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vMoveFD_GLYPHSET
*
* Routine Description:
*
*   Copies an FD_GLYPHSET from one location to another. The pointers
*   in the destination are fixed up.
*
* Arguments:
*
*   pgsDst  pointer to destination FD_GLYPHSET
*
*   pgsSrc  pointer to source FD_GLYPHSET
*
* Called by:
*
*   bComputeGlyphSet
*
* Return Value:
*
*   none
*
\**************************************************************************/

void vMoveFD_GLYPHSET(FD_GLYPHSET *pgsDst, FD_GLYPHSET *pgsSrc)
{
    char *pSrc, *pSrcLast, *pDst;
    ULONG_PTR dp;

    //
    // move the structure
    //

    RtlCopyMemory(pgsDst, pgsSrc, pgsSrc->cjThis);

    //
    // if necessary, fix up the pointers
    //

    if (!(pgsSrc->flAccel & GS_UNICODE_HANDLES ))
    {
        pSrc     = (char*) &pgsSrc->awcrun[0].phg;
        pDst     = (char*) &pgsDst->awcrun[0].phg;
        pSrcLast = pSrc + sizeof(WCRUN) * pgsSrc->cRuns;
        dp = pDst - pSrc;
        for ( ; pSrc < pSrcLast; pSrc += sizeof(WCRUN), pDst += sizeof(WCRUN))
        {
            *(char**)pDst = *(char**)pSrc + dp;
        }
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   bComputeGlyphSet
*
* Routine Description:
*
*   This procedure provides safe access to GreComputeGlyphSet from user
*   mode. All addresses supplied by the caller, except for pCall, are
*   probed and access is surrounded by try/except pairs.
*
* Arguments:
*
*   pCall       a pointer to a GDICALL structure in kernel mode. This is
*               a copy of the user mode structure passed to NtGdiCall.
*
* Called by:
*
*   NtGdiCall
*
* Return Value:
*
\**************************************************************************/

BOOL bComputeGlyphSet(GDICALL *pCall)
{
    extern VOID vMoveFD_GLYPHSET( FD_GLYPHSET *pDst, FD_GLYPHSET *pSrc);
    static FD_GLYPHSET *pGlyphSet;

    ASSERTGDI(pCall->Id == ComputeGlyphSet_,"pCall->Id == ComputeGlyphSet_\n");

    pCall->ComputeGlyphSetArgs.ReturnValue = FALSE;

    if ( pCall->ComputeGlyphSetArgs.ppGlyphSet == 0 )
    {
        if ( pCall->ComputeGlyphSetArgs.ByteCount == 0 )
        {
            if ( pGlyphSet == 0 )
            {
                pGlyphSet =
                    EngComputeGlyphSet(
                        pCall->ComputeGlyphSetArgs.nCodePage,
                        pCall->ComputeGlyphSetArgs.nFirstChar,
                        pCall->ComputeGlyphSetArgs.cChars
                        );
                if ( pGlyphSet )
                {
                    pCall->ComputeGlyphSetArgs.ppGlyphSet  = &pGlyphSet;
                    pCall->ComputeGlyphSetArgs.ByteCount   = pGlyphSet->cjThis;
                    pCall->ComputeGlyphSetArgs.ReturnValue = TRUE;
                }
            }
            else
            {
                VFREEMEM( pGlyphSet );
                pGlyphSet = 0;
            }
        }
    }
    else if (pCall->ComputeGlyphSetArgs.ppGlyphSet == &pGlyphSet && pGlyphSet != 0)
    {
        pCall->ComputeGlyphSetArgs.ReturnValue = TRUE;
        try
        {
            ProbeForWrite(
                pCall->ComputeGlyphSetArgs.pGlyphSet
              , pGlyphSet->cjThis
              , 8
              );
            vMoveFD_GLYPHSET(
                pCall->ComputeGlyphSetArgs.pGlyphSet
              , pGlyphSet
                );
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            pCall->ComputeGlyphSetArgs.ReturnValue = FALSE;
        }
        VFREEMEM( pGlyphSet );
        pGlyphSet = 0;
    }

    return( pCall->ComputeGlyphSetArgs.ReturnValue );
}


#define NLS_TABLE_KEY \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\CodePage"

BOOL GetNlsTablePath(
    UINT CodePage,
    PWCHAR PathBuffer
)
/*++

Routine Description:

  This routine takes a code page identifier, queries the registry to find the
  appropriate NLS table for that code page, and then returns a path to the
  table.

Arguments;

  CodePage - specifies the code page to look for

  PathBuffer - Specifies a buffer into which to copy the path of the NLS
    file.  This routine assumes that the size is at least MAX_PATH

Return Value:

  TRUE if successful, FALSE otherwise.

Gerrit van Wingerden [gerritv] 1/22/96

--*/
{
    NTSTATUS NtStatus;
    BOOL Result = FALSE;
    HANDLE RegistryKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    RtlInitUnicodeString(&UnicodeString, NLS_TABLE_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);

    if(NT_SUCCESS(NtStatus))
    {
        WCHAR *ResultBuffer;
        ULONG BufferSize = sizeof(WCHAR) * MAX_PATH +
          sizeof(KEY_VALUE_FULL_INFORMATION);

        ResultBuffer = PALLOCMEM(BufferSize,'slnG');

        if(ResultBuffer)
        {
            ULONG ValueReturnedLength;
            WCHAR CodePageStringBuffer[20];
            swprintf(CodePageStringBuffer, L"%d", CodePage);

            RtlInitUnicodeString(&UnicodeString,CodePageStringBuffer);

            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) ResultBuffer;

            NtStatus = ZwQueryValueKey(RegistryKeyHandle,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyValueInformation,
                                       BufferSize,
                                       &BufferSize);

            if(NT_SUCCESS(NtStatus))
            {

                swprintf(PathBuffer,L"\\SystemRoot\\System32\\%ws",
                         (WCHAR *)&(KeyValueInformation->Data[0]));
                Result = TRUE;
            }
            else
            {
                WARNING("GetNlsTablePath failed to get NLS table\n");
            }
            VFREEMEM(ResultBuffer);
        }
        else
        {
            WARNING("GetNlsTablePath out of memory\n");
        }

        ZwCloseKey(RegistryKeyHandle);
    }
    else
    {
        WARNING("GetNlsTablePath failed to open NLS key\n");
    }

    return(Result);
}


INT ConvertToAndFromWideCharSymCP(
    IN LPWSTR WideCharString,
    IN INT BytesInWideCharString,
    IN LPSTR MultiByteString,
    IN INT BytesInMultiByteString,
    IN BOOL ConvertToWideChar
)
/*++

Routine Description:

  This routine converts a SB character string to or from a wide char string
  assuming the CP_SYMBOL code page. We simply using the following rules to map
  the single byte char to Unicode:
    0x00->0x1f map to 0x0000->0x001f
    0x20->0xff map to 0xf020->0xf0ff

Return Value:

  Success - The number of bytes in the converted WideCharString
  Failure - -1

Tessiew [Xudong Wu]  Sept/25/97

-- */
{
    INT  cSB, cMaxSB, cWC, cMaxWC;

    if ((BytesInWideCharString && (WideCharString == NULL)) ||
        (BytesInMultiByteString && (MultiByteString == NULL)))
    {
        return 0;
    }

    if (ConvertToWideChar)
    {
        cMaxSB = MIN(BytesInMultiByteString, BytesInWideCharString / (INT)sizeof(WCHAR));

        for (cSB = 0; cSB < cMaxSB; cSB++)
        {
            WideCharString[cSB] = ((BYTE)MultiByteString[cSB] < 0x20) ?
                                    (WCHAR)MultiByteString[cSB] :
                                    (WCHAR)((BYTE)MultiByteString[cSB] | ((WCHAR)(0xf0) << 8));
        }
        return (cMaxSB * sizeof(WCHAR));
    }
    else
    {
        cMaxWC = MIN(BytesInWideCharString / (INT)sizeof(WCHAR), BytesInMultiByteString);

        for (cWC = 0; cWC < cMaxWC; cWC++)
        {
            // there is some error wchar in the string
            // but we still return however many we finished

            if ((WideCharString[cWC] >= 0x0020) &&
                ((WideCharString[cWC] < 0xf020) ||
                 (WideCharString[cWC] > 0xf0ff)))
            {
                return (cWC);
            }

            MultiByteString[cWC] = (BYTE)WideCharString[cWC];
        }

        return (cMaxWC);
    }
}


INT ConvertToAndFromWideChar(
    IN UINT CodePage,
    IN LPWSTR WideCharString,
    IN INT BytesInWideCharString,
    IN LPSTR MultiByteString,
    IN INT BytesInMultiByteString,
    IN BOOL ConvertToWideChar
)
/*++

Routine Description:

  This routine converts a character string to or from a wide char string
  assuming a specified code page.  Most of the actual work is done inside
  RtlCustomCPToUnicodeN, but this routine still needs to manage the loading
  of the NLS files before passing them to the RtlRoutine.  We will cache
  the mapped NLS file for the most recently used code page which ought to
  suffice for out purposes.

Arguments:
  CodePage - the code page to use for doing the translation.

  WideCharString - buffer the string is to be translated into.

  BytesInWideCharString - number of bytes in the WideCharString buffer
    if converting to wide char and the buffer isn't large enough then the
    string in truncated and no error results.

  MultiByteString - the multibyte string to be translated to Unicode.

  BytesInMultiByteString - number of bytes in the multibyte string if
    converting to multibyte and the buffer isn't large enough the string
    is truncated and no error results

  ConvertToWideChar - if TRUE then convert from multibyte to widechar
    otherwise convert from wide char to multibyte

Return Value:

  Success - The number of bytes in the converted WideCharString
  Failure - -1

Gerrit van Wingerden [gerritv] 1/22/96

--*/
{
    NTSTATUS NtStatus;
    USHORT OemCodePage, AnsiCodePage;
    CPTABLEINFO LocalTableInfo;
    PCPTABLEINFO TableInfo = NULL;
    PVOID LocalTableBase = NULL;
    INT BytesConverted = 0;

    ASSERTGDI(CodePage != 0, "EngMultiByteToWideChar invalid code page\n");

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

    // see if we can use the default translation routinte

    if(AnsiCodePage == CodePage)
    {
        if(ConvertToWideChar)
        {
            NtStatus = RtlMultiByteToUnicodeN(WideCharString,
                                              BytesInWideCharString,
                                              &BytesConverted,
                                              MultiByteString,
                                              BytesInMultiByteString);
        }
        else
        {
            NtStatus = RtlUnicodeToMultiByteN(MultiByteString,
                                              BytesInMultiByteString,
                                              &BytesConverted,
                                              WideCharString,
                                              BytesInWideCharString);
        }


        if(NT_SUCCESS(NtStatus))
        {
            return(BytesConverted);
        }
        else
        {
            return(-1);
        }
    }

    if (CodePage == CP_SYMBOL)
    {
        return (ConvertToAndFromWideCharSymCP(WideCharString, BytesInWideCharString,
                    MultiByteString, BytesInMultiByteString, ConvertToWideChar));
    }

    TRACE_FONT(("GreAcquireFastMutex(ghfmMemory) 006\n")); GreAcquireFastMutex(ghfmMemory);

    if(CodePage == LastCodePageTranslated)
    {
        // we can use the cached code page information
        TableInfo = &LastCPTableInfo;
        NlsTableUseCount += 1;
    }

    GreReleaseFastMutex(ghfmMemory); TRACE_FONT(("GreReleaseFastMutex(ghfmMemory) 006\n"));

    if(TableInfo == NULL)
    {
        // get a pointer to the path of the NLS table

        WCHAR NlsTablePath[MAX_PATH];

        if(GetNlsTablePath(CodePage,NlsTablePath))
        {
            UNICODE_STRING UnicodeString;
            IO_STATUS_BLOCK IoStatus;
            HANDLE NtFileHandle;
            OBJECT_ATTRIBUTES ObjectAttributes;

            RtlInitUnicodeString(&UnicodeString,NlsTablePath);

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                       NULL,
                                       NULL);

            NtStatus = ZwCreateFile(&NtFileHandle,
                                    SYNCHRONIZE | FILE_READ_DATA,
                                    &ObjectAttributes,
                                    &IoStatus,
                                    NULL,
                                    0,
                                    FILE_SHARE_READ,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0);

            if(NT_SUCCESS(NtStatus))
            {
                FILE_STANDARD_INFORMATION StandardInfo;

                // Query the object to determine its length.

                NtStatus = ZwQueryInformationFile(NtFileHandle,
                                                  &IoStatus,
                                                  &StandardInfo,
                                                  sizeof(FILE_STANDARD_INFORMATION),
                                                  FileStandardInformation);

                if(NT_SUCCESS(NtStatus) && StandardInfo.EndOfFile.LowPart)
                {
                    UINT LengthOfFile = StandardInfo.EndOfFile.LowPart;

                    LocalTableBase = PALLOCMEM(LengthOfFile,'cwcG');

                    if(LocalTableBase)
                    {
                        // Read the file into our buffer.

                        NtStatus = ZwReadFile(NtFileHandle,
                                              NULL,
                                              NULL,
                                              NULL,
                                              &IoStatus,
                                              LocalTableBase,
                                              LengthOfFile,
                                              NULL,
                                              NULL);

                        if(!NT_SUCCESS(NtStatus))
                        {
                            WARNING("EngMultiByteToWideChar unable to read file\n");
                            VFREEMEM(LocalTableBase);
                            LocalTableBase = NULL;
                        }
                    }
                    else
                    {
                        WARNING("EngMultiByteToWideChar out of memory\n");
                    }
                }
                else
                {
                    WARNING("EngMultiByteToWideChar unable query NLS file\n");
                }

                ZwClose(NtFileHandle);
            }
            else
            {
                WARNING("EngMultiByteToWideChar unable to open NLS file\n");
            }
        }
        else
        {
            WARNING("EngMultiByteToWideChar get registry entry for NLS file failed\n");
        }

        if(LocalTableBase == NULL)
        {
            return(-1);
        }

        // now that we've got the table use it to initialize the CodePage table

        RtlInitCodePageTable(LocalTableBase,&LocalTableInfo);
        TableInfo = &LocalTableInfo;
    }

    // Once we are here TableInfo points to the the CPTABLEINFO struct we want


    if(ConvertToWideChar)
    {
        NtStatus = RtlCustomCPToUnicodeN(TableInfo,
                                         WideCharString,
                                         BytesInWideCharString,
                                         &BytesConverted,
                                         MultiByteString,
                                         BytesInMultiByteString);
    }
    else
    {
        NtStatus = RtlUnicodeToCustomCPN(TableInfo,
                                         MultiByteString,
                                         BytesInMultiByteString,
                                         &BytesConverted,
                                         WideCharString,
                                         BytesInWideCharString);
    }


    if(!NT_SUCCESS(NtStatus))
    {
        // signal failure

        BytesConverted = -1;
    }


    // see if we need to update the cached CPTABLEINFO information

    if(TableInfo != &LocalTableInfo)
    {
        // we must have used the cached CPTABLEINFO data for the conversion
        // simple decrement the reference count

        TRACE_FONT(("GreAcquireFastMutex(ghfmMemory) 007\n")); GreAcquireFastMutex(ghfmMemory);
        NlsTableUseCount -= 1;
        GreReleaseFastMutex(ghfmMemory); TRACE_FONT(("GreReleaseFastMutex(ghfmMemory) 007\n"));
    }
    else
    {
        PVOID FreeTable;

        // we must have just allocated a new CPTABLE structure so cache it
        // unless another thread is using current cached entry

        TRACE_FONT(("GreAcquireFastMutex(ghfmMemory) 008\n")); GreAcquireFastMutex(ghfmMemory);
        if(!NlsTableUseCount)
        {
            LastCodePageTranslated = CodePage;
            RtlMoveMemory(&LastCPTableInfo, TableInfo, sizeof(CPTABLEINFO));
            FreeTable = LastNlsTableBuffer;
            LastNlsTableBuffer = LocalTableBase;
        }
        else
        {
            FreeTable = LocalTableBase;
        }
        GreReleaseFastMutex(ghfmMemory); TRACE_FONT(("GreReleaseFastMutex(ghfmMemory) 008\n"));

        // Now free the memory for either the old table or the one we allocated
        // depending on whether we update the cache.  Note that if this is
        // the first time we are adding a cached value to the local table, then
        // FreeTable will be NULL since LastNlsTableBuffer will be NULL

        if(FreeTable)
        {
            VFREEMEM(FreeTable);
        }
    }

    // we are done

    return(BytesConverted);
}

VOID EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    )
{
    RtlGetDefaultCodePage(AnsiCodePage,OemCodePage);
}

INT EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return(ConvertToAndFromWideChar(CodePage,
                                    WideCharString,
                                    BytesInWideCharString,
                                    MultiByteString,
                                    BytesInMultiByteString,
                                    TRUE));
}

INT APIENTRY EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )
{
    return(ConvertToAndFromWideChar(CodePage,
                                    WideCharString,
                                    BytesInWideCharString,
                                    MultiByteString,
                                    BytesInMultiByteString,
                                    FALSE));
}

/******************************Public*Routine******************************\
* BOOL EngDeleteFile
*
* Delete a file.
*
* Parameters
*     IN pwszFileName - Name of the file to be deleted
*
* Return Value
*     TRUE - sucess
*     FALSE - fail
*
* History:
*  4-Nov-1996 -by- Lingyun Wang [LingyunW]
* Wrote it.
\**************************************************************************/

BOOL EngDeleteFile (
    PWSZ  pwszFileName
)
{
    UNICODE_STRING    unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS          ntStatus;
    BOOL              bRet = TRUE;

    RtlInitUnicodeString(&unicodeString,
                         pwszFileName);

    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwDeleteFile (&objectAttributes);

    if (ntStatus != STATUS_SUCCESS)
    {
        WARNING ("EngDeleteFile failed \n");
        bRet = FALSE;
    }
    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL EngQueryFileTimeStamp
*
* Query a file timetimep.
*
* Parameters
*     IN pwsz - Name of the file
*
* Return Value
*     Timestamp
*
* History:
*  22-Nov-1996 -by- Lingyun Wang [LingyunW]
* Wrote it.
\**************************************************************************/

LARGE_INTEGER EngQueryFileTimeStamp (
    PWSZ  pwsz
)
{
    HANDLE FileHandle;
    UNICODE_STRING    unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK  IoStatusBlock;
    NTSTATUS   ntStatus;
    LARGE_INTEGER SystemTime, LocalTime;
    FILE_BASIC_INFORMATION File_Info;

    SystemTime.QuadPart = 0;
    LocalTime.QuadPart = 0;

    RtlInitUnicodeString(&unicodeString,
                         pwsz
                         );


    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenFile(&FileHandle,
                          FILE_GENERIC_READ,
                          &objectAttributes,
                          &IoStatusBlock,
                          FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                          FILE_SYNCHRONOUS_IO_ALERT);

    if(!NT_SUCCESS(ntStatus))
    {
        WARNING("fail to get handle of file file\n");
    }

    ntStatus = ZwQueryInformationFile (FileHandle,
                              &IoStatusBlock,
                              &File_Info,
                              sizeof(FILE_BASIC_INFORMATION),
                              FileBasicInformation
                              );

    if (ntStatus != STATUS_SUCCESS)
    {
         WARNING("failed queryinformationfile\n");
         return (LocalTime);
    }

    ZwClose (FileHandle);

    SystemTime = File_Info.LastWriteTime;

    GreSystemTimeToLocalTime(&SystemTime, &LocalTime);

    return(LocalTime);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\maskblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: maskblt.cxx
*
* This contains the blting API functions.
*
* Created: 25-Apr-1991 11:35:16
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
* History:
*  07-Sep-1991 -by- Patrick Haluptzok patrickh
* Added it as a global table for the Engine.
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE - This is so you can do: Rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};

/******************************Public*Data*********************************\
* ROP3 translation table
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
* History:
*  Wed 22-Aug-1990 16:51:16 -by- Charles Whitmer [chuckwh]
* Added it as a global table for the Engine.
\**************************************************************************/

BYTE gajRop3[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};

/******************************Public*Routine******************************\
* GrePatBltLockedDC
*
*   This routine is called by PatBlt,PolyPatBlt, and queued PatBlt once the
*   dc is locked, the devlock is owned and all parameters are captured.
*
* Arguments:
*
*   dcoDst   - reference to locked DC object
*   prclDst  - destination rect in screen coords
*   xoDst    - reference to xlate object
*   rop4     - raster op
*   pSurfDst - pointer to dst surface
*
* Return Value:
*
*   bool status
*
* History:
*
*    21-Aug-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
GrePatBltLockedDC(
    XDCOBJ    &dcoDst,
    EXFORMOBJ &xoDst,
    ERECTL    *prclDst,
    DWORD      rop4,
    SURFACE   *pSurfDst,
    COLORREF  crTextColor,
    COLORREF  crBackColor,
    ULONG     ulTextColor,
    ULONG     ulBackColor
    )
{

    BOOL bReturn  = TRUE;   // return true if it is just clipped
    ECLIPOBJ *pco = NULL;

    if (dcoDst.bDisplay() && !dcoDst.bRedirection() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return (FALSE);
    }

    //
    // Same as GreMaskblt, bail out
    // if the dest DC has a stock bitmap
    //
    
    ASSERTGDI(!dcoDst.bStockBitmap(), "GrePatBltLockedDC dst stock bitmap\n");

    if (dcoDst.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // This is a expression to save a return in here.
    // Basically pco can be NULL if the rect is completely in the
    // cached rect in the DC or if we set up a clip object that isn't empty.
    //
    // it is possible for the coordinates to wrap after adding in the origin
    // so we need to check that the rectangle is still well ordered.  If not,
    // we just fail since the result would be a blt going the opposite direction
    // as intended.
    //

    *prclDst += dcoDst.eptlOrigin();

    if (
         (
           (prclDst->left < prclDst->right) &&
           (prclDst->top  < prclDst->bottom)

         ) &&
         (
           (
             (prclDst->left   >= dcoDst.prclClip()->left) &&
             (prclDst->right  <= dcoDst.prclClip()->right) &&
             (prclDst->top    >= dcoDst.prclClip()->top) &&
             (prclDst->bottom <= dcoDst.prclClip()->bottom)
           ) ||
           (
             pco = dcoDst.pco(),
             pco->vSetup(dcoDst.prgnEffRao(), *prclDst,CLIP_NOFORCETRIV),
             *prclDst = pco->erclExclude(),
             (!prclDst->bEmpty())
           )
         )
       )

    {
        EBRUSHOBJ *pboFill;

        if ((((rop4 << 4) ^ rop4) & 0x00F0) != 0)
        {
            pboFill = dcoDst.peboFill();

            if (
                  (dcoDst.ulDirty() & DIRTY_FILL) ||
                  (dcoDst.pdc->flbrush() & DIRTY_FILL) ||
                  (pboFill->bCareAboutFg() && (pboFill->crCurrentText() != crTextColor)) ||
                  (pboFill->bCareAboutBg() && (pboFill->crCurrentBack() != crBackColor))
               )
            {
                COLORREF crTextColorOld = dcoDst.pdc->crTextClr();
                COLORREF crBackColorOld = dcoDst.pdc->crBackClr();
                ULONG    ulTextColorOld = dcoDst.pdc->ulTextClr();
                ULONG    ulBackColorOld = dcoDst.pdc->ulBackClr();

                dcoDst.ulDirtySub(DIRTY_FILL);
                dcoDst.pdc->flbrushSub(DIRTY_FILL);
                XEPALOBJ palDst(pSurfDst->ppal());
                XEPALOBJ palDstDC(dcoDst.ppal());

                // batched Textcolor and Bkcolor, need to be restored

                dcoDst.pdc->crTextClr(crTextColor);
                dcoDst.pdc->crBackClr(crBackColor);
                dcoDst.pdc->ulTextClr(ulTextColor);
                dcoDst.pdc->ulBackClr(ulBackColor);

                pboFill->vInitBrush(dcoDst.pdc,
                                    dcoDst.pdc->pbrushFill(),
                                    palDstDC,
                                    palDst,
                                    pSurfDst);

                dcoDst.pdc->crTextClr(crTextColorOld);
                dcoDst.pdc->crBackClr(crBackColorOld);
                dcoDst.pdc->ulTextClr(ulTextColorOld);
                dcoDst.pdc->ulBackClr(ulBackColorOld);
            }
        }
        else
        {
            pboFill = NULL;
        }

        DEVEXCLUDEOBJ dxo(dcoDst,prclDst,pco);

        //
        // Inc the target surface uniqueness
        //

        INC_SURF_UNIQ(pSurfDst);

        //
        // Dispatch the call.
        //

        bReturn = (*(pSurfDst->pfnBitBlt()))
                  (
                      pSurfDst->pSurfobj(),
                      (SURFOBJ *) NULL,
                      (SURFOBJ *) NULL,
                      pco,
                      NULL,
                      prclDst,
                      (POINTL *)  NULL,
                      (POINTL *)  NULL,
                      pboFill,
                      &dcoDst.pdc->ptlFillOrigin(),
                      rop4
                  );

    }
    return(bReturn);
}

/******************************Public*Routine******************************\
* NtGdiPatBlt
*
*   Pattern Blting Output API.
*
* Arguments:
*
*   hdcDst - Destination DC
*   x      - Destination x position
*   y      - Destination y position
*   cx     - Destination width
*   cy     - Destination height
*   rop4   - Destination raster operation
*
* Return Value:
*
*   BOOL Status
*
\**************************************************************************/

BOOL
NtGdiPatBlt(
    HDC hdcDst,
    int x,
    int y,
    int cx,
    int cy,
    DWORD rop4
    )
{
    GDITraceHandle(NtGdiPatBlt, "(%X, %d, %d, %d, %d, %X)\n", (va_list)&hdcDst,
                   hdcDst);

    BOOL bReturn = FALSE;
    BOOL bLock = FALSE;
    PDC  pdc;

    XDCOBJ dcoDst(hdcDst);

    //
    // Validate the destination DC.
    //

    if (dcoDst.bValid())
    {
        //
        // Process the rop for DDI, check for no source required.
        //

        rop4 = (rop4 >> 16) & 0x000000FF;
        rop4 = (rop4 << 8) | rop4;

        if ((((rop4 << 2) ^ rop4) & 0x00CC) == 0)
        {
            EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

            if (!xoDst.bRotation())
            {
                ERECTL erclDst(x,y,x+cx,y+cy);
                xoDst.bXform(erclDst);
                erclDst.vOrder();

                if (!erclDst.bEmpty())
                {
                    //
                    // Accumulate bounds.  We can do this before knowing if the operation is
                    // successful because bounds can be loose.
                    //

                    if (dcoDst.fjAccum())
                    {
                        dcoDst.vAccumulate(erclDst);
                    }

                    //
                    // Lock the device and surface.
                    //

                    DEVLOCKOBJ dloTrg;

                    if (dloTrg.bLock(dcoDst))
                    {
                        //
                        // Check surface is included in DC.
                        //

                        SURFACE *pSurfDst = dcoDst.pSurface();

                        if (pSurfDst != NULL)
                        {
                            ULONG ulDirty = dcoDst.pdc->ulDirty();

                            if (ulDirty & DC_BRUSH_DIRTY)
                            {
                               GreDCSelectBrush (dcoDst.pdc, dcoDst.pdc->hbrush());
                            }

                            bReturn = GrePatBltLockedDC(dcoDst,
                                                        xoDst,
                                                        &erclDst,
                                                        rop4,
                                                        pSurfDst,
                                                        dcoDst.pdc->crTextClr(),
                                                        dcoDst.pdc->crBackClr(),
                                                        dcoDst.pdc->ulTextClr(),
                                                        dcoDst.pdc->ulBackClr()
                                                        );
                        }
                        else
                        {
                            bReturn = TRUE;
                        }
                    }
                    else
                    {
                        bReturn = dcoDst.bFullScreen();
                    }
                }
                else
                {
                    bReturn = TRUE;
                }
            }
            else
            {
                //
                // There is rotation involved - send it off to MaskBlt to handle it.
                //

                bReturn = GreMaskBlt(hdcDst, x, y, cx, cy, 0, 0, 0, 0, 0, 0, rop4 << 16, 0);
            }
        }
        else
        {
            WARNING1("ERROR PatBlt called with Rop requires Source or on invalid Dst\n");
        }

        //
        // Unlock DC
        //

        dcoDst.vUnlock();
    }
    else
    {
        WARNING1("ERORR PatBlt called on invalid DC\n");
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GrePolyPatBltInternal
*
* Arguments:
*
*   dcoDst    - Destination DC (locked)
*   rop4      - Destination raster op
*   pPolyPat  - POLYPATBLT structure
*   Count     - number of POLYPATBLTs
*   crTextClr - rext color
*   crBackClr - background color
*
* Return Value:
*
*   status
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GrePolyPatBltInternal(
    XDCOBJ    &dcoDst,
    DWORD       rop4,
    PPOLYPATBLT pPolyPat,
    DWORD       Count,
    DWORD       Mode,
    COLORREF    crTextClr,
    COLORREF    crBackClr,
    ULONG       ulTextClr,
    ULONG       ulBackClr
)
{
    GDITraceHandle(GrePolyPatBltInternal, "(dcoDst, %X, %p, %u, %X, %X, %X)\n",
                   (va_list)&rop4, dcoDst.bValid() ? dcoDst.hdc() : NULL);

    BOOL bReturn = TRUE;

    //
    // validate input params
    //

    if ((Count != 0) && (pPolyPat != NULL) && (Mode == PPB_BRUSH))
    {
        //
        // Process the rop for DDI, check for no source required.
        //

        rop4 = (rop4 >> 16) & 0x000000FF;
        rop4 = (rop4 << 8) | rop4;

        if ((((rop4 << 2) ^ rop4) & 0x00CC) == 0)
        {
            //
            // Validate the destination DC
            //

            if (dcoDst.bValid())
            {
                HBRUSH hbrSave = dcoDst.pdc->hbrush();

                //
                // make sure brush is in sync in DC
                //

                if (dcoDst.pdc->ulDirty() & DC_BRUSH_DIRTY)
                {
                    GreDCSelectBrush(dcoDst.pdc,hbrSave);
                }

                //
                // lock the device 1 time for all calls
                //

                DEVLOCKOBJ dloTrg;

                if (dloTrg.bLock(dcoDst))
                {
                    EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

                    SURFACE *pSurfDst = dcoDst.pSurface();

                    while (Count--)
                    {
                        int    x;
                        int    y;
                        int    cx;
                        int    cy;
                        HBRUSH hbr;

                        __try
                        {
                            x      = pPolyPat->x;
                            y      = pPolyPat->y;
                            cx     = pPolyPat->cx;
                            cy     = pPolyPat->cy;
                            hbr    = pPolyPat->BrClr.hbr;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            bReturn = FALSE;

                            //
                            // must break out of while loop but restore brush
                            //

                            break;
                        }

                        GDITraceHandle(GrePolyPatBltInternal,
                                       "  pPolyPat = { (%d, %d) - (%d, %d) }\n",
                                       (va_list)pPolyPat, dcoDst.hdc());

                        //
                        // select in brush for this patblt, remember old
                        // brush for restore if needed
                        //

                        if (hbr != (HBRUSH)NULL)
                        {
                            GreDCSelectBrush(dcoDst.pdc, hbr);
                        }

                        if (!xoDst.bRotation())
                        {
                            ERECTL erclDst(x,y,x+cx,y+cy);
                            xoDst.bXform(erclDst);
                            erclDst.vOrder();

                            if (!erclDst.bEmpty())
                            {
                                //
                                // Accumulate bounds.  We can do this before knowing if the operation is
                                // successful because bounds can be loose.
                                //

                                if (dcoDst.fjAccum())
                                {
                                    dcoDst.vAccumulate(erclDst);
                                }

                                //
                                // Check surface is included in DC.
                                //

                                if (pSurfDst != NULL)
                                {
                                    bReturn = GrePatBltLockedDC(dcoDst,
                                                                xoDst,
                                                                &erclDst,
                                                                rop4,
                                                                pSurfDst,
                                                                crTextClr,
                                                                crBackClr,
                                                                ulTextClr,
                                                                ulBackClr
                                                                );
                                }
                            }
                        }
                        else
                        {
                            //
                            // There is rotation involved - send it off to MaskBlt to handle it.
                            //

                            bReturn = GreMaskBlt((HDC)dcoDst.pdc->hHmgr, x, y, cx, cy, 0, 0, 0, 0, 0, 0, rop4 << 16, 0);
                        }

                        pPolyPat++;
                    }
                }
                else
                {
                    bReturn = dcoDst.bFullScreen();
                }

                //
                // make sure dc brush is restored
                //

                if (dcoDst.pdc->hbrush() != hbrSave)
                {
                    dcoDst.pdc->hbrush(hbrSave);
                    dcoDst.pdc->ulDirtyAdd(DC_BRUSH_DIRTY);
                }
            }
            else
            {
                WARNING1("ERORR PatBlt called on invalid DC\n");
                bReturn = FALSE;
            }
        }
        else
        {
            WARNING1("ERROR PatBlt called with Rop requires Source or on invalid Dst\n");
            bReturn = FALSE;
        }
    }
    else
    {
        if (Count != 0)
        {
            WARNING1("ERORR PolyPatBlt called with NULL pPolyPat\n");
            bReturn = FALSE;
        }
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* NtGdiPolyPatBlt
*
* Arguments:
*
*   hdcDst   - Destination DC
*   rop4     - Destination raster op
*   pPolyPat - POLYPATBLT structure
*   Count    - number of POLYPATBLTs
*
* Return Value:
*
*   status
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiPolyPatBlt(
    HDC         hdc,
    DWORD       rop4,
    PPOLYPATBLT pPoly,
    DWORD       Count,
    DWORD       Mode
    )
{
    GDITraceHandle(NtGdiPolyPatBlt, "(%X, %X, %p, %u, %X)\n", (va_list)&hdc,
                   hdc);

    BOOL bRet = TRUE;

    if (Count != 0)
    {
        if (pPoly != NULL)
        {
            XDCOBJ dcoDst(hdc);

            if (dcoDst.bValid())
            {
                //
                // Make sure length do not overflow.
                //
                // Note: using MAXULONG instead of MAXIMUM_POOL_ALLOC (or the
                //       BALLOC_ macros) because we are not allocating memory.
                //

                if (Count <= (MAXULONG / sizeof(POLYPATBLT)))
                {
                    __try
                    {
                        ProbeForRead(pPoly,sizeof(POLYPATBLT)*Count,sizeof(DWORD));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(46);
                        bRet = FALSE;
                    }
                }
                else
                {
                    bRet = FALSE;
                }

                if (bRet)
                {
                    bRet = GrePolyPatBltInternal(dcoDst,
                                                 rop4,
                                                 pPoly,
                                                 Count,
                                                 Mode,
                                                 dcoDst.pdc->crTextClr(),
                                                 dcoDst.pdc->crBackClr(),
                                                 dcoDst.pdc->ulTextClr(),
                                                 dcoDst.pdc->ulBackClr());
                }

                dcoDst.vUnlockFast();
            }
            else
            {
                bRet = FALSE;
                EngSetLastError(ERROR_INVALID_HANDLE);
            }
        }
        else
        {
            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GrePolyPatBlt
*
* Arguments:
*
*   hdcDst    - Destination DC
*   rop4      - Destination raster op
*   pPolyPat  - POLYPATBLT structure
*   Count     - number of POLYPATBLTs
*   Mode      - color mode
*
* Return Value:
*
*   status
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
APIENTRY
GrePolyPatBlt(
    HDC         hdc,
    DWORD       rop4,
    PPOLYPATBLT pPoly,
    DWORD       Count,
    DWORD       Mode
    )
{
    GDITraceHandle(GrePolyPatBlt, "(%X, %X, %p, %u, %X)\n", (va_list)&hdc, hdc);

    XDCOBJ dcoDst(hdc);
    BOOL bRet = FALSE;

    if (dcoDst.bValid())
    {

        bRet = GrePolyPatBltInternal(dcoDst,
                                     rop4,
                                     pPoly,
                                     Count,
                                     Mode,
                                     dcoDst.pdc->crTextClr(),
                                     dcoDst.pdc->crBackClr(),
                                     dcoDst.pdc->ulTextClr(),
                                     dcoDst.pdc->ulBackClr());

        dcoDst.vUnlockFast();
    }
    else
    {
        EngSetLastError(ERROR_INVALID_HANDLE);
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* NtGdiFlushUserBatch
*
*   Unbatch drawing calls (all to same DC so DC lock and
*   DEVLOCK and XFORMOBJ are same.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
*    18-May-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if DBG_GDI_BATCH

ULONG GdiBatchCounts[32];
ULONG GdiBatchTypeCounts[8];
ULONG SystemTable[4096];
ULONG gClearTable = 1;

#endif

VOID
NtGdiFlushUserBatch()
{

    //
    // DBG_GDI_BATCH is never tuyrned on in a debug or free build, it
    // is a private measuring tool.
    //

    #if DBG_GDI_BATCH

        _asm
        {
            ;eax is the system service
            lea ebx, SystemTable
            and eax, 4096-1
            inc DWORD PTR[ebx + 4*eax]
        }

    #endif
    GDITrace(NtGdiFlushUserBatch, "", NULL);

    PTEB pteb = NtCurrentTeb();

    ULONG GdiBatchCount;
    PBYTE pGdiBatch;

    //
    // Non dc commands must be executed from batch
    // whether dc/dev locks succeed or not
    //

    BOOL  bExecNonDCOnly = TRUE;
    
    #if DBG_GDI_BATCH

       if (gClearTable)
       {
           RtlZeroMemory(&SystemTable[0],4*4096);
           RtlZeroMemory(&GdiBatchCounts[0],4*32);
           RtlZeroMemory(&GdiBatchTypeCounts[0],4*8);
           gClearTable = 0;
       }

    #endif

    //
    // clear batch control
    //

    __try
    {
        GdiBatchCount = pteb->GdiBatchCount;
        pGdiBatch = (PBYTE)&pteb->GdiTebBatch.Buffer[0];
        pteb->GdiBatchCount      = 0;
        pteb->GdiTebBatch.Offset = 0;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    PBYTE pGdiBatchEnd = pGdiBatch + GDI_BATCH_SIZE;
    //
    // read batch once at start
    //

    if ( 
         (GdiBatchCount > 0)  &&
         (GdiBatchCount < (GDI_BATCH_SIZE/4))
       )
    {
        HDC    hdcDst = 0;
       
        __try
        {
            hdcDst = (HDC)pteb->GdiTebBatch.HDC;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

        if (hdcDst != NULL)
        {
            XDCOBJ dcoDst(hdcDst);

            //
            // Validate the destination DC.
            //

            if (dcoDst.bValid())
            {
                //
                // Stats
                //

                #if DBG_GDI_BATCH

                    if (GdiBatchCount < 32)
                    {
                        GdiBatchCounts[GdiBatchCount]++;
                    }

                #endif

                //
                // Lock the device.
                //

                DEVLOCKOBJ dloTrg;

                if (dloTrg.bLock(dcoDst))
                {
                    //
                    // execute all batch commands from DC loop
                    //

                    bExecNonDCOnly = FALSE;

                    //
                    // remember DC_ATTR hbr
                    //

                    HBRUSH hbrDCA = dcoDst.pdc->hbrush();

                    do
                    {
                        //
                        // Pull patblt off teb and execute. TEB is not safe
                        // so all offsets must be checked to make sure no
                        // corruption has occured.
                        //

                        ULONG GdiBatchType;
                        ULONG GdiBatchLength;
                        ULONG GdiBatchIncrement;
                        BOOL  bRead = TRUE;

                        __try
                        {
                            GdiBatchType   = ((PBATCHCOMMAND)pGdiBatch)->Type;
                            GdiBatchLength = ((PBATCHCOMMAND)pGdiBatch)->Length;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            break;
                        }

                        if ((pGdiBatch + GdiBatchLength) > pGdiBatchEnd)
                        {
                            //
                            // exit while loop
                            //

                            WARNING("Error in GDI TEB batch address");
                            break;
                        }


                        //
                        // performance measure
                        //

                        #if DBG_GDI_BATCH

                        if (GdiBatchType <8)
                        {
                            GdiBatchTypeCounts[GdiBatchType]++;
                        }

                        #endif

                        //
                        // Check command type
                        //

                        switch (GdiBatchType)
                        {

                        //
                        // execute ExtTextOut and ExtTextOutRect
                        //

                        case BatchTypeTextOut:
                        case BatchTypeTextOutRect:
                        {

                            GreBatchTextOut(
                                        dcoDst,
                                        (PBATCHTEXTOUT)pGdiBatch,
                                        GdiBatchLength
                                        );

                        }
                        break;

                        //
                        // execute SelectClip
                        //

                        case BatchTypeSelectClip:
                        {
                            RECTL rclClip;
                            int iMode;

                            __try
                            {
                                rclClip = ((PBATCHSELECTCLIP)pGdiBatch)->rclClip;
                                iMode = ((PBATCHSELECTCLIP)pGdiBatch)->iMode;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }

                            if (bRead)
                            {
                                GreExtSelectClipRgnLocked(
                                                dcoDst,
                                                &rclClip,
                                                iMode);
                            }
                        }
                        break;

                        //
                        // delete brush
                        //

                        case BatchTypeDeleteBrush:
                        {
                            HOBJ hObj;

                            __try
                            {
                                hObj = (HOBJ)((PBATCHDELETEBRUSH)pGdiBatch)->hbrush;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                NtGdiDeleteObjectApp(hObj);
                        }
                        break;

                        //
                        // delete region
                        //

                        case BatchTypeDeleteRegion:
                        {
                            HOBJ hObj;

                            __try
                            {
                                hObj = (HOBJ)((PBATCHDELETEREGION)pGdiBatch)->hregion;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                NtGdiDeleteObjectApp(hObj);
                        }
                        break;

                        //
                        // set brush origin
                        //

                        case BatchTypeSetBrushOrg:
                        {
                            int x, y;

                            __try
                            {
                                x = ((PBATCHSETBRUSHORG)pGdiBatch)->x;
                                y = ((PBATCHSETBRUSHORG)pGdiBatch)->y;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                dcoDst.pdc->ptlBrushOrigin(
                                               x,
                                               y
                                               );
                        }
                        break;

                        case BatchTypeSelectFont:
                        {
                            HFONT hFont;

                            __try
                            {
                                hFont = (HFONT)((PBATCHSELECTFONT)pGdiBatch)->hFont;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                bRead = FALSE;
                            }
                            if (bRead)
                                GreSelectFont(hdcDst,
                                              hFont
                                              );
                        }
                        break;


                        //
                        // batched PolyPatBlt
                        //

                        case BatchTypePolyPatBlt:
                        {
                            PBATCHPOLYPATBLT pBatch;
                            COLORREF         crSaveDCBrushColor;
                            COLORREF         crBatchDCBrushColor;
                            POINTL           ptlViewportOrgSave;
                            POINTL           ptlBatchViewportOrg;
                            ULONG            ulSaveDCBrushColor;
                            ULONG            ulBatchDCBrushColor;
                            ULONG            Mode;
                            ULONG            TextColor, BackColor;
                            ULONG            ulTextColor, ulBackColor;

                            pBatch = (PBATCHPOLYPATBLT)pGdiBatch;

                            //
                            // Pull count off the TEB, the data could be
                            // overwritten so do all checking against the copy.
                            //
                            COUNT Count;
                            COUNT cjBuffer = GdiBatchLength - offsetof(BATCHPOLYPATBLT, ulBuffer);
                            __try
                            {
                                Count = pBatch->Count;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                break;
                            }

                            //
                            // Validate pBatch->Count and size of
                            // ulBuffer
                            //
                            if ((Count < (MAXULONG / sizeof(POLYPATBLT))) &&
                                ((Count * sizeof(POLYPATBLT)) <= cjBuffer))
                            {
                                //
                                // Set the DCBrush Color
                                //
                                crSaveDCBrushColor = dcoDst.pdc->crDCBrushClr();
                                ulSaveDCBrushColor = dcoDst.pdc->ulDCBrushClr();

                                __try
                                {
                                    Mode                = pBatch->Mode;
                                    TextColor           = pBatch->TextColor;
                                    BackColor           = pBatch->BackColor;
                                    ulTextColor         = pBatch->ulTextColor;
                                    ulBackColor         = pBatch->ulBackColor;
                                    crBatchDCBrushColor = pBatch->DCBrushColor;
                                    ulBatchDCBrushColor = pBatch->ulDCBrushColor;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if (crSaveDCBrushColor != crBatchDCBrushColor)
                                {
                                    dcoDst.pdc->crDCBrushClr(crBatchDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulBatchDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();

                                __try
                                {
                                    ptlBatchViewportOrg.x = pBatch->ptlViewportOrg.x;
                                    ptlBatchViewportOrg.y = pBatch->ptlViewportOrg.y;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if ((ptlViewportOrgSave.x != ptlBatchViewportOrg.x) ||
                                    (ptlViewportOrgSave.y != ptlBatchViewportOrg.y))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlBatchViewportOrg.x);
                                    dcoDst.pdc->lViewportOrgY(ptlBatchViewportOrg.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);

                                }

                                GrePolyPatBltInternal(
                                            dcoDst,
                                            pBatch->rop4,
                                            (PPOLYPATBLT)&pBatch->ulBuffer[0],
                                            Count,
                                            Mode,
                                            TextColor,
                                            BackColor,
                                            ulTextColor,
                                            ulBackColor
                                            );

                                //
                                // Restore the original DCBrush color
                                //
                                if (crSaveDCBrushColor != dcoDst.pdc->crDCBrushClr())
                                {
                                    dcoDst.pdc->crDCBrushClr(crSaveDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulSaveDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
                                    (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
                                    dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);

                                }

                            }
                            else
                            {
                                WARNING1("ERROR PolyPatBlt batch overflow\n");
                            }
                        }
                        break;

                        //
                        // common path for PatBlt and BitBlt
                        //

                        case BatchTypePatBlt:
                        {
                            PBATCHPATBLT pBatchPpb = (PBATCHPATBLT)pGdiBatch;

                            GDITraceHandle2(NtGdiPatBlt, "-BATCH %8lX: (%ld, %ld), %ldx%ld, HBR %lX, rop %lX...\n", (va_list)pBatchPpb, hdcDst, pBatchPpb->hbr);

                            int      x;
                            int      y;
                            int      cx;
                            int      cy;

                            DWORD    rop4;

                            ULONG    TextColor, ulTextColor;
                            ULONG    BackColor, ulBackColor;

                            __try
                            {
                                x           = pBatchPpb->x;
                                y           = pBatchPpb->y;
                                cx          = pBatchPpb->cx;
                                cy          = pBatchPpb->cy;
                                rop4        = pBatchPpb->rop4;
                                TextColor   = pBatchPpb->TextColor;
                                BackColor   = pBatchPpb->BackColor;
                                ulTextColor = pBatchPpb->ulTextColor;
                                ulBackColor = pBatchPpb->ulBackColor;
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                                break;
                            }
                            //
                            // Process the rop for DDI, check for no source required.
                            //

                            rop4 = (rop4 >> 16) & 0x000000FF;
                            rop4 = (rop4 << 8) | rop4;

                            //
                            // make sure command is a BitBlt or PatBlt with rop
                            // specifying no source required.
                            //

                            if ((((rop4 << 2) ^ rop4) & 0x00CC) == 0)
                            {
                                //
                                // get color information
                                //

                                HBRUSH   hbrBatch,
                                         hbrSave  = dcoDst.pdc->hbrush();
                                COLORREF crSaveDCBrushColor,
                                         crSaveIcmBrushColor,
                                         crBatchDCBrushColor,
                                         crBatchIcmBrushColor;
                                BOOL     bIcmBrush = FALSE;
                                POINTL   ptlViewportOrgSave;
                                POINTL   ptlBatchViewportOrg;
                                ULONG    ulSaveDCBrushColor;
                                ULONG    ulBatchDCBrushColor;

                                __try
                                {
                                    hbrBatch = pBatchPpb->hbr;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                //
                                // Select the brush from batch record
                                //
                                GreDCSelectBrush(dcoDst.pdc,hbrBatch);

                                //
                                // Set the DCBrush Color from batch record
                                //
                                crSaveDCBrushColor = dcoDst.pdc->crDCBrushClr();
                                ulSaveDCBrushColor = dcoDst.pdc->ulDCBrushClr();

                                __try
                                {
                                    crBatchDCBrushColor = pBatchPpb->DCBrushColor;
                                    ulBatchDCBrushColor = pBatchPpb->ulDCBrushColor;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if (crSaveDCBrushColor != crBatchDCBrushColor)
                                {
                                    dcoDst.pdc->crDCBrushClr(crBatchDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulBatchDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                //
                                // Set the ICM-ed color from batch record
                                //  (only effective when ICM is turned-on)
                                //
                                if (dcoDst.pdc->bIsHostICM() &&
                                    dcoDst.pdc->hcmXform())
                                {
                                    //
                                    // Save the current ICM brush state.
                                    //
                                    bIcmBrush = dcoDst.pdc->bValidIcmBrushColor();

                                    //
                                    // if the ICM is enabled, we believe batch
                                    // record contains valid ICMed color.
                                    //
                                    dcoDst.pdc->ulDirtyAdd(ICM_BRUSH_TRANSLATED);

                                    crSaveIcmBrushColor = dcoDst.pdc->crIcmBrushColor();
                                    __try
                                    {
                                        crBatchIcmBrushColor = pBatchPpb->IcmBrushColor;
                                    }
                                    __except(EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        break;
                                    }

                                    if (crSaveIcmBrushColor != crBatchIcmBrushColor)
                                    {
                                        dcoDst.pdc->crIcmBrushColor(crBatchIcmBrushColor);
                                        dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                    }
                                }

                                ptlViewportOrgSave = dcoDst.pdc->ptlViewportOrg();
                                __try
                                {
                                    ptlBatchViewportOrg.x = pBatchPpb->ptlViewportOrg.x;
                                    ptlBatchViewportOrg.y = pBatchPpb->ptlViewportOrg.y;
                                }
                                __except(EXCEPTION_EXECUTE_HANDLER)
                                {
                                    break;
                                }

                                if ((ptlViewportOrgSave.x != ptlBatchViewportOrg.x) ||
                                    (ptlViewportOrgSave.y != ptlBatchViewportOrg.y))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlBatchViewportOrg.x);
                                    dcoDst.pdc->lViewportOrgY(ptlBatchViewportOrg.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);
                                }

                                //
                                // Execute PatBlt
                                //

                                EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);

                                if (!xoDst.bRotation())
                                {
                                    ERECTL erclDst(x,y,x+cx,y+cy);
                                    xoDst.bXform(erclDst);
                                    erclDst.vOrder();

                                    if (!erclDst.bEmpty())
                                    {
                                        //
                                        // Accumulate bounds.  We can do this before knowing if the operation is
                                        // successful because bounds can be loose.
                                        //

                                        if (dcoDst.fjAccum())
                                        {
                                            dcoDst.vAccumulate(erclDst);
                                        }

                                        //
                                        // metafile patblt will have NULL surface but must still
                                        // accumulate bounds
                                        //

                                        SURFACE *pSurfDst = dcoDst.pSurface();

                                        if (pSurfDst != NULL)
                                        {
                                            GrePatBltLockedDC(
                                                           dcoDst,
                                                           xoDst,
                                                           &erclDst,
                                                           rop4,
                                                           pSurfDst,
                                                           TextColor,
                                                           BackColor,
                                                           ulTextColor,
                                                           ulBackColor
                                                           );
                                        }
                                    }
                                }
                                else
                                {
                                    //
                                    // There is rotation involved - send it off to MaskBlt to handle it.
                                    //
                                    COLORREF crTextColorOld = dcoDst.pdc->crTextClr();
                                    COLORREF crBackColorOld = dcoDst.pdc->crBackClr();
                                    COLORREF ulTextColorOld = dcoDst.pdc->ulTextClr();
                                    COLORREF ulBackColorOld = dcoDst.pdc->ulBackClr();

                                    dcoDst.pdc->crTextClr(TextColor);
                                    dcoDst.pdc->crBackClr(BackColor);
                                    dcoDst.pdc->ulTextClr(ulTextColor);
                                    dcoDst.pdc->ulBackClr(ulBackColor);

                                    GreMaskBlt(hdcDst, x, y, cx, cy, 0, 0, 0, 0, 0, 0, rop4 << 16, 0);

                                    dcoDst.pdc->crTextClr(crTextColorOld);
                                    dcoDst.pdc->crBackClr(crBackColorOld);
                                    dcoDst.pdc->ulTextClr(ulTextColorOld);
                                    dcoDst.pdc->ulBackClr(ulBackColorOld);
                                }

                                //
                                // make sure dc brush is restored
                                //
                                if (dcoDst.pdc->hbrush() != hbrSave)
                                {
                                    dcoDst.pdc->hbrush(hbrSave);
                                    dcoDst.pdc->ulDirtyAdd(DC_BRUSH_DIRTY);
                                }

                                //
                                // Restore the original.
                                //
                                if (crSaveDCBrushColor != dcoDst.pdc->crDCBrushClr())
                                {
                                    dcoDst.pdc->crDCBrushClr(crSaveDCBrushColor);
                                    dcoDst.pdc->ulDCBrushClr(ulSaveDCBrushColor);
                                    dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                }

                                if (dcoDst.pdc->bIsHostICM() &&
                                    dcoDst.pdc->hcmXform())
                                {
                                    if (crSaveIcmBrushColor != dcoDst.pdc->crIcmBrushColor())
                                    {
                                        dcoDst.pdc->crIcmBrushColor(crSaveIcmBrushColor);
                                        dcoDst.pdc->ulDirtyAdd(DIRTY_FILL);
                                    }

                                    if (!bIcmBrush)
                                        dcoDst.pdc->ulDirtySub(ICM_BRUSH_TRANSLATED);
                                }

                                if ((ptlViewportOrgSave.x != dcoDst.pdc->lViewportOrgX()) ||
                                    (ptlViewportOrgSave.y != dcoDst.pdc->lViewportOrgY()))
                                {
                                    dcoDst.pdc->lViewportOrgX(ptlViewportOrgSave.x);
                                    dcoDst.pdc->lViewportOrgY(ptlViewportOrgSave.y);

                                    dcoDst.pdc->flSet_flXform(
                                                  PAGE_XLATE_CHANGED     |
                                                  DEVICE_TO_WORLD_INVALID);
                                }

                            }
                            else
                            {
                                WARNING1("ERROR PatBlt called with Rop requires Source or on invalid Dst\n");
                            }
                        }
                        break;

                        default:

                            //
                            // unknown command on TEB
                            //

                            WARNING("ERROR in GDI batch command code");
                        }

                        //
                        // Decrement the batch command count and increment the batch
                        // pointer to the next batch command
                        //

                        GdiBatchCount--;

                        GdiBatchIncrement = (GdiBatchLength + sizeof(PVOID) - 1)
                            & ~(sizeof(PVOID)-1);

                        pGdiBatch += GdiBatchIncrement;

                    } while (
                              (GdiBatchCount > 0) &&
                              ((pGdiBatch + sizeof(BATCHCOMMAND)) < pGdiBatchEnd)
                            );

                    //
                    // clear batch control
                    //

                    __try
                    {
                        pteb->GdiBatchCount      = 0;
                        pteb->GdiTebBatch.Offset = 0;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }

                    //
                    // restore DC_ATTR brush and set dirty flag
                    //

                    dcoDst.pdc->hbrush(hbrDCA);
                    dcoDst.pdc->ulDirtyAdd(DC_BRUSH_DIRTY);

                }

                //
                // Unlock DC
                //

                dcoDst.vUnlock();
            }
            else
            {
                WARNING("GDI Batch routine: invalid hdc");
            }
        }

        //
        // non dc based commands must be executed whether there
        // was a dc or devlock failure or not. If the batch was
        // not flushed above, it must be flushed here.
        //

        if (bExecNonDCOnly)
        {
            //
            // can only be non-dc based batched commands
            //

            do
            {
                //
                // Pull patblt off teb and execute. TEB is not safe
                // so all offsets must be checked to make sure no
                // corruption has occured.
                //

                ULONG GdiBatchType;
                ULONG GdiBatchLength;
                ULONG GdiBatchIncrement;
                BOOL bRead = TRUE;

                __try
                {
                    GdiBatchType   = ((PBATCHCOMMAND)pGdiBatch)->Type;
                    GdiBatchLength = ((PBATCHCOMMAND)pGdiBatch)->Length;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    break;
                }

                if ((pGdiBatch + GdiBatchLength) > pGdiBatchEnd)
                {
                    //
                    // exit while loop
                    //

                    WARNING("Error in GDI TEB batch address");
                    break;
                }

                //
                // performance measure
                //

                #if DBG_GDI_BATCH

                if (GdiBatchType <8)
                {
                    GdiBatchTypeCounts[GdiBatchType]++;
                }

                #endif

                //
                // Check command type
                //

                switch (GdiBatchType)
                {

                //
                // execute ExtTextOut and ExtTextOutRect
                //

                case BatchTypeTextOut:
                case BatchTypeTextOutRect:
                case BatchTypeSelectClip:
                case BatchTypeSelectFont:
                case BatchTypePolyPatBlt:
                case BatchTypePatBlt:
                case BatchTypeSetBrushOrg:
                break;

                //
                // delete brush
                //

                case BatchTypeDeleteBrush:
                {
                    HOBJ hObj;
                    __try
                    {
                        hObj = (HOBJ)((PBATCHDELETEBRUSH)pGdiBatch)->hbrush;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        bRead = FALSE;
                    }
                    if (bRead)
                        NtGdiDeleteObjectApp(hObj);
                }
                break;

                //
                // delete region
                //

                case BatchTypeDeleteRegion:
                {
                    HOBJ hObj;

                    __try
                    {
                        hObj = (HOBJ)((PBATCHDELETEREGION)pGdiBatch)->hregion;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        bRead = FALSE;
                    }
                    if (bRead)
                        NtGdiDeleteObjectApp(hObj);
                }
                break;

                default:

                    //
                    // unknown command on TEB
                    //

                    WARNING("ERROR in GDI batch command code");
                }

               //
               // Decrement the batch command count and increment the batch
               // pointer to the next batch command
               //

               GdiBatchCount--;

               GdiBatchIncrement = (GdiBatchLength + sizeof(PVOID) - 1)
                            & ~(sizeof(PVOID)-1);

               pGdiBatch += GdiBatchIncrement;


            } while (
                      (GdiBatchCount > 0) &&
                      ((pGdiBatch + sizeof(BATCHCOMMAND)) < pGdiBatchEnd)
                    );

            __try
            {
                pteb->GdiBatchCount      = 0;
                pteb->GdiTebBatch.Offset = 0;
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
        }
    }

    //
    // reset hDC
    //
    __try
    {
        pteb->GdiTebBatch.HDC = 0;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

/******************************Public*Routine******************************\
* GdiThreadCalloutFlushUserBatch
*
*   Processes all delete region calls that are part of the batch queue,
*   called only when a thread terminates and we want to recover the resources
*   allocated to a region. 
*   WINBUG We need a better solution to process the whole batch list when
*   thread terminates.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* History:
*
\**************************************************************************/

VOID
GdiThreadCalloutFlushUserBatch()
{
    PTEB pteb = NtCurrentTeb();

    ULONG GdiBatchCount;
    PBYTE pGdiBatch;

    //
    // clear batch control
    //

    __try
    {
        GdiBatchCount = pteb->GdiBatchCount;
        pGdiBatch = (PBYTE)&pteb->GdiTebBatch.Buffer[0];
        pteb->GdiBatchCount      = 0;
        pteb->GdiTebBatch.Offset = 0;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return;
    }

    PBYTE pGdiBatchEnd = pGdiBatch + GDI_BATCH_SIZE;
    //
    // read batch once at start
    //

    if ( 
         (GdiBatchCount > 0)  &&
         (GdiBatchCount < (GDI_BATCH_SIZE/4))
       )
    {
        do
        {
            ULONG GdiBatchType;
            ULONG GdiBatchLength;
            ULONG GdiBatchIncrement;
            BOOL bRead = TRUE;

            __try
            {
                GdiBatchType   = ((PBATCHCOMMAND)pGdiBatch)->Type;
                GdiBatchLength = ((PBATCHCOMMAND)pGdiBatch)->Length;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                //
                // Exit while loop.
                //
                break;
            }

            if ((pGdiBatch + GdiBatchLength) > pGdiBatchEnd)
            {
                //
                // exit while loop
                //

                WARNING("Error in GDI TEB batch address");
                break;
            }

            //
            // Check command type
            //

            switch (GdiBatchType)
            {

            //
            // execute ExtTextOut and ExtTextOutRect
            //

            case BatchTypeTextOut:
            case BatchTypeTextOutRect:
            case BatchTypeSelectClip:
            case BatchTypeSelectFont:
            case BatchTypePolyPatBlt:
            case BatchTypePatBlt:
            case BatchTypeSetBrushOrg:
            case BatchTypeDeleteBrush:
            break;

            //
            // delete region
            //

            case BatchTypeDeleteRegion:
            {
                HOBJ hObj;

                __try
                {
                    hObj = (HOBJ)((PBATCHDELETEREGION)pGdiBatch)->hregion;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    bRead = FALSE;
                }

                if (bRead)
                    NtGdiDeleteObjectApp(hObj);
            }
            break;

            default:

                //
                // unknown command on TEB
                //

                WARNING("ERROR in GDI batch command code");
            }

           //
           // Decrement the batch command count and increment the batch
           // pointer to the next batch command
           //

           GdiBatchCount--;

           GdiBatchIncrement = (GdiBatchLength + sizeof(PVOID) - 1)
                        & ~(sizeof(PVOID)-1);

           pGdiBatch += GdiBatchIncrement;


        } while (
                  (GdiBatchCount > 0) &&
                  ((pGdiBatch + sizeof(BATCHCOMMAND)) < pGdiBatchEnd)
                );
    }
}

/******************************Public*Routine******************************\
* NtGdiBitBlt
*
* API entry point for doing a BitBlt.
*
* returns: TRUE for success, FALSE for failure.
*
* History:
*  Wed 03-Nov-1993 -by- Patrick Haluptzok [patrickh]
* optimize for size, we make sure at dispatch level not to send functions
* that don't need a SRC to PatBlt.
*
*  Sun 30-Aug-1992 -by- Patrick Haluptzok [patrickh]
* optimize for performance
*
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Accumulate bounds, region pointer change.
*
*  Sun 20-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make ATTRCACHE the default.
*
*  23-Apr-1991 -by- Patrick Haluptzok patrickh
* Expanded on ChuckWh's BitBlt code.
*
*  Wed 22-Aug-1990 15:22:39 -by- Charles Whitmer [chuckwh]
* BitBlt: Wrote it.  This is a first pass.
\**************************************************************************/

BOOL
NtGdiBitBlt(
    HDC    hdcDst,
    int    x,
    int    y,
    int    cx,
    int    cy,
    HDC    hdcSrc,
    int    xSrc,
    int    ySrc,
    DWORD  rop4,
#ifdef _WINDOWBLT_NOTIFICATION_
    DWORD  crBackColor,
    FLONG  fl
#else
    DWORD  crBackColor
#endif
)
{
#ifdef _WINDOWBLT_NOTIFICATION_
  GDITraceHandle2(NtGdiBitBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %X, %X, %X)\n",
                  (va_list)&hdcDst, hdcDst, hdcSrc);
#else
  GDITraceHandle2(NtGdiBitBlt, "(%X, %d, %d, %d, %d, %X, %d, %d, %X, %X)\n",
                  (va_list)&hdcDst, hdcDst, hdcSrc);
#endif

  BOOL bReturn = FALSE;

  //
  // Check for CAPTUREBLT rop flag; if it's set, let StretchBlt handle
  // it. [Bug #278291]
  //

  if (rop4 & CAPTUREBLT)
  {
      return GreStretchBlt(hdcDst,x,y,cx,cy,hdcSrc,xSrc,ySrc,cx,cy,rop4,crBackColor);
  }

  POINTL ptOrgDst;
  DWORD  OrgRop4 = rop4, dwOldLayout;

  rop4 = rop4 & ~NOMIRRORBITMAP;

#if DBG
  if ((((rop4 << 2) ^ rop4) & 0x00CC0000) == 0)
  {
      WARNING("NtGdiBitBlt() called with no source required\n");
  }
#endif

  // Lock down the DC

  XDCOBJ  dcoDst(hdcDst);

  if (dcoDst.bValid() && !dcoDst.bStockBitmap())
  {
    XDCOBJ  dcoSrc(hdcSrc);

    if (dcoSrc.bValid())
    {

      if ( ((dcoDst.pdc->dwLayout() & LAYOUT_ORIENTATIONMASK) != (dcoSrc.pdc->dwLayout() & LAYOUT_ORIENTATIONMASK)) &&
           (((OrgRop4 & NOMIRRORBITMAP) && MIRRORED_DC(dcoDst.pdc)) || MIRRORED_DC_NO_BITMAP_FLIP(dcoDst.pdc))
         ) {
        dcoDst.pdc->vGet_ptlWindowOrg( &ptOrgDst );
        dwOldLayout = dcoDst.pdc->dwSetLayout(-1, 0);
        x = ptOrgDst.x - x - cx;

        // Restore the DC if the flag is in the DC and not part
        // of the Rops. [samera]
        //
        OrgRop4 = NOMIRRORBITMAP;
      } else {
        OrgRop4 = 0;
      }

      EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
      EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);


      if ((!xoDst.bRotation()) && (xoDst.bEqualExceptTranslations(xoSrc)))
      {
        //
        // Return null operations.  Don't need to check source for
        // empty because the xforms are the same except translation.
        //

        ERECTL erclSrc(xSrc,ySrc,xSrc+cx,ySrc+cy);
        xoSrc.bXform(erclSrc);
        erclSrc.vOrder();

        ERECTL erclDst(x,y,x+cx,y+cy);
        xoDst.bXform(erclDst);
        erclDst.vOrder();

        if (!erclDst.bEmpty())
        {
          //
          // Accumulate bounds.  We can do this outside the DEVLOCK
          //

          if (dcoDst.fjAccum())
            dcoDst.vAccumulate(erclDst);

          //
          // Lock the Rao region and the surface if we are drawing on a
          // display surface.  Bail out if we are in full screen mode.
          //

          DEVLOCKBLTOBJ dlo;
          BOOL bLocked;

          bLocked = dlo.bLock(dcoDst, dcoSrc);

          if (bLocked)
          {
            //
            // Check pSurfDst, this may be an info DC or a memory DC with default bitmap.
            //

            SURFACE *pSurfDst;

            if ((pSurfDst = dcoDst.pSurface()) != NULL)
            {
              //
              // Set up the brush if necessary.
              //

              XEPALOBJ   palDst(pSurfDst->ppal());
              XEPALOBJ   palDstDC(dcoDst.ppal());
              EBRUSHOBJ *pbo;

              //
              // Finish rop to pass over ddi to driver.
              //

              rop4 = (rop4 >> 16) & 0x000000FF;
              rop4 = (rop4 << 8) | rop4;

              //
              // Check if we need a brush.
              //

              if ((((rop4 << 4) ^ rop4) & 0x00F0) != 0)
              {
                pbo = dcoDst.peboFill();

                ULONG ulDirty = dcoDst.pdc->ulDirty();

                if ( ulDirty & DC_BRUSH_DIRTY)
                {
                    GreDCSelectBrush(dcoDst.pdc,dcoDst.pdc->hbrush());
                }

                if ((dcoDst.ulDirty() & DIRTY_FILL) || (dcoDst.pdc->flbrush() & DIRTY_FILL))
                {
                  dcoDst.ulDirtySub(DIRTY_FILL);
                  dcoDst.pdc->flbrushSub(DIRTY_FILL);

                  pbo->vInitBrush(
                          dcoDst.pdc,
                          dcoDst.pdc->pbrushFill(),
                          palDstDC,
                          palDst,
                          pSurfDst);
                }
              }
              else
              {
                  pbo = NULL;
              }

              //
              // With a fixed DC origin we can change the destination to SCREEN coordinates.
              //

              erclDst += dcoDst.eptlOrigin();

              EPOINTL eptlOffset;
              SURFACE *pSurfSrc = dcoSrc.pSurface();

              //
              // Basically we check that pSurfSrc is not NULL which
              // happens for memory bitmaps with the default bitmap
              // and for info DC's.  Otherwise we continue if
              // the source is readable or if it isn't we continue
              // if we are blting display to display or if User says
              // we have ScreenAccess on this display DC.  Note
              // that if pSurfSrc is not readable the only way we
              // can continue the blt is if the src is a display.
              //

              if (pSurfSrc != NULL)
              {
                  if ((pSurfSrc->bReadable() && ((dcoDst.bDisplay() && !dcoDst.bRedirection()) ? UserScreenAccessCheck() : TRUE)) ||
                     ( (dcoSrc.bDisplay())  &&
                       ((dcoDst.bDisplay()) || UserScreenAccessCheck() )))
                  {
                    //
                    // Lock the source surface.
                    //

                    XEPALOBJ palSrc(pSurfSrc->ppal());

                    //
                    // Compute the offset between source and dest, in screen coordinates.
                    //

                    eptlOffset.x = erclDst.left - erclSrc.left - dcoSrc.eptlOrigin().x;
                    eptlOffset.y = erclDst.top - erclSrc.top - dcoSrc.eptlOrigin().y;

                    //
                    // Compute the source surface origin, taking into account multi-mon
                    // and negative offsets:
                    //

                    LONG xOrigin = 0;
                    LONG yOrigin = 0;

                    PDEVOBJ pdoSrc(pSurfSrc->hdev());
                    if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc)) && (pdoSrc.bMetaDriver()))
                    {
                        xOrigin = pdoSrc.pptlOrigin()->x;
                        yOrigin = pdoSrc.pptlOrigin()->y;
                    }

                    //
                    // Take care of the source rectangle.  We may have to reduce it. We do this
                    // so a driver can always assume that neither the source nor the destination
                    // rectangles hang over the edge of a surface.
                    //
                    // Intersect the dest with the source surface extents.
                    //

                    erclDst.left    = MAX(xOrigin + eptlOffset.x, erclDst.left);
                    erclDst.top     = MAX(yOrigin + eptlOffset.y, erclDst.top);
                    erclDst.right   = MIN((xOrigin + pSurfSrc->sizl().cx + eptlOffset.x), erclDst.right);
                    erclDst.bottom  = MIN((yOrigin + pSurfSrc->sizl().cy + eptlOffset.y), erclDst.bottom);

                    if ((erclDst.left < erclDst.right) && (erclDst.top < erclDst.bottom))
                    {
                      //
                      // This is a pretty gnarly expression to save a return in here.
                      // Basically pco can be NULL if the rect is completely in the
                      // cached rect in the DC or if we set up a clip object that isn't empty.
                      //

                      ECLIPOBJ *pco = NULL;

                      if (((erclDst.left   >= dcoDst.prclClip()->left) &&
                           (erclDst.right  <= dcoDst.prclClip()->right) &&
                           (erclDst.top    >= dcoDst.prclClip()->top) &&
                           (erclDst.bottom <= dcoDst.prclClip()->bottom)) ||
                          (pco = dcoDst.pco(),
                           pco->vSetup(dcoDst.prgnEffRao(), erclDst, CLIP_NOFORCETRIV),
                           erclDst = pco->erclExclude(),
                           (!erclDst.bEmpty())))
                      {
                        //
                        // Compute the (reduced) origin.
                        //

                        erclSrc.left = erclDst.left - eptlOffset.x;
                        erclSrc.top = erclDst.top - eptlOffset.y;

                        DEVEXCLUDEOBJ dxo;
                        EXLATEOBJ xlo;
                        XLATEOBJ *pxlo;

                        //
                        // C++ would generate alot of code to exit here to have
                        // a return so we set bReturn to TRUE if we succeed to
                        // init a valid xlate.  We avoid a return this way.
                        //

                        if (dcoSrc.pSurface() == dcoDst.pSurface())
                        {
                          pxlo = NULL;
                          bReturn = TRUE;

                          //
                          // To Call vExclude directly you must check it's a Display PDEV
                          // and that cursor exclusion needs to be done.
                          //

                          if (dcoDst.bDisplay() && dcoDst.bNeedsSomeExcluding())
                          {
                            //
                            // Compute the exclusion rectangle.  (It's expanded to include the source.)
                            //

                            ERECTL erclReduced = erclDst;

                            if (erclSrc.left < erclReduced.left)
                                erclReduced.left = erclSrc.left;
                            else
                                erclReduced.right += (erclSrc.left - erclReduced.left);

                            if (erclSrc.top < erclReduced.top)
                                erclReduced.top  = erclSrc.top;
                            else
                                erclReduced.bottom += (erclSrc.top - erclReduced.top);

                            dxo.vExclude2(dcoDst.hdev(), &erclReduced, pco, &eptlOffset);
                          }
                        }
                        else
                        {
                          //
                          // Get a translate object.
                          //

                          XEPALOBJ   palSrcDC(dcoSrc.ppal());

                          if (crBackColor == (COLORREF)-1)
                              crBackColor = dcoSrc.pdc->ulBackClr();

                          //
                          // No ICM with BitBlt(), so pass NULL color transform to XLATEOBJ
                          //

                          bReturn = xlo.bInitXlateObj(NULL,                   // hColorTransform
                                                      dcoDst.pdc->lIcmMode(), // ICM mode
                                                      palSrc,
                                                      palDst,
                                                      palSrcDC,
                                                      palDstDC,
                                                      dcoDst.pdc->crTextClr(),
                                                      dcoDst.pdc->crBackClr(),
                                                      crBackColor);

                          pxlo = xlo.pxlo();

                          //
                          // WARNING: When we support multiple displays that support cursors
                          // the following exclude logic will need to be redone.  Right now
                          // we assume that there can only be 1 display surface around that
                          // needs cursor exclusion.
                          //

                          if (dcoDst.bDisplay())
                          {
                            if (dcoDst.bNeedsSomeExcluding())
                            {
                              //
                              // To Call vExclude directly you must check it's a Display PDEV
                              // and that cursor exclusion needs to be done.
                              //

                              dxo.vExclude(dcoDst.hdev(),&erclDst,pco);
                            }
                          }
                          else
                          {
                            //
                            // The left top of erclSrc is correctly computed
                            // we just need the bottom,right updated now.
                            //

                            erclSrc.right = erclDst.right - eptlOffset.x,
                            erclSrc.bottom = erclDst.bottom - eptlOffset.y,
                            dxo.vExcludeDC(dcoSrc,&erclSrc);
                          }
                        }

                        if (bReturn)
                        {
                          //
                          // Inc the target surface uniqueness
                          //

                          INC_SURF_UNIQ(pSurfDst);

                          //
                          // Check if we're on the same PDEV, we can't blt between
                          // different PDEV's.  Well, actually we can so long as the
                          // source is an engine-exclusive surface, which we check
                          // by looking at iType() and dhsurf().
                          //

                          if ((dcoDst.hdev() == dcoSrc.hdev()) ||
                              ((pSurfSrc->iType() == STYPE_BITMAP) &&
                               (pSurfSrc->dhsurf() == NULL) && !dcoDst.bPrinter()))
                          {
                            if (rop4 == 0xCCCC)
                            {
                              PDEVOBJ pdo(pSurfDst->hdev());

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// To enable, need to add these to winddi.h:
//
//      #define GCAPS2_WINDOW_BLT       0x00000004
//      #define BMF_WINDOW_BLT          0x0040
//
// In addition, w32\kmode\services.tab needs to be modified to add a
// parameter to BitBlt.
//
// See also:
//      w32\w32inc\gre.h
//      ntgdi\inc\ntgdi.h
//      ntgdi\client\output.c
//      ntgdi\gre\maskblt.cxx
//      ntuser\kernel\swp.c         zzzBltValidBits is where BitBlt
//                                  is called to move the window
//
#ifdef _WINDOWBLT_NOTIFICATION_
                              //
                              // If window blt notification needed, add
                              // the bit to dst surface flags.
                              //

                              if (fl & GBB_WINDOWBLT)
                                pSurfDst->fjBitmap(pSurfDst->fjBitmap() | BMF_WINDOW_BLT);
#endif

                              bReturn = (*PPFNGET(pdo, CopyBits, pSurfDst->flags())) (
                                           pSurfDst->pSurfobj(),
                                           pSurfSrc->pSurfobj(),
                                           pco,
                                           pxlo,
                                           &erclDst,
                                           (POINTL *)  &erclSrc);

#ifdef _WINDOWBLT_NOTIFICATION_
                              //
                              // Clear the window blt notification flag.  Not
                              // valid anywhere else, so don't bother checking
                              // if we actually set it.
                              //

                              pSurfDst->fjBitmap(pSurfDst->fjBitmap() & ~BMF_WINDOW_BLT);
#endif
                            }
                            else
                            {
                              bReturn = (*(pSurfDst->pfnBitBlt())) (
                                           pSurfDst->pSurfobj(),
                                           pSurfSrc->pSurfobj(),
                                           (SURFOBJ *) NULL,
                                           pco,
                                           pxlo,
                                           &erclDst,
                                           (POINTL *)  &erclSrc,
                                           (POINTL *)  NULL,
                                           pbo,
                                           &dcoDst.pdc->ptlFillOrigin(),
                                           rop4);
                            }
                          }
                          else
                          {
                            //
                            // we need to carry dlo down since we may need
                            // to free the DEVLOCK of the source surf if
                            // we are going out to user mode printer drivers
                            //

                            PDEVOBJ pdoDst(pSurfDst->hdev());

                            bReturn = SimBitBlt(
                                           pSurfDst->pSurfobj(),
                                           pSurfSrc->pSurfobj(),
                                           (SURFOBJ *) NULL,
                                           pco,
                                           pxlo,
                                           &erclDst,
                                           (POINTL *)  &erclSrc,
                                           (POINTL *)  NULL,
                                           pbo,
                                           &dcoDst.pdc->ptlFillOrigin(),
                                           rop4,
                                           pdoDst.bPrinter() ? &dlo : NULL);
                          }
                        }
                        else
                        {
                          WARNING1("bInitXlateObj failed in GreBitBlt\n");
                        }
                      }
                      else
                      {
                          bReturn = TRUE;
                      }
                  }
                  else
                  {
                    bReturn = TRUE;
                  }
                }
                else
                {
                    WARNING1("GreBitBlt failed - trying to read from unreadable surface\n");
                    EngSetLastError(ERROR_INVALID_HANDLE);
                }
              }
              else
              {
                  bReturn = TRUE;
              }
            }
            else
            {
              bReturn = TRUE;
            }
          }
          else
          {
            // Return True if we are in full screen mode.

            bReturn = dcoDst.bFullScreen() | dcoSrc.bFullScreen();
          }
        }
        else
        {
          bReturn = TRUE;
        }
      }
      else
      {
        bReturn = GreStretchBlt(hdcDst,x,y,cx,cy,hdcSrc,xSrc,ySrc,cx,cy,rop4,crBackColor);
      }
      if (OrgRop4 & NOMIRRORBITMAP) {
        dcoDst.pdc->dwSetLayout(-1, dwOldLayout);
      }
      dcoSrc.vUnlockFast();
    }
    else
    {
      WARNING1("GreBitBlt failed invalid SrcDC\n");
    }
    dcoDst.vUnlockFast();

  }
  else
  {
    WARNING1("GreBitBlt failed invalid DstDC\n");
  }

  return(bReturn);
}
/******************************Public*Routine******************************\
* GreRectBlt
*
* Internal entry point for faster Rectangle drawing.  The rectangle is
* specified in device pixel coordinates.
*
* NOTE: The caller must have already taken care of the brush dirty bits!
*
* History:
*  6-May-1992 -by- J. Andrew Goossen [andrewgo]
* Cloned some code.
\**************************************************************************/

BOOL GreRectBlt(
DCOBJ&     dcoTrg,
ERECTL*    percl       // Device pixel coordinates
)
{
    ASSERTGDI(dcoTrg.bValid(), "Invalid DC");

    BLTRECORD   blt;

// Initialize the blt record

    ROP4 rop4 = gaMix[dcoTrg.pdc->jROP2() & 0x0F];
    ULONG ulAvec = (ULONG) gajRop3[rop4];
    ASSERTGDI(!(ulAvec & AVEC_NEED_SOURCE), "Invalid rop");

// Accumulate bounds.  We can do this outside the DEVLOCK

    if (dcoTrg.fjAccum())
        dcoTrg.vAccumulate(*percl);


// Lock the target surface

    DEVLOCKBLTOBJ dlo(dcoTrg);

// This check also verifies that there's a surface

    if (dcoTrg.bFullScreen())
    {
        return(TRUE);
    }

    if (!dlo.bValid())
    {
        return(FALSE);
    }

    blt.pSurfTrg(dcoTrg.pSurface());
    ASSERTGDI(blt.pSurfTrg() != NULL, "ERROR no good");
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

// Set up the brush if necessary.

    if (ulAvec & AVEC_NEED_PATTERN)
    {
        blt.pbo(dcoTrg.peboFill());

        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
            GreDCSelectBrush(dcoTrg.pdc,dcoTrg.pdc->hbrush());
        }

        if ((dcoTrg.ulDirty() & DIRTY_FILL) || (dcoTrg.pdc->flbrush() & DIRTY_FILL))
        {
            dcoTrg.ulDirtySub(DIRTY_FILL);
            dcoTrg.pdc->flbrushSub(DIRTY_FILL);

            blt.pbo()->vInitBrush(
                                dcoTrg.pdc,
                                dcoTrg.pdc->pbrushFill(),
                               *((XEPALOBJ *) blt.ppoTrgDC()),
                               *((XEPALOBJ *) blt.ppoTrg()),
                                blt.pSurfTrg()
                                );
        }

    // We have to check for a NULL brush because the dirty bits might be
    // wrong, and the 'realized' brush is a NULL one:

        if (blt.pbo()->bIsNull())
            return(FALSE);

        blt.Brush(dcoTrg.pdc->ptlFillOrigin());

        if ((blt.pbo()->bIsMasking()) &&
            (dcoTrg.pdc->jBkMode() == TRANSPARENT))
        {
            rop4 = rop4 | (0xAA00);
        }
        else
        {
            rop4 = (rop4 << 8) | rop4;
        }
    }
    else
    {
    // No masking being done, simple rop.

        blt.pbo(NULL);

        rop4 = (rop4 << 8) | rop4;
    }

    blt.rop(rop4);

// Initialize some stuff for DDI.

    blt.pSurfMsk((SURFACE *) NULL);

// Set the target rectangle and blt the bits.

    *blt.perclTrg() = *percl;

    return(blt.bBitBlt(dcoTrg, dcoTrg, ulAvec));
}

/******************************Public*Routine******************************\
* GreMaskBlt
*
* API entry point for doing a BitBlt with a Mask.
*
* History:
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Complete rewrite.
*
*  20-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make ATTRCACHE the default.
*
*  23-Apr-1991 -by- Patrick Haluptzok patrickh
* Expanded on ChuckWh's BitBlt code.
*
*  Wed 22-Aug-1990 15:22:39 -by- Charles Whitmer [chuckwh]
* BitBlt: Wrote it.  This is a first pass.
\**************************************************************************/

BOOL
GreMaskBlt(
    HDC        hdcTrg,
    int        x,
    int        y,
    int        cx,
    int        cy,
    HDC        hdcSrc,
    int        xSrc,
    int        ySrc,
    HBITMAP    hbmMask,
    int        xMask,
    int        yMask,
    DWORD      rop4,
    DWORD      crBackColor
    )
{
    GDITraceHandle3(GreMaskBlt,
                    "(%X, %d, %d, %d, %d, %X, %d, %d, %X, %d, %d, %X, %X)\n",
                    (va_list)&hdcTrg, hdcTrg, hdcSrc, hbmMask);

    ULONG ulAvec;
    BLTRECORD   blt;

    //
    // Lock the target DC and surface
    //

    DCOBJ   dcoTrg(hdcTrg);
    BOOL    bReturn = FALSE;

    if (!dcoTrg.bValidSurf())
    {
        if (dcoTrg.bValid() && !dcoTrg.bStockBitmap())
        {
            if (dcoTrg.fjAccum())
            {
                EXFORMOBJ exo(dcoTrg, WORLD_TO_DEVICE);
                ERECTL    ercl(x, y, x + cx, y + cy);

                if (exo.bXform(ercl))
                {
                    //
                    // Make the rectangle well ordered.
                    //

                    ercl.vOrder();
                    dcoTrg.vAccumulate(ercl);
                    bReturn = TRUE;
                }
            }
            else
                bReturn = TRUE;
        }
        else
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);

        return(bReturn);
    }

    if (dcoTrg.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return bReturn;
    }

// Initialize the blt record

// Deal with the mask if needed

    rop4 >>= 16;

    if ((hbmMask == 0) || ((rop4 & 0x00FF) == ((rop4 >> 8) & 0x00FF)))
    {
        rop4 &= 0x00FF;
        ulAvec = gajRop3[rop4];
        rop4 = rop4 | (rop4 << 8);
        blt.rop(rop4);
        blt.pSurfMsk((SURFACE *) NULL);
    }
    else
    {
        SURFREF soMsk((HSURF)hbmMask);

        if (!soMsk.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        blt.pSurfMsk((SURFACE *) soMsk.ps);

        if ((blt.pSurfMsk()->iType() != STYPE_BITMAP) ||
            (blt.pSurfMsk()->iFormat() != BMF_1BPP))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        soMsk.vKeepIt();

        blt.flSet(BLTREC_MASK_NEEDED | BLTREC_MASK_LOCKED);

        blt.rop(rop4);
        ulAvec  = ((ULONG) gajRop3[blt.ropFore()]) |
                  ((ULONG) gajRop3[blt.ropBack()]);

        ulAvec |= AVEC_NEED_MASK;
    }

// Lock the source DC if necessary

    DCOBJ     dcoSrc;

// Lock the relevant surfaces

    DEVLOCKBLTOBJ dlo;

    if (ulAvec & AVEC_NEED_SOURCE)
    {
        dcoSrc.vLock(hdcSrc);
    }

    if ((ulAvec & AVEC_NEED_SOURCE) && (dcoSrc.bValid()))
    {
        dlo.bLock(dcoTrg, dcoSrc);
    }
    else
    {
        dlo.bLock(dcoTrg);
    }

    if (!dlo.bValid())
    {
        return(dcoTrg.bFullScreen());
    }

    blt.pSurfTrg(dcoTrg.pSurface());
    blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

    if (ulAvec & AVEC_NEED_SOURCE)
    {
        if (!dcoSrc.bValidSurf() || !dcoSrc.pSurface()->bReadable())
        {
            if (!dcoSrc.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            if (!dcoSrc.pSurfaceEff()->bReadable())
            {
                if (dcoTrg.dctp() == DCTYPE_INFO)
                {
                    if (dcoTrg.fjAccum())
                    {
                        EXFORMOBJ exo(dcoTrg, WORLD_TO_DEVICE);
                        ERECTL    ercl(x, y, x + cx, y + cy);

                        if (exo.bXform(ercl))
                        {
                        // Make the rectangle well ordered.

                            ercl.vOrder();
                            dcoTrg.vAccumulate(ercl);
                        }

                        return(TRUE);
                    }
                }

            // Do the security test on SCREEN to MEMORY blits.

                if (dcoSrc.bDisplay() && !dcoTrg.bDisplay())
                {
                    if (!UserScreenAccessCheck())
                    {
                        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
                        return(FALSE);
                    }
                }
            }

        // If the source isn't a DISPLAY we should exit

            if (!dcoSrc.bDisplay())
                return(FALSE);
        }

        blt.pSurfSrc(dcoSrc.pSurfaceEff());
        blt.ppoSrc()->ppalSet(blt.pSurfSrc()->ppal());
        blt.ppoSrcDC()->ppalSet(dcoSrc.ppal());
        blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);

    // Now set the source rectangle

        if (blt.pxoSrc()->bRotation() || !blt.Src(xSrc, ySrc, cx, cy))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

    // If there is a mask, set the mask rectangle

        if (ulAvec & AVEC_NEED_MASK)
            blt.Msk(xMask, yMask);

    // Create the color translation object
    //
    // No ICM with MaskBlt(), so pass NULL color transform to XLATEOBJ

        if (!blt.pexlo()->bInitXlateObj(NULL,                   // hColorTransform
                                        dcoTrg.pdc->lIcmMode(), // ICM mode
                                       *blt.ppoSrc(),
                                       *blt.ppoTrg(),
                                       *blt.ppoSrcDC(),
                                       *blt.ppoTrgDC(),
                                        dcoTrg.pdc->crTextClr(),
                                        dcoTrg.pdc->crBackClr(),
                                        crBackColor))
        {
            WARNING("bInitXlateObj failed in MaskBlt\n");
            return(FALSE);
        }

        blt.flSet(BLTREC_PXLO);
    }
    else
    {
        blt.pSurfSrc((SURFACE *) NULL);

    // We need to lock the source DC if a mask is required.  We need
    // this to get the transform for the mask rectangle.

        if (ulAvec & AVEC_NEED_MASK)
        {
            //
            // if hdcSrc is NULL, assign to hdcTrg
            //

            if (hdcSrc == (HDC)NULL) {
                hdcSrc = hdcTrg;
            }

            dcoSrc.vLock(hdcSrc);

            if (!dcoSrc.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                return(FALSE);
            }

            blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);

        // Use the target extents (we need something) to specify the
        // size of the mask.  The extent is actually saved in the SOURCE
        // rectangle, since this is the only meaningful place for it.

            if (blt.pxoSrc()->bRotation() || !blt.Msk(xMask, yMask, cx, cy))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }
    }

// Set up the brush if necesary.

    if (ulAvec & AVEC_NEED_PATTERN)
    {
        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        blt.pbo(dcoTrg.peboFill());

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
            GreDCSelectBrush(dcoTrg.pdc,dcoTrg.pdc->hbrush());
        }

        if ((dcoTrg.ulDirty() & DIRTY_FILL) || (dcoTrg.pdc->flbrush() & DIRTY_FILL))
        {
            dcoTrg.ulDirtySub(DIRTY_FILL);
            dcoTrg.pdc->flbrushSub(DIRTY_FILL);

            blt.pbo()->vInitBrush(
                                dcoTrg.pdc,
                                dcoTrg.pdc->pbrushFill(),
                               *((XEPALOBJ *) blt.ppoTrgDC()),
                               *((XEPALOBJ *) blt.ppoTrg()),
                                blt.pSurfTrg());
        }

        blt.Brush(dcoTrg.pdc->ptlFillOrigin());

    } else {

        //
        // NULL the pebo
        //

        blt.pbo((EBRUSHOBJ *)NULL);
    }

// Now all the essential information has been collected.  We now
// need to check for promotion and call the appropriate method to
// finish the blt.  If we rotate we must send the call away.

    if (dcoTrg.bDisplay() && !dcoTrg.bRedirection() && dcoSrc.bValidSurf() && !dcoSrc.bDisplay())
    {
        if (!UserScreenAccessCheck())
        {
            SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
            return (FALSE);
        }
    }

    if (blt.pxoTrg()->bRotation())
    {
        if (!blt.TrgPlg(x, y, cx, cy))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        return(blt.bRotate(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));
    }

// We can now set the target rectangle

    if (!blt.Trg(x, y, cx, cy))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// If there is a source and we scale, send the call away.  Note that
// since the mask extent is cleverly placed in aptlSrc if there is no
// source, maskblts that scale will get sent to bStretch().

    if ((ulAvec & AVEC_NEED_SOURCE) && !blt.bEqualExtents())
        return(blt.bStretch(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));

    return(blt.bBitBlt(dcoTrg, dcoSrc, ulAvec));
}

/******************************Public*Routine******************************\
* BLTRECORD::bBitBlt(dcoTrg, dcoSrc, ulAvec)
*
* Do a bitblt from the blt record
*
* History:
*  18-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bBitBlt(
DCOBJ&      dcoTrg,
DCOBJ&      dcoSrc,
ULONG       ulAvec)
{
    //
    // Make the target rectangle well ordered.
    //

    perclTrg()->vOrder();

    //
    // Compute the new Rao region if it's dirty.  This can happen if
    // we need clipping due to a rotation (the DEVLOCKBLTOBJ is obtained
    // before we compute the clipping in the prgnAPI)
    //

    if (dcoTrg.pdc->bDirtyRao())
    {
        if (!dcoTrg.pdc->bCompute())
        {
            return(FALSE);
        }
    }

    //
    // Accumulate bounds.  We can do this before knowing if the operation is
    // successful because bounds can be loose.
    //

    if (dcoTrg.fjAccum())
        dcoTrg.vAccumulate(*perclTrg());

    //
    // With a fixed DC origin we can change the target to SCREEN coordinates.
    //

    *perclTrg() += dcoTrg.eptlOrigin();

    //
    // Handle BitBlts without source
    //

    //
    // Get an PDEV for dispatching
    //

    PDEVOBJ pdoTrg(pSurfTrg()->hdev());


    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        ECLIPOBJ eco(dcoTrg.prgnEffRao(), *perclTrg());

        //
        // Check the target which is reduced by clipping.
        //

        if (eco.erclExclude().bEmpty())
        {
            return(TRUE);
        }

        //
        // Before we call to the driver, validate that the mask will actually
        // cover the entire target.  Rememeber, the source extent equals the
        // required size for the mask in cases with no source needed!
        //
        // The mask offsets must not be negative.
        //
        // cx and cy, which are stored in perclSrc, may be negative
        //
        // if cx is negative then the mask x points must be swapped
        // if cy is negative then the mask y points must be swapped
        //

        if (perclSrc()->right < 0) {
            LONG lTmp;
            lTmp          = aptlMask[0].x;
            aptlMask[0].x = aptlMask[1].x;
            aptlMask[1].x = lTmp;
        }

        if (perclSrc()->bottom < 0) {
            LONG lTmp;
            lTmp          = aptlMask[0].y;
            aptlMask[0].y = aptlMask[1].y;
            aptlMask[1].y = lTmp;
        }

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if ((aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                (pSurfMsk()->sizl().cx - aptlMask[0].x < ABS(perclSrc()->right)) ||
                (pSurfMsk()->sizl().cy - aptlMask[0].y < ABS(perclSrc()->bottom)))
            {

                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            //
            // Adjust the mask origin for clipping
            //

            aptlMask[0].x += eco.erclExclude().left - perclTrg()->left;
            aptlMask[0].y += eco.erclExclude().top  - perclTrg()->top;
        }

        //
        // Exclude the pointer.
        //

        DEVEXCLUDEOBJ dxo(dcoTrg,&eco.erclExclude(),&eco);

        //
        // Inc the target surface uniqueness
        //

        INC_SURF_UNIQ(pSurfTrg());

        //
        // Dispatch the call.
        //

        return((*(pSurfTrg()->pfnBitBlt()))
                (pSurfTrg()->pSurfobj(),
                 (SURFOBJ *) NULL,
                 pSurfMskOut()->pSurfobj(),
                 &eco,
                 NULL,
                 perclTrg(),
                 (POINTL *) NULL,
                 aptlMask,
                 pbo(),
                 aptlBrush,
                 rop4));
    }

    //
    // Now compute the source rectangle
    //

    EPOINTL *peptlOff = (EPOINTL *) &aptlSrc[0];
    EPOINTL *peptlSrc = (EPOINTL *) &aptlSrc[1];

    peptlSrc->x = MIN(peptlSrc->x, peptlOff->x);
    peptlSrc->y = MIN(peptlSrc->y, peptlOff->y);

    ERECTL erclReduced;

    //
    // if cx or cy was negative then hte corosponding mask extents
    // must be swapped
    //

    if (aptlSrc[0].x > aptlSrc[1].x) {
        LONG lTmp;
        lTmp          = aptlMask[0].x;
        aptlMask[0].x = aptlMask[1].x;
        aptlMask[1].x = lTmp;
    }

    if (aptlSrc[0].y > aptlSrc[1].y) {
        LONG lTmp;
        lTmp          = aptlMask[0].y;
        aptlMask[0].y = aptlMask[1].y;
        aptlMask[1].y = lTmp;
    }

    //
    // If the source and target are the same surface, we won't have
    // to DEVLOCK the source and other fun stuff.
    //

    if (dcoSrc.pSurface() == dcoTrg.pSurface())
    {
        //
        // Compute the source surface origin, taking into account multi-mon
        // and negative offsets:
        //

        LONG xOrigin = 0;
        LONG yOrigin = 0;

        PDEVOBJ pdoSrc(pSurfSrc()->hdev());
        if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc())) && (pdoSrc.bMetaDriver()))
        {
            xOrigin = pdoSrc.pptlOrigin()->x;
            yOrigin = pdoSrc.pptlOrigin()->y;
        }

        //
        // Compute the offset between source and target, in screen coordinates.
        //

        peptlOff->x = perclTrg()->left - peptlSrc->x - dcoSrc.eptlOrigin().x;
        peptlOff->y = perclTrg()->top  - peptlSrc->y - dcoSrc.eptlOrigin().y;

        //
        // Take care of the source rectangle.  We may have to reduce it.  This is
        // not good enough for a secure system, we are doing it so that the device
        // driver can always assume that neither the source nor the target
        // rectangles hang over the edge of a surface.
        //
        // Intersect the target with the source clipping window.
        //

        erclReduced.left   = peptlOff->x + xOrigin;
        erclReduced.top    = peptlOff->y + yOrigin;
        erclReduced.right  = peptlOff->x + xOrigin + pSurfTrg()->sizl().cx;
        erclReduced.bottom = peptlOff->y + yOrigin + pSurfTrg()->sizl().cy;
        erclReduced *= *perclTrg();

        ECLIPOBJ eco(dcoTrg.prgnEffRao(), erclReduced);

        erclReduced = eco.erclExclude();

        //
        // Check the target which is reduced by clipping.
        //

        if (erclReduced.bEmpty())
        {
            return(TRUE);
        }

        //
        // Before we call to the driver, validate that the mask will actually
        // cover the entire target.
        //
        //  aptlMask must not be negative.
        //
        //  Blt Trg extents have already been ordered
        //

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if ((aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                ((pSurfMsk()->sizl().cx - aptlMask[0].x) < (perclTrg()->right - perclTrg()->left)) ||
                ((pSurfMsk()->sizl().cy - aptlMask[0].y) < (perclTrg()->bottom - perclTrg()->top)))
            {

                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }

            //
            // Adjust the mask origin for clipping
            //

            aptlMask[0].x += eco.erclExclude().left - perclTrg()->left;
            aptlMask[0].y += eco.erclExclude().top  - perclTrg()->top;
        }

        //
        // Compute the (reduced) origin.
        //

        peptlSrc->x = erclReduced.left - peptlOff->x;
        peptlSrc->y = erclReduced.top - peptlOff->y;

        //
        // Compute the exclusion rectangle.  (It's expanded to include the source.)
        //

        if (peptlSrc->x < erclReduced.left)
            erclReduced.left    = peptlSrc->x;
        else
            erclReduced.right  += peptlSrc->x - erclReduced.left;

        if (peptlSrc->y < erclReduced.top)
            erclReduced.top    = peptlSrc->y;
        else
            erclReduced.bottom += peptlSrc->y - erclReduced.top;

        //
        // Exclude the pointer from the output region and offset region.
        //

        DEVEXCLUDEOBJ dxo(dcoTrg,&erclReduced,&eco,peptlOff);

        //
        // Inc the target surface uniqueness
        //

        INC_SURF_UNIQ(pSurfTrg());

        //
        // Dispatch the call.
        //

        if (rop4 == 0xCCCC) {

            //
            // call copy bits if rop specifies srccopy
            //

            return((*PPFNGET(pdoTrg,CopyBits,pSurfTrg()->flags())) (
                pSurfTrg()->pSurfobj(),
                pSurfSrc()->pSurfobj(),
                &eco,
                NULL,
                &eco.erclExclude(),
                peptlSrc));

        } else {

            return((*(pSurfTrg()->pfnBitBlt())) (
                 pSurfTrg()->pSurfobj(),
                 pSurfSrc()->pSurfobj(),
                 pSurfMskOut()->pSurfobj(),
                 &eco,
                 NULL,
                 &eco.erclExclude(),
                 peptlSrc,
                 aptlMask,
                 pbo(),
                 aptlBrush,
                 rop4));
        }
    }

    //
    // If the devices are on different PDEV's and we are not targeting a meta driver
    // then we can only succeed if the Engine
    // manages one or both of the surfaces.  Check for this.
    //
    // WINBUG #298689 4-4-2001 jasonha  Handle any device stretch to Meta

    BOOL bTrgMetaDriver = (dcoTrg.bSynchronizeAccess() && pdoTrg.bValid() && pdoTrg.bMetaDriver());
    
    if (dcoTrg.hdev() != dcoSrc.hdev())
    {
       if (!bTrgMetaDriver)
       {
            if(((dcoTrg.pSurfaceEff()->iType() != STYPE_BITMAP)
               || (dcoTrg.pSurfaceEff()->dhsurf() != NULL)) &&
              ((dcoSrc.pSurfaceEff()->iType() != STYPE_BITMAP)
               || (dcoSrc.pSurfaceEff()->dhsurf() != NULL)))
            {
              SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
              return(FALSE);
            }
       }
    }

    //
    // Compute the source surface origin, taking into account multi-mon
    // and negative offsets:
    //

    LONG xOrigin = 0;
    LONG yOrigin = 0;

    PDEVOBJ pdoSrc(pSurfSrc()->hdev());
    if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc())) && (pdoSrc.bMetaDriver()))
    {
        xOrigin = pdoSrc.pptlOrigin()->x;
        yOrigin = pdoSrc.pptlOrigin()->y;
    }

    //
    // Compute the offset between source and dest, in screen coordinates.
    //

    peptlOff->x = perclTrg()->left - peptlSrc->x - dcoSrc.eptlOrigin().x;
    peptlOff->y = perclTrg()->top - peptlSrc->y - dcoSrc.eptlOrigin().y;

    //
    // Take care of the source rectangle.  We may have to reduce it.  This is
    // not good enough for a secure system, we are doing it so that the device
    // driver can always assume that neither the source nor the destination
    // rectangles hang over the edge of a surface.
    // Intersect the dest with the source surface extents.
    //

    erclReduced.left   = peptlOff->x + xOrigin;
    erclReduced.top    = peptlOff->y + yOrigin;
    erclReduced.right  = peptlOff->x + xOrigin + pSurfSrc()->sizl().cx;
    erclReduced.bottom = peptlOff->y + yOrigin + pSurfSrc()->sizl().cy;
    erclReduced *= *perclTrg();

    ECLIPOBJ eco(dcoTrg.prgnEffRao(), erclReduced);

    erclReduced = eco.erclExclude();

    //
    // Check the destination which is reduced by clipping.
    //

    if (erclReduced.bEmpty())
    {
        return(TRUE);
    }

    //
    // Before we call to the driver, validate that the mask will actually
    // cover the entire source/target.
    //

    if (pSurfMskOut() != (SURFACE *) NULL)
    {
        if ((aptlMask[0].x < 0) ||
            (aptlMask[0].y < 0) ||
            ((pSurfMsk()->sizl().cx - aptlMask[0].x) < (perclTrg()->right - perclTrg()->left)) ||
            ((pSurfMsk()->sizl().cy - aptlMask[0].y) < (perclTrg()->bottom - perclTrg()->top)))
        {

            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        // Adjust the mask origin for clipping

        aptlMask[0].x += eco.erclExclude().left - perclTrg()->left;
        aptlMask[0].y += eco.erclExclude().top    - perclTrg()->top;
    }

    //
    // Compute the (reduced) origin.
    //

    peptlSrc->x = erclReduced.left - peptlOff->x;
    peptlSrc->y = erclReduced.top  - peptlOff->y;

    //
    // Get ready to exclude the cursor
    //

    DEVEXCLUDEOBJ dxo;

    //
    // They can't both be display so if the source is do the special stuff.
    // The following code assumes there is only 1 display in the system.
    //

    if (dcoSrc.bDisplay())
    {
        erclReduced -= *peptlOff;
        dxo.vExclude(dcoSrc.hdev(),&erclReduced,NULL);
    }
    else if (dcoTrg.bDisplay())
    {
        dxo.vExclude(dcoTrg.hdev(),&erclReduced,&eco);
    }

    //
    // Inc the target surface uniqueness
    //

    INC_SURF_UNIQ(pSurfTrg());

    //
    // Dispatch the call.
    //

    if (rop4 == 0xCCCC) {

        //
        // call copy bits if rop specifies srccopy
        //

        return((*PPFNGET(pdoTrg,CopyBits,pSurfTrg()->flags())) (
            pSurfTrg()->pSurfobj(),
            pSurfSrc()->pSurfobj(),
            &eco,
            pexlo()->pxlo(),
            &eco.erclExclude(),
            peptlSrc));

    } else {

        return((*(pSurfTrg()->pfnBitBlt()))
            (pSurfTrg()->pSurfobj(),
             pSurfSrc()->pSurfobj(),
             pSurfMskOut()->pSurfobj(),
             &eco,
             pexlo()->pxlo(),
             &eco.erclExclude(),
             peptlSrc,
             aptlMask,
             pbo(),
             aptlBrush,
             rop4));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\misceudc.cxx ===
/*********************************************************************************
 * misceudc.cxx
 *
 * This file contains EUDC specific methods for various GRE object.  I am moving
 * them to a separate file to make it easier to modify them after checkin freezes.
 * Once FE_SB ifdefs are removed we will probably want to move these object back
 * to the appropriate xxxobj.cxx files.
 *
 * 5-1-96 Gerrit van Wingerden [gerritv]
 *
 * Copyright (c) 1996-1999 Microsoft Corporation
 ********************************************************************************/

#include "precomp.hxx"

extern HSEMAPHORE ghsemEUDC2;

LONG lNormAngle(LONG lAngle);

/******************************Public*Routine******************************\
* GLYPHDATA *RFONTOBJ::pgdGetEudcMetrics()
*
*  9-29-1993 Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

GLYPHDATA *RFONTOBJ::pgdGetEudcMetrics(WCHAR wc, RFONTOBJ* prfoBase)
{
    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache(prfoBase))
        {
            return(NULL);
        }
    }

    if (prfnt->wcgp->cRuns == 0)
    {
        WARNING("EUDC -- pgdGetEudcMetrics - empty glyphset\n");
        return pgdDefault();
    }

    GPRUN *pwcRun = prfnt->wcgp->agpRun; // initialize with guess for loop below

    GLYPHDATA *wpgd;

// Find the correct run, if any.
// Try the current run first.

    UINT swc = (UINT)wc - pwcRun->wcLow;
    if ( swc >= pwcRun->cGlyphs )
    {
        pwcRun = gprunFindRun(wc);

        swc = (UINT)wc - pwcRun->wcLow;

        if ( swc < pwcRun->cGlyphs )
        {
            wpgd = pwcRun->apgd[swc];
        }
        else
        {
            return(NULL);
        }
    }
    else
    {

    // Look up entry in current run
    // This path should go in line

        wpgd = pwcRun->apgd[swc];
    }

// check to make sure in cache, insert if needed

    if ( wpgd == NULL )
    {
    // This path should go out of line

        if ( !bInsertMetrics(&pwcRun->apgd[swc], wc) )
        {

        // when insert fails trying to get just metrics, it is a hard
        // failure.  Get out of here!

            WARNING("EUDC -- bGetGlyphMetrics - bInsertMetrics failed\n");
            return(NULL);
        }

        wpgd = pwcRun->apgd[swc];
    }

    return wpgd;
}

/******************************Public*Routine******************************\
* GLYPHDATA *RFONTOBJ::pgdGetEudcMetricsPlus()
*
*
*  9-29-1993 Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

GLYPHDATA *RFONTOBJ::pgdGetEudcMetricsPlus
(
    WCHAR wc,
    RFONTOBJ*  prfoBase
)
{
    if (prfnt->wcgp == NULL)
    {
        if (!bAllocateCache(prfoBase))
        {
            return(NULL);
        }
    }

    if (prfnt->wcgp->cRuns == 0)
    {
        WARNING("EUDC -- pgdGetEudcMetricsPlus - empty glyphset\n");
        return pgdDefault();
    }

    GPRUN *pwcRun = prfnt->wcgp->agpRun; // initialize with guess for loop below

    GLYPHDATA *wpgd;

// Find the correct run, if any.
// Try the current run first.

    UINT swc = (UINT)wc - pwcRun->wcLow;
    if ( swc >= pwcRun->cGlyphs )
    {
        pwcRun = gprunFindRun(wc);

        swc = (UINT)wc - pwcRun->wcLow;

        if ( swc < pwcRun->cGlyphs )
        {
            wpgd = pwcRun->apgd[swc];
        }
        else
        {
            return(NULL);
        }
    }
    else
    {

    // Look up entry in current run
    // This path should go in line

        wpgd = pwcRun->apgd[swc];
    }


// check to make sure in cache, insert if needed


    if ( wpgd == NULL )
    {

    // This path should go out of line

        if ( !bInsertMetricsPlus(&pwcRun->apgd[swc], wc) )
        {

        // when insert fails trying to get just metrics, it is a hard
        // failure.  Get out of here!

            WARNING("EUDC -- bGetGlyphMetricsPlus - bInsertMetrics failed\n");
            return(NULL);
        }

        wpgd = pwcRun->apgd[swc];
    }


// Don't bother inserting glyphs since we are going to force the driver to
// enum anyway.

    return wpgd;
}

/******************************Public*Routine******************************\
* RFONTOBJ::bCheckEudcFontCaps
*
* History:
*  9-Nov-93 -by- Hideyuki Nagase
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bCheckEudcFontCaps
(
    IFIOBJ  &ifioEudc
)
{
    // Check FontLink configuration.

    if( ulFontLinkControl & FLINK_DISABLE_LINK_BY_FONTTYPE )
    {

    // Fontlink for Device font is disabled ?

        if( bDeviceFont() )
        {
            if( ulFontLinkControl & FLINK_DISABLE_DEVFONT )
            {
                return(FALSE);
            }
        }
         else
        {

        // Fontlink for TrueType font is disabled ?

            if( (ulFontLinkControl & FLINK_DISABLE_TTFONT) &&
                (prfnt->flInfo & FM_INFO_TECH_TRUETYPE   )    )
            {
                return( FALSE );
            }

        // Fontlink for Vector font is disabled ?

            if( (ulFontLinkControl & FLINK_DISABLE_VECTORFONT) &&
                (prfnt->flInfo & FM_INFO_TECH_STROKE         )    )
            {
                return( FALSE );
            }

        // Fontlink for Bitmap font is disabled ?

            if( (ulFontLinkControl & FLINK_DISABLE_BITMAPFONT) &&
                (prfnt->flInfo & FM_INFO_TECH_BITMAP         )    )
            {
                return( FALSE );
            }
        }
    }

    BOOL bRotIs90Degree;

// Can EUDC font do arbitarary tramsforms ?

    if( ifioEudc.bArbXforms() )
        return( TRUE );

// Can its Orientation degree be divided by 900 ?

    bRotIs90Degree = (prfnt->ulOrientation % 900) == 0;

// if the Orientation is 0, 90, 270, 360... and the EUDC font can be
// rotated by 90 degrees, we accept this link.

    if( ifioEudc.b90DegreeRotations() && bRotIs90Degree )
        return( TRUE );

// if not, we reject this link.

    return( FALSE );
}


/******************************Public*Routine******************************\
* IsSingularEudcGlyph
*
* History:
*
*  25-Jul-95 -by- Hideyuki Nagase
* Wrote it.
\**************************************************************************/

BOOL IsSingularEudcGlyph
(
    GLYPHDATA *wpgd, BOOL bSimulatedBold
)
{
//
// Determine this is really registerd EUDC glyph or not.
//
// [NT 3.51 code for reference]
//
//  if( wpgd->rclInk.left == 0 &&
//      wpgd->rclInk.top  == 0 &&
//      (wpgd->rclInk.right  == 0 || wpgd->rclInk.right  == 1) &&
//      (wpgd->rclInk.bottom == 0 || wpgd->rclInk.bottom == 1)
//    )
//      return( TRUE );
//
// This glyph does not have advance width, it might be non-registered
// character, then return TRUE to let replace this with EUDC default
// character.
//

// dchinn 5/12/99: The code used to use the bSimulatedBold flag.
// If bSimulatedBold were TRUE and if fxD == 0x10, then we return TRUE.
// That code is no longer needed because ClaudeBe made a change elsewhere
// to leave fxD as 0x00 when doing bold simulation.  So, the test below
// is correct whether or not bSimulatedBold is TRUE.

    if( wpgd->fxD == 0 ) return( TRUE );

//
// Otherwise, use this glyph.
//
    return( FALSE );
}

BOOL RFONTOBJ::bInitSystemTT(XDCOBJ &dco)
{
    UINT iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);
    RFONTOBJ rfo;
    EUDCLOGFONT SystemTTLogfont;

    ComputeEUDCLogfont(&SystemTTLogfont, dco);

    PFE *ppfeSystem = (gappfeSystemDBCS[iPfeOffset] == NULL) ?
      gappfeSystemDBCS[PFE_NORMAL] : gappfeSystemDBCS[iPfeOffset];

    rfo.vInit(dco,ppfeSystem,&SystemTTLogfont,FALSE );

    if( rfo.bValid() )
    {
        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                     "vInitSystemTT() -- linking system DBCS font");

        prfnt->prfntSystemTT = rfo.prfntFont();

    }
    return(prfnt->prfntSystemTT != NULL);
}


GLYPHDATA *RFONTOBJ::FindLinkedGlyphDataPlus
(
    XDCOBJ  *pdco,
    ESTROBJ *pto,
    WCHAR    wc,
    COUNT    index,
    COUNT    c,
    BOOL    *pbAccel,
    BOOL     bSystemTTSearch,
    BOOL     bGetBits
)
{
    GLYPHDATA *wpgd;

    LONG *plPartition = pto ? pto->plPartitionGet() : NULL;

// don't setup system EUDC font if there are remote links

    if(!pdco->uNumberOfLinkedUFIs() && bSystemTTSearch && bIsSystemTTGlyph(wc))
    {
        if(!prfnt->prfntSystemTT)
        {
            WARNING("Error initializing TT system font 2\n");
            return(pgdDefault());
        }
        
        if(pto && !(pto->bSystemPartitionInit()))
        {
        // this call can't fail for the SystemTT case
            pto->bPartitionInit(c,0,FALSE);
        }

    // mark the glyph as coming from a SystemTT font

        RFONTTMPOBJ rfo;

        rfo.vInit(prfnt->prfntSystemTT);

        if(rfo.bValid() &&
           (wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this) : rfo.pgdGetEudcMetrics(wc, this)))
        {

            if (pto)
            {
                ASSERTGDI(pto->bSystemPartitionInit(),
                          "FindLinkedGlyphDataPlus: FontLink partition no initialized\n");

                pto->vTTSysGlyphsInc();
                plPartition[index] = EUDCTYPE_SYSTEM_TT_FONT;

            // turn off accelerator since we're going to mess with the driver

                *pbAccel = FALSE;
            }

            return(wpgd);
        }
         else
        {
            return(pgdDefault());
        }
    }

// next search through all the EUDC fonts in order to see if the glyph is one of them

    for( UINT uiFont = 0;
              uiFont < prfnt->uiNumLinks;
              uiFont ++ )
    {
        RFONTTMPOBJ rfo;

        rfo.vInit( prfnt->paprfntFaceName[uiFont] );

        if(rfo.bValid())
        {
            if( (wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this)
                                : rfo.pgdGetEudcMetrics(wc, this)) != NULL )
            {
        if( !IsSingularEudcGlyph(wpgd, rfo.pfo()->flFontType & FO_SIM_BOLD) )
                {

                    if (pto)
                    {
                        plPartition[index] = EUDCTYPE_FACENAME + uiFont;
                        pto->vFaceNameInc(uiFont);

                    // turn off accelerator since we're going to mess with the driver

                        *pbAccel = FALSE;
                    }

                    return( wpgd );
                }
            }
        }
    }

// see if the glyph is in the DEFAULT EUDC font

    if( prfnt->prfntDefEUDC != NULL )
    {
        RFONTTMPOBJ rfo( prfnt->prfntDefEUDC );

        if (rfo.bValid())
        {
            wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this)
                            : rfo.pgdGetEudcMetrics(wc, this);

            if( wpgd != NULL )
            {
        if( !IsSingularEudcGlyph(wpgd, rfo.pfo()->flFontType & FO_SIM_BOLD) )
                {
                    if (pto)
                    {
                    // mark this character as an EUDC character

                        plPartition[index] = EUDCTYPE_DEFAULT;

                    // increment count of Sys EUDC glyphs

                        pto->vDefGlyphsInc();

                    // turn off accelerator since we're going to mess with the driver

                        *pbAccel = FALSE;
                    }

                    return( wpgd );
                }
            }
        }
    }

// see if the glyph is in the SYSTEM-WIDE EUDC font

    if( prfnt->prfntSysEUDC != NULL )
    {
        RFONTTMPOBJ rfo( prfnt->prfntSysEUDC );

        if (rfo.bValid())
        {
            wpgd = bGetBits ? rfo.pgdGetEudcMetricsPlus(wc, this)
                            : rfo.pgdGetEudcMetrics(wc, this);

            if( wpgd != NULL )
            {
        if( !IsSingularEudcGlyph(wpgd, rfo.pfo()->flFontType & FO_SIM_BOLD))
                {
                    if (pto)
                    {
                    // mark this character as an EUDC characte and indicate that there
                    // are EUDC glyphs in the font

                        plPartition[index] = EUDCTYPE_SYSTEM_WIDE;
                        pto->vSysGlyphsInc();

                    // turn off accelerator since we're going to mess with the driver

                        *pbAccel = FALSE;
                    }
                    return( wpgd );
                }
            }
        }
    }

    return( NULL );
}

/******************************Public*Routine******************************\
* RFONTOBJ::wpgdGetLinkMetricsPlus
*
* If GetGlyphMetricsPlus encounters a default character call off to this
* routine to try and get it from the EUDC and face name linked fonts.
*
* History:
*
*  19-Jan-95 -by- Hideyuki Nagase
* Rewrote it.
*
*  14-Jul-93 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

GLYPHDATA *RFONTOBJ::wpgdGetLinkMetricsPlus
(
    XDCOBJ      *pdco,
    ESTROBJ     *pto,
    WCHAR       *pwc,
    WCHAR       *pwcInit,
    COUNT        c,
    BOOL        *pbAccel,
    BOOL         bGetBits
)
{
    GLYPHDATA *wpgd;
    WCHAR *pwcCurrent = pwc;
    WCHAR *pwcEnd = pwcInit + c;

    // bLinkingTurnedOff forces linking to be turned off.  It will be TRUE
    // when we are printing an EMF file that originated on a machine that
    // had no fontlinking turned on

    if(pdco == NULL ||
       pdco->bLinkingTurnedOff() ||
       (!gbAnyLinkedFonts && !IS_SYSTEM_EUDC_PRESENT() && (pdco->uNumberOfLinkedUFIs() == 0)))
    {
        return(pgdDefault());
    }


    for (; (pwcCurrent < pwcEnd && (*pwcCurrent >= 0x80) && (*pwcCurrent <= 0x9F) ); pwcCurrent+=1)
    {
    }

    if (pwcCurrent == pwcEnd)
    {
        // all the characters are in the range 0x80 to 0x9F
        // we don't want to look through font linking for characters in that range

        // this is a performance issue to avoid calling font linking code on English system with 
        // far east language pack installed

        // client side caching is requesting through iGetPublicWidthTable() the width for ANSI codes
        // 0x00 to 0xFF, those code are converted to Unicode. Some code in the range 0x80->0x9F
        // are not converted and stay in that range causing the linked fonts to be loaded to look for those characters
        // Unicode in that range belong to the C1 controls, it doesn't make sense to look for them through
        // font linking, see Windows bug 157772.

        return(pgdDefault());
    }


    // always initialize the System TT to avoid a deadlock situation

    if (!pdco->uNumberOfLinkedUFIs() && prfnt->bIsSystemFont)
    {
        if((!prfnt->prfntSystemTT) && !bInitSystemTT(*pdco))
        {
            WARNING("Error initializing TT system font 4\n");
        }
        else
        {
            GreAcquireSemaphore(prfnt->hsemEUDC);
            
            if(!(prfnt->flEUDCState & TT_SYSTEM_INITIALIZED))
            {
                INCREMENTEUDCCOUNT;
                RFONTTMPOBJ rfo(prfnt->prfntSystemTT);
                rfo.vGetCache();
    
                prfnt->flEUDCState |= TT_SYSTEM_INITIALIZED;
            }

            GreReleaseSemaphore(prfnt->hsemEUDC);
        }
    }

// if this is an SBCS system font and the glyph exists in the DBCS TT system front
// grab it from there

    if(!pdco->uNumberOfLinkedUFIs() && bIsSystemTTGlyph(*pwc))
    {
        if(!prfnt->prfntSystemTT)
        {
            WARNING("Invalid prfntSystemTT\n");
            return(pgdDefault());
        }

        if(pto && !(pto->bSystemPartitionInit()))
        {
        // this call can't fail for the SystemTT case
            pto->bPartitionInit(c,0,FALSE);
        }

    // mark the glyph as coming from a SystemTT font

        RFONTTMPOBJ rfo;

        rfo.vInit(prfnt->prfntSystemTT);

        if(rfo.bValid() &&
           (wpgd = (bGetBits ? rfo.pgdGetEudcMetricsPlus(*pwc, this)
                                : rfo.pgdGetEudcMetrics(*pwc, this))))
        {
            if (pto)
            {
                ASSERTGDI(pto->bSystemPartitionInit(),
                          "wpgdGetLinkMetricsPlus: FontLink partition no initialized\n");

                LONG *plPartition = pto->plPartitionGet();
                pto->vTTSysGlyphsInc();
                plPartition[pwc-pwcInit] = EUDCTYPE_SYSTEM_TT_FONT;

            // turn off accelerator since we're going to mess with the driver

                *pbAccel = FALSE;
            }

            return(wpgd);
        }
        else
        {
            return(pgdDefault());
        }
    }

// if the codepoint is not in any linked font or the EUDC information is
// being changed just return the default character

    if(!pdco->uNumberOfLinkedUFIs() &&!bIsLinkedGlyph( *pwc ))
    {
        return( pgdDefault() );
    }

    // initialize EUDC fonts if we haven't done so already
    {
        GreAcquireSemaphore(prfnt->hsemEUDC);

        if( !( prfnt->flEUDCState & EUDC_INITIALIZED ) )
        {

        // this value will be decremented in RFONTOBJ::dtHelper()

            INCREMENTEUDCCOUNT;

            FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,
                      "wpgdGetLinkMetricsPlus():No request to change EUDC data %d\n", gcEUDCCount);
    
            vInitEUDC( *pdco );

        // lock the font cache semaphores for any EUDC rfonts linked to this font

            if( prfnt->prfntSysEUDC != NULL )
            {
            // lock the SystemEUDC RFONT cache

                RFONTTMPOBJ rfo( prfnt->prfntSysEUDC );
                rfo.vGetCache();
            }

            if( prfnt->prfntDefEUDC != NULL )
            {
                RFONTTMPOBJ rfo( prfnt->prfntDefEUDC );
                rfo.vGetCache();
            }

            for( UINT ii = 0; ii < prfnt->uiNumLinks; ii++ )
            {
                if( prfnt->paprfntFaceName[ii] != NULL )
                {
                    RFONTTMPOBJ rfo( prfnt->paprfntFaceName[ii] );
                    rfo.vGetCache();
                }
            }

            prfnt->flEUDCState |= EUDC_INITIALIZED;

        }

        GreReleaseSemaphore(prfnt->hsemEUDC);
    }
    
    if (pto && !(pto->bPartitionInit()) )
    {
    // Sets up partitioning pointers and glyph counts in the ESTROBJ.

        if( !(pto->bPartitionInit(c,prfnt->uiNumLinks,TRUE)) )
        {
            return( pgdDefault() );
        }
    }

// Find linked font GLYPHDATA

    wpgd = FindLinkedGlyphDataPlus(
               pdco,pto,*pwc,(COUNT)(pwc-pwcInit),c,pbAccel,FALSE, bGetBits);

    if( wpgd == NULL )
    {
    // load EudcDefault Char GlyphData from "Base font".

        wpgd = bGetBits ?
               pgdGetEudcMetricsPlus(EudcDefaultChar, NULL) :
               pgdGetEudcMetrics(EudcDefaultChar, NULL);

        if( wpgd != NULL )
        {
            return( wpgd );
        }

    // load EudcDefault Char GlyphData from "Linked font".

        wpgd = FindLinkedGlyphDataPlus(pdco,pto,EudcDefaultChar,(COUNT)(pwc-pwcInit),c,pbAccel,TRUE, bGetBits);

        if( wpgd != NULL )
        {
            return( wpgd );
        }

    // Otherwise return default char of base font.

        return( pgdDefault() );
    }

    return( wpgd );
}

/******************************Public*Routine******************************\
 * RFONTOBJ::dtHelper()
 *
 *  Thu 12-Jan-1995 15:00:00 -by- Hideyuki Nagase [hideyukn]
 * Rewrote it.
 **************************************************************************/

VOID RFONTOBJ::dtHelper(BOOL bReleaseEUDC2)
{

    FLINKMESSAGE(DEBUG_FONTLINK_RFONT,"Calling dtHelper()\n");

    GreAcquireSemaphore(prfnt->hsemEUDC);


// if SystemTT RFONTOBJ was used release it

    if((prfnt->flEUDCState & TT_SYSTEM_INITIALIZED) &&
       !(prfnt->flEUDCState & EUDC_NO_CACHE))
    {
        if (prfnt->prfntSystemTT)
        {
            RFONTTMPOBJ rfo(prfnt->prfntSystemTT);
            rfo.vReleaseCache();
            DECREMENTEUDCCOUNT;
        }
    }

// if EUDC was initizlized for this RFONTOBJ, clean up its.

    if( prfnt->flEUDCState & EUDC_INITIALIZED )
    {

        if(!(prfnt->flEUDCState & EUDC_NO_CACHE))
        {
            for( INT ii = prfnt->uiNumLinks - 1; ii >= 0; ii-- )
            {
                if( prfnt->paprfntFaceName[ii] != NULL )
                {
                    RFONTTMPOBJ rfo( prfnt->paprfntFaceName[ii] );
                    rfo.vReleaseCache();
                }
            }

            if( prfnt->prfntDefEUDC != NULL )
            {
                RFONTTMPOBJ rfo( prfnt->prfntDefEUDC );
                rfo.vReleaseCache();
            }

            if( prfnt->prfntSysEUDC != NULL )
            {
                RFONTTMPOBJ rfo( prfnt->prfntSysEUDC );
                rfo.vReleaseCache();
            }
        }

        if (bReleaseEUDC2)
        {
            ASSERTGDI(gcEUDCCount > 0, "gcEUDCCount <= 0\n");
            DECREMENTEUDCCOUNT;
        }
    }

    prfnt->flEUDCState &= ~(EUDC_INITIALIZED|TT_SYSTEM_INITIALIZED|EUDC_NO_CACHE);

    GreReleaseSemaphore(prfnt->hsemEUDC);
    
}


/******************************************************************************
 * void RFONTOBJ::ComputeEUDCLogfont(EUDCLOGFONT*)
 *
 * This function computes an EUDCLOGFONT from a base font.
 *
 *****************************************************************************/


void RFONTOBJ::ComputeEUDCLogfont(EUDCLOGFONT *pEudcLogfont, XDCOBJ& dco)
{
    PDEVOBJ pdo(dco.hdev());
    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);

    PFEOBJ pfeo(prfnt->ppfe);
    RFONTTMPOBJ rfoT(prfnt);
    DCOBJ       dcoT(dco.hdc());
    IFIOBJR     ifio(pfeo.pifi(),rfoT,dcoT);
    BOOL        bFixedPitch = FALSE;

    if (!lfo.bValid())
        return;

    pEudcLogfont->fsSelection    = ifio.fsSelection();
    pEudcLogfont->flBaseFontType = pfo()->flFontType;
    pEudcLogfont->lBaseHeight    = lfo.lHeight();
    pEudcLogfont->lBaseWidth     = lfo.lWidth();
    pEudcLogfont->lEscapement    = lfo.lEscapement();
    pEudcLogfont->ulOrientation  = lfo.ulOrientation();

    LONG  lInternalLeading = 0;

    if(ifio.bFixedPitch())
        bFixedPitch = TRUE;

// We have to try to scale linked font as exactly same size as base font.

    if( !(pEudcLogfont->bContinuousScaling = ifio.bContinuousScaling()) )
    {
        if (dco.pdc->bWorldToDeviceIdentity())
        {
        // We only need to get the AveCharWidth for FIX_PITCH

            if (bFixedPitch)
                pEudcLogfont->lBaseWidth  = ifio.fwdAveCharWidth();

        // these are special case hacks to get better linking with Ms San Serif
        // we force a bitmap for size 8 and 10 and also use ascent based
        // mapping for all other size.
        //
        // Old comment:
        //    for NT 5.0 make this more general
        //    and make it configurable in the registry.
        //

            if(!_wcsicmp(ifio.pwszFaceName(), L"Ms Sans Serif"))
            {

                if(fxMaxExtent() > LTOFX(12) && fxMaxExtent() < LTOFX(17))
                {
                    pEudcLogfont->lBaseHeight = 12;
                }
                else
                {
                    pEudcLogfont->lBaseHeight =
                      LONG_FLOOR_OF_FIX(fxMaxAscent() + FIX_HALF);
                }
            }

            else
            if(ulFontLinkControl & FLINK_SCALE_EUDC_BY_HEIGHT)
            {
                pEudcLogfont->lBaseHeight = LONG_FLOOR_OF_FIX(fxMaxExtent() + FIX_HALF);
            }
            else
            {
                pEudcLogfont->lBaseHeight = LONG_FLOOR_OF_FIX(fxMaxAscent() + FIX_HALF);
            }
        }
        else
        {
            if (bFixedPitch)
                pEudcLogfont->lBaseWidth = lCvt(efDtoWBase_31(),((LONG) ifio.fwdAveCharWidth()) << 4);

            if (ulFontLinkControl & FLINK_SCALE_EUDC_BY_HEIGHT)
            {
                pEudcLogfont->lBaseHeight = lCvt(efDtoWAscent_31(),(LONG) fxMaxExtent());
            }
            else
            {
                pEudcLogfont->lBaseHeight = lCvt(efDtoWAscent_31(),(LONG) fxMaxAscent());
            }
        }

    // Multiply raster interger scaling value.
    // (Only for Width, Height was already scaled value.)

        if (bFixedPitch)
            pEudcLogfont->lBaseWidth *= prfnt->ptlSim.x;

        FLINKMESSAGE(DEBUG_FONTLINK_DUMP,"GDISRV:BaseFont is RASTER font\n");
    }
    else
    {
        LONG    lBaseHeight;

        if (dco.pdc->bWorldToDeviceIdentity())
        {
            lBaseHeight = LONG_FLOOR_OF_FIX(fxMaxExtent() + FIX_HALF);
        }
         else
        {
            lBaseHeight = lCvt(efDtoWAscent_31(),(LONG) fxMaxExtent());
        }

        if (lNonLinearIntLeading() == MINLONG)
        {
        // Rather than scaling the notional internal leading, try
        // to get closer to HINTED internal leading by computing it
        // as the difference between the HINTED height and UNHINTED
        // EmHeight.

            lInternalLeading = lBaseHeight - lCvt(efNtoWScaleAscender(),ifio.fwdUnitsPerEm());
            if (bFixedPitch)
                pEudcLogfont->lBaseWidth = lCvt(efNtoWScaleBaseline(), ifio.tmAveCharWidth());        
        }
        else
        {
        // But if the font provider has given us a hinted internal leading,
        // just use it.

            lInternalLeading =
            lCvt(efDtoWAscent_31(),lNonLinearIntLeading());
            if (bFixedPitch)
                pEudcLogfont->lBaseWidth = lCvt(efDtoWBase_31(), lNonLinearAvgCharWidth());        
        }

        // Check we should eliminate the internal leading for EUDC size.

        if( lInternalLeading < 0 )
            pEudcLogfont->lBaseHeight = lBaseHeight + lInternalLeading;
        else
            pEudcLogfont->lBaseHeight = lBaseHeight - lInternalLeading;

        if ((pEudcLogfont->lBaseHeight <= 13))
        {
            if (pEudcLogfont->lBaseHeight == 11 && lBaseHeight >= 12)
                pEudcLogfont->lBaseHeight = 12;
            else if (pEudcLogfont->lBaseHeight == 13 && lBaseHeight >= 15)
                pEudcLogfont->lBaseHeight = 15;
        }
    }


// if the base font is Raster font. we need to adjust escapement/orientation.
// because they can not generate arbitaraty rotated glyphs.

    if(!(ifio.bArbXforms()))
    {
        if( ifio.b90DegreeRotations() )
        {
        // font provider can support per 90 degree rotations.

            if( pEudcLogfont->ulOrientation )
            {
                ULONG ulTemp;
                ulTemp = lNormAngle(pEudcLogfont->ulOrientation);
                pEudcLogfont->ulOrientation =
                    (ulTemp / ORIENTATION_90_DEG) * ORIENTATION_90_DEG;

                if( (dco.pdc->bYisUp()) && (ulTemp % ORIENTATION_90_DEG))
                    pEudcLogfont->ulOrientation =
                        lNormAngle(pEudcLogfont->ulOrientation + ORIENTATION_90_DEG);
            }

            if( pEudcLogfont->lEscapement )
            {
                LONG lTemp;
                lTemp = lNormAngle(pEudcLogfont->lEscapement);
                pEudcLogfont->lEscapement =
                    (lTemp / ORIENTATION_90_DEG) * ORIENTATION_90_DEG;

                if( (dco.pdc->bYisUp()) && (lTemp % ORIENTATION_90_DEG))
                    pEudcLogfont->lEscapement =
                         lNormAngle(pEudcLogfont->lEscapement + ORIENTATION_90_DEG);
            }
        }
         else
        {
        // font provider can generate only horizontal glyph

            pEudcLogfont->ulOrientation = 0L;
            pEudcLogfont->lEscapement   = 0L;
        }
    }

    #if DBG
    if(gflEUDCDebug & DEBUG_FONTLINK_DUMP)
    {
        DbgPrint(" Base font face name %ws \n", ifio.pwszFaceName());
        DbgPrint("GDISRV:lBaseWidth  = %d\n",pEudcLogfont->lBaseWidth);
        DbgPrint("GDISRV:lBaseHeight = %d\n",pEudcLogfont->lBaseHeight);
        DbgPrint("GDISRV:lInternalL  = %d\n",lInternalLeading);
        DbgPrint("GDISRV:lEscapement  = %d\n",pEudcLogfont->lEscapement);
        DbgPrint("GDISRV:lOrientation = %d\n",pEudcLogfont->ulOrientation);
    }
    #endif
}


/******************************************************************************
 * PFE *ppfeFromUFI(PUNIVERSAL_FONT_ID pufi)
 *
 * Given a UFI, returns a corresponding PFE.  This function assume the caller
 * has grabed the ghsemPublicPFT semaphore.
 *
 *****************************************************************************/


PFE *ppfeFromUFI(PUNIVERSAL_FONT_ID pufi)
{
    PUBLIC_PFTOBJ pfto;
    FHOBJ fho(&pfto.pPFT->pfhUFI);
    HASHBUCKET  *pbkt;

    PFE         *ppfeRet = NULL;

    pbkt = fho.pbktSearch( NULL, (UINT*)NULL, pufi );

    if( pbkt != NULL )
    {
        PFELINK  *ppfel;

        for (ppfel = pbkt->ppfelEnumHead ; ppfel; ppfel = ppfel->ppfelNext)
        {
            PFEOBJ pfeo (ppfel->ppfe);

        // if the UFI's match and (in the case of a remote font) the process
        // that created the remote font is the same as the current one then
        // we've got a match

            if(UFI_SAME_FACE(pfeo.pUFI(),pufi) && pfeo.SameProccess())
            {
                if( pfeo.bDead() )
                {
                    WARNING("MAPPER::bFoundForcedMatch mapped to dead PFE\n");
                }
                else
                {
                    ppfeRet = ppfel->ppfe;
                    break;
                }
            }
        }

    #if DBG
        if (!ppfel)
        {
            WARNING1("ppfeFromUFI couldn't map to PFE\n");
        }
    #endif

    }
    else
    {
        WARNING("ppfeFromUFI pbkt is NULL\n");
    }

    return ppfeRet;
}


void RFONTOBJ::vInitEUDCRemote(XDCOBJ& dco)
{

#if DBG
    DbgPrint("calling remote vinit\n");
#endif // DBG

    if((prfnt->paprfntFaceName != NULL) &&
       (prfnt->paprfntFaceName[0] != NULL))
    {
    // If there is at least one facename link then the remote links must be initialized.
    // The set of links for a particular RFONT will never change during a print
    // job and the RFONT can only be used for this print-job (PDEV).  Thus we
    // don't have to check a time stamp or anything else to determine if the links
    // have changed and can simply return.

        return;
    }

// remote UFIs get treated as facename links so first initialize the facename array

    if(prfnt->paprfntFaceName == (PRFONT *)NULL)
    {
        if(dco.uNumberOfLinkedUFIs() > QUICK_FACE_NAME_LINKS)
        {
            if(!(prfnt->paprfntFaceName =
                 (PRFONT *)PALLOCMEM(dco.uNumberOfLinkedUFIs() * sizeof(PRFONT),'flnk')))
            {
                WARNING("vInitEUDCRemote: out of memory\n");
                return;
            }
        }
        else
        {
            prfnt->paprfntFaceName = prfnt->aprfntQuickBuff;
        }
    }

    prfnt->uiNumLinks = 0;

// Lock and Validate the LFONTOBJ user object.

    UINT u;
    PFEOBJ pfeo(prfnt->ppfe);
    PDEVOBJ pdo(dco.hdev());
    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);

    RFONTTMPOBJ rfoT(prfnt);
    DCOBJ       dcoT(dco.hdc());
    IFIOBJR     ifio(pfeo.pifi(),rfoT,dcoT);

// Fill up LogFont for EUDC.

    EUDCLOGFONT EudcLogFont;

    ComputeEUDCLogfont(&EudcLogFont, dco);

    for(u = 0; u < dco.uNumberOfLinkedUFIs(); u++)
    {
        {
         // this set of brackets is to make sure the ppfref descructor gets called
            PFE *ppfe;
            PFFREFOBJ pffref;
            RFONTOBJ rfo;

#if DBG
            DbgPrint("Trying to get pfe %d\n", u);
#endif // DBG

            {
                SEMOBJ  so(ghsemPublicPFT);

                if(ppfe = ppfeFromUFI(&dco.pufiLinkedFonts()[u]))
                {
                    PFEOBJ  pfeo1(ppfe);
                    pffref.vInitRef(pfeo1.pPFF());
#if DBG
                    DbgPrint("Found it\n");
#endif // DBG
                }

            }

            if(ppfe)
            {
                rfo.vInit(dco, ppfe, &EudcLogFont, FALSE);

                if(rfo.bValid())
                {
#if DBG
                    DbgPrint("Got a valid RFONT ENTRY\n");
#endif // DBG
                    prfnt->paprfntFaceName[prfnt->uiNumLinks++] =
                      rfo.prfntFont();
                }
            }
        }
    }

#if DBG
    DbgPrint("done: font has %d remote links\n", prfnt->uiNumLinks);
#endif // DBG
}


/******************************Public*Routine******************************\
* RFONTOBJ::vInitEUDC( XDCOBJ )
*
* This routine is called during text out when the first character that isn't
* in the base font is encountered.  vInitEUDC will then realize any EUDC RFONTS
* (if they haven't already been realized on previous text outs) so that they
* can possibly be used if the character(s) are in the EUDC fonts.
*
*  Thu 12-Jan-1995 15:00:00 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vInitEUDC( XDCOBJ& dco )
{

    if(dco.uNumberOfLinkedUFIs())
    {
        vInitEUDCRemote(dco);
        return;
    }

    FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                 "Calling vInitEUDC()\n");

// If we have already initialized System EUDC font, and NOT have
// any FaceName Linked font, we have nothing to do in this function.

    PFEOBJ pfeo(prfnt->ppfe);

// In most cases, we have the system EUDC font, at least.
// If the system eudc was initizlied, we might short-cut the eudc realization.

    if((prfnt->prfntSysEUDC != NULL) || (!IS_SYSTEM_EUDC_PRESENT()))
    {
    // if default eudc scheme is disabled or is already initizlied. we can
    // short-cut the realization.

        if((!bFinallyInitializeFontAssocDefault && !gbSystemDBCSFontEnabled) ||
           (prfnt->prfntDefEUDC != NULL) )
        {
        // if there is no facename eudc for this font or, is already initizlied
        // we can return here...

            if((pfeo.pGetLinkedFontEntry() == NULL) ||
               ((prfnt->paprfntFaceName != NULL) &&
                (pfeo.pGetLinkedFontEntry() != NULL) &&
                (prfnt->bFilledEudcArray == TRUE) &&
                (prfnt->ulTimeStamp == pfeo.ulGetLinkTimeStamp())))
            {
                return;
            }
        }
    }

// Lock and Validate the LFONTOBJ user object.

    PDEVOBJ pdo(dco.hdev());
    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);

    RFONTTMPOBJ rfoT(prfnt);
    DCOBJ       dcoT(dco.hdc());
    IFIOBJR     ifio(pfeo.pifi(),rfoT,dcoT);

// Fill up LogFont for EUDC.

    EUDCLOGFONT EudcLogFont;

    ComputeEUDCLogfont(&EudcLogFont, dco);

// first handle the system EUDC font

    UINT iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);

    if((prfnt->prfntSysEUDC == NULL) &&
       (gappfeSysEUDC[iPfeOffset] != NULL))
    {
        RFONTOBJ    rfo;
        PFEOBJ      pfeoEudc(gappfeSysEUDC[iPfeOffset]);
        IFIOBJ      ifioEudc(pfeoEudc.pifi());

         FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                      "Connecting System wide EUDC font....\n");

    // check Eudc font capacity

        if(!bCheckEudcFontCaps(ifioEudc))
        {
        // font capacity is not match we won't use system eudc.

            prfnt->prfntSysEUDC = (RFONT *)NULL;
        }
        else
        {
            rfo.vInit( dco,
                       gappfeSysEUDC[iPfeOffset],
                       &EudcLogFont,
                       FALSE );      // prfnt->cache.bSmallMetrics );

            if( rfo.bValid() )
            {
                FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                             "vInitEUDC() -- linking System EUDC\n");

                prfnt->prfntSysEUDC = rfo.prfntFont();
            }
        }
    }

// next handle default links

    if(bFinallyInitializeFontAssocDefault && (prfnt->prfntDefEUDC == NULL))
    {
        BYTE jWinCharSet        = (ifio.lfCharSet());
        BYTE jFamily            = (ifio.lfPitchAndFamily() & 0xF0);
        UINT iIndex             = (jFamily >> 4);
        BOOL bEnableDefaultLink = FALSE;

        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                     "Connecting Default EUDC font....\n");

    // Check default font association is disabled for this charset or not.

        switch (jWinCharSet)
        {
        case ANSI_CHARSET:
        case OEM_CHARSET:
        case SYMBOL_CHARSET:
            //
            // following code is equal to
            //
            // if ((Char == ANSI_CHARSET   && fFontAssocStatus & ANSI_ASSOC)  ||
            //     (Char == OEM_CHARSET    && fFontAssocStatus & OEM_ASSOC)   ||
            //     (Char == SYMBOL_CHARSET && fFontAssocStatus & SYMBOL_ASSOC)  )
            //
            if( ((jWinCharSet + 2) & 0xf) & fFontAssocStatus )
            {
                bEnableDefaultLink = TRUE;
            }
             else
                bEnableDefaultLink = FALSE;
            break;

        default:
            bEnableDefaultLink = FALSE;
            break;
        }

        if( bEnableDefaultLink )
        {
        // Check the value is valid or not.

            if( iIndex < NUMBER_OF_FONTASSOC_DEFAULT )
            {
                ASSERTGDI( (FontAssocDefaultTable[iIndex].DefaultFontType == jFamily),
                            "GDISRV:FONTASSOC DEFAULT:Family index is wrong\n");

            // if the registry data for specified family's default is ivalid
            // use default.....

                if( !FontAssocDefaultTable[iIndex].ValidRegData )
                {
                    iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
                }
            }
             else
            {
            // iIndex is out of range, use default one....

                WARNING("GDISRV:FontAssoc:Family is strange, use default\n");

                iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
            }


        // If vertical font is selected for base font, but the vertical font for
        // default EUDC is not available, but normal font is provided, use normal
        // font.

            if((iPfeOffset == PFE_VERTICAL) &&
               (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] ==
                PPFENULL) &&
                (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL] != PPFENULL))
            {
                iPfeOffset = PFE_NORMAL;
            }

            RFONTOBJ    rfo;
            PFEOBJ pfeoEudc(FontAssocDefaultTable[iIndex].DefaultFontPFEs[iPfeOffset]);

        // Check the PFE in default table is valid or not.

            if( pfeoEudc.bValid() )
            {
                IFIOBJ      ifioEudc(pfeoEudc.pifi());

                if( !bCheckEudcFontCaps(ifioEudc) )
                {
                    prfnt->prfntDefEUDC = (RFONT *)NULL;
                }
                 else
                {
                    rfo.vInit( dco,
                               FontAssocDefaultTable[iIndex].DefaultFontPFEs[iPfeOffset],
                               &EudcLogFont,
                               FALSE );      // prfnt->cache.bSmallMetrics );

                    if( rfo.bValid() )
                    {
                        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                                     "vInitEUDC() -- linking default EUDC\n");

                        prfnt->prfntDefEUDC = rfo.prfntFont();
                    }
                }
            }
        }
        else
        {
        // FontAssociation is disabled for this charset.

            prfnt->prfntDefEUDC = (RFONT *)NULL;
        }
    }
    else
    {
        prfnt->prfntDefEUDC = NULL;
    }

// next handle all the face name links

    if(pfeo.pGetLinkedFontEntry() != NULL)
    {
        BOOL bNeedToBeFilled = !(prfnt->bFilledEudcArray);

        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,"Connecting Face name EUDC font....\n");

        //
        // if this RFONT has linked RFONT array and its linked font information
        // is dated, just update it here..
        //

        if((prfnt->paprfntFaceName != NULL) &&
           (prfnt->ulTimeStamp != pfeo.ulGetLinkTimeStamp()))
        {
            FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                         "vInitEUDC():This RFONT is dated, now updating...\n");

            //
            // Inactivating old linked RFONT.
            //
            // if Eudc font that is linked to this RFONT was removed, the removed
            // RFONT entry contains NULL, and its Eudc RFONT is already killed during
            // EudcUnloadLinkW() function. then we should inactivate all Eudc RFONT that
            // is still Active (Not Killed)..
            //

            for( UINT ii = 0 ; ii < prfnt->uiNumLinks ; ii++ )
            {
                //
                // Check Eudc RFONT is still active..
                //

                if( prfnt->paprfntFaceName[ii] != NULL )
                {
                    RFONTTMPOBJ rfoTmp( prfnt->paprfntFaceName[ii] );

                    #if DBG
                    if( gflEUDCDebug & DEBUG_FONTLINK_RFONT )
                    {
                        DbgPrint("vInitEUDC() deactivating linked font %x\n",
                                  prfnt->paprfntFaceName[ii]);
                    }
                    #endif

                    rfoTmp.bMakeInactiveHelper((PRFONT *)NULL);

                    prfnt->paprfntFaceName[ii] = NULL;
                }
            }

            //
            // Free this Array if it was allocated..
            //

            if( prfnt->paprfntFaceName != prfnt->aprfntQuickBuff )
                VFREEMEM( prfnt->paprfntFaceName );

            //
            // Invalidate the pointer.
            //

            prfnt->paprfntFaceName = (PRFONT *)NULL;
            prfnt->uiNumLinks      = 0;
        }

        if( prfnt->paprfntFaceName == (PRFONT *)NULL )
        {
            if(pfeo.pGetLinkedFontEntry()->uiNumLinks > QUICK_FACE_NAME_LINKS)
            {
                prfnt->paprfntFaceName =
                  (PRFONT *)PALLOCMEM(pfeo.pGetLinkedFontEntry()->uiNumLinks *
                                      sizeof(PRFONT),'flnk');
            }
             else
            {
                prfnt->paprfntFaceName = prfnt->aprfntQuickBuff;
            }

            bNeedToBeFilled = TRUE;
        }

        if( bNeedToBeFilled )
        {
            PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;
            UINT        uiRfont = 0;

            while( p != pfeo.pGetLinkedFontList() )
            {
                #if DBG
                if( gflEUDCDebug & DEBUG_FONTLINK_RFONT )
                {
                    DbgPrint("vInitEUDC() -- linking FaceName %d\n", uiRfont);
                }
                #endif

                PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);

                //
                // Check this linked font have Vertical facename or not,
                // if it doesn't have, use normal facename...
                //

                UINT iPfeOffsetLocal;

                if( ppfeData->appfe[iPfeOffset] == NULL )
                    iPfeOffsetLocal = PFE_NORMAL;
                 else
                    iPfeOffsetLocal = iPfeOffset;

                PFEOBJ   pfeoEudc(ppfeData->appfe[iPfeOffsetLocal]);
                IFIOBJ   ifioEudc(pfeoEudc.pifi());

                if( bCheckEudcFontCaps(ifioEudc) )
                {
                    RFONTOBJ rfo;

                    rfo.vInit( dco,
                               ppfeData->appfe[iPfeOffsetLocal],
                               &EudcLogFont,
                               FALSE );        // prfnt->cache.bSmallMetrics );

                    if( rfo.bValid() )
                    {
                        ASSERTGDI(uiRfont < pfeo.pGetLinkedFontEntry()->uiNumLinks ,
                                 "uiRfont >= pfeo.uiNumLinks\n");
                        prfnt->paprfntFaceName[uiRfont] = rfo.prfntFont();

                        //
                        // Increase real linked font number.
                        //

                        uiRfont++;
                    }
                }

                p = p->Flink;
            }


            prfnt->uiNumLinks = uiRfont;

            prfnt->ulTimeStamp = pfeo.ulGetLinkTimeStamp();

            prfnt->bFilledEudcArray = TRUE;
        }
    }
    else
    {
    // if this PFE has no eudc link list..
    // the pointer to linked RFONT array should be NULL.

        ASSERTGDI(prfnt->paprfntFaceName == NULL,
                  "vInitEUDC():The font has not linked font, but has its Array\n");
    }

    #if DBG
    if(gflEUDCDebug & DEBUG_FONTLINK_DUMP) lfo.vDump();
    #endif
}

/******************************Public*Routine******************************\
* RFONTOBJ::vInit (DCOBJ, PFE*, LONG, FIX)
*
* This is a special constructor used for EUDC fonts.  Rather than use the
* LOGFONT currently selected into the DC to map to a PFE, it is passed in
* a PFE.  If lBaseWidth of lBaseHeight is non-zero vInit will try to realize a
* font with width and height as close as possible to those lBaseWidth/Height.
*
*  Tue 24-Oct-1995 12:00:00 -by- Hideyuki Nagase [hideyukn]
* Rewrote it.
*
*  Thu 23-Feb-1995 10:00:00 -by- Hideyuki Nagase [hideyukn]
* SmallMetrics support.
*
*  Fri 25-Mar-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vInit(
    XDCOBJ      &dco,
    PFE         *ppfeEUDCFont,
    EUDCLOGFONT *pEudcLogFont,
    BOOL         bSmallMetrics
    )
{
    SEMOBJ  sem(ghsemEUDC2);
        
    BOOL bNeedPaths = dco.pdc->bActive() ? TRUE : FALSE;

    FLINKMESSAGE(DEBUG_FONTLINK_RFONT,"gdisrv!vInit():Initializing EUDC font.\n");

    ASSERTGDI(bSmallMetrics == FALSE,"gdisrv!bSmallMetrics is 1 for EUDC font\n");

    BOOL bRet = FALSE;

// Get PDEV user object (need for bFindRFONT).
// This must be done before the ghsemPublicPFT is locked down.

    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI(pdo.bValid(), "gdisrv!RFONTOBJ(dco): bad pdev in dc\n");

// Lock and Validate the LFONTOBJ user object.

    LFONTOBJ lfo(dco.pdc->hlfntCur(), &pdo);
    if (!lfo.bValid())
    {
        WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }

// Now we're ready to track down this RFONT we want...
// Compute the Notional to Device transform for this realization.

    PFEOBJ  pfeo(ppfeEUDCFont);
    IFIOBJ  ifio(pfeo.pifi());

    ASSERTGDI(pfeo.bValid(), "gdisrv!RFONTOBJ(dco): bad ppfe from mapping\n");

// Set bold and italic simulation flags if neccesary

    FLONG flSim = 0;

// if base font is originally italialized or simulated, we
// also generate italic font.

    if ( (pEudcLogFont->flBaseFontType & FO_SIM_ITALIC) ||
         (pEudcLogFont->fsSelection    & FM_SEL_ITALIC)    )
    {
        flSim |= lfo.flEudcFontItalicSimFlags(ifio.bNonSimItalic(),
                                              ifio.bSimItalic());
    }

// If the basefont is BMP font then we only embolden the linked font for Display
// If the basefont is scalable then we embolden linked font at any device.

    if ( (pdo.bDisplayPDEV() || pEudcLogFont->bContinuousScaling) &&
         ((pEudcLogFont->fsSelection & FM_SEL_BOLD) ||
         (pEudcLogFont->flBaseFontType & FO_SIM_BOLD)))
    {
        flSim |= lfo.flEudcFontBoldSimFlags((USHORT)ifio.lfWeight());
    }

//
//
//  We won't set bold simulation flag to font driver.
//  This is for following situation.
// if the base font is FIXED_PITCH font, and enbolden, then
// we need to scale EUDC font as same width of based font.
// but font enbolden simulation is depend on the font driver, we
// might not get exact same witdh of scaled eudc font.
//

//
// this is needed only by ttfd to support win31 hack: VDMX XFORM QUANTIZING
// NOTE: in the case that the requested height is 0 we will pick a default
// value which represent the character height and not the cell height for
// Win 3.1 compatibility.  Thus I have he changed this check to be <= 0
// from just < 0. [gerritv]
//
    if (ifio.bTrueType() && (lfo.plfw()->lfHeight <= 0))
        flSim |= FO_EM_HEIGHT;

// Now we need to check if the base font is going to be antialiased,
// if so we also want to antialias the linked font, if it is capable of it

    if ((pEudcLogFont->flBaseFontType & FO_GRAY16) && (pfeo.pifi()->flInfo & FM_INFO_4BPP))
    {
        flSim |= (pEudcLogFont->flBaseFontType & (FO_GRAY16 | FO_CLEARTYPE_X));
    }

// Hack the width of the logfont to get same width of eudc font as base font.

    LONG lWidthSave         = lfo.lWidth( pEudcLogFont->lBaseWidth );
    LONG lHeightSave        = lfo.lHeight( pEudcLogFont->lBaseHeight );
    ULONG ulOrientationSave = lfo.ulOrientation( pEudcLogFont->ulOrientation );
    ULONG lEscapementSave   = lfo.lEscapement( pEudcLogFont->lEscapement );

    FD_XFORM fdx;           // realize with this notional to device xform
    POINTL   ptlSim;        // for bitmap scaling simulations

    if (!ifio.bContinuousScaling())
    {
        WARNING("EUDC font could not be ContinuousScaling\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }
     else
    {
        ptlSim.x = 1; ptlSim.y = 1; // this will be not used for scalable font...
    }

    bRet = pfeo.bSetFontXform(dco, lfo.plfw(), &fdx,
                              0,
                              flSim,
                              (POINTL* const) &ptlSim,
                              ifio,
                              TRUE  // font is linked
                             );

// if bSetFontXform() was fail, return here....

    if( !bRet )
    {
        lfo.lWidth( lWidthSave );
        lfo.lHeight( lHeightSave );
        lfo.ulOrientation( ulOrientationSave );
        lfo.lEscapement( lEscapementSave );
        WARNING("gdisrv!RFONTOBJ(dco): failed to compute font transform\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }

// Tell PFF about this new reference, and then release the global sem.
// Note that vInitRef() must be called while holding the semaphore.

    PFFREFOBJ pffref;
    {
        SEMOBJ  so(ghsemPublicPFT);
        pffref.vInitRef(pfeo.pPFF());
    }

// go find the font

    EXFORMOBJ xoWtoD(dco.pdc->mxWorldToDevice());
    ASSERTGDI(xoWtoD.bValid(), "gdisrv!RFONTOBJ(dco) - \n");

// Attempt to find an RFONT in the lists cached off the PDEV.  Its transform,
// simulation state, style, etc. all must match.

    if ( bFindRFONT(&fdx,
                    flSim,
                    0, // lfo.pelfw()->elfStyleSize,
                    pdo,
                    &xoWtoD,
                    ppfeEUDCFont,
                    bNeedPaths,
                    dco.pdc->iGraphicsMode(),
                    bSmallMetrics,

                    RFONT_TYPE_UNICODE  // must be unicode for EUDC
                    ) )
    {

        FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,"EUDC RFONT is %x\n",prfnt);

    // now restore the old width

        lfo.lWidth( lWidthSave );
        lfo.lHeight( lHeightSave );
        lfo.ulOrientation( ulOrientationSave );
        lfo.lEscapement( lEscapementSave );

    // Grab cache semaphore.

        vGetCache();
        dco.pdc->vXformChange(FALSE);

        return;
    }

// If we get here, we couldn't find an appropriate font realization.
// Now, we are going to create one just for us to use.

    bRet = bRealizeFont(&dco,
                        &pdo,
                        lfo.pelfw(),
                        ppfeEUDCFont,
                        &fdx,
                        (POINTL* const) &ptlSim,
                        flSim,
                        0, // lfo.pelfw()->elfStyleSize,
                        bNeedPaths,
                        bSmallMetrics,
                        RFONT_TYPE_UNICODE
                       );
// now restore the old width

    lfo.lWidth( lWidthSave );
    lfo.lHeight( lHeightSave );
    lfo.ulOrientation( ulOrientationSave );
    lfo.lEscapement( lEscapementSave );


    if( !bRet )
    {
        WARNING("gdisrv!RFONTOBJ(dco): realization failed, RFONTOBJ invalidated\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        return;
    }

    ASSERTGDI(bValid(), "gdisrv!RFONTOBJ(dco): invalid hrfnt from realization\n");

// We created a new RFONT, we better hold the PFF reference!

    pffref.vKeepIt();

// Finally, grab the cache semaphore.

    vGetCache();
    dco.pdc->vXformChange(FALSE);

    FLINKMESSAGE2(DEBUG_FONTLINK_RFONT,"EUDC RFONT is %x\n",prfnt);

    return;
}

/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bIsLinkedGlyph (WCHAR wc)
*
* Does a quick check to see if a character is in either the system EUDC
* font or a font that has been linked to this RFONT.
*
*  Tue 17-Jan-1995 14:00:00 -by- Hideyuki Nagase [hideyukn]
* Rewrote it.
*
*  Wed 11-Aug-1993 10:00:00 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

#define IS_PRIVATE_EUDC_AREA(wc) \
        (((wc) >= 0xE000) && ((wc) <= 0xF8FF))

BOOL RFONTOBJ::bIsLinkedGlyph( WCHAR wc )
{
    GreAcquireSemaphore( ghsemEUDC1 );

// we don't release ghsemEUDC1 mutex here, we have to guard the current eudc
// link data. All of the API that change eudc data, try to hold this
// mutex, if we hold it, nobody can process the request...
//
// if another thread will change eudc link between this thread is in after
// release the mutex (end of this function) and before we increment gcEUDCCount
// in vInitEUDC(). In the case, this function might return TRUE for non-linked
// char or return FALSE for linked char, but we don't need to worry about this.
// because following line in wpgdGetLinkMetricsPlus() will returns NULL and
// we will return default char. the cost is only time..

    BOOL bRet = FALSE;

// EudcDefaultChar should be displayed for 'Private User Area', when there is no
// font are linked. (font's default character should not be came up).

    if( IS_PRIVATE_EUDC_AREA(wc) )
    {
        bRet = TRUE;
    }

    if( (bRet == FALSE) && IS_SYSTEM_EUDC_PRESENT() && IS_IN_SYSTEM_EUDC(wc) )
    {
        bRet = TRUE;
    }

    if( (bRet == FALSE) && bFinallyInitializeFontAssocDefault )
    {
        //
        // THIS CODEPATH SHOULD BE OPTIMIZED....
        //
        // UNDER_CONSTRUCTION.
        //
        UINT   iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);
        PFEOBJ pfeo(prfnt->ppfe);
        IFIOBJ ifio(pfeo.pifi());
        BYTE   jFamily = (ifio.lfPitchAndFamily() & 0xF0);
        UINT   iIndex  = (jFamily >> 4);

        //
        // Check the value is valid or not.
        //
        if( iIndex < NUMBER_OF_FONTASSOC_DEFAULT )
        {
            ASSERTGDI( (FontAssocDefaultTable[iIndex].DefaultFontType == jFamily),
                        "GDISRV:FONTASSOC DEFAULT:Family index is wrong\n");

            //
            // if the registry data for specified family's default is ivalid
            // use default.....
            //
            if( !FontAssocDefaultTable[iIndex].ValidRegData )
            {
                iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
            }
        }
         else
        {
            //
            // iIndex is out of range, use default..
            //
            WARNING("GDISRV:FontAssoc:Family is strange, use default\n");

            iIndex = (NUMBER_OF_FONTASSOC_DEFAULT-1);
        }

        //
        // If vertical font is selected for base font, but the vertical font for
        // default EUDC is not available, but normal font is provided, use normal
        // font.
        //
        if( (iPfeOffset == PFE_VERTICAL) &&
            (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_VERTICAL] == PPFENULL) &&
            (FontAssocDefaultTable[iIndex].DefaultFontPFEs[PFE_NORMAL]   != PPFENULL))
        {
            iPfeOffset = PFE_NORMAL;
        }

        PFEOBJ      pfeoEudc(FontAssocDefaultTable[iIndex].DefaultFontPFEs[iPfeOffset]);

        //
        // Check the PFE in default table is valid or not.
        //
        if( pfeoEudc.bValid() )
        {
            if( IS_IN_FACENAME_LINK( pfeoEudc.pql(), wc ))
            {
                bRet = TRUE;
            }
        }
    }
    else
    if(gbSystemDBCSFontEnabled)
    {
        PFEOBJ pfeo(prfnt->ppfe);

        if(pfeo.bSBCSSystemFont())
        {
        // we assume that the set of glyphs is the same for the vertical and
        // non vertical PFE's so for simplicity always use the normal pfe.

            PFEOBJ pfeSystemDBCSFont(gappfeSystemDBCS[PFE_NORMAL]);

            ASSERTGDI(pfeSystemDBCSFont.bValid(),
                      "bIsLinkedGlyph: invalid SystemDBCSFont pfe\n");

            if(IS_IN_FACENAME_LINK(pfeSystemDBCSFont.pql(),wc))
            {
                bRet = TRUE;
            }
        }
    }

// Walk through FaceName link list if we haven't found it yet.

    if( bRet == FALSE )
    {
        //
        // Is this a FaceName EUDC character ?
        //
        UINT iPfeOffset = (prfnt->bVertical ? PFE_VERTICAL : PFE_NORMAL);

        PFEOBJ pfeo(prfnt->ppfe);
        PLIST_ENTRY p = pfeo.pGetLinkedFontList()->Flink;

        //
        // Scan the linked font list for this base font.
        //

        while( p != pfeo.pGetLinkedFontList() )
        {
            PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);

            //
            // Check this linked font have Vertical facename or not,
            // if it doesn't have, use normal facename...
            //

            UINT iPfeOffsetLocal;

            if( ppfeData->appfe[iPfeOffset] == NULL )
                iPfeOffsetLocal = PFE_NORMAL;
             else
                iPfeOffsetLocal = iPfeOffset;

            PFEOBJ   pfeoEudc(ppfeData->appfe[iPfeOffsetLocal]);

            ASSERTGDI( pfeoEudc.pql() != NULL ,
                      "bIsLinkedGlyph() pfeoEudc.pql() == NULL\n" );

            if(IS_IN_FACENAME_LINK( pfeoEudc.pql(), wc ))
            {
                bRet = TRUE;
                break;
            }

            p = p->Flink;
        }
    }

    GreReleaseSemaphore( ghsemEUDC1 );

    return(bRet);
}






/******************************Public*Routine******************************\
* BOOL STROBJ_bEnumLinked (pstro,pc,ppgpos)
*
* The glyph enumerator.
*
* History:
*  Tue 28-Sep-1993 11:37:00 -by- Gerrit van Wingerden
* Converted to a special helper function to handle linked fonts.
*
*  Tue 17-Mar-1992 10:35:05 -by- Charles Whitmer [chuckwh]
* Simplified it and gave it the quick exit.  Also let drivers call here
* direct.
*
*  02-Oct-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL STROBJ_bEnumLinked(ESTROBJ *peso, ULONG *pc,PGLYPHPOS  *ppgpos)
{
// Quick exit.

    if( peso->cgposCopied == 0 )
    {
        for( peso->plNext = peso->plPartition, peso->pgpNext = peso->pgpos;
            *(peso->plNext) != peso->lCurrentFont;
            (peso->pgpNext)++, (peso->plNext)++ );
        {
        }
    }
    else
    {
       if( peso->cgposCopied == peso->cGlyphs )
       {
        // no more glyphs so just return
            *pc = 0;
            return(FALSE);
       }
       else
       {
        // find next glyph

            for( (peso->plNext)++, (peso->pgpNext)++;
                 *(peso->plNext) != (peso->lCurrentFont);
                 (peso->pgpNext)++, (peso->plNext)++ );
            {
            }
       }
    }

    if (peso->prfo == NULL)  // check for journaling
    {
        WARNING("ESTROBJ::bEnum(), bitmap font, prfo == NULL\n");
        *pc = 0;
        return(FALSE);
    }

    if( peso->prfo->cGetGlyphData(1,peso->pgpNext) == 0 )
    {
        WARNING("couldn't get glyph for some reason\n");
        *pc = 0;
        return(FALSE);
    }

    peso->cgposCopied += 1;     // update enumeration state
    *pc = 1;
    *ppgpos = peso->pgpNext;

    return(peso->cgposCopied < peso->cGlyphs);  // TRUE => more to come.
}

/******************************Public*Routine******************************\
* VOID ESTROBJ fxBaseLineAdjust( _fxBaseLineAdjust )
*
* History:
*  24-Dec-1993 -by- Hideyuki Nagase
* Wrote it.
\**************************************************************************/

VOID ESTROBJ::ptlBaseLineAdjustSet( POINTL& _ptlBaseLineAdjust )
{
    INT ii;
    UINT uFound;

    ptlBaseLineAdjust = _ptlBaseLineAdjust;

    if( !(ptlBaseLineAdjust.x || ptlBaseLineAdjust.y) )
        return;

    for( ii = 0,uFound = 0 ; uFound < cGlyphs ; ii++ )
    {
        if( plPartition[ii] == lCurrentFont )
        {
            pgpos[ii].ptl.x += ptlBaseLineAdjust.x;
            pgpos[ii].ptl.y += ptlBaseLineAdjust.y;
            uFound++;
        }
    }
}

/******************************Public*Routine******************************\
* BOOL ESTROBJ bPartitionInit( c, uiNumLinks )
*
* History:
*  29-Nov-1995 -by- Hideyuki Nagase
* Add initialize for FaceNameGlyphs array.
*
*  29-Sep-1993 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL ESTROBJ::bPartitionInit(COUNT c, UINT uiNumLinks, BOOL bEudcInit)
{

// Always initialize at least for the SystemTTEUDC Font.  We can't initialize
// the EUDC specific stuff until we've called RFONTOBJ::vInitEUDC, something
// we won't do when just outputing System DBCS glyphs

// the first thing we should do is clear the SO_ZERO_BEARINGS and
// SO_CHAR_INC_EQUAL_BM_BASE flags in the TEXOBJ since this will turn
// off potentially fatal optimizations in the H3 case.

    flAccel &= ~(SO_CHAR_INC_EQUAL_BM_BASE|SO_ZERO_BEARINGS);

    if(!(flTO & TO_SYS_PARTITION))
    {
        plPartition = (LONG*) &pgpos[c];
        pwcPartition = (WCHAR*) &plPartition[c];
        RtlZeroMemory((VOID*)plPartition, c * sizeof(LONG));
        pacFaceNameGlyphs = NULL;

        cSysGlyphs = 0;
        cDefGlyphs = 0;
        cTTSysGlyphs = 0;

        flTO |= TO_SYS_PARTITION;
    }

    if(bEudcInit)
    {
        if( uiNumLinks >= QUICK_FACE_NAME_LINKS )
        {
            pacFaceNameGlyphs = (ULONG *) PALLOCMEM(uiNumLinks * sizeof(UINT),'flnk');

            if (pacFaceNameGlyphs == (ULONG *) NULL)
            {
            // if we fail allocate memory, we just cancel eudc output.
                return (FALSE);
            }

            flTO |= TO_ALLOC_FACENAME;
        }
        else
        {
            pacFaceNameGlyphs = acFaceNameGlyphs;
            RtlZeroMemory((VOID*) pacFaceNameGlyphs, uiNumLinks * sizeof(UINT));
        }

        flTO |= TO_PARTITION_INIT;
    }

    return (TRUE);
}


/****************************************************************************
* RFONTOBJ::GetLinkedFontUFIs
*
* This routine returns the UFI's for the font(s) that are linked to this
* RFONT.  If pufi is NULL, simply returns the number of UFI's linked to
* this RFONT.
*
*****************************************************************************/

INT RFONTOBJ::GetLinkedFontUFIs(XDCOBJ& dco, PUNIVERSAL_FONT_ID pufi, INT NumUFIs)
{
    UINT u;
    INT UFICount = 0;

// check pui

    if (NumUFIs && pufi == NULL)
    {
        WARNING("RFONTOBJ::GetLinkedFontUFIs() pufi == NULL but NumUFIs != 0\n");
        return (0);
    }

// initialize system TT font if applicable

    if(prfnt->bIsSystemFont)
    {
        if((!prfnt->prfntSystemTT) && !bInitSystemTT(dco))
        {
            WARNING("Error initializing TT system font 5\n");
            return(0);
        }
        prfnt->flEUDCState |= EUDC_NO_CACHE;
    }

// initialize EUDC fonts if we haven't done so already

    {
        GreAcquireSemaphore(prfnt->hsemEUDC);
        
        if( !( prfnt->flEUDCState & EUDC_INITIALIZED ) )
        {
        // this value will be decremented in RFONTOBJ::dtHelper()

            INCREMENTEUDCCOUNT;

            vInitEUDC(dco);
            prfnt->flEUDCState |= (EUDC_INITIALIZED | EUDC_NO_CACHE);
        }

        GreReleaseSemaphore(prfnt->hsemEUDC);
    }
    
    if(prfnt->prfntSystemTT)
    {
        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->prfntSystemTT);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    for(u = 0; u < prfnt->uiNumLinks; u++)
    {
        ASSERTGDI(prfnt->paprfntFaceName[u],"GDI:uGetLinkedFonts: null facename font\n");

        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->paprfntFaceName[u]);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    if(prfnt->prfntDefEUDC)
    {
        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->prfntDefEUDC);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    if(prfnt->prfntSysEUDC)
    {
        if(UFICount++ < NumUFIs)
        {
            RFONTTMPOBJ rfo(prfnt->prfntSysEUDC);
            rfo.vUFI(pufi);
            pufi++;
        }
    }

    return(UFICount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\miscgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: miscgdi.cxx
*
* Misc. GDI routines
*
* Created: 13-Aug-1990 by undead
*
* Copyright (c) 1989-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

//
// GCAPS2_SYNCFLUSH and GCAPS2_SYNCTIMER globals
//

LONG gcSynchronizeFlush = -1;
LONG gcSynchronizeTimer = -1;
UINT_PTR gidSynchronizeTimer;

//
// GCAPS2_SYNCTIMER timer interval, in milliseconds
//

#define SYNCTIMER_FREQUENCY 50

/******************************Public*Routine******************************\
* GreSaveScreenBits (hdev,iMode,iIdent,prcl)
*
* Passes the call to the device driver, or returns doing nothing.  This
* call is pretty fast, no locks are done.
*
*  Fri 11-Sep-1992 -by- Patrick Haluptzok [patrickh]
* Add cursor exclusion.
*
*  Thu 27-Aug-1992 16:40:42 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

ULONG_PTR GreSaveScreenBits(HDEV hdev,ULONG iMode,ULONG_PTR iIdent,RECTL *prcl)
{
    ULONG_PTR ulReturn = 0;
    RECTL rcl = {0,0,0,0};

    PDEVOBJ  po(hdev);

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    if (!po.bDisabled())
    {
        PFN_DrvSaveScreenBits pfn = PPFNDRV(po,SaveScreenBits);

        if (pfn != (PFN_DrvSaveScreenBits) NULL)
        {
            DEVEXCLUDEOBJ dxo;

            if (iMode == SS_FREE)
            {
            // Make if a very small rectangle.

                prcl = &rcl;
            }

            ASSERTGDI(po.bDisplayPDEV(), "ERROR");

            ulReturn = (*pfn)(po.pSurface()->pSurfobj(),iMode,iIdent,prcl);
        }
    }
#if DBG
    else
    {
        if (iMode == SS_FREE)
            WARNING("GreSaveScreenBits called to free memory in full screen - memory lost\n");
    }
#endif

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(po.hsemDevLock());

    return(ulReturn);
}

/******************************Public*Routine******************************\
* GreValidateSurfaceHandle
*
* This allows USER to validate handles passed to it by the client side.
*
* Returns: TRUE if handle is valid and of the correct type,
*          FALSE otherwise.
*
* History:
*  06-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreValidateServerHandle(HANDLE hobj, ULONG ulType)
{
    return(HmgValidHandle((HOBJ)hobj, (OBJTYPE) ulType));
}

/******************************Public*Routine******************************\
* GreSetBrushOrg
*
* Set the application defined brush origin into the DC
*
* Returns: Old brush origin
*
* History:
*  30-Oct-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreSetBrushOrg(
    HDC hdc,
    int x,
    int y,
    LPPOINT ptl_)
{
    DCOBJ  dco(hdc);
    PPOINTL ptl = (PPOINTL)ptl_;

    if (dco.bValid())
    {
        if (ptl != NULL)
            *ptl = dco.pdc->ptlBrushOrigin();

        //
        // update DCATTR brush org
        //

        dco.pdc->pDCAttr->ptlBrushOrigin.x = x;
        dco.pdc->pDCAttr->ptlBrushOrigin.y = y;

        //
        // update km brush prg
        //

        dco.pdc->ptlBrushOrigin((LONG)x,(LONG)y);
        return(TRUE);
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }
}


/******************************Public*Routine******************************\
* GreGetBrushOrg
*
* Returns: Old application brush origin
*
* History:
*  30-Oct-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreGetBrushOrg(HDC hdc,PPOINT ptl_)
{
    DCOBJ  dco(hdc);
    PPOINTL ptl = (PPOINTL)ptl_;

    if (dco.bValid())
    {
        *ptl = dco.pdc->ptlBrushOrigin();
        return(TRUE);
    }
    else
        return(FALSE);
}

/******************************Public*Routine******************************\
* vGetDeviceCaps()
*
* Common device capabilities routine.
*
\**************************************************************************/

VOID vGetDeviceCaps(
    PDEVOBJ& po,
    PDEVCAPS pDevCaps
    )
{
    GDIINFO* pGdiInfo;

    pGdiInfo = po.GdiInfoNotDynamic();  // Use of this local removes pointer
                                        //   dereferences

    pDevCaps->ulVersion         = pGdiInfo->ulVersion;
    pDevCaps->ulTechnology      = pGdiInfo->ulTechnology;

    // Note that ul*Size fields are now in micrometers

    pDevCaps->ulHorzSizeM       = (pGdiInfo->ulHorzSize+500)/1000;
    pDevCaps->ulVertSizeM       = (pGdiInfo->ulVertSize+500)/1000;
    pDevCaps->ulHorzSize        = pGdiInfo->ulHorzSize;
    pDevCaps->ulVertSize        = pGdiInfo->ulVertSize;
    pDevCaps->ulHorzRes         = pGdiInfo->ulHorzRes;
    pDevCaps->ulVertRes         = pGdiInfo->ulVertRes;
    pDevCaps->ulBitsPixel       = pGdiInfo->cBitsPixel;
    if (pDevCaps->ulBitsPixel == 15)
        pDevCaps->ulBitsPixel = 16; // Some apps, such as PaintBrush or
                                    //   NetScape, break if we return 15bpp

    pDevCaps->ulPlanes          = pGdiInfo->cPlanes;
    pDevCaps->ulNumPens         = (pGdiInfo->ulNumColors == (ULONG)-1) ?
                             (ULONG)-1 : 5 * pGdiInfo->ulNumColors;
    pDevCaps->ulNumFonts        = po.cFonts();
    pDevCaps->ulNumColors       = pGdiInfo->ulNumColors;
    pDevCaps->ulRasterCaps      = pGdiInfo->flRaster;
    pDevCaps->ulShadeBlendCaps  = pGdiInfo->flShadeBlend;
    pDevCaps->ulAspectX         = pGdiInfo->ulAspectX;
    pDevCaps->ulAspectY         = pGdiInfo->ulAspectY;
    pDevCaps->ulAspectXY        = pGdiInfo->ulAspectXY;
    pDevCaps->ulLogPixelsX      = pGdiInfo->ulLogPixelsX;
    pDevCaps->ulLogPixelsY      = pGdiInfo->ulLogPixelsY;
    pDevCaps->ulSizePalette     = pGdiInfo->ulNumPalReg;
    pDevCaps->ulColorRes        = pGdiInfo->ulDACRed + pGdiInfo->ulDACGreen + pGdiInfo->ulDACBlue;
    pDevCaps->ulPhysicalWidth   = pGdiInfo->szlPhysSize.cx;
    pDevCaps->ulPhysicalHeight  = pGdiInfo->szlPhysSize.cy;
    pDevCaps->ulPhysicalOffsetX = pGdiInfo->ptlPhysOffset.x;
    pDevCaps->ulPhysicalOffsetY = pGdiInfo->ptlPhysOffset.y;

    pDevCaps->ulTextCaps        = pGdiInfo->flTextCaps;
    pDevCaps->ulTextCaps       |= (TC_OP_CHARACTER | TC_OP_STROKE | TC_CP_STROKE |
                                   TC_UA_ABLE | TC_SO_ABLE);

    if (pGdiInfo->ulTechnology != DT_PLOTTER)
        pDevCaps->ulTextCaps |= TC_VA_ABLE;

    pDevCaps->ulVRefresh        = pGdiInfo->ulVRefresh;
    pDevCaps->ulDesktopHorzRes  = pGdiInfo->ulHorzRes;
    pDevCaps->ulDesktopVertRes  = pGdiInfo->ulVertRes;
    pDevCaps->ulBltAlignment    = pGdiInfo->ulBltAlignment;

    pDevCaps->ulColorManagementCaps
                                = GetColorManagementCaps(po);
}

/******************************Public*Routine******************************\
* NtGdiGetDeviceCapsAll()
*
*   Get all the adjustable device caps for the dc.  Allows us to cache this
*   information on the client side.
*
* History:
*  09-Jan-1996 -by-  Lingyun Wang [lingyunw]
* Made it based on GreGetDeviceCapsAll from the old client\server code.
\**************************************************************************/

BOOL
APIENTRY
NtGdiGetDeviceCapsAll(
    HDC hdc,
    PDEVCAPS pDevCaps
    )
{
    BOOL bRet = TRUE;
    DEVCAPS devCapsTmp;

    // Lock the destination and its transform.

    DCOBJ dco(hdc);

    // return FALSE if it is a invalid DC

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    // Lock down the pdev

    PDEVOBJ po(dco.hdev());

    ASSERTGDI(po.bValid(), "Invalid PDEV");

    __try
    {
        ProbeForWrite(pDevCaps, sizeof(DEVCAPS), sizeof(BYTE));

        vGetDeviceCaps(po, pDevCaps);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING ("try-except failed IN NtGdiGetDeviceCapsAll\n");

        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GreUpdateSharedDevCaps()
*
*   Update the device caps in the shared memory
*
* History:
*  09-Jan-1996 -by-  Lingyun Wang [lingyunw]
* Made it based on GreGetDeviceCapsAll from the old client\server code.
\**************************************************************************/

BOOL
GreUpdateSharedDevCaps(
    HDEV hdev
    )
{
    PDEVOBJ po(hdev);
    ASSERTGDI(po.bValid(), "Invalid HDEV");

    vGetDeviceCaps(po, gpGdiDevCaps);

    return(TRUE);
}


/******************************Public*Routine******************************\
* GreGetDeviceCaps
*
* Returns: device driver specific information
*
* NOTE: This function MUST mirror NtGdiGetDeviceCapsAll and that in
*       client\dcquery.c!
*
* History:
*  01-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewritten to corrected GDIINFO structure.
*
*  30-Oct-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int GreGetDeviceCaps(HDC hdc, int lIndex)
{
// Init return value

    int iRet = 0;

// Lock the destination and its transform.

    DCOBJ dco(hdc);
    if (dco.bValid())
    {
    // Lock down the pdev

        PDEVOBJ po(dco.hdev());
        ASSERTGDI(po.bValid(), "Invalid PDEV");

    // Note that dynamic mode changes may cause the GDIINFO data to change
    // at any time (but not the actual 'pGdiInfo' pointer):

        GDIINFO* pGdiInfo = po.GdiInfoNotDynamic();

        switch (lIndex)
        {
        case DRIVERVERSION:                     //  Version = 0100h for now
           iRet = (pGdiInfo->ulVersion);
           break;

        case TECHNOLOGY:                        //  Device classification
           iRet = (pGdiInfo->ulTechnology);
           break;

        case HORZSIZE:                          //  Horizontal size in millimeters
           iRet =  (pGdiInfo->ulHorzSize+500)/1000;
           break;

        case VERTSIZE:                          //  Vertical size in millimeters
           iRet =  (pGdiInfo->ulVertSize+500)/1000;
           break;

        case HORZRES:                           //  Horizontal width in pixels
           iRet = (pGdiInfo->ulHorzRes);
           break;

        case VERTRES:                           //  Vertical height in pixels
           iRet = (pGdiInfo->ulVertRes);
           break;

        case BITSPIXEL:                         //  Number of bits per pixel
           iRet = (pGdiInfo->cBitsPixel);
           if (iRet == 15)
               iRet = 16;                       //  Some apps, such as PaintBrush or
                                                //  NetScape, break if we return 15bpp
           break;

        case PLANES:                            //  Number of planes
           iRet = (pGdiInfo->cPlanes);
           break;

        case NUMBRUSHES:                        //  Number of brushes the device has
           iRet = (-1);
           break;

        case NUMPENS:                           //  Number of pens the device has
           iRet = (pGdiInfo->ulNumColors == (ULONG)-1) ?
                             (ULONG)-1 : 5 * pGdiInfo->ulNumColors;
           break;

        case NUMMARKERS:                        //  Number of markers the device has
           iRet = (0);
           break;

        case NUMFONTS:                          //  Number of fonts the device has
           iRet = (po.cFonts());
           break;

        case NUMCOLORS:                         //  Number of colors in color table
           iRet = (pGdiInfo->ulNumColors);
           break;

        case PDEVICESIZE:                       //  Size required for the device descriptor
           iRet = (0);
           break;

        case CURVECAPS:                         //  Curves capabilities
           iRet = (CC_CIRCLES   |
                  CC_PIE        |
                  CC_CHORD      |
                  CC_ELLIPSES   |
                  CC_WIDE       |
                  CC_STYLED     |
                  CC_WIDESTYLED |
                  CC_INTERIORS  |
                  CC_ROUNDRECT);
           break;

        case LINECAPS:                          //  Line capabilities
            iRet = (LC_POLYLINE  |
                   LC_MARKER     |
                   LC_POLYMARKER |
                   LC_WIDE       |
                   LC_STYLED     |
                   LC_WIDESTYLED |
                   LC_INTERIORS);
            break;

        case POLYGONALCAPS:                     //  Polygonal capabilities
            iRet = (PC_POLYGON    |
                   PC_RECTANGLE   |
                   PC_WINDPOLYGON |
                   PC_TRAPEZOID   |
                   PC_SCANLINE    |
                   PC_WIDE        |
                   PC_STYLED      |
                   PC_WIDESTYLED  |
                   PC_INTERIORS);
            break;

        case TEXTCAPS:                          //  Text capabilities
        {

            FLONG fl = pGdiInfo->flTextCaps;

        // Engine will simulate vector fonts on raster devices.

            if (pGdiInfo->ulTechnology != DT_PLOTTER)
                fl |= TC_VA_ABLE;

        // Turn underlining, strikeout.  Engine will do it for device if needed.

            fl |= (TC_UA_ABLE | TC_SO_ABLE);

        // Return flag.

            iRet =  fl;
            break;
        }

        case CLIPCAPS:                          //  Clipping capabilities
           iRet = (CP_RECTANGLE);
           break;

        case RASTERCAPS:                        //  Bitblt capabilities
           iRet = (pGdiInfo->flRaster);
           break;

        case SHADEBLENDCAPS:                    //  Shade and blend capabilities
           iRet = (pGdiInfo->flShadeBlend);
           break;

        case ASPECTX:                           //  Length of X leg
           iRet = (pGdiInfo->ulAspectX);
           break;

        case ASPECTY:                           //  Length of Y leg
           iRet = (pGdiInfo->ulAspectY);
           break;

        case ASPECTXY:                          //  Length of hypotenuse
           iRet = (pGdiInfo->ulAspectXY);
           break;

        case LOGPIXELSX:                        //  Logical pixels/inch in X
           iRet = (pGdiInfo->ulLogPixelsX);
           break;

        case LOGPIXELSY:                        //  Logical pixels/inch in Y
           iRet = (pGdiInfo->ulLogPixelsY);
           break;

        case SIZEPALETTE:                       // # entries in physical palette
            iRet = (pGdiInfo->ulNumPalReg);
            break;

        case NUMRESERVED:                       // # reserved entries in palette
            iRet = (20);
            break;

        case COLORRES:
            iRet = (pGdiInfo->ulDACRed + pGdiInfo->ulDACGreen + pGdiInfo->ulDACBlue);
            break;

        case PHYSICALWIDTH:                     // Physical Width in device units
           iRet = (pGdiInfo->szlPhysSize.cx);
           break;

        case PHYSICALHEIGHT:                    // Physical Height in device units
           iRet = (pGdiInfo->szlPhysSize.cy);
           break;

        case PHYSICALOFFSETX:                   // Physical Printable Area x margin
           iRet = (pGdiInfo->ptlPhysOffset.x);
           break;

        case PHYSICALOFFSETY:                   // Physical Printable Area y margin
           iRet = (pGdiInfo->ptlPhysOffset.y);
           break;

        case VREFRESH:                          // Vertical refresh rate of the device
           iRet = (pGdiInfo->ulVRefresh);
           break;

        //
        // NOTE : temporarily disable this feature for the BETA.
        // We will reenable when the engine does it.
        //

        case DESKTOPHORZRES:                    // Width of entire virtual desktop
           iRet = (pGdiInfo->ulHorzRes);
           break;

        case DESKTOPVERTRES:                    // Height of entire virtual desktop
           iRet = (pGdiInfo->ulVertRes);
           break;

        case BLTALIGNMENT:                      // Preferred blt alignment
           iRet = (pGdiInfo->ulBltAlignment);
           break;

        case HORZSIZEM:                         //  Horizontal size in millimeters/1000
           iRet = pGdiInfo->ulHorzSize;
           break;

        case VERTSIZEM:                         //  Vertical size in millimeters/1000
           iRet = pGdiInfo->ulVertSize;
           break;

        case CAPS1:                             //  InternalCaps
           iRet = (po.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) ?
                  C1_MIRROR_DEVICE : 0;
           break;

        case COLORMGMTCAPS:                     //  Color management capabilities
           iRet = GetColorManagementCaps(po);

        default:
           iRet = 0;
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* BOOL GreDeleteObject(HOBJ)
*
* History:
*  Fri 13-Sep-1991 -by- Patrick Haluptzok [patrickh]
* added DC deletion
*
*  Tue 27-Nov-1990 -by- Patrick Haluptzok [patrickh]
* added palette deletion, surface deletion, brush deletion.
*
*  Wed 22-Aug-1990 Greg Veres [w-gregv]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreDeleteObject (HANDLE hobj)
{
    int ii;

// don't allow deletion of stock objects, just succeed

    if (HmgStockObj(hobj))
    {
        return(TRUE);
    }

    switch (HmgObjtype(hobj))
    {
    case RGN_TYPE:
        return(bDeleteRegion((HRGN) hobj));
    case SURF_TYPE:
        return(bDeleteSurface((HSURF)hobj));
    case PAL_TYPE:
        return(bDeletePalette((HPAL) hobj));
    case LFONT_TYPE:
        // see if its in cfont list.

        for (ii = 0; ii < MAX_PUBLIC_CFONT; ++ii)
        {
            if (gpGdiSharedMemory->acfPublic[ii].hf == hobj)
            {
                // just nuke the hfont as this invalidates the whole entry

                gpGdiSharedMemory->acfPublic[ii].hf = 0;
                break;
            }
        }
        return(bDeleteFont((HLFONT) hobj, FALSE));

    case BRUSH_TYPE:
        return(bDeleteBrush((HBRUSH) hobj, FALSE));
    case DC_TYPE:
        return(bDeleteDCInternal((HDC) hobj,TRUE,FALSE));
    default:
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* NtGdiDeleteObjectApp()
*
*   Same as DeleteObject() but doesn't allow public objects to be deleted.
*   This should only be called from server.c coming from the client.  User
*   and console should call the DeleteObject().
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiDeleteObjectApp(
    HANDLE hobj
    )
{
    ULONG objt;

    // don't allow deletion of stock objects, just succeed

    if (HmgStockObj(hobj))
    {
        return(TRUE);
    }

    objt = HmgObjtype(hobj);

    // check if it is a public object.  If it is, check if it is a public deletable
    // surface set by user.

    if (GreGetObjectOwner((HOBJ)hobj,objt) == OBJECT_OWNER_PUBLIC)
    {
        if (objt == SURF_TYPE)
        {
            WARNING("Trying to delete public surface!");
        }

    #if 0
        BOOL bMsg = TRUE;

        if (objt == BRUSH_TYPE)
        {
            BRUSHSELOBJ bo(hbrush);

            if (bo.bValid() || bo.bIsGlobal())
                bMsg = FALSE;
        }

        if (bMsg)
        {
            DbgPrint("GDI Warning: app trying to delete public object %lx\n",hobj);
        }
    #endif

        //
        // return FALSE if hobj == NULL
        // otherwise TRUE
        //
        return(hobj != NULL);
    }

    switch (objt)
    {
    case RGN_TYPE:
        return(bDeleteRegion((HRGN) hobj));
    case SURF_TYPE:
        return(bDeleteSurface((HSURF)hobj));
    case PAL_TYPE:
        return(bDeletePalette((HPAL) hobj));
    case LFONT_TYPE:
        return(bDeleteFont((HLFONT) hobj, FALSE));
    case BRUSH_TYPE:
        return(bDeleteBrush((HBRUSH) hobj, FALSE));
    case DC_TYPE:
    // don't allow deletion of DC's by an app if the undeletable flag is set

        return(bDeleteDCInternal((HDC) hobj,FALSE,FALSE));
    default:
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* cjGetBrushOrPen
*
* Gets brush or pen object data.
*
* For extended pens, some information such as the style array are kept
* only on this, the server side.  Most of the brush data is also kept
* on the client side for GetObject.
*
* returns: Number of bytes needed if pvDest == NULL, else bytes copied out.
*          For error it returns 0.
*
* History:
*  Thu 23-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

LONG cjGetBrushOrPen(HANDLE hobj, int iCount, LPVOID pvDest)
{
    LONG lRet = 0;

    BRUSHSELOBJ bro((HBRUSH) hobj);

// NOTE SIZE: Most of this is bunk, since for NT all brush data is kept on the
// client side, and so some of this code path won't even be
// executed. [andrewgo]
//
// And for DOS, we would return some fields as zero, whereas under
// NT we would always return what we were given. [andrewgo]

    if (bro.bValid())
    {
        if (bro.bIsOldStylePen())
        {
        // Old style pen...

            bSyncBrushObj(bro.pbrush());

            if (pvDest == (LPVOID) NULL)
            {
                lRet = sizeof(LOGPEN);
            }
            else if (iCount >= sizeof(LOGPEN))
            {
                if ((iCount == (int) sizeof(EXTLOGPEN)) &&
                    ((UINT) bro.flStylePen() == PS_NULL))
                {
                    //moved the NULL extended pen handling from client
                    //side to server side

                     PEXTLOGPEN pelp = (PEXTLOGPEN) pvDest;

                     pelp->elpPenStyle   = PS_NULL;
                     pelp->elpWidth      = 0;
                     pelp->elpBrushStyle = 0;
                     pelp->elpColor      = 0;
                     pelp->elpHatch      = 0;
                     pelp->elpNumEntries = 0;

                     lRet = sizeof(EXTLOGPEN);
                }
                else
                {
                // Fill in the logical pen.

                    ((LOGPEN *) pvDest)->lopnStyle   = (UINT) bro.flStylePen();
                    ((LOGPEN *) pvDest)->lopnWidth.x = (int) bro.lWidthPen();
                    ((LOGPEN *) pvDest)->lopnWidth.y = 0;
                    ((LOGPEN *) pvDest)->lopnColor   = bro.clrPen();
                    lRet = sizeof(LOGPEN);
                }
            }
        }
        else if (bro.bIsPen())
        {
        // Extended pen...

            ULONG cstyle = (bro.bIsUserStyled()) ? bro.cstyle() : 0;

            int cj = (int) (sizeof(EXTLOGPEN) - sizeof(DWORD) +
                            sizeof(DWORD) * (SIZE_T) cstyle);

            if (pvDest == (LPVOID) NULL)
            {
                lRet = cj;
            }
            else if (iCount >= cj)
            {
                PEXTLOGPEN pelp = (PEXTLOGPEN) pvDest;

                pelp->elpPenStyle   = (UINT) bro.flStylePen();
                pelp->elpWidth      = (UINT) bro.lWidthPen();
                pelp->elpNumEntries = cstyle;

                if (cstyle > 0)
                {
                // We can't just do a RtlCopyMemory for cosmetics, because
                // we don't know how the LONGs are packed in the
                // FLOAT_LONG array:

                    PFLOAT_LONG pelSrc = bro.pstyle();
                    PLONG       plDest = (PLONG) &pelp->elpStyleEntry[0];

                    for (; cstyle > 0; cstyle--)
                    {
                        if (bro.bIsCosmetic())
                            *plDest = pelSrc->l;
                        else
                        {
                            EFLOATEXT efLength(pelSrc->e);
                            BOOL b = efLength.bEfToL(*plDest);

                            ASSERTGDI(b, "Shouldn't have overflowed");
                        }

                        plDest++;
                        pelSrc++;
                    }
                }

            // The client side GetObject will fill in the rest of the
            // EXTLOGPEN struct. i.e. elpBrushStyle, elpColor, and elpHatch.

            // Changed: added these here -30-11-94 -by- Lingyunw
            // added lBrushStyle and lHatch to PEN

               pelp->elpBrushStyle = bro.lBrushStyle();
               pelp->elpColor      = bro.crColor();
               pelp->elpHatch      = bro.lHatch();

               lRet = cj;
            }
        }
        else
        {
         // Brush...

            if (pvDest == (LPVOID) NULL)
            {
                lRet = sizeof(LOGBRUSH);
            }
            else if (iCount >= sizeof(LOGBRUSH))
            {
            // make sure the kernel attributes match

               bSyncBrushObj(bro.pbrush());

            // Fill in logical brush.  Figure out what type it is.

            // Duplicates of this info is kept on the client side,
            // so most calls won't even get here:

                if (bro.flAttrs() & BR_IS_SOLID)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_SOLID;
                    ((LOGBRUSH *) pvDest)->lbColor   = bro.crColor();
                    ((LOGBRUSH *) pvDest)->lbHatch   = 0;
                }
                else if (bro.flAttrs() & BR_IS_BITMAP)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_PATTERN;
                    ((LOGBRUSH *) pvDest)->lbColor   = 0;
                    ((LOGBRUSH *) pvDest)->lbHatch   = (ULONG_PTR)bro.hbmClient();
                }
                else if (bro.flAttrs() & BR_IS_HATCH)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_HATCHED;
                    ((LOGBRUSH *) pvDest)->lbColor   = bro.crColor();
                    ((LOGBRUSH *) pvDest)->lbHatch   = bro.ulStyle();
                }
                else if (bro.flAttrs() & BR_IS_NULL)
                {
                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_HOLLOW;
                    ((LOGBRUSH *) pvDest)->lbColor   = 0;
                    ((LOGBRUSH *) pvDest)->lbHatch   = 0;
                }
                else if (bro.flAttrs() & BR_IS_DIB)
                {
                // Could be BS_DIBPATTERN or BS_DIBPATTERNPT, but we'll just
                // return BS_DIBPATTERN.

                    ((LOGBRUSH *) pvDest)->lbStyle   = BS_DIBPATTERN;
                    ((LOGBRUSH *) pvDest)->lbColor   = bro.crColor();
                    ((LOGBRUSH *) pvDest)->lbHatch   = (ULONG_PTR)bro.hbmClient();
                }
                else
                    RIP("ERROR GreGetObject invalid brush type");

                lRet = sizeof(LOGBRUSH);
            }
        }
    }
    else
    {
        WARNING1("cjGetBrushOrPen():hobj is invalid\n");
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(lRet);
}

/******************************Public*Routine******************************\
* GreGetObject
*
* API function
*
* returns: number of bytes needed if pvDest == NULL, else bytes copied out
*          for error it returns 0
*
* in case a log font object is requested, the function will fill the buffer with
* as many bytes of the EXTLOGFONT structure as requested. If a caller
* wants a LOGFONTW structure in the buffer, he should specify
*        ulCount == sizeof(LOGFONTW)
* The function will copy the first sizeof(LOGFONTW) bytes of the EXTLOGFONTW
* structure to the buffer, which is precisely the LOGFONTW structure. The rest
* of the EXTLOGFONTW structure will be chopped off.
*
* History:
*
*  Thu 12-Dec-1996 -by- Bodin Dresevic [BodinD]
* update: changed EXTLOGFONT to ENUMLOGFONTEXDVW
*
*  Thu 30-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* added extended pen support.
*
*  Wed 21-Aug-1991 -by- Bodin Dresevic [BodinD]
* update: converted to return EXTLOGFONTW
*
*  Fri 24-May-1991 -by- Patrick Haluptzok [patrickh]
* added first pass pen and brush stuff.
*
*  Tue 24-Apr-1991 -by- Patrick Haluptzok [patrickh]
* added surface stuff.
*
*  08-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int APIENTRY GreExtGetObjectW(HANDLE hobj, int  ulCount, LPVOID pvDest)
{
    int cRet = 0;

    switch (HmgObjtype(hobj))
    {
    case PAL_TYPE:
        cRet = 2;

        if (pvDest != NULL)
        {
            if (ulCount < 2)
            {
                cRet = 0;
            }
            else
            {
                SEMOBJ  semo(ghsemPalette);

                {
                    EPALOBJ pal((HPALETTE) hobj);

                    if (!(pal.bValid()))
                        cRet = 0;
                    else
                        *((PUSHORT) pvDest) = (USHORT) (pal.cEntries());
                }
            }
        }
        break;

    case LFONT_TYPE:

    // The output object is assumed to be
    // an ENUMLOGFONTEXDVW structure.
    // client side shall do the translation to LOGFONT if necessary

        {
            LFONTOBJ lfo((HLFONT) hobj);
            if (lfo.bValid())
            {
                if (pvDest != (LPVOID) NULL)
                {
                    SIZE_T cjCopy = MIN((SIZE_T) ulCount, lfo.cjElfw());

                    RtlCopyMemory(pvDest, lfo.pelfw(), (UINT) cjCopy);

                    cRet = (ULONG) cjCopy;
                }
                else
                {
                    cRet = lfo.cjElfw();
                }
            }
            else
            {
                WARNING("GreGetObject(): bad handle\n");
            }
        }
        break;

    case SURF_TYPE:
        if (pvDest != (LPVOID) NULL)
        {
            cRet = 0;

            if (ulCount >= (int)sizeof(BITMAP))
            {
                SURFREF SurfBm((HSURF) hobj);

                if ((SurfBm.bValid()) && 
                    (SurfBm.ps->bApiBitmap() || SurfBm.ps->bDirectDraw()))
                {
                    BITMAP *pbm = (BITMAP *) pvDest;

                    pbm->bmType = 0;
                    pbm->bmWidth = SurfBm.ps->sizl().cx;
                    pbm->bmHeight = SurfBm.ps->sizl().cy;

                    pbm->bmBitsPixel = (WORD) gaulConvert[SurfBm.ps->iFormat()];
                    pbm->bmWidthBytes = ((SurfBm.ps->sizl().cx * pbm->bmBitsPixel + 15) >> 4) << 1;
                    pbm->bmPlanes = 1;
                    pbm->bmBits = (LPSTR) NULL;

                    cRet = sizeof(BITMAP);

                // Get the bitmapinfoheader for the dibsection if the buffer
                // can hold it.

                    if (SurfBm.ps->bDIBSection() || SurfBm.ps->bDirectDraw())
                    {
                        // Win95 compatability.  They fill in the bits even if it
                        // is not big enough for a full DIBSECTION

                        pbm->bmBits = IS_USER_ADDRESS((LPSTR) SurfBm.ps->pvBits()) ? (LPSTR) SurfBm.ps->pvBits() : NULL;

                        // If this is a DIBSection/DirectDraw surface bmWidthBytes must be aligned
                        // on a DWORD boundary.

                        pbm->bmWidthBytes = ((SurfBm.ps->sizl().cx * pbm->bmBitsPixel + 31) & ~31) >> 3;

                        if (ulCount >= sizeof(DIBSECTION))
                        {
                            PBITMAPINFOHEADER pbmih = &((DIBSECTION *)pvDest)->dsBmih;

                            pbmih->biSize = sizeof(BITMAPINFOHEADER);
                            pbmih->biBitCount = 0;

                            if (GreGetDIBitsInternal(0,(HBITMAP)hobj,0,0,NULL,
                                (PBITMAPINFO)pbmih,DIB_RGB_COLORS,0,
                                sizeof(DIBSECTION)))
                            {
                                cRet = sizeof(DIBSECTION);

                            // More Win9x compatibility: for DDraw surfaces, the
                            // following field is always zero.  GDI+ keys off
                            // this Win9x feature to do cheap detection of
                            // DDraw surfaces:

                                if (SurfBm.ps->bDirectDraw())
                                {
                                    pbmih->biSizeImage = 0;
                                }
                            }


                            XEPALOBJ pal(SurfBm.ps->ppal());

                            if (pal.bValid() && pal.bIsBitfields())
                            {
                                ((DIBSECTION *)pvDest)->dsBitfields[0] = pal.flRed();
                                ((DIBSECTION *)pvDest)->dsBitfields[1] = pal.flGre();
                                ((DIBSECTION *)pvDest)->dsBitfields[2] = pal.flBlu();
                            }

                        // to be consistent with win95, Getobject returns BI_RGB for
                        // 24bpp, and 32bpp when BI_RGB is set at creation time

                            else
                            {
                                if (pal.bValid() && pal.bIsBGR())
                                {
                                    pbmih->biCompression = BI_RGB;
                                }

                                ((DIBSECTION *)pvDest)->dsBitfields[0] = 0;
                                ((DIBSECTION *)pvDest)->dsBitfields[1] = 0;
                                ((DIBSECTION *)pvDest)->dsBitfields[2] = 0;
                            }

                            ((DIBSECTION *)pvDest)->dshSection = SurfBm.ps->hDIBSection();
                            ((DIBSECTION *)pvDest)->dsOffset = SurfBm.ps->dwOffset();
                        }
                    }
                }
            }
        }
        else
        {
            cRet = sizeof(BITMAP);
        }

        break;

    case BRUSH_TYPE:
        cRet = (int) cjGetBrushOrPen(hobj, ulCount, pvDest);
        break;

    case ICMLCS_TYPE:
        cRet = cjGetLogicalColorSpace(hobj,ulCount,pvDest);
        break;

    default:
        break;
    }

    return(cRet);
}


/******************************Public*Routine******************************\
* GreGetStockObject
*
* API function
*
* returns the handle to the stock object requested.
*
* History:
*  08-Dec-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HANDLE gahStockObjects[PRIV_STOCK_LAST+1] = {0};

HANDLE GreGetStockObject(int ulIndex)
{
    if (((UINT)ulIndex) <= PRIV_STOCK_LAST)
    {
        return(gahStockObjects[ulIndex]);
    }
    else
    {
        return(0);
    }
}

BOOL bSetStockObject(
    HANDLE h,
    int    iObj
    )
{
    if (h)
    {
        gahStockObjects[iObj] = (HANDLE)((ULONG_PTR)h | GDISTOCKOBJ);
        HmgModifyHandleType((HOBJ) gahStockObjects[iObj]);
    }
    return(h != NULL);
}

/******************************Public*Routine******************************\
* BOOL GreGetColorAdjustment
*
*  Get the color adjustment data of the given DC.
*
* History:
*  25-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreGetColorAdjustment(HDC hdc, COLORADJUSTMENT *pca)
{
    DCOBJ dco(hdc);
    BOOL Status;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        Status = FALSE;

    } else {

        // Retrieve info from the DC.  Mask out the internal flag.

        *pca = *dco.pColorAdjustment();
        pca->caFlags &= (CA_NEGATIVE | CA_LOG_FILTER);
        Status = TRUE;
    }

    return Status;
}

/******************************Public*Routine******************************\
* BOOL GreSetColorAdjustment
*
*  Set the color adjustment data of the given DC.
*
* History:
*  25-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreSetColorAdjustment(HDC hdc, COLORADJUSTMENT *pcaNew)
{
    DCOBJ dco(hdc);
    BOOL Status;

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        Status = FALSE;

    } else {

        // Store info into the DC.  Turn off any flags that we don't support.

        *dco.pColorAdjustment() = *pcaNew;
        dco.pColorAdjustment()->caFlags &= (CA_NEGATIVE | CA_LOG_FILTER);
        Status = TRUE;
    }

    return Status;
}

/******************************Public*Routine******************************\
* HANDLE GreCreateClientObj()
*
*   A ClientObj contains no data.  It is purly to provide a handle to the
*   client for objects such as metafiles that exist only on the client side.
*
*   ulType is a client type.
*
* History:
*  17-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HANDLE NtGdiCreateClientObj(
    ULONG ulType)
{
    HANDLE h  = NULL;

    // ClientObj handles should never have any INDEX bits set and have some 
    // ALT bits set. Also the type must be a LO_CLIENTOBJ_TYPE

    if((ulType & (INDEX_MASK)) || !(ulType & (ALTTYPE_MASK)) || ((ulType & TYPE_MASK) != LO_CLIENTOBJ_TYPE))
    {
        WARNING("GreCreateClientObj: bad type\n");
        return(h);
    }

    PVOID  pv = ALLOCOBJ(sizeof(OBJECT), CLIENTOBJ_TYPE, FALSE);

    if (pv)
    {
        h = HmgInsertObject(pv, 0, CLIENTOBJ_TYPE);

        if (!h)
        {
            WARNING("GreCreateClientObj: HmgInsertObject failed\n");
            FREEOBJ(pv, CLIENTOBJ_TYPE);
        }
        else
        {
            pv = HmgLock((HOBJ) h,CLIENTOBJ_TYPE);

            if (pv != NULL)
            {
                h = MODIFY_HMGR_TYPE(h,ulType);
                HmgModifyHandleType((HOBJ)h);
                DEC_EXCLUSIVE_REF_CNT(pv);
            }
            else
            {
                RIP("GreCreateClientObj failed lock\n");
            }

        }
    }
    else
    {
        WARNING("GreCreateClientObj(): ALLOCOBJ failed\n");
    }

    return(h);
}

/******************************Public*Routine******************************\
*
*
* History:
*  17-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL GreDeleteClientObj(
    HANDLE h)
{
    PVOID pv = HmgRemoveObject((HOBJ)h, 0, 0, TRUE, CLIENTOBJ_TYPE);

    if (pv != NULL)
    {
        FREEOBJ(pv, CLIENTOBJ_TYPE);
        return(TRUE);
    }
    else
    {
        WARNING("GreDeleteClientObj: HmgRemoveObject failed\n");
        return(FALSE);
    }
}

/******************************Public*Routine******************************\
* NtGdiDeleteClientObj()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
NtGdiDeleteClientObj(
    HANDLE h
    )
{
    return(GreDeleteClientObj(h));
}

/******************************Public*Routine******************************\
* GreFreePool
*
* Private USER call to delete memory allocated by GDI.
*
* Only known use is to delete the MDEV structure returned by DrvCreateMDEV
* and cached by USER.
*
* History:
*  24-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" VOID GreFreePool(PVOID pv)
{
    GdiFreePool(pv);
}

/******************************Public*Routine******************************\
* hdevEnumerate
*
* Enumerates all display PDEVs without keeping ghsemDriverMgmt, allowing
* the devlock to be taken on each. This function must be called until it
* returns NULL or proper cleanup will not occur.
*
* History:
*  02-Jul-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

HDEV
hdevEnumerate(
    HDEV    hdevPrevious
    )
{
    PDEV*   ppdev;

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    // If we are called with NULL hdevPrevious then create the PDEVOBJ from
    // gppdevList, else create it from hdevPrevious:

    PDEVOBJ po(hdevPrevious ? hdevPrevious : (HDEV) gppdevList);
    ASSERTGDI(po.bValid(), "Invalid HDEV");

    // Search for the next display PDEV. If hdevPrevious is NULL, then
    // we start with po, else start from the next:
    
    for (ppdev = hdevPrevious ? po.ppdev->ppdevNext : po.ppdev;
         ppdev;
         ppdev = ppdev->ppdevNext)
    {
        // We're only interested in display PDEVs:

        if (ppdev->fl & PDEV_DISPLAY)
        {
            // We found the next display PDEV, so take a reference count
            // on it before releasing ghsemDriverMgmt and returning. This
            // reference count will be removed next time through:

            ppdev->cPdevRefs++;
            break;
        }
    }

    // If hdevPrevious is not NULL then we need to remove the reference
    // count we took, and we'll also release ghsemDriverMgmt here in the
    // appropriate place:
        
    if (hdevPrevious)
    {
        // If our reference count is not the last, just decrement, else we
        // need to call vUnreferencePdev so the PDEV will actually be
        // deleted:
        
        ASSERTGDI(po.cPdevRefs() > 0,
            "PDEV reference count is 0 but should be at least 1");
        
        if (po.cPdevRefs() > 1)
        {
            po.ppdev->cPdevRefs--;
            GreReleaseSemaphoreEx(ghsemDriverMgmt);
        }
        else
        {
            // Release ghsemDriverMgmt before calling vUnreferencePdev
            // because the call may result in the devlock being taken:

            GreReleaseSemaphoreEx(ghsemDriverMgmt);
            po.vUnreferencePdev();
        }
    }
    else
    {
        GreReleaseSemaphoreEx(ghsemDriverMgmt);
    }

    return (HDEV) ppdev;
}

/******************************Public*Routine******************************\
* vSynchronizeDriver
*
* Calls DrvSynchronize if the driver has set either GCAPS2_SYNCFLUSH
* or GCAPS2_SYNCTIMER, as appropriate.
*
* History:
*  15-Dec-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vSynchronizeDriver(FLONG flSynchronizeType)
{
    HDEV    hdev;

    //
    // Note that we check the synchronize counts outside of a lock, which
    // is okay.
    //

    //
    // We just accumlate what needs to be synchronized when we are in the middle
    // of a mode change.
    //

    if (CModeChangeInProgress::lInModeChange)
    {
        if(flSynchronizeType == GCAPS2_SYNCFLUSH && gcSynchronizeFlush != -1)
            InterlockedCompareExchange(&CModeChangeInProgress::lNeedSyncFlush,1,0);
        if(flSynchronizeType == GCAPS2_SYNCTIMER && gcSynchronizeTimer != -1)
            InterlockedCompareExchange(&CModeChangeInProgress::lNeedTimerFlush,1,0);
        return;
    }

    if (((flSynchronizeType == GCAPS2_SYNCFLUSH) && (gcSynchronizeFlush != -1)) ||
        ((flSynchronizeType == GCAPS2_SYNCTIMER) && (gcSynchronizeTimer != -1)))
    {
        for (hdev = hdevEnumerate(NULL); hdev; hdev = hdevEnumerate(hdev))
        {
            PDEVOBJ pdo(hdev);

            ASSERTGDI(pdo.bValid(), "GreFlush: invalid PDEV");
            ASSERTGDI(pdo.bDisplayPDEV(), "GreFlush: not a display PDEV");

            if (pdo.flGraphicsCaps2NotDynamic() & flSynchronizeType)
            {
                GreAcquireSemaphoreEx(pdo.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
                GreEnterMonitoredSection(pdo.ppdev, WD_DEVLOCK);

                if ((pdo.flGraphicsCaps2() & flSynchronizeType) &&
                    !(pdo.bDisabled()))
                {
                    FLONG   fl = 0;

                    if ((flSynchronizeType == GCAPS2_SYNCFLUSH) &&
                        (gcSynchronizeFlush != -1))
                    {
                        fl |= DSS_FLUSH_EVENT;
                    }

                    if ((flSynchronizeType == GCAPS2_SYNCTIMER) &&
                        (gcSynchronizeTimer != -1))
                    {
                        fl |= DSS_TIMER_EVENT;
                    }

                    pdo.vSync(pdo.pSurface()->pSurfobj(), NULL, fl);
                }

                GreExitMonitoredSection(pdo.ppdev, WD_DEVLOCK);
                GreReleaseSemaphoreEx(pdo.hsemDevLock());
            }
        }
    }
}

/******************************Public*Routine******************************\
* GreFlush
*
* Called for GdiFlush.
*
* Calls DrvSynchronize if it is hooked and GCAPS2_SYNCFLUSH is set.
*
* History:
*  15-Dec-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
GreFlush()
{
    vSynchronizeDriver(GCAPS2_SYNCFLUSH);
}

/******************************Public*Routine******************************\
* GreSynchronizeTimer
*
* When the synchronization timer is enabled, this routine will be called
* by User's RIT.  We, in turn, call any driver that has set GCAPS_SYNCTIMER.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID APIENTRY GreSynchronizeTimer(PVOID pwnd, UINT msg, UINT_PTR id, LPARAM lParam)
{
    vSynchronizeDriver(GCAPS2_SYNCTIMER);
}

/******************************Public*Routine******************************\
* vEnableSynchronize
*
* This routine enables GCAPS2_SYNCFLUSH and GCAPS2_SYNCTIMER
* synchronization for the driver.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vEnableSynchronize(HDEV hdev)
{
    GDIFunctionID(vEnableSynchronize);

    PDEVOBJ po(hdev);

    FLONG flCaps = po.flGraphicsCaps2();

    if (flCaps & (GCAPS2_SYNCFLUSH | GCAPS2_SYNCTIMER))
    {
        BOOL    AcquireUserCritSec;

        //
        // We will be calling User, which needs to acquire its critical
        // section.  The devlock must always be acquired after the User
        // critical section; consequently, we cannot be holding a devlock
        // at this point if we're not already holding the user lock.
        //

        AcquireUserCritSec = !UserIsUserCritSecIn();
        if (AcquireUserCritSec)
        {
            po.vAssertNoDevLock();
            UserEnterUserCritSec();
        }

        if (flCaps & GCAPS2_SYNCTIMER)
        {
            //
            // It's the responsibility of the first thread to increment
            // the count past -1 to create the timer.
            //

            if (++gcSynchronizeTimer == 0)
            {
                ASSERTGDI(gidSynchronizeTimer == 0,
                    "Expected no timer to have already been created.");

                //
                // Note that at boot time we actually expect this timer
                // creation to fail, as User hasn't had a chance to
                // create the RIT yet.  GreSetTimers handles the actual
                // timer creation for that case.  Because of this case,
                // we can't strictly fail here if the timer can't be
                // created; however, it's not the end of the world --
                // this will happen only in a degenerate case, and at
                // worst the video will be very jerky.
                //

                gidSynchronizeTimer = UserSetTimer(SYNCTIMER_FREQUENCY,
                                                   GreSynchronizeTimer);
            }
        }

        if (flCaps & GCAPS2_SYNCFLUSH)
        {
            gcSynchronizeFlush++;
        }

        po.vSynchronizeEnabled(TRUE);

        if (AcquireUserCritSec)
        {
            UserLeaveUserCritSec();
        }
    }
}

/******************************Public*Routine******************************\
* vDisableSynchronize(HDEV hdev)
*
* This routine disables GCAPS2_SYNCFLUSH and GCAPS2_SYNCTIMER
* synchronization for the driver.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vDisableSynchronize(HDEV hdev)
{
    GDIFunctionID(vDisableSynchronize);

    PDEVOBJ po(hdev);
    BOOL    AcquireUserCritSec;

    //
    // We will be calling User, which needs to acquire its critical
    // section.  The devlock must always be acquired after the User
    // critical section; consequently, we cannot be holding a devlock
    // at this point if we're not already holding the user lock.
    //

    AcquireUserCritSec = !UserIsUserCritSecIn();
    if (AcquireUserCritSec)
    {
        po.vAssertNoDevLock();
        UserEnterUserCritSec();
    }

    if (po.bSynchronizeEnabled())
    {
        FLONG flCaps = po.flGraphicsCaps2();

        if (flCaps & GCAPS2_SYNCFLUSH)
        {
            ASSERTGDI(gcSynchronizeFlush > -1, "Unexpected flush count");

            gcSynchronizeFlush--;
        }

        if (flCaps & GCAPS2_SYNCTIMER)
        {
            //
            // It's the responsibility of the first thread to decrement
            // the count to -1 to kill the timer.
            //

            ASSERTGDI(gcSynchronizeTimer > -1, "Unexpected timer count");

            if (--gcSynchronizeTimer < 0)
            {
                if (gidSynchronizeTimer != 0)
                {
                    UserKillTimer(gidSynchronizeTimer);
                    gidSynchronizeTimer = 0;
                }
            }
        }

        po.vSynchronizeEnabled(FALSE);
    }

    if (AcquireUserCritSec)
    {
        UserLeaveUserCritSec();
    }
}

/******************************Public*Routine******************************\
* GreStartTimers()
*
* Called by User when the RIT thread is finally initialized, and we
* can set up timers.  We need this because driver initialization
* occurs before the RIT is initialized, which would have been the
* natural place to put the timer initialization for us.
*
* History:
*  2-Jun-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID GreStartTimers()
{
    GDIFunctionID(GreStartTimers);

    BOOL    AcquireUserCritSec;

    AcquireUserCritSec = !UserIsUserCritSecIn();
    if (AcquireUserCritSec)
    {
        UserEnterUserCritSec();
    }

    if (gcSynchronizeTimer != -1)
    {
        ASSERTGDI(gidSynchronizeTimer == NULL,
                "Expected no timer to have already been created.");

        gidSynchronizeTimer = UserSetTimer(SYNCTIMER_FREQUENCY,
                                           GreSynchronizeTimer);
    }

    if (AcquireUserCritSec)
    {
        UserLeaveUserCritSec();
    }
}

/**************************************************************************\
* CmodeChangeInProgress::vDone(). 
*
* Called by DrvChangeDisplaySettings just before it realeases the
* ghsemShareDevLock so we may flush any pending vSynchronizeDriver calls.
*
* History:
*  18-Oct-2001 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

void CModeChangeInProgress::vDone()
{
    InterlockedDecrement(&lInModeChange);

    if (lNeedSyncFlush)
    {
        vSynchronizeDriver(GCAPS2_SYNCFLUSH);
        InterlockedDecrement(&lNeedSyncFlush);
    }
    if (lNeedTimerFlush)
    {
        vSynchronizeDriver(GCAPS2_SYNCTIMER);
        InterlockedDecrement(&lNeedTimerFlush);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\meta.cxx ===
/******************************Module*Header*******************************\
* Module Name: meta.cxx
*
* This contains the code to create metafiles in the kernel
*
* Created: 26-Mar-1997
* Author: Andre Vachon [andreva]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"


#if DBG
LONG cSrvMetaFile = 0;
LONG cMaxSrvMetaFile = 0;
#endif

class META : public OBJECT
{
public:
    DWORD iType;    // MFPICT_IDENTIFIER or MFEN_IDENTIFIER
    DWORD mm;       // used by MFPICT_IDENTIFIER only
    DWORD xExt;     // used by MFPICT_IDENTIFIER only
    DWORD yExt;     // used by MFPICT_IDENTIFIER only
    ULONG cbData;   // Number of bytes in abData[]
    BYTE  abData[1];    // Metafile bits
};

typedef META *PMETA;

/******************************Public*Routine******************************\
* NtGdiCreateServerMetaFile()
*
* History:
*  26-Mar-1997 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
NtGdiCreateServerMetaFile(
    DWORD  iType,
    ULONG  cjData,
    LPBYTE pjData,
    DWORD  mm,
    DWORD  xExt,
    DWORD  yExt
    )
{
    PMETA pMeta;
    HANDLE hRet = NULL;

    if ((iType != MFEN_IDENTIFIER) && (iType != MFPICT_IDENTIFIER))
    {
        ASSERTGDI(FALSE, "GreCreateServerMetaFile: unknown type\n");
        return NULL;
    }

    if (pjData == NULL)
    {
        WARNING("GreCreateServerMetaFile: No metafile bits\n");
        return NULL;
    }

    if (cjData > (MAXULONG - sizeof(META)))
    {
        WARNING("GreCreateServerMetaFile: overflow\n");
        return NULL;
    }

    pMeta = (PMETA) HmgAlloc(cjData + sizeof(META),
                             META_TYPE,
                             HMGR_ALLOC_LOCK | HMGR_MAKE_PUBLIC);

    if (pMeta)
    {
        hRet = pMeta->hGet();

        pMeta->iType  = iType;
        pMeta->mm     = mm;
        pMeta->xExt   = xExt;
        pMeta->yExt   = yExt;
        pMeta->cbData = cjData;

        if (cjData)
        {
            __try
            {
                //
                // Probe and Read the structure
                //

                ProbeForRead(pjData, cjData, sizeof(DWORD));

                RtlCopyMemory((PVOID) pMeta->abData,
                              (PVOID) pjData,
                              cjData);

#if DBG
                InterlockedIncrement(&cSrvMetaFile);
                if (cMaxSrvMetaFile < cSrvMetaFile)
                {
                    cMaxSrvMetaFile = cSrvMetaFile;
                }

                if (cSrvMetaFile >= 100)
                {
                    DbgPrint("GreCreateServerMetaFile: Number of server metafiles is %ld\n", cSrvMetaFile);
                }
#endif
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(14);
                hRet = 0;
            }

        }

        if (hRet == 0)
        {
            HmgFree((HOBJ) pMeta->hGet());
        }
        else
        {
            DEC_EXCLUSIVE_REF_CNT(pMeta);
        }
    }

    if (hRet == 0)
    {
        WARNING("NtGdiCreateServerMetaFile: unable to create metafile\n");
    }

    return (hRet);
}


/******************************Public*Routine******************************\
* NtGdiGetServerMetaFileBits()
*
* History:
*  26-Mar-1997 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
NtGdiGetServerMetaFileBits(
    HANDLE hmo,
    ULONG  cjData,
    LPBYTE pjData,
    PDWORD piType,
    PDWORD pmm,
    PDWORD pxExt,
    PDWORD pyExt
    )
{
    ULONG  ulRet = 0;

    PMETA pMeta = (PMETA) HmgLock((HOBJ)hmo, META_TYPE);

    if (pMeta)
    {
        if (pMeta->iType == MFPICT_IDENTIFIER ||
            pMeta->iType == MFEN_IDENTIFIER)
        {
            //
            // How much data is (or should be) returned.
            //

            ulRet = pMeta->cbData;

            if (cjData)
            {
                if (cjData != pMeta->cbData)
                {
                    ASSERTGDI(FALSE, "GreGetServerMetaFileBits: sizes do no match");
                    ulRet = 0;
                }
                else
                {
                    __try
                    {
                        ProbeAndWriteUlong(pxExt,pMeta->xExt);
                        ProbeAndWriteUlong(pyExt,pMeta->yExt);
                        ProbeAndWriteUlong(piType,pMeta->iType);
                        ProbeAndWriteUlong(pmm,pMeta->mm);

                        ProbeForWrite(pjData, cjData, sizeof(DWORD));

                        RtlCopyMemory(pjData,
                                      (PVOID) pMeta->abData,
                                      pMeta->cbData);

                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        WARNINGX(20);
                        ulRet = 0;
                    }
                }
            }
        }

        DEC_EXCLUSIVE_REF_CNT(pMeta);
    }

    return (ulRet);
}


/******************************Public*Routine******************************\
* GreDeleteServerMetaFile()
*
* History:
*  26-Mar-1997 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/


BOOL
GreDeleteServerMetaFile(
    HANDLE hmo
    )
{
    PMETA pMeta = (PMETA) HmgLock((HOBJ)hmo, META_TYPE);

    if (pMeta)
    {
        if (pMeta->iType == MFPICT_IDENTIFIER ||
            pMeta->iType == MFEN_IDENTIFIER)
        {
            HmgFree((HOBJ) pMeta->hGet());
#if DBG
            InterlockedDecrement(&cSrvMetaFile);
            if (cSrvMetaFile < 0)
            {
                ASSERTGDI(FALSE, "GreDeleteServerMetaFile: cSrvMetaFile < 0");
            }
#endif
            return TRUE;
        }
        else
        {
            DEC_EXCLUSIVE_REF_CNT(pMeta);
        }
    }

    WARNING("GreDeleteServerMetaFile: bad metafile handle");

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\misc.cxx ===
/******************************Module*Header*******************************\
* Module Name: MISC.CXX                                                   *
*                                                                         *
* _HYDRA_  routines                                                         *
*                                                                         *
* Copyright (c) 1997-1999 Microsoft                                            *
\**************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

BOOL G_fDoubleDpi = FALSE;
BOOL G_fConsole = TRUE;
PFILE_OBJECT G_RemoteVideoFileObject = NULL;
PFILE_OBJECT G_RemoteConnectionFileObject = NULL;
HANDLE G_RemoteConnectionChannel = NULL;
PBYTE G_PerformanceStatistics = NULL;
LPWSTR G_DisplayDriverNames = L"vgastub\0";



PFILE_OBJECT G_SaveRemoteVideoFileObject = NULL;
PFILE_OBJECT G_SaveRemoteConnectionFileObject = NULL;
HANDLE G_SaveRemoteConnectionChannel = NULL;
PBYTE G_SavePerformanceStatistics = NULL;


/******************************Exported*Routine****************************\
*
* GreConsoleShadowStart( )
*
*
* Saves remote channel handles and swicth to channel handles for Console Shadow
*
\**************************************************************************/

BOOL GreConsoleShadowStart( HANDLE hRemoteConnectionChannel,
                           PBYTE pPerformanceStatistics,
                           PFILE_OBJECT pVideoFile,
                           PFILE_OBJECT pRemoteConnectionFileObject
                            )
{

    G_SaveRemoteVideoFileObject = G_RemoteVideoFileObject;
    G_SaveRemoteConnectionFileObject = G_RemoteConnectionFileObject;
    G_SavePerformanceStatistics = G_PerformanceStatistics;
    G_SaveRemoteConnectionChannel = G_RemoteConnectionChannel;

    
    G_RemoteVideoFileObject = pVideoFile;
    G_RemoteConnectionFileObject = pRemoteConnectionFileObject;
    G_PerformanceStatistics = pPerformanceStatistics;
    G_RemoteConnectionChannel = hRemoteConnectionChannel;

    return TRUE;
}


/******************************Exported*Routine****************************\
*
* GreConsoleShadowStop( )
*
*
* Restores remote channel handles after Console Shadow
*
\**************************************************************************/

BOOL GreConsoleShadowStop( VOID )
{

    
    G_RemoteVideoFileObject = G_SaveRemoteVideoFileObject;
    G_RemoteConnectionFileObject = G_SaveRemoteConnectionFileObject;
    G_PerformanceStatistics = G_SavePerformanceStatistics;
    G_RemoteConnectionChannel = G_SaveRemoteConnectionChannel;

    return TRUE;
}





/******************************Exported*Routine****************************\
*
* GreMultiUserInitSession( )
*
*
* Initialize the multi-user session gre library
*
\**************************************************************************/

BOOL GreMultiUserInitSession( HANDLE hRemoteConnectionChannel,
                           PBYTE pPerformanceStatistics,
                           PFILE_OBJECT pVideoFile,
                           PFILE_OBJECT pRemoteConnectionFileObject,
                           ULONG DisplayDriverNameLength,
                           PWCHAR DisplayDriverName
                            )
{
    BOOL bRet = FALSE;

    G_RemoteVideoFileObject = pVideoFile;
    G_RemoteConnectionFileObject = pRemoteConnectionFileObject;
    G_PerformanceStatistics = pPerformanceStatistics;
    G_RemoteConnectionChannel = hRemoteConnectionChannel;

    G_DisplayDriverNames = (LPWSTR)GdiAllocPool(
                            (DisplayDriverNameLength + 1) * sizeof(WCHAR),
                            'yssU');

    if (G_DisplayDriverNames)
    {
        wcsncpy(G_DisplayDriverNames, DisplayDriverName, DisplayDriverNameLength + 1);
        bRet = TRUE;
    }

    return bRet;
}

/******************************Exported*Routine****************************\
* HDXDrvEscape( hdev, iEsc, pInbuffer, cbInbuffer )
*
* Tell the TShare display driver to perform the specified operation.
*
* hdev (input)
*   Identifies the device
*
* iEsc (input)
*   Specifies the Operation to be performed
*
*       ESC_FLUSH_FRAME_BUFFER      Flush the frame buffer
*       ESC_SET_WD_TIMEROBJ         Pass the timer object to the WD
*
* pInbuffer (input)
*   Data buffer
*
* cbInbuffer (input)
*   Data buffer length
*
\**************************************************************************/

BOOL HDXDrvEscape( HDEV hdev, ULONG iEsc, PVOID pInbuffer, ULONG cbInbuffer )
{
    BOOL Result;
    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);;

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);;

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver to perform the specified operation
        //
        if ( PPFNVALID(po,Escape) )
        Result = (*PPFNDRV(po,Escape))(&po.pSurface()->so, iEsc, cbInbuffer, pInbuffer, 0, NULL );
        else
            Result = TRUE;
    }
    GreReleaseSemaphoreEx(po.hsemDevLock());

    return(Result);
}

/******************************Exported*Routine****************************\
*
* bDrvReconnect( hDev, RemoteConnectionChannel )
*
* This is done for reconnects.
*
* Notify the display driver of a new connection (not a shadow connection)
*
* hdev (input)
*   Identifies device to be connected
* RemoteConnectionChannel (input)
*   Remote channel handle
* pRemoteConnectionFileObject (input)
*   Remote connection channel file object
*
\**************************************************************************/

BOOL bDrvReconnect( HDEV hdev,
                    HANDLE RemoteConnectionChannel,
                    PFILE_OBJECT pRemoteConnectionFileObject,
                    BOOL bSetPalette )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver connect function (if defined)
        //

        if ( PPFNVALID(po,Reconnect) )
            Result = (*PPFNDRV(po,Reconnect))( RemoteConnectionChannel, pRemoteConnectionFileObject );
        else
            Result = TRUE;

        if ( bSetPalette == TRUE ) {

            //
            // Set the palette
            //

            XEPALOBJ pal(po.ppalSurf());
            ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

            if ((Result == TRUE) && pal.bIsPalManaged())
            {
                ASSERTGDI(PPFNVALID(po,SetPalette), "ERROR palette is not managed");

                (*PPFNDRV(po,SetPalette))(po.dhpdev(),
                                          (PALOBJ *) &pal,
                                          0,
                                          0,
                                          pal.cEntries());
            }
        }
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}


/******************************Exported*Routine****************************\
* bDrvDisconnect(hdev)
*
* Notify the display driver that the connection is going away.
* This is the primary connection.
*
* hdev (input)
*   Identifies device to be disabled
*
* RemoteConnectionChannel (input)
*   Channel being disconnected
*
* pRemoteConnectionFileObject (input)
*   File object pointer to Channel being disconnected
*
\**************************************************************************/

BOOL bDrvDisconnect( HDEV hdev, HANDLE RemoteConnectionChannel, PFILE_OBJECT pRemoteConnectionFileObject )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver disconnect function (if defined)
        //

        if ( PPFNVALID(po,Disconnect) )
            Result = (*PPFNDRV(po,Disconnect))( RemoteConnectionChannel, pRemoteConnectionFileObject );
        else
            Result = TRUE;
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}

/******************************Exported*Routine****************************\
*
* bDrvShadowConnect( hDev, RemoteConnectionChannel, pRemoteConnectionFileObject )
*
* This is done for new shadow connections.
*
* hdev (input)
*   Identifies device to be connected
* RemoteConnectionChannel ( input )
*   Remote connection channel of shadow (for modes)
* pRemoteConnectionFileObject ( input )
*   Remote Connection file object pointer of shadow (for modes)
*
\**************************************************************************/

BOOL bDrvShadowConnect( HDEV hdev, PVOID pRemoteConnectionData, ULONG RemoteConnectionDataLength )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver connect function (if defined)
        //

        if ( PPFNVALID(po,ShadowConnect) )
            Result = (*PPFNDRV(po,ShadowConnect))( pRemoteConnectionData, RemoteConnectionDataLength );
        else
            Result = TRUE;

        //
        // Set the palette
        //

        XEPALOBJ pal(po.ppalSurf());
        ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

        if ((Result == TRUE) && pal.bIsPalManaged())
        {
            ASSERTGDI(PPFNVALID(po,SetPalette), "ERROR palette is not managed");

            (*PPFNDRV(po,SetPalette))(po.dhpdev(),
                                      (PALOBJ *) &pal,
                                      0,
                                      0,
                                      pal.cEntries());
        }
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}


/******************************Exported*Routine****************************\
* bDrvShadowDisconnect(hdev, RemoteConnectionChannel, pRemoteConnectionFileObject)
*
* Notify the display driver that the shadow connection is going away.
*
* hdev (input)
*   Identifies device to be disabled
*
* RemoteConnectionChannel (input)
*   Shadow Channel being disconnected
* pRemoteConnectionFileObject (input)
*   Shadow Channel being disconnected
*
\**************************************************************************/

BOOL bDrvShadowDisconnect( HDEV hdev, PVOID pRemoteConnectionData, ULONG RemoteConnectionDataLength )
{
    BOOL Result;

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver disconnect function (if defined)
        //

        if ( PPFNVALID(po,ShadowDisconnect) )
            Result = (*PPFNDRV(po,ShadowDisconnect))( pRemoteConnectionData, RemoteConnectionDataLength );
        else
            Result = TRUE;

        //
        // Reset the palette
        //

        XEPALOBJ pal(po.ppalSurf());
        ASSERTGDI(pal.bValid(), "EPALOBJ failure\n");

        if ((Result == TRUE) && pal.bIsPalManaged())
        {
            ASSERTGDI(PPFNVALID(po,SetPalette), "ERROR palette is not managed");

            (*PPFNDRV(po,SetPalette))(po.dhpdev(),
                                      (PALOBJ *) &pal,
                                      0,
                                      0,
                                      pal.cEntries());
        }
    }

    GreReleaseSemaphoreEx(po.hsemDevLock());

    return( Result );
}


/******************************Exported*Routine****************************\
* vDrvInvalidateRect( hdev, prcl )
*
* Tell the display driver to invalidate the specified rect.
*
* hdev (input)
*   Identifies the device
*
* prcl (input)
*   Identifies the rectangle to invalidate
*
\**************************************************************************/

VOID vDrvInvalidateRect( HDEV hdev, PRECT prcl )
{
    GDIFunctionID(vDrvInvalidateRect);

    PDEVOBJ po(hdev);

    if (!po.bValid())
        return;

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return;

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver invalidate rect function (if defined)
        //
        if ( PPFNVALID(po,InvalidateRect) )
            (*PPFNDRV(po,InvalidateRect))( prcl );
    }

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphore(po.hsemDevLock());
}


/******************************Exported*Routine****************************\
* vDrvDispalyIOCtl( hdev, pbuffer, cbbuffer )
*
* Tell the display driver to invalidate the specified rect.
*
* hdev (input)
*   Identifies the device
*
* pbuffer (input)
*   IOCtl data buffer
*
* cbbuffer (input)
*   IOCtl data buffer length
*
\**************************************************************************/

BOOL bDrvDisplayIOCtl( HDEV hdev, PVOID pbuffer, ULONG cbbuffer )
{
    BOOL Result;
    PDEVOBJ po(hdev);

    if (!po.bValid())
        return(FALSE);;

    //
    // If this is not a DISPLAY, return error
    //

    if (!po.bDisplayPDEV())
        return(FALSE);;

    //
    // Wait for the display to become available and lock it.
    //

    GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

    {
        SEMOBJ so(po.hsemPointer());

        //
        // The device may have something going on, synchronize with it first
        //

        po.vSync(po.pSurface()->pSurfobj(),NULL,0);

        //
        // Call the driver invalidate rect function (if defined)
        //
        if ( PPFNVALID(po,DisplayIOCtl) )
            Result = (*PPFNDRV(po,DisplayIOCtl))( pbuffer, cbbuffer );
        else
            Result = TRUE;
    }

    GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(po.hsemDevLock());

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\muio.c ===
/*************************************************************************
*
* io.c
*
* Functions to perform kernel level file I/O.
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
*
*************************************************************************/

#include <ntosp.h>
#include <ctxdd.h>

#if !defined(_GDIPLUS_)

/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS
_CtxDoFileIo(
    IN ULONG MajorFunction,
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent,
    OUT PIO_STATUS_BLOCK pIosb,
    OUT PIRP *ppIrp 
    );

NTSTATUS
_CtxDeviceControlComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*******************************************************************************
 *
 *  CtxReadFile
 *
 *    Kernel read file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to read buffer
 *    Length (input)
 *       length of read buffer
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxReadFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    return( _CtxDoFileIo( IRP_MJ_READ, fileObject, Buffer, Length, pEvent, pIosb, ppIrp ) );
}


/*******************************************************************************
 *
 *  CtxWriteFile
 *
 *    Kernel write file routine.
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    Buffer (input)
 *       pointer to write buffer
 *    Length (input)
 *       length of write buffer
 *    pEvent (input) 
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxWriteFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    return( _CtxDoFileIo( IRP_MJ_WRITE, fileObject, Buffer, Length, pEvent, pIosb, ppIrp ) );
}


NTSTATUS
_CtxDoFileIo(
    IN ULONG MajorFunction,
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent,
    OUT PIO_STATUS_BLOCK pIosb,
    OUT PIRP *ppIrp
    )
{
    PDEVICE_OBJECT deviceObject;
    LARGE_INTEGER Offset;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    KIRQL irql;
    extern ULONG IoReadOperationCount, IoWriteOperationCount;
    static IO_STATUS_BLOCK Iosb;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
    KeClearEvent( pEvent );
    }

    /*
     * If the caller does not supply an IOSB, supply
     * a static one to avoid the overhead of the exception
     * handler in the IO completion APC. Since the caller(s)
     * do not care about the result, we can point all such
     * callers to the same one.
     */
    if( pIosb == NULL ) {
        pIosb = &Iosb;
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    Offset.LowPart = FILE_WRITE_TO_END_OF_FILE;
    Offset.HighPart = -1;
    irp = IoBuildAsynchronousFsdRequest( MajorFunction, deviceObject,
                                         Buffer, Length, &Offset, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );
   
    /*
     * Save callers event pointer.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    irp->UserEvent = pEvent;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;

    /*
     * Set the address of the current thread in the packet so the
     * completion code will have a context to execute in.
     */
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue the IRP to the current thread
    //
    IoQueueThreadIrp( irp );


    //
    // Call driver
    //
    status = IoCallDriver( deviceObject, irp );

    //
    // If irp->UserEvent == NULL, IO completion will set the file
    // object event and status.
    //
    if (pEvent == NULL) {

        if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            KernelMode, // Prevent KSTACK from paging
                                            FALSE,      // Non-alertable
                                            (PLARGE_INTEGER) NULL );

            ASSERT(status != STATUS_ALERTED);
            ASSERT(status != STATUS_USER_APC);

            status = fileObject->FinalStatus;
        }
    }

    if ( pEvent != NULL && ppIrp != NULL ) {
        // Trap whatever driver uses this inheritly broken interface
        *ppIrp = NULL;
    }

    return( status );
}


/*******************************************************************************
 *
 *  CtxDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IoControlCode (input)
 *       Io control code
 *    InputBuffer (input)
 *       pointer to input buffer (optional)
 *    InputBufferLength (input)
 *       length of input buffer
 *    OutputBuffer (input)
 *       pointer to output buffer (optional)
 *    OutputBufferLength (input)
 *       length of output buffer
 *    InternalDeviceIoControl (input)
 *       if TRUE, use IOCTL_INTERNAL_DEVICE_IO_CONTROL
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxDeviceIoControlFile(
    IN PFILE_OBJECT fileObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
    KeClearEvent( pEvent );
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( IoControlCode, deviceObject,
                                         InputBuffer, InputBufferLength,
                                         OutputBuffer, OutputBufferLength,
                                         InternalDeviceIoControl,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Call the driver
     */
    status = IoCallDriver( deviceObject, irp );

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if ( pEvent == NULL ) {
        if ( status == STATUS_PENDING ) {
            status = KeWaitForSingleObject( &fileObject->Event, UserRequest, KernelMode, FALSE, NULL );
            if ( status == STATUS_SUCCESS )
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if ( ppIrp )
            *ppIrp = irp;
    }

    return( status );
}


/*******************************************************************************
 *
 *  CtxInternalDeviceIoControlFile
 *
 *    Kernel DeviceIoControl routine
 *
 * ENTRY:
 *    fileObject (input)
 *       pointer to file object for I/O
 *    IrpParameters (input)
 *       information to write to the parameters section of the
 *       stack location of the IRP.
 *    IrpParametersLength (input)
 *       length of the parameter information.  Cannot be greater than 16.
 *    MdlBuffer (input)
 *       if non-NULL, a buffer of nonpaged pool to be mapped
 *       into an MDL and placed in the MdlAddress field of the IRP.
 *    MdlBufferLength (input)
 *       the size of the buffer pointed to by MdlBuffer.
 *    MinorFunction (input)
 *       the minor function code for the request.
 *    pEvent (input)
 *       pointer to I/O event (optional)
 *    pIosb (output)
 *       pointer to IoStatus block (optional)
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
CtxInternalDeviceIoControlFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    )
{
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;
    NTSTATUS status;

    /*
     * We don't support synchronous (i.e. locked) file I/O.
     */
    ASSERT( !(fileObject->Flags & FO_SYNCHRONOUS_IO) );
    if ( (fileObject->Flags & FO_SYNCHRONOUS_IO) ) {
        return( STATUS_INVALID_PARAMETER_MIX );
    }

    /*
     * If caller specified an event, clear it before we begin.
     */
    if ( pEvent ) {
    KeClearEvent( pEvent );
    }

    /*
     * Get the DeviceObject for this file
     */
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    /*
     * Build the IRP for this request
     */
    irp = IoBuildDeviceIoControlRequest( 0, deviceObject,
                                         NULL, 0,
                                         NULL, 0,
                                         TRUE,
                                         pEvent, pIosb );
    if ( irp == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * If an MDL buffer was specified, get an MDL, map the buffer,
     * and place the MDL pointer in the IRP.
     */
    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            IoFreeIrp( irp );
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        irp->MdlAddress = NULL;
    }

    /*
     * Reference the file object since it will be dereferenced in the
     * I/O completion code, and save a pointer to it in the IRP.
     * Also, we must set IRP_SYNCHRONOUS_API in the IRP flags so that
     * the I/O completion code will NOT attempt to dereference the
     * event object, since it is not a real object manager object.
     */
    ObReferenceObject( fileObject );
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = fileObject;
    irp->Flags |= IRP_SYNCHRONOUS_API;

    /*
     * Fill in the service-dependent parameters for the request.
     */
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    /*
     * Set up a completion routine which we'll use to free the MDL
     * allocated previously.
     */
    IoSetCompletionRoutine( irp, _CtxDeviceControlComplete, NULL, TRUE, TRUE, TRUE );

    /*
     * Call the driver
     */
    status = IoCallDriver( deviceObject, irp );

    /*
     * If the caller did not specify a wait event and the I/O is pending,
     * then we must wait for the I/O to complete before we return.
     */
    if ( pEvent == NULL ) {
        if ( status == STATUS_PENDING ) {
            status = KeWaitForSingleObject( &fileObject->Event, UserRequest, KernelMode, FALSE, NULL );
            if ( status == STATUS_SUCCESS )
                status = fileObject->FinalStatus;
        }

    /*
     * Caller specified a wait event.
     * Return the Irp pointer if the caller specified a return pointer.
     */
    } else {
        if ( ppIrp )
            *ppIrp = irp;
    }

    return( status );
}


NTSTATUS
_CtxDeviceControlComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return( STATUS_SUCCESS );

}

#endif // !defined(_GDIPLUS_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\muclean.cxx ===
/******************************Module*Header*******************************\
* Module Name: muclean.cxx
*
* Cleanup module for WIN32K.SYS GRE
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#include "muclean.hxx"
#include "verifier.hxx"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * External variables we must cleanup
 */

// hmgrapi.cxx
extern PLARGE_INTEGER gpLockShortDelay;
extern PVOID *gpTmpGlobalFree;
extern PVOID gpTmpGlobal;
extern "C" HFASTMUTEX ghfmMemory;
extern PVOID  gpHmgrSharedHandleSection;

// drvsup.cxx
extern PLDEV gpldevDrivers;

extern PBYTE gpRGBXlate;

// invcmap.cxx
extern PBYTE gpDefITable;

/*
 * Our global data for tracking lists
 */

LIST_ENTRY MultiUserGreEngAllocList;
HSEMAPHORE MultiUserEngAllocListLock = NULL;
#if DBG
LIST_ENTRY DebugGreMapViewList;
HSEMAPHORE DebugGreMapViewListLock = NULL;
#endif

/*
 * The EngLoadModule tracking list
 */
LIST_ENTRY GreEngLoadModuleAllocList;
HSEMAPHORE GreEngLoadModuleAllocListLock = NULL;

BOOL FASTCALL NtGdiCloseProcess(W32PID,CLEANUPTYPE);

/*
 * Forward references
 */

VOID MultiUserCleanupPathAlloc();
VOID MultiUserGreCleanupEngResources();
VOID MultiUserGreHmgOwnAll(W32PID);
VOID MultiUserGreCleanupDrivers();
VOID MultiUserGreCleanupAllFonts();
VOID MultiUserGreDeleteXLATE();
VOID vCleanUpFntCache(VOID);

// drvsup.cxx
extern VOID MultiUserDrvCleanupGraphicsDeviceList();

// fontsup.cxx
extern VOID MultiUserGreDeleteScripts();

/*
 * Debug only
 */

#if DBG

// Hydra session id (see ntuser\kernel\globals.c).
extern "C" ULONG gSessionId;

VOID DebugGreCleanupMapView();
VOID MultiUserGreHmgDbgScan(BOOL, BOOL);

char *gpszHmgrType[] = {
    "ObjectType        ",       // 0x00
    "DC_TYPE           ",       // 0x01
    "DD_DIRECTDRAW_TYPE",       // 0x02
    "DD_SURFACE_TYPE   ",       // 0x03
    "RGN_TYPE          ",       // 0x04
    "SURF_TYPE         ",       // 0x05
    "CLIENTOBJ_TYPE    ",       // 0x06
    "PATH_TYPE         ",       // 0x07
    "PAL_TYPE          ",       // 0x08
    "ICMLCS_TYPE       ",       // 0x09
    "LFONT_TYPE        ",       // 0x0a
    "RFONT_TYPE        ",       // 0x0b
    "PFE_TYPE          ",       // 0x0c
    "PFT_TYPE          ",       // 0x0d
    "ICMCXF_TYPE       ",       // 0x0e
    "SPRITE_TYPE       ",       // 0x0f
    "BRUSH_TYPE        ",       // 0x10
    "D3D_HANDLE_TYPE   ",       // 0x11
    "DD_VIDEOPORT_TYPE ",       // 0x12
    "SPACE_TYPE        ",       // 0x13
    "DD_MOTIONCOMP_TYPE",       // 0x14
    "META_TYPE         ",       // 0x15
    "EFSTATE_TYPE      ",       // 0x16
    "BMFD_TYPE         ",       // 0x17
    "VTFD_TYPE         ",       // 0x18
    "TTFD_TYPE         ",       // 0x19
    "RC_TYPE           ",       // 0x1a
    "TEMP_TYPE         ",       // 0x1b
    "DRVOBJ_TYPE       ",       // 0x1c
    "DCIOBJ_TYPE       ",       // 0x1d
    "SPOOL_TYPE        "        // 0x1e
};
#endif

/*
 *  Can put these initialization functions in the INIT segment.
 */

extern "C" {
BOOL GreEngLoadModuleTrackInit();
BOOL MultiUserGreCleanupInit();
}

#pragma alloc_text(INIT, MultiUserGreCleanupInit)
#pragma alloc_text(INIT, GreEngLoadModuleTrackInit)

extern "C" HSEMAPHORE   ghsemBMFD;
extern "C" HSEMAPHORE   ghsemVTFD;
extern "C" CP_GLYPHSET *gpcpGlyphsets;
extern "C" CP_GLYPHSET *gpcpVTFD;

extern void vCleanupPrintKViewList();

/******************************Public*Routine******************************\
* GreEngLoadModuleTrackInit
*
*   Initializes the EngLoadModule tracking list
*
* Arguments:
*
* Return Value:
*
* History:
*
*    21-Apr-1998 -by- Ori Gershony [orig]
*
\**************************************************************************/

extern "C"
BOOL
GreEngLoadModuleTrackInit()
{
    InitializeListHead(&GreEngLoadModuleAllocList);

    GreEngLoadModuleAllocListLock = GreCreateSemaphoreNonTracked();

    return (GreEngLoadModuleAllocListLock != NULL);
}


/*****************************************************************************
 *
 *  MultiUserGreCleanupInit
 *
 *   Init the GRE cleanup code
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/



extern "C"
BOOL
MultiUserGreCleanupInit()
{
    InitializeListHead(&MultiUserGreEngAllocList);
#if DBG
    InitializeListHead(&DebugGreMapViewList);
#endif

    MultiUserEngAllocListLock = GreCreateSemaphoreNonTracked();

#if DBG
    DebugGreMapViewListLock = GreCreateSemaphoreNonTracked();
#endif

#if DBG
    return ((MultiUserEngAllocListLock != NULL) &&
            (DebugGreMapViewListLock != NULL));
#else
    return (MultiUserEngAllocListLock != NULL);
#endif
}



/*****************************************************************************
 *
 *  MultiUserNtGreCleanup
 *
 *   This performs the main additional cleanup processing
 *   of kernel mode GRE. This supports the unloading of the
 *   win32k.sys kernel module on WinFrame.
 *
 *   Our concern here is non-paged pool and kernel resource
 *   objects. Paged pool is not a problem since a WINSTATION SPACE
 *   paged pool allocator is used which destroys all pageable memory
 *   allocated by win32k.sys and its video and printer drivers when
 *   the WINSTATION SPACE is deleted.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

extern PPAGED_LOOKASIDE_LIST pHmgLookAsideList[];
extern "C" PVOID LastNlsTableBuffer;

VOID CleanUpEUDC(VOID);

extern "C"
BOOL
MultiUserNtGreCleanup()
{
    NTSTATUS ntstatus;
    W32PID pid = W32GetCurrentPID();

    //
    // Assign ownership of all handle manager objects to cleanup process.
    // Must be done first.
    //

    MultiUserGreHmgOwnAll(pid);

    GdiMultiUserFontCleanup();

    //
    // Use the process termination code to delete the majority of objects
    // (all except some font related objects).
    //

    if(gpentHmgr!=NULL) {
      NtGdiCloseProcess(pid, CLEANUP_SESSION);
    }


    if (gpfsTable)
    {
        VFREEMEM(gpfsTable);
        gpfsTable = NULL;
    }

    if (MAPPER::SignatureTable)
    {
        VFREEMEM(MAPPER::SignatureTable);
        MAPPER::SignatureTable = NULL;
    }

    // Clean up LastNlsTableBuffer

    if (LastNlsTableBuffer)
    {
        VFREEMEM(LastNlsTableBuffer);
        LastNlsTableBuffer = NULL;
    }

    //
    // Cleanup the scripts (created by InitializeScripts during
    // InitializeGre).
    //
    MultiUserGreDeleteScripts();

    //
    // Cleanup the XLATE cache (created by vInitXLATE during
    // InitializeGre).
    //

    MultiUserGreDeleteXLATE();

    //
    // Cleanup RBRUSH caches.
    //

    if (gpCachedEngbrush)
    {
        //
        // Engine brush cache is just one deep (refer to
        // EngRealizeBrush in engbrush.cxx).
        //

        VFREEMEM(gpCachedEngbrush);
    }

    if (gpCachedDbrush)
    {
        //
        // Device brush cache is just one deep (refer to
        // BRUSHOBJ__pvAllocRbrush in brushddi.cxx).
        //

        VFREEMEM(gpCachedDbrush);
    }

    if (gpRGBXlate)
    {
       VFREEMEM(gpRGBXlate);
       gpRGBXlate = NULL;
    }

    if(gpDefITable)
    {
        VFREEMEM(gpDefITable);
        gpDefITable = NULL;
    }

    //
    // Cleanup driver objects.
    //

    MultiUserGreCleanupDrivers();

#ifdef _PER_SESSION_GDEVLIST_
    //
    // Currently, the graphics device list (see drvsup.cxx) is allocated
    // per-Hydra session.  AndreVa has proposed that they be allocated
    // globally.  He's probably right, but until this changes we need to
    // clean them up during Hydra shutdown.
    //
    // To enable cleanup of the per-Hydra graphics device lists (i.e.,
    // the function MultiUserDrvCleanupGraphicsDeviceList in drvsup.cxx),
    // define _PER_SESSION_GDEVLIST_ in muclean.hxx.
    //

    MultiUserDrvCleanupGraphicsDeviceList();

#endif

    //
    // Handle manager should be empty at this point.
    //

#if DBG
    if (gpentHmgr != NULL) {
        MultiUserGreHmgDbgScan(TRUE, TRUE);
    }
#endif

    //
    // Cleanup random pool allocations.
    //

    if (gpLockShortDelay)
    {
        GdiFreePool(gpLockShortDelay);
        gpLockShortDelay = NULL;
    }

    if (gpTmpGlobal)
    {
        GdiFreePool(gpTmpGlobal);
        gpTmpGlobal = NULL;
    }

    if (gpTmpGlobalFree)
    {
        GdiFreePool(gpTmpGlobalFree);
        gpTmpGlobalFree = NULL;
    }

    //
    // Call the C++ "friend" function for cleanup
    //

    MultiUserCleanupPathAlloc();

    //
    // These must be last since they catch all the
    // leftover NT kernel resource objects that were
    // not released by the above code.
    //
    // The reason this is done is that these objects
    // can be created as the result of embedded classes
    // that stay around.
    //
    // Also every printer driver also can call EngCreateSemaphore
    // and leak it.
    //

    //
    // Cleanup the tracked resources.
    //

    MultiUserGreCleanupEngResources();

#if DBG
    //
    // On free builds, we track and cleanup only the views
    // allocated by drivers (i.e., through the Eng
    // helper functions).
    //
    // However, on debug builds we will track all views
    // to help find engine leaks.  The functions below
    // will cleanup, but they will also assert.
    //

    DebugGreCleanupMapView();
#endif

    //
    // Cleanup watchdog's association list mutex.
    //

    GreDeleteFastMutex(gAssociationListMutex);
    gAssociationListMutex = NULL;

    //
    // Cleanup the HMGR look aside buffer mutex.
    //

    GreDeleteFastMutex(ghfmMemory);
    ghfmMemory = NULL;

    if (gpGdiSharedMemory)
    {
        ntstatus = Win32UnmapViewInSessionSpace(gpGdiSharedMemory);
        gpGdiSharedMemory = NULL;
    }

    if (gpHmgrSharedHandleSection)
    {
        Win32DestroySection(gpHmgrSharedHandleSection);
        gpHmgrSharedHandleSection  = NULL;
    }

    //
    // Free the HMGR lookaside lists.
    //

    for (int i = 0; i <= MAX_TYPE; i++)
    {
        if (pHmgLookAsideList[i] != NULL)
        {
            ExDeletePagedLookasideList(pHmgLookAsideList[i]);
            GdiFreePool(pHmgLookAsideList[i]);
            pHmgLookAsideList[i]=NULL;
        }
    }

    return(TRUE);
}

/*****************************************************************************
 *
 *  MultiUserCleanupPathAlloc
 *
 *   Friend function to cleanup a PATHALLOC object's
 *   class global state.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
MultiUserCleanupPathAlloc()
{
    // pathobj.cxx
    if (PATHALLOC::hsemFreelist)
    {
        GreDeleteSemaphore(PATHALLOC::hsemFreelist);
        PATHALLOC::hsemFreelist = NULL;
    }

    //
    // Release the PATHALLOC freelist.
    //

    while (PATHALLOC::freelist)
    {
        PATHALLOC *ppa = PATHALLOC::freelist;
        PATHALLOC::freelist = ppa->ppanext;

        VFREEMEM(ppa);
    }

    return;
}

/******************************Public*Routine******************************\
* MultiUserGreTrackAddEngResource
*
* Add an entry associated with an EngAllocMem.
*
* WARNING:
*   EngInitializeSafeSemaphore calls GreCreateSemaphore which in turn calls
*   this function.  Since EngInitializeSafeSemaphore does this with the
*   HMGR global lock (MLOCKFAST) held, this function must never call any
*   anything that grabs MLOCKFAST.  If this becomes necessary in the future,
*   EngInitializeSafeSemaphore must be rewritten.
*
* History:
*  19-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreTrackAddEngResource(
    PENGTRACKHDR peth,
    ULONG ulType
    )
{
    PLIST_ENTRY Entry = (PLIST_ENTRY) peth;

    //setting to 0 would be a waste of time
    //peth->ulReserved = 0;
    peth->ulType     = ulType;

    if(MultiUserEngAllocListLock) GreAcquireSemaphore(MultiUserEngAllocListLock);

    InsertTailList(&MultiUserGreEngAllocList, Entry);

    if(MultiUserEngAllocListLock) GreReleaseSemaphore(MultiUserEngAllocListLock);
}

/******************************Public*Routine******************************\
* MultiUserGreTrackRemoveEngResource
*
* Add an entry associated with an EngAllocMem.
*
* WARNING:
*   EngDeleteSafeSemaphore calls GreDeleteSemaphore which in turn calls
*   this function.  Since EngDeleteSafeSemaphore does this with the
*   HMGR global lock (MLOCKFAST) held, this function must never call any
*   anything that grabs MLOCKFAST.  If this becomes necessary in the future,
*   EngDeleteSafeSemaphore must be rewritten.
*
* History:
*  19-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreTrackRemoveEngResource(
    PENGTRACKHDR peth
    )
{
    PLIST_ENTRY Entry = (PLIST_ENTRY) peth;

    if(MultiUserEngAllocListLock) GreAcquireSemaphore(MultiUserEngAllocListLock);

    RemoveEntryList(Entry);

    if(MultiUserEngAllocListLock) GreReleaseSemaphore(MultiUserEngAllocListLock);
}

/******************************Public*Routine******************************\
* MultiUserGreCleanupEngResources
*
* Cleanup the tracked EngAlloc objects and tracked (Gre and Eng) semaphores.
*
* WARNING: This must not invoke any code which uses tracked semaphores. If
*          it is inevitable, the semaphores in question must be changed
*          to non-tracked semaphores (and cleaned up explicitly).
*
* WARNING: This function is called late in MultiUserGreCleanupEngResources.
*          Be careful to avoid using structures that have already been
*          cleaned up.
*
* History:
*  19-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupEngResources()
{
    volatile PLIST_ENTRY pNextEntry;

    if(MultiUserEngAllocListLock)
    {
        pNextEntry = MultiUserGreEngAllocList.Flink;

        while (pNextEntry != &MultiUserGreEngAllocList)
        {
            //
            // Resource starts after the ENGTRACKHDR.
            //

            PVOID pvVictim = (PVOID) (((ENGTRACKHDR *) pNextEntry) + 1);

            //
            // Invoke the appropriate deletion function based on type.
            //

            switch (((ENGTRACKHDR *) pNextEntry)->ulType)
            {
            case ENGTRACK_ALLOCMEM:
                EngFreeMem(pvVictim);
                break;

            case ENGTRACK_SEMAPHORE:
            case ENGTRACK_DRIVER_SEMAPHORE:
                GreDeleteSemaphore((HSEMAPHORE)pvVictim);
                break;

            case ENGTRACK_VERIFIERALLOCMEM:
                VerifierEngFreeMem(pvVictim);
                break;

            default:
                #if DBG
                DbgPrint("MultiUserGreCleanupEngResources: "
                         "unrecognized type 0x%08lx\n",
                         ((ENGTRACKHDR *) pNextEntry)->ulType);
                RIP("MultiUserGreCleanupEngResources: possible leak detected\n");
                #endif
                break;
            }

            //
            // Restart at the begining of the list since our
            // entry got deleted.
            //

            pNextEntry = MultiUserGreEngAllocList.Flink;
        }
    }

    //
    // Now delete all objects on the GreEngLoadModuleAllocList.
    //

    if(GreEngLoadModuleAllocListLock)
    {
        while (GreEngLoadModuleAllocList.Flink != &GreEngLoadModuleAllocList)
        {
            //
            // Free the module after setting the reference count to 1 (to eliminate
            // looping cRef times).
            //

            ((PENGLOADMODULEHDR)(GreEngLoadModuleAllocList.Flink))->cRef = 1;
            EngFreeModule ((HANDLE) (((PENGLOADMODULEHDR)(GreEngLoadModuleAllocList.Flink)) + 1));
        }
    }

    //
    // Delete the list locks.
    //

    GreDeleteSemaphoreNonTracked(MultiUserEngAllocListLock);
    MultiUserEngAllocListLock = NULL;

    GreDeleteSemaphoreNonTracked(GreEngLoadModuleAllocListLock);
    GreEngLoadModuleAllocListLock = NULL;
}

/*****************************Exported*Routine*****************************\
* MultiUserGreHmgOwnAll
*
* Set owner of all objects in handle manager to specified process.  Used
* for multi-user (Hydra) shutdown of GRE.
*
* WARNING:
*
*   Caller beware! This is very evil code.  It ignores the current owner
*   and the lock counts.  Acceptable for shutdown code, but definitely
*   unsafe for any other purpose.
*
* History:
*  03-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreHmgOwnAll(
    W32PID pid)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index
    UINT cObj = 0;

    //
    // Don't bother with locks.  We're shutting down, so nobody else
    // is here!
    //
    // MLOCKFAST mo;

    //
    // Scan through the entire handle manager table and set owner for
    // all valid objects.
    //
    if(gpentHmgr==NULL) {
      WARNING("MultiUserGreHmgOwnAll: gpentHmgr is NULL\n");
      return;
    }

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if ((pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
        {
            //
            // Since this is shutdown, don't bother with lock counts and
            // such.
            //

            SET_OBJECTOWNER_PID(pentTmp->ObjectOwner, pid);
            cObj++;
        }
    }

    //
    // Reset handle quota count to number objects now owned
    // (not really that important for shutdown, but it supresses
    // many warnings).
    //

    PW32PROCESS pw32Current = W32GetCurrentProcess();
    if (pw32Current)
    {
        pw32Current->GDIHandleCount = cObj;
    }
}

/******************************Public*Routine******************************\
* MultiUserGreCleanupHmgRemoveAllLocks
*
* For all objects of the specified type, all locks are removed and the
* object is marked as deletable.  If the DEF_TYPE is specified, all valid
* objects are modified.
*
* WARNING:
*
*   Caller beware! This is very evil code.  It ignores the current owner
*   and the lock counts.  Acceptable for shutdown code, but definitely
*   unsafe for any other purpose.
*
* History:
*  07-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupHmgRemoveAllLocks(OBJTYPE type)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index

    //
    // Don't bother with locks.  We're shutting down, so nobody else
    // is here!
    //
    // MLOCKFAST mo;

    //
    // Scan through the entire handle manager table zap the share count
    // and lock flag for all objects that belong to specified W32PID.
    //

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (
             ((type != DEF_TYPE) && (type == pentTmp->Objt)) ||

             ((type == DEF_TYPE) &&
              (pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
           )
        {
            ASSERTGDI((OBJECTOWNER_PID(pentTmp->ObjectOwner) == W32GetCurrentPID()),
                      "MultiUserGreCleanupHmgRemoveAllLocks: "
                      "found unowned object still in hmgr table\n");

            pentTmp->ObjectOwner.Share.Lock  = 0;
            pentTmp->einfo.pobj->ulShareCount = 0;
            pentTmp->Flags &= ~HMGR_ENTRY_UNDELETABLE;
        }
    }
}

/******************************Public*Routine******************************\
* MultiUserGreCleanupHmgOwnRemoveAllLocks
*
* For all objects of the specified type owned by current process,all locks
* are removed and the object is marked as deletable. If the DEF_TYPE is
* specified, all valid objects are modified.
*
* WARNING:
*
*   Caller beware! This is very evil code.  It ignores the current owner
*   and the lock counts.  Acceptable for shutdown code, but definitely
*   unsafe for any other purpose.
*
* History:
*  01-Aug-2001 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupHmgOwnRemoveAllLocks(OBJTYPE type)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index

    //
    // Got to take the Handle manager lock 
    //
    MLOCKFAST mo;

    //
    // Scan through the entire handle manager table zap the share count
    // and lock flag for all objects that belong to specified W32PID.
    //

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if (
             (((type != DEF_TYPE) && (type == pentTmp->Objt)) ||

             ((type == DEF_TYPE) &&
              (pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))) &&
             ((OBJECTOWNER_PID(pentTmp->ObjectOwner) == W32GetCurrentPID()))
           )
        {
            pentTmp->ObjectOwner.Share.Lock  = 0;
            pentTmp->einfo.pobj->ulShareCount = 0;
            pentTmp->Flags &= ~HMGR_ENTRY_UNDELETABLE;
        }
    }
}

/******************************Public*Routine******************************\
* bCleanupFontHash
* bCleanupFontTable
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Worker functions for MultiUserGreCleanupAllFonts.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  06-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bCleanupFontHash(FONTHASH **ppfh)
{
    BOOL bResult = FALSE;

    FHOBJ fho(ppfh);

    if (fho.bValid())
    {
        fho.vFree();
        bResult = TRUE;
    }

    return bResult;
}

BOOL bCleanupFontTable(PFT **pppft)
{
    BOOL bResult = FALSE;
    PFT *ppft = *pppft;

    PUBLIC_PFTOBJ  pfto(ppft);

    if (pfto.bValid())
    {
        //
        // Unload any fonts still in the table.
        //

        bResult = pfto.bUnloadAllButPermanentFonts(TRUE);

        //
        // Remove the font hash tables if they exist (for device fonts, the
        // font hash tables exist off the PFF rather than the PFT).
        //

        if (ppft->pfhFace)
        {
            bResult &= bCleanupFontHash(&ppft->pfhFace);
        }

        if (ppft->pfhFamily)
        {
            bResult &= bCleanupFontHash(&ppft->pfhFamily);
        }

        if (ppft->pfhUFI)
        {
            bResult &= bCleanupFontHash(&ppft->pfhUFI);
        }

        //
        // Finally, delete the font table.
        //

        bResult &= pfto.bDelete();
        *pppft = NULL;
    }

    return bResult;
}


/******************************Public*Routine******************************\
* MultiUserGreCleanupAllFonts
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Delete the font tables and hash tables.
*
* History:
*  06-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID MultiUserGreCleanupAllFonts()
{
    BOOL bResult;

    //
    // Note: since this should only be called during win32k shutdown,
    // don't bother with grabbing the semaphore.
    //

    //GreAcquireSemaphore(ghsemPublicPFT);
    {
        // Hydra
        // Saw the case where gpPFTPublic was not initialized on Hydra system

        //ASSERTGDI(gpPFTPublic, "MultiUserGreCleanupAllFonts: invalid gpPFTPublic\n");
        //ASSERTGDI(gpPFTPublic, "MultiUserGreCleanupAllFonts: invalid gpPFTDevice\n");

        //
        // Handle private table.  Note that private table can be lazily
        // created, so we have to check gpPFTPrivate.
        //

        if (gpPFTPrivate)
        {
            //
            // Delete the private font table.
            //

            bResult = bCleanupFontTable(&gpPFTPrivate);
        }

        // Hydra
        // Saw the case where gpPFTPublic was not initialized

        if (gpPFTPublic)
        {
            //
            // Delete the public font table.
            //

            bResult = bCleanupFontTable(&gpPFTPublic);
        }

        // Hydra
        // saw the case where gpPFTDevice was not intialized on Hydra system

        if (gpPFTDevice)
        {
            //
            // Delete the device font table.
            //

            bResult = bCleanupFontTable(&gpPFTDevice);
        }

        // Clean up the gpPrintKViewList

        if (gpPrintKViewList)
        {
            vCleanupPrintKViewList();
        }
    }

    // Clean up FD_GLYPHSET for VTFD and BMFD.
    // Here is the cheapest way to do some garbage collection.

    GreAcquireSemaphore(ghsemVTFD);
    if (gpcpVTFD)
    {
        CP_GLYPHSET *pcpNext, *pcpCurrent;

        pcpCurrent = gpcpVTFD;

        while(pcpCurrent)
        {
            pcpNext = pcpCurrent->pcpNext;
            VFREEMEM(pcpCurrent);
            pcpCurrent =  pcpNext;
        }

        gpcpVTFD = NULL;
    }
    GreReleaseSemaphore(ghsemVTFD);

    GreAcquireSemaphore(ghsemBMFD);
    if (gpcpGlyphsets)
    {
        CP_GLYPHSET *pcpNext, *pcpCurrent;

        pcpCurrent = gpcpGlyphsets;

        while(pcpCurrent)
        {
            pcpNext = pcpCurrent->pcpNext;
            VFREEMEM(pcpCurrent);
            pcpCurrent =  pcpNext;
        }

        gpcpGlyphsets = NULL;
    }
    GreReleaseSemaphore(ghsemBMFD);
    //GreReleaseSemaphore(ghsemPublicPFT);

}

/******************************Public*Routine******************************\
* MultiUserGreCleanupDrivers
*
* Cleanup the ppdev and lpdev driver lists.
*
* History:
*  07-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreCleanupDrivers()
{
    //
    // Note: since this should only be called during win32k shutdown,
    // don't bother with grabbing the semaphore.
    //

    //GreAcquireSemaphore(ghsemDriverMgmt);

    //
    // Remove all PDEVs from the global list.
    //

    volatile PDEV *ppdevCur;

    while (ppdevCur = gppdevList)
    {
        //
        // Force reference count to 1, so PDEV will be deleted.
        //

        ppdevCur->cPdevRefs     = 1;
        ppdevCur->cPdevOpenRefs = 1;

        //
        // Unload the pdev (PDEVOBJ::vUnreferencePdev will update gppdevList).
        //

        PDEVOBJ pdo((HDEV) ppdevCur);
        ASSERTGDI(pdo.bValid(), "MultiUserGreCleanupDrivers: invalid pdev\n");
        pdo.vUnreferencePdev(CLEANUP_SESSION);
    }

    //
    // Cleanup direct draw driver before force unload.
    //

    DxDdCleanupDxGraphics();

    //
    // Remove all LDEVs from the global list.
    //

    volatile PLDEV pldevCur;

    while (pldevCur = gpldevDrivers)
    {
        //
        // Force reference count to 1, so LDEV will be deleted.
        //

        pldevCur->cldevRefs = 1;
        ldevUnloadImage(pldevCur);
    }

    //GreReleaseSemaphore(ghsemDriverMgmt);
}

/******************************Public*Routine******************************\
* MultiUserGreDeleteXLATE
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Delete the XLATE cache.
*
* History:
*  09-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreDeleteXLATE()
{
    ULONG ulEntry;

    for (ulEntry = 0; ulEntry < XLATE_CACHE_SIZE; ulEntry++)
    {
        if (xlateTable[ulEntry].pxlate)
            VFREEMEM(xlateTable[ulEntry].pxlate);
    }
}

VOID
GreFreeSemaphoresForCurrentThread(
    VOID
    )

{
    //
    // Walk the list of tracked semaphores, and release any held by this
    // thread.
    //

    if (MultiUserEngAllocListLock) {

        GreAcquireSemaphore(MultiUserEngAllocListLock);

        PENGTRACKHDR EngTrackHdr;

        EngTrackHdr = (PENGTRACKHDR) MultiUserGreEngAllocList.Flink;

        while (EngTrackHdr->list.Flink != &MultiUserGreEngAllocList) {

            if (EngTrackHdr->ulType == ENGTRACK_DRIVER_SEMAPHORE) {

                HSEMAPHORE hsem = (HSEMAPHORE)(EngTrackHdr + 1);

                if (GreIsSemaphoreOwnedByCurrentThread(hsem)) {

                    //
                    // The current thread was holding a semaphore.  Release
                    // it using the same technique the driver would have used.
                    //

                    EngReleaseSemaphore(hsem);
                }
            }

            EngTrackHdr = (PENGTRACKHDR)EngTrackHdr->list.Flink;
        }

        GreReleaseSemaphore(MultiUserEngAllocListLock);
    }
}

#if DBG
/******************************Public*Routine******************************\
* MultiUserGreHmgDbgScan
*
* Dumps the current handle manager contents.
*
* History:
*  07-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
MultiUserGreHmgDbgScan(BOOL bDumpTable, BOOL bCheckEmpty)
{
    PENTRYOBJ  pentTmp;
    UINT uiIndex = 1;       // 1 is the first valid index
    UINT cObj = 0;
    BOOL bTitle = FALSE;

    ASSERTGDI((gpentHmgr != NULL),
              "gpentHmgr MUST be != NULL");

    for (uiIndex = 1; uiIndex < gcMaxHmgr; uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if ((pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
        {
            cObj++;
        }
    }

    if (bCheckEmpty && cObj)
    {
        DbgPrint("\n"
                 "*****************************************\n");
        DbgPrint("  MultiUserGreHmgDbgScan\n\n");
        DbgPrint("       TERMSRV session id = 0x%08lx\n", gSessionId);
        DbgPrint("      Cleanup process pid = 0x%08lx\n", W32GetCurrentPID());
        DbgPrint("\n"
                 "*****************************************\n");
    }

    //
    // Scan through the entire handle manager table and set owner for
    // all valid objects.
    //

    for (uiIndex = 1; uiIndex < gcMaxHmgr && (bDumpTable && cObj != 0); uiIndex++)
    {
        pentTmp = (PENTRYOBJ) &gpentHmgr[uiIndex];

        if ((pentTmp->Objt > DEF_TYPE) && (pentTmp->Objt <= MAX_TYPE))
        {
            //
            // Since this is shutdown, don't bother with lock counts and
            // such.
            //

            if (!bTitle)
            {
                DbgPrint("------------------\t------ ------ ----\n");
                DbgPrint(                "%s\tpid    count  lock\n", gpszHmgrType[0]);
                DbgPrint("------------------\t------ ------ ----\n");
                bTitle = TRUE;
            }

            DbgPrint("%s\t0x%04x 0x%04x %ld\n",
                     gpszHmgrType[pentTmp->Objt],
                     OBJECTOWNER_PID(pentTmp->ObjectOwner),
                     pentTmp->einfo.pobj->ulShareCount,
                     pentTmp->ObjectOwner.Share.Lock
                     );

        }
    }

    if (bTitle )
    {
        DbgPrint("------------------\t------ ------ ----\n");
    }

    if (bCheckEmpty && (cObj != 0))
    {
        DbgPrint("MultiUserGreHmgDbgScan: %ld objects in hmgr table\n", cObj);
        RIP("MultiUserGreHmgDbgScan: object leak detected\n");
    }
}

/*****************************************************************************
 *
 *  DebugGreTrackAddMapView
 *
 *   Track GRE's Map View's for cleanup purposes
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
DebugGreTrackAddMapView(
    PVOID ViewBase
    )
{
    PLIST_ENTRY Entry;
    PVOID Atom;

    if(DebugGreMapViewListLock) GreAcquireSemaphore(DebugGreMapViewListLock);

    Atom = (PVOID) PALLOCNOZ(sizeof(PVOID)+sizeof(LIST_ENTRY), 'mesG');

    if (Atom)
    {
        *(PVOID *)Atom = ViewBase;

        Entry = (PLIST_ENTRY)(((PCHAR)Atom) + sizeof(PVOID));

        InsertTailList(&DebugGreMapViewList, Entry);
    }

    if(DebugGreMapViewListLock) GreReleaseSemaphore(DebugGreMapViewListLock);

    return;
}

/*****************************************************************************
 *
 *  DebugGreTrackRemoveMapView
 *
 *   Remove the GRE Map View from the list
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
DebugGreTrackRemoveMapView(
    PVOID ViewBase
    )
{
    #if !defined(_GDIPLUS_)

    PLIST_ENTRY NextEntry;
    PVOID Atom;

    if(DebugGreMapViewListLock) GreAcquireSemaphore(DebugGreMapViewListLock);

    NextEntry = DebugGreMapViewList.Flink;

    while (NextEntry != &DebugGreMapViewList)
    {
        Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

        if (ViewBase == *(PVOID *)Atom)
        {
            RemoveEntryList(NextEntry);

            VFREEMEM(Atom);

            break;
        }

        NextEntry = NextEntry->Flink;
    }

    if(DebugGreMapViewListLock) GreReleaseSemaphore(DebugGreMapViewListLock);

    return;

    #endif // !_GDIPLUS_
}

/*****************************************************************************
 *
 *  DebugGreCleanupMapView
 *
 *   Cleanup the tracked Map View's
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

VOID
DebugGreCleanupMapView()
{
    volatile PLIST_ENTRY NextEntry;
    PVOID ViewBase;
    PVOID Atom;

    if(DebugGreMapViewListLock)
    {
        if (!IsListEmpty(&DebugGreMapViewList))
        {
            DbgPrint("DebugGreCleanupMapView: DebugGreMapViewList 0x%08lx not empty\n", &DebugGreMapViewList);
            RIP("DebugGreCleanupMapView: leak detected\n");
        }

        //
        // Cleanup every mapped view tracked in the list.
        //

        NextEntry = DebugGreMapViewList.Flink;

        while (NextEntry != &DebugGreMapViewList)
        {
            // We can not use CONTAINING_RECORD since we are
            // not within a single C structure.

            RemoveEntryList(NextEntry);

            Atom = (PVOID)(((PCHAR)NextEntry) - sizeof(PVOID));

            ViewBase = *(PVOID *)Atom;

            DbgPrint("DebugGreCleanupMapView: cleanup Map View %x\n", ViewBase);

            MmUnmapViewInSessionSpace(ViewBase);

            GdiFreePool(Atom);

            // Restart at the begining of the list since our
            // entry got deleted
            NextEntry = DebugGreMapViewList.Flink;
        }

    }
    //
    // Free the list semaphore.
    //

    GreDeleteSemaphoreNonTracked(DebugGreMapViewListLock);
        DebugGreMapViewListLock = NULL;

    return;
}
#endif

/******************************Public*Routine******************************\
* GdiMultiUserFontCleanup
*
*   Deletes all the fonts from the system font tables.
*
*   This is only called by user when CSRSS goes away on a Hydra terminal.
*
*
* History:
*  29-Sept-1998 -by- Xudong Wu [tessiew]
* Wrote it.
\**************************************************************************/
VOID
GdiMultiUserFontCleanup()
{
	if(!gpPFTPublic)
		return;
		
#ifdef FE_SB
    CleanUpEUDC();
#endif

    //
    // Cleanup the rest of the font stuff (font tables, font hash tables,
    // font files, font substitution table, font mapper).
    //

    MultiUserGreCleanupAllFonts();

    vCleanUpFntCache();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\paintddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: paintddi.cxx
*
* Paint callbacks
*
* Created: 05-Mar-1992 18:30:39
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngPaint
*
* Paint the clipping region with the specified brush
*
* History:
*  05-Mar-1992 -by- Donald Sidoroff [donalds]
* add accelerators for common mix modes.
*
*  Sat 07-Sep-1991 -by- Patrick Haluptzok [patrickh]
* add translate of mix to rop
*
*  01-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngPaint(
SURFOBJ  *pso,
CLIPOBJ  *pco,
BRUSHOBJ *pdbrush,
POINTL   *pptlBrush,
MIX       mix)
{
    GDIFunctionID(EngPaint);

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    ASSERTGDI(pso != (SURFOBJ *) NULL, "NULL SURFOBJ\n");
    ASSERTGDI(pco != (CLIPOBJ *) NULL, "NULL CLIPOBJ\n");
    ASSERTGDI(pco->iMode == TC_RECTANGLES,"iMode not rects\n");
    ASSERTGDI(mix & 0xff00, "Background mix uninitialized");

    ROP4 rop4 = gaMix[(mix >> 8) & 0x0F];
    rop4 = rop4 << 8;
    rop4 = rop4 | ((ULONG) gaMix[mix & 0x0F]);

    return(pSurf->pfnBitBlt())(
                (SURFOBJ *) pso,
                (SURFOBJ *) NULL,
                (SURFOBJ *) NULL,
                pco,
                NULL,
                (RECTL *) &(((ECLIPOBJ *) pco)->erclExclude()),
                (POINTL *)  NULL,
                (POINTL *)  NULL,
                pdbrush,
                pptlBrush,
                rop4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\os.cxx ===
/******************************Module*Header*******************************\
* Module Name: os.cxx                                                      *
*                                                                          *
* Convenient functions to access the OS interface.                         *
*                                                                          *
* Created: 29-Aug-1989 19:59:05                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1989-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.hxx"
#include "muclean.hxx"
#include "winstaw.h"

extern BOOL G_fConsole;
extern PFILE_OBJECT G_RemoteVideoFileObject;
extern "C" USHORT gProtocolType;

/******************************Public*Routine******************************\
* EngGetProcessHandle
*
* Returns the current thread of the application.
*
* History:
*  24-Jan-1996 -by- Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HANDLE APIENTRY EngGetProcessHandle()
{
    return (HANDLE) NULL;
}

/******************************Public*Routine******************************\
* EngGetCurrentProcessId
*
* Returns the current process id of the application.
*
* History:
*  28-May-1999 -by- Barton House [bhouse]
* Wrote it.
\**************************************************************************/

HANDLE APIENTRY EngGetCurrentProcessId()
{
    return PsGetCurrentProcessId();
}

/******************************Public*Routine******************************\
* EngGetCurrentThreadId
*
* Returns the current thread id of the application.
*
* History:
*  28-May-1999 -by- Barton House [bhouse]
* Wrote it.
\**************************************************************************/

HANDLE APIENTRY EngGetCurrentThreadId()
{
    return PsGetCurrentThreadId();
}

#if !defined(_GDIPLUS_)
// Kernel-mode version

    /******************************Public*Routine******************************\
    * GreCreateSemaphore
    *
    * Create a semaphore with tracking.
    *
    * For use by GDI internal code. Tracking
    * allows semaphores to be released during MultiUserNtGreCleanup (Hydra)
    * cleanup.
    *
    * Warning! For code dealing with pool/semaphore tracking, as
    *   in pooltrk.cxx and muclean.cxx, do not create semaphores with
    *   this function, as it may call functions which use those semaphores. Instead,
    *   use GreCreateSemaphoreNonTracked and GreDeleteSemaphoreNonTracked.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    * History:
    *
    *    25-May-1995 - Changed to PERESOURCE
    *    19-May-1998 - Changed to HSEMAPHORE.
    *                  Merged AcquireGreResource with hsemCreateTracked
    *                  to create this function.
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphore()
    {
        return GreCreateSemaphoreInternal(OBJ_ENGINE_CREATED);
    }

    HSEMAPHORE
    GreCreateSemaphoreInternal(ULONG CreateFlag)
    {
        PERESOURCE pres;
        ULONGSIZE_T cj = sizeof(ERESOURCE);

        //
        // Adjust size to include ENGTRACKHDR header.
        //

        cj += sizeof(ENGTRACKHDR);

        //
        // Allocate ERESOURCE (must be nonpaged pool).
        //

        pres = (PERESOURCE) GdiAllocPoolNonPagedNS(cj, 'mesG');

        if (pres)
        {
            //
            // Adjust resource to exclude the ENGTRACKHDR.
            //
            //                 Buffer
            //   pethNew --> +----------------+
            //               | ENGTRACKHDR    |
            //      pres --> +----------------+
            //               | ERESOURCE      |
            //               |                |
            //               +----------------+
            //
            // Note that pethNew always points to base of allocation.
            //

            ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pres;

            pres = (PERESOURCE) (pethNew + 1);

            //
            // Initialize the resource.
            //

            if (NT_SUCCESS(ExInitializeResourceLite(pres)))
            {
                //
                // Track the resource.
                //

                if (CreateFlag & OBJ_DRIVER_CREATED) {
                    MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_DRIVER_SEMAPHORE);
                } else {
                    MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_SEMAPHORE);
                }
            }
            else
            {
                GdiFreePool(pethNew);
                pres = NULL;
            }
        }
        return (HSEMAPHORE) pres;
    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphore
    *
    * Deletes the given semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphore(
        HSEMAPHORE hsem
        )
    {
        PERESOURCE pres = (PERESOURCE) hsem;
        if (pres)
        {
            ENGTRACKHDR *pethVictim = (ENGTRACKHDR *) pres;

            //
            // Need to adjust peth pointer to header.
            //
            // Note: whether Hydra or non-Hydra, pethVictim will always
            // point to the base of the allocation.
            //

            //
            // Remove victim from tracking list.
            //

            pethVictim -= 1;
            MultiUserGreTrackRemoveEngResource(pethVictim);
    
            ASSERTGDI(pres->OwnerThreads[0].OwnerThread
                != (ERESOURCE_THREAD) PsGetCurrentThread(),
                "The resource is being deleted while it's still held!");

            ExDeleteResourceLite(pres);
            GdiFreePool(pethVictim);
        }
    }

    /******************************Public*Routine******************************\
    * GreCreateSemaphoreNonTracked
    *
    * Create a semaphore, without pool-tracking or semaphore-tracking.
    *
    * Only for use by the pool-tracking and semaphore-tracking code. This
    * avoids the circular dependency which using GreCreateSemaphore would
    * cause.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphoreNonTracked()
    {
        PERESOURCE pres;

        pres = (PERESOURCE) ExAllocatePoolWithTag(
                   (POOL_TYPE)NonPagedPool,
                   sizeof(ERESOURCE), 'mesG');

        if (pres)
        {
            if (!NT_SUCCESS(ExInitializeResourceLite(pres)))
            {
                ExFreePool(pres);
                pres = NULL;
            }
        }

        return (HSEMAPHORE) pres;
    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphoreNonTracked
    *
    * Deletes the given non-tracked semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphoreNonTracked(
        HSEMAPHORE hsem
        )
    {
        PERESOURCE pres = (PERESOURCE) hsem;

        if (pres)
        {

            ASSERTGDI(pres->OwnerThreads[0].OwnerThread
                != (ERESOURCE_THREAD) PsGetCurrentThread(),
                "The resource is being deleted while it's still held!");

            ExDeleteResourceLite(pres);
            ExFreePool(pres);
        }
    }

#ifdef VALIDATE_LOCKS

    BOOL gDebugSem = TRUE;
    BOOL gDebugSemBreak = FALSE;

#define SEM_HISTORY_LENGTH  4

    typedef struct {
        const char *name;
        const char *func;
        const char *file;
        int         line;
    } SemHistory;

    typedef struct SemEntry {
        HSEMAPHORE  hsem;
        ULONG       count;
        ULONG       order;
        HSEMAPHORE  parent;
#if SEM_HISTORY_LENGTH
        SemHistory  Acquired[SEM_HISTORY_LENGTH];
#endif
    } SemEntry;

#define kMaxSemEntries  64

    typedef struct SemTable {
        FLONG       flags;
        ULONG       numEntries;
        SemEntry    entries[kMaxSemEntries];
    } SemTable;


    /******************************Public*Routine******************************\
    * SemTrace::SemTrace                                                       *
    \**************************************************************************/

    SemTrace::SemTrace(FLONG SetFlags)
    {
        DontClearMask = ~0;

        if (gDebugSem && gDebugSemBreak)
        {
            pThread = W32GetCurrentThread();

            if(pThread != NULL)
            {
                SemTable *pSemTable = (SemTable *) pThread->pSemTable;

                if(pSemTable != NULL)
                {
                    DontClearMask = pSemTable->flags | ~SetFlags;

                    if (DontClearMask != ~0)
                    {
                        DbgPrint(" ** Enabling additional sem tracing for W32THREAD @ %p, SemTable @ %p\n", pThread, pSemTable);
                        pSemTable->flags |= SetFlags;
                    }
                }
            }
        }
    }

    /******************************Public*Routine******************************\
    * SemTrace::~SemTrace                                                      *
    \**************************************************************************/

    SemTrace::~SemTrace()
    {
        // Have anything to clear?
        if (DontClearMask != ~0)
        {
            SemTable *pSemTable = (SemTable *)pThread->pSemTable;

            if (pSemTable)
            {
                DbgPrint(" ** Disabling additional sem tracing for W32THREAD @ %p, SemTable @ %p\n", pThread, pSemTable);
                pSemTable->flags &= DontClearMask;
            }
            else
            {
                DbgPrint(" ** Couldn't disable added sem tracing for W32THREAD @ %p; SemTable is NULL\n", pThread);
            }
        }
    }


    /*****************************Private*Routine******************************\
    * FindSemEntry                                                             *
    \**************************************************************************/

    SemEntry * FindSemEntry(SemTable * pTable, HSEMAPHORE hsem)
    {
        SemEntry *  entry = pTable->entries;
        SemEntry *  sentry = entry + pTable->numEntries;

        while(entry < sentry)
        {
            if(entry->hsem == hsem)
                return entry;
            entry++;
        }

        return NULL;

    }


    /*****************************Private*Routine******************************\
    * RemoveSemEntry                                                           *
    \**************************************************************************/

    void
    RemoveSemEntry(
        SemTable   *pTable,
        SemEntry   *entry,
        const char *name,
        const char *func,
        const char *file,
        int         line
        )
    {
        SemEntry   *sentry;
        SemEntry    OldEntry;

        ASSERTGDI(pTable->numEntries > 0, "numEntries is invalid");
        ASSERTGDI(entry < pTable->entries + pTable->numEntries, "entry is invalid");

        OldEntry = *entry;

        pTable->numEntries--;

        sentry = &pTable->entries[pTable->numEntries];

        if (entry != sentry)
        {
            DbgPrint("Locks released out of acquisition order\n");
            DbgPrint("  Now releasing order %4d %s (%X) in %s @ %s:%d\n",
                     entry->order, name, entry->hsem, func, file, line);

            while (entry < sentry)
            {
                *entry = *(entry + 1);
#if SEM_HISTORY_LENGTH
                DbgPrint("  Warning: Still holding order %4d %s (%X) %u times\n"
                         "   First acquired in %s @ %s:%d\n",
                         entry->order,
                         entry->Acquired[0].name,
                         entry->hsem,
                         entry->count,
                         entry->Acquired[0].func,
                         entry->Acquired[0].file,
                         entry->Acquired[0].line
                         );
#else
                DbgPrint("  Warning: Still holding order %4d %s (%X) %u times\n",
                         entry->order, entry->hsem, entry->count
                         );

#endif
                if (OldEntry.hsem == entry->parent)
                {
                    DbgPrint("   * Error: Releasing parent before child.\n");
                }
                else if (OldEntry.parent == entry->parent && OldEntry.order < entry->order)
                {
                    DbgPrint("   * Error: Higher order semaphore is still held.\n");
                }
                entry++;
            }

            if (gDebugSemBreak)
            {
                DbgBreakPoint();
            }
        }

        if (pTable->flags & ST_SAVE_RELEASES)
        {
            // Maintain a history of released locks
            // 
            sentry = &pTable->entries[kMaxSemEntries-1];

            while(entry < sentry)
            {
                *entry = *(entry + 1);
                entry++;
            }

            *sentry = OldEntry;
        }
    }


    /******************************Public*Routine******************************\
    * GreReleaseSemaphoreAndValidate                                           *
    *                                                                          *
    *  Call via GreAcquireSemaphoreEx with VALIDATE_LOCKS enabled.             *
    \**************************************************************************/

    VOID 
    GreAcquireSemaphoreAndValidate(
        HSEMAPHORE  hsem,
        ULONG       order,
        HSEMAPHORE  parent,
        const char *name,
        const char *func,
        const char *file,
        int         line
        ) 
    {
        GDIFunctionID(GreAcquireSemaphoreAndValidate);

        GreAcquireSemaphore(hsem);
    
        if(gDebugSem)
        {
            PW32THREAD pThread = W32GetCurrentThread();

            if(pThread != NULL)
            {
                SemTable *pSemTable = (SemTable *) pThread->pSemTable;
        
                if(pSemTable == NULL)
                {
                    pThread->pSemTable = PALLOCMEM(sizeof(SemTable), 'dtdG');

                    pSemTable = (SemTable *) pThread->pSemTable;

                    if(pSemTable != NULL)
                    {
                        pThread->pSemTable = (PVOID)pSemTable;
                        pSemTable->flags = ST_DEFAULT;
                        pSemTable->numEntries = 0;
                    }
                }
        
                if(pSemTable != NULL)
                {
                    SemEntry *pSemEntry = FindSemEntry(pSemTable, hsem);
        
                    if(pSemEntry != NULL)
                    {
                        if (pSemTable->flags & ST_VERBOSE)
                        {
                            DbgPrint("SemTrace: Reacquire (%d) order %4d %24s (%X) in %s @ %s:%d\n",
                                     pSemEntry->count, order, name, hsem, func, file, line);
                        }

                        if (order != pSemEntry->order)
                        {
                            DbgPrint("* Different order specification (%d) for %24s (%X) in %s @ %s:%d\n"
                                     "  Originally acquired with order %d as %s in %s @ %s:%d (%d acquisitions)\n",
                                     order, name, hsem, func, file, line,
                                     pSemEntry->order,
                                     pSemEntry->Acquired[0].name,
                                     pSemEntry->Acquired[0].func,
                                     pSemEntry->Acquired[0].file,
                                     pSemEntry->Acquired[0].line,
                                     pSemEntry->count
                                     );
                        }

#if SEM_HISTORY_LENGTH > 1
                        if (pSemEntry->count < SEM_HISTORY_LENGTH)
                        {
                            pSemEntry->Acquired[pSemEntry->count].name = name;
                            pSemEntry->Acquired[pSemEntry->count].func = func;
                            pSemEntry->Acquired[pSemEntry->count].file = file;
                            pSemEntry->Acquired[pSemEntry->count].line = line;
                        }
#endif
                        pSemEntry->count++;
                    }
                    else
                    {
                        if (pSemTable->flags & ST_VERBOSE)
                        {
                            DbgPrint("SemTrace: Now acquiring order %4d %24s (%X) in %s @ %s:%d\n",
                                     order, name, hsem, func, file, line);
                        }

                        ASSERTGDI(pSemTable->numEntries < kMaxSemEntries, "too many entries");
        
                        pSemEntry = &pSemTable->entries[pSemTable->numEntries++];
                        pSemEntry->hsem = hsem;
                        pSemEntry->order = order;
                        pSemEntry->parent = parent;
                        pSemEntry->count = 1;
#if SEM_HISTORY_LENGTH
                        pSemEntry->Acquired[0].name = name;
                        pSemEntry->Acquired[0].func = func;
                        pSemEntry->Acquired[0].file = file;
                        pSemEntry->Acquired[0].line = line;
#endif
        
                        // Check order

                        if(parent != NULL)
                        {
                            if(FindSemEntry(pSemTable, parent) == NULL)
                            {
                                DbgPrint("Parent semaphore not acquired");
                                if (gDebugSemBreak)
                                {
                                    DbgBreakPoint();
                                }
                            }
                        }

                        SemEntry *  entry = pSemTable->entries;
                        SemEntry *  sentry = entry + pSemTable->numEntries;

                        BOOL    Misordered = FALSE;

                        while(entry < sentry)
                        {
                            if(entry->parent == parent && entry->order > order)
                            {
                                if (!Misordered)
                                {
                                    DbgPrint("Locks obtained out of order\n");
                                    if (!(pSemTable->flags & ST_VERBOSE))
                                    {
                                        DbgPrint("  Now acqquiring order %4d %24s (%X) in %s @ %s:%d\n",
                                                 order, name, hsem, func, file, line);
                                    }
                                    Misordered = TRUE;
                                }
#if SEM_HISTORY_LENGTH
                                DbgPrint("  Conflicts with order %4d %24s (%X) first acquired in %s @ %s:%d with %d acquisitions\n",
                                         entry->order,
                                         entry->Acquired[0].name,
                                         entry->hsem,
                                         entry->Acquired[0].func,
                                         entry->Acquired[0].file,
                                         entry->Acquired[0].line,
                                         entry->count
                                         );
#else
                                DbgPrint("  Conflicts with order %4d (%X)\n",
                                         entry->order, entry->hsem
                                         );
#endif
                            }
                            entry++;
                        }

                        if (Misordered && gDebugSemBreak)
                        {
                            DbgBreakPoint();
                        }
                    }
                }
            }
        }
    }


    /******************************Public*Routine******************************\
    * GreReleaseSemaphoreAndValidate                                           *
    *                                                                          *
    *  Call via GreReleaseSemaphoreEx with VALIDATE_LOCKS enabled.             *
    \**************************************************************************/

    VOID
    GreReleaseSemaphoreAndValidate(
        HSEMAPHORE hsem,
        const char *name,
        const char *func,
        const char *file,
        int         line
        )
    {
        GDIFunctionID(GreReleaseSemaphoreAndValidate);

        if(gDebugSem)
        {
            PW32THREAD pThread = W32GetCurrentThread();

            if(pThread != NULL)
            {
                SemTable * pSemTable = (SemTable *) pThread->pSemTable;

                if(pSemTable != NULL)
                {
                    SemEntry * pSemEntry = FindSemEntry(pSemTable, hsem);

                    ASSERTGDI(pSemEntry != NULL, "error finding sem");

                    if(pSemEntry != NULL)
                    {
                        pSemEntry->count--;

                        if (pSemTable->flags & ST_VERBOSE)
                        {
                            if (pSemEntry->count)
                            {
                                DbgPrint("TraceSem: Releasing (%d) order %4d %24s (%X) in %s @ %s:%d\n",
                                         pSemEntry->count, pSemEntry->order, name, hsem, func, file, line);
                            }
                            else
                            {
                                DbgPrint("TraceSem: Fully release order %4d %24s (%X) in %s @ %s:%d\n",
                                         pSemEntry->order, name, hsem, func, file, line);
                            }
                        }

#if SEM_HISTORY_LENGTH > 1
                        if (pSemTable->flags & ST_SAVE_RELEASES)
                        {
                            // Maintain a history of releases
                            //
                            SemHistory *entry = &pSemEntry->Acquired[pSemEntry->count];
                            SemHistory *sentry = &pSemEntry->Acquired[SEM_HISTORY_LENGTH-1];

                            SemHistory  OldAcquisition = *entry;

                            while(entry < sentry)
                            {
                                *entry = *(entry + 1);
                                entry++;
                            }

                            *sentry = OldAcquisition;
                        }
#endif

                        if(pSemEntry->count == 0)
                        {
                            RemoveSemEntry(pSemTable, pSemEntry, name, func, file, line);
                        }
                    }
                }
            }
        }

        GreReleaseSemaphore(hsem);
    }
#endif

    
    /******************************Public*Routine******************************\
    * GreAcquireSemaphore                                                      *
    \**************************************************************************/

    VOID 
    FASTCALL GreAcquireSemaphore(
        HSEMAPHORE hsem
        )
    {
        //
        // This if is here for cleanup code
        // Generic cleanup code needs to
        // acquire the semaphore, but in some cases
        // the semaphore either hasn't been created or it
        // has been thrown away already.
        //
        if (hsem)
        {
            KeEnterCriticalRegion();
            ExAcquireResourceExclusiveLite((PERESOURCE) hsem, TRUE);
        }
        else
        {
#if DBG
            if (G_fConsole)
            {
                RIP("Tried to acquire a non-existant or deleted semaphore\n");
            }
            else
            {
                WARNING("Tried to acquire a non-existant or deleted semaphore\n");
            }
#endif
        }
    }


    /******************************Public*Routine******************************\
    * GreAcquireSemaphoreShared                                                *
    \**************************************************************************/

    VOID
    FASTCALL GreAcquireSemaphoreShared(
        HSEMAPHORE hsem
        )
    {
        //
        // This if is here for cleanup code
        // Generic cleanup code needs to
        // acquire the semaphore, but in some cases
        // the semaphore either hasn't been created or it
        // has been thrown away already.
        //
        if (hsem)
        {
            KeEnterCriticalRegion();
            ExAcquireResourceSharedLite((PERESOURCE) hsem, TRUE);
        }
        else
        {
#if DBG
            if (G_fConsole)
            {
                RIP("Tried to acquire a non-existant or deleted semaphore\n");
            }
            else
            {
                WARNING("Tried to acquire a non-existant or deleted semaphore\n");
            }
#endif
        }
    }


    /******************************Public*Routine******************************\
    * GreReleaseSemaphore                                                      *
    \**************************************************************************/
    VOID
    FASTCALL GreReleaseSemaphore(
        HSEMAPHORE hsem
        )
    {
        //
        // This if is here for cleanup code
        // Generic cleanup code needs to
        // acquire the semaphore, but in some cases
        // the semaphore either hasn't been created or it
        // has been thrown away already.
        //
        if (hsem)
        {
            ExReleaseResourceLite((PERESOURCE) hsem);
            KeLeaveCriticalRegion();
        }
        else
        {
#if DBG
            if (G_fConsole)
            {
                RIP("Tried to release a non-existant or deleted semaphore\n");
            }
            else
            {
                WARNING("Tried to release a non-existant or deleted semaphore\n");
            }
#endif
        }
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwned                                                      *
    *                                                                          *
    * Returns TRUE if the semaphore is currently held.                         *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwned(
        HSEMAPHORE hsem
        )
    {
        return ((PERESOURCE) hsem)->ActiveCount != 0;
    }


    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwnedByCurrentThread                                       *
    *                                                                          *
    * Returns TRUE if the current thread owns the semaphore, FALSE             *
    * otherwise.                                                               *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwnedByCurrentThread(
        HSEMAPHORE hsem
        )
    {
        return ((PERESOURCE) hsem)->OwnerThreads[0].OwnerThread ==
               (ERESOURCE_THREAD) PsGetCurrentThread();
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreSharedByCurrentThread                                      *
    *                                                                          *
    * Returns TRUE if the current thread owns the semaphore, FALSE             *
    * otherwise.                                                               *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreSharedByCurrentThread(
        HSEMAPHORE hsem
        )
    {
        return ExIsResourceAcquiredSharedLite((PERESOURCE) hsem);
    }

    /******************************Public*Routine******************************\
    * GreCreateFastMutex                                                       *
    *                                                                          *
    * Creates a fast mutex. Exactly like a semaphore, except it is not         *
    * reentrant. Fast mutexes are not tracked either (since they do not need   *
    * to be destroyed by the kernel.) Their pool may be tracked.               *
    *                                                                          *
    \**************************************************************************/
    HFASTMUTEX
    GreCreateFastMutex()
    {
        PFAST_MUTEX pfm;
        pfm = (PFAST_MUTEX) GdiAllocPoolNonPagedNS(sizeof(FAST_MUTEX),
                                                    'msfG');

        if (pfm)
                        {
            ExInitializeFastMutex(pfm);
        }

        return (HFASTMUTEX) pfm;
    }

    /******************************Public*Routine******************************\
    * GreDeleteFastMutex                                                       *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreDeleteFastMutex(
        HFASTMUTEX hfm
        )
    {
        if (hfm) {
            GdiFreePool(hfm);
        }
    }

    /******************************Public*Routine******************************\
    * GreAcquireFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreAcquireFastMutex(
        HFASTMUTEX hfm
        )
    {
        KeEnterCriticalRegion();
        ExAcquireFastMutex((PFAST_MUTEX) hfm);
    }

    /******************************Public*Routine******************************\
    * GreReleaseFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/

    VOID
    GreReleaseFastMutex(
        HFASTMUTEX hfm
        )
    {
        ExReleaseFastMutex((PFAST_MUTEX) hfm);
        KeLeaveCriticalRegion();
    }

#else // _GDIPLUS_
// User-mode version

    /******************************Public*Routine******************************\
    * GreCreateSemaphore
    *
    * Create a semaphore with tracking.
    *
    * For use by GDI internal code. Tracking
    * allows semaphores to be released during MultiUserNtGreCleanup
    * cleanup.
    *
    * Warning! For code dealing with pool/semaphore tracking, as
    *   in pooltrk.cxx and muclean.cxx, do not create semaphores with
    *   this function, as it may call functions which use those semaphores. Instead,
    *   use GreCreateSemaphoreNonTracked and GreDeleteSemaphoreNonTracked.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphore()
    {
        return GreCreateSemaphoreInternal(OBJ_ENGINE_CREATED);
    }

    HSEMAPHORE
    GreCreateSemaphoreInternal(ULONG CreateFlag)
    {
        LPCRITICAL_SECTION pcs;
        SIZE_T cj = sizeof(CRITICAL_SECTION);

        //
        // Adjust size to include ENGTRACKHDR header.
        //
>>  
        cj += sizeof(ENGTRACKHDR);
    
        pcs = (LPCRITICAL_SECTION) RtlAllocateHeap(RtlProcessHeap(), 
                                                   0, 
==                                                 sizeof(CRITICAL_SECTION));

        if (pcs)
        {
            //
            // Adjust semaphore to exclude the ENGTRACKHDR.
            //
            //                 Buffer
            //   pethNew --> +------------------+
            //               | ENGTRACKHDR      |
            //       pcs --> +------------------+
            //               | CRITICAL_SECTION |
            //               |                  |
            //               +------------------+
            //
            // Note that pethNew always points to base of allocation.
            //

            ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pcs;
>>  
            pcs = (LPCRITICAL_SECTION) (pethNew + 1);
    
==          //
            // Initialize the semaphore.
            //

            InitializeCriticalSection(pcs);

            //
            // Track the semaphore
            //
>>
            if (CreateFlag & OBJ_DRIVER_CREATED) {
                MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_DRIVER_SEMAPHORE);
            } else {
                MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_SEMAPHORE);
            }
==      }

        return (HSEMAPHORE) pcs;

    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphore
    *
    * Deletes the given semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphore(
        HSEMAPHORE hsem
        )
    {
        LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hsem;

        if (pcs)
        {
            ENGTRACKHDR *pethVictim = (ENGTRACKHDR *) pcs;

            //
            // Need to adjust peth pointer to header.
            //
            // Note: whether Hydra or non-Hydra, pethVictim will always
            // point to the base of the allocation.
            //
>>  
            //
            // Remove victim from tracking list.
            //
    
            pethVictim -= 1;
            MultiUserGreTrackRemoveEngResource(pethVictim);

==          DeleteCriticalSection(pcs);
            RtlFreeHeap(RtlProcessHeap(), 0, pethVictim);
        }
    }

    /******************************Public*Routine******************************\
    * GreCreateSemaphoreNonTracked
    *
    * Create a semaphore, without pool-tracking or semaphore-tracking.
    *
    * Only for use by the pool-tracking and semaphore-tracking code. This
    * avoids the circular dependency which using GreCreateSemaphore would
    * cause.
    *
    * Return Value:
    *
    *   Handle for new semaphore or NULL
    *
    \**************************************************************************/

    HSEMAPHORE
    GreCreateSemaphoreNonTracked()
    {
        LPCRITICAL_SECTION pcs;

        pcs = (LPCRITICAL_SECTION) RtlAllocateHeap(RtlProcessHeap(),
                                                   0,
                                                   sizeof(CRITICAL_SECTION));

        if (pcs)
        {
            //
            // Initialize the semaphore.
            //

            InitializeCriticalSection(pcs);
        }

        return (HSEMAPHORE) pcs;
    }

    /******************************Public*Routine******************************\
    * GreDeleteSemaphoreNonTracked
    *
    * Deletes the given non-tracked semaphore.
    *
    \**************************************************************************/

    VOID
    GreDeleteSemaphoreNonTracked(
        HSEMAPHORE hsem
        )
    {
        LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hsem;

        if (pcs)
        {
            DeleteCriticalSection(pcs);
            RtlFreeHeap(RtlProcessHeap(), 0, pcs);
        }
    }

    /******************************Public*Routine******************************\
    * GreAcquireSemaphore                                                      *
    \**************************************************************************/
    VOID
    GreAcquireSemaphore(
        HSEMAPHORE hsem
        )
    {
        EnterCriticalSection((LPCRITICAL_SECTION) hsem);
    }

    /******************************Public*Routine******************************\
    * GreReleaseSemaphore                                                      *
    \**************************************************************************/
    VOID
    GreReleaseSemaphore(
        HSEMAPHORE hsem
        )
    {
        LeaveCriticalSection((LPCRITICAL_SECTION) hsem);
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwned                                                      *
    *                                                                          *
    * Returns TRUE if the semaphore is currently held.                         *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwned(
        HSEMAPHORE hsem
        )
    {
        return ((RTL_CRITICAL_SECTION *) hsem)->LockCount != -1;
    }

    /******************************Public*Routine******************************\
    * GreIsSemaphoreOwnedByCurrentThread                                       *
    *                                                                          *
    * Returns TRUE if the current thread owns the semaphore, FALSE             *
    * otherwise.                                                               *
    *                                                                          *
    \**************************************************************************/
    BOOL
    GreIsSemaphoreOwnedByCurrentThread(
        HSEMAPHORE hsem
        )
    {
        return ((RTL_CRITICAL_SECTION *) hsem)->OwningThread ==
               (HANDLE) GetCurrentThreadId();
    }

    /******************************Public*Routine******************************\
    * GreCreateFastMutex                                                       *
    *                                                                          *
    * Creates a fast mutex. In this, the user mode version, it is exactly      *
    * the same as a non-tracked semaphore.
    *                                                                          *
    \**************************************************************************/
    HFASTMUTEX
    GreCreateFastMutex()
    {
        LPCRITICAL_SECTION pcs;

        pcs = (LPCRITICAL_SECTION) RtlAllocateHeap(RtlProcessHeap(),
                                                   0,
                                                   sizeof(CRITICAL_SECTION));

        if (pcs)
        {
            //
            // Initialize the semaphore.
            //

            InitializeCriticalSection(pcs);
        }

        return (HFASTMUTEX) pcs;
    }

    /******************************Public*Routine******************************\
    * GreDeleteFastMutex                                                       *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreDeleteFastMutex(
        HFASTMUTEX hfm
        )
    {
        LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hfm;

        if (pcs)
        {
            DeleteCriticalSection(pcs);
            RtlFreeHeap(RtlProcessHeap(), 0, pcs);
        }
    }

    /******************************Public*Routine******************************\
    * GreAcquireFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/
    VOID
    GreAcquireFastMutex(
        HFASTMUTEX hfm
        )
    {
        EnterCriticalSection((LPCRITICAL_SECTION) hfm);
    }

    /******************************Public*Routine******************************\
    * GreReleaseFastMutex                                                      *
    *                                                                          *
    \**************************************************************************/

    VOID
    GreReleaseFastMutex(
        HFASTMUTEX hfm
        )
    {
        LeaveCriticalSection((LPCRITICAL_SECTION) hfm);
    }

#endif // _GDIPLUS_

/******************************Public*Routines*****************************\
* GreAcquireHmgrSemaphore                                                  *
* GreReleaseHmgrSemaphore                                                  *
*                                                                          *
* Convenience functions for the handle manager semaphore.                  *
*                                                                          *
\**************************************************************************/
VOID
GreAcquireHmgrSemaphore()
{
    GDIFunctionID(GreAcquireHmgrSemaphore);

    GreAcquireSemaphoreEx(ghsemHmgr, SEMORDER_HMGR, NULL);
}

VOID
GreReleaseHmgrSemaphore()
{
    GDIFunctionID(GreReleaseHmgrSemaphore);

    GreReleaseSemaphoreEx(ghsemHmgr);
}

/******************************Public*Routine******************************\
* EngCreateSemaphore()
*
* History:
*  22-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HSEMAPHORE
EngCreateSemaphore(
    VOID
    )
{
    return GreCreateSemaphoreInternal(OBJ_DRIVER_CREATED);
}

VOID
EngAcquireSemaphore(
    HSEMAPHORE hsem
    )
{
    GreAcquireSemaphore(hsem);

    W32THREAD * pThread = W32GetCurrentThread();

#ifdef CHECK_SEMAPHORE_USAGE
    pThread->dwEngAcquireCount++;
#endif
}


VOID
EngReleaseSemaphore(
    HSEMAPHORE hsem
    )
{
    W32THREAD * pThread = W32GetCurrentThread();

#ifdef CHECK_SEMAPHORE_USAGE
    pThread->dwEngAcquireCount--;
#endif
    
    GreReleaseSemaphore(hsem);
}

#ifdef CHECK_SEMAPHORE_USAGE
VOID
GreCheckSemaphoreUsage(
    VOID
    )
{
    W32THREAD * pThread = W32GetCurrentThread();

    ASSERTGDI(pThread->dwEngAcquireCount == 0, "EngAcquireCount non-zero\n");
}
#endif

VOID
EngDeleteSemaphore(
    HSEMAPHORE hsem
    )
{
    GreDeleteSemaphore(hsem);
}

BOOL
EngIsSemaphoreOwned(
    HSEMAPHORE hsem
    )
{
    return(GreIsSemaphoreOwned(hsem));
}

BOOL
EngIsSemaphoreOwnedByCurrentThread(
    HSEMAPHORE hsem
    )
{
    return(GreIsSemaphoreOwnedByCurrentThread(hsem));
}

/******************************Public*Routine******************************\
*
* EngInitializeSafeSemaphore
* EngDeleteSafeSemaphore
*
* Manages semaphore lifetime in a reference-counted thread-safe manner.
*
* History:
*  Wed Apr 16 18:23:40 1997     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL
EngInitializeSafeSemaphore(ENGSAFESEMAPHORE *pssem)
{
    // Do create/destroy inside the handle manager global lock
    // as a convenient way to synchronize them.
    MLOCKFAST mlf;

    ASSERTGDI(pssem->lCount >= 0, "InitSafeSem: bad lCount\n");

    if (pssem->lCount == 0)
    {
        ASSERTGDI(pssem->hsem == NULL, "InitSafeSem: overwriting hsem\n");

        pssem->hsem = GreCreateSemaphoreInternal(OBJ_DRIVER_CREATED);
        if (pssem->hsem == NULL)
        {
            return FALSE;
        }
    }

    pssem->lCount++;

    return TRUE;
}

void
EngDeleteSafeSemaphore(ENGSAFESEMAPHORE *pssem)
{
    // Do create/destroy inside the handle manager global lock
    // as a convenient way to synchronize them.
    MLOCKFAST mlf;

    ASSERTGDI(pssem->lCount >= 1, "DeleteSafeSem: lCount underflow\n");

    if (pssem->lCount == 1)
    {
        ASSERTGDI(pssem->hsem != NULL, "DeleteSafeSem: No hsem\n");

        GreDeleteSemaphore(pssem->hsem);
        pssem->hsem = NULL;
    }

    pssem->lCount--;
}

/******************************Public*Routine******************************\
* EngSetLastError
*
* Saves Error code passed in.
*
* History:
*  Sat 31-Oct-1992 -by- Patrick Haluptzok [patrickh]
* Remove wrapper.
*
*  28-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID  EngSetLastError(ULONG iError)
{
    //
    // Warning: NtCurrentTeb() accesses the TEB structure via the
    // KPCR structure. However, during session shutdown, the
    // TEB ptr is set to zero in the TCB, but not the KPCR.  So if
    // code is callable during session shutdown, cannot invoke
    // NtCurrentTeb.  Use KeGetCurrentThread()->Teb instead.
    //

    PTEB pteb = (PTEB) PsGetCurrentThreadTeb();

    if (pteb)
        pteb->LastErrorValue = iError;

#if DBG
    PSZ psz;

    switch (iError)
    {
    case ERROR_INVALID_HANDLE:
        psz = "ERROR_INVALID_HANDLE";
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        psz = "ERROR_NOT_ENOUGH_MEMORY";
        break;

    case ERROR_INVALID_PARAMETER:
        psz = "ERROR_INVALID_PARAMETER";
        break;

    case ERROR_BUSY:
        psz = "ERROR_BUSY";
        break;

    case ERROR_ARITHMETIC_OVERFLOW:
        psz = "ERROR_ARITHMETIC_OVERFLOW";
        break;

    case ERROR_INVALID_FLAGS:
        psz = "ERROR_INVALID_FLAGS";
        break;

    case ERROR_CAN_NOT_COMPLETE:
        psz = "ERROR_CAN_NOT_COMPLETE";
        break;

    default:
        psz = "unknown error code";
        break;
    }

    // DbgPrint("GRE Err: %s = 0x%04X\n", psz, (USHORT) iError);
#endif
}

/******************************Public*Routine******************************\
*
* History:
*  27-Jun-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG APIENTRY EngGetLastError()
{
    ULONG ulError = 0;

    //
    // Warning: NtCurrentTeb() accesses the TEB structure via the
    // KPCR structure. However, during session shutdown, the
    // TEB ptr is set to zero in the TCB, but not the KPCR.  So if
    // code is callable during session shutdown, cannot invoke
    // NtCurrentTeb.  Use KeGetCurrentThread()->Teb instead.
    //

    PTEB pteb = (PTEB) PsGetCurrentThreadTeb();

    if (pteb)
        ulError = pteb->LastErrorValue;

    return(ulError);
}

/******************************Public*Routine******************************\
* GreLockDisplay()
*
* History:
*  01-Nov-1994 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
GreLockDisplay(
    HDEV hdev
    )
{
    GDIFunctionID(GreLockDisplay);

    PDEVOBJ pdo(hdev);

    GreAcquireSemaphoreEx(pdo.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
    GreEnterMonitoredSection(pdo.ppdev, WD_DEVLOCK);
}

/******************************Public*Routine******************************\
* GreUnlockDisplay()
*
* History:
*  01-Nov-1994 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
GreUnlockDisplay(
    HDEV hdev
    )
{
    GDIFunctionID(GreUnlockDisplay);

    PDEVOBJ pdo(hdev);

    GreExitMonitoredSection(pdo.ppdev, WD_DEVLOCK);
    GreReleaseSemaphoreEx(pdo.hsemDevLock());
}

#if DBG
/******************************Public*Routine******************************\
* GreIsDisplayLocked()
*
* History:
*  10-Jun-1998 -by-  Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
GreIsDisplayLocked(
    HDEV hdev
    )
{
    PDEVOBJ pdo(hdev);
    if (GreIsSemaphoreOwnedByCurrentThread(pdo.hsemDevLock()))
    {
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }

}
#endif


/***************************************************************************\
* EngDebugPrint
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\***************************************************************************/

VOID
EngDebugPrint(
    PCHAR StandardPrefix,
    PCHAR DebugMessage,
    va_list ap
    )
{
    char buffer[256];
    int  len;

    //
    // We prepend the STANDARD_DEBUG_PREFIX to each string, and
    // append a new-line character to the end:
    //

    DbgPrint(StandardPrefix);

    vsprintf(buffer, DebugMessage, ap);
    DbgPrint(buffer);

}


/******************************Public*Routine******************************\
* EngDebugBreak()
*
* History:
*  16-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngDebugBreak(
    VOID
    )
{
    DbgBreakPoint();
}


/******************************Public*Routine******************************\
* EngDebugBreak()
*
* History:
*  7-Dec-2001 -by-  Jonathan Schwartz [JSchwart]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR P1,
    IN ULONG_PTR P2,
    IN ULONG_PTR P3,
    IN ULONG_PTR P4
    )
{
    KeBugCheckEx(BugCheckCode, P1, P2, P3, P4);
}


/******************************Public*Routine******************************\
* EngAllocMem()
*
* History:
*  27-May-1995 -by-  Tom Zakrajsek [tomzak]
* Added a flags parameter to allow zeroing of memory.
*
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

PVOID
EngAllocMem(
    ULONG fl,
    ULONG cj,
    ULONG tag
    )
{
    PVOID pvRet;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return(NULL);

    //
    // Adjust size to include ENGTRACKHDR header.
    //
    // Sundown note: sizeof(ENGTRACKHDR) will fit in 32-bit, so ULONG cast OK
    //

    if (cj <= (MAXULONG - sizeof(ENGTRACKHDR)))
        cj += ((ULONG) sizeof(ENGTRACKHDR));
    else
        return(NULL);

    if (cj >= (PAGE_SIZE * 10000))
    {
        WARNING("EngAllocMem: temp buffer >= 10000 pages");
        return(NULL);
    }

    if (fl & FL_NONPAGED_MEMORY)
    {
        pvRet = GdiAllocPoolNonPaged(cj,tag);
    }
    else
    {
        pvRet = GdiAllocPool(cj,tag); 
    }

    if (fl & FL_ZERO_MEMORY) 
    {
        if (pvRet)
        {
            RtlZeroMemory(pvRet,cj);
        }
    }

    if (pvRet)
    {
        //
        // Add allocation to the tracking list.
        //

        ENGTRACKHDR *pethNew = (ENGTRACKHDR *) pvRet;
        MultiUserGreTrackAddEngResource(pethNew, ENGTRACK_ALLOCMEM);

        //
        // Adjust return pointer to hide the LIST_ENTRY header.
        //

        pvRet = (PVOID) (pethNew + 1);
    }

    return pvRet;
}


/******************************Public*Routine******************************\
* EngFreeMem()
*
* History:
*  02-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
EngFreeMem(
    PVOID pv
    )
{
    if (pv)
    {
        //
        // Remove victim from tracking list.
        //

        ENGTRACKHDR *pethVictim = ((ENGTRACKHDR *) pv) - 1;
        MultiUserGreTrackRemoveEngResource(pethVictim);

        //
        // Adjust pointer to base of allocation.
        //

        pv = (PVOID) pethVictim;

        VFREEMEM(pv);
    }

    return;
}

/******************************Public*Routine******************************\
* EngProbeForRead()
*
* History:
*  02-Oct-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

VOID
EngProbeForRead(
    PVOID Address,
    ULONG Length,
    ULONG Alignment
    )
{
    ProbeForRead(Address, Length, Alignment);
}

/******************************Public*Routine******************************\
* GDIEngUserMemAllocNodeCompare()
*
* History:
*  18-Sep-2001 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/
RTL_GENERIC_COMPARE_RESULTS
GDIEngUserMemAllocNodeCompare(RTL_AVL_TABLE *Table,
                              PVOID FirstStruct,
                              PVOID SecondStruct)
{
    PGDIENGUSERMEMALLOCNODE p1 = (PGDIENGUSERMEMALLOCNODE)FirstStruct;
    PGDIENGUSERMEMALLOCNODE p2 = (PGDIENGUSERMEMALLOCNODE)SecondStruct;

    return (p1->pUserMem > p2->pUserMem ) ? GenericGreaterThan : (p1->pUserMem < p2->pUserMem ) ? GenericLessThan : GenericEqual;
}

/******************************Public*Routine******************************\
* GDIEngUserMemAllocNodeAlloc()
*
* History:
*  18-Sep-2001 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/
PVOID
GDIEngUserMemAllocNodeAlloc(RTL_AVL_TABLE *Table,
                            CLONG Size)
{
    return PALLOCNOZ(Size,'amUG');
}

/******************************Public*Routine******************************\
* GDIEngUserMemAllocNodeFree()
*
* History:
*  18-Sep-2001 -by-  Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/
VOID
GDIEngUserMemAllocNodeFree(RTL_AVL_TABLE *Table,
                           PVOID Buffer)
{
    VFREEMEM(Buffer);
}
/******************************Public*Routine******************************\
* EngAllocUserMem()
*
*   This routine allocates a piece of memory for USER mode and locks it
*   down.  A driver must be very careful with this memory as it is only
*   valid for this process.
*
* History:
*  10-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

PVOID
EngAllocUserMem(
    SIZE_T cj,  //ZwAllocateVirtualMemory uses SIZE_T, change accordingly
    ULONG tag
    )
{
    NTSTATUS status;
    PVOID    pv = NULL;
    HANDLE   hSecure;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return(NULL);

    status = ZwAllocateVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    0,
                    &cj,
                    MEM_COMMIT | MEM_RESERVE,
                    PAGE_READWRITE);

    if (NT_SUCCESS(status))
    {
        hSecure = MmSecureVirtualMemory(pv,cj,PAGE_READWRITE);

        if (hSecure)
        {
            // Add the new allocation to the Process's GDIEngUserMemAllocTable

            PW32PROCESS pW32Process = W32GetCurrentProcess();

            GDIENGUSERMEMALLOCNODE tmpNode;
            PGDIENGUSERMEMALLOCNODE pNewNode = 0;

            BOOLEAN bNew = FALSE;

            tmpNode.pUserMem = pv;
            tmpNode.hSecure = hSecure;
            tmpNode.cj = cj;

            SIMPLELOCK sl(&pW32Process->GDIEngUserMemAllocTableLock);

            pNewNode = (PGDIENGUSERMEMALLOCNODE)
                RtlInsertElementGenericTableAvl(&pW32Process->GDIEngUserMemAllocTable,
                                                &tmpNode,
                                                sizeof(tmpNode),
                                                &bNew);

            ASSERTGDI((pNewNode && !bNew) != TRUE, "EngAllocUserMem: (pNewNode && !bNew) == TRUE\n");

            if (pNewNode == 0 || bNew == FALSE)
            {
                MmUnsecureVirtualMemory(hSecure);
                ZwFreeVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    &cj,
                    MEM_RELEASE);
                pv = NULL;
            }
        }
        else
        {
            ZwFreeVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    &cj,
                    MEM_RELEASE);
            pv = NULL;
        }
    }

    return(pv);
}

/******************************Public*Routize******************************\
* EngSecureMem()
*
* History:
*  02-Oct-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
EngSecureMem(
    PVOID Address,
    ULONG Length
    )
{
    return (MmSecureVirtualMemory(Address, Length, PAGE_READWRITE));
}

/******************************Public*Routine******************************\
* EngUnsecureMem()
*
* History:
*  02-Oct-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*
* Note:  Forwarder only - no code needed
\**************************************************************************/

/******************************Public*Routine******************************\
* EngFreeUserMem()
*
* History:
*  10-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID
EngFreeUserMem(
    PVOID pv
    )
{
    if (pv)
    {
        // Lookup the allocation in the Process's GDIEngUserMemAllocTable

        PW32PROCESS pW32Process = W32GetCurrentProcess();

        GDIENGUSERMEMALLOCNODE lookupNode;
        PGDIENGUSERMEMALLOCNODE pFoundNode;

        lookupNode.pUserMem = pv;

        SIMPLELOCK sl(&pW32Process->GDIEngUserMemAllocTableLock);

        pFoundNode = (PGDIENGUSERMEMALLOCNODE)
           RtlLookupElementGenericTableAvl(&pW32Process->GDIEngUserMemAllocTable,
                                           &lookupNode);

        // If found, Unsecure it, free it and remove entry from
        // GDIEngUserMemAllocTable

        if (pFoundNode)
        {
            ULONG_PTR cj   = (ULONG_PTR) pFoundNode->cj;
            HANDLE hSecure = pFoundNode->hSecure;

            MmUnsecureVirtualMemory(hSecure);

            ZwFreeVirtualMemory(
                    NtCurrentProcess(),
                    &pv,
                    &cj,
                    MEM_RELEASE);

            lookupNode.pUserMem = pv;
            RtlDeleteElementGenericTableAvl(&pW32Process->GDIEngUserMemAllocTable,
                                            &lookupNode);
        }
    }

    return;
}

/******************************Public*Routine******************************\
* EngDeviceIoControl()
*
* History:
*  04-Feb-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

NTSTATUS
GreDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    )

{

    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    IO_STATUS_BLOCK Iosb;
    PIRP pIrp;
    KEVENT event;


    if (hDevice == NULL) {
        return STATUS_INVALID_HANDLE;
    }

    if ( (nInBufferSize >= (PAGE_SIZE * 10000) ) ||
         (nOutBufferSize >= (PAGE_SIZE * 10000)) ||
         ((nInBufferSize + nOutBufferSize) >= (PAGE_SIZE * 10000))) {
        WARNING("EngDeviceIoControl is asked to allocate >= 10000 pages");
        return (STATUS_INVALID_PARAMETER);
    }

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
               dwIoControlCode,
               (PDEVICE_OBJECT) hDevice,
               lpInBuffer,
               nInBufferSize,
               lpOutBuffer,
               nOutBufferSize,
               FALSE,
               &event,
               &Iosb);

    if (pIrp)
    {
        /*
        * Even though the remote video channel emulates a video port, this
        * code doesn't actually use a HANDLE it just uses a DEVICE_OBJECT.
        * Unfortueately, there's only one of those for the remote video driver
        * and so it's not Multi-Session enabled.  Remember the file
        * object handle and stuff it in the call here.  (This code could
        * be called from any process, but globals are in Session space.)
        */
            PIO_STACK_LOCATION irpSp;

        if ( gProtocolType != PROTOCOL_CONSOLE ) {
            irpSp = IoGetNextIrpStackLocation( pIrp );
            irpSp->FileObject = G_RemoteVideoFileObject;
        }
        
        Status = IoCallDriver((PDEVICE_OBJECT) hDevice,
                              pIrp);

        //
        // If the call is synchronous, the IO is always completed
        // and the Status is the same as the Iosb.Status.
        //

        if (Status == STATUS_PENDING) {

            Status = KeWaitForSingleObject(&event,
                                           UserRequest,
                                           KernelMode,
                                           TRUE,
                                           NULL);

            Status = Iosb.Status;
        }

        *lpBytesReturned = (DWORD)Iosb.Information;
    }

    return (Status);

}


DWORD
EngDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    )

{
    DWORD retStatus;
    NTSTATUS Status = GreDeviceIoControl(hDevice,
                                         dwIoControlCode,
                                         lpInBuffer,
                                         nInBufferSize,
                                         lpOutBuffer,
                                         nOutBufferSize,
                                         lpBytesReturned);

    //
    // Do the inverse translation to what the video port does
    // so that we can have the original win32 status codes.
    //
    // Maybe, somehow, we can completely eliminate this double
    // translation - but I don't care for now.  It's just a bit
    // longer on the very odd failiure case
    //

    switch (Status) {

    case STATUS_SUCCESS:
        retStatus = NO_ERROR;
        break;

    case STATUS_NOT_IMPLEMENTED:
        retStatus = ERROR_INVALID_FUNCTION;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        retStatus = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case STATUS_INVALID_PARAMETER:
        retStatus = ERROR_INVALID_PARAMETER;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        retStatus = ERROR_INSUFFICIENT_BUFFER;
        break;

    case STATUS_BUFFER_OVERFLOW:
        retStatus = ERROR_MORE_DATA;
        break;

    case STATUS_PENDING:
        retStatus = ERROR_IO_PENDING;
        break;

    case STATUS_DEVICE_DOES_NOT_EXIST:
        retStatus = ERROR_DEV_NOT_EXIST;
        break;

    default:
        retStatus = Status;
        break;

    }


    return retStatus;
}

VOID
EngMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    )

{

    RtlMultiByteToUnicodeN(UnicodeString,
                           MaxBytesInUnicodeString,
                           BytesInUnicodeString,
                           MultiByteString,
                           BytesInMultiByteString);
}

VOID
EngUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )
{
    RtlUnicodeToMultiByteN( MultiByteString,
                            MaxBytesInMultiByteString,
                            BytesInMultiByteString,
                            UnicodeString,
                            BytesInUnicodeString );
}




/******************************Public*Routine******************************\
* EngQueryPerformanceCounter
*
* Queries the performance counter.
*
* It would have been preferable to use 'KeQueryTickCount,' but has a
* resolution of about 10ms on an x86, which is not sufficient for
* getting an accurate measure of the time between vertical blanks, which
* is typically between 8ms and 17ms.
*
* NOTE: Use this routine sparingly, calling it as infrequently as possible!
*       Calling this routine too frequently can degrade I/O performance
*       for the calling driver and for the system as a whole.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngQueryPerformanceCounter(
    LONGLONG    *pPerformanceCount
    )
{
    LARGE_INTEGER li;

    li = KeQueryPerformanceCounter(NULL);

    *pPerformanceCount = *((LONGLONG*) &li);
}

/******************************Public*Routine******************************\
* EngQueryPerformanceFrequency
*
* Queries the resolution of the performance counter.
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
EngQueryPerformanceFrequency(
    LONGLONG    *pFrequency
    )
{
    KeQueryPerformanceCounter((LARGE_INTEGER*) pFrequency);
}


/******************************Public*Routine******************************\
* EngAllocSectionMem
*
* Allocate mapped memory in session space.
*
* History:
*  23-Oct-2000 -by- Chenyin Zhong [chenyz]
* Wrote it.
\**************************************************************************/

PVOID
EngAllocSectionMem(
    PVOID   *pSectionObject,
    ULONG   fl,
    ULONG   cj,
    ULONG   tag
    )
{
    LARGE_INTEGER   SectionSize;
    PVOID           pMappedBase;
    NTSTATUS        Status;
    HANDLE          hSecure;
    SIZE_T          MemSize = 0;

    //
    // Don't trust the driver to only ask for non-zero length buffers.
    //

    if (cj == 0)
        return(NULL);

    SectionSize.LowPart  = cj;
    SectionSize.HighPart = 0;

    Status = Win32CreateSection(
                pSectionObject,
                SECTION_ALL_ACCESS,
                (POBJECT_ATTRIBUTES)NULL,
                &SectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                (HANDLE)NULL,
                NULL,
                tag);

    if (!NT_SUCCESS(Status)) 
    {
        KdPrint(("MmCreateSection fails in EngAllocSectionMem with error code: 0x%x\n", Status));
        return(NULL);
    }
    cj = 0;
    
    pMappedBase = NULL;
    Status = Win32MapViewInSessionSpace(*pSectionObject, &pMappedBase, &MemSize);

    if (!NT_SUCCESS(Status)) 
    {
        KdPrint(("MmMapViewInSessionSpace fails in EngAllocSectionMem with error code: 0x%x\n", Status));

        Win32DestroySection(*pSectionObject);
        pMappedBase = NULL;
        *pSectionObject = NULL;
    }

    cj = (ULONG)MemSize;

    if (fl & FL_ZERO_MEMORY)
    {
        if (pMappedBase)
        {
            RtlZeroMemory(pMappedBase,cj);
        }
    }

    return pMappedBase;
}        


/******************************Public*Routine******************************\
* EngFreeSectionMem()
*
* History:
*  25-Oct-2000 -by-  Chenyin Zhong [chenyz]
* Wrote it.
*  24-Jul-2002 -by-  Ivan Leichtling [ivanlei]
* Added return value
\**************************************************************************/

BOOL
EngFreeSectionMem(
    PVOID SectionObject,
    PVOID pv   
    )
{
    NTSTATUS Status;
    BOOL     bRet = TRUE;

    if(pv)
    {
        Status = Win32UnmapViewInSessionSpace(pv);
        if (!NT_SUCCESS(Status)) 
        {
            KdPrint(("MmUnmapViewInSessionSpace fails in EngFreeSectionMem with error code: 0x%x\n", Status));
            RIP("MmUnmapViewInSessionSpace failed!");
            bRet = FALSE;
        }
    }
        
    if(SectionObject)    
    {
        Win32DestroySection(SectionObject);
    }
   
    return bRet;
}          


/******************************Public*Routine******************************\
* EngMapSection()
*
* History:
*  25-Oct-2000 -by-  Chenyin Zhong [chenyz]
* Wrote it.
\**************************************************************************/


BOOL
EngMapSection(
    PVOID SectionObject,
    BOOL bMap,
    HANDLE ProcessHandle,
    PVOID *pMapBase
    )
{
    NTSTATUS        Status;
    PEPROCESS       Process;
    LARGE_INTEGER   SectionOffset;
    ULONG           AllocationType = 0L;
    SIZE_T          ViewSize = 0;

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;

    Status = ObReferenceObjectByHandle(ProcessHandle,
                                       PROCESS_VM_OPERATION,
                                       NULL,
                                       KernelMode,
                                       (PVOID *)&Process,
                                       NULL);
    if(!NT_SUCCESS(Status)) 
    {
        return FALSE;
    }


    if(bMap)    //Map section memory
    {   
        *pMapBase = NULL;
        Status = MmMapViewOfSection(SectionObject,              // SectionToMap,
                                    Process,                    // process
                                    pMapBase,                   // CapturedBase,
                                    0L,                         // ZeroBits,
                                    0L,                         // CommitSize,
                                    &SectionOffset,             // SectionOffset,
                                    &ViewSize,                  // CapturedViewSize,
                                    ViewShare,                  // InheritDisposition,
                                    AllocationType,             // AllocationType,
                                    PAGE_READWRITE);            // Allow writing on this view

        if(!NT_SUCCESS(Status))
        {
            ObDereferenceObject(Process);
            *pMapBase = NULL;

            KdPrint(("MmMapViewofSection fails in EngMapSection with error code: %u\n", Status));
            return FALSE;
        }
    }
    else        //Unmap section memory
    {
        Status = MmUnmapViewOfSection (Process, *pMapBase);

        if (!NT_SUCCESS(Status)) 
        {
            ObDereferenceObject(Process);
            return FALSE;
        }
    }

    ObDereferenceObject (Process);
    
    return TRUE;
}         



/******************************Public*Routine******************************\
* EngSave/RestoreFloatingPointState
*
* Saves the floating point state so that drivers can do floating point
* operations.  If the state were no preserved and floating point operations
* were used, we would be corrupting the thread's user-mode state!
*
* History:
*  17-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

typedef struct {
    BOOL            bSaved;
    KFLOATING_SAVE  fsFpState;
} FP_STATE_SAVE;

ULONG
APIENTRY
EngSaveFloatingPointState(
    VOID    *pBuffer,
    ULONG    cjBufferSize       // Must be zero initialized
    )
{
    ULONG           ulRet = 0;
    FP_STATE_SAVE*  pFpStateSave;
    KFLOATING_SAVE  fsTestState;

    pFpStateSave = (FP_STATE_SAVE*) pBuffer;

    if ((pFpStateSave == NULL) || (cjBufferSize == 0))
    {
        // Check to see if the processor supports floating point by
        // simply seeing whether or not KeSaveFloatingPointState
        // succeeds:

        if (!NT_SUCCESS(KeSaveFloatingPointState(&fsTestState)))
        {
            // No floating point hardware.

            return(ulRet);
        }

        KeRestoreFloatingPointState(&fsTestState);
        return(sizeof(FP_STATE_SAVE));
    }

    if (cjBufferSize < sizeof(FP_STATE_SAVE))
    {
        KdPrint(("EngSaveFloatingPointState: The driver's buffer is too small.\n"));
        KdPrint(("Floating point corruption in the application may result."));
        RIP("The driver must be fixed!");
        return(ulRet);
    }

    if (pFpStateSave->bSaved)
    {
        KdPrint(("EngSaveFloatingPointState: Your driver called save twice in a row.\n"));
        KdPrint(("(Either that or it didn't zero initialize the buffer.)\n"));
        KdPrint(("Floating point corruption in the application may result."));
        RIP("The driver must be fixed!");

        // No point in returning failure because at this point they're just
        // plain hosed if they called Save twice in succession.  If however
        // they simply did not zero initialize the buffer, things would still
        // be okay, because KeSaveFloatingPointState itself doesn't need the
        // buffer to be zero initialized.
    }

    ulRet = NT_SUCCESS(KeSaveFloatingPointState(&pFpStateSave->fsFpState));

    pFpStateSave->bSaved = (ulRet != 0);

    return(ulRet);
}

BOOL
APIENTRY
EngRestoreFloatingPointState(
    VOID    *pBuffer
    )
{
    FP_STATE_SAVE*  pFpStateSave;

    pFpStateSave = (FP_STATE_SAVE*) pBuffer;

    if (!pFpStateSave->bSaved)
    {
        KdPrint(("EngRestoreFloatingPointState: Your driver called restore "
                 "twice in a row or called restore without a preceeding "
                 "successful call to save.\n"));
        KdPrint(("Floating point corruption in the application may result."));
        RIP("The driver must be fixed!");
        return(FALSE);
    }

    pFpStateSave->bSaved = FALSE;

    return(NT_SUCCESS(KeRestoreFloatingPointState(&pFpStateSave->fsFpState)));
}

/******************************Public*Routine******************************\
*
* EngQuerySystemAttribute
*
* Can be used by a driver to query certain processor or system specific
* capabilities.
*
\**************************************************************************/

BOOL
EngQuerySystemAttribute(
    ENG_SYSTEM_ATTRIBUTE CapNum,
    PDWORD pCapability)
{
    switch (CapNum) {

    case EngProcessorFeature: {

        SYSTEM_PROCESSOR_INFORMATION spi;

        if (NT_SUCCESS(ZwQuerySystemInformation(
                           SystemProcessorInformation,
                           &spi,
                           sizeof(SYSTEM_PROCESSOR_INFORMATION),
                           NULL))) {

            *pCapability = spi.ProcessorFeatureBits;
            return TRUE;
        }

        break;
    }

    case EngNumberOfProcessors: {

        SYSTEM_BASIC_INFORMATION sbi;

        if (NT_SUCCESS(ZwQuerySystemInformation(
                           SystemBasicInformation,
                           &sbi,
                           sizeof(SYSTEM_BASIC_INFORMATION),
                           NULL))) {

            *pCapability = sbi.NumberOfProcessors;
            return TRUE;
        }

        break;
    }

    case EngOptimumAvailableUserMemory:
    case EngOptimumAvailableSystemMemory:

        break;

    default:

        break;
    }

    return FALSE;
}

#if defined(_GDIPLUS_)

VOID
GreQuerySystemTime(
    PLARGE_INTEGER CurrentTime
    )
{
    GetSystemTimeAsFileTime((PFILETIME) CurrentTime);
}

VOID
GreSystemTimeToLocalTime (
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER LocalTime
    )
{
    FileTimeToLocalFileTime((PFILETIME) SystemTime, (PFILETIME) LocalTime);
}

#else // !_GDIPLUS_

VOID
GreQuerySystemTime(
    PLARGE_INTEGER CurrentTime
    )
{
    KeQuerySystemTime(CurrentTime);
}

VOID
GreSystemTimeToLocalTime (
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER LocalTime
    )
{
    ExSystemTimeToLocalTime (SystemTime, LocalTime);
}

#endif // _GDIPLUS_

#ifdef DDI_WATCHDOG

/******************************Public*Routine******************************\
*
* GreCreateWatchdogs
*
* Creates an array of WATCHDOG_DATA objects pool, and creates and
* initializes associated DPC and DEFERRED_WATCHDOG objects.
*
* Return Value:
*
*   A pointer the new array or NULL
*
* Note:
*
*   dpcCallback must be in non-pagable, non-session kernel memory.
*   DPC objects must be in non-paged, non-session kernel memory.
*   Watchdog objects must be in non-paged, non-session kernel memory.
*   Deferred context must be in non-paged, non-session kernel memory. 
*
\**************************************************************************/

PWATCHDOG_DATA
GreCreateWatchdogs(
    PDEVICE_OBJECT pDeviceObject,
    ULONG ulNumberOfWatchdogs,
    LONG lPeriod,
    PKDEFERRED_ROUTINE dpcCallback,
    PWSTR pwszDriverName,
    HANDLE hDriver,
    PLDEV *ppldevDriverList
    )
{
    PWATCHDOG_DATA pWatchdogData;

    if (NULL == pwszDriverName)
    {
        return NULL;
    }

    pWatchdogData = (PWATCHDOG_DATA)GdiAllocPool(ulNumberOfWatchdogs * sizeof (WATCHDOG_DATA), GDITAG_WATCHDOG);

    if (pWatchdogData)
    {
        PWD_GDI_DPC_CONTEXT pvContext;
        SIZE_T stSize;
        ULONG ulLength;
        ULONG i;

        ulLength = wcslen(pwszDriverName);
        stSize = sizeof(WD_GDI_DPC_CONTEXT) + ((ulLength + 1) * sizeof(WCHAR));

        //
        // Zero out in case we won't be able to create all we need and we'll have to back off.
        //

        RtlZeroMemory(pWatchdogData, ulNumberOfWatchdogs * sizeof (WATCHDOG_DATA));

        for (i = 0; i < ulNumberOfWatchdogs; i++)
        {
            //
            // Allocate DPC object from non-paged, non-session pool.
            //

            pWatchdogData[i].pDpc = (PKDPC)GdiAllocPoolNonPagedNS(sizeof (KDPC), GDITAG_WATCHDOG);

            if (NULL == pWatchdogData[i].pDpc)
            {
                //
                // Allocation failed - delete what we created so far and bail out.
                //

                GreDeleteWatchdogs(pWatchdogData, i);
                pWatchdogData = NULL;
                break;
            }

            //
            // Allocate deferred watchdog object.
            //

            pWatchdogData[i].pWatchdog = WdAllocateDeferredWatchdog(pDeviceObject, WdKernelTime, GDITAG_WATCHDOG);

            if (NULL == pWatchdogData[i].pWatchdog)
            {
                //
                // Allocation failed - delete what we created so far and bail out.
                // Note: We have to free last DPC object here.
                //

                GdiFreePool(pWatchdogData[i].pDpc);
                pWatchdogData[i].pDpc = NULL;

                GreDeleteWatchdogs(pWatchdogData, i);
                pWatchdogData = NULL;
                break;
            }

            //
            // Attach and initialize watchdog context.
            //

            pvContext = (PWD_GDI_DPC_CONTEXT)WdAttachContext(pWatchdogData[i].pWatchdog, (ULONG)stSize);

            if (pvContext)
            {
                pvContext->ppldevDrivers = ppldevDriverList;
                pvContext->hDriver = hDriver;

                //
                // Stuff UNICODE_STRING and driver name into the context attached to watchdog object.
                //

                RtlCopyMemory(pvContext+1,
                              pwszDriverName,
                              (ulLength + 1) * sizeof(WCHAR));

                RtlInitUnicodeString(&pvContext->DisplayDriverName,
                                     (PCWSTR)(pvContext+1));
            }
            else
            {
                //
                // Context creation failed - delete what we created so far and bail out.
                //

                GreDeleteWatchdogs(pWatchdogData, i + 1);
                pWatchdogData = NULL;
                break;
            }

            //
            // Initialize DPC object and start deferred watch.
            //

            KeInitializeDpc(pWatchdogData[i].pDpc, dpcCallback, pvContext);
            WdStartDeferredWatch(pWatchdogData[i].pWatchdog, pWatchdogData[i].pDpc, lPeriod);
        }
    }

    return pWatchdogData;
}

/******************************Public*Routine******************************\
*
* GreDeleteWatchdogs
*
* Stops watchdogs and deletes an array of WATCHDOG_DATA objects.
*
\**************************************************************************/

VOID
GreDeleteWatchdogs(
    PWATCHDOG_DATA pWatchdogData,
    ULONG ulNumberOfWatchdogs
    )
{
    if (NULL != pWatchdogData)
    {
        ULONG i;

        for (i = 0; i < ulNumberOfWatchdogs; i++)
        {
            if (NULL != pWatchdogData[i].pWatchdog)
            {
                //
                // Stop and free deferred watchdog.
                //

                WdStopDeferredWatch(pWatchdogData[i].pWatchdog);
                WdFreeDeferredWatchdog(pWatchdogData[i].pWatchdog);
                pWatchdogData[i].pWatchdog = NULL;
            }

            if (NULL != pWatchdogData[i].pDpc)
            {
                //
                // Free pool allocated for DPC object.
                //

                GdiFreePool(pWatchdogData[i].pDpc);
                pWatchdogData[i].pDpc = NULL;
            }
        }

        //
        // Free pool allocated for WatchdogData array.
        //

        GdiFreePool(pWatchdogData);
    }
}

#endif  // DDI_WATCHDOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\multi.cxx ===
/******************************Module*Header*******************************\
* Module Name: multi.cxx
*
* Supports splitting of request over multiple PDEVs
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PPALETTE DrvRealizeHalftonePalette(HDEV hdevPalette, BOOL bForce);

BOOL  gbMultiMonMismatchColor = FALSE;

RECTL grclEmpty;    // Implicitly initialized to (0,0,0,0)

BYTE  gaMixNeedsPattern[] = { 0, 0, 1, 1, 1, 1, 0, 1,
                              1, 1, 1, 0, 1, 1, 1, 1 };

#define ROP4_NEEDS_PATTERN(rop4) ((((rop4) >> 4) ^ (rop4)) & 0x0f0f)
// Work around for bug #362287
// #define MIX_NEEDS_PATTERN(mix)   (gaMixNeedsPattern[mix & 0xf])
#define MIX_NEEDS_PATTERN(mix)   (TRUE)

#define REALIZE_HALFTONE_PALETTE(hdev) (DrvRealizeHalftonePalette((hdev),FALSE))

typedef struct _MULTIFONTINFO
{
    PVDEV pvdev;
    PVOID pv[1];
} MULTIFONTINFO, *PMULTIFONTINFO;

class MULTIFONT {
private:
    FONTOBJ*        pfoOrg;
    PMULTIFONTINFO  pMultiFontInfo;

public:
    MULTIFONT(FONTOBJ *pfo, LONG csurf, PVDEV pvdev)
    {
        /********************************************************************
        *********************************************************************

            MulDestroyFont calls this constructor with csurf of -1 and a
            pvdev of NULL if and only if pfo->pvConsumer != NULL.  It needs to
            call the pvdev() method.  csurf and pvdev are ONLY referenced if
            pfo->pvConsumer == NULL.

            *** KEEP IT THAT WAY***

        *********************************************************************
        ********************************************************************/

        pfoOrg = pfo;

        if (pfoOrg)
        {
            if (pfoOrg->pvConsumer == NULL)
            {
                pfoOrg->pvConsumer = (PVOID)EngAllocMem(FL_ZERO_MEMORY,
                                      (sizeof(MULTIFONTINFO) + ((csurf-1) *
                                       sizeof(PVOID))), 'lumG');
                pMultiFontInfo = (PMULTIFONTINFO)pfoOrg->pvConsumer;
                if (pMultiFontInfo)
                {
                    pMultiFontInfo->pvdev = pvdev;
                }
                else
                {
                    KdPrint(("MULTIFONT::MULTIFONT failed table allocation\n"));
                }
            }
            else
            {
                pMultiFontInfo = (PMULTIFONTINFO)pfoOrg->pvConsumer;
            }
        }
    }

   ~MULTIFONT()
    {
        if (pfoOrg)
        {
            pfoOrg->pvConsumer = pMultiFontInfo;
        }
    }

    BOOL Valid()
    {
        return (pMultiFontInfo ? TRUE : FALSE);
    }

    VOID DestroyTable()
    {
        if (pfoOrg && (pMultiFontInfo != NULL))
        {
            EngFreeMem(pMultiFontInfo);
            pMultiFontInfo = NULL;
        }
    }

    VOID LoadElement(LONG i)
    {
        if (pfoOrg)
        {
            pfoOrg->pvConsumer = pMultiFontInfo->pv[i];
        }
    }

    VOID StoreElement(LONG i)
    {
        if (pfoOrg)
        {
            pMultiFontInfo->pv[i] = pfoOrg->pvConsumer;
        }
    }

    PVDEV pvdev()
    {
        return pMultiFontInfo->pvdev;
    }
};

typedef struct _MULTIREALIZEDBRUSH
{
    PVOID pvD;
    PVOID pvE;
} MULTIREALIZEDBRUSH;

typedef struct _MULTIBRUSHINFO
{
    ULONG              cSurfaces;
    MULTIREALIZEDBRUSH aBrush[1];
} MULTIBRUSHINFO, *PMULTIBRUSHINFO;

class MULTIBRUSH {
private:
    BOOL            bValid;
    EBRUSHOBJ*      pboOrg;
    SURFACE*        psurfOrg;
    XEPALOBJ        palSurfOrg;
    PMULTIBRUSHINFO pMultiBrushInfo;
    ULONG           iSolidColorOrg;
    PENGBRUSH       pengbrushOrg;

public:
    MULTIBRUSH(BRUSHOBJ *pbo,
               LONG      csurf,
               PVDEV     pvdev,
               SURFOBJ  *pso,
               BOOL      bPatternNeeded)
    {
        bValid = TRUE;

        // This function is monstrous and should probably be moved out of
        // line.  But beware that 'bPatternNeeded' is often passed in as
        // a constant 'FALSE', meaning that for those case this currently
        // expands to nothing.

        pboOrg = (EBRUSHOBJ*) pbo;

        // pso might be NULL, so we make sure to check psurfOrg
        // whenever we use it.

        psurfOrg = SURFOBJ_TO_SURFACE(pso);

        // Invalidate other fields.

        pMultiBrushInfo = NULL;
        iSolidColorOrg  = 0xffffffff;
        pengbrushOrg    = (PENGBRUSH)-1;

        if (pboOrg)
        {
            // Early out for solid brush.

            if ((!bPatternNeeded) || (pboOrg->iSolidColor != 0xffffffff))
            {
                // Keep original color index for iSolidColor.

                iSolidColorOrg = pboOrg->iSolidColor;

                return;
            }

            // Save the original palette for the surface (since we will switch the surface)

            palSurfOrg   = pboOrg->palSurf();

            if (pboOrg->pvRbrush == NULL)
            {
                LONG cj = (sizeof(MULTIBRUSHINFO) + ((csurf-1) * sizeof(MULTIREALIZEDBRUSH)));

                pboOrg->pvRbrush = BRUSHOBJ_pvGetRbrush(pboOrg);

                // It is possible that BRUSHOBJ_pvGetRbrush will fail because
                // the hatch type of the brush is NULL.  In this case we have
                // pMultiBrushInfo == NULL even though there is a brush.  This will
                // be ok because the pvRbrush will not be accessed for such a
                // brush.

                pMultiBrushInfo = (PMULTIBRUSHINFO)pboOrg->pvRbrush;

                if (pMultiBrushInfo)
                {
                    memset (pMultiBrushInfo, 0, cj);
                    pMultiBrushInfo->cSurfaces = pvdev->cSurfaces;

                    PRBRUSH prbrush = (PDBRUSH)DBRUSHSTART(pboOrg->pvRbrush);
                    prbrush->bMultiBrush(TRUE);
                }
                else
                {
                    bValid = FALSE;
                }
            }
            else
            {
                pMultiBrushInfo = (PMULTIBRUSHINFO)pboOrg->pvRbrush;
            }
        }
    }

   ~MULTIBRUSH()
    {
    }

    BOOL Valid()
    {
        return (bValid);
    }

    VOID DestroyTable()
    {
        // NOTE: This routine MUST NOT access any data in from 'pvdev',
        // as the DDML may already be disabled, and 'pvdev' freed, when
        // this brush is deleted.

        if (pboOrg && (pMultiBrushInfo != NULL))
        {
            ULONG csurf = pMultiBrushInfo->cSurfaces;

            ASSERTGDI((csurf > 0), "Expected at least one surface in the list.");

            while (csurf)
            {
                csurf--;

                // Free the driver's DBRUSH if there is one

                PVOID pvRbrush;

                if (pvRbrush = pMultiBrushInfo->aBrush[csurf].pvD)
                {
                    PRBRUSH prbrush = (PDBRUSH) DBRUSHSTART(pvRbrush);
                                        // point to DBRUSH (pvRbrush points to
                                        // realization, which is at the end of DBRUSH)
                    prbrush->vRemoveRef(RB_DRIVER);
                                        // decrement the reference count on the
                                        // realization and free the brush if
                                        // this is the last reference
                    pMultiBrushInfo->aBrush[csurf].pvD = NULL;
                }

                if (pvRbrush = pMultiBrushInfo->aBrush[csurf].pvE) 
                {
                    PRBRUSH prbrush = (PENGBRUSH) pvRbrush;
                                        // point to engine brush realization
                    prbrush->vRemoveRef(RB_ENGINE);
                                        // decrement the reference count on the
                                        // realization and free the brush if
                                        // this is the last reference
                    pMultiBrushInfo->aBrush[csurf].pvE = NULL;
                }
            }
        }
    }

    VOID LoadElement(DISPSURF *pds, SURFACE *psurf)
    {
        if (pboOrg)
        {
            // If psurf == NULL, we were called from MulDestroyBrush.
            // We just leave the brush associated with the multi layer.
            // Otherwise, associate it with the driver we're about to call.

            if (psurf != NULL)
            {
                if (pds->iCompatibleColorFormat != 0)
                {
                    PDEVOBJ  pdo(pds->hdev);
                    PPALETTE ppalDC = ppalDefault;

                    //
                    // If this is palette managed device, use halftone palette.
                    //
                    if (pdo.bIsPalManaged())
                    {
                        ppalDC = REALIZE_HALFTONE_PALETTE(pdo.hdev());
                    }

                    //
                    // If current device has higher color depth than primary
                    // and this dithered brush. we don't use dithered brush
                    // on this, just use solid color here... since this device
                    // should be able to produce much colors...
                    //
                    if ((pds->iCompatibleColorFormat > 0) &&
                        (pboOrg->iSolidColor == 0xffffffff) &&
                        (pboOrg->crDCPalColor() != 0xffffffff))
                    {
                        // Try to map the solid color from surface palette.

                        pboOrg->iSolidColor = ulGetNearestIndexFromColorref(
                                                  psurf->ppal(),
                                                  ppalDC,
                                                  pboOrg->crDCPalColor());
  
                        // Behave as solid color brush.

                        pboOrg->pvRbrush = NULL;
                    }
                    //
                    // If this is solid color, map color index in destination
                    // device palette. we can not use the color index from
                    // meta device when this is different color depth than
                    // primary.
                    //
                    else if (pboOrg->iSolidColor != 0xffffffff)
                    {
                        // Try to map the solid color from surface palette.

                        pboOrg->iSolidColor = ulGetNearestIndexFromColorref(
                                                  psurf->ppal(),
                                                  ppalDC,
                                                  pboOrg->crDCPalColor());

                        // ASSERTGDI(pboOrg->pvRbrush == NULL,
                        //          "MBRUSH:LoadElement(): solid brush, but Rbrush != NULL\n");
                    }
                    else if (pMultiBrushInfo)
                    {
                        // Save the original engine brush, then replace with device specific one.

                        pengbrushOrg = pboOrg->pengbrush();
                        pboOrg->pengbrush((ENGBRUSH *)(pMultiBrushInfo->aBrush[pds->iDispSurf].pvE));

                        // Get device specifc Dbrush.

                        pboOrg->pvRbrush = pMultiBrushInfo->aBrush[pds->iDispSurf].pvD;
                    }
                }
                else if (pMultiBrushInfo)
                {
                    // Get device specifc Dbrush.

                    pboOrg->pvRbrush = pMultiBrushInfo->aBrush[pds->iDispSurf].pvD;
                }

                if (pMultiBrushInfo)
                {
                    pboOrg->psoTarg(psurf);

                    if (psurf->ppal())
                    {
                        pboOrg->palSurf(psurf->ppal());
                    }
                }
            }
        }
    }

    VOID StoreElement(LONG i)
    {
        if (pboOrg)
        {
            if (pMultiBrushInfo)
            {
                // Restore engine brush (if saved)

                if (pengbrushOrg != (PENGBRUSH)-1)
                {
                #if DBG
                    if (pengbrushOrg)
                    {
                        // Make sure the engbrush is not freed.
                        // If freed, this might causes bugcheck.
                        pengbrushOrg->vAddRef();
                        pengbrushOrg->vRemoveRef(RB_ENGINE);
                    }
                #endif

                    pMultiBrushInfo->aBrush[i].pvE = pboOrg->pengbrush();
                    pboOrg->pengbrush(pengbrushOrg);
                    pengbrushOrg = (PENGBRUSH)-1;
                }

                // Restore device brush.

                pMultiBrushInfo->aBrush[i].pvD = pboOrg->pvRbrush;

                if (psurfOrg)
                {
                    pboOrg->psoTarg(psurfOrg);
                }

                if (palSurfOrg.bValid())
                {
                    pboOrg->palSurf(palSurfOrg);
                }
            }

            pboOrg->iSolidColor = iSolidColorOrg;
            pboOrg->pvRbrush    = pMultiBrushInfo;
        }
    }
};

/******************************Public*Routine******************************\
* BOOL GreIsPaletteDisplay
*
* Return TRUE if the display is palettized
*
* History:
*  1-Jan-1997 -by- Vadim Gorokhovsky [vadimg]
\**************************************************************************/

BOOL GreIsPaletteDisplay(HDEV hdev)
{
    PDEVOBJ po(hdev);
    ASSERTGDI(po.bValid(), "Invalid PDEV");
    return (po.GdiInfoNotDynamic()->flRaster & RC_PALETTE);
}

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL FASTCALL bIntersect(
CONST RECTL*    prcl1,
CONST RECTL*    prcl2,
RECTL*          prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* Returns TRUE if 'prcl1' and 'prcl2' intersect.
*
\**************************************************************************/

BOOL FASTCALL bIntersect(
CONST RECTL*    prcl1,
CONST RECTL*    prcl2)
{
    return((prcl1->left   < prcl2->right)  &&
           (prcl1->top    < prcl2->bottom) &&
           (prcl1->right  > prcl2->left)   &&
           (prcl1->bottom > prcl2->top));
}

/******************************Public*Routine******************************\
* BOOL bContains
*
* Returns TRUE if 'prcl1' contains 'prcl2'.
*
\**************************************************************************/

BOOL FASTCALL bContains(
CONST RECTL*    prcl1,
CONST RECTL*    prcl2)
{
    return((prcl1->left   <= prcl2->left)  &&
           (prcl1->right  >= prcl2->right) &&
           (prcl1->top    <= prcl2->top)   &&
           (prcl1->bottom >= prcl2->bottom));
}

/******************************Public*Routine******************************\
* BOOL MSURF::bFindSurface
*
* Given the drawing bounds and clip object, this routine finds a surface
* that will be affected by the drawing.  The child surface's driver should
* then be called using MSURF's public 'pso' surface and 'pco' clip object
* members.
*
* If no surface can be found (the drawing is occuring off-screen from all
* video cards), FALSE is returned.
*
\**************************************************************************/

BOOL MSURF::bFindSurface(
SURFOBJ*    psoOriginal,
CLIPOBJ*    pcoOriginal,
RECTL*      prclDraw)
{
    GDIFunctionID(MSURF::bFindSurface);

    pvdev = (VDEV*) psoOriginal->dhpdev;

    ASSERTGDI((prclDraw->left < prclDraw->right) &&
              (prclDraw->top < prclDraw->bottom),
        "Poorly ordered draw rectangle");

    pmdsurf = NULL;
    if (psoOriginal->iType == STYPE_DEVBITMAP)
    {
        PDEVOBJ pdo(psoOriginal->hdev);
        ASSERTGDI(pdo.bValid() && pdo.bMetaDriver(), "Surface is not a valid Meta surface");

        // Some drivers want to hook drawing calls to device bitmaps and
        // DIBs.  We handle those cases here.

        pmdsurf = (MDSURF*) psoOriginal->dhsurf;

        ASSERTGDI(pmdsurf != NULL, "Unexpected NULL dhsurf");

        pco = pcoOriginal;

        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            if (pmdsurf->apso[pds->iDispSurf] != NULL)
            {
                pso  = pmdsurf->apso[pds->iDispSurf];
                pOffset = &gptlZero;

                return(TRUE);
            }
        }
    }
    else
    {
        // Okay, the drawing is to the screen:

        if ((pcoOriginal == NULL) || (pcoOriginal->iDComplexity == DC_TRIVIAL))
        {
            pco                  = pvdev->pco;
            iOriginalDComplexity = DC_TRIVIAL;
            rclOriginalBounds    = pco->rclBounds;
            rclDraw              = *prclDraw;
        }
        else
        {
            pco                  = pcoOriginal;
            iOriginalDComplexity = pco->iDComplexity;
            rclOriginalBounds    = pco->rclBounds;

            // Intersect the drawing bounds with the clipping bounds, because
            // we touch pixels that intersect both:

            if (!bIntersect(prclDraw, &rclOriginalBounds, &rclDraw))
            {
                return(FALSE);
            }
        }

        // Find the first surface that is affected:

        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            // WINBUG #340569 3-29-2001 jasonha
            //  Prevent access to screen during mode change / full screen mode

            if (!pds->po.bDisabled())
            {
                // First, test for the trivial case where the drawing is
                // contained entirely within this surface:

                if ((iOriginalDComplexity == DC_TRIVIAL) &&
                    (rclDraw.left   >= pds->rcl.left)    &&
                    (rclDraw.top    >= pds->rcl.top)     &&
                    (rclDraw.right  <= pds->rcl.right)   &&
                    (rclDraw.bottom <= pds->rcl.bottom))
                {
                    pco->iDComplexity = DC_TRIVIAL;
                    pco->rclBounds    = rclDraw;

                    pso     = pds->pso;
                    pOffset = &pds->Off;

                    return(TRUE);
                }
                else if (bIntersect(&rclDraw, &pds->rcl, &pco->rclBounds))
                {
                    // Since the drawing is not contained entirely within this
                    // surface, then we don't have DC_TRIVIAL clipping:

                    pco->iDComplexity = (iOriginalDComplexity != DC_TRIVIAL)
                                      ? iOriginalDComplexity
                                      : DC_RECT;

                    pso     = pds->pso;
                    pOffset = &pds->Off;

                    return(TRUE);
                }
            }
        }

        // Restore everything originally passed in that we modified:

        pco->rclBounds    = rclOriginalBounds;
        pco->iDComplexity = iOriginalDComplexity;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL MSURF::bNextSurface
*
* Finds the next driver surface that is affected by the drawing call.
*
* Returns FALSE if no surface can be found.
*
\**************************************************************************/

BOOL MSURF::bNextSurface()
{
    if (pmdsurf != NULL)
    {
        // Find the next driver that wants to hook drawing to device
        // bitmaps and DIBs.

        for (pds = pds->pdsNext; pds != NULL; pds = pds->pdsNext)
        {
            if (pmdsurf->apso[pds->iDispSurf] != NULL)
            {
                pso  = pmdsurf->apso[pds->iDispSurf];
                pOffset = &gptlZero;

                return(TRUE);
            }
        }
    }
    else
    {
        // Find the next driver that is affected by this drawing to the
        // screen.

        for (pds = pds->pdsNext; pds != NULL; pds = pds->pdsNext)
        {
            // WINBUG #340569 3-29-2001 jasonha
            //  Prevent access to screen during mode change / full screen mode

            if (!pds->po.bDisabled())
            {
                // First, test for the trivial case where the drawing is
                // contained entirely within this surface:
    
                if ((iOriginalDComplexity == DC_TRIVIAL) &&
                    (rclDraw.left   >= pds->rcl.left)    &&
                    (rclDraw.top    >= pds->rcl.top)     &&
                    (rclDraw.right  <= pds->rcl.right)   &&
                    (rclDraw.bottom <= pds->rcl.bottom))
                {
                    pco->iDComplexity = DC_TRIVIAL;
    
                    pso     = pds->pso;
                    pOffset = &pds->Off;
    
                    return(TRUE);
                }
    
                else if (bIntersect(&rclDraw, &pds->rcl, &pco->rclBounds))
                {
                    // Since the drawing is not contained entirely within this
                    // surface, then we don't have DC_TRIVIAL clipping:
    
                    pco->iDComplexity = (iOriginalDComplexity != DC_TRIVIAL)
                                      ? iOriginalDComplexity
                                      : DC_RECT;
    
                    pso     = pds->pso;
                    pOffset = &pds->Off;
    
                    return(TRUE);
                }
            }
        }

        // Restore everything originally passed in that we modified:

        pco->rclBounds    = rclOriginalBounds;
        pco->iDComplexity = iOriginalDComplexity;
    }

    return(FALSE);
}

/******************************Member*Routine******************************\
* MSURF::vRestore
*
* Restores state that may have been changed by bFindSurface/bNextSurface.
*
* Note: This must always be used when bFindSurface/bNextSurface return
*       TRUE, but won't be called again.  (Early loop termination.)
*
\**************************************************************************/

void MSURF::vRestore()
{
    // WINBUG: 451121 pravins 08/07/2001 Should be checking for non DEVBITMAP case here. For time being just check the PCO.
    if (pmdsurf != NULL && pco != NULL)
    {
        // Restore everything originally passed in that we modified:

        pco->rclBounds    = rclOriginalBounds;
        pco->iDComplexity = iOriginalDComplexity;
    }
}


/*****************************Private*Routine******************************\
* MULTISURF::vInit
*
* Initializes members and prepares default source surface values
*
\**************************************************************************/

void
MULTISURF::vInit(
    SURFOBJ *psoOriginal,
    RECTL *prclOriginal
    )
{
    GDIFunctionID(MULTISURF::vInit);

    pso = psoOriginal;
    prcl = &rclOrg;
    fl = 0;
    pmdsurf = NULL;

    if (psoOriginal != NULL)
    {
        rclOrg = *prclOriginal;
        dhpdevOrg = psoOriginal->dhpdev;

        // Is this a device associated bitmap?
        if (dhpdevOrg != NULL)
        {
            // Save original source settings
            psurfOrg = SURFOBJ_TO_SURFACE_NOT_NULL(psoOriginal);
            dhsurfOrg = psurfOrg->dhsurf();
            flagsOrg = psurfOrg->flags();

            PDEVOBJ pdo(psurfOrg->hdev());

            ASSERTGDI(pdo.bValid(), "Source doesn't have a valid HDEV");

            // Setup up source
            if (psurfOrg->iType() == STYPE_DEVBITMAP && pdo.bMetaDriver())
            {
                pmdsurf = (MDSURF*) dhsurfOrg;

                ASSERTGDI(psurfOrg->pvBits() != NULL, "Meta DEVBITMAP doesn't have pvBits");

                // Unmark source to make it look like a DIB
                fl = MULTISURF_SET_AS_DIB;
                psurfOrg->iType(STYPE_BITMAP);
                psurfOrg->dhsurf(NULL);
                psurfOrg->dhpdev(NULL);
                psurfOrg->flags(0);
            }
            else
            {
                // Is the surface opaque or does it live in video memory?
                if (psurfOrg->iType() != STYPE_BITMAP ||
                    pso->fjBitmap & BMF_NOTSYSMEM)
                {
                    fl = MULTISURF_USE_COPY;
                }
            }
        }
    }
    else
    {
        dhpdevOrg = NULL;
    }
}


/*****************************Private*Routine******************************\
* MULTISURF::bCreateDIB
*
* Creates a DIB copy of the original surface and computes an adjusted
* rectangle/origin for the surface.
*
\**************************************************************************/

BOOL
MULTISURF::bCreateDIB()
{
    GDIFunctionID(MULTISURF::bCreateDIB);

    ASSERTGDI(!SurfDIB.bValid(), "SurfDIB already created");

    PDEVOBJ  pdo(psurfOrg->hdev());

    ERECTL erclTrim(0L,
                    0L,
                    psurfOrg->sizl().cx,
                    psurfOrg->sizl().cy);

    // Find intersection of surface and area needed
    erclTrim *= rclOrg;

    ERECTL erclTmp(0L,
                   0L,
                   erclTrim.right - erclTrim.left,
                   erclTrim.bottom - erclTrim.top);

    DEVBITMAPINFO dbmi;
    dbmi.iFormat    = psurfOrg->iFormat();
    dbmi.cxBitmap   = erclTmp.right;
    dbmi.cyBitmap   = erclTmp.bottom;
    dbmi.hpal       = psurfOrg->ppal() ? (HPALETTE)psurfOrg->ppal()->hGet() : 0;
    ASSERTGDI(!psurfOrg->bUMPD(), "UMPD surface");
    dbmi.fl         = BMF_TOPDOWN;

    if (!SurfDIB.bCreateDIB(&dbmi, NULL))
    {
        WARNING("Failed SurfDIB memory allocation\n");
        return FALSE;
    }


    (*PPFNDRV(pdo,CopyBits)) (SurfDIB.pSurfobj(),
                              &psurfOrg->so,
                              (CLIPOBJ *) NULL,
                              NULL,
                              (PRECTL) &erclTmp,
                              (POINTL *) &erclTrim);

    rclDIB.left   = prcl->left   - erclTrim.left;
    rclDIB.top    = prcl->top    - erclTrim.top;
    rclDIB.right  = prcl->right  - erclTrim.left;
    rclDIB.bottom = prcl->bottom - erclTrim.top;

    return TRUE;
}


/*****************************Public*Members*******************************\
* BOOL MULTISURF::bLoadSource (2 versions)
*
* Prepares the next source surface for the given destination as follows:
*
*  For a non-device BITMAP (dhpdev = NULL), the orignal surface is used.
*
*  For a Meta DEVBITMAP, a matching device surface is used or if there
*   isn't a match the backing DIB is used (unmarked during vInit).
*
*  For other surfaces, if the destination device is different the original
*   surface is unmarked to look like a DIB when the bits are present in
*   system memory or a DIB copy is created.
*
* Returns FALSE if no surface can be prepared.
*
\**************************************************************************/

BOOL MULTISURF::bLoadSource(
    DISPSURF* pdsDst
    )
{
    GDIFunctionID(MULTISURF::bLoadSource);

    BOOL bRet = TRUE;

    // If this is a device bitmap, there is work to do.
    if (dhpdevOrg != NULL)
    {
        if (pmdsurf != NULL)
        {
            // Meta DEVBITMAP:
            //  Use device managed bitmap for source, else go for the DIB
            pso = pmdsurf->apso[pdsDst->iDispSurf];

            if (pso == NULL)
            {
                pso = &psurfOrg->so;
            }
        }
        else
        {
            bRet = bLoadSourceNotMetaDEVBITMAP(pdsDst->hdev);
        }
    }

    return bRet;
}

BOOL MULTISURF::bLoadSource(
    HDEV hdevDst
    )
{
    GDIFunctionID(MULTISURF::bLoadSource);

    BOOL bRet = TRUE;

    // If this is a device bitmap, there is work to do.
    if (dhpdevOrg != NULL)
    {
        if (pmdsurf != NULL)
        {
            // Meta DEVBITMAP:
            //  Use device managed bitmap for source, else go for the DIB
            VDEV *pvdev = pmdsurf->pvdev;
            DISPSURF *pds;

            ASSERTGDI(pvdev != NULL, "pvdev is NULL.\n");

            for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
            {
                if (pds->hdev == hdevDst)
                {
                    pso = pmdsurf->apso[pds->iDispSurf];
                    break;
                }
            }

            if (pso == NULL)
            {
                pso = &psurfOrg->so;
            }
        }
        else
        {
            bRet = bLoadSourceNotMetaDEVBITMAP(hdevDst);
        }
    }

    return bRet;
}


/*****************************Private*Member*******************************\
* BOOL MULTISURF::bLoadSourceNotMetaDEVBITMAP
*
*  If the destination device is different the original surface is unmarked
*   to look like a DIB when the bits are present in system memory or a DIB
*   copy is created.
*
* Returns FALSE if no surface can be prepared.
*
* NOTE: This routine assumes BITMAPs and Meta DEVBITMAPs have already been
*       handled and won't come here.  See bLoadSource members.
*
\**************************************************************************/

BOOL MULTISURF::bLoadSourceNotMetaDEVBITMAP(
    HDEV hdevDst
    )
{
    GDIFunctionID(MULTISURF::bLoadSourceNotMetaDEVBITMAP);

    if (fl & MULTISURF_USE_COPY)
    {
        // Opaque or video memory surface:
        //  Use a DIB copy if destination doesn't match the source
        if (psurfOrg->hdev() != hdevDst)
        {
            // Do we already have a DIB copy?
            if (!SurfDIB.bValid())
            {
                // Allocate an intermediate DIB for a source
                if (!bCreateDIB())
                {
                    return FALSE;
                }
            }

            // Make pso and prcl point to the copy
            pso = SurfDIB.pSurfobj();
            prcl = &rclDIB;
        }
        else
        {
            // Just use original surface
            pso = &psurfOrg->so;
            prcl = &rclOrg;
        }
    }
    else
    {
        // BITMAP in system memory:
        //  Unmark to appear as DIB if destination doesn't match the source
        if (psurfOrg->hdev() != hdevDst)
        {
            if (!(fl & MULTISURF_SET_AS_DIB))
            {
                if (!(fl & MULTISURF_SYNCHRONIZED))
                {
                    PDEVOBJ pdo(psurfOrg->hdev());
                    pdo.vSync(pso, prcl, 0);
                    fl |= MULTISURF_SYNCHRONIZED;
                }

                // Unset fields to look like a DIB
                fl |= MULTISURF_SET_AS_DIB;
                psurfOrg->dhpdev(NULL);
                psurfOrg->dhsurf(NULL);
                psurfOrg->flags(0);
            }
        }
        else
        {
            if (fl & MULTISURF_SET_AS_DIB)
            {
                // Restore original settings
                fl &= ~MULTISURF_SET_AS_DIB;
                psurfOrg->dhpdev(dhpdevOrg);
                psurfOrg->dhsurf(dhsurfOrg);
                psurfOrg->flags(flagsOrg);
            }
        }
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* BOOL MulEnableDriver
*
* Standard driver DrvEnableDriver function
*
\**************************************************************************/

BOOL MulEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    pded->pdrvfn         = gadrvfnMulti;
    pded->c              = gcdrvfnMulti;
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DHPDEV MulEnablePDEV
*
* Creates a single large VDEV that will represent the combination of other
* smaller PDEVs
*
* This function creates an internal structure that keeps the location of
* the various cards, and also keeps the appropriate data structures to
* be passed down to each driver.
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW *pdm,
LPWSTR    pwszLogAddress,
ULONG     cPat,
HSURF    *phsurfPatterns,
ULONG     cjCaps,
GDIINFO  *pdevcaps,
ULONG     cjDevInfo,
DEVINFO  *pdi,
HDEV      hdev,
LPWSTR    pwszDeviceName,
HANDLE    hDriver)
{
    PMDEV       pmdev = (PMDEV) pdm;
    PVDEV       pvdev;
    DISPSURF    dsAnchor;
    DISPSURF*   pds;
    DISPSURF*   pdsPrev;
    DISPSURF*   pdsTmp;
    HDEV*       paHdev;
    ULONG       i,j;
    ULONG       flGraphicsCaps  = 0xffffffff;
    ULONG       flGraphicsCaps2 = 0xffffffff;
    HDEV        hdevPrimary = NULL;
    BOOL        bPrimaryPalManaged  = FALSE;

    pdsPrev = &dsAnchor;

    // Create the main multi dispsurf structure.

    LONG cjAlloc = ((sizeof(VDEV)) + (sizeof(DISPSURF) * pmdev->chdev));

    pvdev = (VDEV*) EngAllocMem(FL_ZERO_MEMORY, cjAlloc, 'vdVG');
    if (pvdev == NULL)
        return(NULL);

    paHdev = (HDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(HDEV) * pmdev->chdev, 'sdvG');
    if (paHdev == NULL)
    {
        EngFreeMem(pvdev);
        return(NULL);
    }

    pds = (DISPSURF*) ((BYTE*)pvdev + sizeof(VDEV));

    pvdev->cSurfaces = pmdev->chdev;
    pvdev->hdev      = hdev;

    // Loop through the list of MDEVs passed in.

    pvdev->rclBounds.left =   0x7fffffff;
    pvdev->rclBounds.top =    0x7fffffff;
    pvdev->rclBounds.right =  0x80000000;
    pvdev->rclBounds.bottom = 0x80000000;

    ASSERTGDI((pmdev->chdev > 0), "Expected at least one surface in the list.");

    for (i = 0; i < pmdev->chdev; i++)
    {
        // Set this PDEV as parent to each of the PDEVs that we'll manage.

        PDEVOBJ pdo(pmdev->Dev[i].hdev);

    #if TEXTURE_DEMO
        if ((pmdev->Dev[i].rect.left == 0) && (pmdev->Dev[i].rect.top == 0))
    #else
        if (pdo.ppdev->pGraphicsDevice->stateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
    #endif
        {
            ASSERTGDI(!hdevPrimary, "2 or more primary devices in MulEnablePDEV");
            ASSERTGDI(pmdev->Dev[i].rect.left == 0, "mispositioned primary");
            ASSERTGDI(pmdev->Dev[i].rect.top == 0, "mispositioned primary");

            hdevPrimary = pdo.hdev();
            bPrimaryPalManaged = pdo.bIsPalManaged();

            *pdevcaps = *pdo.GdiInfo();
            *pdi = *pdo.pdevinfo();
        }

        // Take the intersection of flags that are capabilities.

        flGraphicsCaps  &= pdo.pdevinfo()->flGraphicsCaps;
        flGraphicsCaps2 &= pdo.pdevinfo()->flGraphicsCaps2;

        pdsPrev->pdsNext    = pds;
        pdsPrev->pdsBltNext = pds;

        pds->iDispSurf      = i;
        pds->rcl            = *((PRECTL) &(pmdev->Dev[i].rect));

        pds->hdev  = pmdev->Dev[i].hdev;
        pds->po.vInit(pds->hdev);
        pds->po.vReferencePdev();

        pds->Off.x = -pdo.pptlOrigin()->x;
        pds->Off.y = -pdo.pptlOrigin()->y;
        pds->pso   =  pdo.pSurface()->pSurfobj();

        // Primary (readable) surfaces are always first in the MDEV structure;
        // Secondary (non-readable) surfaces are always second.  So if this
        // surfaces overlaps a previous one, this surface must be non-readable:

        pds->bIsReadable = TRUE;
        for (pdsTmp = dsAnchor.pdsNext; pdsTmp != pds; pdsTmp = pdsTmp->pdsNext)
        {
            if (bIntersect(&pdsTmp->rcl, &pds->rcl))
                pds->bIsReadable = FALSE;
        }

        // Adjust bounding rectangle:

        pvdev->rclBounds.left   = min(pvdev->rclBounds.left,   pds->rcl.left);
        pvdev->rclBounds.top    = min(pvdev->rclBounds.top,    pds->rcl.top);
        pvdev->rclBounds.right  = max(pvdev->rclBounds.right,  pds->rcl.right);
        pvdev->rclBounds.bottom = max(pvdev->rclBounds.bottom, pds->rcl.bottom);

        pdsPrev = pds;
        pds++;
    }

    ASSERTGDI(hdevPrimary, "No primary devices found in MulEnablePDEV");

    // Make these numbers negative since we don't want them scaled again
    // by GDI.

    pdevcaps->ulHorzSize = (ULONG) -((LONG)pdevcaps->ulHorzSize);
    pdevcaps->ulVertSize = (ULONG) -((LONG)pdevcaps->ulVertSize);

    // Plug in the intersection of the GCAPS:

    flGraphicsCaps &= ~(GCAPS_ASYNCMOVE | GCAPS_ASYNCCHANGE | GCAPS_PANNING);

    // If primary is palette managed device, make it Meta device palette managed, too.

    if (bPrimaryPalManaged)
        pdi->flGraphicsCaps = (flGraphicsCaps | GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);
    else
        pdi->flGraphicsCaps = flGraphicsCaps;

    pdi->flGraphicsCaps2 = flGraphicsCaps2;

    pvdev->iBitmapFormat = pdi->iDitherFormat;

    // Set the root of the list of dispsurfs

    pvdev->pds    = dsAnchor.pdsNext;
    pvdev->pdsBlt = dsAnchor.pdsNext;

    // Set hdev primary

    pvdev->hdevPrimary = hdevPrimary;

    PDEVOBJ poMeta(hdev);

    // Walk through pds list to check each device's colour depth and format

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ poThis(pds->hdev);

        if (poThis.hdev() == hdevPrimary)
        {
            // This is primary PDEV. 0 means compatible.

            pds->iCompatibleColorFormat = 0;

            KdPrint(("GDI DDML: %ws - iDitherFormat is %d, and this is primary.\n",
                        ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                        poThis.iDitherFormat()));
        }
        else
        {
            // Compare colour depth primary and this device.
            //
            // iCompatibleColorFormat will be ...
            //     0           - same as the primary
            //     Plus value  - higher colour depth than primary
            //     Minus value - lower colour depth than primary 

            pds->iCompatibleColorFormat = (poThis.iDitherFormat() - pvdev->iBitmapFormat);

            KdPrint(("GDI DDML: %ws - iDitherFormat is %d.\n",
                        ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                        poThis.iDitherFormat()));

            KdPrint(("GDI DDML: %ws - PalManaged - %s\n",
                        ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                        (poThis.bIsPalManaged() ? "Yes" : "No")));

            // If colour depth is same check palette format.

            if (pds->iCompatibleColorFormat == 0)
            {
                EPALOBJ palMeta(pdi->hpalDefault);
                EPALOBJ palThis(poThis.pdevinfo()->hpalDefault);

                // Compare the palette type.
                //
                // If not equal, treat it as 1 (this is higher colour depth than primary)

                pds->iCompatibleColorFormat =
                    ((palMeta.iPalMode() == palThis.iPalMode()) ? 0 : 1);

                KdPrint(("GDI DDML: %ws - iPalMode is %d.\n",
                            ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName,
                            palThis.iPalMode()));

                if ((pds->iCompatibleColorFormat == 0) &&
                    (palMeta.iPalMode() == PAL_BITFIELDS))
                {
                    // If the palette is bitfields, should check R, G, B assignment.
                    //
                    // If not equal, treat it as 1 (this is higher colour depth than primary)

                    pds->iCompatibleColorFormat =
                       (((palMeta.flRed() == palThis.flRed()) &&
                         (palMeta.flGre() == palThis.flGre()) &&
                         (palMeta.flBlu() == palThis.flBlu())) ? 0 : 1);
                }
            }

            // Mark in global variable if one of device is not same as Meta.

            if (pds->iCompatibleColorFormat != 0)
            {
                // mark hdev in this mdev does not have same color depth.

                pmdev->ulFlags |= MDEV_MISMATCH_COLORDEPTH;

                gbMultiMonMismatchColor = TRUE;

                KdPrint(("GDI DDML: %ws is NOT compatible as primary.\n",
                            ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName));
            }
            else
            {
                // This flag should not be back to FALSE, if system once became mismatch
                // color depth mode. This flag only can be FALSE, when system NEVER experience
                // mismatch color depth mode since system booted.
                //
                // gbMultiMonMismatchColor = FALSE;

                KdPrint(("GDI DDML: %ws is compatible as primary.\n",
                            ((PDEV *)(poThis.hdev()))->pGraphicsDevice->szWinDeviceName));
            }
        }
    }

    // Set the origin in the meta-PDEV.  Note that we do NOT set 'ptlOffset'
    // in the surface, as that would cause all our drawing to the meta-surface
    // to be offset by that amount, which is NOT what we want.

    poMeta.ppdev->ptlOrigin.x = pvdev->rclBounds.left;
    poMeta.ppdev->ptlOrigin.y = pvdev->rclBounds.top;
    poMeta.ppdev->sizlMeta.cx = pvdev->rclBounds.right - pvdev->rclBounds.left;
    poMeta.ppdev->sizlMeta.cy = pvdev->rclBounds.bottom - pvdev->rclBounds.top;

    // Mark this as Meta-PDEV.

    poMeta.bMetaDriver(TRUE);

    KdPrint(("GDI DDML: %li devices at (%li, %li, %li, %li).\n",
        pmdev->chdev, pvdev->rclBounds.left, pvdev->rclBounds.top,
        pvdev->rclBounds.right, pvdev->rclBounds.bottom));

#if TEXTURE_DEMO
    if (ghdevTextureParent)
    {
        paHdev[0] = ghdevTextureParent;
        vSpEnableMultiMon(hdev, 1, paHdev);         // References 'paHdev'
        return((DHPDEV) pvdev);
    }
#endif

    // Initialize Sprite stuff.
    // (Put Mirroring device first, then other drivers).

    j = 0;

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdoTmp(pmdev->Dev[i].hdev);
        if (pdoTmp.flGraphicsCaps() & GCAPS_LAYERED)
        {
            paHdev[j++] = pmdev->Dev[i].hdev;
        }
    }

    for (i = 0; i < pmdev->chdev; i++)
    {
        PDEVOBJ pdoTmp(pmdev->Dev[i].hdev);
        if (!(pdoTmp.flGraphicsCaps() & GCAPS_LAYERED))
        {
            paHdev[j++] = pmdev->Dev[i].hdev;
        }
    }

    vSpEnableMultiMon(hdev, pmdev->chdev, paHdev);  // References 'paHdev'

    return((DHPDEV) pvdev);
}

/******************************Public*Routine******************************\
* VOID MulDisablePDEV
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    PVDEV       pvdev;
    DISPSURF*   pds;

    pvdev = (PVDEV) dhpdev;

    vSpDisableMultiMon(pvdev->hdev); // Frees 'paHdev'

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        pds->po.vUnreferencePdev();
    }

    EngFreeMem(pvdev);
}

/******************************Public*Routine******************************\
* VOID MulCompletePDEV
*
* This function informs us of the 'hdev' that GDI has assigned us.
* We already got that initially information from MulEnablePDEV, but
* GDI reassigns 'hdev's during some mode changes.
*
* WINBUG #289937 01-23-2001 jasonha
*   PDEV still has a reference after removing a monitor
*
* If we are being assigned an 'hdev' that was previously assigned to
* one of the children, then that child is taking over our previously
* assigned 'hdev'.  We update our 'hdev's accordingly.
* NOTE: We must be able to grab ghsemDriverMgmt to successfully
*       reference and unreference PDEV's.
*
* All of the layered drivers that have hdev changes have their
* DrvCompletePDEV functions called directly by GDI.
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    GDIFunctionID(MulCompletePDEV);

    PVDEV       pvdev = (PVDEV) dhpdev;
    HDEV        hdevPrev = pvdev->hdev;
    DISPSURF*   pds;

    if (hdevPrev != hdev)
    {
        // Update hdevPrimary
        if (pvdev->hdevPrimary == hdev)
        {
            pvdev->hdevPrimary = hdevPrev;
        }

        // Update child 'hdev's
        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            if (pds->po.hdev() == hdev)
            {
                ASSERTGDI(pds->po.cPdevRefs() > 1, "Incorrect PDEV reference count.\n");
                pds->po.vUnreferencePdev();

                pds->hdev = hdevPrev;
                pds->po.vInit(hdevPrev);
                pds->po.vReferencePdev();
            }
        }

        pvdev->hdev = hdev;
    }
}

/******************************Public*Routine******************************\
* HSURF MulEnableSurface
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    SIZEL       sizlVirtual;
    HSURF       hsurfVirtual;
    HSURF       hsurf;
    CLIPOBJ*    pco;
    SURFACE    *psurf;

    pvdev = (VDEV*) dhpdev;

    // Note that we don't hook SYNCHRONIZE because we always return a
    // device managed surface to GDI.

    pvdev->flHooks = (HOOK_BITBLT
                    | HOOK_TEXTOUT
                    | HOOK_STROKEPATH
                    | HOOK_FILLPATH
                    | HOOK_STROKEANDFILLPATH
                    | HOOK_LINETO
                    | HOOK_COPYBITS
                    | HOOK_STRETCHBLT
                    | HOOK_GRADIENTFILL
                    | HOOK_TRANSPARENTBLT
                    | HOOK_ALPHABLEND);

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pvdev->rclBounds.right - pvdev->rclBounds.left;
    sizlVirtual.cy = pvdev->rclBounds.bottom - pvdev->rclBounds.top;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pvdev,
                                          sizlVirtual,
                                          pvdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pvdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pvdev->hdev, pvdev->flHooks))
        goto ReturnFailure;

    // Get and save a pointer to the SURFOBJ for the DDML

    pvdev->pso = EngLockSurface(hsurfVirtual);
    if (!pvdev->pso)
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pco->rclBounds = pvdev->rclBounds;
    ((ECLIPOBJ*) pco)->vSet(&pco->rclBounds);

    pvdev->pco = pco;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ poThis(pds->hdev);

        if (poThis.flGraphicsCaps() & GCAPS_LAYERED)
        {
            poThis.pSurface()->hMirrorParent = hsurfVirtual;
        }
    }

    // We're done!

    return(hsurfVirtual);

ReturnFailure:
    KdPrint(("Failed MulEnableSurface\n"));

    MulDisableSurface((DHPDEV) pvdev);
    return(0);
}

/******************************Public*Routine******************************\
* VOID MulDisableSurface
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    PVDEV       pvdev;
    HSURF       hsurf;
    HOBJ        hobj;
    SURFACE*    pSurface;

    pvdev = (VDEV*) dhpdev;

    PDEVOBJ po(pvdev->hdev);

    ASSERTGDI(po.bValid(), "Invalid PDEV");

    EngDeleteClip(pvdev->pco);
    EngUnlockSurface(pvdev->pso);
    EngDeleteSurface(pvdev->hsurf);
}

/******************************Public*Routine******************************\
* BOOL MulSetPalette
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ *ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    BOOL        bRet = TRUE;

    pvdev   = (VDEV*) dhpdev;
    pds     = pvdev->pds;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ pdo(pds->hdev);

        if (pdo.bIsPalManaged() && PPFNVALID(pdo,SetPalette))
        {
            bRet &= (*PPFNDRV(pdo,SetPalette)) (pdo.dhpdev(),
                                                ppalo,
                                                fl,
                                                iStart,
                                                cColors);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL MulIcmSetDeviceGammaRamp
*
* History:
*   19-Feb-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

ULONG MulIcmSetDeviceGammaRamp(
DHPDEV  dhpdev,
ULONG   iFormat,
LPVOID  lpRamp)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    BOOL        bRet = FALSE;

    pvdev   = (VDEV*) dhpdev;
    pds     = pvdev->pds;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ pdo(pds->hdev);

        if ((PPFNVALID(pdo, IcmSetDeviceGammaRamp)) && 
            (pdo.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP))
        {
            bRet &= (*PPFNDRV(pdo,IcmSetDeviceGammaRamp))
                                        (pdo.dhpdev(),
                                         iFormat,
                                         lpRamp);
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL MulRealizeBrush
*
* This function's only job is to handle the call caused by the pvGetRbrush
* in the MULTIBRUSH object.  It should just allocate enough memory for the
* object, and return.
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ *pbo,
SURFOBJ  *psoDst,
SURFOBJ  *psoPat,
SURFOBJ  *psoMask,
XLATEOBJ *pxlo,
ULONG    iHatch)
{
    PVDEV       pvdev;
    LONG        cj;

    pvdev = (VDEV*) psoDst->dhpdev;

    ASSERTGDI(pbo->pvRbrush == NULL, "MulRealizeBrush has a memory leak.\n"
                                     "Called with pbo->pvRbrush != NULL");

    cj = sizeof(MULTIBRUSHINFO) +
         (pvdev->cSurfaces - 1) * sizeof(MULTIREALIZEDBRUSH);

    return(BRUSHOBJ_pvAllocRbrush(pbo, cj) != NULL);
}

/******************************Public*Routine******************************\
* ULONG MulEscape
*
* History:
*   12-Jul-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

ULONG MulEscape(
SURFOBJ *pso,
ULONG    iEsc,
ULONG    cjIn,
PVOID    pvIn,
ULONG    cjOut,
PVOID    pvOut)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    ULONG       ulRet = 0;

    ASSERTGDI((pso->dhsurf != NULL), "Expected device dest.");

    // OpenGL ExtEscapes from the ICD (and MCD) can still
    // end up here at DeletContext time when the original
    // DC has been lost and they try to communicate to the
    // driver with a DC they got by GetDC(NULL).
    //
    // This routine really shouldn't do anything but return 0.

    if ((iEsc == OPENGL_CMD) || (iEsc == OPENGL_GETINFO) ||
        (iEsc == MCDFUNCS)   || (iEsc == WNDOBJ_SETUP))
    {
        return (0);
    } 

    pvdev = (VDEV*) pso->dhpdev;
    pds     = pvdev->pds;
    csurf   = pvdev->cSurfaces;

    ASSERTGDI((csurf > 0), "Expected at least one surface in the list.");

    while (csurf--)
    {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo,Escape))
        {

            ULONG ulTmp;
            ulTmp = pdo.Escape(pds->pso, iEsc, cjIn, pvIn, cjOut, pvOut);

            // set ulRet to last non-zero value returned

            if (ulTmp != 0)
            {
                ulRet = ulTmp;
            }
        }
        pds = pds->pdsNext;
    }
    return(ulRet);
}

/******************************Public*Routine******************************\
* VOID MulDestroyFont
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDestroyFont(
FONTOBJ*    pfo)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    BOOL        bRet = TRUE;

    if (pfo->pvConsumer != NULL)
    {
        MULTIFONT   MFONT(pfo, -1, NULL);

        pvdev   = MFONT.pvdev();
        pds     = pvdev->pds;
        csurf   = pvdev->cSurfaces;

        ASSERTGDI((csurf > 0), "Expected at least one surface in the list.");

        while (csurf--)
        {
            PDEVOBJ pdo(pds->hdev);

            if (PPFNVALID(pdo,DestroyFont))
            {
                MFONT.LoadElement(pds->iDispSurf);
                pdo.DestroyFont(pfo);
                MFONT.StoreElement(pds->iDispSurf);
            }
            pds = pds->pdsNext;
        }
        MFONT.DestroyTable();
    }
}

/******************************Public*Routine******************************\
* VOID MulDestroyBrushInternal
*
* Internal brush destruction routine.  This is called to delete our
* private information associated with multi brushes.
*
* History:
*   9-July-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID MulDestroyBrushInternal(
PVOID pvRbrush)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    BOOL        bRet = TRUE;

    if (pvRbrush != NULL)
    {
        BRUSHOBJ boTmp;

        boTmp.iSolidColor = 0xffffffff;
        boTmp.pvRbrush = pvRbrush;
        boTmp.flColorType = 0;

        MULTIBRUSH   MBRUSH(&boTmp, -1, NULL, NULL, TRUE);
        MBRUSH.DestroyTable();
    }
}

/******************************Public*Routine******************************\
* ULONG ulSimulateSaveScreenBits
*
* This function simulates SaveScreenBits for those drivers that do not
* hook it, by using a temporary bitmap and copying in and out of that.
*
\**************************************************************************/

ULONG_PTR ulSimulateSaveScreenBits(
SURFOBJ*    psoScreen,
ULONG       iMode,
ULONG_PTR   ulIdent,
RECTL*      prcl)          // Already in device's coordinates
{
    SIZEL       sizl;
    HSURF       hsurf;
    SURFOBJ*    psoSave;
    SURFACE*    psurfSave;
    SURFACE*    psurfScreen;
    ULONG_PTR    ulRet;
    RECTL       rclDst;
    POINTL      ptlSrc;

    PDEVOBJ pdo(psoScreen->hdev);

    if (iMode == SS_SAVE)
    {
        sizl.cx = prcl->right - prcl->left;
        sizl.cy = prcl->bottom - prcl->top;

        ASSERTGDI((sizl.cx > 0) && (sizl.cy > 0), "Empty rectangle on save");

        // First, try to create the temporary save bitmap as a Device-Format-
        // Bitmap, and if that fails try it as a normal DIB.  (Many display
        // drivers support off-screen bitmaps via CreateDeviceBitmap, so this
        // is often the fastest way to do it.)

        hsurf = 0;

        if (PPFNVALID(pdo, CreateDeviceBitmap))    
        {
            hsurf = (HSURF) (*PPFNDRV(pdo, CreateDeviceBitmap))
                                           (psoScreen->dhpdev,
                                            sizl,
                                            psoScreen->iBitmapFormat);
        }
        if (hsurf == 0)
        {
            hsurf = (HSURF) EngCreateBitmap(sizl,
                                            0,
                                            psoScreen->iBitmapFormat,
                                            BMF_TOPDOWN,
                                            NULL);
        }

        psoSave = EngLockSurface(hsurf);
        if (psoSave)
        {
            rclDst.left   = 0;
            rclDst.top    = 0;
            rclDst.right  = sizl.cx;
            rclDst.bottom = sizl.cy;

            psurfSave = SURFOBJ_TO_SURFACE(psoSave);

            // Copy the screen to the temporary bitmap.  Note that
            // we do not use OffCopyBits as the coordinates have
            // already been offset to take into account the monitor's
            // origin:

            (*PPFNGET(pdo, CopyBits, psurfSave->flags()))(psoSave,
                                                          psoScreen,
                                                          NULL,
                                                          NULL,
                                                          &rclDst,
                                                          (POINTL*) prcl);
        }

        ulRet = (ULONG_PTR) psoSave;
    }
    else
    {
        psoSave = (SURFOBJ*) ulIdent;

        if (iMode == SS_RESTORE)
        {
            ptlSrc.x = 0;
            ptlSrc.y = 0;
            psurfScreen = SURFOBJ_TO_SURFACE(psoScreen);

            // Copy the temporary bitmap back to the screen:

            (*PPFNGET(pdo, CopyBits, psurfScreen->flags()))(psoScreen,
                                                            psoSave,
                                                            NULL,
                                                            NULL,
                                                            prcl,
                                                            &ptlSrc);
        }

        // Free the bitmap, remembering to retrieve any data from the
        // SURFOBJ before we unlock it.  Note that EngDeleteSurface
        // handles calling DrvDeleteDeviceBitmap if it's a device
        // format bitmap:

        hsurf = psoSave->hsurf;
        EngUnlockSurface(psoSave);
        EngDeleteSurface(hsurf);

        ulRet = TRUE;
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* ULONG MulSaveScreenBits
*
* It's important for the DDML to hook SaveScreenBits even if some of the
* underlying drivers do not, for scenarios such as NetMeeting.  This is
* because if SaveScreenBits is not hooked, USER goes and simulates by
* creating a temporary bitmap and saving and restoring the bits into that
* bitmap via CopyBits -- meaning that for NetMeeting the temporary bitmap
* is sent in full both ways over the wire.  NetMeeting much prefers to be
* able to hook SaveScreenBits so that it can send a small token over the wire
* representing the save or restore.  The problem is that most drivers do
* not support SaveScreenBits, and so for those drivers we simply emulate
* ourselves (thus allowing us to hook SaveScreenBits even if all the
* drivers do not hook SaveScreenBits).
*
* Note also that NetMeeting likes to be able to fail its SS_RESTORE call so
* that it can force a repaint if it wants to.
*
\**************************************************************************/

#define SS_GDI_ENGINE 1
#define SS_GDI_DRIVER 2

typedef struct _MULTISAVEBITS {
   FLONG     flType;
   ULONG_PTR ulBits;
} MULTISAVEBITS, *PMULTISAVEBITS; 

ULONG_PTR MulSaveScreenBits(
SURFOBJ*    pso,
ULONG       iMode,
ULONG_PTR   ulIdent,
RECTL*      prcl)
{
    PVDEV                   pvdev;
    PDISPSURF               pds;
    LONG                    csurf;
    ULONG_PTR               ulRet;
    ULONG_PTR               ulThisBits;
    FLONG                   flThisType;
    MULTISAVEBITS*          pulIdent;
    RECTL                   rclThis;
    PFN_DrvSaveScreenBits   pfnSaveScreenBits;

    pvdev   = (VDEV*) pso->dhpdev;
    pds     = pvdev->pds;
    csurf   = pvdev->cSurfaces;

    if (iMode == SS_SAVE)
    {
        pulIdent = (MULTISAVEBITS*)
            EngAllocMem(FL_ZERO_MEMORY, csurf * sizeof(MULTISAVEBITS), 'vdVG');

        ulRet = (ULONG_PTR)pulIdent;

        if (pulIdent)
        {
            do {
                ulThisBits = 0;

                if (bIntersect(prcl, &pds->rcl, &rclThis))
                {
                    rclThis.left   -= pds->rcl.left;
                    rclThis.right  -= pds->rcl.left;
                    rclThis.top    -= pds->rcl.top;
                    rclThis.bottom -= pds->rcl.top;

                    PDEVOBJ pdoThis(pds->hdev);

                    pfnSaveScreenBits = PPFNVALID(pdoThis, SaveScreenBits)
                                      ? PPFNDRV(pdoThis, SaveScreenBits)
                                      : ulSimulateSaveScreenBits;

                    ulThisBits = pfnSaveScreenBits(pds->pso,
                                                   SS_SAVE,
                                                   0,
                                                   &rclThis);

                    if (ulThisBits == 0)
                    {
                        // Ack, this driver failed to save its screenbits.
                        //
                        // Try the software simulation (if we haven't tried)

                        if (pfnSaveScreenBits != ulSimulateSaveScreenBits)
                        {
                            pfnSaveScreenBits = ulSimulateSaveScreenBits;

                            ulThisBits = pfnSaveScreenBits(pds->pso,
                                                           SS_SAVE,
                                                           0,
                                                           &rclThis);
                        }

                        if (ulThisBits == 0)
                        {
                            // We have to free any screenbits that any earlier
                            // driver saved:

                            MulSaveScreenBits(pso,
                                              SS_FREE,
                                              ulRet,
                                              &grclEmpty);
                            return(0);
                        }
                    }
                }

                if ((pulIdent[pds->iDispSurf].ulBits = ulThisBits) != 0)
                {
                    pulIdent[pds->iDispSurf].flType = 
                        (pfnSaveScreenBits == ulSimulateSaveScreenBits)
                      ? SS_GDI_ENGINE : SS_GDI_DRIVER;
                }

                pds = pds->pdsNext;
            } while (--csurf);
        }
    }
    else
    {
        pulIdent = (MULTISAVEBITS*)ulIdent;

        ulRet = TRUE;           // Assume success

        do {
            ulThisBits = pulIdent[pds->iDispSurf].ulBits;
            flThisType = pulIdent[pds->iDispSurf].flType;

            if (ulThisBits)
            {
                PDEVOBJ pdoThis(pds->hdev);

                if (bIntersect(prcl, &pds->rcl, &rclThis))
                {
                    rclThis.left   -= pds->rcl.left;
                    rclThis.right  -= pds->rcl.left;
                    rclThis.top    -= pds->rcl.top;
                    rclThis.bottom -= pds->rcl.top;
                }
                else
                {
                    rclThis = grclEmpty;
                }

                if ((flThisType == SS_GDI_DRIVER) &&
                    (PPFNVALID(pdoThis, SaveScreenBits)))
                {
                    pfnSaveScreenBits = PPFNDRV(pdoThis, SaveScreenBits);
                }
                else
                {
                    pfnSaveScreenBits = ulSimulateSaveScreenBits;
                }

                ulThisBits = pfnSaveScreenBits(pds->pso,
                                               iMode,
                                               ulThisBits,
                                               &rclThis);

                if ((ulThisBits == 0) && (iMode == SS_RESTORE))
                {
                    // Ack, this driver failed to restore its screenbits.
                    // We'll have to tell USER that we failed, too.  But
                    // first, we have to continue to free the screenbits of
                    // any drivers following in the DDML list:

                    ulRet = FALSE;
                    iMode = SS_FREE;
                    prcl = &grclEmpty;
                }
            }

            pds = pds->pdsNext;
        } while (--csurf);

        EngFreeMem((VOID*) ulIdent);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* VOID MulDeleteDeviceBitmap
*
* If the surface has been hooked by the DDML, do any clean-up required
* so that the surface can be deleted.
*
\**************************************************************************/

VOID MulDeleteDeviceBitmap(
DHSURF dhsurf)
{
    MDSURF*     pmdsurf;
    VDEV*       pvdev;
    DISPSURF*   pds;
    SURFOBJ*    psoMirror;
    HSURF       hsurfMirror;

    pmdsurf = (MDSURF*) dhsurf;
    pvdev   = pmdsurf->pvdev;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        psoMirror = pmdsurf->apso[pds->iDispSurf];
        if (psoMirror != NULL)
        {
            // Note that EngDeleteSurface takes care of calling
            // DrvDeleteDeviceBitmap:

            hsurfMirror = psoMirror->hsurf;
            EngUnlockSurface(psoMirror);
            EngDeleteSurface(hsurfMirror);
        }
    }

    // Note that GDI handles the freeing of the hsurfDevice bitmap.

    EngFreeMem(pmdsurf);
}

/******************************Public*Routine******************************\
* HBITMAP MulCreateDeviceBitmap
*
* Screen readers and other clients of the DDML have to be able to watch
* all drawing calls to compatible bitmaps.  
*
\**************************************************************************/

HBITMAP MulCreateDeviceBitmap(           
DHPDEV dhpdev,
SIZEL  sizl,
ULONG  iFormat)
{
    GDIFunctionID(MulCreateDeviceBitmap);

    HSURF       hsurfDevice;
    HSURF       hsurfMirror;
    MDSURF*     pmdsurf;
    VDEV*       pvdev;
    DISPSURF*   pds;
    SURFOBJ*    psoMirror;
    SURFACE*    psurfMirror;
    FLONG       flHooks;

    pvdev = (VDEV*) dhpdev;

    flHooks = 0;

    pmdsurf = NULL;
    hsurfDevice = NULL;

    // First, pass the call to every mirrored driver and see if they 
    // want to create a Mirrored version:
    
    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        PDEVOBJ poThis(pds->hdev);
   
        if ((poThis.flGraphicsCaps() & GCAPS_LAYERED) && 
            PPFNDRV(poThis, CreateDeviceBitmap))
        {
            // We compare to TRUE to allow for the possibility that
            // in the future we'll change the return value to be
            // something other than BOOL.
    
            hsurfMirror = (HSURF) PPFNDRV(poThis, CreateDeviceBitmap)
                                        (poThis.dhpdev(),
                                         sizl,
                                         iFormat);
            if (hsurfMirror)
                psoMirror = EngLockSurface(hsurfMirror);
            else
                psoMirror = NULL;

            if (psoMirror)
            {
                if (pmdsurf == NULL)
                {
                    
                    hsurfDevice = (HSURF) EngCreateBitmap(sizl, 0, iFormat, BMF_TOPDOWN, NULL);
                   
                    pmdsurf = (MDSURF*) EngAllocMem(
                                 FL_ZERO_MEMORY,
                                 sizeof(MDSURF) + pvdev->cSurfaces * sizeof(SURFOBJ*),
                                 'fsVG');
    
                    if ((pmdsurf == NULL) || (hsurfDevice == NULL))
                    {

                        if (pmdsurf != NULL)
                        {
                             EngFreeMem(pmdsurf);
                        }

                        // Failure, so we're outta here...

                        EngUnlockSurface(psoMirror);
                        EngDeleteSurface(hsurfDevice);

                        return((HBITMAP) NULL);

                    }

                    pmdsurf->apso = (SURFOBJ**)
                      ((BYTE*)pmdsurf + sizeof(MDSURF));

                }

                pmdsurf->pvdev = pvdev;
                pmdsurf->apso[pds->iDispSurf] = psoMirror;

                psurfMirror = SURFOBJ_TO_SURFACE_NOT_NULL(psoMirror);

                psurfMirror->vSetMirror();
                psurfMirror->hMirrorParent = hsurfDevice;

                if (!poThis.bIsPalManaged())
                {
                    // Dev bitmap will have device palette. 
                
                    HPALETTE hpalDevice = (HPALETTE) poThis.ppalSurf()->hGet();

                    EPALOBJ palDeviceSurf(hpalDevice);

                    ASSERTGDI(palDeviceSurf.bValid(), "ERROR invalid palette\n");

                    psurfMirror->ppal(palDeviceSurf.ppalGet());

                    // Reference count it by making it not unlocked.

                    palDeviceSurf.ppalSet((PPALETTE)NULL);
                }
            }
        }
    }

    // If any layering driver hooked the call, make our surface opaque
    // so that we can catch all drawing calls.

    if (pmdsurf != NULL)
    {

        SURFREF sr(hsurfDevice);
          
        if (sr.bValid()) 
        {
        
            sr.ps->vSetEngCreateDeviceBitmap();
            sr.ps->iType(STYPE_DEVBITMAP);
   
            sr.ps->so.dhsurf = (DHSURF)pmdsurf;

            flHooks = pvdev->flHooks;

            // DrvCreateDeviceBitmap calls must always 'EngAssociateSurface'
            // the returned bitmap:
             
            EngAssociateSurface(hsurfDevice, pvdev->hdev, flHooks);
        }
    }

    return((HBITMAP) hsurfDevice);
}

#ifdef OPENGL_MM

// ICD calls directly dispatch to real driver in API level, so it bypass DDML.

#else

/******************************Public*Routine******************************\
* BOOL MulSetPixelFormat
*
*
\**************************************************************************/

BOOL MulSetPixelFormat(
SURFOBJ*    pso,
LONG        iPixelFormat,
HWND        hwnd)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;

    BOOL        bRet = FALSE;

    pvdev = (VDEV*) pso->dhpdev;
    pds   = pvdev->pds;
    csurf = pvdev->cSurfaces;

    do {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo, SetPixelFormat))
        {
            bRet = (*PPFNDRV(pdo, SetPixelFormat))(pds->pso,
                                                   iPixelFormat,
                                                   hwnd);
        }

        pds = pds->pdsNext;
    } while (--csurf != 0);

    return(bRet);
}

/******************************Public*Routine******************************\
* LONG MulDescribePixelFormat
*
*
\**************************************************************************/

LONG MulDescribePixelFormat(
DHPDEV                  dhpdev,
LONG                    iPixelFormat,
ULONG                   cjpfd,
PIXELFORMATDESCRIPTOR*  ppfd)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    DHPDEV      dhpdevDriver;

    LONG        lRet = 0;

    pvdev = (VDEV*) dhpdev;
    pds   = pvdev->pds;
    csurf = pvdev->cSurfaces;

    do {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo, DescribePixelFormat))
        {
            dhpdevDriver = pds->pso->dhpdev;

            lRet = (*PPFNDRV(pdo, DescribePixelFormat))(dhpdevDriver,
                                                        iPixelFormat,
                                                        cjpfd,
                                                        ppfd);
        }

        pds = pds->pdsNext;
    } while (--csurf != 0);

    return(lRet);
}

/******************************Public*Routine******************************\
* BOOL MulSwapBuffers
*
*
\**************************************************************************/

BOOL MulSwapBuffers(
SURFOBJ*    pso,
WNDOBJ*     pwo)
{
    PVDEV       pvdev;
    PDISPSURF   pds;
    LONG        csurf;
    BOOL        bRet = FALSE;

    pvdev = (VDEV*) pso->dhpdev;
    pds   = pvdev->pds;
    csurf = pvdev->cSurfaces;

    do {
        PDEVOBJ pdo(pds->hdev);
        if (PPFNVALID(pdo, SwapBuffers))
        {
            bRet = (*PPFNDRV(pdo, SwapBuffers))(pds->pso,
                                                pwo);
        }

        pds = pds->pdsNext;
    } while (--csurf != 0);

    return(bRet);
}

#endif // #ifdef OPENGL_MM

/******************************Public*Routine******************************\
* BOOL MulTextOut
*
* WARNING - WHEN OPTIMIZING
*
* When optimizing for one driver, remember that you'll still
* have to set the psurf on brushes to the driver's surface.
* Otherwise, you'll get a callback for DrvRealizeBrush.
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ  *pso,
STROBJ   *pstro,
FONTOBJ  *pfo,
CLIPOBJ  *pco,
RECTL    *prclExtra,
RECTL    *prclOpaque,
BRUSHOBJ *pboFore,
BRUSHOBJ *pboOpaque,
POINTL   *pptlOrg,
MIX       mix)
{
    PVDEV   pvdev = (VDEV*) pso->dhpdev;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    ULONG   cgposCopied;
    RECTL   rclOpaque;

    ASSERTGDI((pboFore->iSolidColor != (ULONG) -1) &&
              (pboOpaque->iSolidColor != (ULONG) -1),
              "Didn't expect patterned brush");

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngTextOut(mDst.pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore,
                          pboOpaque, pptlOrg, mix);
    }

    MULTIBRUSH  MBRUSH_Fore(pboFore, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH_Fore.Valid())
    {
        return (FALSE);
    }

    MULTIBRUSH  MBRUSH_Opaque(pboOpaque, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH_Opaque.Valid())
    {
        return (FALSE);
    }

    MULTIFONT   MFONT(pfo, pvdev->cSurfaces, pvdev);
    if (!MFONT.Valid())
    {
        return (FALSE);
    }

    RECTL*      prclBounds = (prclOpaque != NULL)
                           ? prclOpaque
                           : &pstro->rclBkGround;

    cgposCopied = ((ESTROBJ*)pstro)->cgposCopied;

    rclOpaque = *prclBounds;

    if (msurf.bFindSurface(pso, pco, prclBounds))
    {
        do {
            STROBJ_vEnumStart(pstro);

            MFONT.LoadElement(msurf.pds->iDispSurf);
            MBRUSH_Fore.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));
            MBRUSH_Opaque.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            ((ESTROBJ*)pstro)->cgposCopied = cgposCopied;

            // Some drivers modify 'prclOpaque', so always pass them a copy:

            *prclBounds = rclOpaque;

            bRet &= OffTextOut(PPFNMGET(msurf, TextOut),
                               msurf.pOffset,
                               msurf.pso,
                               pstro,
                               pfo,
                               msurf.pco,
                               prclExtra,
                               prclOpaque,
                               pboFore,
                               pboOpaque,
                               pptlOrg,
                               mix);

            MBRUSH_Fore.StoreElement(msurf.pds->iDispSurf);
            MBRUSH_Opaque.StoreElement(msurf.pds->iDispSurf);
            MFONT.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulStrokePath
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pbo,
POINTL    *pptlBrushOrg,
LINEATTRS *pla,
MIX        mix)
{
    PVDEV       pvdev = (VDEV*) pso->dhpdev;
    BOOL        bRet = TRUE;
    FLOAT_LONG  elStyleState = pla->elStyleState;
    MSURF       msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngStrokePath(mDst.pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix);
    }

    MULTIBRUSH  MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    // Get the path bounds and make it lower-right exclusive:

    RECTL   rclDst;
    RECTFX  rcfxBounds;
    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclDst.left   = (rcfxBounds.xLeft   >> 4);
    rclDst.top    = (rcfxBounds.yTop    >> 4);
    rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

    if (msurf.bFindSurface(pso, pco, &rclDst))
    {
        do {
            PATHOBJ_vEnumStart(ppo);
            pla->elStyleState = elStyleState;
            MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffStrokePath(PPFNMGET(msurf, StrokePath),
                                  msurf.pOffset,
                                  msurf.pso,
                                  ppo,
                                  msurf.pco,
                                  pxo,
                                  pbo,
                                  pptlBrushOrg,
                                  pla,
                                  mix);

            MBRUSH.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulFillPath
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ  *pso,
PATHOBJ  *ppo,
CLIPOBJ  *pco,
BRUSHOBJ *pbo,
POINTL   *pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    PVDEV   pvdev = (VDEV*) pso->dhpdev;
    BOOL    bRet = TRUE;
    MSURF   msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngFillPath(mDst.pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
    }

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mix));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    // Get the path bounds and make it lower-right exclusive:

    RECTL   rclDst;
    RECTFX  rcfxBounds;
    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclDst.left   = (rcfxBounds.xLeft   >> 4);
    rclDst.top    = (rcfxBounds.yTop    >> 4);
    rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

    if (msurf.bFindSurface(pso, pco, &rclDst))
    {
        do {
            PATHOBJ_vEnumStart(ppo);
            MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffFillPath(PPFNMGET(msurf, FillPath),
                                msurf.pOffset,
                                msurf.pso,
                                ppo,
                                msurf.pco,
                                pbo,
                                pptlBrushOrg,
                                mix,
                                flOptions);

            MBRUSH.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulStrokeAndFillPath
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulStrokeAndFillPath(
SURFOBJ   *pso,
PATHOBJ   *ppo,
CLIPOBJ   *pco,
XFORMOBJ  *pxo,
BRUSHOBJ  *pboStroke,
LINEATTRS *pla,
BRUSHOBJ  *pboFill,
POINTL    *pptlBrushOrg,
MIX        mixFill,
FLONG      flOptions)
{
    PVDEV       pvdev = (VDEV*) pso->dhpdev;
    BOOL        bRet = TRUE;
    FLOAT_LONG  elSavedStyleState = pla->elStyleState;
    MSURF       msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso);

        bRet = EngStrokeAndFillPath(mDst.pso, ppo, pco, pxo, pboStroke, pla, pboFill,
                                    pptlBrushOrg, mixFill, flOptions);
    }

    MULTIBRUSH  MBRUSH_Stroke(pboStroke, pvdev->cSurfaces, pvdev, pvdev->pso, FALSE);
    if (!MBRUSH_Stroke.Valid())
    {
        return FALSE;
    }

    MULTIBRUSH  MBRUSH_Fill(pboFill, pvdev->cSurfaces, pvdev, pvdev->pso, MIX_NEEDS_PATTERN(mixFill));
    if (!MBRUSH_Fill.Valid())
    {
        return FALSE;
    }

    // Get the path bounds and make it lower-right exclusive:

    RECTL   rclDst;
    RECTFX  rcfxBounds;
    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclDst.left   = (rcfxBounds.xLeft   >> 4);
    rclDst.top    = (rcfxBounds.yTop    >> 4);
    rclDst.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclDst.bottom = (rcfxBounds.yBottom >> 4) + 2;

    if (msurf.bFindSurface(pso, pco, &rclDst))
    {
        do {
            pla->elStyleState = elSavedStyleState;
            PATHOBJ_vEnumStart(ppo);
            MBRUSH_Stroke.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));
            MBRUSH_Fill.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffStrokeAndFillPath(PPFNMGET(msurf, StrokeAndFillPath),
                                         msurf.pOffset,
                                         msurf.pso,
                                         ppo,
                                         msurf.pco,
                                         pxo,
                                         pboStroke,
                                         pla,
                                         pboFill,
                                         pptlBrushOrg,
                                         mixFill,
                                         flOptions);

            MBRUSH_Stroke.StoreElement(msurf.pds->iDispSurf);
            MBRUSH_Fill.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulLineTo
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix)
{
    PVDEV   pvdev = (VDEV*) pso->dhpdev;
    BOOL    bRet = TRUE;
    MSURF   msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso,prclBounds);

        bRet = EngLineTo(mDst.pso, pco, pbo, x1, y1, x2, y2, mDst.prcl, mix);
    }

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, FALSE);
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    if (msurf.bFindSurface(pso, pco, prclBounds))
    {
        do {
            MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

            bRet &= OffLineTo(PPFNMGET(msurf, LineTo),
                              msurf.pOffset,
                              msurf.pso,
                              msurf.pco,
                              pbo,
                              x1,
                              y1,
                              x2,
                              y2,
                              prclBounds,
                              mix);

            MBRUSH.StoreElement(msurf.pds->iDispSurf);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulGradientFill
*
* History:
*  23-Apr-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

BOOL MulGradientFill(
SURFOBJ     *pso,
CLIPOBJ     *pco,
XLATEOBJ    *pxlo,
TRIVERTEX   *pVertex,
ULONG        nVertex,
PVOID        pMesh,
ULONG        nMesh,
RECTL       *prclExtents,
POINTL      *pptlDitherOrg,
ULONG        ulMode)
{
    PVDEV     pvdev = (VDEV*) pso->dhpdev;
    XLATEOBJ *pxloSave = pxlo;
    BOOL      bRet = TRUE;
    MSURF     msurf;

    if (pso->iType == STYPE_DEVBITMAP)
    {
        // Handle drawing to 'master' device bitmap:
        MULTISURF mDst(pso,prclExtents);

        bRet = EngGradientFill(mDst.pso, pco, pxlo, pVertex, nVertex, pMesh, nMesh,
                               mDst.prcl, pptlDitherOrg, ulMode);
    }

    if (msurf.bFindSurface(pso, pco, prclExtents))
    {
         do {
             
             PSURFACE pSurfDest = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
             EXLATEOBJ xloDevice;
 
             // if the target surface is not compatible to primary surface,
             // create XLATEOBJ for source surface to target. otherwise
             // we can just use given XLATEOBJ.
 
             if (pSurfDest->iFormat() > BMF_8BPP) 
             {
                 // 16bpp or above do not require a translation object.

                 pxlo = NULL;
             } 
             else if (msurf.pds->iCompatibleColorFormat != 0)
             {
                 XLATE    *pxloM         = (XLATE *) pxlo;
                 PPALETTE  ppalDestDC    = ppalDefault;
                 PPALETTE  ppalSurfSrc   = gppalRGB;

                 PDEVOBJ pdo(msurf.pds->hdev);

                 if (pdo.bIsPalManaged())
                 {
                     // Use halftone palette for pal-managed device.

                     ppalDestDC = REALIZE_HALFTONE_PALETTE(pdo.hdev());
                 }
 
                 if (xloDevice.bInitXlateObj(
                             (pxloM ? pxloM->hcmXform : NULL),
                             (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                             ppalSurfSrc,       // Source palette
                             pSurfDest->ppal(), // Destination palette
                             ppalDestDC,        // Source DC palette
                             ppalDestDC,        // Destination DC palette
                             (pxloM ? pxloM->iForeDst : 0x0L),
                             (pxloM ? pxloM->iBackDst : 0x0L),
                             (pxloM ? pxloM->iBackSrc : 0x0L),
                             0))
                 {
                     pxlo = xloDevice.pxlo();
                 }
             }

             bRet &= OffGradientFill(PPFNMGET(msurf, GradientFill),
                                    msurf.pOffset,
                                    msurf.pso,
                                    msurf.pco,
                                    pxlo,
                                    pVertex,
                                    nVertex,
                                    pMesh,
                                    nMesh,
                                    prclExtents,
                                    pptlDitherOrg,
                                    ulMode);

             // Restore XLATEOBJ
 
             pxlo = pxloSave;
             
        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulStretchBlt
*
* History:
*   1-May-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

BOOL MulStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    GDIFunctionID(MulStretchBlt);

    XLATEOBJ *pxloSave = pxlo;
    
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    SURFMEM  srcCopy;
    PSURFACE pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);
    PDEVOBJ  pdoSrc(pSurfSrc->hdev());
    RECTL    rclSrcCopy = *prclSrc;     

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() && 
        pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclSrcCopy ))
            return FALSE; 
        
        if(srcCopy.ps == NULL) 
        {
            // We didn't get to the point of creating the surface 
            // becasue the rect was out of bounds. 
            return TRUE; 
        }

        prclSrc = &rclSrcCopy; 
        psoSrc  = srcCopy.pSurfobj();         
        pSurfSrc= SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);
        pdoSrc.vInit(pSurfSrc->hdev());
    }

    //
    // Inverting stretches are a pain because 'bFindSurface' doesn't
    // understand poorly ordered rectangles.  So we'll make yet 
    // another copy of the source in this case. 
    //

    SURFMEM  srcInv; 
    RECTL    rclDstCopy;
    
    PPALETTE ppalSrc  = pSurfSrc->ppal(); 
    
    if ((prclDst->left >= prclDst->right) || 
        (prclDst->top >= prclDst->bottom))
    {
        DEVBITMAPINFO   dbmi;

        RECTL rclSrcClip = *prclSrc; 

        if( rclSrcClip.left < 0 )
        {
            rclSrcClip.left = 0; 
        }
        if( rclSrcClip.right > pSurfSrc->sizl().cx ) 
        {
            rclSrcClip.right = pSurfSrc->sizl().cx;
        }
        if( rclSrcClip.top < 0 ) 
        {
            rclSrcClip.top = 0;
        }
        if( rclSrcClip.bottom > pSurfSrc->sizl().cy ) 
        {
            rclSrcClip.bottom = pSurfSrc->sizl().cy; 
        }

        if( (rclSrcClip.right <= rclSrcClip.left) || 
            (rclSrcClip.bottom <= rclSrcClip.top ) )
        {
            return TRUE; 
        }

        dbmi.cxBitmap = rclSrcClip.right - rclSrcClip.left;
        dbmi.cyBitmap = rclSrcClip.bottom - rclSrcClip.top;
        dbmi.hpal     = ppalSrc ? ((HPALETTE) ppalSrc->hGet()) : 0;
        dbmi.iFormat  = pSurfSrc->iFormat();
        dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

        srcInv.bCreateDIB(&dbmi, (VOID *) NULL);

        if (!srcInv.bValid())
             return(FALSE);

        rclSrcCopy.left   -= rclSrcClip.left; 
        rclSrcCopy.right  -= rclSrcClip.left; 
        rclSrcCopy.top    -= rclSrcClip.top; 
        rclSrcCopy.bottom -= rclSrcClip.top; 

        RECTL rclInv;

        // Setup for x-inversion

        if( prclDst->left >= prclDst->right ) 
        {
            rclDstCopy.left = prclDst->right; 
            rclDstCopy.right= prclDst->left; 
            
            rclInv.left  = rclSrcCopy.right; 
            rclInv.right = rclSrcCopy.left; 
        }
        else
        {
            rclDstCopy.left = prclDst->left; 
            rclDstCopy.right= prclDst->right; 
        
            rclInv.left  = rclSrcCopy.left; 
            rclInv.right = rclSrcCopy.right; 
        }

        // Setup for y-inversion 

        if( prclDst->top >= prclDst->bottom ) 
        {
            rclDstCopy.top = prclDst->bottom; 
            rclDstCopy.bottom = prclDst->top; 
            
            rclInv.top  = rclSrcCopy.bottom; 
            rclInv.bottom = rclSrcCopy.top; 
        }
        else
        {
            rclDstCopy.top = prclDst->top; 
            rclDstCopy.bottom = prclDst->bottom; 
            
            rclInv.top  = rclSrcCopy.top; 
            rclInv.bottom = rclSrcCopy.bottom; 
        }

        // Do the actual inversion

        if(!EngStretchBlt(srcInv.pSurfobj(), psoSrc, NULL, (CLIPOBJ *)NULL, &xloIdent, NULL,
                             NULL, &rclInv, prclSrc, NULL, COLORONCOLOR))
            return FALSE;

        prclSrc  = &rclSrcCopy; 
        prclDst  = &rclDstCopy; 
    
        psoSrc   = srcInv.pSurfobj();         
        pSurfSrc = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc); 
        pdoSrc.vInit(pSurfSrc->hdev());
    }

    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDst);

    // WINBUG #298689 4-4-2001 jasonha  Handle multi-device stretches
    MULTISURF   mSrc(psoSrc, prclSrc);

    //
    // If the destination is a Device Bitmap, we must draw to 
    // the master DIB also. 
    // 

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst,prclDst); 
        bRet = EngStretchBlt(mDst.pso, mSrc.pso, psoMask, pco, pxlo, pca,
                             pptlHTOrg, mDst.prcl, mSrc.prcl, pptlMask, iMode);
    }

    if (bMultiDst)
    {
        do {

            BOOL bError;

            EXLATEOBJ xloDevice;

            PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);

            bError = !mSrc.bLoadSource(msurf.pds);

            if (bError == FALSE)
            {
                pSurfSrc = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso); 
                ppalSrc = pSurfSrc->ppal();

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;                                
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulStretchBlt(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvStretchBlt pfn = PPFNMGET(msurf, StretchBlt);                

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 

                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                }

                // 
                // If the driver does not support halftoning we call Eng
                //

                if( iMode == HALFTONE ) 
                {
                    PDEVOBJ pdoTrg(pSurfDst->hdev()); 

                    if (!(pdoTrg.flGraphicsCapsNotDynamic() & GCAPS_HALFTONE))
                        pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                }

                // Don't call the driver if the source rectangle exceeds the source
                // surface. Some drivers punt using a duplicate of the source
                // SURFOBJ, but without preserving its sizlBitmap member.
                // This causes a source clipping bug (77102).       

                if((mSrc.prcl->left < 0) || 
                   (mSrc.prcl->top  < 0) ||
                   (mSrc.prcl->right  > mSrc.pso->sizlBitmap.cx) ||
                   (mSrc.prcl->bottom > mSrc.pso->sizlBitmap.cy))
                {
                    pfn = (PFN_DrvStretchBlt)EngStretchBlt;
                }

                bRet &= OffStretchBlt(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      &gptlZero,
                                      mSrc.pso,
                                      psoMask,
                                      msurf.pco,
                                      pxlo,
                                      pca,
                                      pptlHTOrg,
                                      prclDst,
                                      mSrc.prcl,
                                      pptlMask,
                                      iMode);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL MulAlphaBlend
*
* History:
*   17-dec-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************************************/

BOOL MulAlphaBlend(
SURFOBJ       *psoDst,
SURFOBJ       *psoSrc,
CLIPOBJ       *pco,
XLATEOBJ      *pxlo,
RECTL         *prclDst,
RECTL         *prclSrc,
BLENDOBJ      *pBlendObj)
{
    GDIFunctionID(MulAlphaBlend);

    XLATEOBJ *pxloSave       = pxlo;
    XLATEOBJ *pxloSaveDCto32 = ((EBLENDOBJ*)pBlendObj)->pxloDstTo32;
    XLATEOBJ *pxloSave32toDC = ((EBLENDOBJ*)pBlendObj)->pxlo32ToDst;
    XLATEOBJ *pxloSaveSrcTo32 = ((EBLENDOBJ*)pBlendObj)->pxloSrcTo32;
 
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    SURFMEM  srcCopy;
    PDEVOBJ  pdoSrc(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    RECTL    rclCopy = *prclSrc; 

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() && 
        pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclCopy ))
            return FALSE; 
        
        if(srcCopy.ps == NULL ) 
        {
            // We didn't get to the point of creating the surface 
            // becasue the rect was out of bounds. 
            return TRUE; 
        }


        prclSrc = &rclCopy; 
        psoSrc  = srcCopy.pSurfobj(); 
        pdoSrc.vInit(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    }
 
    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDst);

    MULTISURF mSrc(psoSrc,prclSrc);

    //
    // If the destination is a Device Bitmap, we must draw to
    // the master DIB also.
    //

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst,prclDst);

        bRet = EngAlphaBlend(mDst.pso, mSrc.pso, pco, pxlo, mDst.prcl,
                             mSrc.prcl, pBlendObj);
    }

    if (bMultiDst)
    {
        do {

            BOOL bError = FALSE;

            EXLATEOBJ xloDevice;
            EXLATEOBJ xloDstDCto32; 
            EXLATEOBJ xlo32toDstDC; 
            EXLATEOBJ xloSrcTo32; 

            XEPALOBJ  palRGB(gppalRGB);

            bError = !mSrc.bLoadSource(msurf.pds);

            PSURFACE pSurfDst = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
            PSURFACE pSurfSrc;

            if (bError == FALSE)
            {
                pSurfSrc = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulAlphaBlend(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        ULONG iForeDst; 
                   
                        if( pxloM ) 
                        {
                            iForeDst = pxloM->iForeDst; 
                        }
                        else
                        {
                            iForeDst = 0x0L; 
                        }

                        ULONG iBackDst; 

                        if( pxloM ) 
                        {
                            iBackDst = pxloM->iBackDst; 
                        }
                        else
                        {
                            iBackDst = 0x0L; 
                        }

                        ULONG iBackSrc; 

                        if( pxloM ) 
                        {
                            iBackSrc = pxloM->iBackSrc; 
                        }
                        else
                        {
                            iBackSrc = 0x0L; 
                        }

                        //
                        // Src to Dst 
                        // 

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    iForeDst,
                                    iBackDst,
                                    iBackSrc,
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }

                        //
                        // Dst to 32 
                        // 

                        if ((bError == FALSE) &&
                             xloDstDCto32.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        pSurfDst->ppal(),
                                        palRGB,
                                        ppalDestDC,
                                        ppalDestDC,
                                        iForeDst,
                                        iBackDst,
                                        iBackSrc))
                        {
                            ((EBLENDOBJ*)pBlendObj)->pxloDstTo32 = xloDstDCto32.pxlo(); 
                        }
                        else
                        {
                            bError = TRUE; 
                        }                    

                        //
                        // 32 to Dst
                        //

                        if ((bError == FALSE) &&
                             xlo32toDstDC.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        palRGB,
                                        pSurfDst->ppal(),
                                        ppalDestDC,
                                        ppalDestDC,
                                        iForeDst,
                                        iBackDst,
                                        iBackSrc))
                        {
                            ((EBLENDOBJ*)pBlendObj)->pxlo32ToDst = xlo32toDstDC.pxlo();
                        }
                        else
                        {
                            bError = TRUE; 
                        }
                    
                        //
                        // Src to 32
                        //

                        if ((bError == FALSE) &&
                            (mSrc.pso != psoSrc))
                        {
                            if (xloSrcTo32.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            pSurfSrc->ppal(),
                                            palRGB,
                                            ppalDefault,
                                            ppalDestDC,
                                            iForeDst,
                                            iBackDst,
                                            iBackSrc))
                            {
                                ((EBLENDOBJ*)pBlendObj)->pxloSrcTo32 = xloSrcTo32.pxlo(); 
                            }
                            else
                            {
                                bError = TRUE; 
                            }                    
                        }
                    }
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvAlphaBlend pfn = PPFNMGET(msurf, AlphaBlend); 

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 
                
                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvAlphaBlend)EngAlphaBlend;
                }

                bRet &= OffAlphaBlend(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      &gptlZero,
                                      mSrc.pso,
                                      msurf.pco,
                                      pxlo,
                                      prclDst,
                                      mSrc.prcl,
                                      pBlendObj);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;
            ((EBLENDOBJ*)pBlendObj)->pxloDstTo32 = pxloSaveDCto32;
            ((EBLENDOBJ*)pBlendObj)->pxlo32ToDst = pxloSave32toDC;
            ((EBLENDOBJ*)pBlendObj)->pxloSrcTo32 = pxloSaveSrcTo32;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulTransparentBlt
*
* History:
*   22-Dec-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************************************/

BOOL MulTransparentBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDst,
RECTL*              prclSrc,
ULONG               TransColor,
ULONG               ulReserved)
{
    GDIFunctionID(MulTransparentBlt);

    XLATEOBJ *pxloSave = pxlo;
    ULONG     TransColorSave = TransColor;

    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    SURFMEM  srcCopy;
    PDEVOBJ  pdoSrc(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    RECTL    rclCopy = *prclSrc; 

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() && 
        pdoSrc.bMetaDriver())
    {
        if(!MulCopyDeviceToDIB( psoSrc, &srcCopy, &rclCopy ))
            return FALSE; 
        
        if(srcCopy.ps == NULL ) 
        {
            // We didn't get to the point of creating the surface 
            // becasue the rect was out of bounds. 
            return TRUE; 
        }

        prclSrc = &rclCopy; 
        psoSrc  = srcCopy.pSurfobj(); 
        pdoSrc.vInit(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());
    }

    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDst);

    MULTISURF mSrc(psoSrc,prclSrc);

    //
    // If the destination is a Device Bitmap, we must draw to 
    // the master DIB also. 
    // 

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst,prclDst);

        bRet = EngTransparentBlt(mDst.pso, mSrc.pso, pco, pxlo, 
                                 mDst.prcl, mSrc.prcl, TransColor, ulReserved);
    }

    if (bMultiDst)
    {
        do {

            BOOL bError = FALSE;

            EXLATEOBJ xloDevice;

            bError = !mSrc.bLoadSource(msurf.pds);

            PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
            PSURFACE  pSurfSrc; 

            if (bError == FALSE)
            {
                pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulTransparent(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }
                }

                if (mSrc.pso != psoSrc)
                {
                    PSURFACE    pSurfSrcOrg = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);

                    TransColor =
                        ulGetNearestIndexFromColorref(
                            pSurfSrc->ppal(),
                            ppalDefault,
                            ulIndexToRGB(
                                pSurfSrcOrg->ppal(),
                                ppalDefault,
                                TransColor),
                            SE_DO_SEARCH_EXACT_FIRST);
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvTransparentBlt pfn = PPFNMGET(msurf, TransparentBlt); 

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 
                
                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvTransparentBlt)EngTransparentBlt;
                }

                bRet &= OffTransparentBlt(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      &gptlZero,
                                      mSrc.pso,                                
                                      msurf.pco,
                                      pxlo,
                                      prclDst,
                                      mSrc.prcl,
                                      TransColor,
                                      ulReserved);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;
            TransColor = TransColorSave;

        } while (msurf.bNextSurface());
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL MulDrawStream
*
* 1-27-2001 bhouse
* Wrote it.
*
\**************************************************************************/

BOOL MulDrawStream(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDstBounds,
POINTL*             pptlDstOffset,
ULONG               ulIn,
PVOID               pvIn,
DSSTATE*            pdss)
{
    GDIFunctionID(MulDrawStream);

    XLATEOBJ *      pxloSave = pxlo;
    PDRAWSTREAMINFO pdsi = (PDRAWSTREAMINFO) pdss;
    XLATEOBJ *      pxloSaveDstToBGRA = pdsi->pxloDstToBGRA;
    XLATEOBJ *      pxloSaveBGRAToDst = pdsi->pxloBGRAToDst;
    XLATEOBJ *      pxloSaveSrcToBGRA = pdsi->pxloSrcToBGRA;
    COLORREF        crSaveColorKey    = pdsi->dss.crColorKey;
    
    // 
    // We cannot handle cases where the source is a meta, 
    // so make a copy in this case. 
    // 

    PDEVOBJ  pdoSrc(SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->hdev());

    if( psoSrc->iType == STYPE_DEVICE && pdoSrc.bValid() &&  
        pdoSrc.bMetaDriver())
    {
        DbgPrint("MulDrawStream: this should never happen\n");
        return TRUE;
    }

    PVDEV   pvdev = (VDEV*) psoDst->dhpdev;
    USHORT  iDstType = psoDst->iType;
    BOOL    bMultiDst;
    BOOL    bRet = TRUE;
    MSURF   msurf;
    RECTL   rclDst;
    RECTL   rclSrc;

    ASSERTGDI(iDstType != STYPE_BITMAP, "BITMAP destination\n");

    bMultiDst = msurf.bFindSurface(psoDst, pco, prclDstBounds);

    MULTISURF mSrc(psoSrc);
    //
    // If the destination is a Device Bitmap, we must draw to 
    // the master DIB also. 
    // 

    if (iDstType == STYPE_DEVBITMAP)
    {
        MULTISURF mDst(psoDst);
        bRet = EngDrawStream(mDst.pso, mSrc.pso, pco, pxlo, 
                    prclDstBounds, pptlDstOffset, ulIn, pvIn, pdss);
    }

    // TODO bhouse
    // Need to fix translates in pdsi

    if (bMultiDst)
    {
        do {

            BOOL bError = FALSE;

            EXLATEOBJ xloDevice;
            EXLATEOBJ xloDstToBGRA; 
            EXLATEOBJ xloBGRAToDst; 
            EXLATEOBJ xloSrcToBGRA; 

            XEPALOBJ  palRGB(gppalRGB);
            
            bError = !mSrc.bLoadSource(msurf.pds);

            PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
            PSURFACE  pSurfSrc;

            if (bError == FALSE)
            {
                pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if (msurf.pds->iCompatibleColorFormat != 0)
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulDrawStream(): ppalSrc is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    
                        if ((bError == FALSE) &&
                             xloDstToBGRA.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        pSurfDst->ppal(),
                                        palRGB,
                                        ppalDestDC,
                                        ppalDestDC,
                                        (pxloM ? pxloM->iForeDst : 0x0L),
                                        (pxloM ? pxloM->iBackDst : 0x0L),
                                        (pxloM ? pxloM->iBackSrc : 0x0L)))
                        {
                            pdsi->pxloDstToBGRA = xloDstToBGRA.pxlo(); 
                        }
                        else
                        {
                            bError = TRUE; 
                        }                    

                        //
                        // 32 to Dst
                        //

                        if ((bError == FALSE) &&
                             xloBGRAToDst.bInitXlateObj(
                                        NULL,
                                        DC_ICM_OFF,
                                        palRGB,
                                        pSurfDst->ppal(),
                                        ppalDestDC,
                                        ppalDestDC,
                                        (pxloM ? pxloM->iForeDst : 0x0L),
                                        (pxloM ? pxloM->iBackDst : 0x0L),
                                        (pxloM ? pxloM->iBackSrc : 0x0L)))
                        {
                            pdsi->pxloBGRAToDst = xloBGRAToDst.pxlo();
                        }
                        else
                        {
                            bError = TRUE; 
                        }
                    
                        if ((bError == FALSE) &&
                            (mSrc.pso != psoSrc))
                        {
                            //
                            // Src to 32
                            //

                            if (xloSrcToBGRA.bInitXlateObj(
                                            NULL,
                                            DC_ICM_OFF,
                                            pSurfSrc->ppal(),
                                            palRGB,
                                            ppalDefault,
                                            ppalDestDC,
                                            (pxloM ? pxloM->iForeDst : 0x0L),
                                            (pxloM ? pxloM->iBackDst : 0x0L),
                                            (pxloM ? pxloM->iBackSrc : 0x0L)))
                            {
                                pdsi->pxloSrcToBGRA = xloSrcToBGRA.pxlo();
                            }
                            else
                            {
                                bError = TRUE;
                            }

                            if (bError == FALSE)
                            {
                                PSURFACE    pSurfSrcOrg = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);

                                pdsi->dss.crColorKey =
                                    ulGetNearestIndexFromColorref(
                                        pSurfSrc->ppal(),
                                        ppalDefault,
                                        ulIndexToRGB(
                                            pSurfSrcOrg->ppal(),
                                            ppalDefault,
                                            pdsi->dss.crColorKey),
                                        SE_DO_SEARCH_EXACT_FIRST);
                            }
                        }
                    }
                }
            }

            if (bError == FALSE)
            {
                PFN_DrvDrawStream pfn = PPFNDRVENG(msurf.pds->po, DrawStream);

                //
                // If the source is also a device surface, it must correspond
                // to one of the drivers. In this case, call Eng if the 
                // same driver does not manage the source and the destination
                // 
                
                if( mSrc.pso->iType == STYPE_DEVICE && 
                    (pSurfSrc->hdev() != pSurfDst->hdev()))
                {
                    pfn = (PFN_DrvDrawStream) EngDrawStream;
                }

                bRet &= OffDrawStream(pfn,
                                      msurf.pOffset,
                                      msurf.pso,
                                      mSrc.pso,                                
                                      msurf.pco,
                                      pxlo,
                                      prclDstBounds,
                                      pptlDstOffset,
                                      ulIn,
                                      pvIn,
                                      pdss);
            }
            else
            {
                bRet = FALSE;
            }

            // Restore XLATEOBJ

            pxlo = pxloSave;
            pdsi->pxloBGRAToDst = pxloSaveBGRAToDst;
            pdsi->pxloDstToBGRA = pxloSaveDstToBGRA;
            pdsi->pxloSrcToBGRA = pxloSaveSrcToBGRA;
            pdsi->dss.crColorKey = crSaveColorKey;


        } while (msurf.bNextSurface());
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL bSrcBeforeDst
*
* This function determines if the source rectangle, offset by dx and dy,
* will intersect the destination rectangle.  In other words, the source
* will be required to do the blt to the destination.  This means that the
* blt must be done to the destination before the blt to the source so that
* the source bits are not overwritten before they're used.
*
* History:
*  25-Apr-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

inline BOOL bSrcBeforeDst(
RECTL*  prclDst,
RECTL*  prclSrc,
LONG    dx,
LONG    dy)
{
    return((prclDst->left   < dx + prclSrc->right)  &&
           (prclDst->right  > dx + prclSrc->left)   &&
           (prclDst->top    < dy + prclSrc->bottom) &&
           (prclDst->bottom > dy + prclSrc->top));
}

/******************************Public*Routine******************************\
* VOID vSortBltOrder
*
* This function sorts the list of surfaces for the correct ordering on
* screen-to-screen blts that span boards.
*
* When this routine is done, 'pvdev->pdsBlt' will point to the first
* surface that should be processed, and each surface's 'pdsBltNext'
* field will point to the next one in order.
*
* History:
*  25-Apr-1996 -by- Tom Zakrajsek [tomzak]
* Wrote it.
*
\**************************************************************************/

VOID vSortBltOrder(
VDEV*   pvdev,
LONG    dx,
LONG    dy)
{
    DISPSURF* pdsBltHeadOld = pvdev->pdsBlt;
    DISPSURF* pdsBltHeadNew = pdsBltHeadOld;

    pdsBltHeadOld = pdsBltHeadOld->pdsBltNext;
    pdsBltHeadNew->pdsBltNext = NULL;

    while (pdsBltHeadOld)
    {
        DISPSURF * pdsBltInsert = pdsBltHeadOld;
        DISPSURF * pdsBltPrev = pdsBltHeadNew;
        DISPSURF * pdsBltCur = pdsBltHeadNew;

        pdsBltInsert = pdsBltHeadOld;
        pdsBltHeadOld = pdsBltHeadOld->pdsBltNext;

        while((pdsBltCur) &&
              (!bSrcBeforeDst(&pdsBltInsert->rcl,    // Dst
                              &pdsBltCur->rcl,       // Src
                              dx,
                              dy)))
        {
            pdsBltPrev = pdsBltCur;
            pdsBltCur = pdsBltCur->pdsBltNext;
        }

        if (pdsBltCur == pdsBltHeadNew)
        {
            pdsBltHeadNew = pdsBltInsert;
            pdsBltInsert->pdsBltNext = pdsBltCur;
        }
        else
        {
            pdsBltPrev->pdsBltNext = pdsBltInsert;
            pdsBltInsert->pdsBltNext = pdsBltCur;
        }
    }

    pvdev->pdsBlt = pdsBltHeadNew;
}

/******************************Public*Routine******************************\
* BOOL bBitBltScreenToScreen
*
* Handles screen-to-screen blts that may possibly span multiple displays.
*
\**************************************************************************/

BOOL bBitBltScreenToScreen(
SURFOBJ  *pso,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4)
{
    VDEV*       pvdev;
    LONG        dx;
    LONG        dy;
    DISPSURF*   pdsDst;
    DISPSURF*   pdsSrc;
    SURFOBJ*    psoDst;
    SURFOBJ*    psoSrc;
    POINTL*     pOffDst;
    POINTL*     pOffSrc;
    RECTL       rclDst;
    POINTL      ptlSrc;
#if _MSC_VER < 1300
    DHSURF      dhsurfSave;
    DHPDEV      dhpdevSave;
#endif
    SIZEL       sizl;
    HSURF       hsurfTmp;
    SURFOBJ*    psoTmp;
    RECTL       rclDstTmp;
    BOOL        bRet;
    RECTL       rclSaveBounds;

    bRet = TRUE;

    pvdev = (VDEV*) pso->dhpdev;

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top - pptlSrc->y;

    vSortBltOrder(pvdev, dx, dy);

    XLATEOBJ *pxloSave = pxlo;

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, ROP4_NEEDS_PATTERN(rop4));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    if (pco != NULL)
    {
        rclSaveBounds = pco->rclBounds;
    }

    BOOL bWndBltNotify = (pso != NULL) && (pso->fjBitmap & BMF_WINDOW_BLT);

    for (pdsDst = pvdev->pdsBlt; pdsDst != NULL; pdsDst = pdsDst->pdsBltNext)
    {
        for (pdsSrc = pdsDst; pdsSrc != NULL; pdsSrc = pdsSrc->pdsBltNext)
        {
            rclDst.left   = dx + pdsSrc->rcl.left;
            rclDst.right  = dx + pdsSrc->rcl.right;
            rclDst.top    = dy + pdsSrc->rcl.top;
            rclDst.bottom = dy + pdsSrc->rcl.bottom;

            if (bIntersect(prclDst, &rclDst, &rclDst) &&
                bIntersect(&rclDst, &pdsDst->rcl, &rclDst))
            {
                ptlSrc.x = rclDst.left - dx;
                ptlSrc.y = rclDst.top  - dy;

                psoSrc = pdsSrc->pso;
                psoDst = pdsDst->pso;

                pOffSrc = &pdsSrc->Off;
                pOffDst = &pdsDst->Off;

#if _MSC_VER < 1300
                dhpdevSave = NULL;
#endif
                hsurfTmp   = NULL;

                if (psoSrc == psoDst)
                {
                    // This simply amounts to a screen-to-screen blt on
                    // the same surface.
                }
                else if ((!pdsSrc->bIsReadable) ||
                         (bIntersect(&pdsSrc->rcl, &pdsDst->rcl)))
                {
                    // If the source surface isn't readable, or if the two
                    // surfaces overlap (such as can happen when two display
                    // cards are echoing the same output), don't use the
                    // source as a destination for updating the display.  We
                    // need to do this otherwise when we do a screen-to-
                    // screen blt with a mirroring driver in the background,
                    // we'll think that the mirrored surface has to be blt
                    // to the screen -- but the read of the surface will
                    // fail and we'll end up blting blackness.

                    psoSrc = NULL;
                }
                else
                {
                    // This blt has to happen across boards, and the source
                    // bits aren't directly readable.  We'll have to create
                    // a temporary buffer and make a copy:

                    sizl.cx = rclDst.right - rclDst.left;
                    sizl.cy = rclDst.bottom - rclDst.top;

                    PDEVOBJ pdoSrc(pdsSrc->hdev);

                    hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                                       0,
                                                       pdoSrc.iDitherFormat(),
                                                       0,
                                                       NULL);

                    psoTmp = EngLockSurface(hsurfTmp);
                    if (psoTmp)
                    {
                        rclDstTmp.left   = 0;
                        rclDstTmp.top    = 0;
                        rclDstTmp.right  = sizl.cx;
                        rclDstTmp.bottom = sizl.cy;

                        bRet &= OffCopyBits(*PPFNGET(pdoSrc, 
                                                     CopyBits, 
                                                     pdoSrc.pSurface()->flags()),
                                            &gptlZero,
                                            psoTmp,
                                            &pdsSrc->Off,
                                            psoSrc,
                                            NULL,
                                            NULL,
                                            &rclDstTmp,
                                            &ptlSrc);
                    }

                    psoSrc  = psoTmp;
                    pOffSrc = &gptlZero;

                    ptlSrc.x = 0;
                    ptlSrc.y = 0;
                }

                // Do the blt:

                if (psoSrc)
                {
                    BOOL bError = FALSE;

                    PDEVOBJ pdoSrc(pdsSrc->hdev);
                    PDEVOBJ pdoDst(pdsDst->hdev);

                    EXLATEOBJ xloDevice;

                    if ((psoDst != psoSrc) &&
                        ((pdsDst->iCompatibleColorFormat != 0) ||
                         (pdsSrc->iCompatibleColorFormat != 0)))
                    {
                        XLATE    *pxloM    = (XLATE *) pxlo;
                        PSURFACE  pSurfSrc = pdsSrc->po.pSurface();
                        PSURFACE  pSurfDst = pdsDst->po.pSurface();
                        PPALETTE  ppalSrcDC = ppalDefault;
                        PPALETTE  ppalDstDC = ppalDefault;

                        // If destination surface is not compatible as primary
                        // and pal-managed device, then use halftone palette
                        // (source is higher then destination).

                        if ((pdsDst->iCompatibleColorFormat != 0) &&
                             pdoDst.bIsPalManaged())
                        {
                            ppalDstDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    pSurfSrc->ppal(), // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalSrcDC,        // Source DC palette
                                    ppalDstDC,        // Destination DC palette
                                    (pxloM ? pxloM->iForeDst  : 0x0L),
                                    (pxloM ? pxloM->iBackDst  : 0x0L),
                                    (pxloM ? pxloM->iBackSrc  : 0x0L),
                                    (pdsSrc->po.bIsPalManaged() ? XLATE_USE_SURFACE_PAL : 0)))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }

                    if (bError == FALSE)
                    {
                        // If we have a clipobj,
                        // We must ensure that pco->rclBounds is never bigger than
                        // prclDst on the CopyBits call.
                        if ((pco == NULL) ||
                            bIntersect(&rclSaveBounds, &rclDst, &pco->rclBounds))
                        {
                            if (rop4 == 0xcccc)
                            {
                                // If window blt notification is needed (i.e.,
                                // destination meta-surface has BMF_WINDOW_BLT bit
                                // set), setthe notification bit in the destination
                                // surfobj.

                                USHORT fjBitmapSave = psoDst->fjBitmap;

                                if (bWndBltNotify)
                                    psoDst->fjBitmap |= BMF_WINDOW_BLT;

                                bRet &= OffCopyBits(PPFNGET(pdoDst, 
                                                            CopyBits,
                                                            pdoDst.pSurface()->flags()),
                                                    pOffDst,
                                                    psoDst,
                                                    pOffSrc,
                                                    psoSrc,
                                                    pco,
                                                    pxlo,
                                                    &rclDst,
                                                    &ptlSrc);

                                // Restore the surfobj flagss.

                                psoDst->fjBitmap = fjBitmapSave;
                            }
                            else
                            {
                                MBRUSH.LoadElement(pdsDst, SURFOBJ_TO_SURFACE_NOT_NULL(psoDst));

                                bRet &= OffBitBlt(PPFNGET(pdoDst, 
                                                          BitBlt, 
                                                          pdoDst.pSurface()->flags()),
                                                  pOffDst,
                                                  psoDst,
                                                  pOffSrc,
                                                  psoSrc,
                                                  psoMask,
                                                  pco,
                                                  pxlo,
                                                  &rclDst,
                                                  &ptlSrc,
                                                  pptlMask,
                                                  pbo,
                                                  pptlBrush,
                                                  rop4);

                                MBRUSH.StoreElement(pdsDst->iDispSurf);
                            }
                        }
                    }
                    else
                    {
                        bRet = FALSE;
                    }

                    // Restore XLATEOBJ.

                    pxlo = pxloSave;
                }

                // Now undo everything:

#if _MSC_VER < 1300
                if (dhpdevSave)
                {
                    psoSrc->dhsurf = dhsurfSave;
                    psoSrc->dhpdev = dhpdevSave;
                }
                else
#endif
                if (hsurfTmp)
                {
                    EngUnlockSurface(psoTmp);
                    EngDeleteSurface(hsurfTmp);
                }
            }
        }
    }

    if (pco != NULL)
    {
        pco->rclBounds = rclSaveBounds;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bBitBltFromScreen
*
* Handles screen-to-bitmap blts that may possibly span multiple displays.
*
\**************************************************************************/

BOOL bBitBltFromScreen(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4)
{
    GDIFunctionID(bBitBltFromScreen);

    VDEV*       pvdev;
    DHPDEV      dhpdevDst;
    RECTL       rclDraw;
    MSURF       msurf;
    POINTL      ptlSrc;
    RECTL       rclDst;
    SURFOBJ*    psoDstTmp;
    LONG        dx;
    LONG        dy;

    XLATEOBJ   *pxloSave = pxlo;

    BOOL    bRet = TRUE;

    pvdev = (VDEV*) psoSrc->dhpdev;

    MULTISURF mDst(psoDst,prclDst);

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Trim the destination rectangle to what's specified in the CLIPOBJ's
    // 'rclBounds':

    rclDraw = *prclDst;
    if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
    {
        if (!bIntersect(&pco->rclBounds, &rclDraw, &rclDraw))
            return(TRUE);
    }

    // Convert 'rclDraw' from destination coordinates to source coordinates:

    rclDraw.left   -= dx;
    rclDraw.right  -= dx;
    rclDraw.top    -= dy;
    rclDraw.bottom -= dy;

    MULTIBRUSH MBRUSH(pbo, pvdev->cSurfaces, pvdev, pvdev->pso, ROP4_NEEDS_PATTERN(rop4));
    if (!MBRUSH.Valid())
    {
        return FALSE;
    }

    // Source is screen.

    if (msurf.bFindSurface(psoSrc, NULL, &rclDraw))
    {
        do {

            PDEVOBJ poSrc(msurf.pso->hdev);

            // for DIB we blit once from each screen.  For device managed bitmaps, we blit
            // once to the master compatible bitmap and once to the device managed bitmap
            // for each screen.
            if (poSrc.flGraphicsCaps() & GCAPS_LAYERED)
            {
                if (mDst.pmdsurf == NULL || mDst.pmdsurf->apso[msurf.pds->iDispSurf] == NULL)
                    continue;
                psoDstTmp = mDst.pmdsurf->apso[msurf.pds->iDispSurf];
            }
            else
                psoDstTmp = mDst.pso;
            
            do {
               
               BOOL bError = FALSE;
            
               EXLATEOBJ xloDevice;

               // if the source surface is not compatible to primary surface,
               // create XLATEOBJ for source surface to target. otherwise
               // we can just use given XLATEOBJ.

               if (msurf.pds->iCompatibleColorFormat != 0)
               {
                  XLATE    *pxloM     = (XLATE *) pxlo;
                  PSURFACE  pSurfSrc  = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
                  PSURFACE  pSurfDst  = SURFOBJ_TO_SURFACE_NOT_NULL(psoDstTmp);
                  PPALETTE  ppalDst   = pSurfDst->ppal();

                  if (!ppalDst)
                  {
                     // Destination surface does not have associated palette.
                     // (Destination surface is compatible bitmap)

                     if (pxloM && pxloM->ppalDst)
                     {
                        // if XLATEOBJ has destination palette, use it.

                        ppalDst = pxloM->ppalDst;
                     }
                     else
                     {
                        if ((pxloM == NULL) || pxloM->bIsIdentity())
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc);

                            // if translation is identity, we can use the palette for
                            // meta-source surface as destination. since it's trivial.

                            // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                            if (psoDstTmp == psoDst)
                            {
                                ppalDst = pSurfTmp->ppal();
                            }
                        }
                        else
                        {
                        #if HIDEYUKN_DBG
                            DbgPrint("GDI DDML: bBitBltFromScreen(): ppalDst is NULL\n");
                            DbgBreakPoint();
                        #endif
                            bError = TRUE;
                        }
                     }
                  }

                  if (bError == FALSE)
                  {

                      // WINBUG #365408 4-10-2001 jasonha Need to investigate old comment in bBitBltFromScreen
                      //
                      // We need to investigate the following old comment:
                      //    make sure that when the target surface is paletee managed we should
                      //    foreground realization to copy bits from non-primary surface.

                     if (xloDevice.bInitXlateObj(
                               (pxloM ? pxloM->hcmXform : NULL),
                               (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                               pSurfSrc->ppal(), // Source (device surface) palette
                               ppalDst,          // Destination palette
                               ppalDefault,      // Source DC palette
                               ppalDefault,      // Destination DC palette
                               (pxloM ? pxloM->iForeDst : 0x0L),
                               (pxloM ? pxloM->iBackDst : 0x0L),
                               (pxloM ? pxloM->iBackSrc : 0x0L),
                               XLATE_USE_SURFACE_PAL))
                     {
                        pxlo = xloDevice.pxlo();
                     }
                     else
                     {
                        bError = TRUE;
                     }
                  }
               }

               if (bError == FALSE)
               {
                  if (msurf.pco->iDComplexity == DC_TRIVIAL)
                  {
                     // Since bFindSurface/bNextSurface specified no clipping,
                     // the entire source surface is readable in one shot:

                     ptlSrc = *pptlSrc;
                     rclDst = *prclDst;
                  }
                  else
                  {
                     // Since the screen is the source, but the clip bounds
                     // apply to the destination, we have to convert our surface
                     // clipping information to destination coordinates:

                     ptlSrc.x      = msurf.pco->rclBounds.left;
                     ptlSrc.y      = msurf.pco->rclBounds.top;

                     rclDst.left   = msurf.pco->rclBounds.left   + dx;
                     rclDst.right  = msurf.pco->rclBounds.right  + dx;
                     rclDst.top    = msurf.pco->rclBounds.top    + dy;
                     rclDst.bottom = msurf.pco->rclBounds.bottom + dy;
                  }

                  if (rop4 == 0xcccc)
                  {
                     bRet &= OffCopyBits(
                                PPFNMGET(msurf, CopyBits),
                                &gptlZero,
                                psoDstTmp,
                                msurf.pOffset,
                                msurf.pso,
                                pco,       // Note that this is the original 'pco'
                                pxlo,
                                &rclDst,
                                &ptlSrc);
                  }
                  else
                  {
                     MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

                     bRet &= OffBitBlt(
                                PPFNMGET(msurf, BitBlt),
                                &gptlZero,
                                psoDstTmp,
                                msurf.pOffset,
                                msurf.pso,
                                psoMask,
                                pco,       // Note that this is the original 'pco'
                                pxlo,
                                &rclDst,
                                &ptlSrc,
                                pptlMask,
                                pbo,
                                pptlBrush,
                                rop4);

                     MBRUSH.StoreElement(msurf.pds->iDispSurf);
                  }
               }
               else
               {
                  bRet = FALSE;
               }

               // Restore XLATEOBJ.

               pxlo = pxloSave;

#if 1
               ASSERTGDI(!((mDst.pmdsurf != NULL) &&
                           (psoDstTmp == mDst.pso) &&
                           (mDst.pmdsurf->apso[msurf.pds->iDispSurf] != NULL)),
                         "Non-Layered device is part of Meta DEVBITMAP.\n");
               psoDstTmp = NULL;
#else
               if ((mDst.pmdsurf != NULL) && (psoDstTmp == mDst.pso))
                   psoDstTmp = mDst.pmdsurf->apso[msurf.pds->iDispSurf];
               else
                   psoDstTmp = NULL;
#endif

            } while (psoDstTmp != NULL);

        } while (msurf.bNextSurface());
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
SURFOBJ  *psoMask,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc,
POINTL   *pptlMask,
BRUSHOBJ *pbo,
POINTL   *pptlBrush,
ROP4      rop4)
{
    GDIFunctionID(MulBitBlt);

    BOOL        bFromScreen;
    BOOL        bToScreen;
    VDEV*       pvdev;
    USHORT      iDstType;
    BOOL        bMultiDst;
    MDSURF*     pmdsurfSrc;
    DHPDEV      dhpdevSrc;
    RECTL       rclDst;
    MSURF       msurf;
    BOOL        bRet;
    BOOL        bError;

    XLATEOBJ   *pxloSave = pxlo;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = (psoDst->iType == STYPE_DEVICE);

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        return(bBitBltScreenToScreen(psoDst, psoMask, pco, pxlo,
                                     &rclDst, pptlSrc, pptlMask, pbo,
                                     pptlBrush, rop4));
    }
    else if (bFromScreen)
    {
        return(bBitBltFromScreen(psoDst, psoSrc, psoMask, pco, pxlo,
                                 &rclDst, pptlSrc, pptlMask, pbo,
                                 pptlBrush, rop4));
    }
    else // if (bToScreen)
    {
        bRet = TRUE;

        pvdev = (VDEV*) psoDst->dhpdev;

        // WINBUG #380128 05-04-2001 jasonha Initialize MSURF before MULTISURF
        // WINBUG #402896 05-24-2001 jasonha Initialize MULTIBURSH before MULTISURF
        //  MULTIBRUSH and MSURF must be intialized before the destination
        //  SURFACE might be modified.  The destination SURFACE may be changed
        //  when the source and destination are the same.

        iDstType = psoDst->iType;
        bMultiDst = (iDstType != STYPE_BITMAP) && msurf.bFindSurface(psoDst, pco, prclDst);

        // MBRUSH is only needed for the bMultiDst case, therefore pass
        // a NULL pbo, to reduce unnecessary setup.
        MULTIBRUSH  MBRUSH(((bMultiDst) ? pbo : NULL),
                           ((bMultiDst) ? pvdev->cSurfaces : 0),
                           ((bMultiDst) ? pvdev: NULL),
                           ((bMultiDst) ? pvdev->pso : NULL),
                           ((bMultiDst) ? ROP4_NEEDS_PATTERN(rop4) : FALSE));

        MULTISURF   mSrc(psoSrc, pptlSrc, rclDst.right - rclDst.left, rclDst.bottom - rclDst.top);

        if (iDstType != STYPE_DEVICE)
        {
            // For STYPE_BITMAP, we only blit to the DIB.
            // For STYPE_DEVBITMAP, we then blit to each device bitmap.

            MULTISURF mDst(psoDst,prclDst);
           
            bRet = EngBitBlt(mDst.pso, mSrc.pso, psoMask, pco, pxlo, mDst.prcl,
                             mSrc.pptl(), pptlMask, pbo, pptlBrush, rop4);
        }

        if (bMultiDst) 
        {
            if (!MBRUSH.Valid())
            {
                msurf.vRestore();
                return FALSE;
            }

            do {

                bError = !mSrc.bLoadSource(msurf.pds);

                EXLATEOBJ xloDevice;

                // if the target surface is not compatible to primary surface,
                // create XLATEOBJ for source surface to target. otherwise
                // we can just use given XLATEOBJ.

                if ((bError == FALSE) &&
                    (mSrc.pso != NULL) &&
                    (msurf.pds->iCompatibleColorFormat != 0))
                {
                    XLATE    *pxloM      = (XLATE *) pxlo;
                    PSURFACE  pSurfSrc   = SURFOBJ_TO_SURFACE_NOT_NULL(mSrc.pso);
                    PSURFACE  pSurfDst   = SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso);
                    PPALETTE  ppalSrc    = pSurfSrc->ppal();
                    PPALETTE  ppalDestDC = ppalDefault;

                    PDEVOBJ   pdoDst(msurf.pds->hdev);

                    if (pdoDst.bIsPalManaged())
                    {
                        // Use halftone palette for pal-managed device.

                        ppalDestDC = REALIZE_HALFTONE_PALETTE(pdoDst.hdev());
                    }

                    if (!ppalSrc)
                    {
                        // Source surface does not have associated palette.
                        // (Source surface is compatible bitmap)

                        if (pxloM && pxloM->ppalSrc)
                        {
                            // if XLATEOBJ has source palette, use it.

                            ppalSrc = pxloM->ppalSrc;
                        }
                        else
                        {
                            PSURFACE pSurfTmp = SURFOBJ_TO_SURFACE_NOT_NULL(psoDst);

                            if ((pxloM == NULL) || pxloM->bIsIdentity())
                            {
                                // if translation is identity, we can use the palette for
                                // meta-destination surface as source. since it's trivial.

                                // WINBUG #396667 10-03-2001 jasonha A/V due to improper XLATE setup
                                if (mSrc.pso == psoSrc)
                                {
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else if (pxloM->ppalDstDC)
                            {
                                // We are bitblting from compatible bitmap to a surface in
                                // meta-surface. but we are not in foreground.

                                ppalDestDC = pxloM->ppalDstDC;

                                // WINBUG #274637 02-12-2001 jasonha A/V due to improper XLATE setup
                                if (pSurfSrc->iFormat() == pSurfTmp->iFormat())
                                {
                                    // We are bitblting from a compatible bitmap that is
                                    // not palettized but is a the same format as the
                                    // meta-surface, so we use the destination palette.
                                    ppalSrc = pSurfTmp->ppal();
                                }
                            }
                            else
                            {
                            #if HIDEYUKN_DBG
                                DbgPrint("GDI DDML: MulBitBlt(): ppalDst is NULL\n");
                                DbgBreakPoint();
                            #endif
                                bError = TRUE;
                            }
                        }
                    }

                    if (bError == FALSE)
                    {
                        XEPALOBJ palSurfSrc(ppalSrc);
                        ULONG    flFlags = 0;

                        if (palSurfSrc.bValid() && palSurfSrc.bIsPalManaged())
                        {
                            // Source is palette managed surface.

                            if (ppalDestDC == ppalDefault)
                            {
                                // We don't know DC palette here, but we know we are in foregroud,
                                // (since translation is trivial)
                                // so, we just map from source surface palette to destination
                                // surface palette directly (destination is at least higher color
                                // depth than source).

                                flFlags = XLATE_USE_SURFACE_PAL;
                            }
                            else
                            {
                                // We may not be in foreground. but map from foreground translation
                                // in source, so that we will not loose original color on secondary
                                // devices which can produce higher color depth then source.

                                flFlags = XLATE_USE_FOREGROUND;
                            }
                        }

                        if (xloDevice.bInitXlateObj(
                                    (pxloM ? pxloM->hcmXform : NULL),
                                    (pxloM ? pxloM->lIcmMode : DC_ICM_OFF),
                                    palSurfSrc,       // Source palette
                                    pSurfDst->ppal(), // Destination palette
                                    ppalDefault,      // Source DC palette
                                    ppalDestDC,       // Destination DC palette
                                    (pxloM ? pxloM->iForeDst : 0x0L),
                                    (pxloM ? pxloM->iBackDst : 0x0L),
                                    (pxloM ? pxloM->iBackSrc : 0x0L),
                                    flFlags))
                        {
                            pxlo = xloDevice.pxlo();
                        }
                        else
                        {
                            bError = TRUE;
                        }
                    }
                }

                if (bError == FALSE)
                {
                    if (0) // (bHalftone)
                    {
                        MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

                        bRet &= OffStretchBltROP(EngStretchBltROP,
                                          msurf.pOffset,
                                          msurf.pso,
                                          &gptlZero,
                                          mSrc.pso,
                                          psoMask,
                                          msurf.pco,
                                          pxlo,
                                          NULL,
                                          &gptlZero,
                                          &rclDst,
                                          mSrc.prcl,
                                          pptlMask,
                                          HALFTONE,
                                          pbo,
                                          rop4);

                        MBRUSH.StoreElement(msurf.pds->iDispSurf);
                    }
                    else if (rop4 == 0xcccc)
                    {
                        bRet &= OffCopyBits(PPFNMGET(msurf, CopyBits),
                                            msurf.pOffset,
                                            msurf.pso,
                                            &gptlZero,
                                            mSrc.pso,
                                            msurf.pco,
                                            pxlo,
                                            &rclDst,
                                            mSrc.pptl());
                    }
                    else
                    {
                        MBRUSH.LoadElement(msurf.pds, SURFOBJ_TO_SURFACE_NOT_NULL(msurf.pso));

                        bRet &= OffBitBlt(PPFNMGET(msurf, BitBlt),
                                          msurf.pOffset,
                                          msurf.pso,
                                          &gptlZero,
                                          mSrc.pso,
                                          psoMask,
                                          msurf.pco,
                                          pxlo,
                                          &rclDst,
                                          mSrc.pptl(),
                                          pptlMask,
                                          pbo,
                                          pptlBrush,
                                          rop4);

                        MBRUSH.StoreElement(msurf.pds->iDispSurf);
                    }
                }
                else
                {
                    bRet = FALSE;
                }

                // Restore XLATEOBJ.

                pxlo = pxloSave;

            } while (msurf.bNextSurface());
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ  *psoDst,
SURFOBJ  *psoSrc,
CLIPOBJ  *pco,
XLATEOBJ *pxlo,
RECTL    *prclDst,
POINTL   *pptlSrc)
{
    return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                     pptlSrc, NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* BOOL MulUpdateColors
*
* History:
*  18-Aug-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

BOOL MulUpdateColors(
SURFOBJ  *pso,
CLIPOBJ  *pco,
XLATEOBJ *pxlo)
{
    VDEV*       pvdev;
    DISPSURF*   pdsDst;
    SURFOBJ*    psoDst;
    POINTL*     pOffDst;
    RECTL       rclDst;
    POINTL      ptlSrc;
    RECTL       rclBounds;
    BOOL        bRet;

    bRet = TRUE;

    pvdev = (VDEV*) pso->dhpdev;

    ASSERTGDI(pco,"MulUpdateColors(): pco is null\n");

    //
    // Save bounds rectangle to updates.
    //

    rclBounds = pco->rclBounds;

    //
    // Walk through all devices.
    //

    for (pdsDst = pvdev->pds; pdsDst != NULL; pdsDst = pdsDst->pdsNext)
    {
        PDEVOBJ pdo(pdsDst->hdev);

        //
        // Check the device is palette managed or not.
        //
        // + If this is not palette managed device, we don't need to
        // do anything.
        // 
        // + Palette is shared with all palette devices, so we can
        // use exactly same XLATEOBJ for all palette devices.
        //

        if (pdo.bIsPalManaged())
        {
            //
            // Clip the rectangle to monitor.
            //

            if (bIntersect(&rclBounds, &pdsDst->rcl, &rclDst))
            {
                //
                // We must ensure that pco->rclBounds is never bigger than
                // prclDst on the CopyBits call.
                //

                pco->rclBounds = rclDst;

                //
                // Source points is same as destination upper-left.
                //

                ptlSrc.x = rclDst.left;
                ptlSrc.y = rclDst.top;

                psoDst  = pdsDst->pso;
                pOffDst = &pdsDst->Off;

                //
                // Update each pixel with correct color (by XLATEOBJ).
                //

                bRet &= OffCopyBits(PPFNGET(pdo, 
                                            CopyBits,
                                            pdo.pSurface()->flags()),
                                    pOffDst, psoDst, 
                                    pOffDst, psoDst,
                                    pco,     pxlo,
                                    &rclDst, &ptlSrc);
            }
        }
    }

    //
    // Restore original.
    //

    pco->rclBounds = rclBounds;

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulCopyDeviceToDIB
*
* Copies the specified rectangle of a multimon device surface to a DIB
* updating the rectangle to be relativeto the DIB's origin (0,0)  
* 
* The surface is not actually created if the rectangle is 
* out of bounds, so the caller has to check if the value 
* of pDibSurface.ps was modified at all. 
* 
* History:
*  16-Dec-1998 -by- Andre Matos [amatos]
* Wrote it.
*
\**************************************************************************/

BOOL MulCopyDeviceToDIB( 
SURFOBJ *pso, 
SURFMEM *pDibSurf,
RECTL   *prclSrc)
{
    DEVBITMAPINFO   dbmi;

    PSURFACE pSurfSrc  = SURFOBJ_TO_SURFACE(pso);
    PDEVOBJ  pdoSrc(pSurfSrc->hdev()); 

    RECTL rclSrcClip = *prclSrc; 

    if(rclSrcClip.left < pdoSrc.pptlOrigin()->x) 
    {
        rclSrcClip.left = pdoSrc.pptlOrigin()->x;
    }
    if(rclSrcClip.right > 
       (pdoSrc.pptlOrigin()->x + pSurfSrc->sizl().cx)) 
    {
        rclSrcClip.right = 
            pdoSrc.pptlOrigin()->x + pSurfSrc->sizl().cx;
    }
    if(rclSrcClip.top < pdoSrc.pptlOrigin()->y) 
    {
        rclSrcClip.top = pdoSrc.pptlOrigin()->y;
    }
    if(rclSrcClip.bottom > 
       (pdoSrc.pptlOrigin()->y + pSurfSrc->sizl().cy)) 
    {
        rclSrcClip.bottom = 
            pdoSrc.pptlOrigin()->y + pSurfSrc->sizl().cy;
    }

    // If the source rectangle was outside of the source 
    // surface, we can return. 

    if((rclSrcClip.top >= rclSrcClip.bottom) ||
       (rclSrcClip.left >= rclSrcClip.right )) 
    {
        return TRUE; 
    }

    RECTL rclDst = {0, 0, rclSrcClip.right - rclSrcClip.left, 
        rclSrcClip.bottom - rclSrcClip.top};
    
    POINTL srcOrigin = { rclSrcClip.left, rclSrcClip.top }; 

    PPALETTE ppalSrc = pSurfSrc->ppal(); 

    dbmi.cxBitmap = rclDst.right;
    dbmi.cyBitmap = rclDst.bottom;
    dbmi.hpal     = ppalSrc ? ((HPALETTE) ppalSrc->hGet()) : 0;
    dbmi.iFormat  = pSurfSrc->iFormat();
    dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;    

    pDibSurf->bCreateDIB(&dbmi, (VOID *) NULL);

    if (!pDibSurf->bValid())
         return(FALSE);

    if (!MulBitBlt(pDibSurf->pSurfobj(), pso, NULL, (CLIPOBJ *) NULL, 
             &xloIdent, &rclDst, &srcOrigin, NULL, NULL, NULL, 0xcccc)) 
        return FALSE; 

    prclSrc->left   -= rclSrcClip.left; 
    prclSrc->right  -= rclSrcClip.left; 
    prclSrc->top    -= rclSrcClip.top; 
    prclSrc->bottom -= rclSrcClip.top; 

    return TRUE; 
}

/******************************Public*Structure****************************\
* DRVFN gadrvfnMulti[]
*
* Build the driver function table gadrvfnMulti with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

DRVFN gadrvfnMulti[] = {

    // Effectively required by all drivers:

    {  INDEX_DrvEnablePDEV            , (PFN) MulEnablePDEV           },
    {  INDEX_DrvCompletePDEV          , (PFN) MulCompletePDEV         },
    {  INDEX_DrvDisablePDEV           , (PFN) MulDisablePDEV          },
    {  INDEX_DrvEnableSurface         , (PFN) MulEnableSurface        },
    {  INDEX_DrvDisableSurface        , (PFN) MulDisableSurface       },
    {  INDEX_DrvSetPalette            , (PFN) MulSetPalette           },
    {  INDEX_DrvRealizeBrush          , (PFN) MulRealizeBrush         },

    //
    // The DDML is special in that it does not manage any physical device.
    // GDI and USER should handle all calls involing modes, and those calls
    // should never get to the DDML.
    //
    // {  INDEX_DrvAssertMode         , (PFN) MulAssertMode           },
    // {  INDEX_DrvGetModes           , (PFN) MulGetModes             },

    // Required for device-managed surfaces:

    {  INDEX_DrvTextOut               , (PFN) MulTextOut              },
    {  INDEX_DrvStrokePath            , (PFN) MulStrokePath           },
    {  INDEX_DrvCopyBits              , (PFN) MulCopyBits             },

    // Optional, must be supported by "Eng" backup calls:

    {  INDEX_DrvBitBlt                , (PFN) MulBitBlt               },
    {  INDEX_DrvLineTo                , (PFN) MulLineTo               },
    {  INDEX_DrvFillPath              , (PFN) MulFillPath             },
    {  INDEX_DrvStrokeAndFillPath     , (PFN) MulStrokeAndFillPath    },
    {  INDEX_DrvStretchBlt            , (PFN) MulStretchBlt           },
    {  INDEX_DrvAlphaBlend            , (PFN) MulAlphaBlend           },
    {  INDEX_DrvTransparentBlt        , (PFN) MulTransparentBlt       },
    {  INDEX_DrvGradientFill          , (PFN) MulGradientFill         },
    {  INDEX_DrvDrawStream            , (PFN) MulDrawStream           },

    // For handling device bitmaps with layered drivers:

    {  INDEX_DrvCreateDeviceBitmap    , (PFN) MulCreateDeviceBitmap   },
    {  INDEX_DrvDeleteDeviceBitmap    , (PFN) MulDeleteDeviceBitmap   },

    // These calls only go to drivers that specifically need to get them.
    // DrvDestroyFont is only called for the specific drivers that hooked
    // it.  I checked it out, and the engine calls DrvDestroyFont regardless
    // of whether or not pvConsumer is NULL.  Therefore, I do the same for
    // each of the drivers.

    {  INDEX_DrvDestroyFont           , (PFN) MulDestroyFont          },
    {  INDEX_DrvEscape                , (PFN) MulEscape               },
    {  INDEX_DrvSaveScreenBits        , (PFN) MulSaveScreenBits       },

#ifdef OPENGL_MM
    // ICD calls directly dispatch to real driver in API level, so it bypass DDML.
#else
    {  INDEX_DrvSetPixelFormat        , (PFN) MulSetPixelFormat       },
    {  INDEX_DrvDescribePixelFormat   , (PFN) MulDescribePixelFormat  },
    {  INDEX_DrvSwapBuffers           , (PFN) MulSwapBuffers          },
#endif // OPENGL_MM

    // Image Color Management - DeviceGammaRamp control:

    {  INDEX_DrvIcmSetDeviceGammaRamp , (PFN) MulIcmSetDeviceGammaRamp},

};

ULONG gcdrvfnMulti = sizeof(gadrvfnMulti) / sizeof(DRVFN);

#ifdef OPENGL_MM

/******************************Public*Routine******************************\
* HDEV hdevFindDeviceHDEV
*
* OpenGL calls should only go to one driver and not the meta device.
* Try to find the appropriate hdev and return it.
*
* History:
*   28-Jan-1998 -by- Robert Tray [v-rotray]
* First pass.
*
\**************************************************************************/

HDEV hdevFindDeviceHdev(
    HDEV      hdevMeta,
    RECTL     rect,
    PEWNDOBJ  pwo)       // OPTIONAL
{
    //
    // *PixelFormat, SwapBuffers, & OGL Escape calls should
    // only go to one device.   Which one?
    // If there is a valid WNDOBJ then it will tell us
    // which surface is the right one.
    // If the extents of the window are completely contained
    // on one monitor then return the hdev of that device.
    // If the window straddles monitors then .... how about
    // we return 0 and hopefully in that case the app will
    // fall back to software rendering.  By the time the app
    // is serious about rendering he has a WNDOBJ.  So hopefully
    // we will only hit these ambiguous situations while the
    // app is doing a DescribePixelFormat.
    //

    PDEVOBJ pdo(hdevMeta);

    ASSERTGDI(pdo.bMetaDriver(),"hdevFindDeviceHDEV(): hdevMeta is not meta-PDEV\n");

    PVDEV     pvdev = (VDEV*) pdo.dhpdev();

    PDISPSURF pds;
    HDEV      hdevMatch = NULL;

    //
    // If WNDOBJ is given and the HDEV for the WNDOBJ
    // is one of child of this meta-PDEV. use it.
    //
    if (pwo && pwo->bValid())
    {
        hdevMatch = pwo->pto->pSurface->hdev();

        for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
        {
            if (hdevMatch == pds->hdev)
            {
                // found the match

                return (hdevMatch);
            }
        }
    }

    ULONG intersectMon = 0;

    for (pds = pvdev->pds; pds != NULL; pds = pds->pdsNext)
    {
        if (bContains(&pds->rcl,&rect))
        {
            // The window is contained on this device

            return (pds->hdev);
        }

        if (bIntersect(&pds->rcl,&rect))
        {
            // The window is intersected with this device.

            PDEVOBJ pdoDevice(pds->hdev);

            // If this device has GCAPS2_ICD_MULTIMON flag, they
            // wants us to call them with any OpenGL window intersect
            // with thier device.

            if (pdoDevice.flGraphicsCaps2() & GCAPS2_ICD_MULTIMON)
            {
                return (pds->hdev);
            }

            intersectMon++;

            hdevMatch = pds->hdev;
        }
    }

    //
    // If the window is not contained on one monitor but
    // it only intersects one then that might mean that it's
    // hanging off the outside edge of a monitor.
    //

    if (intersectMon == 1)
    {
        return hdevMatch;
    }

    //
    // I suppose you could possibly return the hdev for the
    // primary monitor in some of these ambiguous cases but
    // until I think of them I'll just return NULL
    //

    return NULL;
}

#endif // OPENGL_MM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\palgdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: palgdi.cxx
*
* This module provides the API level interface functions for dealing with
* palettes.
*
* Created: 07-Nov-1990 22:21:11
* Author: Patrick Haluptzok  patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// hForePalette is a global variable that tells which palette is currently
// realized in the foreground.

HPALETTE    hForePalette = 0;
PW32PROCESS hForePID = 0;


#if DBG

ULONG   DbgPal = 0;
#define PAL_DEBUG(l,x)  {if (l <= DbgPal) {DbgPrint("%p ", hpalDC); DbgPrint(x);}}

#else

#define PAL_DEBUG(l,x)

#endif

/******************************Public*Routine******************************\
* GreGetDIBColorTable
*
* Get the color table of the DIB section currently selected into the dc
* identified by the given hdc.  If the surface is not a DIB section,
* this function will fail.
*
* History:
*  07-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

#if ((BMF_1BPP != 1) || (BMF_4BPP != 2) || (BMF_8BPP != 3))
#error GetDIBColorTable BAD FORMAT
#endif

UINT
APIENTRY
GreGetDIBColorTable(
    HDC hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD *pRGB
    )
{

    UINT  iRet = 0;
    DCOBJ dco(hdc);

    if (pRGB != (RGBQUAD *)NULL)
    {
        if (dco.bValid())
        {
            //
            // Protect against dynamic mode changes while we go grunging
            // around in the surface.
            //

            DEVLOCKOBJ dlo;
            dlo.vLockNoDrawing(dco);

            //
            // Fail if the selected in surface is not a DIB or the depth is more than
            // 8BPP.
            //

            SURFACE *pSurf = dco.pSurfaceEff();
            ULONG iFormat = pSurf->iFormat();
            if ((pSurf->bDIBSection() || (pSurf->pPal != NULL)) &&
                (iFormat <= BMF_8BPP) && (iFormat >= BMF_1BPP))
            {
                //
                // Lock the surface palette and figure out the max index allowed on the
                // palette.  Win95 does not return un-used entries.
                //

                XEPALOBJ pal(pSurf->ppal());
                ASSERTGDI(pal.bValid(), "GetDIBColorTable: invalid pal\n");

                UINT iMax = (UINT) pal.cEntries();

                if (iStart >= iMax)
                {
                    return(0);
                }

                UINT iLast = iStart + cEntries;

                if (iLast > iMax)
                {
                    iLast = iMax;
                }

                pal.vFill_rgbquads(pRGB, iStart, iRet = iLast - iStart);
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* GreSetDIBColorTable
*
* Set the color table of the DIB section currently selected into the dc
* identified by the given hdc.  If the surface is not a DIB section,
* this function will fail.
*
* History:
*  07-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
GreSetDIBColorTable(
    HDC hdc,
    UINT iStart,
    UINT cEntries,
    RGBQUAD *pRGB
    )
{

    UINT  iRet = 0;
    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        //
        // Protect against dynamic mode changes while we go grunging
        // around in the surface.
        //

        DEVLOCKOBJ dlo;
        dlo.vLockNoDrawing(dco);

        //
        // Fail if the selected in surface is not a DIB or the depth is more than
        // 8BPP.
        //

        SURFACE *pSurf = dco.pSurfaceEff();
        ULONG iFormat = pSurf->iFormat();
        if (pSurf->bDIBSection() &&
            (iFormat <= BMF_8BPP) && (iFormat >= BMF_1BPP))
        {
            //
            // Mark the brushes dirty.
            //

            dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);

            //
            // Lock the surface palette and figure out the max
            // index allowed on the palette.
            //

            XEPALOBJ pal(pSurf->ppal());
            ASSERTGDI(pal.bValid(), "GetDIBColorTable: invalid pal\n");

            UINT iMax = (UINT) pal.cEntries();
            if (iStart < iMax)
            {
                UINT iLast = iStart + cEntries;
                if (iLast > iMax)
                    iLast = iMax;

                pal.vCopy_rgbquad(pRGB, iStart, iRet = iLast - iStart);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* GreCreatePalette - creates a palette from the logpal information given
*
* API function.
*
* returns HPALETTE for succes, (HPALETTE) 0 for failure
*
* History:
*  07-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
GreCreatePalette(
    LPLOGPALETTE pLogPal
    )
{

    return(GreCreatePaletteInternal(pLogPal,pLogPal->palNumEntries));
}

HPALETTE
APIENTRY
GreCreatePaletteInternal(
    LPLOGPALETTE pLogPal,
    UINT cEntries
    )
{
    if ((pLogPal->palVersion != 0x300) || (cEntries == 0))
    {
        WARNING("GreCreatePalette failed, 0 entries or wrong version\n");
        return((HPALETTE) 0);
    }

    //
    // The constructor checks for invalid flags and fails if they are found.
    //

    PALMEMOBJ pal;

    if (!pal.bCreatePalette(PAL_INDEXED,
                            cEntries,
                            (PULONG) pLogPal->palPalEntry,
                            0, 0, 0,
                            (PAL_DC | PAL_FREE)))
    {
        return((HPALETTE) 0);
    }

    ASSERTGDI(pal.cEntries() != 0, "ERROR can't be 0, bGetEntriesFrom depends on that");

    pal.vKeepIt();
    GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);
    return((HPALETTE) pal.hpal());
}

/******************************Public*Routine******************************\
* NtGdiCreatePaletteInternal()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
NtGdiCreatePaletteInternal(
    LPLOGPALETTE pLogPal,
    UINT         cEntries
    )
{
    HPALETTE hpalRet = (HPALETTE)1;

    //
    // verify cEntries
    //

    if (cEntries <= 65536)
    {
        int cj = cEntries * sizeof(PALETTEENTRY) + offsetof(LOGPALETTE,palPalEntry);
        WORD Version;
        PULONG pPaletteEntry;

        __try
        {
            // it is safe to do a byte here.  If we can access dword's on byte boundries
            // this will work.  If not we will hit an exception under a try except.  Winhelp
            // passes in an unaligned palette but only on x86.

            ProbeForRead(pLogPal,cj, sizeof(BYTE));
            Version = pLogPal->palVersion;
            pPaletteEntry = (PULONG) pLogPal->palPalEntry;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            hpalRet = (HPALETTE)0;
        }

        if (hpalRet)
        {
            if ((Version != 0x300) || (cEntries == 0))
            {
                WARNING("GreCreatePalette failed, 0 entries or wrong version\n");
                hpalRet = (HPALETTE)0;
            }

            if (hpalRet)
            {

                //
                // The constructor checks for invalid flags and fails if they are found.
                //

                PALMEMOBJ pal;
                BOOL bStatus;

                //
                // bCreatePalette must use a try-except when accessing pPaletteEntry
                //

                bStatus = pal.bCreatePalette(PAL_INDEXED,
                                             cEntries,
                                             pPaletteEntry,
                                             0,
                                             0,
                                             0,
                                             (PAL_DC | PAL_FREE));

                if (bStatus)
                {
                    ASSERTGDI(pal.cEntries() != 0, "ERROR can't be 0, bGetEntriesFrom depends on that");

                    bStatus = GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);

                    if (bStatus)
                    {
                        pal.vKeepIt();
                        hpalRet = pal.hpal();
                    }
                    else
                    {
                        hpalRet = (HPALETTE)0;
                    }
                }
                else
                {
                    hpalRet = (HPALETTE)0;
                }
            }
        }
    }
    else
    {
        hpalRet = 0;
        WARNING("GreCreatePalette failed,cEntries too large\n");
    }


    return(hpalRet);
}

/******************************Public*Routine******************************\
* GreCreateCompatibleHalftonePalette
*
*   Creates the win95 compatible halftone palette
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/27/1996 Mark Enstrom [marke]
*
\**************************************************************************/

HPALETTE
APIENTRY
GreCreateCompatibleHalftonePalette(
    HDC hdc
    )
{
    HPALETTE  hpalRet;
    PALMEMOBJ pal;
    BOOL      bStatus;

    //
    // bCreatePalette must use a try-except when accessing pPaletteEntry
    //

    bStatus = pal.bCreatePalette(PAL_INDEXED,
                                 256,
                                 (PULONG)&aPalHalftone[0].ul,
                                 0,
                                 0,
                                 0,
                                 (PAL_DC | PAL_FREE | PAL_HT));

    if (bStatus)
    {
        ASSERTGDI(pal.cEntries() != 0, "ERROR can't be 0, bGetEntriesFrom depends on that");

        pal.flPal(PAL_HT);

        bStatus = GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);

        if (bStatus)
        {
            pal.vKeepIt();
            hpalRet = pal.hpal();
        }
        else
        {
            hpalRet = (HPALETTE)0;
        }
    }
    else
    {
        hpalRet = (HPALETTE)0;
    }
    return(hpalRet);
}

/******************************Public*Routine******************************\
* GreCreateHalftonePalette(hdc)
*
* Create a halftone palette for the given DC.
*
* History:
*  31-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

HPALETTE
APIENTRY
GreCreateHalftonePalette(
    HDC hdc
    )
{
    //
    // Validate and lock down the DC.  NOTE: Even though the surface is accessed
    // in this function, it is only for information purposes.  No reading or
    // writing of the surface occurs.
    //

    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return((HPALETTE) 0);
    }

    //
    // Get the PDEV from the DC.
    //

    PDEVOBJ po(dco.hdev());

    //
    // Acquire the devlock to protect against dynamic mode changes while
    // we enable halftoning for the PDEV and we construct the halftone
    // palette from this information.
    //

    DEVLOCKOBJ dlo(po);

    //
    // Create the halftone block if it has not existed yet.
    //

    if ((po.pDevHTInfo() == NULL) &&
        !po.bEnableHalftone((PCOLORADJUSTMENT)NULL))
        return((HPALETTE) 0);

    DEVICEHALFTONEINFO *pDevHTInfo = (DEVICEHALFTONEINFO *)po.pDevHTInfo();

    //
    // Use the entries in the halftone palette in the halftone block to create
    // the palette.
    //

    EPALOBJ palHT((HPALETTE)pDevHTInfo->DeviceOwnData);
    ASSERTGDI(palHT.bValid(), "GreCreateHalftonePalette: invalid HT pal\n");

    PALMEMOBJ pal;
    if (palHT.cEntries())
    {
        if (!pal.bCreatePalette(PAL_INDEXED, palHT.cEntries(),
                                (PULONG)palHT.apalColorGet(), 0, 0, 0,
                                (PAL_DC | PAL_FREE | PAL_HT)))
        {
            return((HPALETTE) 0);
        }
    }
    else
    {
        //
        // 16BPP halftone uses 555 for RGB.  We can't create a zero
        // entry palette at the API level, so lets create a default palette.
        //

        if (!pal.bCreatePalette(PAL_INDEXED, (ULONG)logDefaultPal.palNumEntries,
                                (PULONG)logDefaultPal.palPalEntry, 0, 0, 0,
                                PAL_DC | PAL_FREE | PAL_HT))
        {
            return(FALSE);
        }
    }

    pal.vKeepIt();
    GreSetPaletteOwner((HPALETTE)pal.hpal(), OBJECT_OWNER_CURRENT);
    return((HPALETTE) pal.hpal());
}

/******************************Public*Routine******************************\
* GreGetNearestPaletteIndex - returns the nearest palette index to crColor
*   in the hpalette.  Can only fail if hpal passed in is busy or bad.
*
* API function.
*
* returns value >= 0 for success, -1 for failure.
*
* History:
*  09-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT
APIENTRY
NtGdiGetNearestPaletteIndex(
    HPALETTE hpal,
    COLORREF crColor
    )
{
    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {
        //
        // If the palette has 0 entries return the color passed in.
        //

        if (pal.cEntries())
        {
            if (crColor & 0x01000000)
            {
                crColor &= 0x0000FFFF;

                if (crColor >= pal.cEntries())
                    crColor = 0;
            }
            else
            {
                crColor &= 0x00FFFFFF;
                crColor = pal.ulGetNearestFromPalentry(*((PPALETTEENTRY) &crColor));
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        crColor = CLR_INVALID;
    }

    return((UINT) crColor);
}

/******************************Public*Routine******************************\
* GreAnimatePalette
*
* API function
*
* Returns: The number of logical palette entries animated, 0 for error.
*
* History:
*  17-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GreAnimatePalette(HPALETTE hpal, UINT ulStartIndex,
                    UINT ulNumEntries,  CONST PALETTEENTRY *lpPaletteColors)
{
    BOOL bReturn = FALSE;

    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {
        bReturn = (BOOL) pal.ulAnimatePalette(ulStartIndex, ulNumEntries, lpPaletteColors);
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GreGetPaletteEntries
*
* API function
*
* returns: 0 for failure, else number of entries retrieved.
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreGetPaletteEntries(HPALETTE hpal, UINT ulStartIndex,
                                 UINT ulNumEntries, LPPALETTEENTRY pRGB)
{
    //
    // Note on this call we can just let the default palette go through
    // since it isn't getting modified, and the constructor is smart
    // enough not to really lock it down.
    //

    EPALOBJ pal((HPALETTE) hpal);

    if (!pal.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    return(pal.ulGetEntries(ulStartIndex, ulNumEntries, pRGB, FALSE));
}

/******************************Public*Routine******************************\
* GreSetPaletteEntries
*
* API function
*
* returns: 0 for failure, else number of entries retrieved.
*
* History:
*  18-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT
GreSetPaletteEntries(
    HPALETTE hpal,
    UINT     ulStartIndex,
    UINT     ulNumEntries,
    CONST PALETTEENTRY *pRGB
    )
{
    //
    // Note on this call we don't worry about STOCKOBJ_PAL because ulSetEntries
    // won't let the default palette get modified.
    //

    UINT uiReturn = 0;

    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {
        //
        // You must grab the palette semaphore to touch the linked list of DC's.
        //

        SEMOBJ  semo(ghsemPalette);

        uiReturn = (UINT) pal.ulSetEntries(ulStartIndex, ulNumEntries, pRGB);

        //
        // Run down all the DC's for this palette.
        // Set the flags to dirty the brushes, since we changed the palette!
        //

        {
            MLOCKFAST mlo;

            HDC hdcNext = pal.hdcHead();
            while ( hdcNext != (HDC)0 )
            {
                MDCOBJA dco(hdcNext);

                //
                // WINBUG #55203 2-1-2000 bhouse Remove temporary fix to avoid AV when setting DIRTY_BRUSHES
                // This is just a temp fix (since '95 hehehe) to keep
                // this from doing an AV. Lingyun, making the
                // brush flags all be in kernel memory will
                // fix this.
                //
                // this should just be
                // dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                //

                if (GreGetObjectOwner((HOBJ)hdcNext,DC_TYPE) ==  W32GetCurrentPID())
                {
                    dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                }
                else
                {
                    dco.pdc->flbrushAdd(DIRTY_FILL);
                }

                hdcNext = dco.pdc->hdcNext();
            }
        }
    }

    return(uiReturn);
}

/******************************Public*Routine******************************\
* GreGetNearestColor
*
* This function returns the color that will be displayed on the device
* if a solid brush was created with the given colorref.
*
* History:
*  Mon 29-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Don't round the color on non-indexed devices
*
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

COLORREF APIENTRY GreGetNearestColor(HDC hdc, COLORREF crColor)
{
    ULONG ulRet;

    DCOBJ   dco(hdc);

    if (dco.bValid())
    {

        //
        // Protect against dynamic mode changes while we go grunging
        // around in the surface.
        //

        DEVLOCKOBJ dlo;
        dlo.vLockNoDrawing(dco);

        XEPALOBJ palDC(dco.ppal());

        XEPALOBJ palSurf;

        SURFACE *pSurf = dco.pSurfaceEff();

        if ((dco.dctp() == DCTYPE_INFO) || (dco.dctp() == DCTYPE_DIRECT))
        {
            PDEVOBJ po(dco.hdev());
            ASSERTGDI(po.bValid(), "ERROR GreGetNearestColor invalid PDEV\n");

            palSurf.ppalSet(po.ppalSurf());
            ASSERTGDI(palSurf.bValid(), "ERROR GreGetNearestColor invalid palDefault");
        }
        else
        {
            ASSERTGDI(dco.dctp() == DCTYPE_MEMORY, "Not a memory DC type");
            palSurf.ppalSet(pSurf->ppal());
        }

        //
        // if ICM translate the color to CMYK, just return the passed CMYK color.
        //
        if (dco.pdc->bIsCMYKColor())
        {
            ulRet = crColor;
        }
        else
        {
            if (((crColor & 0x01000000) == 0) &&
                (palSurf.bValid() && !(palSurf.bIsIndexed())))
            {
                //
                // Well if it isn't index it's RGB,BGR, or Bitfields.
                // In any case to support Win3.1 we need to return exactly
                // what was passed in otherwise they think we are a monochrome
                // device.  Bitfields could result is some messy rounding so
                // it's more exact to just return the RGB passed in.
                //

                ulRet = crColor & 0x00FFFFFF;  // mask off the highest byte
            }
            else
            {
                ulRet = ulIndexToRGB(palSurf, palDC, ulGetNearestIndexFromColorref(palSurf, palDC, crColor));
            }
        }
    }
    else
    {
        ulRet = CLR_INVALID;
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* GreGetSystemPaletteEntries
*
* API Function - copies out the range of palette entries from the DC's
*                surface's palette.
*
* returns: number of entries retrieved from the surface palette, 0 for FAIL
*
* History:
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreGetSystemPaletteEntries(HDC hdc, UINT ulStartIndex,
                            UINT ulNumEntries, PPALETTEENTRY pRGB)
{
    UINT uiReturn = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Acquire the devlock while grunging in the surface palette to
        // protect against dynamic mode changes.
        //

        DEVLOCKOBJ dlo(po);

        if (po.bIsPalManaged())
        {
            XEPALOBJ palSurf(po.ppalSurf());
            uiReturn = (UINT) palSurf.ulGetEntries(ulStartIndex, ulNumEntries,
                                                   pRGB, TRUE);
        }
    }

    return(uiReturn);
}

/******************************Public*Routine******************************\
* GreGetSystemPaletteUse
*
* API function
*
* returns: SYSPAL_STATIC or SYSPAL_NOSTATIC, 0 for an error
*
* History:
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreGetSystemPaletteUse(HDC hdc)
{
    ULONG ulReturn = SYSPAL_ERROR;

    DCOBJ   dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Acquire the devlock while grunging in the surface palette to
        // protect against dynamic mode changes.
        //

        DEVLOCKOBJ dlo(po);

        if (po.bIsPalManaged())
        {
            XEPALOBJ palSurf(po.ppalSurf());

            if (palSurf.bIsNoStatic())
            {
                ulReturn = SYSPAL_NOSTATIC;
            }
            else if (palSurf.bIsNoStatic256())
            {
                ulReturn = SYSPAL_NOSTATIC256;
            }
            else
            {
                ulReturn = SYSPAL_STATIC;
            }
        }
    }

    return(ulReturn);
}

/******************************Public*Routine******************************\
* GreSetSystemPaletteUse
*
* API function - Sets the number of reserved entries if palette managed
*
* returns - the old flag for the palette, 0 for error
*
* History:
*  15-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

UINT APIENTRY GreSetSystemPaletteUse(HDC hdc, UINT ulUsage)
{
    //
    // Validate the parameters, Win3.1 sets the flag to static if it's invalid.
    //

    if ((ulUsage != SYSPAL_STATIC) && (ulUsage != SYSPAL_NOSTATIC) &&
        (ulUsage != SYSPAL_NOSTATIC256))
        ulUsage = SYSPAL_STATIC;

    //
    // Initialize return value.
    //

    ULONG ulReturn = SYSPAL_ERROR;
    BOOL bPalChanged = FALSE;
    ULONG i;

    DCOBJ   dco(hdc);

    if (dco.bValid())
    {
        //
        // Lock the screen semaphore so that we don't get flipped into
        // full screen after checking the bit.  This also protects us
        // from dynamic mode changes that change the 'bIsPalManaged'
        // status.
        //

        PDEVOBJ po(dco.hdev());

        DEVLOCKOBJ dlo(po);

        XEPALOBJ palSurf(po.ppalSurf());
        XEPALOBJ palDC(dco.ppal());

        if (po.bIsPalManaged())
        {
            //
            // The palette managed case.
            //

            {
                //
                // Protect access to the goodies in the system palette
                // with the SEMOBJ.  We don't want a realize happening
                // while we fiddle flags.
                //

                SEMOBJ  semo(ghsemPalette);

                if (palSurf.bIsNoStatic())
                {
                    ulReturn = SYSPAL_NOSTATIC;
                }
                else if (palSurf.bIsNoStatic256())
                {
                    ulReturn = SYSPAL_NOSTATIC256;
                }
                else
                {
                    ulReturn = SYSPAL_STATIC;
                }


                if (ulUsage == SYSPAL_STATIC)
                {
                    //
                    // reset the colors from their original copy in the devinfo palette.
                    // The copy already has the flags properly set.
                    //

                    if (palSurf.bIsNoStatic() || palSurf.bIsNoStatic256())
                    {
                        //
                        // Change the palette that GDI manages, copy over up to
                        // 20 static colors from ppalDefault
                        //

                        XEPALOBJ palOriginal(ppalDefault);
                        ASSERTGDI(palOriginal.bValid(), "ERROR ulMakeStatic0");

                        ULONG ulNumReserved = palSurf.ulNumReserved() >> 1;

                        if (ulNumReserved > 10)
                        {
                            ulNumReserved = 10;
                        }

                        //
                        // set the beginning entries
                        //

                        for (i = 0; i < ulNumReserved; i++)
                        {
                            PALETTEENTRY palEntry = palOriginal.palentryGet(i);

                            palEntry.peFlags = PC_USED | PC_FOREGROUND;
                            palSurf.palentrySet(i,palEntry);
                        }

                        //
                        // set the ending entries
                        //

                        ULONG ulCurrentPal = palSurf.cEntries();
                        ULONG ulCurrentDef = 20;

                        for (i = 0; i < ulNumReserved; i++)
                        {
                            PALETTEENTRY palEntry;

                            ulCurrentPal--;
                            ulCurrentDef--;

                            palEntry = palOriginal.palentryGet(ulCurrentDef);
                            palEntry.peFlags = PC_USED | PC_FOREGROUND;
                            palSurf.palentrySet(ulCurrentPal,palEntry);
                        }

                        //
                        // Mark the brushes dirty for this DC.
                        //

                        dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);


                        palSurf.flPalSet(palSurf.flPal() & ~PAL_NOSTATIC & ~PAL_NOSTATIC256);
                        palSurf.vUpdateTime();
                        bPalChanged = TRUE;
                    }
                }
                else if (ulUsage == SYSPAL_NOSTATIC)
                {
                    //
                    // unmark all the static colors, with the exception of black and
                    // white that stay with us.
                    //

                    for (i = 1; i < (palSurf.cEntries()-1); i++)
                    {
                        palSurf.apalColorGet()[i].pal.peFlags = 0;
                    }

                    palSurf.vSetNoStatic();
                }
                else //SYSPAL_NOSTATIC256
                {
                    //
                    // unmark all the static colors
                    //
                    for (i = 0; i < (palSurf.cEntries()); i++)
                    {
                        palSurf.apalColorGet()[i].pal.peFlags = 0;
                    }

                    palSurf.vSetNoStatic256();

                }

            }

            if (bPalChanged)
            {
                SEMOBJ so(po.hsemPointer());

                if (!po.bDisabled())
                {
                    po.pfnSetPalette()(
                        po.dhpdevParent(),
                        (PALOBJ *) &palSurf,
                        0,
                        0,
                        palSurf.cEntries());
                }
            }
        }
    }

    return(ulReturn);
}

/******************************Public*Routine******************************\
* NtGdiResizePalette()
*
* API function
*
* returns: TRUE for success, FALSE for failure
*
* History:
*  Tue 10-Sep-1991 -by- Patrick Haluptzok [patrickh]
* rewrite to be multi-threaded safe
*
*  19-Jan-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define PAL_MAX_SIZE 1024

BOOL
APIENTRY
NtGdiResizePalette(
    HPALETTE hpal,
    UINT     cEntry
    )
{
    //
    // Check for quick out before constructors
    //

    if ((cEntry > PAL_MAX_SIZE) || (cEntry == 0))
    {
        WARNING("GreResizePalette failed - invalid size\n");
        return(FALSE);
    }

    BOOL bReturn = FALSE;

    //
    // Validate the parameter.
    //

    EPALOBJ palOld(hpal);

    if ((palOld.bValid()) && (!palOld.bIsPalDefault()) && (palOld.bIsPalDC()))
    {
        //
        // Create a new palette. Don't mark it to keep because after
        // bSwap it will be palOld and we want it to be deleted.
        //

        PALMEMOBJ pal;

        if (pal.bCreatePalette(PAL_INDEXED,
                                cEntry,
                                (PULONG) NULL,
                                0, 0, 0,
                                PAL_DC | PAL_FREE))
        {

            //
            // Grab the palette semaphore which stops any palettes from being selected
            // in or out.  It protects the linked DC list, can't copy DC head until
            // we hold it.
            //

            SEMOBJ  semo(ghsemPalette);

            //
            // Copy the data from old palette.
            //

            pal.vCopyEntriesFrom(palOld);
            pal.flPalSet(palOld.flPal());
            pal.hdcHead(palOld.hdcHead());
            pal.hdev(palOld.hdev());
            pal.cRefhpal(palOld.cRefhpal());
            pal.vComputeCallTables();

            HDC hdcNext, hdcTemp;

            MLOCKFAST mlo;

            //
            // Run down the list and exclusive lock all the handles.
            //

            {
                hdcNext = pal.hdcHead();

                while (hdcNext != (HDC) 0)
                {
                    MDCOBJ dcoLock(hdcNext);

                    if (!dcoLock.bLocked())
                    {
                        WARNING1("ResizePalette failed because a DC the hpal is in is busy\n");
                        break;
                    }

                    hdcNext = dcoLock.pdc->hdcNext();
                    dcoLock.vDontUnlockDC();
                }
            }

            if (hdcNext == (HDC) 0)
            {
                //
                // We have the palette semaphore and all the DC's exclusively locked.  Noone else
                // can be accessing the translates because you must hold one of those things to
                // access them.  So we can delete the translates.
                //

                palOld.vMakeNoXlate();
                palOld.vUpdateTime();

                //
                // Note that bSwap calls locked SpapHandle vesrion so the Hmgr Resource
                // is required (luckily it was grabbed earlier).
                //

                //
                // try to swap palettes, bSwap can only succedd if
                // this routine owns the only locks on the objecs
                //

                bReturn = pal.bSwap((PPALETTE *) &palOld,1,1);

                if (bReturn)
                {
                    ASSERTGDI(bReturn, "ERROR no way");

                    //
                    // Run down all the DC's for this palette and update the pointer.
                    // Set the flags to dirty the brushes since we changed the palette.
                    //

                    {
                        hdcNext = pal.hdcHead();

                        while (hdcNext != (HDC)0)
                        {
                            MDCOBJA dcoAltLock(hdcNext);
                            dcoAltLock.pdc->ppal(palOld.ppalGet());
                            dcoAltLock.ulDirty(dcoAltLock.ulDirty() | DIRTY_BRUSHES);
                            hdcNext = dcoAltLock.pdc->hdcNext();
                        }
                    }
                }
                else
                {
                    WARNING1("ResizePalette failed - ref count != 1\n");
                }

            }
            else
            {
                WARNING1("ResizePalette failed lock of DC in chain\n");
            }

            //
            // Unlock all the DC we have locked and return FALSE
            //

            {
                hdcTemp = pal.hdcHead();

                while (hdcTemp != hdcNext)
                {
                    MDCOBJ dcoUnlock(hdcTemp);
                    ASSERTGDI(dcoUnlock.bLocked(), "ERROR couldn't re-lock to unlock");
                    DEC_EXCLUSIVE_REF_CNT(dcoUnlock.pdc);
                    hdcTemp = dcoUnlock.pdc->hdcNext();
                }
            }
        }
        else
        {
            WARNING("GreResizePalette failed palette creation\n");
        }
    }
    else
    {
        WARNING("GreResizePalette failed invalid hpal\n");
    }

    return(bReturn);
}

/******************************Public*Routine******************************\
* GreUpdateColors
*
* API function - Updates the colors in the Visible Region for a Window on
* a palette mangaged device.
*
* This is an example of how UpdateColors is used:
*
*   case WM_PALETTECHANGED:
*
*       // if NTPAL was not responsible for palette change and if
*       // palette realization causes a palette change, do a redraw.
*
*       if ((HWND)wParam != hWnd)
*       {
*           if (bLegitDraw)
*           {
*               hDC = GetDC(hWnd);
*               hOldPal = SelectPalette(hDC, hpalCurrent, 0);
*
*               i = RealizePalette(hDC);
*
*               if (i)
*               {
*                   if (bUpdateColors)
*                   {
*                       UpdateColors(hDC);
*                       UpdateCount++;
*                   }
*                   else
*                       InvalidateRect(hWnd, (LPRECT) (NULL), 1);
*               }
*
*               SelectPalette(hDC, hOldPal, 0);
*               ReleaseDC(hWnd, hDC);
*           }
*       }
*       break;
*
* The hpal can only be selected into 1 type of device DC at a time.
* Xlates from the DC palette to the surface palette are only done on DC's
* that are for the PDEV surface.  Since an hpal can only be selected into
* one of these and creation and deletion of the pxlate needs to be semaphored
* we use the PDEV semaphore to protect it's access.
*
* An xlate vector mapping the DC palette to the surface palette is created
* during a RealizePalette if the surface is a palette managed device.  This
* is put in pxlate in the hpal.  The old pxlate is moved into pxlateOld
* and the xlate in pxlateOld is deleted.  UpdateColors works by looking at
* the difference between the current xlate mapping and the old xlate mapping
* and updating the pixels in the VisRgn to get a closest mapping.
*
* This API can only be called once for a palette.  The old xlate is deleted
* during UpdateColors so that the next time it is called it will fail.  This
* is because it only makes sense to update the pixels once.  Doing it more
* than once would give ugly unpredictable results.
*
* History:
*  12-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiUpdateColors(HDC hdc)
{
    BOOL bReturn = FALSE;

    DCOBJ   dco(hdc);

    if (!dco.bValidSurf())
    {
        return(FALSE);
    }

    PDEVOBJ pdo(dco.hdev());

    //
    // Grab DEVLOCK for output and to lock the surface
    //

    DEVLOCKOBJ dlo(dco);

    if (pdo.bIsPalManaged())
    {
        SURFACE *pSurf = dco.pSurface();

        //
        // This only works on palette managed surfaces.
        //

        if (pSurf == pdo.pSurface())
        {
            XEPALOBJ palSurf(pSurf->ppal());
            XEPALOBJ palDC(dco.ppal());

            //
            // Accumulate bounds.  We can do this before knowing if the operation is
            // successful because bounds can be loose.
            //

            if (dco.fjAccum())
                dco.vAccumulate(dco.erclWindow());

            if (dlo.bValid())
            {
                if ((palDC.ptransCurrent() != NULL) &&
                    (palDC.ptransOld() != NULL))
                {
                    XLATEMEMOBJ xlo(palSurf, palDC);

                    if (xlo.bValid())
                    {
                        ECLIPOBJ co(dco.prgnEffRao(), dco.erclWindow());

                        //
                        // Check the destination which is reduced by clipping.
                        //

                        if (!co.erclExclude().bEmpty())
                        {
                            //
                            // Exclude the pointer.
                            //

                            DEVEXCLUDEOBJ dxo(dco,&co.erclExclude(),&co);

                            //
                            // Inc the target surface uniqueness
                            //

                            INC_SURF_UNIQ(pSurf);

                            if (!pdo.bMetaDriver())
                            {
                                //
                                // Dispatch the call.  Give it no mask.
                                //

                                bReturn = (*PPFNGET(pdo, CopyBits, pSurf->flags())) (
                                        pSurf->pSurfobj(),
                                        pSurf->pSurfobj(),
                                        &co,
                                        xlo.pxlo(),
                                        (RECTL *) &co.erclExclude(),
                                        (POINTL *) &co.erclExclude());
                            }
                            else
                            {
                                //
                                // Dispatch to DDML.
                                //

                                bReturn = MulUpdateColors(
                                        pSurf->pSurfobj(),
                                        &co,
                                        xlo.pxlo());
                            }
                        }
                        else
                            bReturn = TRUE;
                    }
                }
                else
                    bReturn = TRUE;  // Nothing to update
            }
            else
            {
                bReturn = dco.bFullScreen();
            }
        }
    }

    return(bReturn);
}


/******************************Public*Routine******************************\
* RealizeDefaultPalette
*
* Take away colors that have been realized by other Windows.  Reset it to
* state where no colors have been taken.  Return number of colors
*
* History:
*  07-Jan-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C"
ULONG GreRealizeDefaultPalette(
    HDC  hdcScreen,
    BOOL bClearDefaultPalette)
{

    DCOBJ dco(hdcScreen);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Block out the GreRealizePalette code.  Also protect us from
        // dynamic mode changes while we grunge in the surface palette.
        //
        DEVLOCKOBJ dlo(po);

        SEMOBJ  semo(ghsemPalette);

        if (po.bIsPalManaged())
        {
            XEPALOBJ palSurf(po.ppalSurf());
            ASSERTGDI(palSurf.bIsPalManaged(), "GreRealizeDefaultPalette");

            //
            // Now map back to static colors if necesary.  Win3.1 does not do this but we do
            // just in case naughty app died and left the palette hosed.
            //
            //
            if (palSurf.bIsNoStatic() || palSurf.bIsNoStatic256())
            {
                GreSetSystemPaletteUse(hdcScreen, SYSPAL_STATIC);
            }

            //
            // Get rid of the PC_FOREGROUND flag from the non-reserved entries.
            //

            ULONG ulTemp = palSurf.ulNumReserved() >> 1;
            ULONG ulMax = palSurf.cEntries() - ulTemp;

            for (; ulTemp < ulMax; ulTemp++)
            {
                palSurf.apalColorGet()[ulTemp].pal.peFlags &= (~PC_FOREGROUND);
            }

            if (bClearDefaultPalette)
            {
                hForePalette = NULL;
            }

            palSurf.vUpdateTime();

            //
            // Mark the brushes dirty.
            //

            dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
        }
    }
    else
    {
        WARNING("ERROR User called RealizeDefaultPalette with bad hdc\n");
    }

    //
    // What should this return value be ?
    //

    return(0);
}


/******************************Public*Routine******************************\
* UnrealizeObject
*
* Resets a logical palette.
*
* History:
*  16-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GreUnrealizeObject(HANDLE hpal)
{
    BOOL bReturn = FALSE;

    EPALOBJ pal((HPALETTE) hpal);

    if (pal.bValid())
    {

        //
        // You must grab the palette semaphore to access the translates.
        //

        SEMOBJ  semo(ghsemPalette);

        if (pal.ptransFore() != NULL)
        {
            pal.ptransFore()->iUniq = 0;
        }

        if (pal.ptransCurrent() != NULL)
        {
            pal.ptransCurrent()->iUniq = 0;
        }

        bReturn = TRUE;
    }

    return(bReturn);
}


/******************************Public*Routine******************************\
* GreRealizePalette
*
* Re-written to be Win3.1 compatible.
*
* History:
*  22-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" DWORD GreRealizePalette(HDC hdc)
{
    ULONG nTransChanged = 0;
    ULONG nPhysChanged = 0;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Lock the screen semaphore so that we don't get flipped into
        // full screen after checking the bit.  This also protects us
        // from dynamic mode changes that change the 'bIsPalManaged'
        // status.
        //

        DEVLOCKOBJ dlo(po);

        XEPALOBJ palSurf(po.ppalSurf());
        XEPALOBJ palDC(dco.ppal());

        HPALETTE hpalDC = palDC.hpal();
        HDC hdcNext, hdcTemp;

        if (po.bIsPalManaged())
        {
            ASSERTGDI(palSurf.bIsPalManaged(), "GreRealizePalette");

            //
            // Access to the ptrans and the fields of the hpal are protected by
            // this semaphore.
            //

            SEMOBJ  semo(ghsemPalette);

            if ((SAMEHANDLE(hpalDC,hForePalette)) ||
                ((dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
                 (SAMEINDEX(hpalDC, hForePalette)) &&
                 (hForePID == W32GetCurrentProcess())))
            {
                //
                // Check for early out.
                //

                if (palDC.bIsPalDefault())
                {
                    //
                    // Do nothing.
                    //

                    PAL_DEBUG(2,"DC has default palette quick out\n");

                }
                else
                {
                    if ((palDC.ptransFore() != NULL) &&
                        (palDC.ptransFore() == palDC.ptransCurrent()) &&
                        (palDC.ptransFore()->iUniq == palSurf.ulTime()))
                    {
                        //
                        // Everything is valid.
                        //

                        PAL_DEBUG(2,"ptransCurrent == ptransFore quick out\n");
                    }
                    else
                    {
                        MLOCKFAST mlo;

                        //
                        // Run down the list and exclusive lock all the handles.
                        //

                        {
                            hdcNext = palDC.hdcHead();

                            while (hdcNext != (HDC) 0)
                            {
                                MDCOBJ dcoLock(hdcNext);

                                if (!dcoLock.bLocked())
                                {
                                    WARNING1("GreRealizePalette failed because a DC the hpal is in is busy\n");
                                    break;
                                }

                                dcoLock.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                                hdcNext = dcoLock.pdc->hdcNext();
                                dcoLock.vDontUnlockDC();
                            }
                        }

                        if (hdcNext == (HDC) 0)
                        {
                            //
                            // Get rid of the old mapping, it is useless now.
                            //

                            if (palDC.ptransOld())
                            {
                                if (palDC.ptransOld() != palDC.ptransFore())
                                    VFREEMEM(palDC.ptransOld());

                                palDC.ptransOld(NULL);
                            }

                            //
                            // Check if we have stale translates.
                            // UnrealizeObject and SetPaletteEntries can cause it.
                            //

                            if ((palDC.ptransFore()) && (palDC.ptransFore()->iUniq == 0))
                            {
                                if (palDC.ptransCurrent() != palDC.ptransFore())
                                    VFREEMEM(palDC.ptransFore());

                                palDC.ptransFore(NULL);
                            }

                            //
                            // Check if we need a new foreground realization.
                            //

                            if (palDC.ptransFore() == NULL)
                            {
                                //
                                // Need to force ourselves in for the first time.
                                //

                                PAL_DEBUG(2,"Creating a foreground realization\n");

                                palDC.ptransFore(ptransMatchAPal(dco.pdc,palSurf, palDC, TRUE, &nPhysChanged, &nTransChanged));

                                if (palDC.ptransFore() == NULL)
                                {
                                    WARNING("RealizePalette failed initial foreground realize\n");
                                }
                            }
                            else
                            {
                                //
                                // Foreground Realize already done and isn't stale.
                                // Force the foreground mapping into the physical palette.
                                //

                                PAL_DEBUG(2,"Forcing a foreground realization in to palette\n");


                                vMatchAPal(dco.pdc,palSurf, palDC, &nPhysChanged, &nTransChanged);
                            }

                            palDC.ptransOld(palDC.ptransCurrent());
                            palDC.ptransCurrent(palDC.ptransFore());
                        }
                        else
                        {
                            WARNING("GreRealizePalette failed to lock down all DC's in linked list\n");
                        }

                        //
                        // Unlock all the DC we have locked.
                        //

                        {
                            hdcTemp = palDC.hdcHead();

                            while (hdcTemp != hdcNext)
                            {
                                MDCOBJ dcoUnlock(hdcTemp);
                                ASSERTGDI(dcoUnlock.bLocked(), "ERROR couldn't re-lock to unlock");
                                DEC_EXCLUSIVE_REF_CNT(dcoUnlock.pdc);
                                hdcTemp = dcoUnlock.pdc->hdcNext();
                            }
                        }
                    }

                }
            }
            else
            {
                //
                // We are a background palette.
                //

                if (!palDC.bIsPalDefault())
                {

                    //
                    // Check for the quick out.
                    //

                    if ((palDC.ptransCurrent() != NULL) &&
                        (palDC.ptransCurrent()->iUniq == palSurf.ulTime()))
                    {
                        //
                        // Well it's good enough.  Nothing has changed that
                        // would give us any better mapping.
                        //

                        PAL_DEBUG(2,"ptransCurrent not foreground but good enough\n");
                    }
                    else
                    {
                        MLOCKFAST mlo;

                        //
                        // Run down the list and exclusive lock all the handles.
                        //

                        {
                            hdcNext = palDC.hdcHead();

                            while (hdcNext != (HDC) 0)
                            {
                                MDCOBJ dcoLock(hdcNext);

                                if (!dcoLock.bLocked())
                                {
                                    WARNING1("GreRealizePalette failed because a DC the hpal is in is busy\n");
                                    break;
                                }

                                dcoLock.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);
                                hdcNext = dcoLock.pdc->hdcNext();
                                dcoLock.vDontUnlockDC();
                            }
                        }

                        if (hdcNext == (HDC) 0)
                        {
                            //
                            // We have work to do, get rid of the old translate.
                            //

                            if (palDC.ptransOld())
                            {
                                if (palDC.ptransOld() != palDC.ptransFore())
                                    VFREEMEM(palDC.ptransOld());

                                palDC.ptransOld(NULL);
                            }

                            //
                            // Check if we have stale translates.
                            // UnrealizeObject and SetPaletteEntries can cause it.
                            //

                            if ((palDC.ptransFore()) && (palDC.ptransFore()->iUniq == 0))
                            {
                                if (palDC.ptransCurrent() != palDC.ptransFore())
                                {
                                        VFREEMEM(palDC.ptransFore());
                                }

                                palDC.ptransFore(NULL);
                            }

                            //
                            // Check for initial foreground realization.
                            //

                            PAL_DEBUG(2,"Realizing in the background\n");

                            if (palDC.ptransFore() == NULL)
                            {
                                //
                                //  Create a scratch pad to establish a foreground realize.
                                //

                                PAL_DEBUG(2,"Making ptransFore in the background\n");

                                PALMEMOBJ palTemp;

                                if (palTemp.bCreatePalette(PAL_INDEXED,
                                                           palSurf.cEntries(),
                                                           NULL,
                                                           0, 0, 0, PAL_MANAGED))
                                {
                                    ULONG ulTemp = 0;
                                    ASSERTGDI(palTemp.cEntries() == 256, "ERROR palTemp invalid");

                                    palTemp.vCopyEntriesFrom(palSurf);
                                    palTemp.ulNumReserved(palSurf.ulNumReserved());
                                    palTemp.flPalSet(palSurf.flPal());
                                    palTemp.vComputeCallTables();

                                    PAL_DEBUG(2,"Need to make a foreground realize first\n");

                                    //
                                    // Need to map ourselves for the first time.  This actually doesn't
                                    // change the current surface palette but instead computes the
                                    // translate vector that would result if it was to be mapped in now.
                                    //

                                    palDC.ptransFore(ptransMatchAPal(dco.pdc,palTemp, palDC, TRUE, &ulTemp, &ulTemp));
                                }

                                #if DBG
                                if (palDC.ptransFore() == NULL)
                                {
                                    WARNING("RealizePalette failed initial foreground realize\n");
                                }
                                #endif
                            }

                            //
                            // Save the Current mapping into Old.
                            //

                            palDC.ptransOld(palDC.ptransCurrent());

                            if (palDC.ptransFore() == NULL)
                            {
                                //
                                // The Current can't be set if the Fore
                                // is NULL so we're done.
                                //

                                palDC.ptransCurrent(NULL);
                            }
                            else
                            {
                                //
                                // Get the new Current mapping.
                                //

                                PAL_DEBUG(2,"Making ptransCurrent\n");

                                palDC.ptransCurrent(ptransMatchAPal(dco.pdc,palSurf, palDC, FALSE, &nPhysChanged, &nTransChanged));

                                if (palDC.ptransCurrent() == NULL)
                                {
                                    //
                                    // Well we can't have the foreground set
                                    // and the current being NULL so just
                                    // make it foreground for this memory
                                    // failure case.
                                    //

                                    palDC.ptransCurrent(palDC.ptransFore());
                                    WARNING("ptransCurrent failed allocation in RealizePalette");
                                }
                            }
                        }

                        //
                        // Unlock all the DC we have locked.
                        //

                        {
                            hdcTemp = palDC.hdcHead();

                            while (hdcTemp != hdcNext)
                            {
                                MDCOBJ dcoUnlock(hdcTemp);
                                ASSERTGDI(dcoUnlock.bLocked(), "ERROR couldn't re-lock to unlock");
                                DEC_EXCLUSIVE_REF_CNT(dcoUnlock.pdc);
                                hdcTemp = dcoUnlock.pdc->hdcNext();
                            }
                        }
                    }
                }
            }
        }

        //
        // Check if the device needs to be notified.
        //

        if (nPhysChanged)
        {
            //
            // Lock the screen semaphore so that we don't get flipped into
            // full screen after checking the bit.
            //

            GreAcquireSemaphoreEx(po.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(po.ppdev, WD_DEVLOCK);

            {
                SEMOBJ so(po.hsemPointer());

                if (!po.bDisabled())
                {
                    po.pfnSetPalette()(
                        po.dhpdevParent(),
                        (PALOBJ *) &palSurf,
                        0,
                        0,
                        palSurf.cEntries());
                }
            }

            GreExitMonitoredSection(po.ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(po.hsemDevLock());

            //
            // mark palsurf if it is a halftone palette
            //

            if (palSurf.cEntries() == 256)
            {
                ULONG ulIndex;
                for (ulIndex=0;ulIndex<256;ulIndex++)
                {
                    if (
                         (palSurf.ulEntryGet(ulIndex) & 0xffffff) !=
                         (aPalHalftone[ulIndex].ul & 0xffffff)
                       )
                    {
                        break;
                    }
                }

                if (ulIndex == 256)
                {
                    palSurf.flPal(PAL_HT);
                }
                else
                {
                    FLONG fl = palSurf.flPal();
                    fl &= ~PAL_HT;
                    palSurf.flPalSet(fl);
                }
            }
        }
    }

    return(nTransChanged | (nPhysChanged << 16));
}


/******************************Public*Routine******************************\
* IsDCCurrentPalette
*
* Returns TRUE if the palette is the foreground palette.
*
* History:
*  18-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C" BOOL IsDCCurrentPalette(HDC hdc)
{
    BOOL bReturn = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        if ((SAMEHANDLE(dco.hpal(), (HPAL)hForePalette)) ||
            ((dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
             (SAMEINDEX(dco.hpal(), hForePalette)) &&
             (hForePID == W32GetCurrentProcess())))
        {
            bReturn = TRUE;
        }
    }

    return(bReturn);
}



/******************************Public*Routine******************************\
* GreSelectPalette
*
* API function for selecting palette into the DC.
*
* Returns previous hpal if successful, (HPALETTE) 0 for failure.
*
* History:
*  17-Nov-1990 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

extern "C"
HPALETTE GreSelectPalette(
    HDC      hdc,
    HPALETTE hpalNew,
    BOOL     bForceBackground)
{

    //
    // The palette semaphore serializes access to the reference count and
    // the linked list of DC's a palette is selected into.  We don't want
    // 2 people trying to select at the same time.  We must hold this between
    // the setting of the hsem and the incrementing of the reference count.
    //

    SEMOBJ  semo(ghsemPalette);

    //
    // Validate and lock down the DC and new palette.
    //

    DCOBJ dco(hdc);
    EPALOBJ palNew(hpalNew);

    #if DBG
        if (DbgPal >= 2)
        {
            DbgPrint("GreSelectPalette %p\n",palNew.ppalGet());
        }
    #endif

    if ((!dco.bLocked()) ||
        (!palNew.bValid())|| (!palNew.bIsPalDC()))
    {
        //
        // Error code logged by failed lock.
        //

        WARNING1("GreSelectPalette failed, invalid palette or DC\n");
        return((HPALETTE)NULL);
    }

    if (!bForceBackground)
    {
        hForePID = W32GetCurrentProcess();
        hForePalette = hpalNew;
    }

    HPAL hpalOld = (HPAL) dco.hpal();

    if (SAMEHANDLE(hpalOld,(HPAL)hpalNew))
    {
        return((HPALETTE)hpalOld);
    }

    PDEVOBJ po(dco.hdev());
    XEPALOBJ palOld(dco.ppal());

    //
    // Check that we aren't trying to select the palette into a
    // device incompatible with a type we are already selected into.
    // We need to be able to translate from the DC hpal to the surface hpal
    // to do Animate, ect. So we can only be selected into one
    // surface with a PAL_MANAGED hpal because we only maintain one
    // translate table in the DC hpal.
    //

    if (!palNew.bIsPalDefault())
    {
        if (!palNew.bSet_hdev(dco.hdev()))
        {
            WARNING("GreSelectPalette failed hsemDisplay check\n");
            return((HPALETTE)NULL);
        }
    }

    //
    // Grab the multi-lock semaphore to run the DC link list.
    //

    MLOCKFAST mlo;

    //
    // Take care of the old hpal.  Remove from linked list.  Decrement cRef.
    // Remove the hdc from the linked list of DC's associated with palette.
    //

    palOld.vRemoveFromList(dco);

    //
    // Set the new palette in so the old hpal is truly gone.
    //

    dco.pdc->hpal((HPAL)hpalNew);
    dco.pdc->ppal(palNew.ppalGet());
    dco.ulDirty(dco.ulDirty() | DIRTY_BRUSHES);

    //
    // Associate the palette with the bitmap for use when converting DDBs
    // to DIBs for dynamic mode changes.  We don't associate the default
    // palette because the normal usage pattern is:
    //
    //     hpalOld = SelectPalette(hdc, hpal);
    //     RealizePalette(hdc);
    //     BitBlt(hdc);
    //     SelectPalette(hdc, hpalOld);
    //

    if ((dco.bHasSurface()) && (!palNew.bIsPalDefault()))
    {
        dco.pSurface()->hpalHint(hpalNew);
    }

    //
    // Take care of the new hpal.
    //

    palNew.vAddToList(dco);

    return((HPALETTE)hpalOld);
}

/******************************Public*Routine******************************\
* ulMagicFind - look for given magic color in default palette
*
* Arguments:
*
*   clrMagic - COLORREF of color to search for
*
* Return Value:
*
*   Index if found, 0xffffffff if not found.
*
* History:
*
*    15-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
ulMagicFind(
    PALETTEENTRY peMagic
    )
{
    XEPALOBJ xePalDefault(ppalDefault);
    return(xePalDefault.ulGetMatchFromPalentry(peMagic));
}


/******************************Public*Routine******************************\
* bSetMagicColor - set the specified magic color in both the device
*   palette and the default palette
*
* Arguments:
*
*   hdev     - hdev
*   Index    - magic color index (8,9,246,247)
*   palSurf  - surface palette
*   palDC    - logical palette
*   palColor - magic color
*
* Return Value:
*
*   Status
*
* History:
*
*    15-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

extern PPALETTE gppalHalftone;

BOOL
bSetMagicColor(
    XEPALOBJ     palSurf,
    ULONG        ulIndex,
    PAL_ULONG    PalEntry
    )
{
    BOOL bRet = FALSE;

    ASSERTGDI(((ulIndex == 8) || (ulIndex == 9) || (ulIndex == 246) || (ulIndex == 247)),
                "bSetMagicColor Error, wrong palette  index");

    //
    // make sure there are 20 reserved entries, and the static
    // colors are in use
    //

    if (
         (palSurf.ulNumReserved() == 20) &&
          (!palSurf.bIsNoStatic()) &&
          (!palSurf.bIsNoStatic256())
       )
    {
        //
        // set the entrie in the surface palette
        //

        PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
        palSurf.ulEntrySet(ulIndex,PalEntry.ul);

        //
        // update the palette time stamp
        //

        palSurf.vUpdateTime();

        //
        // set colors in the defaukt halftone palette for multimon system
        //
        
        if (gppalHalftone)
        {
            XEPALOBJ palHalftone(gppalHalftone);
            palHalftone.ulEntrySet(ulIndex,PalEntry.ul);
        }

        //
        // offset to upper half of default palette if needed
        //

        if (ulIndex > 10)
        {
            ulIndex = ulIndex - 236;
        }

        PalEntry.pal.peFlags = 0;

        //
        // set colors in the default Logical palette.
        //

        logDefaultPal.palPalEntry[ulIndex] = PalEntry.pal;

        //
        // set colors in the default palette and default log palette
        //

        XEPALOBJ palDefault(ppalDefault);
        palDefault.ulEntrySet(ulIndex,PalEntry.ul);

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* vResetSurfacePalette - copy the magic colors from the default palette
*   to the surface palette, and call the driver to set the palette
*
* NOTE: The devlock and pointer semaphore must already be held!
*
* Arguments:
*
*   po       - PDEV object
*   palSurf  - surface palette
*
* Return Value:
*
*   Status
*
* History:
*
*    21-Mar-1996 -by- J. Andrew Goossen [andrewgo]
*
\**************************************************************************/

VOID
vResetSurfacePalette(
    HDEV         hdev
    )
{
    PDEVOBJ po(hdev);

    if (po.bIsPalManaged())
    {
        XEPALOBJ palSurf(po.ppalSurf());

        ASSERTGDI(palSurf.bValid(), "Invalid surface palette");

        if (
             (palSurf.ulNumReserved() == 20) &&
             (!palSurf.bIsNoStatic()) &&
             (!palSurf.bIsNoStatic256())
           )
        {
            PAL_ULONG PalEntry;

            XEPALOBJ palDefault(ppalDefault);

            //
            // set the entries in the surface palette
            //

            PalEntry.pal = palDefault.palentryGet(8);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(8,PalEntry.ul);

            PalEntry.pal = palDefault.palentryGet(9);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(9,PalEntry.ul);

            PalEntry.pal = palDefault.palentryGet(246 - 236);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(246,PalEntry.ul);

            PalEntry.pal = palDefault.palentryGet(247 - 236);
            PalEntry.pal.peFlags = PC_FOREGROUND | PC_USED;
            palSurf.ulEntrySet(247,PalEntry.ul);
        }

        if (!po.bDisabled())
        {
            (*PPFNDRV(po,SetPalette))(
                po.dhpdev(),
                (PALOBJ *) &palSurf,
                0,
                0,
                palSurf.cEntries());
        }
    }
}

/******************************Public*Routine******************************\
*
* GreSetMagicColor  win95 compatible: set surface and default palette
*                   "magic" entries. This changes the default palette,
*                   and will affect bitmaps that think they have the
*                   correct 20 default colors already...
*
* Arguments:
*
*   hdc     - DC, specifies device surface
*   Index   - magic index, 1 of 8,9,246,247
*   peMagic - new color
*
* Return Value:
*
*   Status
*
* History:
*
*    10-Nov-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
NtGdiSetMagicColors(
    HDC          hdc,
    PALETTEENTRY peMagic,
    ULONG        Index
    )
{
    return(GreSetMagicColors(hdc,peMagic,Index));
}

BOOL
GreSetMagicColors(
    HDC          hdc,
    PALETTEENTRY peMagic,
    ULONG        Index
    )
{
    DCOBJ     dco(hdc);
    BOOL      bRet = FALSE;
    BOOL      bPaletteChange = FALSE;
    BOOL      bChildDriver = FALSE;

    if (dco.bValid())
    {
        if (
             (Index == 8)   ||
             (Index == 9)   ||
             (Index == 246) ||
             (Index == 247)
           )
        {
            PAL_ULONG PalEntry;

            PalEntry.pal = peMagic;

            //
            // must be RGB or PALETTERGB
            //

            if (
                 ((PalEntry.ul & 0xff000000) == 0) ||
                 ((PalEntry.ul & 0xff000000) == 0x02000000)
               )
            {
                PDEVOBJ  po(dco.hdev());
                BOOL     bSetColor = FALSE;

                //
                // Lock the screen semaphore so that we don't get flipped into
                // full screen after checking the bit.  Plus it also protects
                // us from a dynamic mode change, which can change the
                // bIsPalManaged status.
                //

                DEVLOCKOBJ dlo(po);

                if (po.bIsPalManaged())
                {
                    bSetColor = TRUE;
                }
                else if (po.bMetaDriver())
                {
                    //
                    // If this is meta-driver, check if there is any palette device
                    //
                    PVDEV     pvdev = (VDEV*) po.dhpdev();
                    PDISPSURF pds   = pvdev->pds;
                    LONG      csurf = pvdev->cSurfaces;
                    do
                    {
                        po.vInit(pds->hdev);
                        if (po.bIsPalManaged())
                        {
                            bSetColor = TRUE;
                            bChildDriver = TRUE;
                            break;
                        }
                        pds = pds->pdsNext;
                    } while (--csurf);
                }

                if (bSetColor)
                {
                    XEPALOBJ palSurf(po.ppalSurf());

                    //
                    // palette sem scope
                    //

                    {
                        SEMOBJ  semPalette(ghsemPalette);

                        //
                        // look for color
                        //

                        ULONG ulMagicIndex = ulMagicFind(PalEntry.pal);

                        if (ulMagicIndex != 0xffffffff)
                        {
                            //
                            // found exact match
                            //

                            if (ulMagicIndex >= 10)
                            {
                                //
                                // the returned index must be adjusted for surface palette
                                //

                                ulMagicIndex += 236;
                            }

                            if (ulMagicIndex == Index)
                            {
                                if (bChildDriver)
                                {
                                    // If this is child of meta driver, we still need to call
                                    // driver to update palette. (in the ppalDefault, doesn't
                                    // mean in the child surface palette).
                                    //
                                    // set magic color
                                    //

                                    bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                                    bRet = bPaletteChange;
                                }
                                else
                                {
                                    //
                                    // already set
                                    //

                                    bRet = TRUE;
                                }
                            }
                            else
                            {
                                //
                                // make sure RGB is not a non-magic VGA color,
                                // if there is a match, it can only be a magic
                                // color
                                //

                                if (
                                     (ulMagicIndex == 8) ||
                                     (ulMagicIndex == 9) ||
                                     (ulMagicIndex == 246) ||
                                     (ulMagicIndex == 247)
                                   )
                                {
                                    //
                                    // set magic color
                                    //

                                    bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                                    bRet = bPaletteChange;
                                }
                                else
                                {
                                    //
                                    // bad rgb, restore Index with
                                    // default color
                                    //

                                    if (Index == 8)
                                    {
                                        PalEntry.ul = 0x00C0DCC0;
                                    }
                                    else if (Index == 9)
                                    {
                                        PalEntry.ul = 0x00F0CAA6;
                                    }
                                    else if (Index == 246)
                                    {
                                        PalEntry.ul = 0x00F0FBFF;
                                    }
                                    else
                                    {
                                        PalEntry.ul = 0x00A4A0A0;
                                    }

                                    bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                                    bRet = FALSE;
                                }
                            }
                        }
                        else
                        {
                            //
                            // set magic color
                            //

                            bPaletteChange = bSetMagicColor(palSurf,Index,PalEntry);
                            bRet = bPaletteChange;
                        }
                    }

                    if (bPaletteChange)
                    {
                        SEMOBJ so(po.hsemPointer());

                        if (!po.bDisabled())
                        {
                            po.pfnSetPalette()(
                                po.dhpdevParent(),
                                (PALOBJ *) &palSurf,
                                0,
                                0,
                                palSurf.cEntries());
                        }
                    }
                }
            }
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\palddi.cxx ===
/******************************Module*Header*******************************\
* Module Name: palddi.cxx
*
* provides driver callbacks for palette management.
*
* Created: 06-Dec-1990 11:16:58
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* EngCreatePalette
*
* This is the engine entry point for device drivers to create palettes.
*
* History:
*  05-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HPALETTE EngCreatePalette(
ULONG iMode,
ULONG cColors,
PULONG pulColors,
FLONG flRed,
FLONG flGre,
FLONG flBlu)
{
    HPALETTE hpal = (HPALETTE) 0;
    BOOL     bUMPD = iMode & UMPD_FLAG;
    PALMEMOBJ pal;

    iMode = iMode & ~UMPD_FLAG;

// If PAL_BITFIELDS, check to see if we can substitute one of the
// special cases PAL_RGB or PAL_BGR.

    if ( (iMode == PAL_BITFIELDS) && (flGre == 0x0000ff00) &&
         ( ((flRed == 0x000000ff) && (flBlu == 0x00ff0000)) ||
           ((flRed == 0x00ff0000) && (flBlu == 0x000000ff)) ) )
    {
        iMode = (flRed == 0x000000ff) ? PAL_RGB : PAL_BGR;
    }

// We default to assuming it's fixed palette and then at EngAssociate
// time we look at his pdev and decide if this guy is more capable
// than that and set the palette up accordingly.

    if (pal.bCreatePalette(iMode, cColors, pulColors,
                           flRed, flGre, flBlu, PAL_FIXED))
    {
        pal.vKeepIt();
        hpal = (HPALETTE)pal.hpal();
        pal.ppalSet(NULL);      // Leave a reference count of 1 so that we
                                // can do vUnrefPalette() in EngDeletePalette

        if (bUMPD)
        {
            GreSetPaletteOwner(hpal, OBJECT_OWNER_CURRENT);
        }
    }

    return(hpal);
}

/******************************Public*Routine******************************\
* EngQueryPalette
*
* This is the engine entry point for device drivers to query palettes.
* This is intended mostly for remote-control drivers such as NetMeeting
* to determine the palette type of the primary display.
*
* Note that the driver has to look at GCAPS_PALMANAGED to determine
* whether it's a fixed palette or not.
*
* History:
*  04-Jan-1997 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

ULONG EngQueryPalette(
HPALETTE    hpal,
ULONG      *piMode,
ULONG       cColors,
ULONG      *pulColors)
{
    ULONG ulRet = 0;

    EPALOBJ pal(hpal);
    if (pal.bValid())
    {
        *piMode
            = pal.flPal() & (PAL_INDEXED | PAL_BITFIELDS | PAL_RGB | PAL_BGR);

        if (pal.cEntries() != 0)
        {
            // It's palettized:

            ulRet = pal.ulGetEntries(0, cColors, (PALETTEENTRY*) pulColors, TRUE);
        }
        else
        {
            // It's bitfields:

            ulRet = 3;

            if ((cColors >= 3) && (pulColors != NULL))
            {
                *(pulColors)     = pal.flRed();
                *(pulColors + 1) = pal.flGre();
                *(pulColors + 2) = pal.flBlu();
            }
        }
    }
    else
    {
        WARNING("EngQueryPalette -- Invalid palette");
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* EngDeletePalette
*
* Driver entry point for deleting palettes it has created
*
* History:
*  05-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL EngDeletePalette(HPALETTE hpal)
{
    BOOL b = FALSE;

    EPALOBJ palobj(hpal);
    if (palobj.bValid() && !palobj.bIsPalDC())
    {
        // First, undo the alt-lock we just did by invoking EPALOBJ:

        DEC_SHARE_REF_CNT(palobj.ppalGet());

        // Device dependent bitmaps for RGB colour depths have their palettes
        // pointing to the surface's primary palette.  With dynamic colour
        // depth changing, we want to keep those palette references around
        // even after the primary surface is deleted.
        //
        // This means that during the dynamic mode change, the palette should
        // not be deleted when the old instance of the driver asks it to be
        // deleted, but instead when the last bitmap referencing the palette
        // is deleted.  Having everyone use 'vUnrefPalette' makes this Just
        // Work.

        palobj.vUnrefPalette();

        b = TRUE;
    }

    return(b);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\paleng.cxx ===
/******************************Module*Header*******************************\
* Module Name: paleng.cxx
*
* Palette support routines used by NT components.
*
* Created: 27-Nov-1990 12:28:40
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* GreSetPaletteOwner
*
* Sets the palette owner.
*
\**************************************************************************/

BOOL
GreSetPaletteOwner(
                  HPALETTE hpal,
                  W32PID lPid)
{
    BOOL bRet = FALSE;


    if (hpal==(HPALETTE)STOCKOBJ_PAL)
    {
        WARNING("GreSetPaletteOwner: Cannot set owner for the stock Palette\n");
    }
    else
    {
        bRet = HmgSetOwner((HOBJ)hpal,lPid,PAL_TYPE);
    }
    return (bRet);
}

/******************************Public*Routine******************************\
* CreateSurfacePal
*
* Turns a physical palette into a palette managed palette for a device.
*
* History:
*  Tue 04-Dec-1990 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

BOOL CreateSurfacePal(XEPALOBJ palSrc, FLONG iPalType, ULONG ulNumReserved, ULONG ulNumPalReg)
{
    ASSERTGDI(iPalType == PAL_MANAGED, "ERROR: CreateSurfacePalette passed bad iPalType\n");
    ASSERTGDI(palSrc.bValid(), "ERROR CreateSurfacePal palSrc");
    ASSERTGDI(palSrc.cEntries() != 0, "ERROR CreateSurfacePal");

    //
    // If it is a Palette managed surface we must keep an exact
    // copy of it's origal state for certain functionality.
    //

    PALMEMOBJ pal;
    BOOL b;

    b = pal.bCreatePalette(palSrc.iPalMode(),
                           palSrc.cEntries(),
                           (PULONG) palSrc.apalColorGet(),
                           0,
                           0,
                           0,
                           iPalType);
    if (b)
    {
        ASSERTGDI(pal.bIsIndexed(), "Creating a non-indexed managed surface ???");
        ASSERTGDI(pal.bIsPalManaged(), "ERROR PAL_MANaged not pal managed");

        //
        // Now we have to set the type or the source to be PAL_MANAGED.
        //

        palSrc.flPalSet((palSrc.flPal() & ~(PAL_FIXED)) | PAL_MANAGED);

        //
        // Set the used and foreground flags on the reserved palette entries.
        //

        PAL_ULONG palTemp;

        ASSERTGDI((ulNumReserved & 0x00001) == 0, "ERROR non multiple of 2 reserved colors");

        palSrc.ulNumReserved(ulNumReserved);
        pal.ulNumReserved(ulNumReserved);
        ulNumReserved >>= 1;

        ULONG iPalMode;

        for (iPalMode = 0; iPalMode < ulNumReserved; iPalMode++)
        {
            palTemp.ul = pal.ulEntryGet(iPalMode);
            palTemp.pal.peFlags = (PC_FOREGROUND | PC_USED);
            pal.ulEntrySet(iPalMode, palTemp.ul);

            palTemp.ul = pal.ulEntryGet(iPalMode + (ulNumPalReg - ulNumReserved));
            palTemp.pal.peFlags = (PC_FOREGROUND | PC_USED);
            pal.ulEntrySet(iPalMode + (ulNumPalReg - ulNumReserved), palTemp.ul);
        }

        //
        // Ok the palette is in perfect initial shape, copy it.
        //

        palSrc.vCopyEntriesFrom(pal);
        palSrc.ppalOriginal(pal.ppalGet());
        pal.ulTime(palSrc.ulTime());
        pal.vKeepIt();
    }

    return(b);
}


/******************************Public*Routine******************************\
* ulGetNearestIndexFromColorref
*
*  Given the surface palette and the DC palette, this returns the index in
*  palSurf that crColor maps to.
*
*  Modifies: Nothing.
*
*  Returns: Index in palSurf that crColor maps to.
*
*  PALETTERGB   puts a 2 in the high byte.
*  PALETTEINDEX puts a 1 in the high byte.
*
* History:
*  Mon 02-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

ULONG
ulGetNearestIndexFromColorref(
    XEPALOBJ    palSurf,
    XEPALOBJ    palDC,
    ULONG       crColor,
    ULONG       seSearchExactFirst)
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PDEV          *ppdev = (PDEV *)palDC.hdev();

    PAL_ULONG palTemp;
    palTemp.ul = crColor;

    //
    // Check if it's palette managed.  If it's a device bitmap for a palette managed
    // device it will have an invalid palette.  If the palettes valid then it may be
    // the palette managed device's palette.
    //

    if ((!palSurf.bValid()) || (palSurf.bIsPalManaged()))
    {

        //
        // RGB:             Match to default palette or dither
        //
        // PALETTERGB:      Match RGB value to nearest entry in palette
        //
        // PALETTEINDEX:    The low 16 bits is a direct index to a palette entry
        //

        //
        // Check if it's a color forces us to access the xlate
        //

        if (palTemp.ul & 0x03000000)
        {
            if (palTemp.ul & 0x01000000)
            {
                //
                // PALETTEINDEX:
                //
                // This means they have an explicit entry in the DC palette they want
                //

                palTemp.pal.peFlags = 0;

                if (palTemp.ul >= palDC.cEntries())
                {
                    palTemp.ul = 0;
                }
            }
            else
            {
                //
                // PALETTERGB:
                //
                // Get rid of the top byte first.  It's 0x02 and we want to
                // search with this being an RGB.
                //


                palTemp.pal.peFlags = 0;

                palTemp.ul = palDC.ulGetNearestFromPalentry(
                                                            palTemp.pal,
                                                            seSearchExactFirst
                                                           );
            }

            //
            // If the DC's palette is the default palette, adjust if this is in the
            // top 10 colors, then we're done, because there's no translation of
            // the default palette
            //

            if (palDC.bIsPalDefault())
            {
                if (palTemp.ul >= 10)
                {
                    palTemp.ul = palTemp.ul + 236;
                }

                return(palTemp.ul);
            }

            //
            // Now do the right thing based on whether we are on the device bitmap
            // or the device surface.
            //

            if ((palSurf.bValid()) && (palDC.ptransCurrent() != NULL))
            {
                return(palDC.ulTranslateDCtoCurrent(palTemp.ul));
            }

            if ((!palSurf.bValid()) && (palDC.ptransFore() != NULL))
            {
                return(palDC.ulTranslateDCtoFore(palTemp.ul));
            }

            //
            // App is in hosed state which is possible in multi-tasking system.
            // Map as best we can into static colors, get the RGB from palDC.
            //

            palTemp.pal = palDC.palentryGet(palTemp.ul);

            //
            // If PC_EXPLICIT is set just return value modulo 256.
            //

            if (palTemp.pal.peFlags == PC_EXPLICIT)
            {
                return(palTemp.ul & 0x000000FF);
            }
        }

        //
        // check for DIBINDEX
        //

        if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
        {
            return(palTemp.ul & 0x000000FF);
        }

        //
        // At this point palTemp is an RGB value
        //
        // Well we need to match against the default palette.  We quickly
        // check for black and white and pass the rest through.
        //

        palTemp.pal.peFlags = 0;

        if (palTemp.ul == 0xFFFFFF)
        {
            palTemp.ul = 19;
        }
        else if (palTemp.ul != 0)
        {
            palTemp.ul =
                ((XEPALOBJ) ppalDefault).ulGetNearestFromPalentry(
                                                palTemp.pal,
                                                seSearchExactFirst
                                               );
        }

        if (palTemp.ul >= 10)
        {
            palTemp.ul = palTemp.ul + 236;
        }

        return(palTemp.ul);
    }

    //
    // This means they are not palette managed.
    //

    if (palTemp.ul & 0x01000000)
    {
        //
        // PALETTEINDEX:
        // This means they have an explicit entry in the DC palette they want.
        //

        palTemp.ul &= 0x0000FFFF;

        if (palTemp.ul >= palDC.cEntries())
        {
            palTemp.ul = 0;
        }

        palTemp.pal = palDC.palentryGet(palTemp.ul);
    }
    else if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
    {
        //
        // check for DIBINDEX
        //

        palTemp.ul &= 0x000000FF;

        return((palTemp.ul >= palSurf.cEntries()) ? 0 : palTemp.ul);
    }
    else
    {
        //
        // We just look for the closest RGB.
        //

        palTemp.pal.peFlags = 0;
    }

    //
    // Now it is time to look in the surface palette for the matching color.
    //

    return(palSurf.ulGetNearestFromPalentry(palTemp.pal, seSearchExactFirst));
}


/******************************Public*Routine******************************\
* ulGetMatchingIndexFromColorref
*
*  Given the surface palette and the DC palette, this returns the index in
*  palSurf that crColor maps to exactly, or 0xFFFFFFFF if it doesn't map
*  exactly to any color. Note that if the "find nearest in palette managed"
*  bit (0x20000000) is set, the nearest color qualifies as a match, because
*  that's what they're asking for. However, there is no guarantee that either
*  of the special bits will result in a match, because the palette may be in
*  an incorrect state or they could be asking for a direct index into the DC
*  palette that produces a color that's not in the surface's palette (in the
*  case of a non-palette-managed surface).
*
*  Modifies: Nothing.
*
*  Returns: Index in palSurf that crColor maps to.
*
*  PALETTERGB   puts a 2 in the high byte (find nearest)
*  PALETTEINDEX puts a 1 in the high byte (find specified index)
*
* History:
*  Sun 27-Dec-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

ULONG
ulGetMatchingIndexFromColorref(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG    crColor
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PAL_ULONG       palTemp;
    PDEV           *ppdev = (PDEV *)palDC.hdev();

    palTemp.ul = crColor;

    //
    // Check if it's palette managed.  If it's a device bitmap for a palette managed
    // device it will have an invalid palette.  If the palette's valid then it may be
    // the palette managed device's palette.
    //

    if ((!palSurf.bValid()) || (palSurf.bIsPalManaged()))
    {

        //
        // RGB:             Match to default palette or dither
        //
        // PALETTERGB:      Match RGB value to nearest entry in palette
        //
        // PALETTEINDEX:    The low 16 bits is a direct index to a palette entry
        //
        //
        // Check if it's a color forces us to access the xlate
        //

        if (palTemp.ul & 0x03000000)
        {
            if (palTemp.ul & 0x01000000)
            {
                //
                // PALETTEINDEX:
                //
                // This means they have an explicit entry in the DC palette they
                // want; only the lower byte is valid
                //

                palTemp.ul &= 0x0000FFFF;

                if (palTemp.ul >= palDC.cEntries())
                {
                    palTemp.ul = 0;
                }

            }
            else // (palTemp.ul & 0x02000000)
            {
                //
                // Get rid of the top byte first.  It's 0x02 and we want to search
                // the DC's palette for the nearest match with this being an RGB.
                // Note that in this case the nearest match and exact match are
                // logically equivalent
                //

                palTemp.pal.peFlags = 0;

                palTemp.ul = palDC.ulGetNearestFromPalentry(palTemp.pal);
            }

            //
            // If the DC's palette is the default palette, adjust if this is in the
            // top 10 colors, then we're done, because there's no translation of
            // the default palette
            //

            if (palDC.bIsPalDefault())
            {
                if (palTemp.ul >= 10)
                {
                    palTemp.ul = palTemp.ul + 236;
                }

                return(palTemp.ul);
            }

            //
            // Now do the right thing based on whether we are on the device bitmap
            // or the device surface
            //

            if ((palSurf.bValid()) && (palDC.ptransCurrent() != NULL))
            {
                //
                // We're drawing to a palette managed device surface, using the
                // current translation (which may be either back or fore, depending
                // on whether the application is in the foreground and owns the
                // palette)
                //

                return(palDC.ulTranslateDCtoCurrent(palTemp.ul));
            }

            if ((!palSurf.bValid()) && (palDC.ptransFore() != NULL))
            {
                //
                // We're drawing to a bitmap for a palette managed device, using
                // the fore translation (always treat drawing to a bitmap as
                // foreground drawing)
                //

                return(palDC.ulTranslateDCtoFore(palTemp.ul));
            }

            //
            // App is in hosed state which is possible in multi-tasking system.
            // Map as best we can into static colors, get the RGB from palDC and
            // try to find that in the default palette
            //

            palTemp.pal = palDC.palentryGet(palTemp.ul);

            //
            // If PC_EXPLICIT is set just return value modulo 256.
            //

            if (palTemp.pal.peFlags == PC_EXPLICIT)
            {
                return(palTemp.ul & 0x000000FF);
            }
        }

        //
        // check for DIBINDEX
        //

        if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
        {
            return(palTemp.ul & 0x000000FF);
        }

        //
        // Well, we're palette managed and have a plain old RGB (or failed to
        // find  the desired translation), so we need to match against the
        // default palette.  We quickly check for black and white and pass
        // the rest through.
        //

        palTemp.pal.peFlags = 0;

        if (palTemp.ul == 0xFFFFFF)
        {
            palTemp.ul = 19;
        }
        else if (palTemp.ul != 0)
        {
            palTemp.ul = ((XEPALOBJ) ppalDefault).ulGetMatchFromPalentry(palTemp.pal);
        }

        //
        // If we're in the top half of the default palette, adjust to the high end
        // of the 256-color palette, where the top half of the default palette
        // actually resides
        //

        if ((palTemp.ul != 0xFFFFFFFF) && (palTemp.ul >= 10))
        {
            palTemp.ul = palTemp.ul + 236;
        }

        return(palTemp.ul);
    }

    //
    // Not palette managed.
    //

    if (palTemp.ul & 0x01000000)
    {
        //
        // This means they have an explicit entry in the DC palette they want.
        // Limit the maximum explicit entry to 8 bits.
        //

        palTemp.ul &= 0x0000FFFF;

        //
        // If the index is off the end of the palette, wrap it modulo the palette
        // length.
        //

        if (palTemp.ul >= palDC.cEntries())
        {
            palTemp.ul = 0;
        }

        //
        // Search the palette for the color closest to the color selected from the
        // DC palette by the specified index
        //

        palTemp.pal = palDC.palentryGet(palTemp.ul);
    }
    else if ((palTemp.ul & 0x10ff0000) == 0x10ff0000)
    {
        //
        // check for DIBINDEX
        //

        palTemp.ul &= 0x000000FF;

        return((palTemp.ul >= palSurf.cEntries()) ? 0 : palTemp.ul);
    }
    else
    {
        //
        // We just look for the closest RGB; mask off the flags.
        //

        palTemp.pal.peFlags = 0;
    }

    //
    // Now it is time to look in the surface palette for the matching color.
    //

    return(palSurf.ulGetMatchFromPalentry(palTemp.pal));
}

/******************************Public*Routine******************************\
* ulColorRefToRGB
*
* Given a color ref this returns the RGB it corresponds to.
*
* This is a helper function given a color ref that may contain
* DIBINDEX value, do the appropriate translation of the DIBINDEX.
*
* History:
*  19-Jan-2001 -by- Barton House bhouse
* Wrote it.
\**************************************************************************/

ULONG
ulColorRefToRGB(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG iColorRef
    )
{
    if((iColorRef & 0x10FF0000) == 0x10FF0000)
    {
        return ulIndexToRGB(palSurf, palDC, iColorRef & 0xFF);
    }
    else
    {
        return iColorRef;
    }
}


/******************************Public*Routine******************************\
* ulIndexToRGB
*
* Given an index this returns the RGB it corresponds to.
*
* History:
*  21-Nov-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG
ulIndexToRGB(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG iSolidColor
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PAL_ULONG palTemp;

    if (palSurf.bValid())
    {
        return(palSurf.ulIndexToRGB(iSolidColor));
    }

    //
    // It's a palette managed device bitmap.
    //

    if (iSolidColor < 10)
    {
        palTemp.pal = logDefaultPal.palPalEntry[iSolidColor];
        return(palTemp.ul);
    }

    if (iSolidColor > 245)
    {
        palTemp.pal = logDefaultPal.palPalEntry[iSolidColor - 236];
        return(palTemp.ul);
    }

    //
    // Well it's the first entry in the logical palette that mapped here in the
    // foreground xlate.  If the foreground Xlate is invalid, who knows, return 0.
    //

    SEMOBJ  semo(ghsemPalette);

    if (palDC.ptransFore() != NULL)
    {
        PBYTE pjTemp = palDC.ptransFore()->ajVector;
        palTemp.ul = palDC.cEntries();

        for (palTemp.ul = 0; palTemp.ul < palDC.cEntries(); palTemp.ul++,pjTemp++)
        {
            if (*pjTemp == ((BYTE) iSolidColor))
                return(palDC.ulEntryGet(palTemp.ul));
        }
    }

    //
    // Well we just don't know.
    //

    return(0);
}

/******************************Public*Routine******************************\
* bIsCompatible
*
* This returns TRUE if the bitmap can be selected into this PDEV's memory
* DC's based on "Can we determine the color information".  It also returns
* the palette you could use for a reference for color information.
*
* History:
*  28-Jan-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bIsCompatible(PPALETTE *pppalReference, PPALETTE ppalBM, SURFACE *pSurfBM, HDEV hdev)
{
    BOOL bRet = TRUE;

    XEPALOBJ palBM(ppalBM);
    PDEVOBJ po(hdev);


    // We need to make sure this could be selected into this DC.  If it is a device
    // managed bitmap, it must be the same device.

    if (((pSurfBM->iType() != STYPE_BITMAP) || (pSurfBM->dhsurf() != 0)) &&
        (pSurfBM->hdev() != hdev))
    {
        WARNING1("bIsCompatible failed Device surface for another PDEV\n");
        bRet = FALSE;
    }
    else if (palBM.bValid())
    {
        // No problem, we already have color information.

        *pppalReference = palBM.ppalGet();
    }
    else if (pSurfBM->iFormat() != po.iDitherFormat())
    {
        // Check surface is compatible with PDEV for selection.

        WARNING1("bIsCompatible: Bitmap not compatible with DC\n");
        bRet = FALSE;
    }
    else
    {
        // If it's not palette managed set in palette for the device.  Otherwise
        // leave it NULL and the right stuff will happen.

        if (!po.bIsPalManaged())
        {
            *pppalReference = po.ppalSurf();
        }
        else
        {
            *pppalReference = (PPALETTE) NULL;
            ASSERTGDI(po.iDitherFormat() == BMF_8BPP, "ERROR GetDIBits no palette not 8BPP");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* rgbFromColorref
*
* Given the surface palette and the DC palette, this returns the rgb that
* this colorref represents.
*
* Returns: RGB that crColor maps to.
*
* PALETTERGB   puts a 2 in the high byte (find nearest)
* PALETTEINDEX puts a 1 in the high byte (find specified index)
*
* History:
*  Thu 18-Feb-1993 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

ULONG
rgbFromColorref(
    XEPALOBJ palSurf,
    XEPALOBJ palDC,
    ULONG crColor
    )
{
    ASSERTGDI(palDC.bValid(), "ERROR invalid palDC");

    PAL_ULONG palTemp;
    palTemp.ul = crColor;

    if (palTemp.ul & 0x01000000)
    {
        //
        // This means they have an explicit entry in the DC palette they
        // want.  Only the lower byte is valid.
        //

        palTemp.ul &= 0x0000FFFF;

        if (palTemp.ul >= palDC.cEntries())
        {
            palTemp.ul = 0;
        }

        palTemp.pal = palDC.palentryGet(palTemp.ul);

        //
        // If PC_EXPLICIT reach into the surface palette if possible.
        //

        if (palTemp.pal.peFlags == PC_EXPLICIT)
        {
            if (palSurf.bValid())
            {
                if (palSurf.cEntries())
                {
                    palTemp.ul &= 0x000000FF;

                    if (palTemp.ul >= palSurf.cEntries())
                    {
                        palTemp.ul = palTemp.ul % palSurf.cEntries();
                    }

                    palTemp.pal = palSurf.palentryGet(palTemp.ul);
                }
            }
        }
    }

    palTemp.pal.peFlags = 0;

    return(palTemp.ul);
}

/******************************Public*Routine******************************\
* bEqualRGB_In_Palette
*
* This function determines if 2 palettes contain identical RGB entries and
* palette sizes and therefore have an identity xlate between them.  This is
* need with DIBSECTIONS which may have duplicate palette entries but still
* should have identity xlates when blting between them.
*
* History:
*  10-Mar-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bEqualRGB_In_Palette(XEPALOBJ palSrc, XEPALOBJ palDst)
{
    ASSERTGDI(palSrc.bValid(), "ERROR invalid SRC");
    ASSERTGDI(palDst.bValid(), "ERROR invalid DST");

    //
    // Check for equal size palettes that are == to 256 in size.
    // 256 is the size of our palette managed palettes.
    //

    if ((palSrc.cEntries() != palDst.cEntries()) ||
        (palDst.cEntries() != 256))
    {
        return(FALSE);
    }

    //
    // If the Dst is a DC palette make sure it contains an identity
    // realization in it.
    //

    UINT uiIndex;

    if (palDst.bIsPalDC())
    {
        //
        // Check the translate for the current if it's the screen, otherwise
        // check the translate for the foreground for a bitmap.
        //

        TRANSLATE *ptrans = palDst.ptransFore();

        if (ptrans == NULL)
            return(FALSE);

        uiIndex = palDst.cEntries();

        while(uiIndex--)
        {
            if (ptrans->ajVector[uiIndex] != uiIndex)
                return(FALSE);
        }
    }

    uiIndex = palDst.cEntries();
    ULONG ulTemp;

    while(uiIndex--)
    {
        ulTemp = palSrc.ulEntryGet(uiIndex) ^ palDst.ulEntryGet(uiIndex);

        if (ulTemp & 0xFFFFFF)
        {
            return(FALSE);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\opendc.cxx ===
/******************************Module*Header*******************************\
* Module Name: OPENDC.CXX
*
* Handles DC creation and driver loading.
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern FLONG flRaster(ULONG, FLONG);

/******************************Exported*Routine****************************\
* GreCreateDisplayDC
*
* Opens a DC on the specified display PDEV.
* Allocates space for a DC, fills in the defaults.
* If successfull, increments the PDEV reference count.
*
\**************************************************************************/

HDC
GreCreateDisplayDC(
    HDEV hdev,
    ULONG iType,
    BOOL bAltType)
{
    GDIFunctionID(GreCreateDisplayDC);

    HDC hdc = (HDC) NULL;

    //
    // We hold the devlock to protect against dynamic mode changes
    // while we're copying mode specific information to the DC.
    //

    PDEVOBJ pdo(hdev);
    DEVLOCKOBJ dlo(pdo);

    DCMEMOBJ dcmo(iType, bAltType);

    if (dcmo.bValid())
    {
        //
        // Copy info from the PDEV into the DC.
        //

        dcmo.pdc->ppdev((PDEV *) pdo.hdev());
        dcmo.pdc->flGraphicsCaps(pdo.flGraphicsCaps());    // cache it for later use by graphics output functions
        dcmo.pdc->flGraphicsCaps2(pdo.flGraphicsCaps2());  // cache it for later use by graphics output functions
        dcmo.pdc->dhpdev(pdo.dhpdev());
        dcmo.hsemDcDevLock(pdo.hsemDevLock());

        if (iType == DCTYPE_MEMORY)
        {
            SIZEL sizlTemp;

            sizlTemp.cx = 1;
            sizlTemp.cy = 1;

            dcmo.pdc->sizl(sizlTemp);
        }
        else
        {
            dcmo.pdc->sizl(pdo.sizl());

            //
            // The info and direct DC's for the screen need to grab
            // the semaphore before doing output, the memory DC's will
            // grab the semaphore only if a DFB is selected.
            //

            if (iType == DCTYPE_DIRECT)
            {
                dcmo.bSynchronizeAccess(pdo.bDisplayPDEV());
                dcmo.pdc->vDisplay(pdo.bDisplayPDEV());

                //
                // If this DC is created against with disabled PDEV,
                // mark it as full screen mode. All hdc on disbaled
                // PDEV should be marked as 'in fullscreen'.
                // (see PDEVOBJ::bDisabled(BOOL bDisable))
                //

                dcmo.pdc->bInFullScreen(pdo.bDisabled());

                if (!pdo.bPrinter())
                    dcmo.pdc->pSurface(pdo.pSurface());
            }
        }

        //
        // Call the region code to set a default clip region.
        //

        if (dcmo.pdc->bSetDefaultRegion())
        {
            // If display PDEV, select in the System stock font.

            dcmo.vSetDefaultFont(pdo.bDisplayPDEV());

            // set user mode VisRect
            dcmo.pdc->vUpdate_VisRect(dcmo.pdc->prgnVis());

            if (GreSetupDCAttributes((HDC)(dcmo.pdc->hGet())))
            {
                // Mark the DC as permanent, hold the PDEV reference.

                dcmo.vKeepIt();

                // This will permanently increase the ref count to indicate
                // a new DC has been created.

                pdo.vReferencePdev();

                // turn on the DC_PRIMARY_DISPLAY flag for primary dc's

                if (hdev == UserGetHDEV())
                {
                    dcmo.pdc->ulDirtyAdd(DC_PRIMARY_DISPLAY);
                }

                // finish initializing the DC.

                hdc = dcmo.hdc();
            }
            else
            {
                // DCMEMOBJ will be freed, delete vis region

                dcmo.pdc->vReleaseVis();

                // delete LOGFONT in DC which set by dcmo.vSetDefaultFont() in above.

                DEC_SHARE_REF_CNT_LAZY_DEL_LOGFONT(dcmo.pdc->plfntNew());
            }
        }

        if (hdc == NULL)
        {
            // dec reference counts on brush, pen and others
            // (which incremented in DCOBJ::DCOBJ())

            DEC_SHARE_REF_CNT_LAZY0(dcmo.pdc->pbrushFill());
            DEC_SHARE_REF_CNT_LAZY0(dcmo.pdc->pbrushLine());
            DEC_SHARE_REF_CNT_LAZY_DEL_COLORSPACE(dcmo.pdc->pColorSpace());
        }
#if DBG
        else
        {
            // Enable visrgn validation from this point

            GreValidateVisrgn(hdc, TRUE);
        }
#endif
    }

    return hdc;
}

/******************************Public*Routine******************************\
* NtGdiCreateMetafileDC()
*
* History:
*  01-Jun-1995 -by-  Andre Vachon [andreva]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
NtGdiCreateMetafileDC(
    HDC   hdc
    )
{
    HDC hdcNew = NULL;

    if (hdc)
    {
        //
        // Lock down the given DC.
        //

        DCOBJ   dco(hdc);

        if (dco.bValid())
        {
            //
            // Allocate the DC, fill it with defaults.
            //

            hdcNew = GreCreateDisplayDC((HDEV) dco.pdc->ppdev(), DCTYPE_INFO, TRUE);
        }
    }
    else
    {
        //
        // We must call USER to get the current PDEV\HDEV for this thread
        // This should end up right back in GreCreateDisplayDC
        //

        hdcNew = UserGetDesktopDC(DCTYPE_INFO, TRUE, FALSE);
    }

    return hdcNew;
}

/******************************Public*Routine******************************\
* NtGdiCreateCompatibleDC()
*
* History:
*  01-Nov-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
NtGdiCreateCompatibleDC(
    HDC      hdc
    )
{
    HDC hdcRet = GreCreateCompatibleDC(hdc);

    //
    // Make sure user attributes are added to this dc
    //

    #if DBG

    if (hdcRet)
    {
        DCOBJ dco(hdcRet);
        if (dco.bValid())
        {
            ASSERTGDI((PENTRY_FROM_POBJ((POBJ)dco.pdc))->pUser != NULL,"NtGdiCreateCompatibleDC: pUser == NULL");
        }
    }

    #endif

    return(hdcRet);
}

/******************************Public*Routine******************************\
* HDC GreCreateCompatibleDC(hdc)
*
* History:
*  01-Jun-1995 -by-  Andre Vachon [andreva]
* Wrote it.
*
\**************************************************************************/

HDC APIENTRY GreCreateCompatibleDC(HDC hdc)
{
    HDC hdcNew = NULL;

    if (hdc)
    {
        //
        // Lock down the given DC.
        //

        DCOBJ   dco(hdc);

        if (dco.bValid())
        {
            //
            // Allocate the DC, fill it with defaults.
            //

            hdcNew = GreCreateDisplayDC((HDEV) dco.pdc->ppdev(),
                                        DCTYPE_MEMORY,
                                        FALSE);
            //
            // If the compatible DC for a mirrored DC then mirror it.
            //

            if (hdcNew)
            {
                DWORD dwLayout = dco.pdc->dwLayout();

                if (dwLayout & LAYOUT_ORIENTATIONMASK)
                {
                    GreSetLayout(hdcNew, -1, dwLayout);
                }
            }
       }
    }
    else
    {
        hdcNew = UserGetDesktopDC(DCTYPE_MEMORY, FALSE, FALSE);
    }

    return hdcNew;
}


/******************************Public*Routine******************************\
* BOOL GreSelectRedirectionBitmap
*
* This routine selects a redirection bitmap into a redirection DC.  A single
* redirection bitmap can be selected into multiple redirection DCs.
* Note:  The caller needs to hold the devlock.
* Note:  The redirection bitmap must be in system memory because GDI may
*     attempt to convert it to a memory bitmap in the future (mode change,
*     speed optimizations in some code paths, etc.) and we cannot do that
*     here because there's no easy way of getting the list of redirection
*     DCs on that surface.
*
* Arguments:
*
*   hdc -- The redirection DC as created by GreCreateRedirectionDC.
*
*   hbitmap -- The redirection bitmap to be selected into hdc.  This needs
*       to be a memory bitmap (but not DIB-section) which is compatible with
*       the display pdev.
*
* Return Value:
*
*   True upon success
*
* History:
*  21-Sep-1998 -by-  Ori Gershony [orig]
* Wrote it.
*
\**************************************************************************/

BOOL
APIENTRY
GreSelectRedirectionBitmap(
    HDC hdc,
    HBITMAP hBitmap
    )
{
    ULONG ulRet=TRUE;

    DCOBJA dco(hdc);
    if (dco.bValid())
    {
        SURFACE* pSurface = NULL;
        PDEVOBJ po(dco.hdev());

#if DBG
        po.vAssertDevLock();
#endif

        if (hBitmap == NULL)
        {
            dco.pdc->bRedirection(FALSE);

            pSurface = po.pSurface();
        }
        else
        {
            dco.pdc->bRedirection(TRUE);

            SURFREF surfref((HSURF) hBitmap);
            if (surfref.bValid())
            {
                pSurface = surfref.ps;

                ASSERTGDI((pSurface->iType() == STYPE_BITMAP) && (!(pSurface->fjBitmap() & BMF_NOTSYSMEM)),
                    "GreSelectRedirectionBitmap: bitmap must be in system memory");

                ASSERTGDI(!pSurface->hDIBSection(),
                    "GreSelectRedirectionBitmap: cannot select DIB-section into a redirection DC");

                PPALETTE ppalReference;
                ASSERTGDI(bIsCompatible(&ppalReference, NULL, pSurface, dco.hdev()),
                    "GreSelectRedirectionBitmap:  hBitmap not compatible with display hdev");

                //
                // Mark bitmap as redirection bitmap if not one already
                //
                if (!pSurface->bRedirection())
                {
                    pSurface->vSetRedirection();
                }
            }
        }

        if (pSurface != NULL)
        {
            //
            // Replace the surface in all the saved DCs too.
            //
            if (dco.lSaveDepth() > 1)
            {
                ulRet = GreSelectRedirectionBitmap (dco.hdcSave(), hBitmap);

                //
                // The recursive call above should never fail, and we are not
                // setup to deal with failure correctly (need to undo change
                // to DC redirection flag, etc.).  We can add code to do that,
                // but user (who calls us) cannot deal with failure either.  So
                // instead we assert that this call succeeded.
                //
                ASSERTGDI(ulRet == TRUE,
                          "GreSelectRedirectionBitmap:  Recursive call on hdcSave failed");
            }

            if (ulRet)
            {
                //
                // Replace the pSurf reference in the DCLEVEL
                //
                dco.pdc->pSurface(pSurface);

                //
                // Set the size to that of the new surface
                //
                dco.pdc->sizl(pSurface->sizl());

                //
                // Make sure that the surface pointers in any EBRUSHOBJ's get
                // updated, by ensuring that vInitBrush() gets called the next
                // time any brush is used in this DC.
                //
                dco.pdc->flbrushAdd(DIRTY_BRUSHES);

                //
                // Note:  we don't set the visrgn so that if user wants to reuse this dc over
                // the same redirection bitmap it won't have to recompute the visrgn (though it
                // will have to recompute it if it will be reused for a different redirection
                // bitmap).
                //
            }
        }
        else
        {
            ulRet = FALSE;
        }
    }
    else
    {
        ulRet = FALSE;
    }

    return ulRet;
}

/******************************Exported*Routine****************************\
* hdcOpenDCW
*
* Opens a DC for a device which is not a display.  GDI should call this
* function from within DevOpenDC, in the case that an hdc is not passed
* in.  This call locates the device and creates a new PDEV.  The physical
* surface associated with this PDEV will be distinct from all other
* physical surfaces.
*
* The window manager should not call this routine unless it is providing
* printing services for an application.
*
* pwszDriver
*
*   This points to a string which identifies the device driver.
*   The given string must be a fully qualified path name.
*
* pdriv
*
*   This is a pointer to the DEVMODEW block.
*
*   Since a single driver, like PSCRIPT.DRV, may support multiple
*   different devices, the szDeviceName field defines which device to
*   use.
*
*   This structure also contains device specific data in abGeneralData.
*   This data is set by the device driver in bPostDeviceModes.
*
*   If the pdriv pointer is NULL, the device driver assumes some default
*   configuration.
*
* iType
*
*   Identifies the type of the DC.  Must be one of DCTYPE_DIRECT,
*   DCTYPE_INFO, or DCTYPE_MEMORY.
*
* Returns:
*
*   HDC         - A handle to the DC.
*
\**************************************************************************/

class PRINTER
{
public:
    HANDLE hSpooler_;
    BOOL   bKeep;

public:
    PRINTER(PWSZ pwszDevice,DEVMODEW *pdriv,HANDLE hspool );
   ~PRINTER()
    {
        if (!bKeep && (hSpooler_ != (HANDLE) NULL))
            ClosePrinter(hSpooler_);
    }

    BOOL   bValid()     {return(hSpooler_ != (HANDLE) NULL);}
    VOID   vKeepIt()    {bKeep = TRUE;}
    HANDLE hSpooler()   {return(hSpooler_);}
};

// PRINTER constructor -- Attempts to open a spooler connection to the
//                        printer.

PRINTER::PRINTER(
    PWSZ pwszDevice,
    DEVMODEW *pdriv,
    HANDLE hspool )
{
    bKeep = FALSE;

    PRINTER_DEFAULTSW defaults;

    defaults.pDevMode = pdriv;
    defaults.DesiredAccess = PRINTER_ACCESS_USE;

    //
    // Attempt to open the printer for spooling journal files.
    // NOTE: For debugging, a global flag disables journaling.
    //

    defaults.pDatatype = (LPWSTR) L"RAW";

    if (hspool)
    {

        hSpooler_ = hspool;

    }
    else
    {
        if (!OpenPrinterW(pwszDevice,&hSpooler_,&defaults))
        {
            //
            // It's not a printer.  OpenPrinterW doesn't guarantee the value
            // of hSpooler in this case, so we have to clear it.
            //

            hSpooler_ = (HANDLE) NULL;
        }
    }

    return;
}

/******************************Public*Routine******************************\
* See comments above.
*
* History:
*  Andre Vachon [andreva]
*
\**************************************************************************/

HDC hdcOpenDCW(
    PWSZ               pwszDevice,  // The device driver name.
    DEVMODEW          *pdriv,       // Driver data.
    ULONG              iType,       // Identifies the type of DC to create.
    HANDLE             hspool,      // do we already have a spooler handle?
    PREMOTETYPEONENODE prton,
    DRIVER_INFO_2W    *pDriverInfo2, // we pass in pDriverInfo for UMPD, NULL otherwise
    PVOID              pUMdhpdev
    )
{
    HDC hdc = (HDC) 0;              // Prepare for the worst.
    DWORD cbNeeded = 0;
    PVOID mDriverInfo;
    BOOL bUMPD = pDriverInfo2 ? TRUE: FALSE;      // TRUE if User Mode driver

    TRACE_INIT(("\nhdcOpenDCW: ENTERING\n"));

    //
    // Attempt to open a display DC.
    //

    if (pwszDevice && !bUMPD)
    {
        PMDEV pmdev = NULL;
        HDEV  hdev = NULL;
        UNICODE_STRING usDevice;

        RtlInitUnicodeString(&usDevice,
                             pwszDevice);

        if (pdriv == NULL)
        {
            //
            // If no DEVMODE is present, then we just want to create a DC on
            // the specific device.
            // This will allow an application to make some escape calls to a
            // specific device\driver.
            //

            hdev = DrvGetHDEV(&usDevice);
        }
        else
        {
            //
            // We have to acquire the USER lock to synchronize with
            // ChangeDisplaySettings.
            //

            UserEnterUserCritSec();

            TRACE_INIT(("hdcOpenDCW: Trying to open as a second display device\n"));

            //
            // Only let the user do this if the device is not part of the
            // desktop.
            //

            pmdev = DrvCreateMDEV(&usDevice,
                                  pdriv,
                                  (PVOID) (ULONG_PTR)0xFFFFFFFF,
                                  GRE_DISP_CREATE_NODISABLE |
                                  GRE_DISP_NOT_APARTOF_DESKTOP,
                                  NULL,
                                  KernelMode,
                                  GRE_RAWMODE,
                                  FALSE); // buffer is captured in NtGdiOpenDCW()

            if (!pmdev)
            {
                DWORD dwDesktopId;

                if (UserGetCurrentDesktopId(&dwDesktopId))
                {
                    //
                    // Try match from current desktop display.
                    // but don't create new display instance.
                    //

                    pmdev = DrvCreateMDEV(&usDevice,
                                          pdriv,
                                          (PVOID) (ULONG_PTR) dwDesktopId,
                                          GRE_DISP_CREATE_NODISABLE |
                                          GRE_DISP_NOT_APARTOF_DESKTOP,

                                          NULL,
                                          KernelMode,
                                          GRE_RAWMODE,
                                          FALSE);
                }
            }

            UserLeaveUserCritSec();

            if (pmdev)
            {
                TRACE_INIT(("Drv_Trace: CreateExclusiveDC: We have an hdev\n"));
                ASSERTGDI(pmdev->chdev == 1,"hdcOpenDCW(): pmdev->chdev != 1");

                hdev = pmdev->Dev[0].hdev;
            }
        }

        if (hdev)
        {
            hdc = GreCreateDisplayDC(hdev, DCTYPE_DIRECT, FALSE);

            if (hdc)
            {
                if (pmdev || hdev)
                {
                    DCOBJ dco(hdc);
                    PDEVOBJ po(dco.hdev());

                    //
                    // Dereference the object since we want DeleteDC
                    // to automatically destroy the PDEV.
                    //
                    // This basically counteracts the extra reference that it done
                    // by DrvCreateMDEV(), or DrvGetHDEV().
                    //
                    po.vUnreferencePdev();
                }
            }
            else
            {
                TRACE_INIT(("hdcOpenDCW: Failed to get DC\n"));
                if (pmdev)
                {
                    DrvDestroyMDEV(pmdev);
                }
                else
                {
                    PDEVOBJ po(hdev);
                    po.vUnreferencePdev();
                }
            }
        }

        if (pmdev)
        {
            VFREEMEM(pmdev);
        }
    }

    //
    // Attempt to open a new printer DC.
    //

    if (hdc == NULL)
    {
        //
        // Open the spooler connection to the printer.
        // Allocate space for DRIVER_INFO.
        //

        PRINTER print(pwszDevice, pdriv, hspool);

        if (print.bValid())
        {
            if (!bUMPD)
            {
               if (mDriverInfo = PALLOCMEM(512, 'pmtG'))
               {
                   //
                   // Fill the DRIVER_INFO.
                   //

                   if (!GetPrinterDriverW(
                         print.hSpooler(),
                         NULL,
                         2,
                         (LPBYTE) mDriverInfo,
                         512,
                         &cbNeeded))
                   {

                       //
                       // Call failed - free the memory.
                       //

                       VFREEMEM(mDriverInfo);
                       mDriverInfo = NULL;

                       //
                       // Get more space if we need it.
                       //

                       if ((EngGetLastError() == ERROR_INSUFFICIENT_BUFFER) &&
                           (cbNeeded > 0))
                       {
                           if (mDriverInfo = PALLOCMEM(cbNeeded, 'pmtG'))
                           {

                               if (!GetPrinterDriverW(print.hSpooler(),
                                                      NULL,
                                                      2,
                                                      (LPBYTE) mDriverInfo,
                                                      cbNeeded,
                                                      &cbNeeded))
                               {
                                   VFREEMEM(mDriverInfo);
                                   mDriverInfo = NULL;
                               }
                           }
                       }
                   }
               }
            }
            else
            {
                //
                // we have a pDriverInfo2 passed in for UMPD
                //
                mDriverInfo = pDriverInfo2;
            }

            if (mDriverInfo != (PVOID) NULL)
            {
                PLDEV pldev;

                if ( bUMPD)
                {
                    //
                    // we fake a pldev for each LoadDriver call.
                    // the real driver list is kept at the client side as a pUMPD list
                    //
                    pldev = UMPD_ldevLoadDriver(((DRIVER_INFO_2W *)mDriverInfo)->pDriverPath,
                                       LDEV_DEVICE_PRINTER);
                }
                else
                {
                    pldev = ldevLoadDriver(((DRIVER_INFO_2W *)mDriverInfo)->pDriverPath,
                                       LDEV_DEVICE_PRINTER);
                }

                if (pldev == NULL)
                {
                    SAVE_ERROR_CODE(ERROR_BAD_DRIVER_LEVEL);
                }
                else
                {

                    //
                    // Create a PDEV.  If no DEVMODEW passed in from above,
                    // use the default from the printer structure.
                    //
                    PDEVOBJ po(pldev,
                            (PDEVMODEW) pdriv,
                            pwszDevice,
                            ((DRIVER_INFO_2W *)mDriverInfo)->pDataFile,
                            ((DRIVER_INFO_2W *)mDriverInfo)->pName,
                            print.hSpooler(),
                            prton,
                            NULL,
                            NULL,
                            bUMPD);

                    if (po.bValid())
                    {
                        //
                        // Make a note that this is a printer.
                        //

                        po.bPrinter(TRUE);

                        //
                        // Allocate the DC, fill it with defaults.
                        //

                        hdc = GreCreateDisplayDC(po.hdev(),
                                                 iType,
                                                 TRUE);

                        //
                        // If the DC was properly create, keep the printer
                        // object so the printer stays open

                        if (hdc)
                        {
                            print.vKeepIt();

                            if (bUMPD && pUMdhpdev)
                            {
                               __try
                               {
                                   ProbeForWritePointer(pUMdhpdev);
                                   *(PUMDHPDEV *)pUMdhpdev = (PUMDHPDEV)po.dhpdev();
                               }
                               __except(EXCEPTION_EXECUTE_HANDLER)
                               {
                                   bDeleteDCInternal(hdc, FALSE, FALSE);
                                   hdc = 0;
                               }
                            }

                        }

                        //
                        // Always delete the PEV reference count.
                        // If the DC was created, the DC keeps the ref count
                        // at 1, and the PDEV will get destroyed when the
                        // DC gets destroyed.
                        // If the DC was not created properly, this will cause
                        // the PDEV to get destroyed immediately.
                        //

                        po.vUnreferencePdev();

                    }
                    else
                    {
                        if (!bUMPD)
                        {
                            ldevUnloadImage(pldev);
                        }
                        else
                        {
                            UMPD_ldevUnloadImage(pldev);
                        }
                    }
                }

                if (!bUMPD)
                {
                    VFREEMEM(mDriverInfo);
                }
            }
        }
    }

    if (hdc == (HDC) NULL)
    {
        WARNING("opendc.cxx: failed to create DC in hdcOpenDCW\n");
    }

    return(hdc);
}

/******************************Public*Routine******************************\
* GreResetDCInternal
*
*   Reset the mode of a DC.  The DC returned will be a different DC than
*   the original.  The only common piece between the original DC and the
*   new one is the hSpooler.
*
*   There are a number of intresting problems to be carefull of.  The
*   original DC can be an info DC.  The new one will always be a direct DC.
*
*   Also, it is important to be carefull of the state of the DC when this
*   function is called and the effects of journaling vs non journaling.
*   In the case of journaling, the spooler is responsible for doing a CreateDC
*   to play the journal file to.  For this reason, the spooler must have the
*   current DEVMODE.  For this reason, ResetDC must call ResetPrinter for
*   spooled DC's.
*
*   ResetDC can happen at any time other than between StartPage-EndPage, even
*   before StartDoc.
*
*
* History:
*  13-Jan-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" BOOL GreResetDCInternal(
    HDC       hdc,
    DEVMODEW *pdmw,  // Driver data.
    BOOL      *pbBanding,
    DRIVER_INFO_2W *pDriverInfo2,
    PVOID     ppUMdhpdev)
{
    BOOL bSurf;
    BOOL bTempInfoDC = FALSE;
    HDC  hdcNew;
    BOOL bRet = FALSE;

    // we need this set of brackets so the DC's get unlocked before we try to delete
    // the dc>

    {
        DCOBJ   dco(hdc);

        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            // if this has been made into a TempInfoDC for printing, undo it now

            bTempInfoDC = dco.pdc->bTempInfoDC();

            if (bTempInfoDC)
                dco.pdc->bMakeInfoDC(FALSE);

            PDEVOBJ po(dco.hdev());

            // get list of Type1 remote type one fonts if there is one and transfer
            // it accross PDEV's.

            PREMOTETYPEONENODE prton = po.RemoteTypeOneGet();
            po.RemoteTypeOneSet(NULL);

            // This call only makes sense on RASTER technology printers.

            if (!dco.bKillReset() &&
                !(dco.dctp() == DCTYPE_MEMORY) &&
                (po.bPrinter()))
            {
                // First, remember if a surface needs to be created

                bSurf = dco.bHasSurface();

                // Now, clean up the DC

                if (dco.bCleanDC())
                {
                    // If there are any outstanding references to this PDEV, fail.

                    if (((PDEV *) po.hdev())->cPdevRefs == 1)
                    {
                        // create the new DC

                        hdcNew = hdcOpenDCW(L"",
                                            pdmw,
                                            DCTYPE_DIRECT,
                                            po.hSpooler(),
                                            prton,
                                            pDriverInfo2,
                                            ppUMdhpdev);

                        if (hdcNew)
                        {
                            // don't want to delete the spooler handle since it
                            // is in the new DC

                            po.hSpooler(NULL);

                            // lock down the new DC and PDEV

                            DCOBJ dcoNew(hdcNew);

                            if (!dcoNew.bValid())
                            {
                                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                            }
                            else
                            {
                                // Transfer any remote fonts

                                dcoNew.PFFListSet(dco.PFFListGet());
                                dco.PFFListSet(NULL);

                                // Transfer any color transform

                                dcoNew.CXFListSet(dco.CXFListGet());
                                dco.CXFListSet(NULL);

                                PDEVOBJ poNew((HDEV) dcoNew.pdc->ppdev());

                                // let the driver know

                                PFN_DrvResetPDEV rfn = PPFNDRV(po,ResetPDEV);

                                if (rfn != NULL)
                                {
                                    (*rfn)(po.dhpdev(),poNew.dhpdev());
                                }

                                // now swap the two handles

                                {
                                    MLOCKFAST mlo;

                                    BOOL bRes = HmgSwapLockedHandleContents((HOBJ)hdc,0,(HOBJ)hdcNew,0,DC_TYPE);
                                    ASSERTGDI(bRes,"GreResetDC - SwapHandleContents failed\n");
                                }

                                bRet = TRUE;
                            }
                        }
                    }
                }
            }
        }

        // DON'T DO ANYTHING HERE, the dcobj's don't match the handles, so
        // unlock them first
    }

    if (bRet)
    {
        // got a new dc, get rid of the old one (remember the handles have
        // been swapped)

        bDeleteDCInternal(hdcNew,TRUE,FALSE);

        // now deal with the new one

        DCOBJ newdco(hdc);

        if (!newdco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            bRet = FALSE;
        }
        else
        {
            PDEVOBJ newpo(newdco.hdev());

            // Create a new surface for the DC.

            if (bSurf)
            {
                if (!newpo.bMakeSurface())
                {
                    bRet = FALSE;
                }
                else
                {
                    newdco.pdc->pSurface(newpo.pSurface());
                    *pbBanding = newpo.pSurface()->bBanding();

                    if( *pbBanding )
                    {
                    // if banding set Clip rectangle to size of band

                        newdco.pdc->sizl((newpo.pSurface())->sizl());
                        newdco.pdc->bSetDefaultRegion();
                    }

                    PFN_DrvStartDoc pfnDrvStartDoc = PPFNDRV(newpo, StartDoc);
                    (*pfnDrvStartDoc)(newpo.pSurface()->pSurfobj(),NULL,0);
                }
            }
            else
            {
                // important to set this to FALSE is a surface has not yet been created
                // ie StartDoc has not yet been called.
                *pbBanding = FALSE;
            }

            // if the original was a tempinfo dc for printing, this one needs to be too.

            if (bRet && bTempInfoDC)
            {
                newdco.pdc->bMakeInfoDC(TRUE);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bDynamicMatchEnoughForModeChange
*
* We can dynamically change modes only if the new mode matches the old
* in certain respects.  This is because, for example, we don't have code
* written to track down all the places where flGraphicsCaps has been copied,
* and then change it asynchronously.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDynamicMatchEnoughForModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew
    )
{
    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);
    BOOL    b = TRUE;

    // We would get quite confused with converting monochrome bitmaps if
    // we were to handle 1bpp:

    if ((poOld.iDitherFormat() == BMF_1BPP) ||
        (poNew.iDitherFormat() == BMF_1BPP))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Can't handle 1bpp");
        b = FALSE;
    }

    // Some random stuff must be the same between the old instance and
    // the new:
    //
    // We impose the restriction that some flGraphicsCaps flags must stay
    // the same with the new mode.  Specifically, we can't allow the
    // following to change:
    //
    // o  We don't allow GCAPS_HIGHRESTEXT to change because ESTROBJ::
    //    vInit needs to look at it sometimes without acquiring a lock,
    //    and it's pretty much a printer specific feature anyway.
    // o  We don't allow GCAPS_FORCEDITHER to change because vInitBrush
    //    needs to look for this flag without holding a lock, and because
    //    this flag is intended to be used only by printer drivers.

    if ((poNew.flGraphicsCaps() ^ poOld.flGraphicsCaps())
           & (GCAPS_HIGHRESTEXT | GCAPS_FORCEDITHER))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Driver's flGraphicsCaps did");
        WARNING("  not match for GCAPS_HIGHRESTEXT and GCAPS_FORCEDITHER\n");
        b = FALSE;
    }

    if ((poNew.ulLogPixelsX() != poOld.ulLogPixelsX()) ||
        (poNew.ulLogPixelsY() != poOld.ulLogPixelsY()))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Driver's ulLogPixels did not match\n");
        b = FALSE;
    }

    // We can't handle font producers because I haven't bothered with
    // code to traverse the font code's producer lists and Do The Right
    // Thing (appropriate locks are the biggest pain).  Fortunately,
    // font producing video drivers should be extremely rare.

    if (PPFNDRV(poNew, QueryFont)     ||
        PPFNDRV(poNew, QueryFontCaps) ||
        PPFNDRV(poNew, LoadFontFile)  ||
        PPFNDRV(poNew, QueryFontFile) ||
        PPFNDRV(poNew, GetGlyphMode))
    {
        WARNING("bDynamicMatchEnoughForModeChange: New driver can't be a font provider\n");
        b = FALSE;
    }

    if (PPFNDRV(poOld, QueryFont)     ||
        PPFNDRV(poOld, QueryFontCaps) ||
        PPFNDRV(poOld, LoadFontFile)  ||
        PPFNDRV(poOld, QueryFontFile) ||
        PPFNDRV(poOld, GetGlyphMode))
    {
        WARNING("bDynamicMatchEnoughForModeChange: Old driver can't be a font provider\n");
        b = FALSE;
    }

    ASSERTGDI((poNew.ulTechnology() == DT_RASDISPLAY) &&
              (poOld.ulTechnology() == DT_RASDISPLAY),
        "Display drivers must specify DT_RASDISPLAY for ulTechnology");

    ASSERTGDI((poNew.flTextCaps() & ~TC_SCROLLBLT) ==
              (poOld.flTextCaps() & ~TC_SCROLLBLT),
        "Display drivers should set only TC_RA_ABLE in flTextCaps");

    return(b);
}

/******************************Public*Routine******************************\
* vAssertPaletteRefCountCorrect
*
* Validates the reference count for a palette by counting all the surfaces
* that use it.
*
* History:
*  14-Oct-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#if DBG

VOID
vAssertPaletteRefCountCorrect(
    PALETTE*    ppalOld
    )
{
    LONG        cAltLocks;
    LONG        cSurfaces;
    HOBJ        hobj;
    SURFACE*    pSurface;
    PALETTE*    ppalSurface;

    MLOCKFAST   mo;

    cSurfaces = 0;
    hobj = 0;
    while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
    {
        hobj = (HOBJ) pSurface->hGet();

        ppalSurface = pSurface->ppal();

        if (ppalSurface == ppalOld)
        {
            cSurfaces++;
        }
        else if ((ppalSurface != NULL) && (ppalSurface->ppalColor == ppalOld))
        {
            cSurfaces++;
        }
    }

    cAltLocks = ((POBJ) ppalOld)->ulShareCount;

    // The PDEV keeps a reference count on the palette, as does the
    // EngCreatePalette call.  So the number of Alt-locks should be
    // two more than the number of surfaces with this palette:

    if (cAltLocks < cSurfaces + 2)
    {
        KdPrint(("vAssertPaletteRefCountCorrect cAltLocks: %li != cSurfaces: %li.\n",
            cAltLocks - 2, cSurfaces));

        hobj = 0;
        while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
        {
            hobj = (HOBJ) pSurface->hGet();

            ppalSurface = pSurface->ppal();

            if (ppalSurface == ppalOld)
            {
                KdPrint(("  %p\n", pSurface));
            }
            else if ((ppalSurface != NULL) && (ppalSurface->ppalColor == ppalOld))
            {
                KdPrint((" -%p\n", pSurface));
            }
        }

        RIP("Breaking to debugger...");
    }
}

#else

    #define vAssertPaletteRefCountCorrect(ppalOld)

#endif

/******************************Public*Routine******************************\
* bDynamicRemoveAllDriverRealizations
*
* Cleanses a PDEV of all state that is specific to the device, such as
* device format bitmaps, and brush and font realizations.
*
* NOTE: The following locks must be held:
*
*           1. Devlock;
*           2. RFont list lock;
*           3. Handle manager lock.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDynamicRemoveAllDriverRealizations(
    HDEV    hdev
    )
{
    BOOL                bConversionSuccessful;
    HOBJ                hobj;               // Temporary object handle
    SURFACE*            pSurface;           // Temporary surface pointer
    RFONT*              prfnt;              // Temporary RFONT pointer
    FONTOBJ*            pfo;                // Temporary FONTOBJ pointer
    BRUSH*              pbrush;             // Temporary BRUSH pointer
    PFN_DrvDestroyFont  pfnDrvDestroyFont;
    PDEV*               ppdev;

    PDEVOBJ po(hdev);

    ppdev = po.ppdev;

    // Now traverse all the device bitmaps associated with this device,
    // and convert any driver-owned bitmaps to DIBs.

    bConversionSuccessful = TRUE;

    hobj = 0;
    while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
    {
      // Retrieve the handle to the next surface before we delete
      // the current one:

      hobj = (HOBJ) pSurface->hGet();

      // Note that the sprite code handles mode changes for sprite
      // surfaces.

      if ((pSurface->hdev() == hdev) &&
          (pSurface->bDeviceDependentBitmap()) &&
          (pSurface->dhpdev() != NULL))
      {
        // The surface cannot be converted if there is any
        // outstanding lock other than those done to select
        // a bitmap into a DC.  We can't very well go and de-
        // allocate 'pSurface' while someone is looking at it.
        //
        // However, we really shouldn't fail a dynamic mode
        // change if some thread somewhere in the system should
        // happen to be doing a bitmap operation with a DFB.
        // For that reason, wherever a surface is locked,
        // we endeavour to hold either the dynamic mode change
        // lock or the devlock -- and since at this very moment
        // we have both, that should mean that these conversions
        // will never fail due to lock issues.

        if (pSurface->hdc() != 0)
        {
            // WinBug #242572 3-13-2001 jasonha Surface not selected by DC it thinks it is
            //
            // When a DC is saved while a DFB is selected, but then another
            // surface or no surface is selected, bConvertDfbDcToDib will
            // try to convert the top-level DC's surface to a DIB.
            //
            // Walk the saved DC chain until the first DC actually referencing
            // this surface is found.
            //

            HDC hdc = pSurface->hdc();

            while (1)
            {
                MDCOBJA dco(hdc);           // Alt-lock

                ASSERTGDI(dco.bValid(), "Surface DC is invalid");

                if (dco.pSurface() == pSurface)
                {
                    if (!bConvertDfbDcToDib(&dco))
                    {
                      WARNING("Failed DC surface conversion (possibly from low memory)\n");
                      bConversionSuccessful = FALSE;
                    }
                    break;
                }

                ASSERTGDI(dco.lSaveDepth() > 1, "DC selected surface not found in DC stack.");

                hdc = dco.hdcSave();
            }
        }
        else
        {
          // Handle Compatible Stock Surfaces
          if (pSurface->bStockSurface())
          {

            if (!pConvertDfbSurfaceToDib(hdev, pSurface, pSurface->cRef()))
            {
              WARNING("Failed stock surface conversion in bConvertStockDfbToDib()\n");
              bConversionSuccessful = FALSE;
            }
          }
          else
          {

            // No-one should have a lock on the bitmap:

            if (!pConvertDfbSurfaceToDib(hdev, pSurface, 0))
            {
              WARNING("Failed surface conversion (possibly from low memory)\n");
              bConversionSuccessful = FALSE;
            }
          }
        }
      }
    }

    // We are safe from new DFBs being created right now because we're
    // holding the devlock.

    if (bConversionSuccessful)
    {
      // Now get rid of any font caches that the old instance
      // of the driver may have.
      //
      // We're protected against having bDeleteRFONT call the
      // driver at the same time because it has to grab the
      // Devlock, and we're already holding it.

      pfnDrvDestroyFont = PPFNDRV(po, DestroyFont);
      if (pfnDrvDestroyFont != NULL)
      {
        // We must hold the RFONT list semaphore while we traverse the
        // RFONT list!

        for (prfnt = ppdev->prfntInactive;
             prfnt != NULL;
             prfnt = prfnt->rflPDEV.prfntNext)
        {
          pfo = &prfnt->fobj;
          pfnDrvDestroyFont(pfo);
          pfo->pvConsumer = NULL;
        }

        for (prfnt = ppdev->prfntActive;
             prfnt != NULL;
             prfnt = prfnt->rflPDEV.prfntNext)
        {
          pfo = &prfnt->fobj;
          pfnDrvDestroyFont(pfo);
          pfo->pvConsumer = NULL;
        }
      }

      // Make it so that any brush realizations are invalidated, because
      // we don't want a new instance of the driver trying to use old
      // instance 'pvRbrush' data.
      //
      // This also takes care of invalidating the brushes for all the
      // DDB to DIB conversions.
      //
      // Note that we're actually invalidating the caches of all brushes
      // in the system, because we don't store any 'hdevOld' information
      // with the brush.  Because dynamic mode changes should be relatively
      // infrequent, and because realizations are reasonably cheap, I don't
      // expect this to be a big hit.

      hobj = 0;
      while (pbrush = (BRUSH*) HmgSafeNextObjt(hobj, BRUSH_TYPE))
      {
        hobj = (HOBJ) pbrush->hGet();

        // Mark as dirty by setting the cache ID to
        // an invalid state.

        pbrush->ulSurfTime((ULONG) -1);

        // Set the uniqueness so the are-you-really-
        // dirty check in vInitBrush will not think
        // an old realization is still valid.

        pbrush->ulBrushUnique(pbrush->ulGlobalBrushUnique());
      }

      // We must disable the halftone device information when changing
      // colour depths because the GDIINFO data it was constructed with
      // are no longer valid.  It is always enabled lazily, so there's no
      // need to reenable it here:

      if (ppdev->pDevHTInfo != NULL)
      {
        po.bDisableHalftone();
      }
    }

    return(bConversionSuccessful);
}

/******************************Public*Routine******************************\
* bDynamicIntersectVisRect
*
* It is critical that we must be able to update all VisRgns if the new
* mode is smaller than the old.  If this did not happen, we could allow
* GDI calls to the driver that are outside the bounds of the visible
* display, and as a result the driver would quite likely fall over.
*
* We don't entrust USER to always take care of this case because it
* updates the VisRgns after it knows that bDynamicModeChange was
* successful -- which is too late if the VisRgn change should fail
* because of low memory.  It's acceptable in low memory situations to
* temporarily draw incorrectly as a result of a wrong VisRgn, but it
* is *not* acceptable to crash.
*
* Doing this here also means that USER doesn't have to call
* us while holding the Devlock.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDynamicIntersectVisRect(
    SURFACE*  pSurfaceOld,
    SIZEL     sizlNew
    )
{
    HOBJ    hobj;
    DC*     pdc;

    hobj = 0;
    while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
    {
      hobj = (HOBJ) pdc->hGet();

      if ((!(pdc->fs() & DC_IN_CLONEPDEV)) &&
          (pdc->pSurface() == pSurfaceOld) &&
          (pdc->prgnVis() != NULL))
      {
        if (!GreIntersectVisRect((HDC) hobj, 0, 0,
                                 sizlNew.cx, sizlNew.cy))
        {
          WARNING("bDynamicModeChange: Failed reseting VisRect!\n");

          // Note that if we fail here, we may have already
          // shrunk some VisRgn's.  However, we should have only
          // failed in a very low-memory situation, in which case
          // there will be plenty of other drawing problems.  The
          // regions will likely all be reset back to the correct
          // dimensions by the owning applications, eventually.

          return(FALSE);
        }
      }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDynamicSwitchPalettes
*
* Device Independent Bitmaps (DIBs) are great when switching colour
* depths because, by virtue of their attached colour table (also known
* as a 'palette'), they Just Work at any colour depth.
*
* Device Dependent Bitmaps (DDBs) are more problematic.  They implicitly
* share their palette with the display -- meaning that if the display's
* palette is dynamically changed, the old DDBs will not work.  We get
* around this by dynamically creating palettes to convert them to DIBs.
* Unfortunately, at palettized 8bpp we sometimes have to guess at what
* the appropriate palette would be.  For this reason, whenever we switch
* back to 8bpp we make sure we convert them back to DDBs by removing their
* palettes.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDynamicSwitchPalettes(
    SURFACE*    pSurface,
    PDEV*       ppdevOld,
    PDEV*       ppdevNew
    )
{
    PALETTE*    ppalOld;
    HOBJ        hobj;
    BOOL        bHintCreated;

    ASSERTGDI(pSurface->iType() == STYPE_BITMAP,
        "Unexpected bitmap type");
    ASSERTGDI(pSurface->iFormat() == ppdevOld->devinfo.iDitherFormat,
        "Unexpected bitmap format");

    // Device Format Bitmaps (DFBs) are DDBs that are created via
    // CreateCompatibleBitmap, and so we know what device they're
    // associated with.
    //
    // Unfortunately, non-DFB DDBs (created via CreateBitmap or
    // CreateDiscardableBitmap) have no device assocation -- so we
    // don't know whether or not they're really associated with the
    // display.
    //
    // If a non-DFB DDB is currently selected into a DC owned by the
    // display, we will add a palette to it.  If a non-DFB DDB is
    // not currently selected into a DC owned by the display (implied
    // by having its surface 'hdev' as zero), we will not convert it.
    // SelectBitmap will refuse to load it into a DC.  (In 4.0 we used
    // to always assume that any such bitmap was intended for the
    // display, but that's not always a valid assumption, and doesn't
    // make much sense in a multiple-monitor or multi-user environment
    // anyway.)  Fortunately, non-DFB DDBs are increasingly rare.
    //
    // Note that DFBs are synchronized by the Devlock, and we don't
    // need a lock to change the palette for a non-DFB DDB (see
    // PALETTE_SELECT_SET logic).

    ppalOld = ppdevOld->ppalSurf;

    if (pSurface->ppal() == NULL)
    {
      // Mark the surface to note that we added a palette:

      pSurface->vSetDynamicModePalette();

      if (ppdevOld->GdiInfo.flRaster & RC_PALETTE)
      {
        bHintCreated = FALSE;
        if (pSurface->hpalHint() != 0)
        {
          EPALOBJ palDC(pSurface->hpalHint());
          if ((palDC.bValid())         &&
              (palDC.bIsPalDC())       &&
              (!palDC.bIsPalDefault()) &&
              (palDC.ptransFore() != NULL))
          {
            PALMEMOBJ palPerm;
            XEPALOBJ  palSurf(ppalOld);

            if (palPerm.bCreatePalette(PAL_INDEXED,
                    256,
                    (ULONG*) palSurf.apalColorGet(),
                    0,
                    0,
                    0,
                    PAL_FREE))
            {
              ULONG nPhysChanged = 0;
              ULONG nTransChanged = 0;

              palPerm.ulNumReserved(palSurf.ulNumReserved());

              bHintCreated = TRUE;
              vMatchAPal(NULL,
                         palPerm,
                         palDC,
                         &nPhysChanged,
                         &nTransChanged);

              palPerm.vKeepIt();
              pSurface->ppal(palPerm.ppalGet());

              // Keep a reference active:

              palPerm.ppalSet(NULL);
            }
          }
        }

        if (!bHintCreated)
        {
          INC_SHARE_REF_CNT(ppalDefaultSurface8bpp);
          pSurface->ppal(ppalDefaultSurface8bpp);
        }
      }
      else
      {
        INC_SHARE_REF_CNT(ppalOld);
        pSurface->ppal(ppalOld);
      }
    }
    else if ((pSurface->ppal() == ppalOld) &&
             (pSurface->flags() & PALETTE_SELECT_SET))
    {
      ASSERTGDI((pSurface->hdc() != 0) &&
                (pSurface->cRef() != 0),
               "Expected bitmap to be selected into a DC");

      INC_SHARE_REF_CNT(pSurface->ppal());
      pSurface->flags(pSurface->flags() & ~PALETTE_SELECT_SET);
    }

    // When switching back to palettized 8bpp, remove any palettes we
    // had to add to 8bpp DDBs:

    if (ppdevNew->GdiInfo.flRaster & RC_PALETTE)
    {
      if (pSurface->bDynamicModePalette())
      {
        ASSERTGDI(pSurface->ppal() != NULL,
            "Should be a palette here");

        XEPALOBJ pal(pSurface->ppal());
        pal.vUnrefPalette();

        pSurface->vClearDynamicModePalette();
        pSurface->ppal(NULL);
      }
    }
}

/******************************Public*Routine******************************\
* bDynamicModeChange
*
* USER callable function that switches driver instances between two PDEVs.
*
* GDI's 'HDEV' and 'PDEV' stay the same; only the device's 'pSurface',
* 'dhpdev', GDIINFO, DEVINFO, and palette information change.
*
* The caller is ChangeDisplaySettings in USER, which is reponsible for:
*
*   o Calling us with a valid devmode;
*   o Ensuring that the device is not currently in full-screen mode;
*   o Invalidating all of its SaveScreenBits buffers;
*   o Changing the VisRgn's on all DCs;
*   o Resetting the pointer shape;
*   o Sending the appropriate messages to everyone;
*   o Redrawing the desktop.
*
* Since CreateDC("DISPLAY") always gets mapped to GetDC(NULL), there are
* no DC's for which GDI is responsible for updating the VisRgn.
*
* Dynamically changes a display driver or mode.
*
* Rules of This Routine
* ---------------------
*
* o An important precept is that no drawing by any threads to any
*   application's bitmaps should be affected by this routine.  This means,
*   for example, that we cannot exclusive lock any DCs.
*
* o While we keep GDI's 'HDEV' and 'PDEV' in place, we do have to modify
*   fields like 'dhpdev' and 'pSurface'.  Because we also have to update
*   copies of these fields that are stashed in DC's, it means that *all*
*   accesses to mode-dependent fields such as 'dhpdev,' 'pSurface,' and
*   'sizl' must be protected by holding a resource that this routine
*   acquires -- such as the devlock or handle-manager lock.
*
* o If the function fails for whatever reason, the mode MUST be restored
*   back to its original state.
*
* Returns: TRUE if successful, FALSE if the two PDEVs didn't match enough,
*          or if we're out of memory.
*
* History:
*  8-Feb-1996 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
*
*  27-Aug-1996 -by- J. Andrew Goossen [andrewgo]
* Added support for dynamic display driver changes.
*
\**************************************************************************/

ULONG gcModeChanges;    // # of mode changes, for debugging even on free builds

#define SWAP(x, y, tmp) { (tmp) = (x); (x) = (y); (y) = (tmp); }

typedef union {
    GDIINFO                     GdiInfo;
    DEVINFO                     devinfo;
    PFN                         apfn[INDEX_LAST];
    LDEV*                       pldev;
    HANDLE                      hSpooler;
    PVOID                       pDesktopId;
    PGRAPHICS_DEVICE            pGraphicsDevice;
    POINTL                      ptlOrigin;
    PDEVMODEW                   ppdevDevmode;
    PFN_DrvSetPointerShape      pfnSet;
    PFN_DrvMovePointer          pfnMove;
    PFN_DrvSynchronize          pfnSync;
    PFN_DrvSynchronizeSurface   pfnSyncSurface;
    PFN_DrvSetPalette           pfnSetPalette;
    PFN_DrvBitBlt               pfnUnfilteredBitBlt;
    PFN_DrvNotify               pfnNotify;
    BYTE                        dc[sizeof(DC)];
    SIZEL                       sizlMeta;
    HSURF                       ahsurf[HS_DDI_MAX];
    HLFONT                      hlfnt;
    DWORD                       dwDriverAccelerationLevel;
    DWORD                       dwDriverCapableOverride;
#ifdef DDI_WATCHDOG
    PWATCHDOG_DATA              pWatchdogData;
#endif
} SWAPBUFFER;

BOOL
bDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew
    )
{
    BOOL                bRet;
    BOOL                bFormatChange;
    PDEV*               ppdevOld;
    PDEV*               ppdevNew;
    DHPDEV              dhpdevOld;
    DHPDEV              dhpdevNew;
    SURFACE*            pSurfaceOld;
    SURFACE*            pSurfaceNew;
    PALETTE*            ppalOld;
    PALETTE*            ppalNew;
    ULONG               cBppOld;
    ULONG               cBppNew;
    SIZEL               sizlOld;
    SIZEL               sizlNew;
    SURFACE*            pSurface;        // Temporary surface pointer
    DC*                 pdc;             // Temporary DC pointer
    DRVOBJ*             pdo;             // Temporary DRVOBJ pointer
    HOBJ                hobj;            // Temporary object handle
    BOOL                bPermitModeChange;
    BRUSH*              pbrGrayPattern;
    DC*                 pdcBuffer;       // Points to temporary DC buffer
    SWAPBUFFER*         pswap;
    BOOL                bDisabledOld;
    BOOL                bDisabledNew;
    PFN_DrvResetPDEV    pfnDrvResetPDEV;

    bRet = FALSE;                           // Assume failure

    // We impose some restrictions upon what capabilities may change
    // between drivers:

    if (bDynamicMatchEnoughForModeChange(hdevOld, hdevNew))
    {

      ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
                  "ShareDevlock must held be before calling bDynamicModeChange");

      // Allocate a temporary buffer for use swapping data:

      pswap = (SWAPBUFFER*) PALLOCNOZ(sizeof(SWAPBUFFER), 'pmtG');
      if (pswap)
      {
        PDEVOBJ poOld(hdevOld);
        PDEVOBJ poNew(hdevNew);

        bDisabledNew = poNew.bDisabled();
        bDisabledOld = poOld.bDisabled();

        // Disable timer-based synchronization for these PDEVs for now.
        // This is mainly so that the PDEV_SYNCHRONIZE_ENABLED is set
        // correctly.

        vDisableSynchronize(hdevNew);
        vDisableSynchronize(hdevOld);

        cBppOld = poOld.GdiInfo()->cBitsPixel * poOld.GdiInfo()->cPlanes;
        cBppNew = poNew.GdiInfo()->cBitsPixel * poNew.GdiInfo()->cPlanes;

        // Ideally, we would check the palettes here, too:

        bFormatChange = (cBppOld != cBppNew);

        ppdevOld = (PDEV*) hdevOld;
        ppdevNew = (PDEV*) hdevNew;

        // PDEV shouldn't be clone

        ASSERTGDI(!poOld.bCloneDriver(),"pdevOld is clone!");
        ASSERTGDI(!poNew.bCloneDriver(),"pdevNew is clone!");

        // The following lock rules must be abided, otherwise deadlocks may
        // arise:
        //
        // o  Pointer lock must be acquired after Devlock (GreSetPointer);
        //
        // And see drvsup.cxx, too.
        //
        // So we acquire locks in the following order (note that the
        // vAssertDynaLock() routines should be modified if this list ever
        // changes):

        ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(poOld.hsemDevLock()),
                  "Devlock must be held before acquiring the pointer semaphore");

        SEMOBJ soPointer(poOld.hsemPointer()); // No asynchronous pointer moves

        ASSERTGDI(ppdevOld->pSurface != NULL, "Must be called on a completed PDEV");
        ASSERTGDI(poOld.bDisplayPDEV(), "Must be called on a display PDEV");
        ASSERTGDI((prgnDefault->cScans == 1) && (prgnDefault->rcl.right == 0),
            "Someone changed prgnDefault; could cause driver access violations");

        // Free all PDEV state that is dependent on or cached by the driver:

        if (bDynamicRemoveAllDriverRealizations(hdevOld) &&
            bDynamicRemoveAllDriverRealizations(hdevNew))
        {
          bPermitModeChange = TRUE;

          sizlOld       = poOld.sizl();
          pSurfaceOld   = ppdevOld->pSurface;
          ppalOld       = ppdevOld->ppalSurf;
          dhpdevOld     = ppdevOld->dhpdev;

          sizlNew       = poNew.sizl();
          pSurfaceNew   = ppdevNew->pSurface;
          ppalNew       = ppdevNew->ppalSurf;
          dhpdevNew     = ppdevNew->dhpdev;

          // Make sure the VisRgns are immediately shrunk if necessary:

          if ((sizlNew.cx < sizlOld.cx) || (sizlNew.cy < sizlOld.cy))
          {
            bPermitModeChange &= bDynamicIntersectVisRect(pSurfaceOld, sizlNew);
          }
          if ((sizlOld.cx < sizlNew.cx) || (sizlOld.cy < sizlNew.cy))
          {
            bPermitModeChange &= bDynamicIntersectVisRect(pSurfaceNew, sizlOld);
          }

          // Finally, if we're not switching drivers then let the driver know
          // about the mode switch.  This has to be the last step because we
          // are implicitly telling the driver that it can transfer data from
          // the old instance to the new instance with the assurance that the
          // new instance won't later be abandoned.

          pfnDrvResetPDEV = PPFNDRV(poNew, ResetPDEV);
          if ((pfnDrvResetPDEV != NULL) &&
              (pfnDrvResetPDEV == PPFNDRV(poOld, ResetPDEV)) &&
              (poNew.pldev() == poOld.pldev()))
          {
            // The driver can refuse the mode switch if it wants:

            if (bPermitModeChange)
            {
              GreEnterMonitoredSection(poOld.ppdev, WD_DEVLOCK);
              bPermitModeChange = pfnDrvResetPDEV(dhpdevOld, dhpdevNew);
              GreExitMonitoredSection(poOld.ppdev, WD_DEVLOCK);
            }
          }

          if (bPermitModeChange)
          {
            /////////////////////////////////////////////////////////////
            // At this point, we're committed to the mode change.
            // Nothing below this point can be allowed to fail.
            /////////////////////////////////////////////////////////////

            // Traverse all DC's and update their surface information if
            // they're associated with this device.
            //
            // Note that bDeleteDCInternal wipes some fields in the DC via
            // bCleanDC before freeing the DC, but this is okay since the
            // worst we'll do is update some fields just before the DC gets
            // deleted.

            hobj = 0;
            while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
            {
              hobj = (HOBJ) pdc->hGet();

              if (!(pdc->fs() & DC_IN_CLONEPDEV))
              {
                // Note that we don't check that pdc->hdevOld() == hdevOld
                // because the SaveDC stuff doesn't bother copying the hdevOld,
                // but DOES copy the dclevel.
                //
                // Note that 'flbrushAdd()' is not an atomic operation.
                // However, since we're holding the devlock and the palette
                // lock, there shouldn't be any other threads alt-locking our
                // DC and modifying these fields at the same time:

                if (pdc->pSurface() == pSurfaceOld)
                {
                  pdc->pSurface(pSurfaceNew);
                  pdc->sizl(sizlNew);
                  pdc->flbrushAdd(DIRTY_BRUSHES);
                }
                else if (pdc->pSurface() == pSurfaceNew)
                {
                  pdc->pSurface(pSurfaceOld);
                  pdc->sizl(sizlOld);
                  pdc->flbrushAdd(DIRTY_BRUSHES);
                }

                if (pdc->dhpdev() == dhpdevOld)
                {
                  pdc->dhpdev(dhpdevNew);
                  pdc->flGraphicsCaps(poNew.flGraphicsCaps());
                  pdc->flGraphicsCaps2(poNew.flGraphicsCaps2());
                }
                else if (pdc->dhpdev() == dhpdevNew)
                {
                  pdc->dhpdev(dhpdevOld);
                  pdc->flGraphicsCaps(poOld.flGraphicsCaps());
                  pdc->flGraphicsCaps2(poOld.flGraphicsCaps2());
                }
              }
            }

            // Compatible bitmap palettes may have to be changed if the
            // mode changes.  Note that the sprite code handles any
            // sprite surfaces:

            hobj = 0;
            while (pSurface = (SURFACE*) HmgSafeNextObjt(hobj, SURF_TYPE))
            {
              hobj = (HOBJ) pSurface->hGet();

              if (pSurface->hdev() == hdevOld)
              {
                if (pSurface->bApiBitmap())
                {
                  if ((bFormatChange) &&
                      (pSurface->iFormat() == pSurfaceOld->iFormat()))
                  {
                    vDynamicSwitchPalettes(pSurface, ppdevOld, ppdevNew);
                  }
                }

                // Surfaces private to the driver should be transferred
                // along with the driver instance.

                else if (pSurface->bDriverCreated() && !pSurface->bDirectDraw())
                {
                  pSurface->hdev(hdevNew);
                }
              }
              else if (pSurface->hdev() == hdevNew)
              {
                if (pSurface->bApiBitmap())
                {
                  if ((bFormatChange) &&
                      (pSurface->iFormat() == pSurfaceNew->iFormat()))
                  {
                    vDynamicSwitchPalettes(pSurface, ppdevNew, ppdevOld);
                  }
                }

                // Surfaces private to the driver should be transferred
                // along with the driver instance.

                else if (pSurface->bDriverCreated() && !pSurface->bDirectDraw())
                {
                  pSurface->hdev(hdevOld);
                }
              }
            }

            // DRIVEROBJs are transferred with the driver to the new PDEV:

            hobj = 0;
            while (pdo = (DRVOBJ*) HmgSafeNextObjt(hobj, DRVOBJ_TYPE))
            {
              hobj = (HOBJ) pdo->hGet();

              if (pdo->hdev == hdevOld)
              {
                pdo->hdev = hdevNew;
                poNew.vReferencePdev();
                poOld.vUnreferencePdev();
              }
              else if (pdo->hdev == hdevNew)
              {
                pdo->hdev = hdevOld;
                poOld.vReferencePdev();
                poNew.vUnreferencePdev();
              }
            }

            // Same with WNDOBJs:

            vChangeWndObjs(pSurfaceOld, hdevOld, pSurfaceNew, hdevNew);

            // Re-realize the gray pattern brush which is used for drag
            // rectangles:

            pbrGrayPattern = (BRUSH*) HmgShareLock((HOBJ)ghbrGrayPattern,
                                                   BRUSH_TYPE);

            pdcBuffer = (DC*) &pswap->dc;
            pdcBuffer->pDCAttr = &pdcBuffer->dcattr;
            pdcBuffer->crTextClr(0x00000000);
            pdcBuffer->crBackClr(0x00FFFFFF);
            pdcBuffer->lIcmMode(DC_ICM_OFF);
            pdcBuffer->hcmXform(NULL);

            poOld.pbo()->vInitBrush(pdcBuffer,
                                    pbrGrayPattern,
                                    (XEPALOBJ) ppalDefault,
                                    (XEPALOBJ) ppalNew,
                                    pSurfaceNew);
            poNew.pbo()->vInitBrush(pdcBuffer,
                                    pbrGrayPattern,
                                    (XEPALOBJ) ppalDefault,
                                    (XEPALOBJ) ppalOld,
                                    pSurfaceOld);

            DEC_SHARE_REF_CNT(pbrGrayPattern);

            /////////////////////////////////////////////////////////////
            // Update all our PDEV fields:
            /////////////////////////////////////////////////////////////

            // Swap surface data between the two PDEVs:

            ppdevNew->pSurface = pSurfaceOld;
            ppdevNew->ppalSurf = ppalOld;
            ppdevNew->dhpdev   = dhpdevOld;

            ppdevOld->pSurface = pSurfaceNew;
            ppdevOld->ppalSurf = ppalNew;
            ppdevOld->dhpdev   = dhpdevNew;

            if (!pSurfaceOld->bReadable())
            {
              pSurfaceNew->flags(pSurfaceNew->flags() | UNREADABLE_SURFACE);

              SPRITESTATE *pStateOld = poOld.pSpriteState();
              if (pStateOld)
              {
                if (pStateOld->flOriginalSurfFlags & UNREADABLE_SURFACE ||
                    pStateOld->flSpriteSurfFlags & UNREADABLE_SURFACE)
                {
                  SPRITESTATE *pStateNew = poNew.pSpriteState();
                  if (pStateNew)
                  {
                    pStateNew->flOriginalSurfFlags |= UNREADABLE_SURFACE;
                    pStateNew->flSpriteSurfFlags |= UNREADABLE_SURFACE;
                  }
                }
              }
            }
            else if (!pSurfaceNew->bReadable())
            {
              pSurfaceOld->flags(pSurfaceOld->flags() | UNREADABLE_SURFACE);

              SPRITESTATE *pStateNew = poNew.pSpriteState();
              if (pStateNew)
              {
                if (pStateNew->flOriginalSurfFlags & UNREADABLE_SURFACE ||
                    pStateNew->flSpriteSurfFlags & UNREADABLE_SURFACE)
                {
                  SPRITESTATE *pStateOld = poOld.pSpriteState();
                  if (pStateOld)
                  {
                    pStateOld->flOriginalSurfFlags |= UNREADABLE_SURFACE;
                    pStateOld->flSpriteSurfFlags |= UNREADABLE_SURFACE;
                  }
                }
              }
            }
            // WINBUG #365395 4-10-2001 jasonha Need to investigate old comments in bDynamicModeChange
            //
            // Old Comments:
            //  - vUnrefPalette of old palette for mirrored drivers?
            //  - Secondary palette fix?

            SWAP(ppdevNew->pldev          ,ppdevOld->pldev          ,pswap->pldev          );
            SWAP(ppdevNew->devinfo        ,ppdevOld->devinfo        ,pswap->devinfo        );
            SWAP(ppdevNew->GdiInfo        ,ppdevOld->GdiInfo        ,pswap->GdiInfo        );
            SWAP(ppdevNew->hSpooler       ,ppdevOld->hSpooler       ,pswap->hSpooler       );
            SWAP(ppdevNew->pDesktopId     ,ppdevOld->pDesktopId     ,pswap->pDesktopId     );
            SWAP(ppdevNew->pGraphicsDevice,ppdevOld->pGraphicsDevice,pswap->pGraphicsDevice);
            SWAP(ppdevNew->ptlOrigin      ,ppdevOld->ptlOrigin      ,pswap->ptlOrigin      );
            SWAP(ppdevNew->ppdevDevmode   ,ppdevOld->ppdevDevmode   ,pswap->ppdevDevmode   );

            SWAP(ppdevNew->pfnUnfilteredBitBlt,
                 ppdevOld->pfnUnfilteredBitBlt,
                 pswap->pfnUnfilteredBitBlt);

            SWAP(ppdevNew->dwDriverCapableOverride,
                 ppdevOld->dwDriverCapableOverride,
                 pswap->dwDriverCapableOverride);

            SWAP(ppdevNew->dwDriverAccelerationLevel,
                 ppdevOld->dwDriverAccelerationLevel,
                 pswap->dwDriverAccelerationLevel);

            // Swap multimon data between the two PDEVs:

            if (poOld.bMetaDriver() != poNew.bMetaDriver())
            {
                BOOL bMetaDriver = poOld.bMetaDriver();
                poOld.bMetaDriver(poNew.bMetaDriver());
                poNew.bMetaDriver(bMetaDriver);
            }

            SWAP(ppdevNew->sizlMeta, ppdevOld->sizlMeta, pswap->sizlMeta);

            // Swap pattern brushes

            RtlCopyMemory(pswap->ahsurf,    ppdevNew->ahsurf, sizeof(HSURF)*HS_DDI_MAX);
            RtlCopyMemory(ppdevNew->ahsurf, ppdevOld->ahsurf, sizeof(HSURF)*HS_DDI_MAX);
            RtlCopyMemory(ppdevOld->ahsurf, pswap->ahsurf,    sizeof(HSURF)*HS_DDI_MAX);

            // Swap log fonts.

            SWAP(ppdevNew->hlfntDefault,      ppdevOld->hlfntDefault,      pswap->hlfnt);
            SWAP(ppdevNew->hlfntAnsiVariable, ppdevOld->hlfntAnsiVariable, pswap->hlfnt);
            SWAP(ppdevNew->hlfntAnsiFixed,    ppdevOld->hlfntAnsiFixed,    pswap->hlfnt);

            // Swap the dispatch tables and accelerators:

            RtlCopyMemory(pswap->apfn,    ppdevNew->apfn, sizeof(PFN)*INDEX_LAST);
            RtlCopyMemory(ppdevNew->apfn, ppdevOld->apfn, sizeof(PFN)*INDEX_LAST);
            RtlCopyMemory(ppdevOld->apfn, pswap->apfn,    sizeof(PFN)*INDEX_LAST);

            SWAP(ppdevNew->pfnDrvSetPointerShape, ppdevOld->pfnDrvSetPointerShape, pswap->pfnSet);
            SWAP(ppdevNew->pfnDrvMovePointer,     ppdevOld->pfnDrvMovePointer,     pswap->pfnMove);
            SWAP(ppdevNew->pfnSync,               ppdevOld->pfnSync,               pswap->pfnSync);
            SWAP(ppdevNew->pfnSyncSurface,        ppdevOld->pfnSyncSurface,        pswap->pfnSyncSurface);
            SWAP(ppdevNew->pfnSetPalette,         ppdevOld->pfnSetPalette,         pswap->pfnSetPalette);
            SWAP(ppdevNew->pfnNotify,             ppdevOld->pfnNotify,             pswap->pfnNotify);
#ifdef DDI_WATCHDOG
            SWAP(ppdevNew->pWatchdogData,         ppdevOld->pWatchdogData,         pswap->pWatchdogData);
#endif

            // Inform the drivers of their new PDEVs:

            (*PPFNDRV(poNew, CompletePDEV))(poNew.dhpdev(), poNew.hdev());
            (*PPFNDRV(poOld, CompletePDEV))(poOld.dhpdev(), poOld.hdev());

            // Transfer all the DirectDraw state:

            DxDdDynamicModeChange(hdevOld, hdevNew, 0);

            // Transfer the disabled state:

            poOld.bDisabled(bDisabledNew);
            poNew.bDisabled(bDisabledOld);

            // Update the magic colours in the surface palette:

            vResetSurfacePalette(hdevOld);
            vResetSurfacePalette(hdevNew);

            // Transfer all the sprites between the two PDEVs:

            vSpDynamicModeChange(hdevOld, hdevNew);

            // Update the gamma-ramp on the device only if a gamma-ramp
            // existed in the old (but at this moment, old is "new") PDEV:

            UpdateGammaRampOnDevice(hdevOld, FALSE);

            // Update some handy debug information:

            gcModeChanges++;

            bRet = TRUE;
          }
        }

        VFREEMEM(pswap);

        vEnableSynchronize(hdevNew);
        vEnableSynchronize(hdevOld);
      }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\core\ntgdi\gre\ntgdi.c ===
/******************************Module*Header*******************************\
* Module Name: priv.c
*   This file contains stubs for calls made by USERSRVL
*
* Created: 01-Nov-1994 07:45:35
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/


#include "engine.h"
#include "winfont.h"

#include "server.h"
#include "dciddi.h"
#include "limits.h"
#include "drvsup.hxx"

#ifdef DBGEXCEPT
    int bStopExcept = FALSE;
    int bWarnExcept = FALSE;
#endif

#define DWORD_TO_FLOAT(dw)  (*(PFLOAT)(PDWORD)&(dw))
#define DWORD_TO_FLOATL(dw) (*(FLOATL *)(PDWORD)&(dw))

typedef struct {
   ULONG uM11;
   ULONG uM12;
   ULONG uM21;
   ULONG uM22;
   ULONG uDx;
   ULONG uDy;
} ULONGXFORM, *PULONGXFORM;

VOID ProbeAndWriteBuffer(PVOID Dst, PVOID Src, ULONG Length)
{
    if (((ULONG_PTR)Dst + Length <= (ULONG_PTR)Dst) ||
       ((ULONG_PTR)Dst + Length > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) {
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;
    }

    RtlCopyMemory(Dst, Src, Length);

    return;
}

VOID ProbeAndWriteAlignedBuffer(PVOID Dst, PVOID Src, ULONG Length, ULONG Alignment)
{

    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||
           ((Alignment) == 4) || ((Alignment) == 8) ||
           ((Alignment) == 16));

    if (((ULONG_PTR)Dst + Length <= (ULONG_PTR)Dst) ||
        ((ULONG_PTR)Dst + Length > (ULONG_PTR) MM_USER_PROBE_ADDRESS)  ||
        ((((ULONG_PTR)Dst) & (Alignment - 1)) != 0))    {
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;
    }

    RtlCopyMemory(Dst, Src, Length);

    return;
}


/******************************Public*Routine******************************\
* bConvertDwordToFloat
*
*     This routine casts a DWORD to a float, and checks whether the float
*     is valid (on the Alpha).  This is accomplished by doing a floating
*     point operation and catching the exception if one is generated.
*
* Arguments:
*
*     dword   - the float before the cast
*     *floatl - a pointer to a float that will receive the value after the
*               cast
*
* Return Value:
*
*    TRUE for valid floats, FALSE otherwise.
*
* History:
*
*   13-May-1998 -by- Ori Gershony [OriG]
*
\**************************************************************************/

BOOL
bConvertDwordToFloat(
    DWORD   dword,
    FLOATL *floatl
    )
{
    BOOL bRet=TRUE;

    try
    {
        *floatl = DWORD_TO_FLOATL(dword);

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* ProbeAndConvertXFORM
*
* This routine probe and copy a user mode xform into kernel mode address,
* At the same time, it checks if the each FLOAT in the XFORM is valid, to prevent
* us to get into a floating point trap on ALPHA. Refer to bConvertDwordToFloat
* for more info.
*
* History:
*  11/24/98 by Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
ProbeAndConvertXFORM(
      XFORML *kpXform,
      XFORML *pXform
      )
{
   BOOL bRet=TRUE;

   try
   {
       ULONGXFORM *pUXform = (ULONGXFORM *)kpXform;
       ProbeForRead(pUXform, sizeof(ULONGXFORM), sizeof(BYTE));

       bRet = (bConvertDwordToFloat (pUXform->uM11, &(pXform->eM11))) &&
              (bConvertDwordToFloat (pUXform->uM12, &(pXform->eM12))) &&
              (bConvertDwordToFloat (pUXform->uM21, &(pXform->eM21))) &&
              (bConvertDwordToFloat (pUXform->uM22, &(pXform->eM22))) &&
              (bConvertDwordToFloat (pUXform->uDx, &(pXform->eDx))) &&
              (bConvertDwordToFloat (pUXform->uDy, &(pXform->eDy)));
   }
   except(EXCEPTION_EXECUTE_HANDLER)
   {
       bRet = FALSE;
   }

   return bRet;
}

/******************************Public*Routine******************************\
*
* NtGdiGetCharacterPlacementW
*
* History:
*  26-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define ALIGN4(X) (((X) + 3) & ~3)

DWORD NtGdiGetCharacterPlacementW(
    HDC              hdc,
    LPWSTR           pwsz,
    int              nCount,
    int              nMaxExtent,
    LPGCP_RESULTSW   pgcpw,
    DWORD            dwFlags
)
{
    DWORD   dwRet = 0;
    BOOL    bOk = TRUE;     // only change is something goes wrong
    LPWSTR  pwszTmp = NULL; // probe for read
    ULONG   cjW = 0;

    ULONG   dpOutString = 0;
    ULONG   dpOrder = 0;
    ULONG   dpDx = 0;
    ULONG   dpCaretPos = 0;
    ULONG   dpClass = 0;
    ULONG   dpGlyphs = 0;
    DWORD   cjWord, cjDword;

    LPGCP_RESULTSW   pgcpwTmp = NULL;
    VOID            *pv       = NULL;

// it is much easier to structure the code if we copy pgcpw locally
// at the beginning.

    GCP_RESULTSW    gcpwLocal;

// valitidy checking

    if ((nCount < 0) || ((nMaxExtent < 0) && (nMaxExtent != -1)) || !pwsz)
    {
        return dwRet;
    }

    if (pgcpw)
    {
        try
        {
        // we are eventually going to want to write to this structure
        // so we will do ProbeForWrite now, which will probe the structure
        // for both writing and reading. Otherwise, at this time
        // ProbeForRead would suffice.

           ProbeForWrite(pgcpw, sizeof(GCP_RESULTSW), sizeof(DWORD));
           gcpwLocal = *pgcpw;

        // take nCount to be the smaller of the nCounts and gcpwLocal.nGlyphs
        // Win 95 does the same thing [bodind]

            if (nCount > (int)gcpwLocal.nGlyphs)
                nCount = (int)gcpwLocal.nGlyphs;

        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(1);
            return dwRet;
        }
    }

// Check for overflow of cjByte, cjWord, and cjDword (cjByte is implicit
// in handling of gcpwLocal.lpClass case below).

    if (nCount > (MAXIMUM_POOL_ALLOC / sizeof(DWORD)))
    {
        return dwRet;
    }

    cjWord  = (DWORD)nCount * sizeof(WCHAR);
    cjDword = (DWORD)nCount * sizeof(DWORD);

// if pgcpw != NULL, pgcpw may contain some input data and it may
// point to some output data.

    if (pgcpw)
    {
        cjW = sizeof(GCP_RESULTSW);

        if (gcpwLocal.lpOutString)
        {
            dpOutString = cjW;
            cjW += ALIGN4(cjWord);

            if (cjW < dpOutString)
                return dwRet;
        }

        if (gcpwLocal.lpOrder)
        {
            dpOrder = cjW;
            cjW += cjDword;

            if (cjW < dpOrder)
                return dwRet;
        }

        if (gcpwLocal.lpDx)
        {
            dpDx = cjW;
            cjW += cjDword;

            if (cjW < dpDx)
                return dwRet;
        }

        if (gcpwLocal.lpCaretPos)
        {
            dpCaretPos = cjW;
            cjW += cjDword;

            if (cjW < dpCaretPos)
                return dwRet;
        }

        if (gcpwLocal.lpClass)
        {
            dpClass = cjW;
            cjW += ALIGN4(sizeof(char) * nCount);

            if (cjW < dpClass)
                return dwRet;
        }

        if (gcpwLocal.lpGlyphs)
        {
            dpGlyphs = cjW;
            cjW += cjWord;

            if (cjW < dpGlyphs)
                return dwRet;
        }
    }

// alloc mem for gcpw and the string

    if (cjW <= (MAXIMUM_POOL_ALLOC - cjWord))
        pv = AllocFreeTmpBuffer(cjW + cjWord);

    if (pv)
    {
        pwszTmp = (WCHAR*)((BYTE*)pv + cjW);

        if (pgcpw)
        {
            pgcpwTmp = (LPGCP_RESULTSW)pv;

            if (gcpwLocal.lpOutString)
                pgcpwTmp->lpOutString = (LPWSTR)((BYTE *)pgcpwTmp + dpOutString);
            else
                pgcpwTmp->lpOutString = NULL;

            if (gcpwLocal.lpOrder)
                pgcpwTmp->lpOrder = (UINT FAR*)((BYTE *)pgcpwTmp + dpOrder);
            else
                pgcpwTmp->lpOrder = NULL;

            if (gcpwLocal.lpDx)
                pgcpwTmp->lpDx = (int FAR *)((BYTE *)pgcpwTmp + dpDx);
            else
                pgcpwTmp->lpDx = NULL;

            if (gcpwLocal.lpCaretPos)
                pgcpwTmp->lpCaretPos = (int FAR *)((BYTE *)pgcpwTmp + dpCaretPos);
            else
                pgcpwTmp->lpCaretPos = NULL;

            if (gcpwLocal.lpClass)
                pgcpwTmp->lpClass = (LPSTR)((BYTE *)pgcpwTmp + dpClass);
            else
                pgcpwTmp->lpClass = NULL;

            if (gcpwLocal.lpGlyphs)
                pgcpwTmp->lpGlyphs = (LPWSTR)((BYTE *)pgcpwTmp + dpGlyphs);
            else
                pgcpwTmp->lpGlyphs = NULL;

            pgcpwTmp->lStructSize = cjW;
            pgcpwTmp->nGlyphs     = nCount;
        }

    // check the memory with input data:

        try
        {
            ProbeAndReadBuffer(pwszTmp, pwsz, cjWord);
            if ((dwFlags & GCP_JUSTIFYIN) && pgcpw && gcpwLocal.lpDx)
            {
            // must probe for read, lpDx contains input explaining which glyphs to
            // use as spacers for in justifying string

                ProbeAndReadBuffer(pgcpwTmp->lpDx,gcpwLocal.lpDx, cjDword);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNINGX(2);
            // SetLastError(GetExceptionCode());
            bOk = FALSE;
        }

        if (bOk)
        {
            dwRet = GreGetCharacterPlacementW(hdc, pwszTmp,(DWORD)nCount,
                                              (DWORD)nMaxExtent,
                                              pgcpwTmp, dwFlags);

            if (dwRet && pgcpw) // copy data out
            {
                try
                {
                // ProbeForWrite(pgcpw, sizeof(GCP_RESULTSW), sizeof(DWORD));
                // we did this above, see the comment

                    pgcpw->nMaxFit = pgcpwTmp->nMaxFit;
                    pgcpw->nGlyphs = nCount = pgcpwTmp->nGlyphs;

                    cjWord  = (DWORD)nCount * 2;
                    cjDword = (DWORD)nCount * 4;

                    if (gcpwLocal.lpOutString)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpOutString, pgcpwTmp->lpOutString,
                                      cjWord);
                    }

                    if (gcpwLocal.lpOrder)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpOrder, pgcpwTmp->lpOrder, cjDword);
                    }

                    if (gcpwLocal.lpDx)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpDx, pgcpwTmp->lpDx, cjDword);
                    }

                    if (gcpwLocal.lpCaretPos)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpCaretPos, pgcpwTmp->lpCaretPos,
                                      cjDword);
                    }

                    if (gcpwLocal.lpClass)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpClass, pgcpwTmp->lpClass, nCount);
                    }

                    if (gcpwLocal.lpGlyphs)
                    {
                        ProbeAndWriteBuffer(gcpwLocal.lpGlyphs, pgcpwTmp->lpGlyphs, cjWord);
                    }

                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNINGX(3);
                    // SetLastError(GetExceptionCode());
                    bOk = FALSE;
                }
            }
        }
        FreeTmpBuffer(pv);
    }
    else
    {
        bOk = FALSE;
    }

    return (bOk ? dwRet : 0);
}

/*******************************************************************\
* pbmiConvertInfo                                                  *
*                                                                  *
*  Converts BITMAPCOREHEADER into BITMAPINFOHEADER                 *
*  copies the the color table                                      *
*                                                                  *
* 10-1-95 -by- Lingyun Wang [lingyunw]                             *
\******************************************************************/

LPBITMAPINFO pbmiConvertInfo(CONST BITMAPINFO *pbmi, ULONG iUsage)
{
    LPBITMAPINFO pbmiNew;
    ULONG cjRGB;
    ULONG cColorsMax;
    ULONG cColors;
    UINT  uiBitCount;
    ULONG ulSize;
    RGBTRIPLE *pTri;
    RGBQUAD *pQuad;

    ASSERTGDI (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER), "bad header size\n");

    //
    // convert COREHEADER and copy color table
    //

    cjRGB = sizeof(RGBQUAD);
    uiBitCount = ((LPBITMAPCOREINFO)pbmi)->bmciHeader.bcBitCount;

    //
    // figure out the number of entries
    //
    switch (uiBitCount)
    {
    case 1:
        cColorsMax = 2;
        break;
    case 4:
        cColorsMax = 16;
        break;
    case 8:
        cColorsMax = 256;
        break;
    default:

        if (iUsage == DIB_PAL_COLORS)
        {
            iUsage = DIB_RGB_COLORS;
        }

        cColorsMax = 0;

        switch (uiBitCount)
        {
        case 16:
        case 24:
        case 32:
            break;
        default:
            WARNING("pbmiConvertInfo failed invalid bitcount in bmi BI_RGB\n");
            return(0);
        }
    }

    cColors = cColorsMax;

    if (iUsage == DIB_PAL_COLORS)
        cjRGB = sizeof(USHORT);
    else if (iUsage == DIB_PAL_INDICES)
        cjRGB = 0;

    //
    // convert the core header
    //

    ulSize = sizeof(BITMAPINFOHEADER);

    pbmiNew = PALLOCNOZ(ulSize +
                        cjRGB * cColors,'pmtG');

    if (pbmiNew == NULL)
        return (0);

    pbmiNew->bmiHeader.biSize = ulSize;

    //
    // copy BITMAPCOREHEADER
    //
    pbmiNew->bmiHeader.biWidth = ((BITMAPCOREHEADER *)pbmi)->bcWidth;
    pbmiNew->bmiHeader.biHeight = ((BITMAPCOREHEADER *)pbmi)->bcHeight;
    pbmiNew->bmiHeader.biPlanes = ((BITMAPCOREHEADER *)pbmi)->bcPlanes;
    pbmiNew->bmiHeader.biBitCount = ((BITMAPCOREHEADER *)pbmi)->bcBitCount;
    pbmiNew->bmiHeader.biCompression = 0;
    pbmiNew->bmiHeader.biSizeImage = 0;
    pbmiNew->bmiHeader.biXPelsPerMeter = 0;
    pbmiNew->bmiHeader.biYPelsPerMeter = 0;
    pbmiNew->bmiHeader.biClrUsed = 0;
    pbmiNew->bmiHeader.biClrImportant = 0;

    //
    // copy the color table
    //

    pTri = (RGBTRIPLE *)((LPBYTE)pbmi + sizeof(BITMAPCOREHEADER));
    pQuad = (RGBQUAD *)((LPBYTE)pbmiNew + sizeof(BITMAPINFOHEADER));

    //
    // copy RGBTRIPLE to RGBQUAD
    //
    if (iUsage != DIB_PAL_COLORS)
    {
        INT cj = cColors;

        while (cj--)
        {
            pQuad->rgbRed = pTri->rgbtRed;
            pQuad->rgbGreen = pTri->rgbtGreen;
            pQuad->rgbBlue = pTri->rgbtBlue;
            pQuad->rgbReserved = 0;

            pQuad++;
            pTri++;
        }
    }
    else
    // DIB_PAL_COLORS
    {
        RtlCopyMemory((LPBYTE)pQuad,(LPBYTE)pTri,cColors * sizeof(USHORT));
    }

    return(pbmiNew);
}


LPDEVMODEW
CaptureDEVMODEW(
    LPDEVMODEW pdm
    )

/*++

Routine Description:

    Make a kernel-mode copy of a user-mode DEVMODEW structure

Arguments:

    pdm - Pointer to user mode DEVMODEW structure to be copied

Return Value:

    Pointer to kernel mode copy of DEVMODEW structure
    NULL if there is an error

Note:

    This function must be called inside try/except.

--*/

{
    LPDEVMODEW  pdmKm;
    WORD        dmSize, dmDriverExtra;
    ULONG       ulSize;

    ProbeForRead (pdm, offsetof(DEVMODEW, dmFields), sizeof(BYTE));
    dmSize = pdm->dmSize;
    dmDriverExtra = pdm->dmDriverExtra;
    ulSize = dmSize + dmDriverExtra;

    if ((ulSize <= offsetof(DEVMODEW, dmFields)) || BALLOC_OVERFLOW1(ulSize, BYTE))
    {
        WARNING("bad devmodew size\n");
        return NULL;
    }

    if ((pdmKm = PALLOCTHREADMEMNOZ(ulSize, 'pmtG')) != NULL)
    {
        try
        {
            ProbeAndReadBuffer(pdmKm, pdm, ulSize);
            pdmKm->dmSize = dmSize;
            pdmKm->dmDriverExtra = dmDriverExtra;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            VFREETHREADMEM(pdmKm);
            pdmKm = NULL;
        }
    }
    else
    {
        WARNING("Memory allocation failed in CaptureDEVMODEW\n");
    }

    return pdmKm;
}


DRIVER_INFO_2W*
CaptureDriverInfo2W(
    DRIVER_INFO_2W  *pUmDriverInfo2
    )

/*++

Routine Description:

    Make a kernel-mode copy of a user-mode DRIVER_INFO_2W structure

Arguments:

    pUmDriverInfo2 - Pointer to user mode DRIVER_INFO_2W structure

Return Value:

    Pointer to copied kernel mode DRIVER_INFO_2W structure
    NULL if there is an error

Note:

    We're not copying pEnvironment and pConfigFile fields of
    DRIVER_INFO_2W structure.

    This function must be called inside try/except.

--*/

{
    DRIVER_INFO_2W *pKmDriverInfo2;
    ULONG           NameLen, DriverPathLen, DataFileLen, TotalSize;
    PWSTR           pName, pDriverPath, pDataFile;

    ProbeForRead(pUmDriverInfo2, sizeof(DRIVER_INFO_2W), sizeof(BYTE));

    if ((pName = pUmDriverInfo2->pName) == NULL ||
        (pDriverPath = pUmDriverInfo2->pDriverPath) == NULL ||
        (pDataFile = pUmDriverInfo2->pDataFile) == NULL)
    {
        WARNING("Missing driver name or driver path\n");
        return NULL;
    }

    NameLen = wcslensafe(pName);
    DriverPathLen = wcslensafe(pDriverPath);

    TotalSize = sizeof(DRIVER_INFO_2W) +
                (NameLen + 1) * sizeof(WCHAR) +
                (DriverPathLen + 1) * sizeof(WCHAR);

    // pDataFile != NULL
    DataFileLen = wcslensafe(pDataFile);
    TotalSize += (DataFileLen + 1) * sizeof(WCHAR);

    if (BALLOC_OVERFLOW1(TotalSize, BYTE))
        return NULL;

    // Note: allocated memory is zero-initialized.

    pKmDriverInfo2 = (DRIVER_INFO_2W *) PALLOCTHREADMEM(TotalSize, 'pmtG');

    if (pKmDriverInfo2 != NULL)
    {
        __try
        {
            RtlCopyMemory(pKmDriverInfo2, pUmDriverInfo2, sizeof(DRIVER_INFO_2W));

            pKmDriverInfo2->pEnvironment =
            pKmDriverInfo2->pConfigFile = NULL;

            pKmDriverInfo2->pName = (PWSTR) ((PBYTE) pKmDriverInfo2 + sizeof(DRIVER_INFO_2W));
            pKmDriverInfo2->pDriverPath = pKmDriverInfo2->pName + (NameLen + 1);

            ProbeAndReadBuffer(pKmDriverInfo2->pName, pName, NameLen * sizeof(WCHAR));
            ProbeAndReadBuffer(pKmDriverInfo2->pDriverPath, pDriverPath, DriverPathLen * sizeof(WCHAR));

            pKmDriverInfo2->pDataFile = pKmDriverInfo2->pDriverPath + (DriverPathLen + 1);
            ProbeAndReadBuffer(pKmDriverInfo2->pDataFile, pDataFile, DataFileLen * sizeof(WCHAR));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            VFREETHREADMEM(pKmDriverInfo2);
            pKmDriverInfo2 = NULL;
        }
    }
    else
    {
        WARNING("Memory allocation failed in CaptureDriverInfo2W\n");
    }

    return pKmDriverInfo2;
}

__inline VOID
vFreeDriverInfo2(
    DRIVER_INFO_2W  *pKmDriverInfo2
    )

{
     if (pKmDriverInfo2 != NULL)
         VFREETHREADMEM(pKmDriverInfo2);
}

/******************************Public*Routine******************************\
* GreGetBitmapSize
*
* Returns the size of the header and the color table.
*
* History:
*  Wed 19-Aug-1992 -by- Patrick Haluptzok [patrickh]
* add 16 and 32 bit support
*
*  Wed 04-Dec-1991 -by- Patrick Haluptzok [patrickh]
* Make it handle DIB_PAL_INDICES.
*
*  Tue 08-Oct-1991 -by- Patrick Haluptzok [patrickh]
* Make it handle DIB_PAL_COLORS, calculate max colors based on bpp.
*
*  22-Jul-1991 -by- Eric Kutter [erick]
*  14-Apr-1998 FritzS Convert to Gre function for use by ntuser
* Wrote it.
\**************************************************************************/

ULONG GreGetBitmapSize(CONST BITMAPINFO *pbmi, ULONG iUsage)
{
    ULONG cjRet;
    ULONG cjHeader;
    ULONG cjRGB;
    ULONG cColorsMax;
    ULONG cColors;
    UINT  uiBitCount;
    UINT  uiPalUsed;
    UINT  uiCompression;
    UINT  uiHeaderSize;

    // check for error

    if (pbmi == (LPBITMAPINFO) NULL)
    {
        WARNING("GreGetBitmapSize failed - NULL pbmi\n");
        return(0);
    }

    uiHeaderSize = pbmi->bmiHeader.biSize;

    // Check for PM-style DIB

    if (uiHeaderSize == sizeof(BITMAPCOREHEADER))
    {
        cjHeader = sizeof(BITMAPCOREHEADER);
        cjRGB = sizeof(RGBTRIPLE);
        uiBitCount = ((LPBITMAPCOREINFO)pbmi)->bmciHeader.bcBitCount;
        uiPalUsed = 0;
        uiCompression =  (UINT) BI_RGB;
    }
    else if (uiHeaderSize >= sizeof(BITMAPINFOHEADER))
    {
        cjHeader = uiHeaderSize;
        cjRGB    = sizeof(RGBQUAD);
        uiBitCount = pbmi->bmiHeader.biBitCount;
        uiPalUsed = pbmi->bmiHeader.biClrUsed;
        uiCompression = (UINT) pbmi->bmiHeader.biCompression;
    }
    else
    {
        WARNING("cjBitmapHeaderSize failed