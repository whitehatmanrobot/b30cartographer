.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class OleDragDropHandler {
    
        // This is a bit that we stuff into the DoDragDrop
        // to indicate that the thing that is being dragged should only 
        // be allowed to be moved in the current DropTarget (e.g. parent designer).
        // We use this for interited components that can be modified (e.g. location/size) changed
        // but not removed from their parent.
        //
        protected const int AllowLocalMoveOnly = 0x04000000;
         
        private SelectionUIHandler  selectionHandler;
        private IServiceProvider    serviceProvider;
        private IOleDragClient      client;

        private bool                dragOk;
        private bool                forceDrawFrames;
        private bool                localDrag = false;
        private bool                localDragInside = false;
        private Point               localDragOffset = Point.Empty;
        private DragDropEffects     localDragEffect;
        private object[]            dragComps;
        private Point               dragBase = Point.Empty;
        private static bool         freezePainting = false;
        private static bool         verifiedResourceWarning = false;

        private static Hashtable    currentDrags;
        
        public const string CF_CODE =  "CF_XMLCODE";
        public const string CF_COMPONENTTYPES =  "CF_COMPONENTTYPES";

        public OleDragDropHandler(SelectionUIHandler selectionHandler, IServiceProvider serviceProvider, IOleDragClient client) {
            this.serviceProvider = serviceProvider;
            this.selectionHandler = selectionHandler;
            this.client = client;
        }
        
        public static string DataFormat {
            get {
               return CF_CODE;
            }
        }
        
        public static string ExtraInfoFormat {
            get {
               return CF_COMPONENTTYPES;
            }
        }

        private IComponent GetDragOwnerComponent(IDataObject data){
            if (currentDrags == null || !currentDrags.Contains(data)) {
                return null;
            }
            return currentDrags[data] as IComponent;
        }
        private static void AddCurrentDrag(IDataObject data, IComponent component) {
            if (currentDrags == null) {
                currentDrags = new Hashtable();
            }
            currentDrags[data] = component;
        }

        private static void RemoveCurrentDrag(IDataObject data) {
            currentDrags.Remove(data);
        }

        protected virtual bool CanDropDataObject(IDataObject dataObj) {
            if (dataObj != null) {
                if (dataObj is ComponentDataObjectWrapper) {
                    object[] dragObjs = GetDraggingObjects(dataObj, true);
                    if (dragObjs == null) {
                        return false;
                    }
                    bool dropOk = true;
                    for (int i = 0; dropOk && i < dragObjs.Length; i++) {
                        dropOk = dropOk && (dragObjs[i] is IComponent) && client.IsDropOk((IComponent)dragObjs[i]);
                    }
                    return dropOk;
                }
                try {
                    object serializationData = dataObj.GetData(OleDragDropHandler.DataFormat, false);

                    if (serializationData == null) {
                        return false;
                    }

                    IDesignerSerializationService ds = (IDesignerSerializationService)GetService(typeof(IDesignerSerializationService));
                    if (ds == null) {
                        return false;
                    }
                    
                    ICollection objects = ds.Deserialize(serializationData);
                    if (objects.Count > 0) {
                        bool dropOk = true;
                        
                        foreach(object o in objects) {
                            if (!(o is IComponent)) {
                                continue;
                            }
                             dropOk = dropOk && client.IsDropOk((IComponent)o);
                             if (!dropOk) break;
                        }
                        return dropOk;
                    }
                }
                catch (Exception) {
                    // we return false on any exception
                }
            }
            return false;
        }

        public bool Dragging {
            get{
                return localDrag;
            }
        }
        
        public static bool FreezePainting {
            get {
                return freezePainting;
            }
        }
        
        /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.CreateTool"]/*' />
        /// <devdoc>
        ///      This is the worker method of all CreateTool methods.  It is the only one
        ///      that can be overridden.
        /// </devdoc>
        public IComponent[] CreateTool(ToolboxItem tool, int x, int y, int width, int height, bool hasLocation, bool hasSize) {
        
            // Services we will need
            //
            IToolboxService     toolboxSvc = (IToolboxService)GetService(typeof(IToolboxService));
            ISelectionService   selSvc = (ISelectionService)GetService(typeof(ISelectionService));
            IDesignerHost       host = (IDesignerHost)GetService(typeof(IDesignerHost));
            IComponent[]        comps = new IComponent[0];

            Cursor oldCursor = Cursor.Current;
            Cursor.Current = Cursors.WaitCursor;
            DesignerTransaction trans = null;

            try {
                try {
                    if (host != null)
                        trans = host.CreateTransaction(SR.GetString(SR.DesignerBatchCreateTool, tool.ToString()));
                }
                catch(CheckoutException cxe) {
                    if (cxe == CheckoutException.Canceled)
                        return comps;

                    throw cxe;
                }
                
                try {
                    // We need to tell the undo service not ot accept adds here so
                    // the text buffer doesn't add its own undo stuff.
                    //
                    try {
                        comps = tool.CreateComponents(host);
                    }
                    catch (CheckoutException checkoutEx) {
                        if (checkoutEx == CheckoutException.Canceled) {
                            comps = new IComponent[0];
                        }
                        else {
                            throw;
                        }
                    }
                    
                    if (comps == null) {
                        comps = new IComponent[0];
                    }
                }
                finally {
                    if (toolboxSvc != null && tool.Equals(toolboxSvc.GetSelectedToolboxItem(host))) {
                        toolboxSvc.SelectedToolboxItemUsed();
                    }
                }

                // Now walk for each component that was created.
                //
                bool removeComponents = false;
                try {
                    int compCount = comps == null ? 0 : comps.Length;
                    for (int i = 0; i < compCount; i++) {
    
                        try {
                            // Set component defaults
                            if (host != null) {
                                IDesigner designer = host.GetDesigner(comps[i]);
                                if (designer is ComponentDesigner) {
                                    ((ComponentDesigner) designer).OnSetComponentDefaults();
                                }
                            }
                            
                            OnInitializeComponent(comps[i], x, y, width, height, hasLocation, hasSize);
                        }
                        catch {
                            removeComponents = true;
                            throw;
                        }
                    }
                }
                finally {
                    if (removeComponents) {
                        for (int i = 0; i < comps.Length; i++) {
                            host.DestroyComponent(comps[i]);
                        }
                    }
                }
            }
            finally {
                if (trans != null) {
                    trans.Commit();
                }
                Cursor.Current = oldCursor;
            }

            // Finally, select the newly created components.
            //
            if (selSvc != null && comps.Length > 0) {
                if (host != null) {
                    host.Activate();
                }

                ArrayList selectComps = new ArrayList(comps);

                for (int i = 0; i < comps.Length; i++) {
                    if (!TypeDescriptor.GetAttributes(comps[i]).Contains(DesignTimeVisibleAttribute.Yes)) {
                        selectComps.Remove(comps[i]);
                    }
                }
                selSvc.SetSelectedComponents(selectComps.ToArray(), SelectionTypes.Replace);
            }

            if (host != null) {
                IUIService uiService = (IUIService)host.GetService(typeof(IUIService));
                if (uiService != null) {
                    //if we're adding a component to a localized resource,
                    //display our resource warning message... once.
                    VerifyLocalizedResourceWarning(host.RootComponent, uiService);
                }
            }

            return comps;
        }

        /// <devdoc>
        ///      Called when a component is created from CreateTool().
        ///      Here, we check the root control's Language property - if
        ///      we're adding a control to a specific resource other than
        ///      (Default), then we need to notify the user that any 
        ///      localized values of this component will be persisted into
        ///      both: the specific resource file and the base resource file.
        /// </devdoc>
        private void VerifyLocalizedResourceWarning(IComponent rootComponent, IUIService uiService) {
            if (verifiedResourceWarning || rootComponent == null)
                return;

            PropertyDescriptor prop = TypeDescriptor.GetProperties(rootComponent)["Language"];
            
            if (prop != null && prop.PropertyType == typeof(System.Globalization.CultureInfo)) {
                System.Globalization.CultureInfo ci = (System.Globalization.CultureInfo)prop.GetValue(rootComponent);
                if (!ci.Equals(System.Globalization.CultureInfo.InvariantCulture)) {
                    verifiedResourceWarning = true;
                    //display our friendly warning message
                    uiService.ShowMessage(SR.GetString(SR.LocalizedResourceWarning));
                }
            }
        }

        private void DisableDragDropChildren(ICollection controls, ArrayList allowDropCache) {
            foreach(Control c in controls) {
                if (c != null) {
                    if (c.AllowDrop) {
                        allowDropCache.Add(c);
                        c.AllowDrop = false;
                    }

                    if (c.HasChildren) {
                        DisableDragDropChildren(c.Controls, allowDropCache);
                    }
                }
            }
        }

        
        private Point DrawDragFrames(object[] comps,
                                     Point oldOffset, DragDropEffects oldEffect,
                                     Point newOffset, DragDropEffects newEffect,
                                     bool drawAtNewOffset) {
            Control comp;
            Rectangle newRect = Rectangle.Empty;
            Point     tempPt = Point.Empty;
            Control     parentControl = client.GetDesignerControl();
            
            if (comps == null) {
                return Point.Empty;
            }

            for (int i = 0; i < comps.Length; i++) {
                comp = (Control)client.GetControlForComponent(comps[i]);

                Color backColor = SystemColors.Control;
                try {
                    backColor = comp.BackColor;
                }
                catch(Exception) {
                }

                // If we are moving, we must make sure that the location property of the component
                // is not read only.  Otherwise, we can't move the thing.
                //
                bool readOnlyLocation = true;

                PropertyDescriptor loc = TypeDescriptor.GetProperties(comps[i])["Location"];
                if (loc != null) {
                    readOnlyLocation = loc.IsReadOnly;
                }

                // first, undraw the old rect
                if (!oldOffset.IsEmpty) {
                    if ((int)(oldEffect & DragDropEffects.Move) == 0 ||
                        !readOnlyLocation) {
                        newRect = comp.Bounds;

                        if (drawAtNewOffset) {
                            newRect.X = oldOffset.X;
                            newRect.Y = oldOffset.Y;
                        }
                        else {
                            newRect.Offset(oldOffset.X, oldOffset.Y);
                        }
                        newRect = selectionHandler.GetUpdatedRect(comp.Bounds, newRect, false);

                        // convert the rect to screen coords
                        tempPt = parentControl.PointToScreen(new Point(newRect.X, newRect.Y));
                        newRect.X = tempPt.X;
                        newRect.Y = tempPt.Y;

                        //Bug # 71547 <subhag> to make drag rect visible if any the dimensions of the control are 0
                        //
                        
                        if (newRect.Width == 0)
                            newRect.Width = 5;
                        if (newRect.Height == 0)
                            newRect.Height = 5;
                        
                        ControlPaint.DrawReversibleFrame(newRect, backColor, FrameStyle.Thick);
                    }
                }

                if (!newOffset.IsEmpty) {
                    if ((int)(oldEffect & DragDropEffects.Move) == 0 ||
                        !readOnlyLocation) {
                        newRect = comp.Bounds;
                        if (drawAtNewOffset) {
                            newRect.X = newOffset.X;
                            newRect.Y = newOffset.Y;
                        }
                        else {
                            newRect.Offset(newOffset.X, newOffset.Y);
                        }
                        newRect = selectionHandler.GetUpdatedRect(comp.Bounds, newRect, false);

                        // convert the rect to screen coords
                        tempPt = parentControl.PointToScreen(new Point(newRect.X, newRect.Y));
                        newRect.X = tempPt.X;
                        newRect.Y = tempPt.Y;

                        //Bug # 71547 <subhag> to make drag rect visible if any the dimensions of the control are 0
                        //
                        
                        if (newRect.Width == 0)
                            newRect.Width = 5;
                        if (newRect.Height == 0)
                            newRect.Height = 5;
                        
                        ControlPaint.DrawReversibleFrame(newRect, backColor, FrameStyle.Thick);
                    }
                }
            }

            return newOffset;
        }

        public bool DoBeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
            // if we're in a sizing operation, or the mouse isn't down, don't do this!
            if ((rules & SelectionRules.AllSizeable) != SelectionRules.None || Control.MouseButtons == MouseButtons.None) {
                return true;
            }


            Control c = (Control)client.GetDesignerControl();

            localDrag = true;
            localDragInside = false;

            dragComps = components;
            dragBase = new Point(initialX, initialY);
            localDragOffset = Point.Empty;
            Point basePt = c.PointToClient(new Point(initialX,initialY));
            
            DragDropEffects allowedEffects = DragDropEffects.Copy | DragDropEffects.None | DragDropEffects.Move;
            
            // check to see if any of the components are inherhited. if so, don't allow them to be moved.
            // We replace DragDropEffects.Move with a local bit called AllowLocalMoveOnly which means it
            // can be moved around on the current dropsource/target, but not to another target.  Since only
            // we understand this bit, other drop targets will not allow the move to occur
            //
            for (int i = 0; i < components.Length; i++) {
                InheritanceAttribute attr = (InheritanceAttribute)TypeDescriptor.GetAttributes(components[i])[typeof(InheritanceAttribute)];
                
                if (!attr.Equals(InheritanceAttribute.NotInherited) && !attr.Equals(InheritanceAttribute.InheritedReadOnly)) {
                    allowedEffects &= ~DragDropEffects.Move;    
                    allowedEffects |= (DragDropEffects)AllowLocalMoveOnly;
                }
            }
            
            DataObject data = new ComponentDataObjectWrapper(new ComponentDataObject(client, serviceProvider, components, initialX, initialY));

            // We make sure we're painted before we start the drag.  Then, we disable window painting to
            // ensure that the drag can proceed without leaving turds lying around.  We should be caling LockWindowUpdate,
            // but that causes a horrible flashing because GDI+ uses direct draw.
            //
            NativeMethods.MSG msg = new NativeMethods.MSG();
            while (NativeMethods.PeekMessage(ref msg, IntPtr.Zero, NativeMethods.WM_PAINT, NativeMethods.WM_PAINT, NativeMethods.PM_REMOVE)) {
                NativeMethods.TranslateMessage(ref msg);
                NativeMethods.DispatchMessage(ref msg);
            }

            // don't do any new painting...
            bool oldFreezePainting = freezePainting;

            // asurt 90345 -- this causes some subtle bugs, so i'm turning it off to see if we really need it, and if we do
            // if we can find a better way.
            //
            //freezePainting = true;

            AddCurrentDrag(data, client.Component);

            // Walk through all the children recursively and disable drag-drop
            // for each of them. This way, we will not accidentally try to drop
            // ourselves into our own children.
            //
            ArrayList allowDropChanged = new ArrayList();
            foreach(object comp in components) {
                Control ctl = comp as Control;
                if (ctl != null && ctl.HasChildren) {
                    DisableDragDropChildren(ctl.Controls, allowDropChanged);
                }
            }
            
            DragDropEffects effect = DragDropEffects.None;
            IDesignerHost host = GetService(typeof(IDesignerHost)) as IDesignerHost;
            DesignerTransaction trans = null;
            if (host != null) {
                trans = host.CreateTransaction(SR.GetString(SR.DragDropDragComponents, components.Length));
            }
            try {
                effect = c.DoDragDrop(data, allowedEffects);
                if (trans != null) {
                    trans.Commit();
                }
            }
            finally {
                RemoveCurrentDrag(data);
                
                // Reset the AllowDrop for the components being dragged.
                //
                foreach(Control ctl in allowDropChanged) {
                    ctl.AllowDrop = true;
                }
            
                freezePainting = oldFreezePainting;

                if (trans != null) {
                    ((IDisposable)trans).Dispose();
                }
            }
            
            bool isMove = ((int)(effect & DragDropEffects.Move)) != 0 || ((int)((int)effect & AllowLocalMoveOnly)) != 0;
            
            // since the EndDrag will clear this
            bool isLocalMove = isMove && localDragInside;

            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
            Debug.Assert(selectionUISvc != null, "Unable to get selection ui service when adding child control");

            if (selectionUISvc != null) {
                // We must check to ensure that UI service is still in drag mode.  It is
                // possible that the user hit escape, which will cancel drag mode.
                //
                if (selectionUISvc.Dragging) {
                    // cancel the drag if we aren't doing a local move
                    selectionUISvc.EndDrag(!isLocalMove);
                }
                
            }

            if (!localDragOffset.IsEmpty && effect != DragDropEffects.None) {

                DrawDragFrames(dragComps, localDragOffset, localDragEffect,
                               Point.Empty, DragDropEffects.None, false);
            }

            localDragOffset = Point.Empty;
            dragComps = null;
            localDrag = localDragInside = false;
            dragBase = Point.Empty;
            
            /*if (!isLocalMove && isMove){
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                IUndoService  undoService = (IUndoService)GetService(typeof(IUndoService));
                IActionUnit unit = null;

                if (host != null) {
                    DesignerTransaction trans = host.CreateTransaction("Drag/drop");
                    try{
                        // delete the components
                        try{
                            for (int i = 0; i < components.Length; i++){
                               if (components[i] is IComponent){
                                  if (undoService != null){
                                      unit = new CreateControlActionUnit(host, (IComponent)components[i], true);
                                  }
                                  host.DestroyComponent((IComponent)components[i]);
                                  if (undoService != null){
                                       undoService.AddAction(unit, false);
                                  }
                               }
                            }
                        }catch(CheckoutException ex){
                            if (ex != CheckoutException.Canceled){
                                throw ex;
                            }
                        }
                    }
                    finally{
                        trans.Commit();
                    }
                }
            }*/

            return false;
        }

        public void DoEndDrag(object[] components, bool cancel) {
            dragComps = null;
            localDrag = false;
            localDragInside = false;
        }

        public void DoOleDragDrop(DragEventArgs de) {
            // ASURT 43757: By the time we come here, it means that the user completed the drag-drop and
            // we compute the new location/size of the controls if needed and set the property values.
            // We have to stop freezePainting right here, so that controls can get a chance to validate
            // their new rects.
            //
            freezePainting = false;
            
            // make sure we've actually moved
            if ((localDrag && de.X == dragBase.X && de.Y == dragBase.Y) ||
                de.AllowedEffect == DragDropEffects.None ||
                (!localDrag && !dragOk)) {

                de.Effect = DragDropEffects.None;
                return;
            }

            bool localMoveOnly = ((int)((int)de.AllowedEffect & AllowLocalMoveOnly)) != 0 && localDragInside;
            
            // if we are dragging inside the local dropsource/target, and and AllowLocalMoveOnly flag is set,
            // we just consider this a normal move.
            //
            bool moveAllowed = (de.AllowedEffect & DragDropEffects.Move) != DragDropEffects.None || localMoveOnly;
            bool copyAllowed = (de.AllowedEffect & DragDropEffects.Copy) != DragDropEffects.None;

            if ((de.Effect & DragDropEffects.Move) != 0 && !moveAllowed) {
                // Try copy instead?
                de.Effect = DragDropEffects.Copy;
            }

            // make sure the copy is allowed
            if ((de.Effect & DragDropEffects.Copy) != 0 && !copyAllowed) {
                // if copy isn't allowed, don't do anything

                de.Effect = DragDropEffects.None;
                return;
            }
            
            if (localMoveOnly && (de.Effect & DragDropEffects.Move) != 0) {
               de.Effect |= (DragDropEffects)AllowLocalMoveOnly | DragDropEffects.Move;
            }
            else if ((de.Effect & DragDropEffects.Copy) != 0) {
                de.Effect = DragDropEffects.Copy;
            }

            if (forceDrawFrames || localDragInside) {
                // undraw the drag rect
                localDragOffset = DrawDragFrames(dragComps, localDragOffset, localDragEffect,
                                                 Point.Empty, DragDropEffects.None, forceDrawFrames);
                forceDrawFrames = false;
            }

            Cursor oldCursor = Cursor.Current;

            try {
                Cursor.Current = Cursors.WaitCursor;
                
                if (dragOk || (localDragInside && de.Effect == DragDropEffects.Copy)) {
                
                    // add em to this parent.
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    IContainer container = host.RootComponent.Site.Container;
                   
                    object[] components;
                    IDataObject dataObj = de.Data;
                    bool updateLocation = false;
                
                    if (dataObj is ComponentDataObjectWrapper) {
                        dataObj = ((ComponentDataObjectWrapper)dataObj).InnerData;
                        ComponentDataObject cdo = (ComponentDataObject)dataObj;
                
                        // if we're moving ot a different container, do a full serialization
                        // to make sure we pick up design time props, etc.
                        //
                        IComponent dragOwner = GetDragOwnerComponent(de.Data);
                        bool newContainer = dragOwner == null || client.Component == null || dragOwner.Site.Container != client.Component.Site.Container;
                        bool collapseChildren = false;
                        if (de.Effect == DragDropEffects.Copy || newContainer) {
                            // this causes new elements to be created
                            //
                            cdo.Deserialize(serviceProvider, (int)(de.Effect & DragDropEffects.Copy) == 0);
                        }
                        else {
                            collapseChildren = true;
                        }
                        updateLocation = true;
                        components = cdo.Components;

                        if (collapseChildren) {
                            components = GetTopLevelComponents(components);
                        }

                    }
                    else {
                
                        object serializationData = dataObj.GetData(OleDragDropHandler.DataFormat, true);
                
                        if (serializationData == null) {
                            Debug.Fail("data object didn't return any data, so how did we allow the drop?");
                            components = new IComponent[0];
                        }
                        else {
                            dataObj = new ComponentDataObject(client,  serviceProvider, serializationData);
                            components = ((ComponentDataObject)dataObj).Components;
                            updateLocation = true;
                        }
                    }
                
                    // now we need to offset the components locations from the drop mouse
                    // point to the parent, since their current locations are relative
                    // the the mouse pointer
                    if (components != null && components.Length > 0) {
                
                        Debug.Assert(container != null, "Didn't get a container from the site!");
                        string name;
                        IComponent comp = null;
                
                        DesignerTransaction trans = null;
                
                        try {
                            trans = host.CreateTransaction(SR.GetString(SR.DragDropDropComponents));
                            if (!localDrag) {
                                host.Activate();
                            }
                            
                            ArrayList selectComps = new ArrayList();  
                
                
                            for (int i = 0; i < components.Length; i++) {
                                comp = components[i] as IComponent;

                                if (comp == null) {
                                    comp = null;
                                    continue;
                                }
                                
                                try {
                                    name = null;
                                    if (comp.Site != null) {
                                        name = comp.Site.Name;
                                    }
                                    
                                    Control oldDesignerControl = null;
                                    if (updateLocation) {
                                        
                                        oldDesignerControl = client.GetDesignerControl();
                                        NativeMethods.SendMessage(oldDesignerControl.Handle, NativeMethods.WM_SETREDRAW, 0, 0);
                                    }
                
                                    Point dropPt = client.GetDesignerControl().PointToClient(new Point(de.X, de.Y));
                                    Point newLoc = Point.Empty;
                
                                    PropertyDescriptor loc = TypeDescriptor.GetProperties(comp)["Location"];
                
                                    if (loc != null && !loc.IsReadOnly) {
                                        Rectangle bounds = new Rectangle();
                                        Point pt = (Point)loc.GetValue(comp);
                                        bounds.X = dropPt.X + pt.X;
                                        bounds.Y = dropPt.Y + pt.Y;
                                        bounds = selectionHandler.GetUpdatedRect(Rectangle.Empty, bounds, false);
                                        newLoc = new Point(bounds.X, bounds.Y);
                                    }
                
                                    if (!client.AddComponent(comp, name, false)) {
                                        // this means that we just moved the control
                                        // around in the same designer.
                
                                        de.Effect = DragDropEffects.None;
                                    }
                                    else {
                                        // make sure the component was added to this client
                                        if (client.GetControlForComponent(comp) == null) {
                                           updateLocation = false;
                                        }
                                    }
                
                                    if (updateLocation) {
                
                                        ParentControlDesigner parentDesigner = client as ParentControlDesigner;
                                        ((ComponentDataObject)dataObj).ApplyDiffs(dropPt.X, dropPt.Y);
                                        if (parentDesigner != null) {
                                            Control c = client.GetControlForComponent(comp);
                                            dropPt = parentDesigner.GetSnappedPoint(c.Location);
                                            c.Location = dropPt;
                                        }
                                    }
                                    
                                    if (oldDesignerControl != null) {
                                        //((ComponentDataObject)dataObj).ShowControls();
                                        NativeMethods.SendMessage(oldDesignerControl.Handle, NativeMethods.WM_SETREDRAW, 1, 0);
                                        oldDesignerControl.Invalidate(true);
                                    }
                                    
                                    if (TypeDescriptor.GetAttributes(comp).Contains(DesignTimeVisibleAttribute.Yes)) {
                                         selectComps.Add(comp);
                                    }
                                }
                                catch (CheckoutException ceex) {
                                    if (ceex == CheckoutException.Canceled) {
                                        break;
                                    }
                                    throw;
                                }
                            }
                
                            if (host != null) {
                                 host.Activate();
                            }

                            // select the newly added components
                            ISelectionService selService = (ISelectionService)GetService(typeof(ISelectionService));
                            
                            selService.SetSelectedComponents((object[])selectComps.ToArray(typeof(IComponent)), SelectionTypes.Replace);
                            localDragInside = false;
                        }
                        finally {
                            if (trans != null)
                                trans.Commit();
                        }
                    }
                }
                
                
                if (localDragInside) {
                    ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));
                    Debug.Assert(selectionUISvc != null, "Unable to get selection ui service when adding child control");
                
                    if (selectionUISvc != null) {
                        // We must check to ensure that UI service is still in drag mode.  It is
                        // possible that the user hit escape, which will cancel drag mode.
                        //
                        if (selectionUISvc.Dragging && moveAllowed) {
                            Rectangle offset = new Rectangle(de.X - dragBase.X, de.Y - dragBase.Y, 0, 0);
                            selectionUISvc.DragMoved(offset);
                        }
                
                    }
                
                }
                dragOk = false;
            }
            finally {
               Cursor.Current = oldCursor;
            }
        }

        public void DoOleDragEnter(DragEventArgs de) {
            /*
            this causes focus rects to be drawn, which we don't want to happen.
                
            Control dragHost = client.GetDesignerControl();
            
            if (dragHost != null && dragHost.CanSelect) {
                dragHost.Focus();
            }*/
        
            if (!localDrag && CanDropDataObject(de.Data) && de.AllowedEffect != DragDropEffects.None) {
            
                if (!client.CanModifyComponents) {
                    return;
                }
                dragOk = true;
                
                // this means it's not us doing the drag
                if ((int)(de.KeyState & NativeMethods.MK_CONTROL) != 0 && (de.AllowedEffect & DragDropEffects.Copy) != (DragDropEffects)0) {
                    de.Effect = DragDropEffects.Copy;
                }
                else if ((de.AllowedEffect & DragDropEffects.Move) != (DragDropEffects)0) {
                    de.Effect = DragDropEffects.Move;
                }                   
                else {

                    de.Effect = DragDropEffects.None;
                    return;
                }
                
            }
            else if (localDrag && de.AllowedEffect != DragDropEffects.None) {
                localDragInside = true;
                if ((int)(de.KeyState & NativeMethods.MK_CONTROL) != 0 && (de.AllowedEffect & DragDropEffects.Copy) != (DragDropEffects)0 && client.CanModifyComponents) {
                    de.Effect = DragDropEffects.Copy;
                }
                
                bool localMoveOnly = ((int)((int)de.AllowedEffect & AllowLocalMoveOnly)) != 0 && localDragInside;
                
                if (localMoveOnly) {
                    de.Effect |= (DragDropEffects)AllowLocalMoveOnly;
                }
                 
                if ((de.AllowedEffect & DragDropEffects.Move) != (DragDropEffects)0) {
                    de.Effect |= DragDropEffects.Move;
                }
            }
            else {

                de.Effect = DragDropEffects.None;
            }
        }

        public void DoOleDragLeave() {

            if (localDrag || forceDrawFrames) {
                localDragInside = false;
                localDragOffset = DrawDragFrames(dragComps, localDragOffset, localDragEffect,
                                                 Point.Empty, DragDropEffects.None, forceDrawFrames);

                if (forceDrawFrames && dragOk) {
                    dragBase = Point.Empty;
                    dragComps = null;
                }
                forceDrawFrames = false;
            }
            dragOk = false;
        }

        public void DoOleDragOver(DragEventArgs de) {
            Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\tOleDragDropHandler.OnDragOver: " + de.ToString());
            if (!localDrag && !dragOk) {
                de.Effect = DragDropEffects.None;
                return;
            }
            
            bool copy = (int)(de.KeyState & NativeMethods.MK_CONTROL) != 0 && (de.AllowedEffect & DragDropEffects.Copy) != (DragDropEffects)0 && client.CanModifyComponents;
            
            // we pretend AllowLocalMoveOnly is a normal move when we are over the originating container.
            //
            bool localMoveOnly = ((int)((int)de.AllowedEffect & AllowLocalMoveOnly)) != 0 && localDragInside;
            bool move = (de.AllowedEffect & DragDropEffects.Move) != (DragDropEffects)0 || localMoveOnly;
            
            if ((copy || move) && (localDrag || forceDrawFrames)) {
               // draw the shadow rects.
               Point newOffset = Point.Empty;
               Point convertedPoint = client.GetDesignerControl().PointToClient(new Point(de.X, de.Y));
                
               if (forceDrawFrames) {
                  newOffset = convertedPoint;
               }
               else {
                  newOffset = new Point(de.X - dragBase.X, de.Y - dragBase.Y);
               }

               // 96845 -- only allow drops on the client area
               //
               if (!client.GetDesignerControl().ClientRectangle.Contains(convertedPoint)) {
                   copy = false;
                   move = false;
                   newOffset = localDragOffset;
               }
               
               if (newOffset != localDragOffset) {
                  Debug.WriteLineIf(CompModSwitches.DragDrop.TraceInfo, "\tParentControlDesigner.OnDragOver: " + de.ToString());
                  DrawDragFrames(dragComps, localDragOffset, localDragEffect,
                                 newOffset, de.Effect, forceDrawFrames);
                  localDragOffset = newOffset;
                  localDragEffect = de.Effect;
               }
            }

            
			            
            if (copy) {
                de.Effect = DragDropEffects.Copy;
            }
            else if (move) {
                de.Effect = DragDropEffects.Move;
            }
            else {
                de.Effect = DragDropEffects.None;
            }
            
            if (localMoveOnly) {
               de.Effect |= (DragDropEffects)AllowLocalMoveOnly;
            }
        }

        public void DoOleGiveFeedback(GiveFeedbackEventArgs e) {
            e.UseDefaultCursors = ((!localDragInside && !forceDrawFrames) || ((e.Effect & (DragDropEffects.Copy)) != 0)) || e.Effect == DragDropEffects.None;
            if (!e.UseDefaultCursors) {
                selectionHandler.SetCursor();
            }
        }
        
        private object[] GetDraggingObjects(IDataObject dataObj, bool topLevelOnly) {
            object[] components = null;
            
            if (dataObj is ComponentDataObjectWrapper) {
                dataObj = ((ComponentDataObjectWrapper)dataObj).InnerData;
                ComponentDataObject cdo = (ComponentDataObject)dataObj;

                components = cdo.Components;
            }
            
            if (!topLevelOnly || components == null) {
                return components;
            }

            return GetTopLevelComponents(components);
        }

        public object[] GetDraggingObjects(IDataObject dataObj) {
            return GetDraggingObjects(dataObj, false);
        }

        public object[] GetDraggingObjects(DragEventArgs de) {
            return GetDraggingObjects(de.Data);
        }

        private object[] GetTopLevelComponents(ICollection comps) {
            // Filter the top-level components.
            //
            if (!(comps is IList)) {
                comps = new ArrayList(comps);
            }
            IList compList = (IList)comps;
            ArrayList topLevel = new ArrayList();
            foreach(object comp in compList) {
                Control c = comp as Control;
                if (c == null && comp != null) {
                    topLevel.Add(comp);
                }
                else if (c != null){
                    if (c.Parent == null || !compList.Contains(c.Parent)) {
                        topLevel.Add(comp);
                    }
                }
            }

            return topLevel.ToArray();
        }

        protected object GetService(Type t) {
            return serviceProvider.GetService(t);
        }

        protected virtual void OnInitializeComponent(IComponent comp, int x, int y, int width, int height, bool hasLocation, bool hasSize) {
        }
        
        // just so we can recognize the ones we create
        protected class ComponentDataObjectWrapper: System.Windows.Forms.DataObject{
            ComponentDataObject innerData;

            public ComponentDataObjectWrapper(ComponentDataObject dataObject) : base((IDataObject)dataObject){
                innerData = dataObject;
            }

            public ComponentDataObject InnerData{
                get{
                    return innerData;
                }
            }
        }

        protected class ComponentDataObject : System.Windows.Forms.IDataObject {
            private IServiceProvider  serviceProvider;
            private object[]          components;

            private static  Point     DoNotApplyDiff = new Point(Int32.MinValue, Int32.MinValue);
            
            // we need a hashtable here because the components may be
            // recreated in a different order and we'll need to find the
            // right diff for them.
            private Point[]                 componentDiffs;
            private Hashtable               componentDiffTable;
            private Stream                  serializationStream;
            private object                  serializationData;
            private int                     initialX;
            private int                     initialY;
            private IOleDragClient          dragClient;
            private bool                    appliedDiffs;
            
            public ComponentDataObject(IOleDragClient dragClient, IServiceProvider sp, object[] comps, int x, int y) {
                this.serviceProvider = sp;
                this.components = GetComponentList(comps, null, -1);  
                this.initialX = x;
                this.initialY = y;
                this.dragClient = dragClient;
                ComputeDiffs();
            }

            public ComponentDataObject(IOleDragClient dragClient, IServiceProvider sp, object serializationData) {
                this.serviceProvider = sp;
                this.serializationData = serializationData;
                this.dragClient = dragClient;
            }

            public ComponentDataObject(IOleDragClient dragClient, IServiceProvider sp, object serializationData, int initialX, int initialY) : this(dragClient, sp, serializationData) {
                this.initialX = initialX;
                this.initialY = initialY;
            }
            
            private Stream SerializationStream {
                get {
                    if (serializationStream == null && Components != null) {
                        IDesignerSerializationService ds = (IDesignerSerializationService)serviceProvider.GetService(typeof(IDesignerSerializationService));
                        if (ds != null) {
                        
                            // The first object in this array is a point that contains the offset for the controls
                            //
                            object[] comps = new object[components.Length + 1];
                            for (int i = 0; i < components.Length; i++) {
                                Debug.Assert(components[i] is IComponent, "Item " + components[i].GetType().Name + " is not an IComponent");
                                comps[i + 1] = (IComponent)components[i];
                            }

                            // serialize the diff table so we can figure out what reelative positions to
                            // put the components at when we deserialize them (see deserialize)
                            //
                            comps[0] = componentDiffTable;
                            
                            object sd = ds.Serialize(comps);
                            serializationStream = new MemoryStream();
                            BinaryFormatter formatter = new BinaryFormatter();
                            formatter.Serialize(serializationStream, sd);
                            serializationStream.Seek(0, SeekOrigin.Begin);
                        }
                    }
                    return serializationStream;
                }
            }


            public object[] Components{
                get{
                    if (components == null && (serializationStream != null || serializationData != null)) {
                        Deserialize(null, false);
                        if (components == null) {
                            return new object[0];
                        }
                    }
                    return(object[])components.Clone();
                }
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.ApplyDiffs"]/*' />
            /// <devdoc>
            /// Applys new diffs from a drop point to all the
            /// top level controls in a selection.
            /// </devdoc>
            public void ApplyDiffs(int newX, int newY) {


                if (appliedDiffs) {
                    return;
                }

                //Debug.WriteLine("ApplyDiffs newX=" + newX.ToString() + ", newY =" + newY.ToString());
                for (int i = 0; i < components.Length; i++) {
                    
                    Point diff = componentDiffs[i];
                    if (diff != ComponentDataObject.DoNotApplyDiff) {

                        Point pt = new Point(newX - diff.X ,
                                             newY - diff.Y);
        
                        //Debug.WriteLine("Moving " + i.ToString() + " to " + pt.ToString());
                        PropertyDescriptor loc = TypeDescriptor.GetProperties(components[i])["Location"];
        
                        if (loc != null && !loc.IsReadOnly) {
                            loc.SetValue(components[i], pt);
                        }
                    }
                }
                appliedDiffs = true;
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.ComputeDiffs"]/*' />
            /// <devdoc>
            /// Compute the offsets for each top-level control from
            /// the initial point
            /// </devdoc>
            private void ComputeDiffs() {
                //Debug.WriteLine("ComputDiffs x=" + initialX.ToString() + ", initialY =" + initialY.ToString());
                Control topLevelParent = null;
                componentDiffs = new Point[components.Length];
                componentDiffTable = new Hashtable();
                
                for (int i=0; i < components.Length; i++) {
                    if (components[i] is Control) {
                        Control curControl = (Control)components[i];
                        IDesignerHost designerHost = (IDesignerHost)curControl.Site.GetService(typeof(IDesignerHost));

                        if (designerHost.GetDesigner(curControl) is ControlDesigner) {
                            if (topLevelParent == null) {
                                topLevelParent = curControl.Parent;
                            }

                            if (curControl.Parent == topLevelParent) {
                                Point origin = curControl.PointToScreen(new Point(0,0));
                                //Debug.WriteLine("Diff " + i.ToString() + "  is " + origin.ToString());
                                componentDiffs[i] = new Point(initialX - origin.X, initialY - origin.Y);
                                componentDiffTable[curControl.Site.Name] = componentDiffs[i];
                            }
                            else {
                                componentDiffs[i] = ComponentDataObject.DoNotApplyDiff;
                            }
                        }
                    }
                }
            }
            
        
            /// <include file='doc\CommandSet.uex' path='docs/doc[@for="CommandSet.GetCopySelection"]/*' />
            /// <devdoc>
            ///     Used to retrieve the selection for a copy.  The default implementation
            ///     retrieves the current selection.
            /// </devdoc>
            private object[] GetComponentList(object[] components, ArrayList list, int index) {
    
            if (serviceProvider == null) {
                return components;
            }

            ISelectionService selSvc = (ISelectionService)this.serviceProvider.GetService(typeof(ISelectionService));

            if (selSvc == null) {
                return components;
            }

            ICollection selectedComponents;
            if (components == null)
                selectedComponents = selSvc.GetSelectedComponents();
            else
                selectedComponents = new ArrayList(components);


            IDesignerHost host = (IDesignerHost)serviceProvider.GetService(typeof(IDesignerHost));
            if (host != null) {
                ArrayList copySelection = new ArrayList();
                foreach (IComponent comp in selectedComponents) {
                    copySelection.Add(comp);
                    GetAssociatedComponents(comp, host, copySelection);
                }   
                selectedComponents = copySelection;
            }
            object[] comps = new object[selectedComponents.Count];
            selectedComponents.CopyTo(comps, 0);
            return comps;
        }

        private void GetAssociatedComponents(IComponent component, IDesignerHost host, ArrayList list) {
            ComponentDesigner designer = host.GetDesigner(component) as ComponentDesigner;
            if (designer == null) {
                return;
            }

            foreach (IComponent childComp in designer.AssociatedComponents) {
                list.Add(childComp);
                GetAssociatedComponents(childComp, host, list);
            }
        }  
            
            

            public void HideControls() {
                for (int i = 0; i < components.Length; i++) {
                    if (components[i] is Control) {
                        ((Control)components[i]).Visible = false;
                    }
                }
            }

            public bool IsSameContainer(IContainer cont) {
                for (int i = 0; i < components.Length; i++) {
                    if (components[i] is IComponent) {
                        ISite  site = ((IComponent)components[i]).Site;
                        if (site != null) {
                            return cont == site.Container;
                        }
                    }
                }
                return false;
            }

            public virtual object GetData(string format) {
                return GetData(format, false);
            }

            public virtual object GetData(string format, bool autoConvert) {
                if (format.Equals(OleDragDropHandler.DataFormat)) {
                    BinaryFormatter formatter = new BinaryFormatter();
                    SerializationStream.Seek(0, SeekOrigin.Begin);
                    return formatter.Deserialize(this.SerializationStream);
                }
                return null;
            }

            public virtual object GetData(Type t) {
                return GetData(t.FullName);
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.GetDataPresent"]/*' />
            /// <devdoc>
            ///     If the there is data store in the data object associated with
            ///     format this will return true.
            ///
            /// </devdoc>
            public bool GetDataPresent(string format, bool autoConvert){
                return Array.IndexOf(GetFormats(), format) != -1;
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.GetDataPresent1"]/*' />
            /// <devdoc>
            ///     If the there is data store in the data object associated with
            ///     format this will return true.
            ///
            /// </devdoc>
            public bool GetDataPresent(string format){
                return GetDataPresent(format, false);
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.GetDataPresent2"]/*' />
            /// <devdoc>
            ///     If the there is data store in the data object associated with
            ///     format this will return true.
            ///
            /// </devdoc>
            public bool GetDataPresent(Type format){
                return GetDataPresent(format.FullName, false);
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.GetFormats"]/*' />
            /// <devdoc>
            ///     Retrieves a list of all formats stored in this data object.
            ///
            /// </devdoc>
            public string[] GetFormats(bool autoConvert){
                return GetFormats();
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.GetFormats1"]/*' />
            /// <devdoc>
            ///     Retrieves a list of all formats stored in this data object.
            ///
            /// </devdoc>
            public string[] GetFormats(){
                return new string[]{OleDragDropHandler.DataFormat, DataFormats.Serializable, OleDragDropHandler.ExtraInfoFormat};
            }


            public void Deserialize(IServiceProvider serviceProvider, bool removeCurrentComponents) {

                if (serviceProvider == null) {
                    serviceProvider = this.serviceProvider;
                }

                IDesignerSerializationService ds = (IDesignerSerializationService)serviceProvider.GetService(typeof(IDesignerSerializationService));
                IDesignerHost host = null;
                DesignerTransaction trans = null;

                try {
                    if (serializationData == null) {
                        BinaryFormatter formatter = new BinaryFormatter();
                        serializationData = formatter.Deserialize(SerializationStream);
                    }

                    if (removeCurrentComponents && components != null) {
                        foreach (IComponent removeComp in components) {

                            if (host == null && removeComp.Site != null) {
                                host = (IDesignerHost)removeComp.Site.GetService(typeof(IDesignerHost));
                                if (host != null) {
                                    trans = host.CreateTransaction(SR.GetString(SR.DragDropMoveComponents, components.Length));
                                }
                            }
                            if (host != null) {
                                host.DestroyComponent(removeComp);
                            }
                        }
                        components = null;
                    }
                    
                    // The first object in this list is a point that was used to translate the component
                    // positions. Strip this off.
                    //
                    ICollection objects = ds.Deserialize(serializationData);
                    components = new IComponent[objects.Count - 1];
                    appliedDiffs = false;
                    IEnumerator e = objects.GetEnumerator();
                    int idx = 0;

                    e.MoveNext();

                    // if we don't have a diff table, the first object
                    // in the array is the serialized one from before.  Just take that guy and
                    if (componentDiffTable == null) {
                        componentDiffTable = (Hashtable)e.Current;
                    }
                    
                    while(e.MoveNext()) {
                        components[idx++] = (IComponent)e.Current;
                    }
    
                    if (componentDiffs == null || components.Length != componentDiffs.Length) {
                      componentDiffs = new Point[components.Length];
                    }
                    
                    // only do top-level components here,
                    // because other are already parented.
                    // otherwise, when we process these
                    // components it's too hard to know what we
                    // should be reparenting.
                    ArrayList topComps = new ArrayList();
                    for (int i = 0; i < components.Length; i++) {
                    
                        if (components[i] is Control) {
                           Control c = (Control)components[i];
                           if (c.Parent == null) {
                               topComps.Add(components[i]);
                           }
                        }
                        else {
                           topComps.Add(components[i]);
                        }
                    }
                    
                    components = (object[])topComps.ToArray();
                    
                    for (int i = 0; i < components.Length; i++) {
                        // now fix up our diffs table because the components may be reordered now,
                        // and may get renamed later.  What a pain!
                        string compName = ((IComponent)components[i]).Site.Name;
                        if (componentDiffTable != null && componentDiffTable.Contains(compName)) {
                            componentDiffs[i] = (Point)componentDiffTable[compName];
                        }
                    }
                }
                finally {
                    if (trans != null) {
                        trans.Commit();
                    }
                }
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler..SetData"]/*' />
            /// <devdoc>
            ///     Sets the data to be associated with the specific data format. For
            ///     a listing of predefined formats see System.Windows.Forms.DataFormats.
            ///
            /// </devdoc>
            public void SetData(string format, bool autoConvert, object data){
                SetData(format, data);
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.SetData1"]/*' />
            /// <devdoc>
            ///     Sets the data to be associated with the specific data format. For
            ///     a listing of predefined formats see System.Windows.Forms.DataFormats.
            ///
            /// </devdoc>
            public void SetData(string format, object data){
                throw new Exception(SR.GetString(SR.DragDropSetDataError));
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.SetData2"]/*' />
            /// <devdoc>
            ///     Sets the data to be associated with the specific data format.
            ///
            /// </devdoc>
            public void SetData(Type format, object data){
                SetData(format.FullName, data);
            }

            /// <include file='doc\OleDragDropHandler.uex' path='docs/doc[@for="OleDragDropHandler.ComponentDataObject.SetData3"]/*' />
            /// <devdoc>
            ///     Stores data in the data object. The format assumed is the
            ///     class of data
            ///
            /// </devdoc>
            public void SetData(object data){
                SetData(data.GetType(), data);
            }

            public void ShowControls() {
                for (int i = 0; i < components.Length; i++) {
                    if (components[i] is Control) {
                        ((Control)components[i]).Visible = true;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\selectionuiservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionUIService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Drawing.Design;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;
    using System.Windows.Forms;


    /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService"]/*' />
    /// <devdoc>
    ///     The selection manager handles selection within a form.  There is one selection
    ///     manager for each form or top level designer.
    ///
    ///     A selection consists of an array of components.  One component is designated
    ///     the "primary" selection and is displayed with different grab handles.
    ///
    ///     An individual selection may or may not have UI associated with it.  If the
    ///     selection manager can find a suitable designer that is representing the
    ///     selection, it will highlight the designer's border.  If the merged property
    ///     set has a location property, the selection's rules will allow movement.  Also,
    ///     if the property set has a size property, the selection's rules will allow
    ///     for sizing.  Grab handles may be drawn around the designer and user
    ///     interactions involving the selection frame and grab handles are initiated
    ///     here, but the actual movement of the objects is done in a designer object
    ///     that implements the ISelectionHandler interface.
    ///     @author BrianPe
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class SelectionUIService : Control, ISelectionUIService {

        private static readonly Point InvalidPoint = new Point(int.MinValue, int.MinValue);

        private const int HITTEST_CONTAINER_SELECTOR = 0x0001;
        private const int HITTEST_NORMAL_SELECTION = 0x0002;
        private const int HITTEST_DEFAULT = HITTEST_CONTAINER_SELECTOR | HITTEST_NORMAL_SELECTION;

        // These are used during a drag operation, either through our own handle drag or through
        // ISelectionUIService
        //
        private ISelectionUIHandler     dragHandler;              // the current drag handler
        private object []               dragComponents;           // the controls being dragged
        private SelectionRules          dragRules;                // movement constraints for the drag
        private bool                    dragMoved                 = false;
        private object                  containerDrag;            // object being dragged during a container drag

        // These are used during a drag of a selection grab handle
        //
        private bool                    ignoreCaptureChanged      = false;
        private bool                    mouseDown;                // is our mouse button actually down right now?
        private int                     mouseDragHitTest;         // where the hit occurred that caused the drag
        private Point                   mouseDragAnchor           = InvalidPoint;          // anchor point of the drag
        private Rectangle               mouseDragOffset           = Rectangle.Empty;       // current drag offset
        private Point                   lastMoveScreenCoord       = Point.Empty;
        private bool                    ctrlSelect                = false; // was the CTRL key down when the drag began
        private bool                    mouseDragging             = false; // Are we actually doing a drag?

        private ContainerSelectorActiveEventHandler  containerSelectorActive;  // the event we fire when user interacts with container selector
        private Hashtable                            selectionItems;
        private Hashtable                            selectionHandlers;        // Component UI handlers

        private bool                    savedVisible;    // we stash this when we mess with visibility ourselves.
        private bool                    batchMode;
        private bool                    batchChanged;
        private bool                    batchSync;
        private ISelectionService       selSvc;
        private IDesignerHost           host;

        private DesignerTransaction     dragTransaction;

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIService"]/*' />
        /// <devdoc>
        ///     Creates a new selection manager object.  The selection manager manages all
        ///     selection of all designers under the current form file.
        /// </devdoc>
        public SelectionUIService(IDesignerHost host)
        : base() {

            this.SetStyle(ControlStyles.StandardClick
                          | ControlStyles.Opaque
                          | ControlStyles.DoubleBuffer, true);
            this.host = host;
            this.dragHandler = null;
            this.dragComponents = null;
            this.selectionItems = new Hashtable();
            this.selectionHandlers = new Hashtable();
            this.AllowDrop = true;

            // Not really any reason for this, except that it can be handy when
            // using Spy++
            //
            Text = "SelectionUIOverlay";

            this.selSvc = (ISelectionService)host.GetService(typeof(ISelectionService));
            if (selSvc != null) {
                selSvc.SelectionChanged += new EventHandler(this.OnSelectionChanged);
            }

            // And configure the events we want to listen to.
            //
            host.TransactionOpened += new EventHandler(this.OnTransactionOpened);
            host.TransactionClosed += new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
            if (host.InTransaction) {
                OnTransactionOpened(host, EventArgs.Empty);
            }

            IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentRemove);
                cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }

            // Listen to the SystemEvents so that we can resync selection based on display settings etc.
            SystemEvents.DisplaySettingsChanged += new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.InstalledFontsChanged += new EventHandler(this.OnSystemSettingChanged);
            SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.CreateParams"]/*' />
        /// <devdoc>
        ///     override of control.
        /// </devdoc>
        protected override CreateParams CreateParams {
            get {
                CreateParams cp = base.CreateParams;
                cp.Style &= ~(NativeMethods.WS_CLIPSIBLINGS | NativeMethods.WS_CLIPCHILDREN);
                return cp;
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.BeginMouseDrag"]/*' />
        /// <devdoc>
        ///     Called to initiate a mouse drag on the selection overlay.  We cache some
        ///     state here.
        /// </devdoc>
        private void BeginMouseDrag(Point anchor, int hitTest) {
            Capture = true;
            ignoreCaptureChanged = false;
            mouseDragAnchor = anchor;
            mouseDragging = true;
            mouseDragHitTest = hitTest;
            mouseDragOffset = new Rectangle();
            savedVisible = Visible;
        }

        /// <include file='doc\ControlDesigner.uex' path='docs/doc[@for="ControlDesigner.DisplayError"]/*' />
        /// <devdoc>
        ///      Displays the given exception to the user.
        /// </devdoc>
        private void DisplayError(Exception e) {
            IUIService uis = (IUIService)host.GetService(typeof(IUIService));
            if (uis != null) {
                uis.ShowError(e);
            }
            else {
                string message = e.Message;
                if (message == null || message.Length == 0) {
                    message = e.ToString();
                }
                MessageBox.Show(message, null, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes the entire selection UI manager.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (selSvc != null) {
                    selSvc.SelectionChanged -= new EventHandler(this.OnSelectionChanged);
                }
                
                if (host != null) {
                    host.TransactionOpened -= new EventHandler(this.OnTransactionOpened);
                    host.TransactionClosed -= new DesignerTransactionCloseEventHandler(this.OnTransactionClosed);
                    if (host.InTransaction) {
                        OnTransactionClosed(host, new DesignerTransactionCloseEventArgs(true));
                    }

                    IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
                    if (cs != null) {
                        cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentRemove);
                        cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                    }
                }

                foreach(SelectionUIItem s in selectionItems.Values) {
                    s.Dispose();
                }

                selectionHandlers.Clear();
                selectionItems.Clear();


                // Listen to the SystemEvents so that we can resync selection based on display settings etc.
                SystemEvents.DisplaySettingsChanged -= new EventHandler(this.OnSystemSettingChanged);
                SystemEvents.InstalledFontsChanged -= new EventHandler(this.OnSystemSettingChanged);
                SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnUserPreferenceChanged);
            }
            base.Dispose(disposing);

        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.EndMouseDrag"]/*' />
        /// <devdoc>
        ///     Called when we want to finish a mouse drag and clean up our variables.  We call this
        ///     from multiple places, depending on the state of the finish.  This does NOT end
        ///     the drag -- for that must call EndDrag. This just cleans up the state of the
        ///     mouse.
        /// </devdoc>
        private void EndMouseDrag(Point position) {
        
            // it's possible for us to be destroyed in a drag --
            // e.g. if this is the tray's selectionuiservice
            // and the last item is dragged out, so
            // check diposed first
            
            if (this.IsDisposed) {
                return;
            }
            
            ignoreCaptureChanged = true;
            Capture = false;
            mouseDragAnchor = InvalidPoint;
            mouseDragOffset = Rectangle.Empty;
            mouseDragHitTest = 0;
            dragMoved = false;
            SetSelectionCursor(position);
            mouseDragging = ctrlSelect = false;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.GetHitTest"]/*' />
        /// <devdoc>
        ///     Determines the selection hit test at the given point.  The point should be in screen
        ///     coordinates.
        /// </devdoc>
        private HitTestInfo GetHitTest(Point value, int flags) {
            Point pt = PointToClient(value);
            
            foreach(SelectionUIItem item in selectionItems.Values) {
                
                if ((flags & HITTEST_CONTAINER_SELECTOR) != 0) {
                    if (item is ContainerSelectionUIItem && (item.GetRules() & SelectionRules.Visible) != SelectionRules.None) {
                        int hitTest = item.GetHitTest(pt);
                        if ((hitTest & SelectionUIItem.CONTAINER_SELECTOR) != 0) {
                            return new HitTestInfo(hitTest, item, true);
                        }
                    }
                }
                
                if ((flags & HITTEST_NORMAL_SELECTION) != 0) {
                    if (!(item is ContainerSelectionUIItem) && (item.GetRules() & SelectionRules.Visible) != SelectionRules.None) {
                        int hitTest = item.GetHitTest(pt);
                        if (hitTest != SelectionUIItem.NOHIT) {
                            if (hitTest != 0) {
                                return new HitTestInfo(hitTest, item);
                            }
                            else {
                                return new HitTestInfo(SelectionUIItem.NOHIT, item);
                            }
                        }
                    }
                }
            }

            return new HitTestInfo(SelectionUIItem.NOHIT, null);
        }
        
        private ISelectionUIHandler GetHandler(object component) {
            return (ISelectionUIHandler)selectionHandlers[component];
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.GetTransactionName"]/*' />
        /// <devdoc>
        ///     This method returns a well-formed name for a drag transaction based on
        ///     the rules it is given.
        /// </devdoc>
        public static string GetTransactionName(SelectionRules rules, object[] objects) {
            
            // Determine a nice name for the drag operation
            //
            string transactionName;
            if ((int)(rules & SelectionRules.Moveable) != 0) {
                if (objects.Length > 1) {
                    transactionName = SR.GetString(SR.DragDropMoveComponents, objects.Length);
                }
                else {
                    string name = string.Empty;
                    if (objects.Length > 0) {
                        IComponent comp = objects[0] as IComponent;
                        if (comp != null && comp.Site != null) {
                            name = comp.Site.Name;
                        }
                        else {
                            name = objects[0].GetType().Name;
                        }
                    }
                    transactionName = SR.GetString(SR.DragDropMoveComponent, name);
                }
            }
            else if ((int)(rules & SelectionRules.AllSizeable) != 0) {
                if (objects.Length > 1) {
                    transactionName = SR.GetString(SR.DragDropSizeComponents, objects.Length);
                }
                else {
                    string name = string.Empty;
                    if (objects.Length > 0) {
                        IComponent comp = objects[0] as IComponent;
                        if (comp != null && comp.Site != null) {
                            name = comp.Site.Name;
                        }
                        else {
                            name = objects[0].GetType().Name;
                        }
                    }
                    transactionName = SR.GetString(SR.DragDropSizeComponent, name);
                }
            }
            else {
                transactionName = SR.GetString(SR.DragDropDragComponents, objects.Length);
            }
            
            return transactionName;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnTransactionClosed"]/*' />
        /// <devdoc>
        ///     Called by the designer host when it is entering or leaving a batch
        ///     operation.  Here we queue up selection notification and we turn off
        ///     our UI.
        /// </devdoc>
        private void OnTransactionClosed(object sender, DesignerTransactionCloseEventArgs e) {
            batchMode = false;
            if (batchChanged) {
                batchChanged = false;
                ((ISelectionUIService)this).SyncSelection();
            }
            if (batchSync) {
                batchSync = false;
                ((ISelectionUIService)this).SyncComponent(null);
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnTransactionOpened"]/*' />
        /// <devdoc>
        ///     Called by the designer host when it is entering or leaving a batch
        ///     operation.  Here we queue up selection notification and we turn off
        ///     our UI.
        /// </devdoc>
        private void OnTransactionOpened(object sender, EventArgs e) {
            batchMode = true;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnHandleCreated"]/*' />
        /// <devdoc>
        ///     update our window region on first create.  We shouldn't do this before the handle
        ///     is created or else we will force creation.
        /// </devdoc>
        protected override void OnHandleCreated(EventArgs e) {
            Debug.Assert(!RecreatingHandle, "Perf hit: we are recreating the docwin handle");

            base.OnHandleCreated(e);

            // Default the shape of the control to be empty, so that
            // if nothing is initially selected that our window surface doesn't
            // interfere.
            //
            UpdateWindowRegion();
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnComponentChanged"]/*' />
        /// <devdoc>
        ///     Called whenever a component changes.  Here we update our selection information
        ///     so that the selection rectangles are all up to date.
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs ccevent) {
            if (!batchMode) {
                ((ISelectionUIService)this).SyncSelection();
            }
            else {
                batchChanged = true;
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnComponentRemove"]/*' />
        /// <devdoc>
        ///     called by the formcore when someone has removed a component.  This will
        ///     remove any selection on the component without disturbing the rest of
        ///     the selection
        /// </devdoc>
        private void OnComponentRemove(object sender, ComponentEventArgs ce) {
            selectionHandlers.Remove(ce.Component);
            selectionItems.Remove(ce.Component);
            ((ISelectionUIService)this).SyncComponent(ce.Component);
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnContainerSelectorActive"]/*' />
        /// <devdoc>
        ///     Called to invoke the container active event, if a designer
        ///     has bound to it.
        /// </devdoc>
        private void OnContainerSelectorActive(ContainerSelectorActiveEventArgs e) {
            if (containerSelectorActive != null) {
                containerSelectorActive(this, e);
            }
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///     Called when the selection changes.  We sync up the UI with
        ///     the selection at this point.
        /// </devdoc>
        private void OnSelectionChanged(object sender, EventArgs e) {
            ICollection selection = selSvc.GetSelectedComponents();
            Hashtable newSelection = new Hashtable(selection.Count);
            bool shapeChanged = false;
            
            foreach(object comp in selection ) {
                object existingItem = selectionItems[comp];
                bool create = true;
                
                if (existingItem != null) {
                    if (existingItem is ContainerSelectionUIItem) {
                        ((ContainerSelectionUIItem)existingItem).Dispose();
                        shapeChanged = true;
                    }
                    else {
                        newSelection[comp] = existingItem;
                        create = false;
                    }
                }
                
                if (create) {
                    shapeChanged = true;
                    newSelection[comp] = new SelectionUIItem(this, comp);
                }
            }
            
            if (!shapeChanged) {
                shapeChanged = selectionItems.Keys.Count != newSelection.Keys.Count;
            }
            
            selectionItems = newSelection;
            
            if (shapeChanged) {
                UpdateWindowRegion();
            }
        
            Invalidate();
            Update();
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnSystemSettingChanged"]/*' />
        /// <devdoc>
        ///     User setting requires that we repaint.
        /// </devdoc>
        private void OnSystemSettingChanged(object sender, EventArgs e) {
            Invalidate();
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnUserPreferenceChanged"]/*' />
        /// <devdoc>
        ///     User setting requires that we repaint.
        /// </devdoc>
        private void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {
            Invalidate();
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnDragEnter"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call super.onDragEnter to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnDragEnter(DragEventArgs devent) {
            base.OnDragEnter(devent);
            if (dragHandler != null) {
                dragHandler.OleDragEnter(devent);
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnDragOver"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call super.onDragOver to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnDragOver(DragEventArgs devent) {
            base.OnDragOver(devent);
            if (dragHandler != null) {
                dragHandler.OleDragOver(devent);
            }
        }
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnDragLeave"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call super.onDragLeave to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnDragLeave(EventArgs e) {
            base.OnDragLeave(e);
            if (dragHandler != null) {
                dragHandler.OleDragLeave();
            }
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnDragDrop"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call super.onDragDrop to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnDragDrop(DragEventArgs devent) {
            base.OnDragDrop(devent);
            if (dragHandler != null) {
                dragHandler.OleDragDrop(devent);
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnDoubleClick"]/*' />
        /// <devdoc>
        ///     Inheriting classes should override this method to handle this event.
        ///     Call base.OnDoiubleClick to send this event to any registered event listeners.
        /// </devdoc>
        protected override void OnDoubleClick(EventArgs devent) {
            base.OnDoubleClick(devent);
            if (selSvc != null) {
                object selComp = selSvc.PrimarySelection;
                Debug.Assert(selComp != null, "Illegal selection on double-click");
                if (selComp != null) {
                    ISelectionUIHandler handler = GetHandler(selComp);
                    if (handler != null) {
                        handler.OnSelectionDoubleClick((IComponent)selComp);
                    }
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnMouseDown"]/*' />
        /// <devdoc>
        ///     Overrides Control to handle our selection grab handles.
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs me) {
            if (dragHandler == null && selSvc != null) {
            
                try {
                    mouseDown = true;
                
                    // First, did the user step on anything?
                    //
                    Point anchor = PointToScreen(new Point(me.X, me.Y));
                    HitTestInfo hti = GetHitTest(anchor, HITTEST_DEFAULT);
                    int hitTest = hti.hitTest;
    
                    if ((hitTest & SelectionUIItem.CONTAINER_SELECTOR) != 0) {
                        selSvc.SetSelectedComponents(new object[] {hti.selectionUIHit.component}, SelectionTypes.Normal | SelectionTypes.MouseDown);
    
                        // Then do a drag...
                        //
                        SelectionRules rules = SelectionRules.Moveable;
    
                        if (((ISelectionUIService)this).BeginDrag(rules, anchor.X, anchor.Y)) {
                            Visible = false;
                            containerDrag = hti.selectionUIHit.component;
                            BeginMouseDrag(anchor, hitTest);
                        }
                    }
                    else if (hitTest != SelectionUIItem.NOHIT && me.Button == MouseButtons.Left) {
                        SelectionRules rules = SelectionRules.None;
    
    
                        // If the CTRL key isn't down, select this component,
                        // otherwise, we wait until the mouse up
                        //
                        // Make sure the component is selected
                        //
    
                        ctrlSelect = (Control.ModifierKeys & Keys.Control) != Keys.None;
    
                        if (!ctrlSelect) {
                            SelectionTypes type = SelectionTypes.Click;
                            if (!selSvc.GetComponentSelected(hti.selectionUIHit.component)) {
                                type |= SelectionTypes.MouseDown;
                            }
                            selSvc.SetSelectedComponents(new object[] {hti.selectionUIHit.component}, type);
                        }
    
                        if ((hitTest & SelectionUIItem.MOVE_MASK) != 0) {
                            rules |= SelectionRules.Moveable;
                        }
                        if ((hitTest & SelectionUIItem.SIZE_MASK) != 0) {
                            if ((hitTest & (SelectionUIItem.SIZE_X | SelectionUIItem.POS_RIGHT)) == (SelectionUIItem.SIZE_X | SelectionUIItem.POS_RIGHT)) {
                                rules |= SelectionRules.RightSizeable;
                            }
                            if ((hitTest & (SelectionUIItem.SIZE_X | SelectionUIItem.POS_LEFT)) == (SelectionUIItem.SIZE_X | SelectionUIItem.POS_LEFT)) {
                                rules |= SelectionRules.LeftSizeable;
                            }
                            if ((hitTest & (SelectionUIItem.SIZE_Y | SelectionUIItem.POS_TOP)) == (SelectionUIItem.SIZE_Y | SelectionUIItem.POS_TOP)) {
                                rules |= SelectionRules.TopSizeable;
                            }
                            if ((hitTest & (SelectionUIItem.SIZE_Y | SelectionUIItem.POS_BOTTOM)) == (SelectionUIItem.SIZE_Y | SelectionUIItem.POS_BOTTOM)) {
                                rules |= SelectionRules.BottomSizeable;
                            }
    
                            if (((ISelectionUIService)this).BeginDrag(rules, anchor.X, anchor.Y)) {
                                BeginMouseDrag(anchor, hitTest);
                            }
                        }
                        else {
                            // Our mouse is in drag mode.  We defer the actual move until the user moves the
                            // mouse.
                            //
                            dragRules = rules;
                            BeginMouseDrag(anchor, hitTest);
                        }
                    }
                    else if (hitTest == SelectionUIItem.NOHIT) {
                        dragRules = SelectionRules.None;
                        mouseDragAnchor = InvalidPoint;
                        return;
                    }
                }
                catch(Exception e) {
                    if (e != CheckoutException.Canceled) {
                        DisplayError(e);
                    }
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnMouseMove"]/*' />
        /// <devdoc>
        ///     Overrides Control to handle our selection grab handles.
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs me) {
            base.OnMouseMove(me);

            Point screenCoord = PointToScreen(new Point(me.X, me.Y));

            HitTestInfo hti = GetHitTest(screenCoord, HITTEST_CONTAINER_SELECTOR);
            int         hitTest = hti.hitTest;
            if (hitTest != SelectionUIItem.CONTAINER_SELECTOR && hti.selectionUIHit != null) {
                OnContainerSelectorActive(new ContainerSelectorActiveEventArgs(hti.selectionUIHit.component));
            }

            if (lastMoveScreenCoord == screenCoord) {
                return;
            }

            // If we're not dragging then set the cursor correctly.
            //
            if (!mouseDragging) {
                SetSelectionCursor(screenCoord);
            }
            else {

                // we have to make sure the mouse moved farther than
                // the minimum drag distance before we actually start
                // the drag
                //
                if (!((ISelectionUIService)this).Dragging && (mouseDragHitTest & SelectionUIItem.MOVE_MASK) != 0) {
                    Size minDragSize = SystemInformation.DragSize;

                    if (
                       Math.Abs(screenCoord.X - mouseDragAnchor.X) < minDragSize.Width &&
                       Math.Abs(screenCoord.Y - mouseDragAnchor.Y) < minDragSize.Height) {
                        return;
                    }
                    else {
                        ignoreCaptureChanged = true;
                        if (((ISelectionUIService)this).BeginDrag(dragRules, mouseDragAnchor.X, mouseDragAnchor.Y)) {
                            // we're moving, so we
                            // don't care about the ctrl key any more
                            ctrlSelect = false;
                        }
                        else {
                            EndMouseDrag(MousePosition);
                            return;
                        }
                    }
                }

                Rectangle old = mouseDragOffset;

                if ((mouseDragHitTest & SelectionUIItem.MOVE_X) != 0) {
                    mouseDragOffset.X = screenCoord.X - mouseDragAnchor.X;
                }
                if ((mouseDragHitTest & SelectionUIItem.MOVE_Y) != 0) {
                    mouseDragOffset.Y = screenCoord.Y - mouseDragAnchor.Y;
                }
                if ((mouseDragHitTest & SelectionUIItem.SIZE_X) != 0) {
                    if ((mouseDragHitTest & SelectionUIItem.POS_LEFT) != 0) {
                        mouseDragOffset.X = screenCoord.X - mouseDragAnchor.X;
                        mouseDragOffset.Width = mouseDragAnchor.X - screenCoord.X;
                    }
                    else {
                        mouseDragOffset.Width = screenCoord.X - mouseDragAnchor.X;
                    }
                }
                if ((mouseDragHitTest & SelectionUIItem.SIZE_Y) != 0) {
                    if ((mouseDragHitTest & SelectionUIItem.POS_TOP) != 0) {
                        mouseDragOffset.Y = screenCoord.Y - mouseDragAnchor.Y;
                        mouseDragOffset.Height = mouseDragAnchor.Y - screenCoord.Y;
                    }
                    else {
                        mouseDragOffset.Height = screenCoord.Y - mouseDragAnchor.Y;
                    }
                }

                if (!old.Equals(mouseDragOffset)) {

                    Rectangle delta = mouseDragOffset;
                    delta.X -= old.X;
                    delta.Y -= old.Y;
                    delta.Width -= old.Width;
                    delta.Height -= old.Height;

                    if (delta.X != 0 || delta.Y != 0 || delta.Width != 0 || delta.Height != 0) {

                        // Go to default cursor for moves...
                        //
                        if ((mouseDragHitTest & SelectionUIItem.MOVE_X) != 0
                            || (mouseDragHitTest & SelectionUIItem.MOVE_Y) != 0) {

                            Cursor = Cursors.Default;
                        }
                        ((ISelectionUIService)this).DragMoved(delta);
                    }
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnMouseUp"]/*' />
        /// <devdoc>
        ///     Overrides Control to handle our selection grab handles.
        /// </devdoc>
        protected override void OnMouseUp(MouseEventArgs me) {

            try {
                bool wasDown = mouseDown;
                mouseDown = false;
                Point screenCoord = PointToScreen(new Point(me.X, me.Y));
                
                if (ctrlSelect && !mouseDragging && selSvc != null) {
                    HitTestInfo hti = GetHitTest(screenCoord, HITTEST_DEFAULT);
                    SelectionTypes type = SelectionTypes.Click;
                    if (!selSvc.GetComponentSelected(hti.selectionUIHit.component)) {
                        type |= SelectionTypes.MouseDown;
                    }
                    selSvc.SetSelectedComponents(new object[] {hti.selectionUIHit.component}, type);
                }
    
    
                if (mouseDragging) {
                    object oldContainerDrag = containerDrag;
                    bool oldDragMoved = dragMoved;
                    EndMouseDrag(screenCoord);
    
                    if (((ISelectionUIService)this).Dragging) {
                        ((ISelectionUIService)this).EndDrag(false);
                    }
    
                    if (me.Button == MouseButtons.Right && oldContainerDrag != null && !oldDragMoved) {
                        OnContainerSelectorActive(new ContainerSelectorActiveEventArgs(oldContainerDrag,
                                                                                       ContainerSelectorActiveEventArgsType.Contextmenu));
                    }
                }
            }
            catch(Exception e) {
                if (e != CheckoutException.Canceled) {
                    DisplayError(e);
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnMove"]/*' />
        /// <devdoc>
        ///     If the selection manager move, this indicates that the form has autoscolling
        ///     enabled and has been scrolled.  We have to invalidate here because we may
        ///     get moved before the rest of the components so we may draw the selection in
        ///     the wrong spot.
        /// </devdoc>
        protected override void OnMove(EventArgs e) {
            base.OnMove(e);
            Invalidate();
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.OnPaint"]/*' />
        /// <devdoc>
        ///     overrides control.onPaint.  here we paint the selection handles.  The window's
        ///     region was setup earlier.
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs e) {

            // Paint the regular selection items first, and then the
            // container selectors last so they draw over the
            // top.
            //
            foreach(SelectionUIItem item in selectionItems.Values) {
                if (item is ContainerSelectionUIItem) {
                    continue;
                }
                item.DoPaint(e.Graphics);
            }

            foreach(SelectionUIItem item in selectionItems.Values) {
                if (item is ContainerSelectionUIItem) {
                    item.DoPaint(e.Graphics);
                }
            }
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SetSelectionCursor"]/*' />
        /// <devdoc>
        ///     Sets the appropriate selection cursor at the given point.
        /// </devdoc>
        private void SetSelectionCursor(Point pt) {
            Point clientCoords = PointToClient(pt);
            
            // We render the cursor in the same order we paint.
            //
            foreach(SelectionUIItem item in selectionItems.Values) {
                if (item is ContainerSelectionUIItem) {
                    continue;
                }
                Cursor cursor = item.GetCursorAtPoint(clientCoords);
                if (cursor != null) {
                    if (cursor == Cursors.Default) {
                        Cursor = null;
                    }
                    else {
                        Cursor = cursor;
                    }
                    return;
                }
            }

            foreach(SelectionUIItem item in selectionItems.Values) {
                if (item is ContainerSelectionUIItem) {
                    Cursor cursor = item.GetCursorAtPoint(clientCoords);
                    if (cursor != null) {
                        if (cursor == Cursors.Default) {
                            Cursor = null;
                        }
                        else {
                            Cursor = cursor;
                        }
                        return;
                    }
                }
            }

            // Don't know what to set; just use the default.
            //
            Cursor = null;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.UpdateWindowRegion"]/*' />
        /// <devdoc>
        ///     called when the overlay region is invalid and should be updated
        /// </devdoc>
        private void UpdateWindowRegion() {

            Region region = new Region(new Rectangle(0, 0, 0, 0));

            foreach(SelectionUIItem item in selectionItems.Values) {
                region.Union(item.GetRegion());
            }

            Region = region;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.WndProc"]/*' />
        /// <devdoc>
        ///     Override of our control's WNDPROC.  We diddle with capture a bit,
        ///     and it's important to turn this off if the capture changes.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_LBUTTONUP:
                case NativeMethods.WM_RBUTTONUP:
                    if (mouseDragAnchor != InvalidPoint) {
                        ignoreCaptureChanged = true;
                    }
                    break;

                case NativeMethods.WM_CAPTURECHANGED:
                    if (!ignoreCaptureChanged && mouseDragAnchor != InvalidPoint) {
                        EndMouseDrag(MousePosition);
                        if (((ISelectionUIService)this).Dragging) {
                            ((ISelectionUIService)this).EndDrag(true);
                        }
                    }
                    ignoreCaptureChanged = false;
                    break;
            }

            base.WndProc(ref m);
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.Dragging"]/*' />
        /// <devdoc>
        ///     This can be used to determine if the user is in the middle of a drag operation.
        /// </devdoc>
        bool ISelectionUIService.Dragging {
            get {
                return dragHandler != null;
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.Visible"]/*' />
        /// <devdoc>
        ///     Determines if the selection UI is shown or not.
        ///
        /// </devdoc>
        bool ISelectionUIService.Visible {
            get {
                return Visible;
            }
            set {
                Visible = value;
            }
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.ContainerSelectorActive"]/*' />
        /// <devdoc>
        ///     Adds an event handler to the ContainerSelectorActive event.
        ///     This event is fired whenever the user interacts with the container
        ///     selector in a manor that would indicate that the selector should
        ///     continued to be displayed. Since the container selector normally
        ///     will vanish after a timeout, designers should listen to this event
        ///     and reset the timeout when this event occurs.
        /// </devdoc>
        event ContainerSelectorActiveEventHandler ISelectionUIService.ContainerSelectorActive {
            add {
                containerSelectorActive += value;
            }
            remove {
                containerSelectorActive -= value;
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.AssignSelectionUIHandler"]/*' />
        /// <devdoc>
        ///     Assigns a selection UI handler to a given component.  The handler will be
        ///     called when the UI service needs information about the component.  A single
        ///     selection UI handler can be assigned to multiple components.
        ///
        ///     When multiple components are dragged, only a single handler may control the
        ///     drag.  Because of this, only components that are assigned the same handler
        ///     as the primary selection are included in drag operations.
        ///
        ///     A selection UI handler is automatically unassigned when the component is removed
        ///     from the container or disposed.
        /// </devdoc>
        void ISelectionUIService.AssignSelectionUIHandler(object component, ISelectionUIHandler handler) {

            ISelectionUIHandler oldHandler = (ISelectionUIHandler)selectionHandlers[component];
            if (oldHandler != null) {
                
                // ASURT #44582: The collection editors do not dispose objects from the
                // collection before setting a new collection. This causes items that are
                // common to the old and new collections to come through this code path 
                // again, causing the exception to fire. So, we check to see if the SelectionUIHandler
                // is same, and bail out in that case.
                //
                if (handler == oldHandler) {
                    return;
                }

                Debug.Fail("A component may have only one selection UI handler.");
                throw new InvalidOperationException();
            }
            
            selectionHandlers[component] = handler;
            
            // If this component is selected, create a new UI handler for it.
            //
            if (selSvc != null && selSvc.GetComponentSelected(component)) {
                SelectionUIItem item = new SelectionUIItem(this, component);
                selectionItems[component] = item;
                UpdateWindowRegion();
                item.Invalidate();
            }
        }
        
        void ISelectionUIService.ClearSelectionUIHandler(object component, ISelectionUIHandler handler) {
            ISelectionUIHandler oldHandler = (ISelectionUIHandler)selectionHandlers[component];
            if (oldHandler == handler) {
                selectionHandlers[component] = null;
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.BeginDrag"]/*' />
        /// <devdoc>
        ///     This can be called by an outside party to begin a drag of the currently selected
        ///     set of components.
        /// </devdoc>
        bool ISelectionUIService.BeginDrag(SelectionRules rules, int initialX, int initialY) {
            if (dragHandler != null) {
                Debug.Fail("Caller is starting a drag, but there is already one in progress -- we cannot nest these!");
                return false;
            }
            
            if (rules == SelectionRules.None) {
                Debug.Fail("Caller is starting requesting a drag with no drag rules.");
                return false;
            }
            
            if (selSvc == null) {
                return false;
            }

            savedVisible = Visible;

            // First, get the list of controls
            //
            ICollection col = selSvc.GetSelectedComponents();
            object[] objects = new object[col.Count];
            col.CopyTo(objects, 0);
            
            objects = ((ISelectionUIService)this).FilterSelection(objects, rules);
            if (objects.Length == 0) {
                return false;   // nothing selected
            }

            // We allow all components with the same UI handler as the primary selection
            // to participate in the drag.
            //
            ISelectionUIHandler primaryHandler = null;
            object primary = selSvc.PrimarySelection;
            if (primary != null) {
                primaryHandler = GetHandler(primary);
            }
            if (primaryHandler == null) {
                return false;   // no UI handler for selection
            }

            // Now within the given selection, add those items that have the same
            // UI handler and that have the proper rule constraints.
            //
            ArrayList list = new ArrayList();
            for (int i = 0; i < objects.Length; i++) {
                if (GetHandler(objects[i]) == primaryHandler) {
                    SelectionRules compRules = primaryHandler.GetComponentRules(objects[i]);
                    if ((compRules & rules) == rules) {
                        list.Add(objects[i]);
                    }
                }
            }
            if (list.Count == 0) {
                return false;   // nothing matching the given constraints
            }
            objects = list.ToArray();
            
            bool dragging = false;

            // We must setup state before calling QueryBeginDrag.  It is possible
            // that QueryBeginDrag will cancel a drag (if it places a modal dialog, for
            // example), so we must have the drag data all setup before it cancels.  Then,
            // we will check again after QueryBeginDrag to see if a cancel happened.
            //
            dragComponents = objects;
            dragRules = rules;
            dragHandler = primaryHandler;
            
            string transactionName = GetTransactionName(rules, objects);
            dragTransaction = host.CreateTransaction(transactionName);

            // we need to do two levels of transactions here --
            // one that tracks the async mouse up for resize,
            // one that tracks dragging around.  if we are dragging to another form
            // the remove will trigger an OnMouseEndDrag from COntrolDesigner.Dispose()
            // and kill us here.
            //
            DesignerTransaction localTransaction = host.CreateTransaction(transactionName);

            try {
                if (primaryHandler.QueryBeginDrag(objects, rules, initialX, initialY)) {
                    if (dragHandler != null) {
                        try {
                            dragging = primaryHandler.BeginDrag(objects, rules, initialX, initialY);
                        }
                        catch (Exception e) {
                            Debug.Fail("Drag handler threw during BeginDrag -- bad handler!", e.ToString());
                            dragging = false;
                        }
                    }
                }
            }
            finally {
                
                if (!dragging) {
                    dragComponents = null;
                    dragRules = 0;
                    dragHandler = null;
                        
                    // Always commit this -- BeginDrag returns false for our drags because it is a
                    // complete operation.
                    if (dragTransaction != null) {
                        dragTransaction.Commit();
                        dragTransaction = null;
                    }
                }

                if (localTransaction != null) {
                    localTransaction.Commit();
                }

            }
            return dragging;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.DragMoved"]/*' />
        /// <devdoc>
        ///     Called by an outside party to update drag information.  This can only be called
        ///     after a successful call to beginDrag.
        /// </devdoc>
        void ISelectionUIService.DragMoved(Rectangle offset) {
            Rectangle newOffset = Rectangle.Empty;

            if (dragHandler == null) {
                throw new Exception(SR.GetString(SR.DesignerBeginDragNotCalled));
            }

            Debug.Assert(dragComponents != null, "We should have a set of drag controls here");
            if ((dragRules & SelectionRules.Moveable) == SelectionRules.None
                && (dragRules & (SelectionRules.TopSizeable | SelectionRules.LeftSizeable)) == SelectionRules.None) {
                newOffset = new Rectangle(0, 0, offset.Width, offset.Height);
            }
            if ((dragRules & SelectionRules.AllSizeable) == SelectionRules.None) {
                if (newOffset.IsEmpty) {
                    newOffset = new Rectangle(offset.X, offset.Y, 0, 0);
                }
                else {
                    newOffset.Width = newOffset.Height = 0;
                }
            }

            if (!newOffset.IsEmpty) {
                offset = newOffset;
            }

            Visible = false;
            selSvc.SetSelectedComponents(selSvc.GetSelectedComponents(), SelectionTypes.MouseDown);
            dragMoved = true;

            dragHandler.DragMoved(dragComponents, offset);
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.EndDrag"]/*' />
        /// <devdoc>
        ///     Called by an outside party to finish a drag operation.  This can only be called
        ///     after a successful call to beginDrag.
        /// </devdoc>
        void ISelectionUIService.EndDrag(bool cancel) {
            containerDrag = null;
            ISelectionUIHandler handler = dragHandler;
            object[] components = dragComponents;

            // Clean these out so that even if we throw an exception we don't die.
            //
            dragHandler = null;
            dragComponents = null;
            dragRules = SelectionRules.None;

            if (handler == null) {
                throw new InvalidOperationException();
            }

            // Typically, the handler will be changing a bunch of component properties here.
            // Optimize this by enclosing it within a batch call.
            //
            DesignerTransaction trans = null;
            
            try {
                
                if (components.Length > 1 || (components.Length == 1 && components[0] is IComponent && ((IComponent)components[0]).Site == null)) {
                    trans = host.CreateTransaction(SR.GetString(SR.DragDropMoveComponents, components.Length));
                }
                else if (components.Length == 1) {
                    IComponent comp = components[0] as IComponent;
                    if (comp != null) {
                        trans = host.CreateTransaction(SR.GetString(SR.DragDropMoveComponent, comp.Site.Name));
                    }
                }
            
                try {
                    handler.EndDrag(components, cancel);
                }
                catch (Exception e) {
                    Debug.Fail(e.ToString());
                }
            }
            finally {
                if (trans != null)
                    trans.Commit();
    
                // Reset the selection.  This will re-display our selection.
                //
                Visible = savedVisible;
                selSvc.SetSelectedComponents(selSvc.GetSelectedComponents(), SelectionTypes.Normal | SelectionTypes.MouseUp);
                ((ISelectionUIService)this).SyncSelection();


                if (dragTransaction != null) {
                    dragTransaction.Commit();
                    dragTransaction = null;
                }
                // In case this drag was initiated by us, ensure that our mouse state is correct
                //
                EndMouseDrag(MousePosition);
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.FilterSelection"]/*' />
        /// <devdoc>
        ///     Filters the set of selected components.  The selection service will retrieve all
        ///     components that are currently selected.  This method allows you to filter this
        ///     set down to components that match your criteria.  The selectionRules parameter
        ///     must contain one or more flags from the SelectionRules class.  These flags
        ///     allow you to constrain the set of selected objects to visible, movable,
        ///     sizeable or all objects.
        /// </devdoc>
        object[] ISelectionUIService.FilterSelection(object [] components, SelectionRules selectionRules) {
            object[] selection = null;

            if (components == null) return new object[0];

            // Mask off any selection object that doesn't adhere to the given ruleset.
            // We can ignore this if the ruleset is zero, as all components would be accepted.
            //
            if (selectionRules != SelectionRules.None) {
                ArrayList list = new ArrayList();
                
                foreach(object comp in components) {
                    SelectionUIItem item = (SelectionUIItem)selectionItems[comp];
                    if (item != null && !(item is ContainerSelectionUIItem)) {
                        if ((item.GetRules() & selectionRules) == selectionRules) {
                            list.Add(comp);
                        }
                    }
                }
                
                selection = (object[])list.ToArray();
            }

            return selection == null ? new object[0] : selection;
        }
        
        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.GetAdornmentDimensions"]/*' />
        /// <devdoc>
        ///     Retrieves the width and height of a selection border grab handle.
        ///     Designers may need this to properly position their user interfaces.
        /// </devdoc>
        Size ISelectionUIService.GetAdornmentDimensions(AdornmentType adornmentType) {
            switch (adornmentType) {
                case AdornmentType.GrabHandle:
                    return new Size(SelectionUIItem.GRABHANDLE_WIDTH, SelectionUIItem.GRABHANDLE_HEIGHT);
                case AdornmentType.ContainerSelector:
                case AdornmentType.Maximum:
                    return new Size(ContainerSelectionUIItem.CONTAINER_WIDTH, ContainerSelectionUIItem.CONTAINER_HEIGHT);
            }
            return new Size(0, 0);
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.GetAdornmentHitTest"]/*' />
        /// <devdoc>
        ///     Tests to determine if the given screen coordinate is over an adornment
        ///     for the specified component. This will only return true if the
        ///     adornment, and selection UI, is visible.
        /// </devdoc>
        bool ISelectionUIService.GetAdornmentHitTest(object component, Point value) {
            if (GetHitTest(value, HITTEST_DEFAULT).hitTest != SelectionUIItem.NOHIT) {
                return true;
            }
            return false;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.GetContainerSelected"]/*' />
        /// <devdoc>
        ///     Determines if the component is currently "container" selected. Container
        ///     selection is a visual aid for selecting containers. It doesn't affect
        ///     the normal "component" selection.
        /// </devdoc>
        bool ISelectionUIService.GetContainerSelected(object component) {
            return (component != null && selectionItems[component] is ContainerSelectionUIItem);
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.GetSelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of flags that define rules for the selection.  Selection
        ///     rules indicate if the given component can be moved or sized, for example.
        /// </devdoc>
        SelectionRules ISelectionUIService.GetSelectionRules(object component) {
            SelectionUIItem sel = (SelectionUIItem)selectionItems[component];
            if (sel == null) {
                Debug.Fail("The component is not currently selected.");
                throw new InvalidOperationException();
            }
            return sel.GetRules();
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.GetSelectionStyle"]/*' />
        /// <devdoc>
        ///     Allows you to configure the style of the selection frame that a
        ///     component uses.  This is useful if your component supports different
        ///     modes of operation (such as an in-place editing mode and a static
        ///     design mode).  Where possible, you should leave the selection style
        ///     as is and use the design-time hit testing feature of the IDesigner
        ///     interface to provide features at design time.  The value of style
        ///     must be one of the  SelectionStyle enum values.
        ///
        ///     The selection style is only valid for the duration that the component is
        ///     selected.
        /// </devdoc>
        SelectionStyles ISelectionUIService.GetSelectionStyle(object component) {
            SelectionUIItem s = (SelectionUIItem)selectionItems[component];
            if (s == null) {
                return SelectionStyles.None;
            }
            return s.Style;
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.SetContainerSelected"]/*' />
        /// <devdoc>
        ///     Changes the container selection status of the given component.
        ///     Container selection is a visual aid for selecting containers. It
        ///     doesn't affect the normal "component" selection.
        /// </devdoc>
        void ISelectionUIService.SetContainerSelected(object component, bool selected) {
            if (selected) {
                SelectionUIItem existingItem = (SelectionUIItem)selectionItems[component];
                if (!(existingItem is ContainerSelectionUIItem)) {
                    if (existingItem != null) {
                        existingItem.Dispose();
                    }
                    SelectionUIItem item = new ContainerSelectionUIItem(this, component);
                    selectionItems[component] = item;
                    
                    // Now update our region and invalidate
                    //
                    UpdateWindowRegion();
                    if (existingItem != null) {
                        existingItem.Invalidate();
                    }
                    item.Invalidate();
                }
            }
            else {
                SelectionUIItem existingItem = (SelectionUIItem)selectionItems[component];
                if (existingItem == null || existingItem is ContainerSelectionUIItem) {
                    selectionItems.Remove(component);
                    if (existingItem != null) {
                        existingItem.Dispose();
                    }
                    UpdateWindowRegion();
                    existingItem.Invalidate();
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.SetSelectionStyle"]/*' />
        /// <devdoc>
        ///     Allows you to configure the style of the selection frame that a
        ///     component uses.  This is useful if your component supports different
        ///     modes of operation (such as an in-place editing mode and a static
        ///     design mode).  Where possible, you should leave the selection style
        ///     as is and use the design-time hit testing feature of the IDesigner
        ///     interface to provide features at design time.  The value of style
        ///     must be one of the  SelectionStyle enum values.
        ///
        ///     The selection style is only valid for the duration that the component is
        ///     selected.
        /// </devdoc>
        void ISelectionUIService.SetSelectionStyle(object component, SelectionStyles style) {
            SelectionUIItem selUI = (SelectionUIItem)selectionItems[component];
                        
            if (selSvc != null && selSvc.GetComponentSelected(component)) {
                selUI = new SelectionUIItem(this, component);
                selectionItems[component] = selUI;
            }

            if (selUI != null) {
                selUI.Style = style;
                UpdateWindowRegion();
                selUI.Invalidate();
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.SyncSelection"]/*' />
        /// <devdoc>
        ///     This should be called when a component has been moved, sized or re-parented,
        ///     but the change was not the result of a property change.  All property
        ///     changes are monitored by the selection UI service, so this is automatic most
        ///     of the time.  There are times, however, when a component may be moved without
        ///     a property change notification occurring.  Scrolling an auto scroll Win32
        ///     form is an example of this.
        ///
        ///     This method simply re-queries all currently selected components for their
        ///     bounds and udpates the selection handles for any that have changed.
        /// </devdoc>
        void ISelectionUIService.SyncSelection() {
            if (batchMode) {
                batchChanged = true;
            }
            else {
                if (IsHandleCreated) {
                    bool updateRegion = false;
    
                    foreach(SelectionUIItem item in selectionItems.Values) {
                        updateRegion |= item.UpdateSize();
                        item.UpdateRules();
                    }
    
                    if (updateRegion) {
                        UpdateWindowRegion();
                        Update();
                    }
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ISelectionUIService.SyncComponent"]/*' />
        /// <devdoc>
        ///     This should be called when a component's property changed, that the designer
        ///     thinks should result in a selection UI change.
        ///
        ///     This method simply re-queries all currently selected components for their
        ///     bounds and udpates the selection handles for any that have changed.
        /// </devdoc>
        void ISelectionUIService.SyncComponent(object component) {
            if (batchMode) {
                batchSync = true;
            }
            else {
                if (IsHandleCreated) {
                    foreach(SelectionUIItem item in selectionItems.Values) {
                        item.UpdateRules();
                        item.Dispose();
                    }
    
                    UpdateWindowRegion();
                    Invalidate();
                    Update();
                }
            }
        }

        /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem"]/*' />
        /// <devdoc>
        ///     This class represents a single selected object.
        /// </devdoc>
        private class SelectionUIItem {

            // Flags describing how a given selection point may be sized
            //
            public const int SIZE_X    = 0x0001;
            public const int SIZE_Y    = 0x0002;
            public const int SIZE_MASK = 0x0003;

            // Flags describing how a given selection point may be moved
            //
            public const int MOVE_X    = 0x0004;
            public const int MOVE_Y    = 0x0008;
            public const int MOVE_MASK = 0x000C;

            // Flags describing where a given selection point is located on an object
            //
            public const int POS_LEFT   = 0x0010;
            public const int POS_TOP    = 0x0020;
            public const int POS_RIGHT  = 0x0040;
            public const int POS_BOTTOM = 0x0080;
            public const int POS_MASK   = 0x00F0;

            // This is returned if the given selection point is not within
            // the selection
            //
            public const int NOHIT     = 0x0100;

            // This is returned if the given selection point on the "container selector"
            //
            public const int CONTAINER_SELECTOR = 0x0200;

            public const int GRABHANDLE_WIDTH  = 7;
            public const int GRABHANDLE_HEIGHT = 7;

            // tables we use to determine how things can move and size
            //
            internal static readonly int[] activeSizeArray = new int[] {
                SIZE_X | SIZE_Y | POS_LEFT | POS_TOP,      SIZE_Y | POS_TOP,      SIZE_X | SIZE_Y | POS_TOP | POS_RIGHT,
                SIZE_X | POS_LEFT,                                                SIZE_X | POS_RIGHT,
                SIZE_X | SIZE_Y | POS_LEFT | POS_BOTTOM,   SIZE_Y | POS_BOTTOM,   SIZE_X | SIZE_Y | POS_RIGHT | POS_BOTTOM
            };

            internal static readonly Cursor[] activeCursorArrays = new Cursor[] {
                Cursors.SizeNWSE,   Cursors.SizeNS,   Cursors.SizeNESW,
                Cursors.SizeWE,                      Cursors.SizeWE,
                Cursors.SizeNESW,   Cursors.SizeNS,   Cursors.SizeNWSE
            };

            internal static readonly int[] inactiveSizeArray = new int[] {0, 0, 0, 0, 0, 0, 0, 0};
            internal static readonly Cursor[] inactiveCursorArray = new Cursor[] {
                Cursors.Arrow,   Cursors.Arrow,   Cursors.Arrow,
                Cursors.Arrow,                   Cursors.Arrow,
                Cursors.Arrow,   Cursors.Arrow,   Cursors.Arrow
            };

            internal int[]               sizes;          // array of sizing rules for this selection
            internal Cursor[]            cursors;        // array of cursors for each grab location
            internal SelectionUIService  selUIsvc;
            internal Rectangle           innerRect = Rectangle.Empty;      // inner part of selection (== control bounds)
            internal Rectangle           outerRect = Rectangle.Empty;      // outer part of selection (inner + border size)
            internal Region              region;         // region object that defines the shape
            internal object              component;      // the component we're rendering
            private  Control             control;
            private  SelectionStyles     selectionStyle; // how do we draw this thing?
            private  SelectionRules      selectionRules;
            private  ISelectionUIHandler handler;        // the components selection UI handler (can be null)

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.SelectionUIItem"]/*' />
            /// <devdoc>
            ///     constructor
            /// </devdoc>
            public SelectionUIItem(SelectionUIService selUIsvc, object component) {
                this.selUIsvc = selUIsvc;
                this.component = component;
                selectionStyle = SelectionStyles.Selected;

                // By default, a component isn't visible.  We must establish what
                // it can do through it's UI handler.
                //
                handler = selUIsvc.GetHandler(component);
                
                sizes = inactiveSizeArray;
                cursors = inactiveCursorArray;
                
                if (component is IComponent) {
                    ControlDesigner cd = selUIsvc.host.GetDesigner((IComponent)component) as ControlDesigner;
                    if (cd != null) {
                        control = cd.Control;
                    }
                }

                UpdateRules();
                UpdateGrabSettings();
                UpdateSize();
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.Style"]/*' />
            /// <devdoc>
            ///     Retrieves the style of the selection frame for this selection.
            /// </devdoc>
            public virtual SelectionStyles Style {
                get { return selectionStyle;}
                set {
                    if (value != selectionStyle) {
                        selectionStyle = value;
                        if (region != null) {
                            region.Dispose();
                            region = null;
                        }
                    }
                }
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.DoPaint"]/*' />
            /// <devdoc>
            ///     paints the selection
            /// </devdoc>
            public virtual void DoPaint(Graphics gr) {
                // If we're not visible, then there's nothing to do...
                //
                if ((GetRules() & SelectionRules.Visible) == SelectionRules.None) return;

                bool fActive = false;
                
                if (selUIsvc.selSvc != null) {
                    fActive = component == selUIsvc.selSvc.PrimarySelection;
                
                    // Office rules:  If this is a multi-select, reverse the colors for active / inactive.
                    //
                    fActive = (fActive == (selUIsvc.selSvc.SelectionCount <= 1));
                }
                                 
                Rectangle r       = new Rectangle(outerRect.X, outerRect.Y,
                                                  GRABHANDLE_WIDTH, GRABHANDLE_HEIGHT);
                Rectangle inner = innerRect;
                Rectangle outer = outerRect;

                Region oldClip = gr.Clip;

                Color borderColor = SystemColors.Control;

                if (control != null && control.Parent != null) {
                    Control parent = control.Parent;
                    borderColor = parent.BackColor;
                }

                Brush brush = new SolidBrush(borderColor);
                gr.ExcludeClip(inner);
                gr.FillRectangle(brush, outer);
                gr.Clip = oldClip;

                ControlPaint.DrawSelectionFrame( gr, false, outer, inner, borderColor );

                //if it's not locked & it is sizeable...
                if (((GetRules() & SelectionRules.Locked) == SelectionRules.None) && (GetRules() & SelectionRules.AllSizeable) != SelectionRules.None) {
                    // upper left
                    ControlPaint.DrawGrabHandle(gr, r, fActive, (sizes[0] != 0));

                    // upper right
                    r.X = inner.X + inner.Width;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[2] != 0);

                    // lower right
                    r.Y = inner.Y + inner.Height;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[7] != 0);

                    // lower left
                    r.X = outer.X;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[5] != 0);

                    // lower middle
                    r.X += (outer.Width - GRABHANDLE_WIDTH) / 2;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[6] != 0);

                    // upper middle
                    r.Y = outer.Y;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[1] != 0);

                    // left middle
                    r.X = outer.X;
                    r.Y = inner.Y + (inner.Height - GRABHANDLE_HEIGHT) / 2;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[3] != 0);

                    // right middle
                    r.X = inner.X + inner.Width;
                    ControlPaint.DrawGrabHandle(gr, r, fActive, sizes[4] != 0);
                }
                else {
                    ControlPaint.DrawLockedFrame(gr, outer, fActive);
                }
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.GetCursorAtPoint"]/*' />
            /// <devdoc>
            ///     Retrieves an appropriate cursor at the given point.  If there is no appropriate
            ///     cursor here (ie, the point lies outside the selection rectangle), then this
            ///     will return null.
            /// </devdoc>
            public virtual Cursor GetCursorAtPoint(Point pt) {
                Cursor cursor = null;

                if (PointWithinSelection(pt)) {
                    int nOffset = -1;

                    if ((GetRules() & SelectionRules.AllSizeable) != SelectionRules.None) {
                        nOffset = GetHandleIndexOfPoint(pt);
                    }

                    if (-1 == nOffset) {
                        if ((GetRules() & SelectionRules.Moveable) == SelectionRules.None) {
                            cursor = Cursors.Default;
                        }
                        else {
                            cursor = Cursors.SizeAll;
                        }
                    }
                    else {
                        cursor = cursors[nOffset];
                    }
                }

                return cursor;
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.GetHitTest"]/*' />
            /// <devdoc>
            ///     returns the hit test code of the given point.  This may be one of:
            /// </devdoc>
            public virtual int GetHitTest(Point pt) {

                // Is it within our rects?
                //
                if (!PointWithinSelection(pt)) {
                    return NOHIT;
                }

                // Which index in the array is this?
                //
                int nOffset = GetHandleIndexOfPoint(pt);

                // If no index, the user has picked on the hatch
                //
                if (-1 == nOffset || sizes[nOffset] == 0) {
                    return((GetRules() & SelectionRules.Moveable) == SelectionRules.None ? 0 : MOVE_X | MOVE_Y);
                }

                return sizes[nOffset];
            }


            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.GetHandleIndexOfPoint"]/*' />
            /// <devdoc>
            ///     gets the array offset of the handle at the given point
            /// </devdoc>
            private int GetHandleIndexOfPoint(Point pt) {
                if (pt.X >= outerRect.X && pt.X <= innerRect.X) {
                    // Something on the left side.
                    if (pt.Y >= outerRect.Y && pt.Y <= innerRect.Y)
                        return 0;   // top left

                    if (pt.Y >= innerRect.Y + innerRect.Height && pt.Y <= outerRect.Y + outerRect.Height)
                        return 5;   // bottom left

                    if (pt.Y >= outerRect.Y + (outerRect.Height - GRABHANDLE_HEIGHT) / 2
                        && pt.Y <= outerRect.Y + (outerRect.Height + GRABHANDLE_HEIGHT) / 2)
                        return 3;   // middle left

                    return -1;    // unknown hit
                }

                if (pt.Y >= outerRect.Y && pt.Y <= innerRect.Y) {
                    // something on the top
                    Debug.Assert(!(pt.X >= outerRect.X && pt.X <= innerRect.X),
                                 "Should be handled by left top check");

                    if (pt.X >= innerRect.X + innerRect.Width && pt.X <= outerRect.X + outerRect.Width)
                        return 2;   // top right

                    if (pt.X >= outerRect.X + (outerRect.Width - GRABHANDLE_WIDTH) / 2
                        && pt.X <= outerRect.X + (outerRect.Width + GRABHANDLE_WIDTH) / 2)
                        return 1;   // top middle

                    return -1;    // unknown hit
                }

                if (pt.X >= innerRect.X + innerRect.Width && pt.X <= outerRect.X + outerRect.Width) {
                    // something on the right side
                    Debug.Assert(!(pt.Y >= outerRect.Y && pt.Y <=  innerRect.Y),
                                 "Should be handled by top right check");

                    if (pt.Y >= innerRect.Y + innerRect.Height && pt.Y <= outerRect.Y + outerRect.Height)
                        return 7;   // bottom right

                    if (pt.Y >= outerRect.Y + (outerRect.Height - GRABHANDLE_HEIGHT) / 2
                        && pt.Y <= outerRect.Y + (outerRect.Height + GRABHANDLE_HEIGHT) / 2)
                        return 4;   // middle right

                    return -1;    // unknown hit
                }

                if (pt.Y >= innerRect.Y + innerRect.Height && pt.Y <= outerRect.Y + outerRect.Height) {
                    // something on the bottom
                    Debug.Assert(!(pt.X >= outerRect.X && pt.X <= innerRect.X),
                                 "Should be handled by left bottom check");

                    Debug.Assert(!(pt.X >= innerRect.X + innerRect.Width && pt.X <= outerRect.X + outerRect.Width),
                                 "Should be handled by right bottom check");

                    if (pt.X >= outerRect.X + (outerRect.Width - GRABHANDLE_WIDTH) / 2
                        && pt.X <= outerRect.X + (outerRect.Width + GRABHANDLE_WIDTH) / 2)
                        return 6;   // bottom middle

                    return -1;    // unknown hit
                }

                return -1; // unknown hit
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.GetRegion"]/*' />
            /// <devdoc>
            ///     returns a region handle that defines this selection.  This is used to piece
            ///     together a paint region for the surface that we draw our selection handles on
            /// </devdoc>
            public virtual Region GetRegion() {
                if (region == null) {
                    if ((GetRules() & SelectionRules.Visible) != SelectionRules.None && !outerRect.IsEmpty) {
                        region = new Region(outerRect);
                        region.Exclude(innerRect);
                    }
                    else {
                        region = new Region(new Rectangle(0, 0, 0, 0));
                    }

                    if (handler != null) {
                        Rectangle handlerClip = handler.GetSelectionClipRect(component);
                        if (!handlerClip.IsEmpty) {
                            region.Intersect(selUIsvc.RectangleToClient(handlerClip));
                        }
                    }
                }
                return region;
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.GetRules"]/*' />
            /// <devdoc>
            ///     Retrieves the rules associated with this selection.
            /// </devdoc>
            public SelectionRules GetRules() {
                return selectionRules;
            }

            public void Dispose() {
                if (region != null) {
                    region.Dispose();
                    region = null;
                }
            }
            
            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.Invalidate"]/*' />
            /// <devdoc>
            ///     Invalidates the region for this selection glyph.
            /// </devdoc>
            public void Invalidate() {
                if (!outerRect.IsEmpty && !selUIsvc.Disposing) {
                    selUIsvc.Invalidate(outerRect);
                }
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.PointWithinSelection"]/*' />
            /// <devdoc>
            ///     Part of our hit testing logic; determines if the point is somewhere
            ///     within our selection.
            /// </devdoc>
            protected bool PointWithinSelection(Point pt) {

                // This is only supported for visible selections
                //
                if ((GetRules() & SelectionRules.Visible) == SelectionRules.None || outerRect.IsEmpty || innerRect.IsEmpty) {
                    return false;
                }

                if (pt.X < outerRect.X || pt.X > outerRect.X + outerRect.Width) {
                    return false;
                }

                if (pt.Y < outerRect.Y || pt.Y > outerRect.Y + outerRect.Height) {
                    return false;
                }

                if (pt.X > innerRect.X
                    && pt.X < innerRect.X + innerRect.Width
                    && pt.Y > innerRect.Y
                    && pt.Y < innerRect.Y + innerRect.Height) {
                    return false;
                }
                return true;
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.UpdateGrabSettings"]/*' />
            /// <devdoc>
            ///     Updates the available grab handle settings based on the current rules.
            /// </devdoc>
            private void UpdateGrabSettings() {
                SelectionRules rules = GetRules();

                if ((rules & SelectionRules.AllSizeable) == SelectionRules.None) {
                    sizes   = inactiveSizeArray;
                    cursors = inactiveCursorArray;
                }
                else {
                    sizes = new int[8];
                    cursors = new Cursor[8];

                    Array.Copy(activeCursorArrays, cursors, cursors.Length);
                    Array.Copy(activeSizeArray, sizes, sizes.Length);

                    if ((rules & SelectionRules.TopSizeable) != SelectionRules.TopSizeable) {
                        sizes[0] = 0;
                        sizes[1] = 0;
                        sizes[2] = 0;
                        cursors[0] = Cursors.Arrow;
                        cursors[1] = Cursors.Arrow;
                        cursors[2] = Cursors.Arrow;
                    }
                    if ((rules & SelectionRules.LeftSizeable) != SelectionRules.LeftSizeable) {
                        sizes[0] = 0;
                        sizes[3] = 0;
                        sizes[5] = 0;
                        cursors[0] = Cursors.Arrow;
                        cursors[3] = Cursors.Arrow;
                        cursors[5] = Cursors.Arrow;
                    }
                    if ((rules & SelectionRules.BottomSizeable) != SelectionRules.BottomSizeable) {
                        sizes[5] = 0;
                        sizes[6] = 0;
                        sizes[7] = 0;
                        cursors[5] = Cursors.Arrow;
                        cursors[6] = Cursors.Arrow;
                        cursors[7] = Cursors.Arrow;
                    }
                    if ((rules & SelectionRules.RightSizeable) != SelectionRules.RightSizeable) {
                        sizes[2] = 0;
                        sizes[4] = 0;
                        sizes[7] = 0;
                        cursors[2] = Cursors.Arrow;
                        cursors[4] = Cursors.Arrow;
                        cursors[7] = Cursors.Arrow;
                    }
                }
            }
            
            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.UpdateRules"]/*' />
            /// <devdoc>
            ///     Updates our cached selection rules based on current
            ///     handler values.
            /// </devdoc>
            public void UpdateRules() {
                if (handler == null) {
                    selectionRules = SelectionRules.None;
                }
                else {
                    SelectionRules oldRules = selectionRules;
                    selectionRules = handler.GetComponentRules(component);
                    if (selectionRules != oldRules) {
                        UpdateGrabSettings();
                        Invalidate();
                    }
                }
            }

            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.SelectionUIItem.UpdateSize"]/*' />
            /// <devdoc>
            ///     rebuilds the inner and outer rectangles based on the current
            ///     selItem.component dimensions.  We could calcuate this every time, but that
            ///     would be expensive for functions like getHitTest that are called a lot
            ///     (like on every mouse move)
            /// </devdoc>
            public virtual bool UpdateSize() {
                bool sizeChanged = false;

                // Short circuit common cases
                //
                if (handler == null) return false;
                if ((GetRules() & SelectionRules.Visible) ==SelectionRules.None) return false;

                innerRect = handler.GetComponentBounds(component);
                
                if (!innerRect.IsEmpty) {
                    innerRect = selUIsvc.RectangleToClient(innerRect);

                    Rectangle rcOuterNew = new Rectangle(
                                                        innerRect.X - GRABHANDLE_WIDTH,
                                                        innerRect.Y - GRABHANDLE_HEIGHT,
                                                        innerRect.Width + 2 * GRABHANDLE_WIDTH,
                                                        innerRect.Height + 2 * GRABHANDLE_HEIGHT);

                    if (outerRect.IsEmpty || !outerRect.Equals(rcOuterNew)) {
                        if (!outerRect.IsEmpty)
                            Invalidate();

                        outerRect = rcOuterNew;

                        Invalidate();
                        if (region != null) {
                            region.Dispose();
                            region = null;
                        }
                        sizeChanged = true;
                    }
                }
                else {
                    Rectangle rcNew = new Rectangle(0, 0, 0, 0);
                    sizeChanged = outerRect.IsEmpty || !outerRect.Equals(rcNew);
                    innerRect = outerRect = rcNew;
                }

                return sizeChanged;
            }
        }

        private class ContainerSelectionUIItem : SelectionUIItem {
            public const int CONTAINER_WIDTH  = 13;
            public const int CONTAINER_HEIGHT = 13;
            
            /// <include file='doc\SelectionUIService.uex' path='docs/doc[@for="SelectionUIService.ContainerSelectionUIItem.ContainerSelectionUIItem"]/*' />
            /// <devdoc>
            ///     constructor
            /// </devdoc>
            public ContainerSelectionUIItem(SelectionUIService selUIsvc, object component) : base(selUIsvc, component) {
            }
                      
            public override Cursor GetCursorAtPoint(Point pt) {
                if ((GetHitTest(pt) & CONTAINER_SELECTOR) != 0 && (GetRules() & SelectionRules.Moveable) != SelectionRules.None) {
                    return Cursors.SizeAll;
                }
                else {
                    return null;
                }
            }

            public override int GetHitTest(Point pt) {
                int ht = NOHIT;

                if ((GetRules() & SelectionRules.Visible) != SelectionRules.None && !outerRect.IsEmpty) {
                    Rectangle r = new Rectangle(outerRect.X, outerRect.Y,
                                                CONTAINER_WIDTH, CONTAINER_HEIGHT);

                    if (r.Contains(pt)) {
                        ht = CONTAINER_SELECTOR;
                        if ((GetRules() & SelectionRules.Moveable) != SelectionRules.None) {
                            ht |= MOVE_X | MOVE_Y;
                        }
                    }
                }

                return ht;

            }

            public override void DoPaint(Graphics gr) {

                // If we're not visible, then there's nothing to do...
                //
                if ((GetRules() & SelectionRules.Visible) == SelectionRules.None) return;

                Rectangle glyphBounds = new Rectangle(outerRect.X, outerRect.Y,
                                                      CONTAINER_WIDTH, CONTAINER_HEIGHT);
                ControlPaint.DrawContainerGrabHandle(gr, glyphBounds);
            }

            public override Region GetRegion() {
                if (region == null) {
                    if ((GetRules() & SelectionRules.Visible) != SelectionRules.None && !outerRect.IsEmpty) {
                        Rectangle r       = new Rectangle(outerRect.X, outerRect.Y,
                                                          CONTAINER_WIDTH, CONTAINER_HEIGHT);

                        region = new Region(r);
                    }
                    else {
                        region = new Region(new Rectangle(0, 0, 0, 0));
                    }
                }

                return region;
            }
        }

        private struct HitTestInfo {
            public readonly int hitTest;
            public readonly SelectionUIItem selectionUIHit;
            public readonly bool containerSelector;

            public HitTestInfo(int hitTest, SelectionUIItem selectionUIHit) {
                this.hitTest = hitTest;
                this.selectionUIHit = selectionUIHit;
                this.containerSelector = false;
            }

            public HitTestInfo(int hitTest, SelectionUIItem selectionUIHit, bool containerSelector) {
                this.hitTest = hitTest;
                this.selectionUIHit = selectionUIHit;
                this.containerSelector = containerSelector;
            }

            public override bool Equals(object obj) {
                try {
                    HitTestInfo hi = (HitTestInfo)obj;
                    return hitTest == hi.hitTest && selectionUIHit == hi.selectionUIHit && containerSelector == hi.containerSelector;
                }
                catch (Exception) {
                }
                return false;
            }

            public override int GetHashCode() {
                int hash = hitTest | selectionUIHit.GetHashCode();
                if (containerSelector) {
                    hash |= 0x10000;
                }
                return hash;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\splitterdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="SplitterDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.ComponentModel;

    using System.Diagnostics;
    using System.Drawing.Drawing2D;
    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\SplitterDesigner.uex' path='docs/doc[@for="SplitterDesigner"]/*' />
    /// <devdoc>
    ///      This class handles all design time behavior for the splitter class.  This
    ///      draws a visible border on the splitter if it doesn't have a border so the
    ///      user knows where the boundaries of the splitter lie.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class SplitterDesigner : ControlDesigner {
    
        /// <include file='doc\SplitterDesigner.uex' path='docs/doc[@for="SplitterDesigner.DrawBorder"]/*' />
        /// <devdoc>
        ///      This draws a nice border around our panel.  We need
        ///      this because the panel can have no border and you can't
        ///      tell where it is.
        /// </devdoc>
        /// <internalonly/>
        private void DrawBorder(Graphics graphics) {
            Control ctl = Control;
            Rectangle rc = ctl.ClientRectangle;
            Color penColor;

            // Black or white pen?  Depends on the color of the control.
            //
            if (ctl.BackColor.GetBrightness() < .5) {
                penColor = Color.White;
            }
            else {
                penColor = Color.Black;
            }

            Pen pen = new Pen(penColor);
            pen.DashStyle = DashStyle.Dash;

            rc.Width --;
            rc.Height--;
            graphics.DrawRectangle(pen, rc);

            pen.Dispose();
        }

        /// <include file='doc\SplitterDesigner.uex' path='docs/doc[@for="SplitterDesigner.OnPaintAdornments"]/*' />
        /// <devdoc>
        ///      Overrides our base class.  Here we check to see if there
        ///      is no border on the panel.  If not, we draw one so that
        ///      the panel shape is visible at design time.
        /// </devdoc>
        protected override void OnPaintAdornments(PaintEventArgs pe) {
            Splitter splitter = (Splitter)Component;

            base.OnPaintAdornments(pe);

            if (splitter.BorderStyle == BorderStyle.None) {
                DrawBorder(pe.Graphics);
            }
        }

        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_WINDOWPOSCHANGED:
                    // Really only care about window size changing
                    Control source = (Control)Control;
                    source.Invalidate();
                    break;
            }
            base.WndProc(ref m);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\selectionrules.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionRules.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies a set of selection rule identifiers that
    ///       can be used to indicate attributes for a selected component.
    ///    </para>
    /// </devdoc>
    [Flags]
    public enum SelectionRules {
        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       no special selection attributes.
        ///    </para>
        /// </devdoc>
        None = 0x00000000,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.Moveable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component supports a location
        ///       property that allows it to be moved on the screen, and
        ///       that the selection service is not currently locked.
        ///    </para>
        /// </devdoc>
        Moveable = 0x10000000,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.Visible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component has some form of visible user
        ///       interface and the selection service is drawing a selection border around
        ///       this user interface. If a selected component has this rule set, you can assume
        ///       that the component implements <see cref='System.ComponentModel.IComponent'/>
        ///       and that it
        ///       is associated with a corresponding design instance.
        ///    </para>
        /// </devdoc>
        Visible = 0x40000000,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.Locked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component is locked to
        ///       its container. Overrides the moveable and sizeable
        ///       properties of this enum.
        ///    </para>
        /// </devdoc>
        Locked = unchecked((int)0x80000000),

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.TopSizeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component supports resize from
        ///       the top. This bit will be ignored unless the Sizeable
        ///       bit is also set.
        ///    </para>
        /// </devdoc>
        TopSizeable = 0x00000001,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.BottomSizeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component supports resize from
        ///       the bottom. This bit will be ignored unless the Sizeable
        ///       bit is also set.
        ///    </para>
        /// </devdoc>
        BottomSizeable = 0x00000002,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.LeftSizeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component supports resize from
        ///       the left. This bit will be ignored unless the Sizeable
        ///       bit is also set.
        ///    </para>
        /// </devdoc>
        LeftSizeable = 0x00000004,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.RightSizeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component supports resize from
        ///       the right. This bit will be ignored unless the Sizeable
        ///       bit is also set.
        ///    </para>
        /// </devdoc>
        RightSizeable = 0x00000008,

        /// <include file='doc\SelectionRules.uex' path='docs/doc[@for="SelectionRules.AllSizeable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates
        ///       the given component supports sizing
        ///       in all directions, and the selection service is not currently locked.
        ///    </para>
        /// </devdoc>
        AllSizeable = TopSizeable | BottomSizeable | LeftSizeable | RightSizeable,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\statusbardesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="StatusBarDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Collections;

    /// <include file='doc\StatusBarDesigner.uex' path='docs/doc[@for="StatusBarDesigner"]/*' />
    /// <devdoc>
    ///      This class handles all design time behavior for the status bar class.    
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class StatusBarDesigner : ControlDesigner {

        /// <include file='doc\StatusBarDesigner.uex' path='docs/doc[@for="StatusBarDesigner.AssociatedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a list of assosciated components.  These are components that should be incluced in a cut or copy operation on this component.
        ///    </para>
        /// </devdoc>
        public override ICollection AssociatedComponents {
            get {
                StatusBar sb = Control as StatusBar;
                if (sb != null) {
                    return sb.Panels;
                }
                return base.AssociatedComponents;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\selectionstyles.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionStyles.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\SelectionStyles.uex' path='docs/doc[@for="SelectionStyles"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies identifiers to use to
    ///       indicate the style of the selection frame of a
    ///       component.
    ///    </para>
    /// </devdoc>
    [Flags]
    internal enum SelectionStyles {

        /// <include file='doc\SelectionStyles.uex' path='docs/doc[@for="SelectionStyles.None"]/*' />
        /// <devdoc>
        ///     The component is not currently selected.
        /// </devdoc>
        None = 0,

        /// <include file='doc\SelectionStyles.uex' path='docs/doc[@for="SelectionStyles.Selected"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A component is selected and may be dragged around the
        ///    </para>
        /// </devdoc>
        Selected = 0x01,

        /// <include file='doc\SelectionStyles.uex' path='docs/doc[@for="SelectionStyles.Active"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An alternative selection border,
        ///       indicating that a component is in active editing mode and that clicking and
        ///       dragging on the component affects the component itself, not its position
        ///       in the designer.
        ///       
        ///    </para>
        /// </devdoc>
        Active   = 0x02,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\stringarrayeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringArrayEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {

    using System;
    using System.Collections;
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;

    /// <include file='doc\StringArrayEditor.uex' path='docs/doc[@for="StringArrayEditor"]/*' />
    /// <devdoc>
    ///      The StringArrayEditor is a collection editor that is specifically
    ///      designed to edit arrays containing strings.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class StringArrayEditor : StringCollectionEditor {
        
        public StringArrayEditor(Type type) : base(type) {
        }
    
        /// <include file='doc\StringArrayEditor.uex' path='docs/doc[@for="StringArrayEditor.CreateCollectionItemType"]/*' />
        /// <devdoc>
        ///      Retrieves the data type this collection contains.  The default 
        ///      implementation looks inside of the collection for the Item property
        ///      and returns the returning datatype of the item.  Do not call this
        ///      method directly.  Instead, use the CollectionItemType property.  Use this
        ///      method to override the default implementation.
        /// </devdoc>
        protected override Type CreateCollectionItemType() {
            return CollectionType.GetElementType();
        }
        
        /// <include file='doc\StringArrayEditor.uex' path='docs/doc[@for="StringArrayEditor.GetItems"]/*' />
        /// <devdoc>
        ///      We implement the getting and setting of items on this collection.
        /// </devdoc>
        protected override object[] GetItems(object editValue) {
            if (editValue is Array) {
                Array valueArray = (Array)editValue;
                object[] items = new object[valueArray.GetLength(0)];
                Array.Copy(valueArray, items, items.Length);
                return items;
            }
            else {
                return new object[0];
            }
        }
            
        /// <include file='doc\StringArrayEditor.uex' path='docs/doc[@for="StringArrayEditor.SetItems"]/*' />
        /// <devdoc>
        ///      We implement the getting and setting of items on this collection.
        ///      It should return an instance to replace editValue with, or editValue
        ///      if there is no need to replace the instance.
        /// </devdoc>
        protected override object SetItems(object editValue, object[] value) {
            if (editValue is Array || editValue == null) {
                Array newArray = Array.CreateInstance(CollectionItemType, value.Length);
                Array.Copy(value, newArray, value.Length);
                return newArray;
            }
            return editValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\stringcollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#define NEEDHELPBUTTON    

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.ComponentModel;
    using System;
    using System.Collections;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;
    

    /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor"]/*' />
    /// <devdoc>
    ///      The StringCollectionEditor is a collection editor that is specifically
    ///      designed to edit collections containing strings.  The collection can be
    ///      of any type that can accept a string value; we just present a string-centric
    ///      dialog for the user.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class StringCollectionEditor : CollectionEditor {
        
        public StringCollectionEditor(Type type) : base(type) {
        }

        /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor.CreateCollectionForm"]/*' />
        /// <devdoc>
        ///      Creates a new form to show the current collection.  You may inherit
        ///      from CollectionForm to provide your own form.
        /// </devdoc>
        protected override CollectionForm CreateCollectionForm() {
            return new StringCollectionForm(this);
        }

        /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor.HelpTopic"]/*' />
        /// <devdoc>
        ///    <para>Gets the help topic to display for the dialog help button or pressing F1. Override to
        ///          display a different help topic.</para>
        /// </devdoc>
        protected override string HelpTopic {
            get {
                return "net.ComponentModel.StringCollectionEditor";
            }
        }
            
        /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor.StringCollectionForm"]/*' />
        /// <devdoc>
        ///     StringCollectionForm allows visible editing of a string array. Each line in
        ///     the edit box is an array entry.
        /// </devdoc>
        private class StringCollectionForm : CollectionForm {
    
            private Label instruction = new Label();
            private TextBox textEntry = new TextBox();
            private Button okButton = new Button();
            private Button cancelButton = new Button();
    #if NEEDHELPBUTTON
            private Button helpButton = new Button();
    #endif
    
            private StringCollectionEditor editor = null;

            /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor.StringCollectionForm.StringCollectionForm"]/*' />
            /// <devdoc>
            ///     Constructs a StringCollectionForm.
            /// </devdoc>
            public StringCollectionForm(CollectionEditor editor) : base(editor) {
                this.editor = (StringCollectionEditor) editor;
                InitializeComponent();
            }
    
            private void Edit1_keyDown(object sender, KeyEventArgs e) {
                if (e.KeyCode == Keys.Escape) {
                    cancelButton.PerformClick();
                    e.Handled = true;
                }
            }
    
            private void HelpButton_click(object sender, EventArgs e) {
                editor.ShowHelp();
            }

            private void Form_HelpRequested(object sender, HelpEventArgs e) {
                editor.ShowHelp();
            }

            /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor.StringCollectionForm.InitializeComponent"]/*' />
            /// <devdoc>
            ///     NOTE: The following code is required by the form
            ///     designer.  It can be modified using the form editor.  Do not
            ///     modify it using the code editor.
            /// </devdoc>
            private void InitializeComponent() {
                instruction.Location = new Point(4, 7);
                instruction.Size = new Size(422, 14);
                instruction.TabIndex = 0;
                instruction.TabStop = false;
                instruction.Text = SR.GetString(SR.StringCollectionEditorInstruction);
                
                textEntry.Location = new Point(4, 22);
                textEntry.Size = new Size(422, 244);
                textEntry.TabIndex = 0;
                textEntry.Text = "";
                textEntry.AcceptsTab = true;
                textEntry.AcceptsReturn = true;                
                textEntry.AutoSize = false;
                textEntry.Multiline = true;
                textEntry.ScrollBars = ScrollBars.Both;
                textEntry.WordWrap = false;
                textEntry.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Bottom | AnchorStyles.Right;
                textEntry.KeyDown += new KeyEventHandler(this.Edit1_keyDown);                
    
    #if NEEDHELPBUTTON
                okButton.Location = new Point(185, 274);
    #else
                okButton.Location = new Point(264, 274);
    #endif
                okButton.Size = new Size(75, 23);
                okButton.TabIndex = 1;
                okButton.Text = SR.GetString(SR.StringCollectionEditorOKCaption);
                okButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
                okButton.DialogResult = DialogResult.OK;
                okButton.Click += new EventHandler(this.OKButton_click);
    
    #if NEEDHELPBUTTON
                cancelButton.Location = new Point(264, 274);
    #else
                cancelButton.Location = new Point(343, 274);
    #endif
                cancelButton.Size = new Size(75, 23);
                cancelButton.TabIndex = 2;
                cancelButton.Text = SR.GetString(SR.StringCollectionEditorCancelCaption);
                cancelButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
                cancelButton.DialogResult = DialogResult.Cancel;
    
    #if NEEDHELPBUTTON
                helpButton.Location = new Point(343, 274);
                helpButton.Size = new Size(75, 23);
                helpButton.TabIndex = 3;
                helpButton.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
                helpButton.Text = SR.GetString(SR.StringCollectionEditorHelpCaption);
    #endif
    
                this.Location = new Point(7, 7);
                this.Text = SR.GetString(SR.StringCollectionEditorTitle);
                this.AcceptButton = okButton;
                this.AutoScaleBaseSize = new Size(5, 13);
                this.CancelButton = cancelButton;
                this.ClientSize = new Size(429, 307);
                this.MaximizeBox = false;
                this.MinimizeBox = false;
                this.ControlBox = false;
                this.ShowInTaskbar = false;
                this.StartPosition = FormStartPosition.CenterParent;
                this.MinimumSize = new Size(300, 200);

                helpButton.Click += new EventHandler(this.HelpButton_click);
                this.HelpRequested += new HelpEventHandler(this.Form_HelpRequested);
    
                this.Controls.Clear();
                this.Controls.AddRange(new Control[] {
                                        instruction,
                                        textEntry,
                                        okButton,
                                        cancelButton,
    #if NEEDHELPBUTTON
                                        helpButton
    #endif
                                        });
            }
            
            /// <include file='doc\StringCollectionEditor.uex' path='docs/doc[@for="StringCollectionEditor.StringCollectionForm.OKButton_click"]/*' />
            /// <devdoc>
            ///      Commits the changes to the editor.
            /// </devdoc>
            private void OKButton_click(object sender, EventArgs e) {
                char[] delims = new char[] {'\n'};
                char[] trims = new char[] {'\r'};
                
                string[] strings = textEntry.Text.Split(delims);
                object[] curItems = Items;

                int nItems = strings.Length;
                for (int i = 0; i < nItems; i++) {
                    strings[i] = strings[i].Trim(trims);
                }
                
                bool dirty = true;
                if (nItems == curItems.Length) {
                    int i;
                    for (i = 0; i < nItems; ++i) {
                        if (!strings[i].Equals((string)curItems[i])) {
                            break;
                        }
                    }

                    if (i == nItems)
                        dirty = false;
                }

                if (!dirty) {
                    DialogResult = DialogResult.Cancel;
                    return;
                }

                // ASURT #57372
                // If the final line is blank, we don't want to create an item from it
                //
                if (strings.Length > 0 && strings[strings.Length - 1].Length == 0) {
                    nItems--;
                }
                
                object[] values = new object[nItems];
                for (int i = 0; i < nItems; i++) {
                    values[i] = strings[i];
                }
                
                Items = values;
            }
            
            // <summary>
            //      This is called when the value property in the CollectionForm has changed.
            //      In it you should update your user interface to reflect the current value.
            // </summary>
            // </doc>
            protected override void OnEditValueChanged() {
                object[] items = Items;
                string text = string.Empty;
                
                for (int i = 0; i < items.Length; i++) {
                    if (items[i] is string) {
                        text += (string)items[i];
                        if (i != items.Length - 1) {
                            text += "\r\n";
                        }
                    }
                }
    
                textEntry.Text = text;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\selectionuihandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionUIHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;    
    using System.Windows.Forms;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This is an abstract base class that encapsulates a lot of
    ///       the details of handling selection drags. Just about everyone
    ///       that implements a selection UI handler will extend this.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal abstract class SelectionUIHandler {

        // These handle our drag feedback.  These come into play when we're
        // actually moving components around.  The selection UI service
        // dictates when this happens.
        //
        private Rectangle    dragOffset = Rectangle.Empty;        // this gets added to a component's x, y, width, height
        private Control[]    dragControls;      // the set of controls we're dragging
        private BoundsInfo[] originalCoords;    // the saved coordinates of the components we're dragging.
        private SelectionRules rules;           // the rules of the current drag.
        private DesignerTransaction moveTrans;  // the transaction encompassing the move, if any.

        private const int MinControlWidth = 3;
        private const int MinControlHeight = 3;
        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.BeginDrag"]/*' />
        /// <devdoc>
        ///     Begins a drag operation.  A designer should examine the list of components
        ///     to see if it wants to support the drag.  If it does, it should return
        ///     true.  If it returns true, the designer should provide
        ///     UI feedback about the drag at this time.  Typically, this feedback consists
        ///     of an inverted rectangle for each component, or a caret if the component
        ///     is text.
        /// </devdoc>
        public virtual bool BeginDrag(object[] components, SelectionRules rules, int initialX, int initialY) {
            dragOffset = new Rectangle();
            originalCoords = null;
            this.rules = rules;

            dragControls = new Control[components.Length];
            for(int i = 0; i < components.Length; i++) {
                Debug.Assert(components[i] is IComponent, "Selection UI handler only deals with IComponents");
                dragControls[i] = GetControl((IComponent)components[i]);
                Debug.Assert(dragControls[i] != null, "Everyone must have a control");
            }

            // allow the cliprect to go just beyond the window by one grid.  This helps with round off
            // problems.  We can only do this if the container itself is not in the selection.  Also,
            // if the container is a form and it has autoscroll turned on, we allow a drag beyond the
            // container boundary on the width and height, but not top and left.
            //
            bool containerSelected = false;
            IComponent container = GetComponent();
            for (int i = 0; i < components.Length; i++) {
                if (components[i] == container) {
                    containerSelected = true;
                    break;
                }
            }

            if (!containerSelected) {
                Control containerControl = GetControl();
                Size snapSize = GetCurrentSnapSize();
                Rectangle containerRect = containerControl.RectangleToScreen(containerControl.ClientRectangle);
                containerRect.Inflate(snapSize.Width, snapSize.Height);
                if (GetControl() is ScrollableControl && ((ScrollableControl)GetControl()).AutoScroll) {
                    Rectangle screen = SystemInformation.VirtualScreen;
                    containerRect.Width = screen.Width;
                    containerRect.Height = screen.Height;
                }

            }
            return true;
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.CancelControlMove"]/*' />
        /// <devdoc>
        ///      This is called by MoveControls when the user has requested that the move be
        ///      cancelled.  This puts all the controls back to where they were.
        /// </devdoc>
        private void CancelControlMove(Control[] controls, BoundsInfo[] bounds) {
            Debug.Assert(bounds != null && controls != null && bounds.Length == controls.Length, "bounds->controls mismatch");

            Rectangle b = new Rectangle();
            Point point = new Point();

            // Whip through each of the controls.
            //
            for (int i = 0; i < controls.Length; i++) {

                Control parent = controls[i].Parent;

                // Suspend parent layout so that we don't continously re-arrange components
                // while we move.
                //
                if (parent != null) {
                    parent.SuspendLayout();
                }

                b.X = bounds[i].X;
                b.Y = bounds[i].Y;
                b.Width = bounds[i].Width;
                b.Height = bounds[i].Height;

                controls[i].Bounds = b;
            }

            // And resume their layout
            //
            for (int i = 0; i < controls.Length; i++) {
                Control parent = controls[i].Parent;
                if (parent != null) {
                    parent.ResumeLayout();
                }
            }
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.DragMoved"]/*' />
        /// <devdoc>
        ///     Called when the user has moved the mouse.  This will only be called on
        ///     the designer that returned true from beginDrag.  The designer
        ///     should update its UI feedback here.
        /// </devdoc>
        public virtual void DragMoved(object[] components, Rectangle offset) {
            dragOffset = offset;

            // Since we do full drag, begin a batch operation now so that
            // we don't fire ten thousand change events.  We also
            // call ComponentChanging so that any srcsafe stuff
            // can happen.
            //
            if (originalCoords == null && components.Length > 0) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(host != null, "We really need a designer host here.");
                
                moveTrans = host.CreateTransaction(SelectionUIService.GetTransactionName(rules, components));
            }

            MoveControls(components, false, false);
            Debug.Assert(originalCoords != null, "We are keying off of originalCoords, but MoveControls didn't set it");
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.EndDrag"]/*' />
        /// <devdoc>
        ///     Called when the user has completed the drag.  The designer should
        ///     remove any UI feedback it may be providing.
        /// </devdoc>
        public virtual void EndDrag(object[] components, bool cancel) {
            try {
                try {
                    MoveControls(components, cancel, true);
                }
                catch (CheckoutException checkoutEx) {
                    if (checkoutEx == CheckoutException.Canceled) {
                        MoveControls(components, true, false);
                    }
                    else {
                        throw checkoutEx;
                    }
                }
            }
            finally {
                if (moveTrans != null) {
                    moveTrans.Commit();
                }
            }
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetComponent"]/*' />
        /// <devdoc>
        ///      Retrieves the base component for the selection handler.
        /// </devdoc>
        protected abstract IComponent GetComponent();

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetControl"]/*' />
        /// <devdoc>
        ///      Retrieves the base component's UI control for the selection handler.
        /// </devdoc>
        protected abstract Control GetControl();

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetControl1"]/*' />
        /// <devdoc>
        ///      Retrieves the UI control for the given component.
        /// </devdoc>
        protected abstract Control GetControl(IComponent component);

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetCurrentSnapSize"]/*' />
        /// <devdoc>
        ///      Retrieves the current grid snap size we should snap objects
        ///      to.
        /// </devdoc>
        protected abstract Size GetCurrentSnapSize();

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetService"]/*' />
        /// <devdoc>
        ///      We use this to request often-used services.
        /// </devdoc>
        protected abstract object GetService(Type serviceType);

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetShouldSnapToGrid"]/*' />
        /// <devdoc>
        ///      Determines if the selection UI handler should attempt to snap
        ///      objects to a grid.
        /// </devdoc>
        protected abstract bool GetShouldSnapToGrid();

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.GetUpdatedRect"]/*' />
        /// <devdoc>
        ///      Given a rectangle, this updates the dimensions of it
        ///      with any grid snaps and returns a new rectangle.  If
        ///      no changes to the rectangle's size were needed, this
        ///      may return the same rectangle.
        /// </devdoc>
        public abstract Rectangle GetUpdatedRect(Rectangle orignalRect, Rectangle dragRect, bool updateSize);

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.MoveControls"]/*' />
        /// <devdoc>
        ///      Called when we need to move the controls on our frame while dragging.  This
        ///      can perform three operations:  It can update the current controls location,
        ///      it can commit the new controls (final move), and it can roll back a movement
        ///      to the beginning of the operation.
        /// </devdoc>
        private void MoveControls(object[] components, bool cancel, bool finalMove) {
            Control[] controls = dragControls;
            Rectangle offset = dragOffset;
            BoundsInfo[] bounds = originalCoords;
            Point adjustedLoc = new Point();

            // Erase the clipping and other state if this is the final move.
            //
            if (finalMove) {
                Cursor.Clip = Rectangle.Empty;
                dragOffset = Rectangle.Empty;
                dragControls = null;
                originalCoords = null;
            }

            // If we haven't started to move yet, there's nothing to do.
            //
            if (offset.IsEmpty) {
                return;
            }

            // Short circuit the work if we didn't move anything.
            // This will prevent a change notification for just
            // selecting components.
            //
            if (finalMove && offset.X == 0 && offset.Y == 0 && offset.Width == 0 && offset.Height == 0) {
                return;
            }

            // If cancel was specified, we must roll all controls back to their original positions.
            //
            if (cancel) {
                CancelControlMove(controls, bounds);
                return;
            }

            // We must keep track of the original coordinates of each control, just in case
            // the user cancels out of moving them.  So, we create a "BoundsInfo" object for
            // each control that saves this state.
            //
            if (originalCoords == null && !finalMove) {
                originalCoords = new BoundsInfo[controls.Length];
                for (int i = 0; i < controls.Length; i++) {
                    originalCoords[i] = new BoundsInfo(controls[i]);
                }
                bounds = originalCoords;
            }

            // Two passes here.  First pass suspends all parent layout and updates the
            // component positions.  Second pass re-enables layout.
            //
            for (int i = 0; i < controls.Length; i++) {
                Debug.Assert(controls[i] == GetControl((IComponent)components[i]), "Control->Component mapping is out of sync");

                Control parent = controls[i].Parent;

                // Suspend parent layout so that we don't continously re-arrange components
                // while we move.
                //
                if (parent != null) {
                    parent.SuspendLayout();
                }

                BoundsInfo ctlBounds = bounds[i];

                adjustedLoc.X = ctlBounds.lastRequestedX;
                adjustedLoc.Y = ctlBounds.lastRequestedY;

                if (!finalMove) {
                    ctlBounds.lastRequestedX += offset.X;
                    ctlBounds.lastRequestedY += offset.Y;
                    ctlBounds.lastRequestedWidth += offset.Width;
                    ctlBounds.lastRequestedHeight += offset.Height;
                }

                // Our "target" values are the ones we would like to set
                // the control to.  We may modify them if they would mke the control
                // size negative or zero, however.
                //
                int targetX = ctlBounds.lastRequestedX;
                int targetY = ctlBounds.lastRequestedY;
                int targetWidth = ctlBounds.lastRequestedWidth;
                int targetHeight = ctlBounds.lastRequestedHeight;

                Rectangle oldBounds = controls[i].Bounds;

                if ((rules & SelectionRules.Moveable) == 0) {
                    // We use the minimum size of either a grid snap or 1
                    //
                    Size minSize;

                    if (GetShouldSnapToGrid()) {
                        minSize = GetCurrentSnapSize();
                    }
                    else {
                        minSize = new Size(1, 1);
                    }

                    if (targetWidth < minSize.Width) {
                        targetWidth = minSize.Width;
                        targetX = oldBounds.X;
                    }

                    if (targetHeight < minSize.Height) {
                        targetHeight = minSize.Height;
                        targetY = oldBounds.Y;
                    }
                }
                
                //Bug #72905  <subhag> Form X,Y defaulted to (0,0)
                //
                
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                Debug.Assert(host != null, "No designer host");
                if (controls[i] == host.RootComponent) {
                    targetX = 0;
                    targetY = 0;
                }
                
                // Adjust our target dimensions by the grid snaps
                //
                Rectangle tempNewBounds = GetUpdatedRect(oldBounds, new Rectangle(targetX, targetY, targetWidth, targetHeight), true);
                Rectangle newBounds = oldBounds;
                
                // Now apply the correct values to newBounds -- we only want to apply the new value if our
                // selection rules dictate so.
                //
                if ((rules & SelectionRules.Moveable) != 0) {
                    newBounds.X = tempNewBounds.X;
                    newBounds.Y = tempNewBounds.Y;
                }
                else {
                    if ((rules & SelectionRules.TopSizeable) != 0) {
                        newBounds.Y = tempNewBounds.Y;
                        newBounds.Height = tempNewBounds.Height;
                    }
                    if ((rules & SelectionRules.BottomSizeable) != 0) {
                        newBounds.Height = tempNewBounds.Height;
                    }
                    if ((rules & SelectionRules.LeftSizeable) != 0) {
                        newBounds.X = tempNewBounds.X;
                        newBounds.Width = tempNewBounds.Width;
                    }
                    if ((rules & SelectionRules.RightSizeable) != 0) {
                        newBounds.Width = tempNewBounds.Width;
                    }
                }

                bool locChanged = (offset.X != 0 || offset.Y != 0);
                bool sizeChanged = (offset.Width != 0 || offset.Height != 0);

                // If both the location and size changed, attempt to update the control in
                // one step.  This will prevent flicker.
                //
                if (locChanged && sizeChanged) {

                    // We shouldn't care if we're directly manipulating the control or not during
                    // the move.  For perf, just call directly on the control.  For the final
                    // move, however, we must go through the property descriptor.
                    //
                    PropertyDescriptor boundsProp = TypeDescriptor.GetProperties(components[i])["Bounds"];

                    if (boundsProp != null && !boundsProp.IsReadOnly) {
                        if (finalMove) {
                            object component = components[i];
                            boundsProp.SetValue(component, newBounds);
                        }
                        else {
                            controls[i].Bounds = newBounds;
                        }

                        // Now reset the loc and size changed flags so
                        // we don't try to change again.
                        //
                        locChanged = sizeChanged = false;
                    }
                }

                // Adjust the location property with the new value.  ONLY do this if the offset
                // is nonzero, however.  Otherwise we may get round-off errors that can cause flicker.
                // Plus, why set the property if it shouldn't be?
                //
                if (locChanged) {

                    adjustedLoc.X = newBounds.X;
                    adjustedLoc.Y = newBounds.Y;

                    // We shouldn't care if we're directly manipulating the control or not during
                    // the move.  For perf, just call directly on the control.  For the final
                    // move, however, we must go through the property descriptor.
                    //
                    PropertyDescriptor locationProp = TypeDescriptor.GetProperties(components[i])["Location"];

                    if (locationProp != null && !locationProp.IsReadOnly) {
                        if (finalMove) {
                            object component = components[i];
                            locationProp.SetValue(component, adjustedLoc);
                        }
                        else {
                            controls[i].Location = adjustedLoc;
                        }
                    }
                }

                // Adjust the size property with the new value.  ONLY do this if the offset
                // is nonzero, however.  Otherwise we may get round-off errors that can cause flicker.
                // Plus, why set the property if it shouldn't be?
                //
                if (sizeChanged) {

                    // If you are tempted to hoist this "new" out of the loop, don't.  The undo
                    // unit below just holds a reference to it.
                    //
                    Size size = new Size(Math.Max(MinControlWidth, newBounds.Width), Math.Max(MinControlHeight,newBounds.Height));

                    PropertyDescriptor sizeProp = TypeDescriptor.GetProperties(components[i])["Size"];

                    if (sizeProp != null && !sizeProp.IsReadOnly) {
                        if (finalMove) {
                            object component = components[i];
                            sizeProp.SetValue(component, size);
                        }
                        else {
                            controls[i].Size = size;
                        }
                    }
                }
            }

            // Now resume the parent layouts
            //
            for (int i = 0; i < controls.Length; i++) {
                Control parent = controls[i].Parent;

                if (parent != null) {
                    parent.ResumeLayout();
                    parent.Update();
                }
                
                controls[i].Update();
            }
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.QueryBeginDrag"]/*' />
        /// <devdoc>
        ///     Queries to see if a drag operation
        ///     is valid on this handler for the given set of components.
        ///     If it returns true, BeginDrag will be called immediately after.
        /// </devdoc>
        public bool QueryBeginDrag(object[] components, SelectionRules rules, int initialX, int initialY){
            
            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (cs != null) {
                try {
                    if (components != null && components.Length > 0) {
                        foreach (object c in components) {
                            cs.OnComponentChanging(c, TypeDescriptor.GetProperties(c)["Location"]);
                            PropertyDescriptor sizeProp = TypeDescriptor.GetProperties(c)["Size"];

                            if (sizeProp != null && sizeProp.Attributes.Contains(DesignerSerializationVisibilityAttribute.Hidden)) {
                                sizeProp = TypeDescriptor.GetProperties(c)["ClientSize"];
                            }
                            cs.OnComponentChanging(c, sizeProp);
                        }
                    }
                    else {
                        cs.OnComponentChanging(GetComponent(), null);
                    }
                }
                catch(CheckoutException coEx){
                    if (coEx == CheckoutException.Canceled){
                            // cancel the drag.
                            return false;
                    }
                    throw coEx;
                }

            }
            return components != null && components.Length > 0;
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.SetCursor"]/*' />
        /// <devdoc>
        ///     Asks the handler to set the appropriate cursor
        /// </devdoc>
        public abstract void SetCursor();

        public virtual void OleDragEnter(DragEventArgs de){
        }

        public virtual void OleDragDrop(DragEventArgs de){
        }

        public virtual void OleDragOver(DragEventArgs de){
        }

        public virtual void OleDragLeave(){
        }

        /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.BoundsInfo"]/*' />
        /// <devdoc>
        ///     This class holds bounds information for controls that are being moved.
        /// </devdoc>
        private class BoundsInfo {
            public int X;                           // Original saved X
            public int Y;                           // Original saved Y
            public int Width;                       // Original saved width
            public int Height;                      // Original saved height
            public int lastRequestedX = -1;
            public int lastRequestedY = -1;
            public int lastRequestedWidth = -1;
            public int lastRequestedHeight = -1;

            /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.BoundsInfo.BoundsInfo"]/*' />
            /// <devdoc>
            ///     Creates and initializes a new BoundsInfo object.
            /// </devdoc>
            public BoundsInfo(Control control) {

                // get the size & loc from the props so the designers can adjust them.
                //
                PropertyDescriptor sizeProp = TypeDescriptor.GetProperties(control)["Size"];
                PropertyDescriptor locProp = TypeDescriptor.GetProperties(control)["Location"];

                Size sz;
                Point loc;

                if (sizeProp != null) {
                    sz = (Size)sizeProp.GetValue(control);
                }
                else {
                    sz = control.Size;
                }

                if (locProp != null) {
                    loc = (Point)locProp.GetValue(control);
                }
                else {
                    loc = control.Location;
                }

                X = loc.X;
                Y = loc.Y;
                Width = sz.Width;
                Height = sz.Height;
                lastRequestedX = X;
                lastRequestedY = Y;
                lastRequestedWidth = Width;
                lastRequestedHeight = Height;
            }

            /// <include file='doc\SelectionUIHandler.uex' path='docs/doc[@for="SelectionUIHandler.BoundsInfo.ToString"]/*' />
            /// <devdoc>
            ///     Overrides object ToString.
            /// </devdoc>
            public override string ToString() {
                return "{X=" + X.ToString() + ", Y=" + Y.ToString() + ", Width=" + Width.ToString() + ", Height=" + Height.ToString() + "}";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\tabpagedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabPageDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\TabPageDesigner.uex' path='docs/doc[@for="TabPageDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for tap page controls.  It inherits
    ///      from the base control designer and adds live hit testing
    ///      capabilites for the tree view control.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class TabPageDesigner : PanelDesigner {
    
         /// <include file='doc\TabPageDesigner.uex' path='docs/doc[@for="TabPageDesigner.CanBeParentedTo"]/*' />
         /// <devdoc>
        ///     Determines if the this designer can be parented to the specified desinger --
        ///     generally this means if the control for this designer can be parented into the
        ///     given ParentControlDesigner's designer.
        /// </devdoc>
        public override bool CanBeParentedTo(IDesigner parentDesigner) {
           return (parentDesigner is TabControlDesigner);
        }
        
        /// <include file='doc\TabPageDesigner.uex' path='docs/doc[@for="TabPageDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                Control ctl = Control;

                if (ctl.Parent is TabControl) {
                    rules &= ~SelectionRules.AllSizeable;
                }

                return rules;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\textboxbasedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBoxBaseDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\TextBoxBaseDesigner.uex' path='docs/doc[@for="TextBoxBaseDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend TextBoxBase.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class TextBoxBaseDesigner : ControlDesigner {

        private EventHandler autoSizeChanged = null; // Delegate used to dirty the selectionUIItem when needed.
        private EventHandler multiLineChanged = null; // Delegate used to dirty the selectionUIItem when needed.
        
        /// <include file='doc\TextBoxBaseDesigner.uex' path='docs/doc[@for="TextBoxBaseDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                object component = Component;

                PropertyDescriptor propAutoSize = TypeDescriptor.GetProperties(component)["AutoSize"];
                if (propAutoSize != null) {
                    bool autoSize = (bool)propAutoSize.GetValue(component);

                    // Fix for multiline text boxes - ignore the autoSize property for multiline text boxes                                                                                                      
                    //
                    PropertyDescriptor propMultiline = TypeDescriptor.GetProperties(component)["Multiline"];
                    bool multiline = false;
                    if (propMultiline != null) {
                        multiline = (bool)propMultiline.GetValue(component);
                    }

                    if (autoSize && !multiline)
                        rules &= ~(SelectionRules.TopSizeable | SelectionRules.BottomSizeable);
                }

                return rules;
            }
        }
        
        private string Text {
            get {
                return Control.Text;
            }
            set {
                Control.Text = value;
                
                // This fixes bug #48462. If the text box is not wide enough to display all of the text,
                // then we want to display the first portion at design-time. We can ensure this by
                // setting the selection to (0, 0).
                //
                ((TextBoxBase)Control).Select(0, 0);    
            }
        }        
        
        /// <include file='doc\TextBoxBaseDesigner.uex' path='docs/doc[@for="TextBoxBaseDesigner.Dispose"]/*' />
        /// <devdoc>
        ///      Disposes of this object.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
                if (autoSizeChanged != null)
                    ((TextBoxBase)Control).AutoSizeChanged -= autoSizeChanged;
                if (multiLineChanged != null)
                    ((TextBoxBase)Control).MultilineChanged -= multiLineChanged;
            }
    
            base.Dispose(disposing);
        }

        /// <include file='doc\TextBoxBaseDesigner.uex' path='docs/doc[@for="TextBoxBaseDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            // Hook up the property change notification so that we can dirty the SelectionUIItem when needed.
            autoSizeChanged = new EventHandler(this.OnControlPropertyChanged);
            ((TextBoxBase)Control).AutoSizeChanged += autoSizeChanged;
        
            multiLineChanged = new EventHandler(this.OnControlPropertyChanged);
            ((TextBoxBase)Control).MultilineChanged += multiLineChanged;
        }

        /// <include file='doc\TextBoxBaseDesigner.uex' path='docs/doc[@for="TextBoxBaseDesigner.OnControlPropertyChanged"]/*' />
        /// <devdoc>
        ///      For controls, we sync their property changed event so our component can track their location.
        /// </devdoc>
        private void OnControlPropertyChanged(object sender, EventArgs e) {
            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));

            if (selectionUISvc != null) {
                selectionUISvc.SyncComponent((IComponent)sender);
            }
        }
        
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            
            PropertyDescriptor prop;


            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                "Text",
            };

            Attribute[] empty = new Attribute[0];

            for (int i = 0; i < shadowProps.Length; i++) {
                prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(TextBoxBaseDesigner), prop, empty);
                }
            }
        }              
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\toolbarbuttondesigner.cs ===
// <copyright file="ToolBarButtonDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\ToolBarButtonDesigner.uex' path='docs/doc[@for="ToolBarButtonDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for ToolBarButton controls.  It inherits
    ///      from the base Component designer and overrides the OnSetComponentDefaults
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ToolBarButtonDesigner : ComponentDesigner {
    
        /// <include file='doc\ToolBarButtonDesigner.uex' path='docs/doc[@for="ToolBarButtonDesigner.OnSetComponentDefaults"]/*' />
        /// <devdoc>
        ///     Raises the SetComponentDefault event
        /// </devdoc>
        public override void OnSetComponentDefaults() {
            }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\tabcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Windows.Forms.Design {

    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Collections;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;
    
    /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner"]/*' />
    /// <devdoc>
    ///      This designer handles the tab control.  It provides a design time way to add and
    ///      remove tabs as well as tab hit testing logic.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class TabControlDesigner : ParentControlDesigner {

        private bool tabControlSelected = false;    //used for HitTest logic
        private DesignerVerbCollection verbs;
        private DesignerVerb removeVerb;
        private bool         disableDrawGrid = false;

        // Shadow SelectedIndex property so we separate the persisted value shown in the 
        // properties window from the visible selected page the user is currently working on.
        private int persistedSelectedIndex = 0;
        
        protected override bool DrawGrid {
             get {
                 if (disableDrawGrid) {
                     return false;
                 }
                 return base.DrawGrid;
             }
        }
        
        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.SelectedIndex"]/*' />
        /// <devdoc>
        ///     Accessor method for the SelectedIndex property on TabControl.  We shadow
        ///     this property at design time.
        /// </devdoc>
        private int SelectedIndex {
            get {
                return persistedSelectedIndex;
            }
            set {
                // TabBase.SelectedIndex has no validation logic, so neither do we
                persistedSelectedIndex = value;
            }
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.Verbs"]/*' />
        /// <devdoc>
        ///     Returns the design-time verbs supported by the component associated with
        ///     the customizer. The verbs returned by this method are typically displayed
        ///     in a right-click menu by the design-time environment. The return value may
        ///     be null if the component has no design-time verbs. When a user selects one
        ///     of the verbs, the performVerb() method is invoked with the the
        ///     corresponding DesignerVerb object.
        ///     NOTE: A design-time environment will typically provide a "Properties..."
        ///     entry on a component's right-click menu. The getVerbs() method should
        ///     therefore not include such an entry in the returned list of verbs.
        /// </devdoc>
        public override DesignerVerbCollection Verbs {
            get {
                if (verbs == null) {

                    removeVerb = new DesignerVerb(SR.GetString(SR.TabControlRemove), new EventHandler(this.OnRemove));
                    
                    verbs = new DesignerVerbCollection();
                    verbs.Add(new DesignerVerb(SR.GetString(SR.TabControlAdd), new EventHandler(this.OnAdd)));
                    verbs.Add(removeVerb);
                }

                removeVerb.Enabled = Control.Controls.Count > 0;
                return verbs;
            }
        }
        
        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.CanParent"]/*' />
        /// <devdoc>
        ///     Determines if the this designer can parent to the specified desinger --
        ///     generally this means if the control for this designer can parent the
        ///     given ControlDesigner's designer.
        /// </devdoc>
        public override bool CanParent(Control control) {
            return (control is TabPage);
        }
        
        private void CheckVerbStatus() {
            if (removeVerb != null) {
                removeVerb.Enabled = Control.Controls.Count > 0;
            }
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.Dispose"]/*' />
        /// <devdoc>
        ///     Disposes of this designer.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                ISelectionService svc = (ISelectionService)GetService(typeof(ISelectionService));
                if (svc != null) {
                    svc.SelectionChanged -= new EventHandler(this.OnSelectionChanged);
                }


                IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentChanging -= new ComponentChangingEventHandler(this.OnComponentChanging);
                    cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                }
            }

            base.Dispose(disposing);
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.GetHitTest"]/*' />
        /// <devdoc>
        ///     Allows your component to support a design time user interface.  A TabStrip
        ///     control, for example, has a design time user interface that allows the user
        ///     to click the tabs to change tabs.  To implement this, TabStrip returns
        ///     true whenever the given point is within its tabs.
        /// </devdoc>
        protected override bool GetHitTest(Point point) {
            TabControl tc = ((TabControl)Control);            

            // tabControlSelected tells us if a tab page or the tab control itself is selected.
            // If the tab control is selected, then we need to return true from here - so we can switch back and forth
            // between tabs.  If we're not currently selected, we want to select the tab control
            // so return false.
            if (tabControlSelected) {
                NativeMethods.TCHITTESTINFO tcInfo = new NativeMethods.TCHITTESTINFO();
                tcInfo.pt = Control.PointToClient(point);;
                UnsafeNativeMethods.SendMessage(Control.Handle, NativeMethods.TCM_HITTEST, 0, tcInfo);
                return tcInfo.flags != NativeMethods.TabControlHitTest.TCHT_NOWHERE;
            }
            return false;
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.GetTabPageOfComponent"]/*' />
        /// <devdoc>
        ///     Given a component, this retrieves the tab page that it's parented to, or
        ///     null if it's not parented to any tab page.
        /// </devdoc>
        internal static TabPage GetTabPageOfComponent(object comp) {
            if (!(comp is Control)) {
                return null;
            }

            Control c = (Control)comp;
            while (c != null && !(c is TabPage)) {
                c = c.Parent;
            }
            return(TabPage)c;
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///     Called by the host when we're first initialized.
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            Debug.Assert(component is TabControl, "Component must be a tab control, it is a: "+component.GetType().FullName);

            ISelectionService svc = (ISelectionService)GetService(typeof(ISelectionService));
            if (svc != null) {
                svc.SelectionChanged += new EventHandler(this.OnSelectionChanged);
            }

            IComponentChangeService cs = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentChanging += new ComponentChangingEventHandler(this.OnComponentChanging);
                cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }

            ((TabControl)component).SelectedIndexChanged += new EventHandler(this.OnTabSelectedIndexChanged);
            ((TabControl)component).GotFocus += new EventHandler(this.OnGotFocus);
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.OnAdd"]/*' />
        /// <devdoc>
        ///      Called in response to a verb to add a tab.  This adds a new
        ///      tab with a default name.
        /// </devdoc>
        private void OnAdd(object sender, EventArgs eevent) {
            TabControl tc = (TabControl)Component;
            // member is OK to be null...
            //
            MemberDescriptor member = TypeDescriptor.GetProperties(Component)["Controls"];
            
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                
                DesignerTransaction t = null;
                try {
                    try {
                        t = host.CreateTransaction(SR.GetString(SR.TabControlAddTab, Component.Site.Name));

                        RaiseComponentChanging(member);
                    }
                    catch(CheckoutException ex) {
                        if (ex == CheckoutException.Canceled) {
                            return;
                        }
                        throw ex;
                    }
                    
                    TabPage page = (TabPage)host.CreateComponent(typeof(TabPage));
            
                    string pageText = null;
            
                    PropertyDescriptor nameProp = TypeDescriptor.GetProperties(page)["Name"];
                    if (nameProp != null && nameProp.PropertyType == typeof(string)) {
                        pageText = (string)nameProp.GetValue(page);
                    }
            
                    if (pageText != null) {
                        page.Text = pageText;
                    }
                    
                    tc.Controls.Add(page);
                    
                    RaiseComponentChanged(member, null, null);
                }
                finally {
                    if (t != null)
                        t.Commit();
                }
            }
        }

        private void OnComponentChanging(object sender, ComponentChangingEventArgs e) {
            if (e.Component == Component && e.Member != null && e.Member.Name == "TabPages") {
                PropertyDescriptor controlsProp = TypeDescriptor.GetProperties(Component)["Controls"];
                RaiseComponentChanging(controlsProp);
            }
        }


        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            if (e.Component == Component && e.Member != null && e.Member.Name == "TabPages") {
                PropertyDescriptor controlsProp = TypeDescriptor.GetProperties(Component)["Controls"];
                RaiseComponentChanging(controlsProp);
            }
            CheckVerbStatus();
        }


        private void OnGotFocus(object sender, EventArgs e) {
            IEventHandlerService eventSvc = (IEventHandlerService)GetService(typeof(IEventHandlerService));
            if (eventSvc != null) {
                Control focusWnd = eventSvc.FocusWindow;
                if (focusWnd != null) {
                    focusWnd.Focus();
                }
            }
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.OnRemove"]/*' />
        /// <devdoc>
        ///      This is called in response to a verb to remove a tab.  It removes
        ///      the current tab.
        /// </devdoc>
        private void OnRemove(object sender, EventArgs eevent) {
            TabControl tc = (TabControl)Component;

            // if the control is null, or there are not tab pages, get out!...
            //
            if (tc == null || tc.TabPages.Count == 0) {
                return;
            }

            // member is OK to be null...
            //
            MemberDescriptor member = TypeDescriptor.GetProperties(Component)["Controls"];
            
            TabPage tp    = tc.SelectedTab;

            // destroy the page
            //
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                DesignerTransaction t = null;
                try {
                    try {
                        t = host.CreateTransaction(SR.GetString(SR.TabControlRemoveTab, ((IComponent)tp).Site.Name, Component.Site.Name));
                        RaiseComponentChanging(member);
                    }
                    catch(CheckoutException ex) {
                        if (ex == CheckoutException.Canceled) {
                            return;
                        }
                        throw ex;
                    } 
                    
                    host.DestroyComponent(tp);

                    RaiseComponentChanged(member, null, null);
                }
                finally {
                    if (t != null)
                        t.Commit();
                }
            }
        }
        
        
        protected override void OnPaintAdornments(PaintEventArgs pe) {
            try {
               this.disableDrawGrid = true;
            
                // we don't want to do this for the tab control designer
                // because you can't drag anything onto it anyway.
                // so we will always return false for draw grid.
                base.OnPaintAdornments(pe);
                
            }
            finally {
               this.disableDrawGrid = false;
            }
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.OnSelectionChanged"]/*' />
        /// <devdoc>
        ///      Called when the current selection changes.  Here we check to
        ///      see if the newly selected component is one of our tabs.  If it
        ///      is, we make sure that the tab is the currently visible tab.
        /// </devdoc>
        private void OnSelectionChanged(Object sender, EventArgs e) {
            ISelectionService svc = (ISelectionService)GetService( typeof(ISelectionService) );

            tabControlSelected = false;//this is for HitTest purposes

            if (svc != null) {
                ICollection selComponents = svc.GetSelectedComponents();

                TabControl tabControl = (TabControl)Component;
                
                foreach(object comp in selComponents) {

                    if (comp == tabControl) {
                        tabControlSelected = true;//this is for HitTest purposes
                    }

                    TabPage page = GetTabPageOfComponent(comp);

                    if (page != null && page.Parent == tabControl) {
                        tabControlSelected = false; //this is for HitTest purposes
                        tabControl.SelectedTab = page;
                        break;
                    }
                }
            }
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.OnTabSelectedIndexChanged"]/*' />
        /// <devdoc>
        ///      Called when the selected tab changes.  This accesses the design
        ///      time selection service to surface the new tab as the current
        ///      selection.
        /// </devdoc>
        private void OnTabSelectedIndexChanged(Object sender, EventArgs e) {

            // if this was called as a result of a prop change, don't set the
            // selection to the control (causes flicker)
            //
            // Attempt to select the tab control
            ISelectionService svc = (ISelectionService)GetService(typeof(ISelectionService));
            if (svc != null) {
                ICollection selComponents = svc.GetSelectedComponents();

                TabControl tabControl = (TabControl)Component;
                bool selectedComponentOnTab = false;

                foreach(object comp in selComponents) {
                    TabPage page = GetTabPageOfComponent(comp);
                    if (page != null && page.Parent == tabControl && page == tabControl.SelectedTab) {
                        selectedComponentOnTab = true;
                        break;
                    }
                }

                if (!selectedComponentOnTab) {
                    svc.SetSelectedComponents(new Object[] {Component});
                }
            }
        }

        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                "SelectedIndex",
            };

            Attribute[] empty = new Attribute[0];

            for (int i = 0; i < shadowProps.Length; i++) {
                PropertyDescriptor prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(TabControlDesigner), prop, empty);
                }
            }
        }

        /// <include file='doc\TabControlDesigner.uex' path='docs/doc[@for="TabControlDesigner.WndProc"]/*' />
        /// <devdoc>
        ///      Overrides control designer's wnd proc to handle HTTRANSPARENT.
        /// </devdoc>
        protected override void WndProc(ref Message m) {
            switch (m.Msg) {
                case NativeMethods.WM_NCHITTEST:
                    // The tab control always fires HTTRANSPARENT in empty areas, which
                    // causes the message to go to our parent.  We want
                    // the tab control's designer to get these messages, however,
                    // so change this.
                    //
                    base.WndProc(ref m);
                    if ((int)m.Result == NativeMethods.HTTRANSPARENT) {
                        m.Result = (IntPtr)NativeMethods.HTCLIENT;
                    }
                    break;

                default:
                    base.WndProc(ref m);
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\toolbardesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolBarDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel.Design;
    using System.Windows.Forms;
    using System.Collections;

    /// <summary>
    ///      This class handles all design time behavior for the status bar class.    
    /// </summary>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ToolBarDesigner : ControlDesigner {

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.AssociatedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a list of assosciated components.  These are components that should be incluced in a cut or copy operation on this component.
        ///    </para>
        /// </devdoc>
        public override ICollection AssociatedComponents{
            get {
                ToolBar tb = Control as ToolBar;
                if (tb != null) {
                    return tb.Buttons;
                }
                return base.AssociatedComponents;
            }
        }
        
        /// <include file='doc\ToolBarBaseDesigner.uex' path='docs/doc[@for="ToolBarBaseDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                object component = Component;
                
                PropertyDescriptor propDock = TypeDescriptor.GetProperties(component)["Dock"];
                PropertyDescriptor propAutoSize = TypeDescriptor.GetProperties(component)["AutoSize"];
                if (propDock != null && propAutoSize != null) {
                    DockStyle dock = (DockStyle)propDock.GetValue(component);
                    bool autoSize = (bool)propAutoSize.GetValue(component);
                    if (autoSize) {
                        rules &= ~(SelectionRules.TopSizeable | SelectionRules.BottomSizeable);
                        if (dock != DockStyle.None) {
                            rules &= ~SelectionRules.AllSizeable;
                        }
                    }
                }
                return rules;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\trackbardesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TrackBarDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\TrackBarDesigner.uex' path='docs/doc[@for="TrackBarDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend TrackBar.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class TrackBarDesigner : ControlDesigner {

        /// <include file='doc\TrackBarDesigner.uex' path='docs/doc[@for="TrackBarDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                object component = Component;

                PropertyDescriptor propAutoSize = TypeDescriptor.GetProperties(component)["AutoSize"];
                if (propAutoSize != null) {
                    bool autoSize = (bool)propAutoSize.GetValue(component);

                    PropertyDescriptor propOrientation = TypeDescriptor.GetProperties(component)["Orientation"];
                    Orientation or = Orientation.Horizontal;
                    if (propOrientation != null) {
                        or = (Orientation)propOrientation.GetValue(component);
                    }
                    
                    if (autoSize) {
                        if (or == Orientation.Horizontal) {
                            rules &= ~(SelectionRules.TopSizeable | SelectionRules.BottomSizeable);
                        }
                        else if (or == Orientation.Vertical) {
                            rules &= ~(SelectionRules.LeftSizeable | SelectionRules.RightSizeable);
                        }
                    }
                }

                return rules;
            }
        }
        
        /// <include file='doc\TrackBarDesigner.uex' path='docs/doc[@for="TrackBarDesigner.OnControlPropertyChanged"]/*' />
        /// <devdoc>
        ///      For controls, we sync their property changed event so our component can track their location.
        /// </devdoc>
        private void OnControlPropertyChanged(object sender, EventArgs e) {
            ISelectionUIService selectionUISvc = (ISelectionUIService)GetService(typeof(ISelectionUIService));

            if (selectionUISvc != null) {
                selectionUISvc.SyncComponent((IComponent)sender);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\taborder.cs ===
//------------------------------------------------------------------------------
// <copyright file="TabOrder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Windows.Forms;

    /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder"]/*' />
    /// <devdoc>
    ///     This class encapsulates the tab order UI for our form designer.
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false),
    DesignTimeVisible(false)
    ]
    internal class TabOrder : Control, IMouseHandler, IMenuStatusHandler {
        private IDesignerHost   host;
        private Control         ctlHover;
        private ArrayList      tabControls;
        private Rectangle[]     tabGlyphs;
        private ArrayList      tabComplete;
        private Hashtable       tabNext;
        private Font            tabFont;
        private StringBuilder   drawString;
        private Brush           highlightTextBrush;
        private Pen             highlightPen;
        private int             selSize;
        private Hashtable       tabProperties;
        private Region          region = null;
        private MenuCommand[]   commands;
        private MenuCommand[]   newCommands;
        private string          decimalSep;

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.TabOrder"]/*' />
        /// <devdoc>
        ///     Creates a new tab order control that displays the tab order
        ///     UI for a form.
        /// </devdoc>
        public TabOrder(IDesignerHost host) {
            this.host = host;

            // Determine a font for us to use.
            //
            IUIService uisvc = (IUIService)host.GetService(typeof(IUIService));
            if (uisvc != null) {
                tabFont = (Font)uisvc.Styles["DialogFont"];
            }
            else {
                tabFont = Control.DefaultFont;
            }
            tabFont = new Font(tabFont, FontStyle.Bold);

            // And compute the proper highlight dimensions.
            //
            ISelectionUIService seluisvc = (ISelectionUIService)host.GetService(typeof(ISelectionUIService));
            if (seluisvc != null) {
                selSize = seluisvc.GetAdornmentDimensions(AdornmentType.GrabHandle).Width;
                seluisvc.Visible = false;
            }
            else {
                selSize = 7;
            }

            // Colors and brushes...
            //
            drawString  = new StringBuilder(12);
            highlightTextBrush = new SolidBrush(SystemColors.HighlightText);
            highlightPen = new Pen(SystemColors.Highlight);
            
            // The decimal separator
            //
            NumberFormatInfo formatInfo = (NumberFormatInfo)CultureInfo.CurrentCulture.GetFormat(typeof(NumberFormatInfo));
            if (formatInfo != null) {
                decimalSep = formatInfo.NumberDecimalSeparator;
            }
            else {
                decimalSep = ".";
            }
            

            tabProperties = new Hashtable();

            // Set up a NULL brush so we never try to invalidate the control.  This is
            // more efficient for what we're doing
            //
            SetStyle(ControlStyles.Opaque, true);

            // We're an overlay on top of the form
            //
            IOverlayService os = (IOverlayService)host.GetService(typeof(IOverlayService));
            Debug.Assert(os != null, "No overlay service -- tab order UI cannot be shown");
            if (os != null) {
                os.PushOverlay(this);
            }

            // Push a help keyword so the help system knows we're in place.
            //
            IHelpService hs = (IHelpService)host.GetService(typeof(IHelpService));
            if (hs != null) {
                hs.AddContextAttribute("Keyword", "TabOrderView", HelpKeywordType.FilterKeyword);
            }

            commands = new MenuCommand[] {
                new MenuCommand(new EventHandler(OnKeyCancel),
                                MenuCommands.KeyCancel),

                new MenuCommand(new EventHandler(OnKeyDefault),
                                MenuCommands.KeyDefaultAction),

                new MenuCommand(new EventHandler(OnKeyPrevious),
                                MenuCommands.KeyMoveUp),

                new MenuCommand(new EventHandler(OnKeyNext),
                                MenuCommands.KeyMoveDown),

                new MenuCommand(new EventHandler(OnKeyPrevious),
                                MenuCommands.KeyMoveLeft),

                new MenuCommand(new EventHandler(OnKeyNext),
                                MenuCommands.KeyMoveRight),

                new MenuCommand(new EventHandler(OnKeyNext),
                                MenuCommands.KeySelectNext),

                new MenuCommand(new EventHandler(OnKeyPrevious),
                                MenuCommands.KeySelectPrevious),
            };
            
            newCommands = new MenuCommand[] {
                new MenuCommand(new EventHandler(OnKeyDefault),
                                MenuCommands.KeyTabOrderSelect),
            };
            
            IMenuCommandService mcs = (IMenuCommandService)host.GetService(typeof(IMenuCommandService));
            if (mcs != null) {
                foreach(MenuCommand mc in newCommands) {
                    mcs.AddCommand(mc);
                }
            }

            // We also override keyboard, menu and mouse handlers.  Our override relies on the
            // above array of menu commands, so this must come after we initialize the array.
            //
            IEventHandlerService ehs = (IEventHandlerService)host.GetService(typeof(IEventHandlerService));
            if (ehs != null) {
                ehs.PushHandler(this);
            }
            
            // We sync add, remove and change events so we remain in sync with any nastiness that the
            // form may pull on us.
            //
            IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
            if (cs != null) {
                cs.ComponentAdded += new ComponentEventHandler(this.OnComponentAddRemove);
                cs.ComponentRemoved += new ComponentEventHandler(this.OnComponentAddRemove);
                cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.Dispose"]/*' />
        /// <devdoc>
        ///     Called when it is time for the tab order UI to go away.
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (region != null) {
                    region.Dispose();
                    region = null;
                }

                if (host != null) {
                    IOverlayService os = (IOverlayService)host.GetService(typeof(IOverlayService));
                    if (os != null) {
                        os.RemoveOverlay(this);
                    }

                    IEventHandlerService ehs = (IEventHandlerService)host.GetService(typeof(IEventHandlerService));
                    if (ehs != null) {
                        ehs.PopHandler(this);
                    }

                    IMenuCommandService mcs = (IMenuCommandService)host.GetService(typeof(IMenuCommandService));
                    if (mcs != null) {
                        foreach(MenuCommand mc in newCommands) {
                            mcs.RemoveCommand(mc);
                        }
                    }

                    ISelectionUIService seluisvc = (ISelectionUIService)host.GetService(typeof(ISelectionUIService));
                    if (seluisvc != null) {
                        seluisvc.Visible = true;
                    }

                    // We sync add, remove and change events so we remain in sync with any nastiness that the
                    // form may pull on us.
                    //
                    IComponentChangeService cs = (IComponentChangeService)host.GetService(typeof(IComponentChangeService));
                    if (cs != null) {
                        cs.ComponentAdded -= new ComponentEventHandler(this.OnComponentAddRemove);
                        cs.ComponentRemoved -= new ComponentEventHandler(this.OnComponentAddRemove);
                        cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                    }

                    IHelpService hs = (IHelpService)host.GetService(typeof(IHelpService));
                    if (hs != null) {
                        hs.RemoveContextAttribute("Keyword", "TabOrderView");
                    }

                    host = null;
                }
            }
            base.Dispose(disposing);
        }
        
        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.DrawTabs"]/*' />
        /// <devdoc>
        ///     this function does double duty:  it draws the tabs if fRegion is false, or it
        ///     computes control region rects if fRegion is true (both require that we essentially
        ///     "draw" the tabs)
        /// </devdoc>
        private void DrawTabs(IList tabs, Graphics gr, bool fRegion) {
            IEnumerator e = tabs.GetEnumerator();
            int         iCtl = 0;
            Control     ctl;
            Control     parent;
            Rectangle   rc = Rectangle.Empty;
            Size        sz = Size.Empty;
            string      str;

            Font font = tabFont;

            if (fRegion) {
                region = new Region(new Rectangle(0, 0, 0, 0));
            }

            if (ctlHover != null) {
                Rectangle ctlInner = GetConvertedBounds(ctlHover);
                Rectangle ctlOuter = ctlInner;
                ctlOuter.Inflate(selSize, selSize);

                if (fRegion) {
                    region = new Region(ctlOuter);
                    region.Exclude(ctlInner);
                }
                else {
                    Control p = ctlHover.Parent;
                    Color backColor;
                    backColor = p.BackColor;

                    Region clip = gr.Clip;
                    gr.ExcludeClip(ctlInner);
                    gr.FillRectangle(new SolidBrush(backColor), ctlOuter);

                    ControlPaint.DrawSelectionFrame(gr, false, ctlOuter, ctlInner, backColor);
                    gr.Clip = clip;
                }
            }

            while (e.MoveNext()) {
                ctl = (Control)e.Current;
                rc = GetConvertedBounds(ctl);

                drawString.Length = 0;

                parent = GetSitedParent(ctl);
                Control baseControl = (Control)host.RootComponent;

                while (parent != baseControl && parent != null) {
                    drawString.Insert(0, decimalSep);
                    drawString.Insert(0, parent.TabIndex.ToString());
                    parent = GetSitedParent(parent);
                }

                drawString.Insert(0, ' ');
                drawString.Append(ctl.TabIndex.ToString());
                drawString.Append(' ');

                if (((PropertyDescriptor)tabProperties[ctl]).IsReadOnly) {
                    drawString.Append(SR.GetString(SR.WindowsFormsTabOrderReadOnly));
                    drawString.Append(' ');
                }

                str = drawString.ToString();
                sz = Size.Ceiling(gr.MeasureString(str, font));
                rc.Width = sz.Width + 2;
                rc.Height = sz.Height + 2;
                
                tabGlyphs[iCtl++] = rc;

                Brush brush;
                Pen pen;
                Color textColor;
                if (fRegion) {
                    region.Union(rc);
                }
                else {
                    if (tabComplete.IndexOf(ctl)!=-1) {
                        brush = highlightTextBrush;
                        pen = highlightPen;
                        textColor = SystemColors.Highlight;
                    }
                    else {
                        brush = SystemBrushes.Highlight;
                        pen = SystemPens.HighlightText;
                        textColor = SystemColors.HighlightText;
                    }

                    gr.FillRectangle(brush, rc);
                    gr.DrawRectangle(pen, rc.X, rc.Y, rc.Width - 1, rc.Height - 1);

                    Brush foreBrush = new SolidBrush(textColor);
                    gr.DrawString(str, font, foreBrush, rc.X + 1, rc.Y + 1);
                    foreBrush.Dispose();
                }
            }
            if (fRegion) {
                ctl = (Control)host.RootComponent;
                rc = GetConvertedBounds(ctl);
                region.Intersect(rc);
                Region = region;
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.GetControlAtPoint"]/*' />
        /// <devdoc>
        ///     returns a control in the given tab vector that is at the given point, in
        ///     screen coords.
        /// </devdoc>
        private Control GetControlAtPoint(IList tabs, int x, int y) {
            IEnumerator e = tabs.GetEnumerator();
            Rectangle   rc;
            Control      ctlFound = null;
            Control      ctl;
            Control      parent;

            while (e.MoveNext()) {
                ctl = (Control)e.Current;
                parent = GetSitedParent(ctl);
                rc = ctl.Bounds;
                rc = parent.RectangleToScreen(rc);

                // We do not break if we find it here.  The vector is already setup
                // to have all controls in the current tabbing order, and child controls
                // are always after their parents.  If we broke, we wouldn't necessarially
                // find the appropriate child.
                //
                if (rc.Contains(x, y)) {
                    ctlFound = ctl;
                }
            }
            return ctlFound;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.GetConvertedBounds"]/*' />
        /// <devdoc>
        ///     returns a rectangle in our own client space that represents the bounds
        ///     if the given control
        /// </devdoc>
        private Rectangle GetConvertedBounds(Control ctl) {
            Control parent = ctl.Parent;
            Rectangle rc = ctl.Bounds;
            rc = parent.RectangleToScreen(rc);
            rc = RectangleToClient(rc);
            return rc;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.GetMaxControlCount"]/*' />
        /// <devdoc>
        ///     returns the maximum valid control count for the given control.  This
        ///     may be less than Control.getControlCount() because of invisible controls
        ///     and our own control
        /// </devdoc>
        private int GetMaxControlCount(Control ctl) {
            int count = 0;

            for (int n = 0; n < ctl.Controls.Count; n++) {
                if (GetTabbable(ctl.Controls[n])) {
                    count++;
                }
            }
            return count;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.GetSitedParent"]/*' />
        /// <devdoc>
        ///     Retrieves the next parent control that would be usable
        ///     by the tab order UI.  We only want parents that are
        ///     sited by the designer host.
        /// </devdoc>
        private Control GetSitedParent(Control child) {
            Control parent = child.Parent;

            while (parent != null) {
                ISite site = parent.Site;
                if (site != null && site.Container == host) {
                    break;
                }
                parent = parent.Parent;
            }

            return parent;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.GetTabbing"]/*' />
        /// <devdoc>
        ///     recursively fills the given tab vector with a control list
        /// </devdoc>
        private void GetTabbing(Control ctl, IList tabs) {
            Control ctlTab;
            
            // Now actually count the controls.  We add them to the list in reverse
            // order because the Controls collection is in z-order, and our list
            // needs to be in reverse z-order.  When done, we want this list to be
            // in z-order from back-most to top-most, and from parent-most to 
            // child-most.
            //
            int cnt = ctl.Controls.Count;
            for (int i = cnt - 1; i >= 0; i--) {
                ctlTab = ctl.Controls[i];

                if (null != GetSitedParent(ctlTab) && GetTabbable(ctlTab)) {
                    tabs.Add(ctlTab);
                }

                if (ctlTab.Controls.Count > 0) {
                    GetTabbing(ctlTab, tabs);
                }
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.GetTabbable"]/*' />
        /// <devdoc>
        ///     returns true if this component should show up in our tab list
        /// </devdoc>
        private bool GetTabbable(Control control) {

            for (Control c = control; c != null; c = c.Parent) {
                if (!c.Visible)
                    return false;
            }

            ISite site = control.Site;
            if (site == null || site.Container != host) {
                return false;
            }

            PropertyDescriptor prop = TypeDescriptor.GetProperties(control)["TabIndex"];

            if (prop == null || !prop.IsBrowsable) {
                return false;
            }

            tabProperties[control] = prop;
            return true;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnComponentAddRemove"]/*' />
        /// <devdoc>
        ///     Called in response to a component add or remove event.  Here we re-aquire our
        ///     set of tabs.
        /// </devdoc>
        private void OnComponentAddRemove(object sender, ComponentEventArgs ce) {
            ctlHover = null;
            tabControls = null;
            tabGlyphs = null;
            
            if (tabComplete != null) {
                tabComplete.Clear();
            }
            if (tabNext != null) {
                tabNext.Clear();
            }
            if (region != null) {
                region.Dispose();
                region = null;
            }
            Invalidate();
        }
        
        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnComponentChanged"]/*' />
        /// <devdoc>
        ///      Called in response to a component change event.  Here we update our
        ///      tab order and redraw.
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs ce) {
            tabControls = null;
            tabGlyphs = null;
            if (region != null) {
                region.Dispose();
                region = null;
            }
            Invalidate();
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnKeyCancel"]/*' />
        /// <devdoc>
        ///      Closes the tab order UI.
        /// </devdoc>
        private void OnKeyCancel(object sender, EventArgs e) {
            IMenuCommandService mcs = (IMenuCommandService)host.GetService(typeof(IMenuCommandService));
            Debug.Assert(mcs != null, "No menu command service, can't get out of tab order UI");
            if (mcs != null) {
                MenuCommand mc = mcs.FindCommand(StandardCommands.TabOrder);
                Debug.Assert(mc != null, "No tab order menu command, can't get out of tab order UI");
                if (mc != null) {
                    mc.Invoke();
                }
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnKeyDefault"]/*' />
        /// <devdoc>
        ///      Sets the current tab order selection.
        /// </devdoc>
        private void OnKeyDefault(object sender, EventArgs e) {
            if (ctlHover != null) {
                SetNextTabIndex(ctlHover);
                RotateControls(true);
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnKeyNext"]/*' />
        /// <devdoc>
        ///      Selects the next component in the tab order.
        /// </devdoc>
        private void OnKeyNext(object sender, EventArgs e) {
            RotateControls(true);
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnKeyPrevious"]/*' />
        /// <devdoc>
        ///      Selects the previous component in the tab order.
        /// </devdoc>
        private void OnKeyPrevious(object sender, EventArgs e) {
            RotateControls(false);
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseDoubleClick"]/*' />
        /// <devdoc>
        ///     This is called when the user double clicks on a component.  The typical
        ///     behavior is to create an event handler for the component's default event
        ///     and nativagate to the handler.
        /// </devdoc>
        public virtual void OnMouseDoubleClick(IComponent component) {
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseDown"]/*' />
        /// <devdoc>
        ///     This is called when a mouse button is depressed.  This will perform
        ///     the default drag action for the selected components,  which is to
        ///     move those components around by the mouse.
        /// </devdoc>
        public virtual void OnMouseDown(IComponent component, MouseButtons button, int x, int y) {
            if (ctlHover != null) {
                SetNextTabIndex(ctlHover);
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseDown1"]/*' />
        /// <devdoc>
        ///     Overrides control.OnMouseDown.  Here we set the tab index.  We must
        ///     do this as well as the above OnMouseDown to take into account clicks
        ///     in the tab index numbers.
        /// </devdoc>
        protected override void OnMouseDown(MouseEventArgs e) {
            base.OnMouseDown(e);
            if (ctlHover != null) {
                SetNextTabIndex(ctlHover);
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseHover"]/*' />
        /// <devdoc>
        ///     This is called when the mouse momentarially hovers over the
        ///     view for the given component.
        /// </devdoc>
        public virtual void OnMouseHover(IComponent component) {
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseMove"]/*' />
        /// <devdoc>
        ///     This is called for each movement of the mouse.
        /// </devdoc>
        public virtual void OnMouseMove(IComponent component, int x, int y) {
            if (tabControls != null) {
                Control ctl = GetControlAtPoint(tabControls, x, y);
                SetNewHover(ctl);
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseMove1"]/*' />
        /// <devdoc>
        ///     Overrides control.  We update our cursor here.  We must do this
        ///     as well as the OnSetCursor to take into account mouse movements
        ///     over the tab index numbers.
        /// </devdoc>
        protected override void OnMouseMove(MouseEventArgs e) {
            base.OnMouseMove(e);
            
            if (tabGlyphs != null) {
            
                Control ctl = null;
                
                for(int i = 0; i < tabGlyphs.Length; i++) {
                    if (tabGlyphs[i].Contains(e.X, e.Y)) {
                        // Do not break if we find it -- we must
                        // work for nested children too.
                        ctl = (Control)tabControls[i];
                    }
                }
                
                SetNewHover(ctl);
            }

            if (ctlHover != null) {
                Cursor.Current = Cursors.Cross;
            }
            else {
                Cursor.Current = Cursors.Default;
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnMouseUp"]/*' />
        /// <devdoc>
        ///     This is called when the user releases the mouse from a component.
        ///     This will update the UI to reflect the release of the mouse.
        /// </devdoc>
        public virtual void OnMouseUp(IComponent component, MouseButtons button) {
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnSetCursor"]/*' />
        /// <devdoc>
        ///     This is called when the cursor for the given component should be updated.
        ///     The mouse is always over the given component's view when this is called.
        /// </devdoc>
        public virtual void OnSetCursor(IComponent component) {
            Cursor.Current = Cursors.Cross;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OnPaint"]/*' />
        /// <devdoc>
        ///     Paints the tab control.
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs e) {
            base.OnPaint(e);

            if (null == tabControls) {

                tabControls = new ArrayList();
                GetTabbing((Control)host.RootComponent, tabControls);
                tabGlyphs = new Rectangle[tabControls.Count];
            }
            if (null == tabComplete) {
                tabComplete = new ArrayList();
            }
            if (null == tabNext) {
                tabNext = new Hashtable();
            }
            if (null == region) {
                DrawTabs(tabControls, e.Graphics, true);
            }
            DrawTabs(tabControls, e.Graphics, false);
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OverrideInvoke"]/*' />
        /// <devdoc>
        ///     CommandSet will check with this handler on each status update
        ///     to see if the handler wants to override the availability of
        ///     this command.
        /// </devdoc>
        public bool OverrideInvoke(MenuCommand cmd) {
            for (int i = 0; i < commands.Length; i++) {
                if (commands[i].CommandID.Equals(cmd.CommandID)) {
                    commands[i].Invoke();
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.OverrideStatus"]/*' />
        /// <devdoc>
        ///     CommandSet will check with this handler on each status update
        ///     to see if the handler wants to override the availability of
        ///     this command.
        /// </devdoc>
        public bool OverrideStatus(MenuCommand cmd) {

            for (int i = 0; i < commands.Length; i++) {
                if (commands[i].CommandID.Equals(cmd.CommandID)) {
                    cmd.Enabled = commands[i].Enabled;
                    return true;
                }
            }

            // Overriding the status of commands is easy.  We only
            // get commands that the designer implements, so we don't
            // have to pick and choose which ones to get rid of.  We
            // keep a select view and disable the rest.
            //
            if (!cmd.CommandID.Equals(StandardCommands.TabOrder)) {
                cmd.Enabled = false;
                return true;
            }

            return false;
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.RotateControls"]/*' />
        /// <devdoc>
        ///     Called when the keyboard has been pressed to rotate us
        ///     through the control list.
        /// </devdoc>
        private void RotateControls(bool forward) {
            Control ctl = ctlHover;
            Control form = (Control)host.RootComponent;

            if (ctl == null) {
                ctl = form;
            }

            while (null != (ctl = form.GetNextControl(ctl, forward))) {
                if (GetTabbable(ctl))
                    break;
            }
            SetNewHover(ctl);
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.SetNewHover"]/*' />
        /// <devdoc>
        ///     Establishes a new hover control.
        /// </devdoc>
        private void SetNewHover(Control ctl) {

            if (ctlHover != ctl) {
                if (null != ctlHover) {
                    if (region != null) {
                        region.Dispose();
                        region = null;
                    }
                    Rectangle rc = GetConvertedBounds(ctlHover);
                    rc.Inflate(selSize, selSize);
                    Invalidate(rc);
                }

                ctlHover = ctl;

                if (null != ctlHover) {
                    if (region != null) {
                        region.Dispose();
                        region = null;
                    }
                    Rectangle rc = GetConvertedBounds(ctlHover);
                    rc.Inflate(selSize, selSize);
                    Invalidate(rc);
                }
            }
        }

        /// <include file='doc\TabOrder.uex' path='docs/doc[@for="TabOrder.SetNextTabIndex"]/*' />
        /// <devdoc>
        ///     sets up the next tab index for the given control
        /// </devdoc>
        private void SetNextTabIndex(Control ctl) {
            int index, max;
            Control parent = GetSitedParent(ctl);
            object nextIndex = tabNext[parent];

            if (tabComplete.IndexOf(ctl)==-1)
                tabComplete.Add(ctl);

            if (null != nextIndex)
                index = (int)nextIndex;
            else
                index = 0;

            try {
                PropertyDescriptor prop = (PropertyDescriptor)tabProperties[ctl];
                if (prop != null) {
                
                    int newIndex = index + 1;

                    if (prop.IsReadOnly) {
                        newIndex = (int)prop.GetValue(ctl) + 1;
                    }

                    max = GetMaxControlCount(parent);

                    if (newIndex >= max) {
                        newIndex = 0;
                    }

                    tabNext[parent] = newIndex;

                    if (tabComplete.Count == tabControls.Count)
                        tabComplete.Clear();
                        
                    // Now set the property
                    //
                    if (!prop.IsReadOnly) {
                        try {
                            prop.SetValue(ctl, index);
                        }
                        catch(Exception) {
                        }
                    }
                    else {
                        // If the property is read only, we still count it
                        // so that other properties can "flow" around it.
                        // Therefore, we need a paint.
                        //
                        Invalidate();
                    }
                }
            }
            catch (Exception) {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\usercontroldocumentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserControlDocumentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Collections;    
    using System.ComponentModel;
    using System.Runtime.Serialization;
    using System.Diagnostics;
    using System;    
    using System.Design;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Drawing.Design;
    using System.IO;
    using System.Windows.Forms;

    /// <include file='doc\UserControlDocumentDesigner.uex' path='docs/doc[@for="UserControlDocumentDesigner"]/*' />
    /// <devdoc>
    ///    <para>Provides a base implementation of a designer for user controls.</para>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItemFilter("System.Windows.Forms.UserControl", ToolboxItemFilterType.Custom),
    ToolboxItemFilter("System.Windows.Forms.MainMenu", ToolboxItemFilterType.Prevent)
    ]
    internal class UserControlDocumentDesigner : DocumentDesigner {
        private string fullClassName;

        private ToolboxItem toolboxItem;

        /// <devdoc>
        ///     On user controls, size == client size.  We do this so we can mess around
        ///     with the non-client area of the user control when editing menus and not
        ///     mess up the size property.
        /// </devdoc>
        private Size Size {
            get {
                return Control.ClientSize;
            }
            set {
                Control.ClientSize = value;
            }
        }
        internal override bool CanDropComponents(DragEventArgs de) {
            bool canDrop = base.CanDropComponents(de);

            if (canDrop) {
                // Figure out if any of the components in a main menu item.
                // We don't like main menus on UserControlDocumentDesigner.
                //
                OleDragDropHandler ddh = GetOleDragHandler();
                object[] dragComps = ddh.GetDraggingObjects(de);

                if (dragComps != null) {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    for (int  i = 0; i < dragComps.Length; i++) {
                        if (host == null || dragComps[i] == null || !(dragComps[i] is IComponent)) {
                            continue;
                        }

                        if (dragComps[i] is MainMenu)
                            return false;
                    }
                }
            }

            return canDrop;
        }

        protected override void Dispose(bool disposing) {

            if (disposing) {
                IComponentChangeService componentChangeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
                if (componentChangeService != null) {
                    componentChangeService.ComponentRename -= new ComponentRenameEventHandler(OnComponentRename);
                }
            }
            base.Dispose(disposing);
        }

        /// <include file='doc\UserControlDocumentDesigner.uex' path='docs/doc[@for="UserControlDocumentDesigner.GetToolSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the given tool is supported by this 
        ///       designer.</para>
        /// </devdoc>
        protected override bool GetToolSupported(ToolboxItem tool) {
            bool supported = base.GetToolSupported(tool);

            // If this tool is pointing to ourselves, it should be
            // disabled.
            //
            if (supported && fullClassName != null) {
                return !tool.TypeName.Equals(fullClassName);
            }

            return supported;
        }

        /// <include file='doc\UserControlDocumentDesigner.uex' path='docs/doc[@for="UserControlDocumentDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>Initializes the designer with the given component.</para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            // When the load is finished, we need to push a toolbox item into the toolbox for this
            // control.
            //
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null) {
                host.LoadComplete += new EventHandler(OnLoadComplete);
            }

            IComponentChangeService componentChangeService = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (componentChangeService != null) {
                componentChangeService.ComponentRename += new ComponentRenameEventHandler(OnComponentRename);
            }
        }

        private void OnComponentRename(object sender, ComponentRenameEventArgs e) {
            if (e.Component == Component) {
                UpdateToolboxItem((IDesignerHost)GetService(typeof(IDesignerHost)));
            }
        }
        
        private void OnLoadComplete(object sender, EventArgs e) {
        
            IDesignerHost host = (IDesignerHost)sender;
            host.LoadComplete -= new EventHandler(this.OnLoadComplete);
            
            UpdateToolboxItem(host);
        }
        
        /// <include file='doc\UserControlDocumentDesigner.uex' path='docs/doc[@for="UserControlDocumentDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///      Allows a designer to filter the set of properties
        ///      the component it is designing will expose through the
        ///      TypeDescriptor object.  This method is called
        ///      immediately before its corresponding "Post" method.
        ///      If you are overriding this method you should call
        ///      the base implementation before you perform your own
        ///      filtering.
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            PropertyDescriptor prop;
            
            base.PreFilterProperties(properties);
            
            // Handle shadowed properties
            //
            string[] shadowProps = new string[] {
                "Size"
            };
            
            Attribute[] empty = new Attribute[0];
            
            for (int i = 0; i < shadowProps.Length; i++) {
                prop = (PropertyDescriptor)properties[shadowProps[i]];
                if (prop != null) {
                    properties[shadowProps[i]] = TypeDescriptor.CreateProperty(typeof(UserControlDocumentDesigner), prop, empty);
                }
            }
        }

        private void UpdateToolboxItem(IDesignerHost host) {

            if (host == null) {
                throw new ArgumentNullException();
            }
            // Now get a hold of the toolbox service and add an icon for our user control.  The
            // toolbox service will automatically maintain this icon as long as our file lives.
            //
            IToolboxService tbx = (IToolboxService)GetService(typeof(IToolboxService));

            if (tbx != null) {
                fullClassName = host.RootComponentClassName;
                if (this.toolboxItem != null) {
                    tbx.RemoveToolboxItem(this.toolboxItem);    
                }
                this.toolboxItem = new UserControlToolboxItem(fullClassName);

                try {
                    tbx.AddLinkedToolboxItem(toolboxItem, SR.GetString(SR.UserControlTab), host);
                }
                catch(Exception ex) {
                    Debug.Fail("Failed to add toolbox item", ex.ToString());
                }
            }
        }

        
        /// <include file='doc\UserControlDocumentDesigner.uex' path='docs/doc[@for="UserControlDocumentDesigner.UserControlToolboxItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       This is the toolbox item we place
        ///       on the toolbox for user controls.</para>
        /// </devdoc>
        [ToolboxItemFilter("System.Windows.Forms.UserControl"), Serializable]
        internal class UserControlToolboxItem : ToolboxItem {
        
            public UserControlToolboxItem(string className) {
                TypeName = className;
                
                int idx = className.LastIndexOf('.');
                if (idx != -1) {
                    DisplayName = className.Substring(idx + 1);
                }
                else {
                    DisplayName = className;
                }
                
                Bitmap = new Bitmap(typeof(UserControlDocumentDesigner), "UserControlToolboxItem.bmp");
                Lock();
            }
            
            private UserControlToolboxItem(SerializationInfo info, StreamingContext context) {
                Deserialize(info, context);
            }
            
            protected override IComponent[] CreateComponentsCore(IDesignerHost host) {
                IComponent[] comps = base.CreateComponentsCore(host);
                if (comps == null || comps.Length == 0) {
                    throw new Exception(SR.GetString(SR.DesignerNoUserControl, TypeName));
                }
                return comps;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\sources.inc ===
!IF 0

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    place.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!include $(DNAROOT)\sources.inc


MITBASEDIR=$(DNAROOT)\src\mit

#
# Establish the default "includes" path.
#

MITINCLUDES=$(O);.\;
INCLUDES=$(MITINCLUDES);$(INCLUDES)

#
# Use Unicode
#

C_DEFINES=$(C_DEFINES) /DUNICODE /D_UNICODE

#
# We run on Windows 2000 and higher only
#
WIN32_WINNT_VERSION=0x0500
WIN32_WIN95_VERSION=0x0500
WIN32_IE_VERSION=0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\trayicondesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TrayIconDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.ComponentModel;
    using System;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Windows.Forms;

    /// <include file='doc\TrayIconDesigner.uex' path='docs/doc[@for="NotifyIconDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for OpenFileDialog components.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class NotifyIconDesigner : ComponentDesigner {
        public override void OnSetComponentDefaults() {
            base.OnSetComponentDefaults();
            NotifyIcon icon = (NotifyIcon) Component;
            icon.Visible = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\treeviewdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeViewDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    

    using System.Diagnostics;

    using System;
    using System.Design;
    using System.Drawing;
    using System.Windows.Forms;
    using Microsoft.Win32;

    /// <include file='doc\TreeViewDesigner.uex' path='docs/doc[@for="TreeViewDesigner"]/*' />
    /// <devdoc>
    ///      This is the designer for tree view controls.  It inherits
    ///      from the base control designer and adds live hit testing
    ///      capabilites for the tree view control.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class TreeViewDesigner : ControlDesigner {
        private NativeMethods.TV_HITTESTINFO tvhit = new NativeMethods.TV_HITTESTINFO();

        /// <include file='doc\TreeViewDesigner.uex' path='docs/doc[@for="TreeViewDesigner.GetHitTest"]/*' />
        /// <devdoc>
        ///    <para>Allows your component to support a design time user interface. A TabStrip
        ///       control, for example, has a design time user interface that allows the user
        ///       to click the tabs to change tabs. To implement this, TabStrip returns
        ///       true whenever the given point is within its tabs.</para>
        /// </devdoc>
        protected override bool GetHitTest(Point point) {
            point = Control.PointToClient(point);
            tvhit.pt_x = point.X;
            tvhit.pt_y = point.Y;
            NativeMethods.SendMessage(Control.Handle, NativeMethods.TVM_HITTEST, 0, tvhit);
            if (tvhit.flags == NativeMethods.TVHT_ONITEMBUTTON)
                return true;
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\updownbasedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpDownBaseDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\UpDownBaseDesigner.uex' path='docs/doc[@for="UpDownBaseDesigner"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a designer that can design components
    ///       that extend UpDownBase.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class UpDownBaseDesigner : ControlDesigner {

        /// <include file='doc\UpDownBaseDesigner.uex' path='docs/doc[@for="UpDownBaseDesigner.SelectionRules"]/*' />
        /// <devdoc>
        ///     Retrieves a set of rules concerning the movement capabilities of a component.
        ///     This should be one or more flags from the SelectionRules class.  If no designer
        ///     provides rules for a component, the component will not get any UI services.
        /// </devdoc>
        public override SelectionRules SelectionRules {
            get {
                SelectionRules rules = base.SelectionRules;
                rules &= ~(SelectionRules.TopSizeable | SelectionRules.BottomSizeable);
                return rules;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\winforms\system\winforms\design\treenodecollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="TreeNodeCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Windows.Forms.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System;
    using System.Design;
    using System.Collections;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Windows.Forms;

    /// <include file='doc\TreeNodeCollectionEditor.uex' path='docs/doc[@for="TreeNodeCollectionEditor"]/*' />
    /// <devdoc>
    ///      The TreeNodeCollectionEditor is a collection editor that is specifically
    ///      designed to edit a TreeNodeCollection.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class TreeNodeCollectionEditor : CollectionEditor {

        public TreeNodeCollectionEditor() : base(typeof(TreeNodeCollection)) {
        }

        /// <include file='doc\TreeNodeCollectionEditor.uex' path='docs/doc[@for="TreeNodeCollectionEditor.CreateCollectionForm"]/*' />
        /// <devdoc>
        ///      Creates a new form to show the current collection.  You may inherit
        ///      from CollectionForm to provide your own form.
        /// </devdoc>
        protected override CollectionForm CreateCollectionForm() {
            return new TreeNodeCollectionForm(this);
        }

        /// <include file='doc\TreeNodeCollectionEditor.uex' path='docs/doc[@for="TreeNodeCollectionEditor.HelpTopic"]/*' />
        /// <devdoc>
        ///    <para>Gets the help topic to display for the dialog help button or pressing F1. Override to
        ///          display a different help topic.</para>
        /// </devdoc>
        protected override string HelpTopic {
            get {
                return "net.ComponentModel.TreeNodeCollectionEditor";
            }
        }
        
        private class TreeNodeCollectionForm : CollectionForm {
            private int nextNode = 0;
            private TreeNode curNode;
            private bool settingProps;
            private TreeNodeCollectionEditor editor = null;

            private Container components = new Container();
            private TreeView tvNodes = new TreeView();
            private Button btnAddChild = new Button();
            private TextBox editLabel = new TextBox();
            private Label lblLabel = new Label();
            private Button btnOK = new Button();
            private Button btnCancel = new Button();
            private Button btnDelete = new Button();
            private Button btnAddRoot = new Button();
            private Label lblImage = new Label();
            private ComboBox cmbSelImage = new ComboBox();
            private Label lblSelImage = new Label();
            private ComboBox cmbImage = new ComboBox();
            private Label lblNodes = new Label();
            private GroupBox groupBox1 = new GroupBox();
            
            private object NextNodeKey = new object();

            public TreeNodeCollectionForm(CollectionEditor editor) : base(editor) {
                this.editor = (TreeNodeCollectionEditor) editor;
                InitializeComponent();
            }
            
            private TreeView TreeView {
                get {
                    if (Context != null && Context.Instance is TreeView) {
                        return (TreeView)Context.Instance;
                    }
                    else {
                        Debug.Assert(false, "TreeNodeCollectionEditor couldn't find the TreeView being designed");
                        return null;
                    }
                }
            }
            
            private int NextNode {
                get {
                    if (TreeView != null && TreeView.Site != null) {
                        IDictionaryService ds = (IDictionaryService)TreeView.Site.GetService(typeof(IDictionaryService));
                        Debug.Assert(ds != null, "TreeNodeCollectionEditor relies on IDictionaryService, which is not available.");
                        if (ds != null) {
                            object dictionaryValue = ds.GetValue(NextNodeKey);
                            if (dictionaryValue != null) {
                                nextNode = (int)dictionaryValue;
                            }
                            else {
                                nextNode = 0;
                                ds.SetValue(NextNodeKey, 0);
                            }
                        }    
                    }
                    return nextNode;
                }
                set {
                    nextNode = value;
                    if (TreeView != null && TreeView.Site != null) {
                        IDictionaryService ds = (IDictionaryService)TreeView.Site.GetService(typeof(IDictionaryService));
                        Debug.Assert(ds != null, "TreeNodeCollectionEditor relies on IDictionaryService, which is not available.");
                        if (ds != null) {
                            ds.SetValue(NextNodeKey, nextNode);
                        }    
                    }
                }
            }

            private void Add(TreeNode parent) {

                TreeNode newNode = null;
                string baseNodeName = SR.GetString(SR.BaseNodeName);
                
                if (parent == null)
                    newNode = tvNodes.Nodes.Add(baseNodeName + NextNode++.ToString());
                else {
                    newNode = parent.Nodes.Add(baseNodeName + NextNode++.ToString());
                    parent.Expand();
                }

                if (newNode != null) {
                    tvNodes.SelectedNode = newNode;
                }
            }

            private void BtnAddChild_click(object sender, EventArgs e) {
                Add(curNode);
            }

            private void BtnAddRoot_click(object sender, EventArgs e) {
                Add(null);
            }

            private void BtnDelete_click(object sender, EventArgs e) {
                curNode.Remove();
                if (tvNodes.Nodes.Count == 0) {
                    curNode = null;
                    settingProps = true;
                    editLabel.Text = "";
                    cmbImage.SelectedIndex = 0;
                    cmbSelImage.SelectedIndex = 0;
                    settingProps = false;

                    btnAddChild.Enabled = false;
                    btnDelete.Enabled = false;
                    lblLabel.Enabled = false;
                    editLabel.Enabled = false;
                    lblImage.Enabled = false;
                    cmbImage.Enabled = false;
                    lblSelImage.Enabled = false;
                    cmbSelImage.Enabled = false;
                }
            }

            private void BtnOK_click(object sender, EventArgs e) {
                object[] values = new object[tvNodes.Nodes.Count];
                for (int i = 0; i < values.Length; i++) {
                    values[i] = tvNodes.Nodes[i].Clone();
                }
                Items = values;
            }

            private void CmbImage_drawItem(object sender, DrawItemEventArgs e) {
            
                e.DrawBackground();
                e.DrawFocusRectangle();
            
                if (e.Index == 0) {
                    Brush foreBrush = new SolidBrush(e.ForeColor);
                    e.Graphics.DrawString("(Default)", cmbImage.Font, foreBrush, e.Bounds.X, e.Bounds.Y);
                    foreBrush.Dispose();
                }
                else
                    tvNodes.ImageList.Draw(e.Graphics, e.Bounds.X, e.Bounds.Y, 16, 16, e.Index - 1);
            }

            private void CmbImage_selectedIndexChanged(object sender, EventArgs e) {
                if (!settingProps && curNode != null)
                    curNode.ImageIndex = cmbImage.SelectedIndex-1;
            }

            private void CmbSelImage_selectedIndexChanged(object sender, EventArgs e) {
                if (!settingProps && curNode != null)
                    curNode.SelectedImageIndex = cmbSelImage.SelectedIndex-1;
            }

            private void EditLabel_textChanged(object sender, EventArgs e) {
                if (!settingProps && curNode != null)
                    curNode.Text = editLabel.Text;
            }

            private void Form_HelpRequested(object sender, HelpEventArgs e) {
                editor.ShowHelp();
            }

            /// <include file='doc\TreeNodeCollectionEditor.uex' path='docs/doc[@for="TreeNodeCollectionEditor.TreeNodeCollectionForm.InitializeComponent"]/*' />
            /// <devdoc>
            ///     NOTE: The following code is required by the form
            ///     designer.  It can be modified using the form editor.  Do not
            ///     modify it using the code editor.
            /// </devdoc>
            private void InitializeComponent() {
                System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(TreeNodeCollectionEditor));
                
                tvNodes.ImageIndex = 0;
                tvNodes.HideSelection = false;
                tvNodes.LabelEdit = true;
                tvNodes.AfterLabelEdit += new NodeLabelEditEventHandler(this.TvNodes_afterLabelEdit);
                tvNodes.AfterSelect += new TreeViewEventHandler(this.TvNodes_afterSelect);
                tvNodes.AccessibleDescription = ((string)(resources.GetObject("tvNodes.AccessibleDescription")));
                tvNodes.AccessibleName = ((string)(resources.GetObject("tvNodes.AccessibleName")));
                tvNodes.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("tvNodes.Anchor")));
                tvNodes.Indent = ((int)(resources.GetObject("tvNodes.Indent")));
                tvNodes.Location = ((System.Drawing.Point)(resources.GetObject("tvNodes.Location")));
                tvNodes.Size = ((System.Drawing.Size)(resources.GetObject("tvNodes.Size")));
                tvNodes.TabIndex = ((int)(resources.GetObject("tvNodes.TabIndex")));

                editLabel.Enabled = false;
                editLabel.Text = "";
                editLabel.TextChanged += new EventHandler(this.EditLabel_textChanged);
                editLabel.AccessibleDescription = ((string)(resources.GetObject("editLabel.AccessibleDescription")));
                editLabel.AccessibleName = ((string)(resources.GetObject("editLabel.AccessibleName")));
                editLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("editLabel.Anchor")));
                editLabel.Location = ((System.Drawing.Point)(resources.GetObject("editLabel.Location")));
                editLabel.Size = ((System.Drawing.Size)(resources.GetObject("editLabel.Size")));
                editLabel.TabIndex = ((int)(resources.GetObject("editLabel.TabIndex")));

                lblLabel.Enabled = false;
                lblLabel.AccessibleDescription = ((string)(resources.GetObject("lblLabel.AccessibleDescription")));
                lblLabel.AccessibleName = ((string)(resources.GetObject("lblLabel.AccessibleName")));
                lblLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lblLabel.Anchor")));
                lblLabel.Location = ((System.Drawing.Point)(resources.GetObject("lblLabel.Location")));
                lblLabel.Size = ((System.Drawing.Size)(resources.GetObject("lblLabel.Size")));
                lblLabel.TabIndex = ((int)(resources.GetObject("lblLabel.TabIndex")));
                lblLabel.Text = resources.GetString("lblLabel.Text");

                btnOK.DialogResult = DialogResult.OK;
                btnOK.Click += new EventHandler(this.BtnOK_click);
                btnOK.AccessibleDescription = ((string)(resources.GetObject("btnOK.AccessibleDescription")));
                btnOK.AccessibleName = ((string)(resources.GetObject("btnOK.AccessibleName")));
                btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnOK.Anchor")));
                btnOK.Location = ((System.Drawing.Point)(resources.GetObject("btnOK.Location")));
                btnOK.Size = ((System.Drawing.Size)(resources.GetObject("btnOK.Size")));
                btnOK.TabIndex = ((int)(resources.GetObject("btnOK.TabIndex")));
                btnOK.Text = resources.GetString("btnOK.Text");

                btnCancel.DialogResult = DialogResult.Cancel;
                btnCancel.AccessibleDescription = ((string)(resources.GetObject("btnCancel.AccessibleDescription")));
                btnCancel.AccessibleName = ((string)(resources.GetObject("btnCancel.AccessibleName")));
                btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnCancel.Anchor")));
                btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("btnCancel.Location")));
                btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("btnCancel.Size")));
                btnCancel.TabIndex = ((int)(resources.GetObject("btnCancel.TabIndex")));
                btnCancel.Text = resources.GetString("btnCancel.Text");

                btnAddRoot.Click += new EventHandler(this.BtnAddRoot_click);
                btnAddRoot.AccessibleDescription = ((string)(resources.GetObject("btnAddRoot.AccessibleDescription")));
                btnAddRoot.AccessibleName = ((string)(resources.GetObject("btnAddRoot.AccessibleName")));
                btnAddRoot.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnAddRoot.Anchor")));
                btnAddRoot.Image = ((System.Drawing.Bitmap)(resources.GetObject("btnAddRoot.Image")));
                btnAddRoot.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnAddRoot.ImageAlign")));
                btnAddRoot.Location = ((System.Drawing.Point)(resources.GetObject("btnAddRoot.Location")));
                btnAddRoot.Size = ((System.Drawing.Size)(resources.GetObject("btnAddRoot.Size")));
                btnAddRoot.TabIndex = ((int)(resources.GetObject("btnAddRoot.TabIndex")));
                btnAddRoot.Text = resources.GetString("btnAddRoot.Text");

                btnAddChild.Enabled = false;
                btnAddChild.Click += new EventHandler(this.BtnAddChild_click);
                btnAddChild.AccessibleDescription = ((string)(resources.GetObject("btnAddChild.AccessibleDescription")));
                btnAddChild.AccessibleName = ((string)(resources.GetObject("btnAddChild.AccessibleName")));
                btnAddChild.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnAddChild.Anchor")));
                btnAddChild.Image = ((System.Drawing.Bitmap)(resources.GetObject("btnAddChild.Image")));
                btnAddChild.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnAddChild.ImageAlign")));
                btnAddChild.Location = ((System.Drawing.Point)(resources.GetObject("btnAddChild.Location")));
                btnAddChild.Size = ((System.Drawing.Size)(resources.GetObject("btnAddChild.Size")));
                btnAddChild.TabIndex = ((int)(resources.GetObject("btnAddChild.TabIndex")));
                btnAddChild.Text = resources.GetString("btnAddChild.Text");

                btnDelete.Enabled = false;
                btnDelete.Click += new EventHandler(this.BtnDelete_click);
                btnDelete.AccessibleDescription = ((string)(resources.GetObject("btnDelete.AccessibleDescription")));
                btnDelete.AccessibleName = ((string)(resources.GetObject("btnDelete.AccessibleName")));
                btnDelete.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("btnDelete.Anchor")));
                btnDelete.Image = ((System.Drawing.Bitmap)(resources.GetObject("btnDelete.Image")));
                btnDelete.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("btnDelete.ImageAlign")));
                btnDelete.Location = ((System.Drawing.Point)(resources.GetObject("btnDelete.Location")));
                btnDelete.Size = ((System.Drawing.Size)(resources.GetObject("btnDelete.Size")));
                btnDelete.TabIndex = ((int)(resources.GetObject("btnDelete.TabIndex")));
                btnDelete.Text = resources.GetString("btnDelete.Text");

                lblImage.Enabled = false;
                lblImage.AccessibleDescription = ((string)(resources.GetObject("lblImage.AccessibleDescription")));
                lblImage.AccessibleName = ((string)(resources.GetObject("lblImage.AccessibleName")));
                lblImage.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lblImage.Anchor")));
                lblImage.Location = ((System.Drawing.Point)(resources.GetObject("lblImage.Location")));
                lblImage.Size = ((System.Drawing.Size)(resources.GetObject("lblImage.Size")));
                lblImage.TabIndex = ((int)(resources.GetObject("lblImage.TabIndex")));
                lblImage.Text = resources.GetString("lblImage.Text");

                cmbSelImage.Enabled = false;
                cmbSelImage.DropDownStyle = ComboBoxStyle.DropDownList;
                cmbSelImage.Items.AddRange(new object[] {SR.GetString(SR.DefaultCaption)});
                cmbSelImage.DrawItem += new DrawItemEventHandler(this.CmbImage_drawItem);
                cmbSelImage.SelectedIndexChanged += new EventHandler(this.CmbSelImage_selectedIndexChanged);
                cmbSelImage.AccessibleDescription = ((string)(resources.GetObject("cmbSelImage.AccessibleDescription")));
                cmbSelImage.AccessibleName = ((string)(resources.GetObject("cmbSelImage.AccessibleName")));
                cmbSelImage.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("cmbSelImage.Anchor")));
                cmbSelImage.ItemHeight = ((int)(resources.GetObject("cmbSelImage.ItemHeight")));
                cmbSelImage.Location = ((System.Drawing.Point)(resources.GetObject("cmbSelImage.Location")));
                cmbSelImage.Size = ((System.Drawing.Size)(resources.GetObject("cmbSelImage.Size")));
                cmbSelImage.TabIndex = ((int)(resources.GetObject("cmbSelImage.TabIndex")));
                cmbSelImage.Text = resources.GetString("cmbSelImage.Text");

                lblSelImage.Enabled = false;
                lblSelImage.AccessibleDescription = ((string)(resources.GetObject("lblSelImage.AccessibleDescription")));
                lblSelImage.AccessibleName = ((string)(resources.GetObject("lblSelImage.AccessibleName")));
                lblSelImage.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("lblSelImage.Anchor")));
                lblSelImage.Location = ((System.Drawing.Point)(resources.GetObject("lblSelImage.Location")));
                lblSelImage.Size = ((System.Drawing.Size)(resources.GetObject("lblSelImage.Size")));
                lblSelImage.TabIndex = ((int)(resources.GetObject("lblSelImage.TabIndex")));
                lblSelImage.Text = resources.GetString("lblSelImage.Text");

                groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("groupBox1.Anchor")));
                groupBox1.Location = ((System.Drawing.Point)(resources.GetObject("groupBox1.Location")));
                groupBox1.Size = ((System.Drawing.Size)(resources.GetObject("groupBox1.Size")));
                groupBox1.Text = resources.GetString("groupBox1.Text");
                groupBox1.TabIndex = 99;       // Users shouldn't be tabbing here

                cmbImage.Enabled = false;
                cmbImage.DropDownStyle = ComboBoxStyle.DropDownList;
                cmbImage.Items.AddRange(new object[] {SR.GetString(SR.DefaultCaption)});
                cmbImage.DrawItem += new DrawItemEventHandler(this.CmbImage_drawItem);
                cmbImage.SelectedIndexChanged += new EventHandler(this.CmbImage_selectedIndexChanged);
                cmbImage.AccessibleDescription = ((string)(resources.GetObject("cmbImage.AccessibleDescription")));
                cmbImage.AccessibleName = ((string)(resources.GetObject("cmbImage.AccessibleName")));
                cmbImage.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("cmbImage.Anchor")));
                cmbImage.ItemHeight = ((int)(resources.GetObject("cmbImage.ItemHeight")));
                cmbImage.Location = ((System.Drawing.Point)(resources.GetObject("cmbImage.Location")));
                cmbImage.Size = ((System.Drawing.Size)(resources.GetObject("cmbImage.Size")));
                cmbImage.TabIndex = ((int)(resources.GetObject("cmbImage.TabIndex")));
                cmbImage.Text = resources.GetString("cmbImage.Text");

                lblNodes.AccessibleDescription = ((string)(resources.GetObject("lblNodes.AccessibleDescription")));
                lblNodes.AccessibleName = ((string)(resources.GetObject("lblNodes.AccessibleName")));
                lblNodes.Location = ((System.Drawing.Point)(resources.GetObject("lblNodes.Location")));
                lblNodes.Size = ((System.Drawing.Size)(resources.GetObject("lblNodes.Size")));
                lblNodes.TabIndex = ((int)(resources.GetObject("lblNodes.TabIndex")));
                lblNodes.Text = resources.GetString("lblNodes.Text");

                this.AcceptButton = btnOK;
                this.CancelButton = btnCancel;
                this.MaximizeBox = false;
                this.MinimizeBox = false;
                this.ControlBox = false;
                this.ShowInTaskbar = false;
                this.AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
                this.AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
                this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
                this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
                this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
                this.MinimumSize = ((System.Drawing.Size)(resources.GetObject("$this.MinimumSize")));
                this.StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
                this.Text = resources.GetString("$this.Text");
                this.HelpRequested += new HelpEventHandler(this.Form_HelpRequested);

                this.Controls.AddRange(new Control[] {
                                            lblNodes,
                                            tvNodes,
                                            btnAddRoot,
                                            btnAddChild,
                                            btnDelete,
                                            lblLabel,
                                            editLabel,
                                            lblImage,
                                            cmbImage,
                                            lblSelImage,
                                            cmbSelImage,
                                            groupBox1,
                                            btnOK,
                                            btnCancel
                                            });
            }
            
            /// <include file='doc\TreeNodeCollectionEditor.uex' path='docs/doc[@for="TreeNodeCollectionEditor.TreeNodeCollectionForm.OnEditValueChanged"]/*' />
            /// <devdoc>
            ///      This is called when the value property in the CollectionForm has changed.
            ///      In it you should update your user interface to reflect the current value.
            /// </devdoc>
            protected override void OnEditValueChanged() {
            
                if (EditValue != null) {
                    object[] items = Items;
                    TreeNode[] nodes = new TreeNode[items.Length];

                    for (int i = 0; i < items.Length; i++) {
                        // We need to copy the nodes into our editor TreeView, not move them.
                        // We overwrite the passed-in array with the new roots.
                        //
                        nodes[i] = (TreeNode)((TreeNode)items[i]).Clone();
                    }

                    tvNodes.Nodes.Clear();
                    tvNodes.Nodes.AddRange(nodes);
                    
                    // Update current node related UI
                    //
                    curNode = null;
                    btnAddChild.Enabled = false;
                    btnDelete.Enabled = false;
                    lblLabel.Enabled = false;
                    editLabel.Enabled = false;
                    lblImage.Enabled = false;
                    cmbImage.Enabled = false;
                    lblSelImage.Enabled = false;
                    cmbSelImage.Enabled = false;
                    
                    // The image list for the editor TreeView must be updated to be the same
                    // as the image list for the actual TreeView.
                    //
                    TreeView actualTV = TreeView;
                    if (actualTV != null) {
                        SetImageProps(actualTV.ImageList, actualTV.ImageIndex, actualTV.SelectedImageIndex);
                    }
                }
            }

            private void SetImageProps(ImageList imageList, int imageIndex, int selectedImageIndex) {
            
                if (imageList != null) {
                
                    // Update the treeview image-related properties
                    //
                    tvNodes.ImageList = imageList;
                    tvNodes.ImageIndex = imageIndex;
                    tvNodes.SelectedImageIndex = selectedImageIndex;

                    // Update the form image-related UI
                    //
                    cmbImage.DrawMode = DrawMode.OwnerDrawFixed;
                    cmbImage.MaxDropDownItems = 8;
                    cmbImage.Size = new Size(112, 120);
                    cmbImage.Items.Clear();
                    cmbImage.Items.AddRange(new object[] {SR.GetString(SR.DefaultCaption)});
                    
                    cmbSelImage.DrawMode = DrawMode.OwnerDrawFixed;
                    cmbSelImage.MaxDropDownItems = 8;
                    cmbSelImage.Size = new Size(112, 120);
                    cmbSelImage.Items.Clear();
                    cmbSelImage.Items.AddRange(new object[] {SR.GetString(SR.DefaultCaption)});
                   
                    for (int i = 0; i < imageList.Images.Count; i++) {
                        cmbImage.Items.Add("image" + i.ToString());
                        cmbSelImage.Items.Add("image" + i.ToString());
                    }
                }
                cmbImage.SelectedIndex = 0;
                cmbSelImage.SelectedIndex = 0;
            }

            private void SetNodeProps(TreeNode node) {
                editLabel.Text = node.Text;
                cmbImage.SelectedIndex = node.ImageIndex + 1;
                cmbSelImage.SelectedIndex = node.SelectedImageIndex + 1;
            }

            private void TvNodes_afterSelect(object sender, TreeViewEventArgs e) {
            
                if (curNode == null) {
                
                    btnAddChild.Enabled = true;
                    btnDelete.Enabled = true;
                    lblLabel.Enabled = true;
                    editLabel.Enabled = true;
                    if (tvNodes.ImageList != null) {
                        lblImage.Enabled = true;
                        cmbImage.Enabled = true;
                        lblSelImage.Enabled = true;
                        cmbSelImage.Enabled = true;
                    }
                }
                curNode = e.Node;
                settingProps = true;
                SetNodeProps(curNode);
                settingProps = false;
            }

            private void TvNodes_afterLabelEdit(object sender, NodeLabelEditEventArgs e) {
                if (curNode == e.Node) {
                    settingProps = true;
                    editLabel.Text = e.Label;
                    settingProps = false;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\installredirect.cpp ===
//------------------------------------------------------------------------------
// <copyright file="installredirect.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   installredirect.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#define UNICODE 1
#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"

#define STANDARD_BUFFER 1024

extern "C" __declspec(dllexport) UINT __stdcall SetInstallRedirect(MSIHANDLE hInstall)
{
    INSTALLSTATE iInstalled, iAction;
    WCHAR tszQuickStart[STANDARD_BUFFER];
    WCHAR tszRedirect[STANDARD_BUFFER];
    DWORD dwSize = STANDARD_BUFFER;
    MsiGetProperty(hInstall, L"QuickStartFeatureName", tszQuickStart, &dwSize);
    dwSize = STANDARD_BUFFER;
    MsiGetProperty(hInstall, L"RedirectFeatureName", tszRedirect, &dwSize);
    MsiGetFeatureState(hInstall, tszQuickStart, &iInstalled, &iAction);
    if (iInstalled != iAction && iAction != -1)
    {  
       MsiSetFeatureState(hInstall, tszRedirect, iInstalled);
    }        

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\mshelp.cpp ===
//------------------------------------------------------------------------------
// <copyright file="MsHelp.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MsHelp.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// MsHElp.cpp : Defines the entry point for the DLL application.
//

#define UNICODE 1

#include "Include\stdafx.h"
#include "Include\MsHelp.h"
#define MSNETSDK L"MSNETFRAMEWORKSDKNAMESPACE"

#define STANDARD_BUFFER 1024

// exported as _MsHelpDetection@4
MSHELP_API MsHelpDetection(MSIHANDLE hInstaller)
{
    
    IHxRegisterSessionPtr spRegSession;
    IHxRegisterPtr pRegister;
    HRESULT hr;
    BOOL bMITNET = false;
    BOOL bMITVS = false;
    _bstr_t bstrEmpty = _bstr_t();
    
    hr = spRegSession.CreateInstance(CLSID_HxRegisterSession);
    if (!(SUCCEEDED(hr)))
    {
        return ERROR_SUCCESS;
    }
    
    // Transaction has to be ended before leaving dll
    spRegSession->CreateTransaction(_bstr_t(""));
    if (!(SUCCEEDED(hr)))
    {
        return  ERROR_SUCCESS;
    }

    pRegister = spRegSession->GetRegistrationObject(HxRegisterSession_IHxRegister);
    if (pRegister == NULL)
    {
        // failed, close transaction
        spRegSession->RevertTransaction();
        return  ERROR_SUCCESS;
    }

    // check for namespaces
    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK");
    }
    
    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.chs"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.chs");
    }
    
    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.cht"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.cht");
    }

    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.ko"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.ko");
    }

    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.fr"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.fr");
    }
    
    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.it"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.it");
    }
    
    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.es"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.es");
    }

    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.de"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentEN", L"1");
        bMITNET = true;
        MsiSetProperty(hInstaller, MSNETSDK, L"ms.NETFrameworkSDK.de");
    }

    if (pRegister->IsNamespace(L"ms.NETFrameworkSDK.ja"))
    {
        MsiSetProperty(hInstaller, L"MSHelpNETFrameworkSDKNamespacePresentJA", L"1");
        bMITNET = true;
    }


    if (pRegister->IsNamespace(L"ms.vscc"))
    {
        MsiSetProperty(hInstaller, L"MSHelpVSCCNamespacePresent", L"1");
        bMITVS = true;
    }

    if (bMITVS || bMITNET)
    {
            MsiSetProperty(hInstaller, L"MSHelpServicesPresent", L"1");        
    }
    //done
    spRegSession->RevertTransaction();
    return  ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\isvsrunning.cpp ===
//------------------------------------------------------------------------------
// <copyright file="isvsrunning.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   isvsrunning.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define UNICODE 1
#include <windows.h>
#include <winuser.h>
#include <tchar.h>
#include "psapi.h"
#include "msi.h"
#include "msiquery.h"

#define STANDARD_BUFFER 512 

BOOL IsDevEnv( DWORD processID )
{
    HMODULE hMod;
    HANDLE hProcess = NULL;
    DWORD cbNeeded;
    BOOL bFound = false;
    TCHAR szModName[MAX_PATH + 1];
    
    hProcess = OpenProcess(  PROCESS_QUERY_INFORMATION |
                                    PROCESS_VM_READ,
                                    FALSE, processID );

    if (!hProcess)
    {
        goto Exit;
    }
    
    EnumProcessModules(hProcess, &hMod, sizeof(HMODULE), &cbNeeded);
    if ( GetModuleBaseName( hProcess, hMod, szModName,MAX_PATH))
    {      
        if (!wcscmp(CharLower(szModName), L"devenv.exe") || 
            !wcscmp(CharLower(szModName), L"dexplore.exe"))
        {
            bFound  = true;
        }
    }
  
Exit:
    if (hProcess)
    {
        CloseHandle( hProcess );
    }
    return bFound;

}

BOOL IsDevEnvRunning( )
{
    
    DWORD *aProcesses;
    DWORD cbPreviousNeeded = 0;
    DWORD cbNeeded= 0;
    DWORD cbSize = 0;
    DWORD cProcesses;
    BOOL bFound = false;
    unsigned int i;
    
    do
    {
            cbSize += 1024;
            
            aProcesses = (DWORD *) malloc(cbSize);

            if (!aProcesses)
            {
                goto Exit;
            }

            EnumProcesses(aProcesses, cbSize, &cbNeeded);
            
            if (cbSize == cbNeeded)
            {
                free(aProcesses);
                aProcesses = NULL;
            }
    } while (!aProcesses);
                
    cProcesses = cbNeeded / sizeof(DWORD);

    for ( i = 0; i < cProcesses; i++ )
    {
        if (IsDevEnv(aProcesses[i]))
        {
            bFound = true;
            goto Exit;
        }     
    }
Exit:
    if (aProcesses)
    {
        free(aProcesses);
    }
    return bFound;
}

extern "C" __declspec(dllexport) UINT __stdcall IsVSRunning(MSIHANDLE hInstaller)
{
    BOOL bFound;
    WCHAR VSIsRunningErrMsg[STANDARD_BUFFER];
    WCHAR InstallationWarningCaption[STANDARD_BUFFER];
    int nRetCode;
    DWORD dwSize = STANDARD_BUFFER;
    
    MsiGetProperty(hInstaller, L"VisualStudioIsRunningErrMsg", VSIsRunningErrMsg, &dwSize);

    dwSize = STANDARD_BUFFER;
    MsiGetProperty(hInstaller, L"InstallationWarningCaption", InstallationWarningCaption, &dwSize);
    while (IsDevEnvRunning())
    {
        nRetCode = MessageBox(0, VSIsRunningErrMsg, InstallationWarningCaption, MB_ABORTRETRYIGNORE);
        if (nRetCode == IDABORT) 
        {
            return ERROR_INSTALL_USEREXIT;
        }
        else
        {
            if (nRetCode == IDIGNORE)
            {
                    return ERROR_SUCCESS;
            }
        }
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\finddexplore.cpp ===
//------------------------------------------------------------------------------
// <copyright file="finddexplore.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   finddexplore.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#define UNICODE 1

#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"



extern "C" __declspec(dllexport) UINT __stdcall GetDexplorePath(MSIHANDLE hInstaller)
{
    WCHAR szDexplorePath[MAX_PATH + 1]; 
    WCHAR szVersionNT[10];
    DWORD dwSize = 10;
    long lSize = MAX_PATH;
    HRESULT hr;
    hr =  RegQueryValue(HKEY_LOCAL_MACHINE,
                                    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\dexplore.exe", 
                                    szDexplorePath, 
                                    &lSize);

       
    if (SUCCEEDED(hr))
    {
        MsiGetProperty(hInstaller, L"VersionNT", szVersionNT, &dwSize);
        if (_wtoi(szVersionNT) > 400)
        {
           MsiSetProperty(hInstaller, L"DEXPLOREPATH", (WCHAR *) (_bstr_t("\"") + _bstr_t(szDexplorePath) + _bstr_t("\"")));
        }
        else
        {
           MsiSetProperty(hInstaller, L"DEXPLOREPATH", szDexplorePath);
        }
        MsiSetProperty(hInstaller, L"DexplorePresent",L"1");
    }
    else
    {
        MsiSetProperty(hInstaller, L"DexplorePresent",L"0");
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\include\msiquery.h ===
/*****************************************************************************\
*                                                                             *
* MsiQuery.h - Interface to running installer for custom actions and tools    *
*                                                                             *
* Version 1.0 - 1.2                                                           *
*                                                                             *
* NOTES:  All buffers sizes are TCHAR count, null included only on input      *
*         Return argument pointers may be null if not interested in value     *
*         Returned handles of all types must be closed: MsiCloseHandle(h)     *
*         Functions with UINT return type return a system error code          *
*         Designated functions will set or clear the last error record,       *
*         which is then accessible with MsiGetLastErrorRecord. However,       *
*         the following argument errors do not register an error record:      *
*         ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, ERROR_MORE_DATA.     *
*                                                                             *
* Copyright (c) 1999-2000, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _MSIQUERY_H_
#define _MSIQUERY_H_
#include "msi.h"  // INSTALLSTATE

#define MSI_NULL_INTEGER 0x80000000  // integer value reserved for null

// MsiOpenDatabase persist predefine values, otherwise output database path is used
#define MSIDBOPEN_READONLY     (LPCTSTR)0  // database open read-only, no persistent changes
#define MSIDBOPEN_TRANSACT     (LPCTSTR)1  // database read/write in transaction mode
#define MSIDBOPEN_DIRECT       (LPCTSTR)2  // database direct read/write without transaction
#define MSIDBOPEN_CREATE       (LPCTSTR)3  // create new database, transact mode read/write
#define MSIDBOPEN_CREATEDIRECT (LPCTSTR)4  // create new database, direct mode read/write
#define MSIDBOPEN_PATCHFILE    32/sizeof(*MSIDBOPEN_READONLY) // add flag to indicate patch file

typedef enum tagMSIDBSTATE
{
	MSIDBSTATE_ERROR    =-1,  // invalid database handle
	MSIDBSTATE_READ     = 0,  // database open read-only, no persistent changes
	MSIDBSTATE_WRITE    = 1,  // database readable and updatable
} MSIDBSTATE;

typedef enum tagMSIMODIFY
{
	MSIMODIFY_SEEK             =-1,  // reposition to current record primary key
	MSIMODIFY_REFRESH          = 0,  // refetch current record data
	MSIMODIFY_INSERT           = 1,  // insert new record, fails if matching key exists
	MSIMODIFY_UPDATE           = 2,  // update existing non-key data of fetched record
	MSIMODIFY_ASSIGN           = 3,  // insert record, replacing any existing record
	MSIMODIFY_REPLACE          = 4,  // update record, delete old if primary key edit
	MSIMODIFY_MERGE            = 5,  // fails if record with duplicate key not identical
	MSIMODIFY_DELETE           = 6,  // remove row referenced by this record from table
	MSIMODIFY_INSERT_TEMPORARY = 7,  // insert a temporary record
	MSIMODIFY_VALIDATE         = 8,  // validate a fetched record
	MSIMODIFY_VALIDATE_NEW     = 9,  // validate a new record
	MSIMODIFY_VALIDATE_FIELD   = 10, // validate field(s) of an incomplete record
	MSIMODIFY_VALIDATE_DELETE  = 11, // validate before deleting record
} MSIMODIFY;

typedef enum tagMSICOLINFO
{
	MSICOLINFO_NAMES = 0,  // return column names
	MSICOLINFO_TYPES = 1,  // return column definitions, datatype code followed by width
} MSICOLINFO;

typedef enum tagMSICONDITION
{
	MSICONDITION_FALSE = 0,  // expression evaluates to False
	MSICONDITION_TRUE  = 1,  // expression evaluates to True
	MSICONDITION_NONE  = 2,  // no expression present
	MSICONDITION_ERROR = 3,  // syntax error in expression
} MSICONDITION;

typedef enum tagMSICOSTTREE
{
	MSICOSTTREE_SELFONLY = 0,
	MSICOSTTREE_CHILDREN = 1,
	MSICOSTTREE_PARENTS  = 2,
	MSICOSTTREE_RESERVED = 3,	// Reserved for future use
} MSICOSTTREE;

typedef enum tagMSIDBERROR
{
	MSIDBERROR_INVALIDARG        = -3, //  invalid argument
	MSIDBERROR_MOREDATA          = -2, //  buffer too small
	MSIDBERROR_FUNCTIONERROR     = -1, //  function error
	MSIDBERROR_NOERROR           = 0,  //  no error
	MSIDBERROR_DUPLICATEKEY      = 1,  //  new record duplicates primary keys of existing record in table
	MSIDBERROR_REQUIRED          = 2,  //  non-nullable column, no null values allowed
	MSIDBERROR_BADLINK           = 3,  //  corresponding record in foreign table not found
	MSIDBERROR_OVERFLOW          = 4,  //  data greater than maximum value allowed
	MSIDBERROR_UNDERFLOW         = 5,  //  data less than minimum value allowed
	MSIDBERROR_NOTINSET          = 6,  //  data not a member of the values permitted in the set
	MSIDBERROR_BADVERSION        = 7,  //  invalid version string
	MSIDBERROR_BADCASE           = 8,  //  invalid case, must be all upper-case or all lower-case
	MSIDBERROR_BADGUID           = 9,  //  invalid GUID
	MSIDBERROR_BADWILDCARD       = 10, //  invalid wildcardfilename or use of wildcards
	MSIDBERROR_BADIDENTIFIER     = 11, //  bad identifier
	MSIDBERROR_BADLANGUAGE       = 12, //  bad language Id(s)
	MSIDBERROR_BADFILENAME       = 13, //  bad filename
	MSIDBERROR_BADPATH           = 14, //  bad path
	MSIDBERROR_BADCONDITION      = 15, //  bad conditional statement
	MSIDBERROR_BADFORMATTED      = 16, //  bad format string
	MSIDBERROR_BADTEMPLATE       = 17, //  bad template string
	MSIDBERROR_BADDEFAULTDIR     = 18, //  bad string in DefaultDir column of Directory table
	MSIDBERROR_BADREGPATH        = 19, //  bad registry path string
	MSIDBERROR_BADCUSTOMSOURCE   = 20, //  bad string in CustomSource column of CustomAction table
	MSIDBERROR_BADPROPERTY       = 21, //  bad property string
	MSIDBERROR_MISSINGDATA       = 22, //  _Validation table missing reference to column
	MSIDBERROR_BADCATEGORY       = 23, //  Category column of _Validation table for column is invalid
	MSIDBERROR_BADKEYTABLE       = 24, //  table in KeyTable column of _Validation table could not be found/loaded
	MSIDBERROR_BADMAXMINVALUES   = 25, //  value in MaxValue column of _Validation table is less than value in MinValue column
	MSIDBERROR_BADCABINET        = 26, //  bad cabinet name
	MSIDBERROR_BADSHORTCUT       = 27, //  bad shortcut target
	MSIDBERROR_STRINGOVERFLOW    = 28, //  string overflow (greater than length allowed in column def)
	MSIDBERROR_BADLOCALIZEATTRIB = 29  //  invalid localization attribute (primary keys cannot be localized)

} MSIDBERROR;

typedef enum tagMSIRUNMODE
{
	MSIRUNMODE_ADMIN           =  0, // admin mode install, else product install
	MSIRUNMODE_ADVERTISE       =  1, // installing advertisements, else installing or updating product
	MSIRUNMODE_MAINTENANCE     =  2, // modifying an existing installation, else new installation
	MSIRUNMODE_ROLLBACKENABLED =  3, // rollback is enabled
	MSIRUNMODE_LOGENABLED      =  4, // log file active, enabled prior to install session
	MSIRUNMODE_OPERATIONS      =  5, // spooling execute operations, else in determination phase
	MSIRUNMODE_REBOOTATEND     =  6, // reboot needed after successful installation (settable)
	MSIRUNMODE_REBOOTNOW       =  7, // reboot needed to continue installation (settable)
	MSIRUNMODE_CABINET         =  8, // installing files from cabinets and files using Media table
	MSIRUNMODE_SOURCESHORTNAMES=  9, // source LongFileNames suppressed via PID_MSISOURCE summary property
	MSIRUNMODE_TARGETSHORTNAMES= 10, // target LongFileNames suppressed via SHORTFILENAMES property
	MSIRUNMODE_RESERVED11      = 11, // future use
	MSIRUNMODE_WINDOWS9X       = 12, // operating systems is Windows9?, else Windows NT
	MSIRUNMODE_ZAWENABLED      = 13, // operating system supports demand installation
	MSIRUNMODE_RESERVED14      = 14, // future use
	MSIRUNMODE_RESERVED15      = 15, // future use
	MSIRUNMODE_SCHEDULED       = 16, // custom action call from install script execution
	MSIRUNMODE_ROLLBACK        = 17, // custom action call from rollback execution script
	MSIRUNMODE_COMMIT          = 18, // custom action call from commit execution script
} MSIRUNMODE;

#define INSTALLMESSAGE_TYPEMASK = 0xFF000000L  // mask for type code

// Note: INSTALLMESSAGE_ERROR, INSTALLMESSAGE_WARNING, INSTALLMESSAGE_USER are to or'd
// with a message box style to indicate the buttons to display and return:
// MB_OK,MB_OKCANCEL,MB_ABORTRETRYIGNORE,MB_YESNOCANCEL,MB_YESNO,MB_RETRYCANCEL
// the default button (MB_DEFBUTTON1 is normal default):
// MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3
// and optionally an icon style:
// MB_ICONERROR, MB_ICONQUESTION, MB_ICONWARNING, MB_ICONINFORMATION

typedef enum tagMSITRANSFORM_ERROR
{
	MSITRANSFORM_ERROR_ADDEXISTINGROW   =  0x00000001,
	MSITRANSFORM_ERROR_DELMISSINGROW    =  0x00000002,
	MSITRANSFORM_ERROR_ADDEXISTINGTABLE =  0x00000004,
	MSITRANSFORM_ERROR_DELMISSINGTABLE  =  0x00000008,
	MSITRANSFORM_ERROR_UPDATEMISSINGROW =  0x00000010,
	MSITRANSFORM_ERROR_CHANGECODEPAGE   =  0x00000020,
	MSITRANSFORM_ERROR_VIEWTRANSFORM    =  0x00000100,
} MSITRANSFORM_ERROR;

typedef enum tagMSITRANSFORM_VALIDATE
{
	MSITRANSFORM_VALIDATE_LANGUAGE                   = 0x00000001,
	MSITRANSFORM_VALIDATE_PRODUCT                    = 0x00000002,
	MSITRANSFORM_VALIDATE_PLATFORM                   = 0x00000004,
	MSITRANSFORM_VALIDATE_MAJORVERSION               = 0x00000008,
	MSITRANSFORM_VALIDATE_MINORVERSION               = 0x00000010,
	MSITRANSFORM_VALIDATE_UPDATEVERSION              = 0x00000020,
	MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION         = 0x00000040,
	MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION    = 0x00000080,
	MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION        = 0x00000100,
	MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = 0x00000200,
	MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION      = 0x00000400,
	MSITRANSFORM_VALIDATE_UPGRADECODE                = 0x00000800,
} MSITRANSFORM_VALIDATE;

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// Installer database access functions
// --------------------------------------------------------------------------

// Prepare a database query, creating a view object
// Returns ERROR_SUCCESS if successful, and the view handle is returned,
// else ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_BAD_QUERY_SYNTAX, ERROR_GEN_FAILURE
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseOpenViewA(MSIHANDLE hDatabase,
	LPCSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView);            // returned view if TRUE
UINT WINAPI MsiDatabaseOpenViewW(MSIHANDLE hDatabase,
	LPCWSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView);            // returned view if TRUE
#ifdef UNICODE
#define MsiDatabaseOpenView  MsiDatabaseOpenViewW
#else
#define MsiDatabaseOpenView  MsiDatabaseOpenViewA
#endif // !UNICODE

// Returns the MSIDBERROR enum and name of the column corresponding to the error
// Similar to a GetLastError function, but for the view. NOT the same as MsiGetLastErrorRecord
// Returns errors of MsiViewModify.

MSIDBERROR WINAPI MsiViewGetErrorA(MSIHANDLE hView,
	LPSTR szColumnNameBuffer,  // buffer to hold column name 
	DWORD* pcchBuf);			 // size of buffer
MSIDBERROR WINAPI MsiViewGetErrorW(MSIHANDLE hView,
	LPWSTR szColumnNameBuffer,  // buffer to hold column name 
	DWORD* pcchBuf);			 // size of buffer
#ifdef UNICODE
#define MsiViewGetError  MsiViewGetErrorW
#else
#define MsiViewGetError  MsiViewGetErrorA
#endif // !UNICODE

// Exectute the view query, supplying parameters as required
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_GEN_FAILURE
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiViewExecute(MSIHANDLE hView,
	MSIHANDLE hRecord);             // optional parameter record, or 0 if none

// Fetch the next sequential record from the view
// Result is ERROR_SUCCESS if a row is found, and its handle is returned
// else ERROR_NO_MORE_ITEMS if no records remain, and a null handle is returned
// else result is error: ERROR_INVALID_HANDLE_STATE, ERROR_INVALID_HANDLE, ERROR_GEN_FAILURE

UINT WINAPI MsiViewFetch(MSIHANDLE hView,
	MSIHANDLE  *phRecord);          // returned data record if fetch succeeds

// Modify a database record, parameters must match types in query columns
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_GEN_FAILURE, ERROR_ACCESS_DENIED
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiViewModify(MSIHANDLE hView,
	MSIMODIFY eModifyMode,         // modify action to perform
	MSIHANDLE hRecord);            // record obtained from fetch, or new record

// Return the column names or specifications for the current view
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, or ERROR_INVALID_HANDLE_STATE

UINT WINAPI MsiViewGetColumnInfo(MSIHANDLE hView,
	MSICOLINFO eColumnInfo,        // retrieve columns names or definitions
	MSIHANDLE *phRecord);          // returned data record containing all names or definitions

// Release the result set for an executed view, to allow re-execution
// Only needs to be called if not all records have been fetched
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE

UINT WINAPI MsiViewClose(MSIHANDLE hView);

// Return a record containing the names of all primary key columns for a given table
// Returns an MSIHANDLE for a record containing the name of each column.
// The field count of the record corresponds to the number of primary key columns.
// Field [0] of the record contains the table name.
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_TABLE

UINT WINAPI MsiDatabaseGetPrimaryKeysA(MSIHANDLE hDatabase,
	LPCSTR    szTableName,       // the name of a specific table <case-sensitive>
	MSIHANDLE  *phRecord);         // returned record if ERROR_SUCCESS
UINT WINAPI MsiDatabaseGetPrimaryKeysW(MSIHANDLE hDatabase,
	LPCWSTR    szTableName,       // the name of a specific table <case-sensitive>
	MSIHANDLE  *phRecord);         // returned record if ERROR_SUCCESS
#ifdef UNICODE
#define MsiDatabaseGetPrimaryKeys  MsiDatabaseGetPrimaryKeysW
#else
#define MsiDatabaseGetPrimaryKeys  MsiDatabaseGetPrimaryKeysA
#endif // !UNICODE

// Return an enum defining the state of the table (temporary, unknown, or persistent).
// Returns MSICONDITION_ERROR, MSICONDITION_FALSE, MSICONDITION_TRUE, MSICONDITION_NONE

MSICONDITION WINAPI MsiDatabaseIsTablePersistentA(MSIHANDLE hDatabase,
	LPCSTR szTableName);         // the name of a specific table
MSICONDITION WINAPI MsiDatabaseIsTablePersistentW(MSIHANDLE hDatabase,
	LPCWSTR szTableName);         // the name of a specific table
#ifdef UNICODE
#define MsiDatabaseIsTablePersistent  MsiDatabaseIsTablePersistentW
#else
#define MsiDatabaseIsTablePersistent  MsiDatabaseIsTablePersistentA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Summary information stream management functions
// --------------------------------------------------------------------------

// Integer Property IDs:    1, 14, 15, 16, 19 
// DateTime Property IDs:   10, 11, 12, 13
// Text Property IDs:       2, 3, 4, 5, 6, 7, 8, 9, 18
// Unsupported Propery IDs: 0 (PID_DICTIONARY), 17 (PID_THUMBNAIL)

// Obtain a handle for the _SummaryInformation stream for an MSI database     
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetSummaryInformationA(MSIHANDLE hDatabase, // 0 if not open
	LPCSTR  szDatabasePath,  // path to database, 0 if database handle supplied
	UINT     uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo); // returned handle to summary information data
UINT WINAPI MsiGetSummaryInformationW(MSIHANDLE hDatabase, // 0 if not open
	LPCWSTR  szDatabasePath,  // path to database, 0 if database handle supplied
	UINT     uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo); // returned handle to summary information data
#ifdef UNICODE
#define MsiGetSummaryInformation  MsiGetSummaryInformationW
#else
#define MsiGetSummaryInformation  MsiGetSummaryInformationA
#endif // !UNICODE

// Obtain the number of existing properties in the SummaryInformation stream

UINT WINAPI MsiSummaryInfoGetPropertyCount(MSIHANDLE hSummaryInfo,
	UINT *puiPropertyCount); // pointer to location to return total property count

// Set a single summary information property
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT WINAPI MsiSummaryInfoSetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCSTR szValue);       // text value, used only if string property
UINT WINAPI MsiSummaryInfoSetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCWSTR szValue);       // text value, used only if string property
#ifdef UNICODE
#define MsiSummaryInfoSetProperty  MsiSummaryInfoSetPropertyW
#else
#define MsiSummaryInfoSetProperty  MsiSummaryInfoSetPropertyA
#endif // !UNICODE

// Get a single property from the summary information
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT WINAPI MsiSummaryInfoGetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPSTR  szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiSummaryInfoGetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPWSTR  szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiSummaryInfoGetProperty  MsiSummaryInfoGetPropertyW
#else
#define MsiSummaryInfoGetProperty  MsiSummaryInfoGetPropertyA
#endif // !UNICODE

// Write back changed information to summary information stream

UINT WINAPI MsiSummaryInfoPersist(MSIHANDLE hSummaryInfo);

// --------------------------------------------------------------------------
// Installer database management functions - not used by custom actions
// --------------------------------------------------------------------------

// Open an installer database, specifying the persistance mode, which is a pointer.
// Predefined persist values are reserved pointer values, requiring pointer arithmetic.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiOpenDatabaseA(
	LPCSTR      szDatabasePath,  // path to database, 0 to create temporary database
	LPCSTR      szPersist,       // output database path or one of predefined values
	MSIHANDLE*   phDatabase);     // location to return database handle
UINT WINAPI MsiOpenDatabaseW(
	LPCWSTR      szDatabasePath,  // path to database, 0 to create temporary database
	LPCWSTR      szPersist,       // output database path or one of predefined values
	MSIHANDLE*   phDatabase);     // location to return database handle
#ifdef UNICODE
#define MsiOpenDatabase  MsiOpenDatabaseW
#else
#define MsiOpenDatabase  MsiOpenDatabaseA
#endif // !UNICODE

// Import an MSI text archive table into an open database
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseImportA(MSIHANDLE hDatabase,
	LPCSTR   szFolderPath,     // folder containing archive files
	LPCSTR   szFileName);      // table archive file to be imported
UINT WINAPI MsiDatabaseImportW(MSIHANDLE hDatabase,
	LPCWSTR   szFolderPath,     // folder containing archive files
	LPCWSTR   szFileName);      // table archive file to be imported
#ifdef UNICODE
#define MsiDatabaseImport  MsiDatabaseImportW
#else
#define MsiDatabaseImport  MsiDatabaseImportA
#endif // !UNICODE

// Export an MSI table from an open database to a text archive file
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseExportA(MSIHANDLE hDatabase,
	LPCSTR   szTableName,      // name of table in database <case-sensitive>
	LPCSTR   szFolderPath,     // folder containing archive files
	LPCSTR   szFileName);      // name of exported table archive file
UINT WINAPI MsiDatabaseExportW(MSIHANDLE hDatabase,
	LPCWSTR   szTableName,      // name of table in database <case-sensitive>
	LPCWSTR   szFolderPath,     // folder containing archive files
	LPCWSTR   szFileName);      // name of exported table archive file
#ifdef UNICODE
#define MsiDatabaseExport  MsiDatabaseExportW
#else
#define MsiDatabaseExport  MsiDatabaseExportA
#endif // !UNICODE

// Merge two database together, allowing duplicate rows
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseMergeA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCSTR   szTableName);      // name of non-persistent table to receive errors
UINT WINAPI MsiDatabaseMergeW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCWSTR   szTableName);      // name of non-persistent table to receive errors
#ifdef UNICODE
#define MsiDatabaseMerge  MsiDatabaseMergeW
#else
#define MsiDatabaseMerge  MsiDatabaseMergeA
#endif // !UNICODE

// Generate a transform file of differences between two databases
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseGenerateTransformA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCSTR   szTransformFile,   // name of generated transform file
	int       iReserved1,         // reserved argument, not used
	int       iReserved2);        // reserved argument, not used
UINT WINAPI MsiDatabaseGenerateTransformW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCWSTR   szTransformFile,   // name of generated transform file
	int       iReserved1,         // reserved argument, not used
	int       iReserved2);        // reserved argument, not used
#ifdef UNICODE
#define MsiDatabaseGenerateTransform  MsiDatabaseGenerateTransformW
#else
#define MsiDatabaseGenerateTransform  MsiDatabaseGenerateTransformA
#endif // !UNICODE

// Apply a transform file containing database difference
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseApplyTransformA(MSIHANDLE hDatabase,
	LPCSTR   szTransformFile,    // name of transform file
	int       iErrorConditions);   // errors to suppress, bits from MSITRANSFORM_ERROR
UINT WINAPI MsiDatabaseApplyTransformW(MSIHANDLE hDatabase,
	LPCWSTR   szTransformFile,    // name of transform file
	int       iErrorConditions);   // errors to suppress, bits from MSITRANSFORM_ERROR
#ifdef UNICODE
#define MsiDatabaseApplyTransform  MsiDatabaseApplyTransformW
#else
#define MsiDatabaseApplyTransform  MsiDatabaseApplyTransformA
#endif // !UNICODE

// Create summary information of existing transform to include validation and error conditions
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiCreateTransformSummaryInfoA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCSTR   szTransformFile,    // name of generated transform file
	int       iErrorConditions,    // errors to suppress when applied, from MSITRANSFORM_ERROR
	int       iValidation);        // properties validated when applied, MSITRANSFORM_VALIDATE
UINT WINAPI MsiCreateTransformSummaryInfoW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCWSTR   szTransformFile,    // name of generated transform file
	int       iErrorConditions,    // errors to suppress when applied, from MSITRANSFORM_ERROR
	int       iValidation);        // properties validated when applied, MSITRANSFORM_VALIDATE
#ifdef UNICODE
#define MsiCreateTransformSummaryInfo  MsiCreateTransformSummaryInfoW
#else
#define MsiCreateTransformSummaryInfo  MsiCreateTransformSummaryInfoA
#endif // !UNICODE

// Write out all persistent table data, ignored if database opened read-only
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseCommit(MSIHANDLE hDatabase);

// Return the update state of a database

MSIDBSTATE WINAPI MsiGetDatabaseState(MSIHANDLE hDatabase);

// --------------------------------------------------------------------------
// Record object functions
// --------------------------------------------------------------------------

// Create a new record object with the requested number of fields
// Field 0, not included in count, is used for format strings and op codes
// All fields are initialized to null
// Returns a handle to the created record, or 0 if memory could not be allocated

MSIHANDLE WINAPI MsiCreateRecord(
	UINT cParams);                   // the number of data fields

// Report whether a record field is NULL
// Returns TRUE if the field is null or does not exist
// Returns FALSE if the field contains data, or the handle is invalid

BOOL WINAPI MsiRecordIsNull(MSIHANDLE hRecord,
	UINT iField);

// Return the length of a record field
// Returns 0 if field is NULL or non-existent
// Returns sizeof(int) if integer data
// Returns character count if string data (not counting null terminator)
// Returns bytes count if stream data

UINT WINAPI MsiRecordDataSize(MSIHANDLE hRecord,
	UINT iField);

// Set a record field to an integer value
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT WINAPI MsiRecordSetInteger(MSIHANDLE hRecord,
	UINT iField,
	int iValue);

// Copy a string into the designated field
// A null string pointer and an empty string both set the field to null
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT WINAPI MsiRecordSetStringA(MSIHANDLE hRecord,
	UINT iField,
	LPCSTR      szValue);
UINT WINAPI MsiRecordSetStringW(MSIHANDLE hRecord,
	UINT iField,
	LPCWSTR      szValue);
#ifdef UNICODE
#define MsiRecordSetString  MsiRecordSetStringW
#else
#define MsiRecordSetString  MsiRecordSetStringA
#endif // !UNICODE

// Return the integer value from a record field
// Returns the value MSI_NULL_INTEGER if the field is null
// or if the field is a string that cannot be converted to an integer

int WINAPI MsiRecordGetInteger(MSIHANDLE hRecord,
	UINT iField);

// Return the string value of a record field
// Integer fields will be converted to a string
// Null and non-existent fields will report a value of 0
// Fields containing stream data will return ERROR_INVALID_DATATYPE
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, 
//         ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD, ERROR_BAD_ARGUMENTS

UINT WINAPI MsiRecordGetStringA(MSIHANDLE hRecord,
	UINT iField,
	LPSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf);   // in/out buffer character count
UINT WINAPI MsiRecordGetStringW(MSIHANDLE hRecord,
	UINT iField,
	LPWSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf);   // in/out buffer character count
#ifdef UNICODE
#define MsiRecordGetString  MsiRecordGetStringW
#else
#define MsiRecordGetString  MsiRecordGetStringA
#endif // !UNICODE

// Returns the number of fields allocated in the record
// Does not count field 0, used for formatting and op codes

UINT WINAPI MsiRecordGetFieldCount(MSIHANDLE hRecord);

// Set a record stream field from a file
// The contents of the specified file will be read into a stream object
// The stream will be persisted if the record is inserted into the database
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiRecordSetStreamA(MSIHANDLE hRecord,
	UINT iField,
	LPCSTR      szFilePath);   // path to file containing stream data
UINT WINAPI MsiRecordSetStreamW(MSIHANDLE hRecord,
	UINT iField,
	LPCWSTR      szFilePath);   // path to file containing stream data
#ifdef UNICODE
#define MsiRecordSetStream  MsiRecordSetStreamW
#else
#define MsiRecordSetStream  MsiRecordSetStreamA
#endif // !UNICODE

// Read bytes from a record stream field into a buffer
// Must set the in/out argument to the requested byte count to read
// The number of bytes transferred is returned through the argument
// If no more bytes are available, ERROR_SUCCESS is still returned

UINT WINAPI MsiRecordReadStream(MSIHANDLE hRecord,
	UINT iField,
	char    *szDataBuf,     // buffer to receive bytes from stream
	DWORD   *pcbDataBuf);   // in/out buffer byte count

// Clears all data fields in a record to NULL

UINT WINAPI MsiRecordClearData(MSIHANDLE hRecord);

// --------------------------------------------------------------------------
// Functions to access a running installation, called from custom actions
// The install handle is the single argument passed to custom actions
// --------------------------------------------------------------------------

// Return a handle to the database currently in use by this installer instance

MSIHANDLE WINAPI MsiGetActiveDatabase(MSIHANDLE hInstall); // returns handle to database, 0 if none active

// Set the value for an installer property
// If the property is not defined, it will be created
// If the value is null or an empty string, the property will be removed
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_BAD_ARGUMENTS

UINT WINAPI MsiSetPropertyA(MSIHANDLE hInstall,
	LPCSTR   szName,       // property identifier, case-sensitive
	LPCSTR   szValue);     // property value, null to undefine property
UINT WINAPI MsiSetPropertyW(MSIHANDLE hInstall,
	LPCWSTR   szName,       // property identifier, case-sensitive
	LPCWSTR   szValue);     // property value, null to undefine property
#ifdef UNICODE
#define MsiSetProperty  MsiSetPropertyW
#else
#define MsiSetProperty  MsiSetPropertyA
#endif // !UNICODE

// Get the value for an installer property
// If the property is not defined, it is equivalent to a 0-length value, not error
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, ERROR_INVALID_HANDLE, ERROR_BAD_ARGUMENTS

UINT  WINAPI MsiGetPropertyA(MSIHANDLE hInstall,
	LPCSTR szName,           // property identifier, case-sensitive
	LPSTR  szValueBuf,       // buffer for returned property value
	DWORD   *pcchValueBuf);   // in/out buffer character count
UINT  WINAPI MsiGetPropertyW(MSIHANDLE hInstall,
	LPCWSTR szName,           // property identifier, case-sensitive
	LPWSTR  szValueBuf,       // buffer for returned property value
	DWORD   *pcchValueBuf);   // in/out buffer character count
#ifdef UNICODE
#define MsiGetProperty  MsiGetPropertyW
#else
#define MsiGetProperty  MsiGetPropertyA
#endif // !UNICODE

// Return the numeric language for the currently running install
// Returns 0 if an install not running

LANGID WINAPI MsiGetLanguage(MSIHANDLE hInstall);

// Return one of the boolean internal installer states
// Returns FALSE if the handle is not active or if the mode is not implemented

BOOL WINAPI MsiGetMode(MSIHANDLE hInstall,
	MSIRUNMODE eRunMode);   // particular mode for which the state is returned

// Set an internal install session boolean mode - Note: most modes are read-only
// Returns ERROR_SUCCESS if the mode can be set to the desired state
// Returns ERROR_ACCESS_DENIED if the mode is not settable
// Returns ERROR_INVALID_HANDLE if the handle is not an active install session

UINT WINAPI MsiSetMode(MSIHANDLE hInstall,
	MSIRUNMODE eRunMode,    // particular mode for which state is to be set
	BOOL fState);           // new state for bit flag

// Format record data using a format string containing field markers and/or properties
// Record field 0 must contain the format string
// Other fields must contain data that may be referenced by the format string.

UINT WINAPI MsiFormatRecordA(MSIHANDLE hInstall, // non-zero for property expansion
	MSIHANDLE hRecord,        // handle to record, field 0 contains format string
	LPSTR    szResultBuf,    // buffer to return formatted string
	DWORD    *pcchResultBuf); // in/out buffer character count
UINT WINAPI MsiFormatRecordW(MSIHANDLE hInstall, // non-zero for property expansion
	MSIHANDLE hRecord,        // handle to record, field 0 contains format string
	LPWSTR    szResultBuf,    // buffer to return formatted string
	DWORD    *pcchResultBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiFormatRecord  MsiFormatRecordW
#else
#define MsiFormatRecord  MsiFormatRecordA
#endif // !UNICODE

// Execute another action, either built-in, custom, or UI wizard
// Returns ERROR_FUNCTION_NOT_CALLED if action not found
// Returns ERROR_SUCCESS if action completed succesfully
// Returns ERROR_INSTALL_USEREXIT if user cancelled during action
// Returns ERROR_INSTALL_FAILURE if action failed
// Returns ERROR_INSTALL_SUSPEND if user suspended installation
// Returns ERROR_MORE_DATA if action wishes to skip remaining actions
// Returns ERROR_INVALID_HANDLE_STATE if install session not active
// Returns ERROR_INVALID_DATA if failure calling custom action
// Returns ERROR_INVALID_HANDLE or ERROR_INVALID_PARAMETER if arguments invalid

UINT WINAPI MsiDoActionA(MSIHANDLE hInstall,
	LPCSTR szAction);     // name of action to call, case-sensitive
UINT WINAPI MsiDoActionW(MSIHANDLE hInstall,
	LPCWSTR szAction);     // name of action to call, case-sensitive
#ifdef UNICODE
#define MsiDoAction  MsiDoActionW
#else
#define MsiDoAction  MsiDoActionA
#endif // !UNICODE

// Execute another action sequence, as descibed in the specified table
// Returns the same error codes as MsiDoAction

UINT WINAPI MsiSequenceA(MSIHANDLE hInstall,
	LPCSTR szTable,       // name of table containing action sequence
	INT iSequenceMode);     // for future use, must be 0 in MSI 1.0
UINT WINAPI MsiSequenceW(MSIHANDLE hInstall,
	LPCWSTR szTable,       // name of table containing action sequence
	INT iSequenceMode);     // for future use, must be 0 in MSI 1.0
#ifdef UNICODE
#define MsiSequence  MsiSequenceW
#else
#define MsiSequence  MsiSequenceA
#endif // !UNICODE

// Send an error record to the installer for processing.
// If field 0 (template) is not set, field 1 must be set to the error code,
//   corresponding the the error message in the Error database table,
//   and the message will be formatted using the template from the Error table
//   before passing it to the UI handler for display.
// Returns Win32 button codes: IDOK IDCANCEL IDABORT IDRETRY IDIGNORE IDYES IDNO
//   or 0 if no action taken, or -1 if invalid argument or handle

int WINAPI MsiProcessMessage(MSIHANDLE hInstall,
	INSTALLMESSAGE eMessageType, // type of message
	MSIHANDLE hRecord);          // record containing message format and data

// Evaluate a conditional expression containing property names and values

MSICONDITION WINAPI MsiEvaluateConditionA(MSIHANDLE hInstall,
	LPCSTR  szCondition);
MSICONDITION WINAPI MsiEvaluateConditionW(MSIHANDLE hInstall,
	LPCWSTR  szCondition);
#ifdef UNICODE
#define MsiEvaluateCondition  MsiEvaluateConditionW
#else
#define MsiEvaluateCondition  MsiEvaluateConditionA
#endif // !UNICODE

// Get the installed state and requested action state of a feature
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
UINT WINAPI MsiGetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
#ifdef UNICODE
#define MsiGetFeatureState  MsiGetFeatureStateW
#else
#define MsiGetFeatureState  MsiGetFeatureStateA
#endif // !UNICODE

// Request a feature to be set to a specified state
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	INSTALLSTATE iState);       // requested state for feature
UINT WINAPI MsiSetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	INSTALLSTATE iState);       // requested state for feature
#ifdef UNICODE
#define MsiSetFeatureState  MsiSetFeatureStateW
#else
#define MsiSetFeatureState  MsiSetFeatureStateA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// Set the attribute bits of a specified feature at runtime.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetFeatureAttributesA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	DWORD dwAttributes);        // attributes bits to set for this feature
UINT WINAPI MsiSetFeatureAttributesW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	DWORD dwAttributes);        // attributes bits to set for this feature
#ifdef UNICODE
#define MsiSetFeatureAttributes  MsiSetFeatureAttributesW
#else
#define MsiSetFeatureAttributes  MsiSetFeatureAttributesA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

// Get the installed state and requested action state of a component
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetComponentStateA(MSIHANDLE hInstall,
	LPCSTR     szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
UINT WINAPI MsiGetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR     szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
#ifdef UNICODE
#define MsiGetComponentState  MsiGetComponentStateW
#else
#define MsiGetComponentState  MsiGetComponentStateA
#endif // !UNICODE

// Request a component to be set to a specified state
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetComponentStateA(MSIHANDLE hInstall,
	LPCSTR     szComponent,   // component name within product
	INSTALLSTATE iState);       // requested state for component
UINT WINAPI MsiSetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR     szComponent,   // component name within product
	INSTALLSTATE iState);       // requested state for component
#ifdef UNICODE
#define MsiSetComponentState  MsiSetComponentStateW
#else
#define MsiSetComponentState  MsiSetComponentStateA
#endif // !UNICODE

// Return the disk cost for a feature and related features
// Can specify either current feature state or proposed state
// Can specify extent of related features to cost
// Note that adding costs for several features may produce an
// excessively large cost due to shared components and parents.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiGetFeatureCostA(MSIHANDLE hInstall,
	LPCSTR      szFeature,      // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost);      // returned cost, in units of 512 bytes
UINT  WINAPI MsiGetFeatureCostW(MSIHANDLE hInstall,
	LPCWSTR      szFeature,      // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost);      // returned cost, in units of 512 bytes
#ifdef UNICODE
#define MsiGetFeatureCost  MsiGetFeatureCostW
#else
#define MsiGetFeatureCost  MsiGetFeatureCostA
#endif // !UNICODE

// Set the install level for a full product installation (not a feature request)
// Setting the value to 0 initialized components and features to the default level
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiSetInstallLevel(MSIHANDLE hInstall,
	int iInstallLevel);

// Get the valid install states for a feature, represented by bit flags
// For each valid install state, a bit is set of value: (1 << INSTALLSTATE)
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiGetFeatureValidStatesA(MSIHANDLE hInstall,
	LPCSTR szFeature,
	DWORD  *dwInstallStates);
UINT  WINAPI MsiGetFeatureValidStatesW(MSIHANDLE hInstall,
	LPCWSTR szFeature,
	DWORD  *dwInstallStates);
#ifdef UNICODE
#define MsiGetFeatureValidStates  MsiGetFeatureValidStatesW
#else
#define MsiGetFeatureValidStates  MsiGetFeatureValidStatesA
#endif // !UNICODE

// Return the full source path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetSourcePathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
UINT WINAPI MsiGetSourcePathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetSourcePath  MsiGetSourcePathW
#else
#define MsiGetSourcePath  MsiGetSourcePathA
#endif // !UNICODE

// Return the full target path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetTargetPathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
UINT WINAPI MsiGetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetTargetPath  MsiGetTargetPathW
#else
#define MsiGetTargetPath  MsiGetTargetPathA
#endif // !UNICODE

// Set the full target path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetTargetPathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCSTR     szFolderPath);  // full path for folder, ending in directory separator
UINT WINAPI MsiSetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCWSTR     szFolderPath);  // full path for folder, ending in directory separator
#ifdef UNICODE
#define MsiSetTargetPath  MsiSetTargetPathW
#else
#define MsiSetTargetPath  MsiSetTargetPathA
#endif // !UNICODE

// Check to see if sufficent disk space is present for the current installation
// Returns ERROR_SUCCESS, ERROR_DISK_FULL, ERROR_INVALID_HANDLE_STATE, or ERROR_INVALID_HANDLE

UINT WINAPI MsiVerifyDiskSpace(MSIHANDLE hInstall);

// --------------------------------------------------------------------------
// Functions for rendering UI dialogs from the database representations.
// Purpose is for product development, not for use during installation.
// --------------------------------------------------------------------------

// Enable UI in preview mode to facilitate authoring of UI dialogs.
// The preview mode will end when the handle is closed.

UINT WINAPI MsiEnableUIPreview(MSIHANDLE hDatabase,
	MSIHANDLE* phPreview);       // returned handle for UI preview capability

// Display any UI dialog as modeless and inactive.
// Supplying a null name will remove any current dialog.

UINT WINAPI MsiPreviewDialogA(MSIHANDLE hPreview,
	LPCSTR szDialogName);      // dialog to display, Dialog table key
UINT WINAPI MsiPreviewDialogW(MSIHANDLE hPreview,
	LPCWSTR szDialogName);      // dialog to display, Dialog table key
#ifdef UNICODE
#define MsiPreviewDialog  MsiPreviewDialogW
#else
#define MsiPreviewDialog  MsiPreviewDialogA
#endif // !UNICODE

// Display a billboard within a host control in the displayed dialog.
// Supplying a null billboard name will remove any billboard displayed.

UINT WINAPI MsiPreviewBillboardA(MSIHANDLE hPreview,
	LPCSTR szControlName,      // name of control that accepts billboards
	LPCSTR szBillboard);       // name of billboard to display
UINT WINAPI MsiPreviewBillboardW(MSIHANDLE hPreview,
	LPCWSTR szControlName,      // name of control that accepts billboards
	LPCWSTR szBillboard);       // name of billboard to display
#ifdef UNICODE
#define MsiPreviewBillboard  MsiPreviewBillboardW
#else
#define MsiPreviewBillboard  MsiPreviewBillboardA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Error handling not associated with any particular object
// --------------------------------------------------------------------------

// Return a record handle to the last function that generated an error record
// Only specified functions will set the error record, or clear it if success
// Field 1 of the record will contain the internal MSI error code
// Other fields will contain data specific to the particular error
// The error record is released internally after this function is executed

MSIHANDLE WINAPI MsiGetLastErrorRecord();  // returns 0 if no cached record

#ifdef __cplusplus
}
#endif

#endif // _MSIQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\include\mshelp.h ===
//------------------------------------------------------------------------------
// <copyright file="MsHelp.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   MsHelp.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the MSHELP_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// MSHELP_API functions as being imported from a DLL, whereas this DLL sees symbols
// defined with this macro as being exported.
#ifdef MSHELP_EXPORTS
#define MSHELP_API  extern "C" __declspec(dllexport) UINT __stdcall
#else
#define MSHELP_API __declspec(dllimport)
#endif

// MSHelp 
#import "Lib\hxds.dll"  named_guids no_namespace
#import "Lib\hxvz.dll" named_guids no_namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\include\msi.h ===
/*****************************************************************************\
*                                                                             *
* msi.h - - Interface for external access to Installer Service                *
*                                                                             *
* Version 1.0 - 1.2                                                           *
*                                                                             *
* NOTES:  All buffers sizes are TCHAR count, null included only on input      *
*         Return argument pointers may be null if not interested in value     *
*                                                                             *
* Copyright (c) 1999-2000, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _MSI_H_
#define _MSI_H_

#ifndef _WIN32_MSI
#if (_WIN32_WINNT >= 0x0500)
#define _WIN32_MSI   110
#else
#define _WIN32_MSI   100
#endif //(_WIN32_WINNT >= 0x0500)
#endif // !_WIN32_MSI

// --------------------------------------------------------------------------
// Installer generic handle definitions
// --------------------------------------------------------------------------

typedef unsigned long MSIHANDLE;     // abstract generic handle, 0 == no handle

#ifdef __cplusplus
extern "C" {
#endif

// Close a open handle of any type
// All handles obtained from API calls must be closed when no longer needed
// Normally succeeds, returning TRUE. 

UINT WINAPI MsiCloseHandle(MSIHANDLE hAny);

// Close all handles open in the process, a diagnostic call
// This should NOT be used as a cleanup mechanism -- use PMSIHANDLE class
// Can be called at termination to assure that all handles have been closed
// Returns 0 if all handles have been close, else number of open handles

UINT WINAPI MsiCloseAllHandles();

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

// C++ wrapper object to automatically free handle when going out of scope

class PMSIHANDLE
{
	MSIHANDLE m_h;
 public:
	PMSIHANDLE():m_h(0){}
	PMSIHANDLE(MSIHANDLE h):m_h(h){}
  ~PMSIHANDLE(){if (m_h!=0) MsiCloseHandle(m_h);}
	void operator =(MSIHANDLE h) {if (m_h) MsiCloseHandle(m_h); m_h=h;}
	operator MSIHANDLE() {return m_h;}
	MSIHANDLE* operator &() {if (m_h) MsiCloseHandle(m_h); m_h = 0; return &m_h;}
};
#endif  //__cplusplus

// Install message type for callback is a combination of the following:
//  A message box style:      MB_*, where MB_OK is the default
//  A message box icon type:  MB_ICON*, where no icon is the default
//  A default button:         MB_DEFBUTTON?, where MB_DEFBUTTON1 is the default
//  One of the following install message types, no default
typedef enum tagINSTALLMESSAGE
{
	INSTALLMESSAGE_FATALEXIT      = 0x00000000L, // premature termination, possibly fatal OOM
	INSTALLMESSAGE_ERROR          = 0x01000000L, // formatted error message
	INSTALLMESSAGE_WARNING        = 0x02000000L, // formatted warning message
	INSTALLMESSAGE_USER           = 0x03000000L, // user request message
	INSTALLMESSAGE_INFO           = 0x04000000L, // informative message for log
	INSTALLMESSAGE_FILESINUSE     = 0x05000000L, // list of files in use that need to be replaced
	INSTALLMESSAGE_RESOLVESOURCE  = 0x06000000L, // request to determine a valid source location
	INSTALLMESSAGE_OUTOFDISKSPACE = 0x07000000L, // insufficient disk space message
	INSTALLMESSAGE_ACTIONSTART    = 0x08000000L, // start of action: action name & description
	INSTALLMESSAGE_ACTIONDATA     = 0x09000000L, // formatted data associated with individual action item
	INSTALLMESSAGE_PROGRESS       = 0x0A000000L, // progress gauge info: units so far, total
	INSTALLMESSAGE_COMMONDATA     = 0x0B000000L, // product info for dialog: language Id, dialog caption
	INSTALLMESSAGE_INITIALIZE     = 0x0C000000L, // sent prior to UI initialization, no string data
	INSTALLMESSAGE_TERMINATE      = 0x0D000000L, // sent after UI termination, no string data
	INSTALLMESSAGE_SHOWDIALOG     = 0x0E000000L, // sent prior to display or authored dialog or wizard
} INSTALLMESSAGE;

// external error handler supplied to installation API functions
typedef int (WINAPI *INSTALLUI_HANDLERA)(LPVOID pvContext, UINT iMessageType, LPCSTR szMessage);
// external error handler supplied to installation API functions
typedef int (WINAPI *INSTALLUI_HANDLERW)(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage);
#ifdef UNICODE
#define INSTALLUI_HANDLER  INSTALLUI_HANDLERW
#else
#define INSTALLUI_HANDLER  INSTALLUI_HANDLERA
#endif // !UNICODE

typedef enum tagINSTALLUILEVEL
{
	INSTALLUILEVEL_NOCHANGE = 0,    // UI level is unchanged
	INSTALLUILEVEL_DEFAULT  = 1,    // default UI is used
	INSTALLUILEVEL_NONE     = 2,    // completely silent installation
	INSTALLUILEVEL_BASIC    = 3,    // simple progress and error handling
	INSTALLUILEVEL_REDUCED  = 4,    // authored UI, wizard dialogs suppressed
	INSTALLUILEVEL_FULL     = 5,    // authored UI with wizards, progress, errors
	INSTALLUILEVEL_ENDDIALOG    = 0x80, // display success/failure dialog at end of install
	INSTALLUILEVEL_PROGRESSONLY = 0x40, // display only progress dialog
} INSTALLUILEVEL;

typedef enum tagINSTALLSTATE
{
	INSTALLSTATE_NOTUSED      = -7,  // component disabled
	INSTALLSTATE_BADCONFIG    = -6,  // configuration data corrupt
	INSTALLSTATE_INCOMPLETE   = -5,  // installation suspended or in progress
	INSTALLSTATE_SOURCEABSENT = -4,  // run from source, source is unavailable
	INSTALLSTATE_MOREDATA     = -3,  // return buffer overflow
	INSTALLSTATE_INVALIDARG   = -2,  // invalid function argument
	INSTALLSTATE_UNKNOWN      = -1,  // unrecognized product or feature
	INSTALLSTATE_BROKEN       =  0,  // broken
	INSTALLSTATE_ADVERTISED   =  1,  // advertised feature
	INSTALLSTATE_REMOVED      =  1,  // component being removed (action state, not settable)
	INSTALLSTATE_ABSENT       =  2,  // uninstalled (or action state absent but clients remain)
	INSTALLSTATE_LOCAL        =  3,  // installed on local drive
	INSTALLSTATE_SOURCE       =  4,  // run from source, CD or net
	INSTALLSTATE_DEFAULT      =  5,  // use default, local or source
} INSTALLSTATE;

typedef enum tagUSERINFOSTATE
{
	USERINFOSTATE_MOREDATA   = -3,  // return buffer overflow
	USERINFOSTATE_INVALIDARG = -2,  // invalid function argument
	USERINFOSTATE_UNKNOWN    = -1,  // unrecognized product
	USERINFOSTATE_ABSENT     =  0,  // user info and PID not initialized
	USERINFOSTATE_PRESENT    =  1,  // user info and PID initialized
} USERINFOSTATE;

typedef enum tagINSTALLLEVEL
{
	INSTALLLEVEL_DEFAULT = 0,      // install authored default
	INSTALLLEVEL_MINIMUM = 1,      // install only required features
	INSTALLLEVEL_MAXIMUM = 0xFFFF, // install all features
} INSTALLLEVEL;                   // intermediate levels dependent on authoring

typedef enum tagREINSTALLMODE  // bit flags
{
	REINSTALLMODE_REPAIR           = 0x00000001,  // Reserved bit - currently ignored
	REINSTALLMODE_FILEMISSING      = 0x00000002,  // Reinstall only if file is missing
	REINSTALLMODE_FILEOLDERVERSION = 0x00000004,  // Reinstall if file is missing, or older version
	REINSTALLMODE_FILEEQUALVERSION = 0x00000008,  // Reinstall if file is missing, or equal or older version
	REINSTALLMODE_FILEEXACT        = 0x00000010,  // Reinstall if file is missing, or not exact version
	REINSTALLMODE_FILEVERIFY       = 0x00000020,  // checksum executables, reinstall if missing or corrupt
	REINSTALLMODE_FILEREPLACE      = 0x00000040,  // Reinstall all files, regardless of version
	REINSTALLMODE_MACHINEDATA      = 0x00000080,  // insure required machine reg entries
	REINSTALLMODE_USERDATA         = 0x00000100,  // insure required user reg entries
	REINSTALLMODE_SHORTCUT         = 0x00000200,  // validate shortcuts items
	REINSTALLMODE_PACKAGE          = 0x00000400,  // use re-cache source install package
} REINSTALLMODE;

typedef enum tagINSTALLOGMODE  // bit flags for use with MsiEnableLog and MsiSetExternalUI
{
	INSTALLLOGMODE_FATALEXIT      = (1 << (INSTALLMESSAGE_FATALEXIT      >> 24)),
	INSTALLLOGMODE_ERROR          = (1 << (INSTALLMESSAGE_ERROR          >> 24)),
	INSTALLLOGMODE_WARNING        = (1 << (INSTALLMESSAGE_WARNING        >> 24)),
	INSTALLLOGMODE_USER           = (1 << (INSTALLMESSAGE_USER           >> 24)),
	INSTALLLOGMODE_INFO           = (1 << (INSTALLMESSAGE_INFO           >> 24)),
	INSTALLLOGMODE_RESOLVESOURCE  = (1 << (INSTALLMESSAGE_RESOLVESOURCE  >> 24)),
	INSTALLLOGMODE_OUTOFDISKSPACE = (1 << (INSTALLMESSAGE_OUTOFDISKSPACE >> 24)),
	INSTALLLOGMODE_ACTIONSTART    = (1 << (INSTALLMESSAGE_ACTIONSTART    >> 24)),
	INSTALLLOGMODE_ACTIONDATA     = (1 << (INSTALLMESSAGE_ACTIONDATA     >> 24)),
	INSTALLLOGMODE_COMMONDATA     = (1 << (INSTALLMESSAGE_COMMONDATA     >> 24)),
	INSTALLLOGMODE_PROPERTYDUMP   = (1 << (INSTALLMESSAGE_PROGRESS       >> 24)), // log only
	INSTALLLOGMODE_VERBOSE        = (1 << (INSTALLMESSAGE_INITIALIZE     >> 24)), // log only
	INSTALLLOGMODE_PROGRESS       = (1 << (INSTALLMESSAGE_PROGRESS       >> 24)), // external handler only
	INSTALLLOGMODE_INITIALIZE     = (1 << (INSTALLMESSAGE_INITIALIZE     >> 24)), // external handler only
	INSTALLLOGMODE_TERMINATE      = (1 << (INSTALLMESSAGE_TERMINATE      >> 24)), // external handler only
	INSTALLLOGMODE_SHOWDIALOG     = (1 << (INSTALLMESSAGE_SHOWDIALOG     >> 24)), // external handler only
} INSTALLLOGMODE;

typedef enum tagINSTALLLOGATTRIBUTES // flag attributes for MsiEnableLog
{
	INSTALLLOGATTRIBUTES_APPEND            = (1 << 0),
	INSTALLLOGATTRIBUTES_FLUSHEACHLINE     = (1 << 1),
} INSTALLLOGATTRIBUTES;

typedef enum tagINSTALLFEATUREATTRIBUTE // bit flags
{
	INSTALLFEATUREATTRIBUTE_FAVORLOCAL             = 1 << 0,
	INSTALLFEATUREATTRIBUTE_FAVORSOURCE            = 1 << 1,
	INSTALLFEATUREATTRIBUTE_FOLLOWPARENT           = 1 << 2,
	INSTALLFEATUREATTRIBUTE_FAVORADVERTISE         = 1 << 3,
	INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE      = 1 << 4,
	INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = 1 << 5,
} INSTALLFEATUREATTRIBUTE;

typedef enum tagINSTALLMODE
{
	INSTALLMODE_NOSOURCERESOLUTION   = -3,  // skip source resolution
	INSTALLMODE_NODETECTION          = -2,  // skip detection
	INSTALLMODE_EXISTING             = -1,  // provide, if available
	INSTALLMODE_DEFAULT              =  0,  // install, if absent
} INSTALLMODE;

#define MAX_FEATURE_CHARS  38   // maximum chars in feature name (same as string GUID)


// Product info attributes: advertised information

#define INSTALLPROPERTY_TRANSFORMS            __TEXT("Transforms")
#define INSTALLPROPERTY_LANGUAGE              __TEXT("Language")
#define INSTALLPROPERTY_PRODUCTNAME           __TEXT("ProductName")
#define INSTALLPROPERTY_ASSIGNMENTTYPE        __TEXT("AssignmentType")
#define INSTALLPROPERTY_PACKAGECODE           __TEXT("PackageCode")
#define INSTALLPROPERTY_VERSION               __TEXT("Version")
#if (_WIN32_MSI >=  110)
#define INSTALLPROPERTY_PRODUCTICON           __TEXT("ProductIcon")
#endif //(_WIN32_MSI >=  110)

// Product info attributes: installed information

#define INSTALLPROPERTY_INSTALLEDPRODUCTNAME  __TEXT("InstalledProductName")
#define INSTALLPROPERTY_VERSIONSTRING         __TEXT("VersionString")
#define INSTALLPROPERTY_HELPLINK              __TEXT("HelpLink")
#define INSTALLPROPERTY_HELPTELEPHONE         __TEXT("HelpTelephone")
#define INSTALLPROPERTY_INSTALLLOCATION       __TEXT("InstallLocation")
#define INSTALLPROPERTY_INSTALLSOURCE         __TEXT("InstallSource")
#define INSTALLPROPERTY_INSTALLDATE           __TEXT("InstallDate")
#define INSTALLPROPERTY_PUBLISHER             __TEXT("Publisher")
#define INSTALLPROPERTY_LOCALPACKAGE          __TEXT("LocalPackage")
#define INSTALLPROPERTY_URLINFOABOUT          __TEXT("URLInfoAbout")
#define INSTALLPROPERTY_URLUPDATEINFO         __TEXT("URLUpdateInfo")
#define INSTALLPROPERTY_VERSIONMINOR          __TEXT("VersionMinor")
#define INSTALLPROPERTY_VERSIONMAJOR          __TEXT("VersionMajor")


typedef enum tagINSTALLTYPE
{
	INSTALLTYPE_DEFAULT            =    0,   // set to indicate default behavior
	INSTALLTYPE_NETWORK_IMAGE      =    1,   // set to indicate network install
}INSTALLTYPE;

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// Functions to set the UI handling and logging. The UI will be used for error,
// progress, and log messages for all subsequent calls to Installer Service
// API functions that require UI.
// --------------------------------------------------------------------------

// Enable internal UI

INSTALLUILEVEL WINAPI MsiSetInternalUI(
	INSTALLUILEVEL  dwUILevel,     // UI level
	HWND  *phWnd);                   // handle of owner window

// Enable external UI handling, returns any previous handler or NULL if none.
// Messages are designated with a combination of bits from INSTALLLOGMODE enum.

INSTALLUI_HANDLERA WINAPI MsiSetExternalUIA(
	INSTALLUI_HANDLERA puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	LPVOID             pvContext);   // application context
INSTALLUI_HANDLERW WINAPI MsiSetExternalUIW(
	INSTALLUI_HANDLERW puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	LPVOID             pvContext);   // application context
#ifdef UNICODE
#define MsiSetExternalUI  MsiSetExternalUIW
#else
#define MsiSetExternalUI  MsiSetExternalUIA
#endif // !UNICODE


// Enable logging to a file for all install sessions for the client process,
// with control over which log messages are passed to the specified log file.
// Messages are designated with a combination of bits from INSTALLLOGMODE enum.

UINT WINAPI MsiEnableLogA(
	DWORD     dwLogMode,           // bit flags designating operations to report
	LPCSTR  szLogFile,           // log file, or NULL to disable logging
	DWORD     dwLogAttributes);    // INSTALLLOGATTRIBUTES flags
UINT WINAPI MsiEnableLogW(
	DWORD     dwLogMode,           // bit flags designating operations to report
	LPCWSTR  szLogFile,           // log file, or NULL to disable logging
	DWORD     dwLogAttributes);    // INSTALLLOGATTRIBUTES flags
#ifdef UNICODE
#define MsiEnableLog  MsiEnableLogW
#else
#define MsiEnableLog  MsiEnableLogA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to query and configure a product as a whole.
// --------------------------------------------------------------------------

// Return the installed state for a product

INSTALLSTATE WINAPI MsiQueryProductStateA(
	LPCSTR  szProduct);
INSTALLSTATE WINAPI MsiQueryProductStateW(
	LPCWSTR  szProduct);
#ifdef UNICODE
#define MsiQueryProductState  MsiQueryProductStateW
#else
#define MsiQueryProductState  MsiQueryProductStateA
#endif // !UNICODE

// Return product info

UINT WINAPI MsiGetProductInfoA(
	LPCSTR   szProduct,      // product code
	LPCSTR   szAttribute,    // attribute name, case-sensitive
	LPSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetProductInfoW(
	LPCWSTR   szProduct,      // product code
	LPCWSTR   szAttribute,    // attribute name, case-sensitive
	LPWSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetProductInfo  MsiGetProductInfoW
#else
#define MsiGetProductInfo  MsiGetProductInfoA
#endif // !UNICODE

// Install a new product.
// Either may be NULL, but the DATABASE property must be specfied

UINT WINAPI MsiInstallProductA(
	LPCSTR      szPackagePath,    // location of package to install
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiInstallProductW(
	LPCWSTR      szPackagePath,    // location of package to install
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiInstallProduct  MsiInstallProductW
#else
#define MsiInstallProduct  MsiInstallProductA
#endif // !UNICODE

// Install/uninstall an advertised or installed product
// No action if installed and INSTALLSTATE_DEFAULT specified

UINT WINAPI MsiConfigureProductA(
	LPCSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
UINT WINAPI MsiConfigureProductW(
	LPCWSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
#ifdef UNICODE
#define MsiConfigureProduct  MsiConfigureProductW
#else
#define MsiConfigureProduct  MsiConfigureProductA
#endif // !UNICODE

// Install/uninstall an advertised or installed product
// No action if installed and INSTALLSTATE_DEFAULT specified

UINT WINAPI MsiConfigureProductExA(
	LPCSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState,    // local/source/default/absent/lock/uncache
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiConfigureProductExW(
	LPCWSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState,    // local/source/default/absent/lock/uncache
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiConfigureProductEx  MsiConfigureProductExW
#else
#define MsiConfigureProductEx  MsiConfigureProductExA
#endif // !UNICODE

// Reinstall product, used to validate or correct problems

UINT WINAPI MsiReinstallProductA(
	LPCSTR      szProduct,        // product code
	DWORD         szReinstallMode); // one or more REINSTALLMODE modes
UINT WINAPI MsiReinstallProductW(
	LPCWSTR      szProduct,        // product code
	DWORD         szReinstallMode); // one or more REINSTALLMODE modes
#ifdef UNICODE
#define MsiReinstallProduct  MsiReinstallProductW
#else
#define MsiReinstallProduct  MsiReinstallProductA
#endif // !UNICODE


// Return the product code for a registered component, called once by apps

UINT WINAPI MsiGetProductCodeA(
	LPCSTR   szComponent,   // component Id registered for this product
	LPSTR    lpBuf39);      // returned string GUID, sized for 39 characters
UINT WINAPI MsiGetProductCodeW(
	LPCWSTR   szComponent,   // component Id registered for this product
	LPWSTR    lpBuf39);      // returned string GUID, sized for 39 characters
#ifdef UNICODE
#define MsiGetProductCode  MsiGetProductCodeW
#else
#define MsiGetProductCode  MsiGetProductCodeA
#endif // !UNICODE

// Return the registered user information for an installed product

USERINFOSTATE WINAPI MsiGetUserInfoA(
	LPCSTR  szProduct,        // product code, string GUID
	LPSTR   lpUserNameBuf,    // return user name           
	DWORD    *pcchUserNameBuf, // in/out buffer character count
	LPSTR   lpOrgNameBuf,     // return company name           
	DWORD    *pcchOrgNameBuf,  // in/out buffer character count
	LPSTR   lpSerialBuf,      // return product serial number
	DWORD    *pcchSerialBuf);  // in/out buffer character count
USERINFOSTATE WINAPI MsiGetUserInfoW(
	LPCWSTR  szProduct,        // product code, string GUID
	LPWSTR   lpUserNameBuf,    // return user name           
	DWORD    *pcchUserNameBuf, // in/out buffer character count
	LPWSTR   lpOrgNameBuf,     // return company name           
	DWORD    *pcchOrgNameBuf,  // in/out buffer character count
	LPWSTR   lpSerialBuf,      // return product serial number
	DWORD    *pcchSerialBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetUserInfo  MsiGetUserInfoW
#else
#define MsiGetUserInfo  MsiGetUserInfoA
#endif // !UNICODE

// Obtain and store user info and PID from installation wizard (first run)

UINT WINAPI MsiCollectUserInfoA(
	LPCSTR  szProduct);     // product code, string GUID
UINT WINAPI MsiCollectUserInfoW(
	LPCWSTR  szProduct);     // product code, string GUID
#ifdef UNICODE
#define MsiCollectUserInfo  MsiCollectUserInfoW
#else
#define MsiCollectUserInfo  MsiCollectUserInfoA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to patch existing products
// --------------------------------------------------------------------------

// Patch all possible installed products.

UINT WINAPI MsiApplyPatchA(
	LPCSTR      szPatchPackage,   // location of patch package
	LPCSTR      szInstallPackage, // location of package for install to patch <optional>
	INSTALLTYPE   eInstallType,     // type of install to patch
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiApplyPatchW(
	LPCWSTR      szPatchPackage,   // location of patch package
	LPCWSTR      szInstallPackage, // location of package for install to patch <optional>
	INSTALLTYPE   eInstallType,     // type of install to patch
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiApplyPatch  MsiApplyPatchW
#else
#define MsiApplyPatch  MsiApplyPatchA
#endif // !UNICODE

// Return patch info

UINT WINAPI MsiGetPatchInfoA(
	LPCSTR   szPatch,        // patch code
	LPCSTR   szAttribute,    // attribute name, case-sensitive
	LPSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetPatchInfoW(
	LPCWSTR   szPatch,        // patch code
	LPCWSTR   szAttribute,    // attribute name, case-sensitive
	LPWSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetPatchInfo  MsiGetPatchInfoW
#else
#define MsiGetPatchInfo  MsiGetPatchInfoA
#endif // !UNICODE

// Enumerate all patches for a product

UINT WINAPI MsiEnumPatchesA(
	LPCSTR szProduct,
	DWORD    iPatchIndex,
	LPSTR  lpPatchBuf,
	LPSTR  lpTransformsBuf,
	DWORD    *pcchTransformsBuf);
UINT WINAPI MsiEnumPatchesW(
	LPCWSTR szProduct,
	DWORD    iPatchIndex,
	LPWSTR  lpPatchBuf,
	LPWSTR  lpTransformsBuf,
	DWORD    *pcchTransformsBuf);
#ifdef UNICODE
#define MsiEnumPatches  MsiEnumPatchesW
#else
#define MsiEnumPatches  MsiEnumPatchesA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to query and configure a feature within a product.
// --------------------------------------------------------------------------

// Return the installed state for a product feature

INSTALLSTATE WINAPI MsiQueryFeatureStateA(
	LPCSTR  szProduct,
	LPCSTR  szFeature);
INSTALLSTATE WINAPI MsiQueryFeatureStateW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature);
#ifdef UNICODE
#define MsiQueryFeatureState  MsiQueryFeatureStateW
#else
#define MsiQueryFeatureState  MsiQueryFeatureStateA
#endif // !UNICODE

// Indicate intent to use a product feature, increments usage count
// Prompts for CD if not loaded, does not install feature

INSTALLSTATE WINAPI MsiUseFeatureA(
	LPCSTR  szProduct,
	LPCSTR  szFeature);
INSTALLSTATE WINAPI MsiUseFeatureW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature);
#ifdef UNICODE
#define MsiUseFeature  MsiUseFeatureW
#else
#define MsiUseFeature  MsiUseFeatureA
#endif // !UNICODE

// Indicate intent to use a product feature, increments usage count
// Prompts for CD if not loaded, does not install feature
// Allows for bypassing component detection where performance is critical

INSTALLSTATE WINAPI MsiUseFeatureExA(
	LPCSTR  szProduct,          // product code
	LPCSTR  szFeature,          // feature ID
	DWORD     dwInstallMode,      // INSTALLMODE_NODETECTION, else 0
	DWORD     dwReserved);        // reserved, must be 0
INSTALLSTATE WINAPI MsiUseFeatureExW(
	LPCWSTR  szProduct,          // product code
	LPCWSTR  szFeature,          // feature ID
	DWORD     dwInstallMode,      // INSTALLMODE_NODETECTION, else 0
	DWORD     dwReserved);        // reserved, must be 0
#ifdef UNICODE
#define MsiUseFeatureEx  MsiUseFeatureExW
#else
#define MsiUseFeatureEx  MsiUseFeatureExA
#endif // !UNICODE

// Return the usage metrics for a product feature

UINT WINAPI MsiGetFeatureUsageA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFeature,        // feature ID
	DWORD        *pdwUseCount,     // returned use count
	WORD         *pwDateUsed);     // last date used (DOS date format)
UINT WINAPI MsiGetFeatureUsageW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFeature,        // feature ID
	DWORD        *pdwUseCount,     // returned use count
	WORD         *pwDateUsed);     // last date used (DOS date format)
#ifdef UNICODE
#define MsiGetFeatureUsage  MsiGetFeatureUsageW
#else
#define MsiGetFeatureUsage  MsiGetFeatureUsageA
#endif // !UNICODE

// Force the installed state for a product feature

UINT WINAPI MsiConfigureFeatureA(
	LPCSTR  szProduct,
	LPCSTR  szFeature,
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
UINT WINAPI MsiConfigureFeatureW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature,
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
#ifdef UNICODE
#define MsiConfigureFeature  MsiConfigureFeatureW
#else
#define MsiConfigureFeature  MsiConfigureFeatureA
#endif // !UNICODE


// Reinstall feature, used to validate or correct problems

UINT WINAPI MsiReinstallFeatureA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFeature,        // feature ID, NULL for entire product
	DWORD         dwReinstallMode); // one or more REINSTALLMODE modes
UINT WINAPI MsiReinstallFeatureW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFeature,        // feature ID, NULL for entire product
	DWORD         dwReinstallMode); // one or more REINSTALLMODE modes
#ifdef UNICODE
#define MsiReinstallFeature  MsiReinstallFeatureW
#else
#define MsiReinstallFeature  MsiReinstallFeatureA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to return a path to a particular component.
// The state of the feature being used should have been checked previously.
// --------------------------------------------------------------------------

// Return full component path, performing any necessary installation
// calls MsiQueryFeatureState to detect that all components are installed
// then calls MsiConfigureFeature if any of its components are uninstalled
// then calls MsiLocateComponent to obtain the path the its key file

UINT WINAPI MsiProvideComponentA(
	LPCSTR     szProduct,    // product code in case install required
	LPCSTR     szFeature,    // feature ID in case install required
	LPCSTR     szComponent,  // component ID
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf);// in/out buffer character count
UINT WINAPI MsiProvideComponentW(
	LPCWSTR     szProduct,    // product code in case install required
	LPCWSTR     szFeature,    // feature ID in case install required
	LPCWSTR     szComponent,  // component ID
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf);// in/out buffer character count
#ifdef UNICODE
#define MsiProvideComponent  MsiProvideComponentW
#else
#define MsiProvideComponent  MsiProvideComponentA
#endif // !UNICODE

// Return full component path for a qualified component, performing any necessary installation. 
// Prompts for source if necessary and increments the usage count for the feature.

UINT WINAPI MsiProvideQualifiedComponentA(
	LPCSTR     szCategory,   // component category ID
	LPCSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
UINT WINAPI MsiProvideQualifiedComponentW(
	LPCWSTR     szCategory,   // component category ID
	LPCWSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiProvideQualifiedComponent  MsiProvideQualifiedComponentW
#else
#define MsiProvideQualifiedComponent  MsiProvideQualifiedComponentA
#endif // !UNICODE

// Return full component path for a qualified component, performing any necessary installation. 
// Prompts for source if necessary and increments the usage count for the feature.
// The szProduct parameter specifies the product to match that has published the qualified
// component. If null, this API works the same as MsiProvideQualifiedComponent. 

UINT WINAPI MsiProvideQualifiedComponentExA(
	LPCSTR     szCategory,   // component category ID
	LPCSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPCSTR     szProduct,    // the product code 
	DWORD        dwUnused1,    // not used, must be zero
	DWORD        dwUnused2,    // not used, must be zero
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
UINT WINAPI MsiProvideQualifiedComponentExW(
	LPCWSTR     szCategory,   // component category ID
	LPCWSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPCWSTR     szProduct,    // the product code 
	DWORD        dwUnused1,    // not used, must be zero
	DWORD        dwUnused2,    // not used, must be zero
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiProvideQualifiedComponentEx  MsiProvideQualifiedComponentExW
#else
#define MsiProvideQualifiedComponentEx  MsiProvideQualifiedComponentExA
#endif // !UNICODE

// Return full path to an installed component

INSTALLSTATE WINAPI MsiGetComponentPathA(
	LPCSTR   szProduct,   // product code for client product
	LPCSTR   szComponent, // component Id, string GUID
	LPSTR    lpPathBuf,   // returned path
	DWORD     *pcchBuf);    // in/out buffer character count
INSTALLSTATE WINAPI MsiGetComponentPathW(
	LPCWSTR   szProduct,   // product code for client product
	LPCWSTR   szComponent, // component Id, string GUID
	LPWSTR    lpPathBuf,   // returned path
	DWORD     *pcchBuf);    // in/out buffer character count
#ifdef UNICODE
#define MsiGetComponentPath  MsiGetComponentPathW
#else
#define MsiGetComponentPath  MsiGetComponentPathA
#endif // !UNICODE



// --------------------------------------------------------------------------
// Functions to iterate registered products, features, and components.
// As with reg keys, they accept a 0-based index into the enumeration.
// --------------------------------------------------------------------------

// Enumerate the registered products, either installed or advertised

UINT WINAPI MsiEnumProductsA(
	DWORD     iProductIndex,    // 0-based index into registered products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumProductsW(
	DWORD     iProductIndex,    // 0-based index into registered products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumProducts  MsiEnumProductsW
#else
#define MsiEnumProducts  MsiEnumProductsA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// Enumerate products with given upgrade code

UINT WINAPI MsiEnumRelatedProductsA(
	LPCSTR  lpUpgradeCode,    // upgrade code of products to enumerate
	DWORD     dwReserved,       // reserved, must be 0
	DWORD     iProductIndex,    // 0-based index into registered products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumRelatedProductsW(
	LPCWSTR  lpUpgradeCode,    // upgrade code of products to enumerate
	DWORD     dwReserved,       // reserved, must be 0
	DWORD     iProductIndex,    // 0-based index into registered products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumRelatedProducts  MsiEnumRelatedProductsW
#else
#define MsiEnumRelatedProducts  MsiEnumRelatedProductsA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

// Enumerate the advertised features for a given product.
// If parent is not required, supplying NULL will improve performance.

UINT WINAPI MsiEnumFeaturesA(
	LPCSTR  szProduct,
	DWORD     iFeatureIndex,  // 0-based index into published features
	LPSTR   lpFeatureBuf,   // feature name buffer,   size=MAX_FEATURE_CHARS+1
	LPSTR   lpParentBuf);   // parent feature buffer, size=MAX_FEATURE_CHARS+1
UINT WINAPI MsiEnumFeaturesW(
	LPCWSTR  szProduct,
	DWORD     iFeatureIndex,  // 0-based index into published features
	LPWSTR   lpFeatureBuf,   // feature name buffer,   size=MAX_FEATURE_CHARS+1
	LPWSTR   lpParentBuf);   // parent feature buffer, size=MAX_FEATURE_CHARS+1
#ifdef UNICODE
#define MsiEnumFeatures  MsiEnumFeaturesW
#else
#define MsiEnumFeatures  MsiEnumFeaturesA
#endif // !UNICODE

// Enumerate the installed components for all products

UINT WINAPI MsiEnumComponentsA(
	DWORD    iComponentIndex,  // 0-based index into installed components
	LPSTR   lpComponentBuf);  // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumComponentsW(
	DWORD    iComponentIndex,  // 0-based index into installed components
	LPWSTR   lpComponentBuf);  // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumComponents  MsiEnumComponentsW
#else
#define MsiEnumComponents  MsiEnumComponentsA
#endif // !UNICODE

// Enumerate the client products for a component

UINT WINAPI MsiEnumClientsA(
	LPCSTR  szComponent,
	DWORD     iProductIndex,    // 0-based index into client products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumClientsW(
	LPCWSTR  szComponent,
	DWORD     iProductIndex,    // 0-based index into client products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumClients  MsiEnumClientsW
#else
#define MsiEnumClients  MsiEnumClientsA
#endif // !UNICODE

// Enumerate the qualifiers for an advertised component.

UINT WINAPI MsiEnumComponentQualifiersA(
	LPCSTR   szComponent,         // generic component ID that is qualified
	DWORD     iIndex,	           // 0-based index into qualifiers
	LPSTR    lpQualifierBuf,      // qualifier buffer
	DWORD     *pcchQualifierBuf,   // in/out qualifier buffer character count
	LPSTR    lpApplicationDataBuf,    // description buffer
	DWORD     *pcchApplicationDataBuf); // in/out description buffer character count
UINT WINAPI MsiEnumComponentQualifiersW(
	LPCWSTR   szComponent,         // generic component ID that is qualified
	DWORD     iIndex,	           // 0-based index into qualifiers
	LPWSTR    lpQualifierBuf,      // qualifier buffer
	DWORD     *pcchQualifierBuf,   // in/out qualifier buffer character count
	LPWSTR    lpApplicationDataBuf,    // description buffer
	DWORD     *pcchApplicationDataBuf); // in/out description buffer character count
#ifdef UNICODE
#define MsiEnumComponentQualifiers  MsiEnumComponentQualifiersW
#else
#define MsiEnumComponentQualifiers  MsiEnumComponentQualifiersA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to obtain product or package information.
// --------------------------------------------------------------------------

// Open the installation for a product to obtain detailed information

UINT WINAPI MsiOpenProductA(
	LPCSTR   szProduct,    // product code
	MSIHANDLE  *hProduct);   // returned product handle, must be closed
UINT WINAPI MsiOpenProductW(
	LPCWSTR   szProduct,    // product code
	MSIHANDLE  *hProduct);   // returned product handle, must be closed
#ifdef UNICODE
#define MsiOpenProduct  MsiOpenProductW
#else
#define MsiOpenProduct  MsiOpenProductA
#endif // !UNICODE

// Open a product package in order to access product properties

UINT WINAPI MsiOpenPackageA(
	LPCSTR    szPackagePath,     // path to package, or database handle: #nnnn
	MSIHANDLE  *hProduct);         // returned product handle, must be closed
UINT WINAPI MsiOpenPackageW(
	LPCWSTR    szPackagePath,     // path to package, or database handle: #nnnn
	MSIHANDLE  *hProduct);         // returned product handle, must be closed
#ifdef UNICODE
#define MsiOpenPackage  MsiOpenPackageW
#else
#define MsiOpenPackage  MsiOpenPackageA
#endif // !UNICODE

// Provide the value for an installation property.

UINT WINAPI MsiGetProductPropertyA(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCSTR    szProperty,     // property name, case-sensitive
	LPSTR     lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetProductPropertyW(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCWSTR    szProperty,     // property name, case-sensitive
	LPWSTR     lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetProductProperty  MsiGetProductPropertyW
#else
#define MsiGetProductProperty  MsiGetProductPropertyA
#endif // !UNICODE


// Determine whether a file is a package
// Returns ERROR_SUCCESS if file is a package.

UINT WINAPI MsiVerifyPackageA(
	LPCSTR      szPackagePath);   // location of package
UINT WINAPI MsiVerifyPackageW(
	LPCWSTR      szPackagePath);   // location of package
#ifdef UNICODE
#define MsiVerifyPackage  MsiVerifyPackageW
#else
#define MsiVerifyPackage  MsiVerifyPackageA
#endif // !UNICODE


// Provide descriptive information for product feature: title and description.
// Returns the install level for the feature, or -1 if feature is unknown.
//   0 = feature is not available on this machine
//   1 = highest priority, feature installed if parent is installed
//  >1 = decreasing priority, feature installation based on InstallLevel property

UINT WINAPI MsiGetFeatureInfoA(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature, using INSTALLFEATUREATTRIBUTE
	LPSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf);  // in/out buffer character count
UINT WINAPI MsiGetFeatureInfoW(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCWSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature, using INSTALLFEATUREATTRIBUTE
	LPWSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPWSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetFeatureInfo  MsiGetFeatureInfoW
#else
#define MsiGetFeatureInfo  MsiGetFeatureInfoA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to access or install missing components and files.
// These should be used as a last resort.
// --------------------------------------------------------------------------

// Install a component unexpectedly missing, provided only for error recovery
// This would typically occur due to failue to establish feature availability
// The product feature having the smallest incremental cost is installed

UINT WINAPI MsiInstallMissingComponentA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState);  // local/source/default, absent invalid
UINT WINAPI MsiInstallMissingComponentW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState);  // local/source/default, absent invalid
#ifdef UNICODE
#define MsiInstallMissingComponent  MsiInstallMissingComponentW
#else
#define MsiInstallMissingComponent  MsiInstallMissingComponentA
#endif // !UNICODE

// Install a file unexpectedly missing, provided only for error recovery
// This would typically occur due to failue to establish feature availability
// The missing component is determined from the product's File table, then
// the product feature having the smallest incremental cost is installed

UINT WINAPI MsiInstallMissingFileA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFile);          // file name, without path
UINT WINAPI MsiInstallMissingFileW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFile);          // file name, without path
#ifdef UNICODE
#define MsiInstallMissingFile  MsiInstallMissingFileW
#else
#define MsiInstallMissingFile  MsiInstallMissingFileA
#endif // !UNICODE

// Return full path to an installed component without a product code
// This function attempts to determine the product using MsiGetProductCode
// but is not guaranteed to find the correct product for the caller.
// MsiGetComponentPath should always be called when possible.

INSTALLSTATE WINAPI MsiLocateComponentA(
	LPCSTR szComponent,  // component Id, string GUID
	LPSTR  lpPathBuf,    // returned path
	DWORD   *pcchBuf);    // in/out buffer character count
INSTALLSTATE WINAPI MsiLocateComponentW(
	LPCWSTR szComponent,  // component Id, string GUID
	LPWSTR  lpPathBuf,    // returned path
	DWORD   *pcchBuf);    // in/out buffer character count
#ifdef UNICODE
#define MsiLocateComponent  MsiLocateComponentW
#else
#define MsiLocateComponent  MsiLocateComponentA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// --------------------------------------------------------------------------
// Functions used to manage the list of valid sources.
// --------------------------------------------------------------------------

// Opens the list of sources for the specified user's install of the product
// and removes all network sources from the list. A NULL or empty value for
// the user name indicates the per-machine install.

UINT WINAPI MsiSourceListClearAllA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
UINT WINAPI MsiSourceListClearAllW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
#ifdef UNICODE
#define MsiSourceListClearAll  MsiSourceListClearAllW
#else
#define MsiSourceListClearAll  MsiSourceListClearAllA
#endif // !UNICODE

// Opens the list of sources for the specified user's install of the product
// and adds the provided source as a new network source. A NULL or empty 
// value for the user name indicates the per-machine install.

UINT WINAPI MsiSourceListAddSourceA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved,         // reserved - must be 0
	LPCSTR szSource);          // new source
UINT WINAPI MsiSourceListAddSourceW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved,         // reserved - must be 0
	LPCWSTR szSource);          // new source
#ifdef UNICODE
#define MsiSourceListAddSource  MsiSourceListAddSourceW
#else
#define MsiSourceListAddSource  MsiSourceListAddSourceA
#endif // !UNICODE

// Forces the installer to reevaluate the list of sources the next time that
// the specified product needs a source.

UINT WINAPI MsiSourceListForceResolutionA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
UINT WINAPI MsiSourceListForceResolutionW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
#ifdef UNICODE
#define MsiSourceListForceResolution  MsiSourceListForceResolutionW
#else
#define MsiSourceListForceResolution  MsiSourceListForceResolutionA
#endif // !UNICODE
	
#endif //(_WIN32_MSI >=  110)

// --------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------

// Give the version string and language for a specified file

UINT WINAPI MsiGetFileVersionA(
	LPCSTR    szFilePath,       // path to the file
	LPSTR     lpVersionBuf,     // returned version string
	DWORD      *pcchVersionBuf,   // in/out buffer byte count
	LPSTR     lpLangBuf,        // returned language string
	DWORD       *pcchLangBuf);    // in/out buffer byte count
UINT WINAPI MsiGetFileVersionW(
	LPCWSTR    szFilePath,       // path to the file
	LPWSTR     lpVersionBuf,     // returned version string
	DWORD      *pcchVersionBuf,   // in/out buffer byte count
	LPWSTR     lpLangBuf,        // returned language string
	DWORD       *pcchLangBuf);    // in/out buffer byte count
#ifdef UNICODE
#define MsiGetFileVersion  MsiGetFileVersionW
#else
#define MsiGetFileVersion  MsiGetFileVersionA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// examine a shortcut, and retrieve its descriptor information 
// if available.

UINT WINAPI MsiGetShortcutTargetA(
	LPCSTR    szShortcutPath,    // full file path for the shortcut
	LPSTR     szProductCode,     // returned product code   - GUID
	LPSTR     szFeatureId,       // returned Feature Id.
	LPSTR     szComponentCode);  // returned component code - GUID
UINT WINAPI MsiGetShortcutTargetW(
	LPCWSTR    szShortcutPath,    // full file path for the shortcut
	LPWSTR     szProductCode,     // returned product code   - GUID
	LPWSTR     szFeatureId,       // returned Feature Id.
	LPWSTR     szComponentCode);  // returned component code - GUID
#ifdef UNICODE
#define MsiGetShortcutTarget  MsiGetShortcutTargetW
#else
#define MsiGetShortcutTarget  MsiGetShortcutTargetA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------
// Error codes for installer access functions - until merged to winerr.h
// --------------------------------------------------------------------------

#ifndef ERROR_INSTALL_FAILURE
#define ERROR_INSTALL_USEREXIT      1602L  // User cancel installation.
#define ERROR_INSTALL_FAILURE       1603L  // Fatal error during installation.
#define ERROR_INSTALL_SUSPEND       1604L  // Installation suspended, incomplete.
#define ERROR_UNKNOWN_PRODUCT       1605L  // This action is only valid for products that are currently installed.
#define ERROR_UNKNOWN_FEATURE       1606L  // Feature ID not registered.
#define ERROR_UNKNOWN_COMPONENT     1607L  // Component ID not registered.
#define ERROR_UNKNOWN_PROPERTY      1608L  // Unknown property.
#define ERROR_INVALID_HANDLE_STATE  1609L  // Handle is in an invalid state.
#define ERROR_BAD_CONFIGURATION     1610L  // The configuration data for this product is corrupt.  Contact your support personnel.
#define ERROR_INDEX_ABSENT          1611L  // Component qualifier not present.
#define ERROR_INSTALL_SOURCE_ABSENT 1612L  // The installation source for this product is not available.  Verify that the source exists and that you can access it.
#define ERROR_PRODUCT_UNINSTALLED   1614L  // Product is uninstalled.
#define ERROR_BAD_QUERY_SYNTAX      1615L  // SQL query syntax invalid or unsupported.
#define ERROR_INVALID_FIELD         1616L  // Record field does not exist.
#endif

#ifndef ERROR_INSTALL_SERVICE_FAILURE
#define ERROR_INSTALL_SERVICE_FAILURE      1601L // The Windows Installer service could not be accessed.  Contact your support personnel to verify that the Windows Installer service is properly registered.
#define ERROR_INSTALL_PACKAGE_VERSION      1613L // This installation package cannot be installed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service.
#define ERROR_INSTALL_ALREADY_RUNNING      1618L // Another installation is already in progress.  Complete that installation before proceeding with this install.
#define ERROR_INSTALL_PACKAGE_OPEN_FAILED  1619L // This installation package could not be opened.  Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
#define ERROR_INSTALL_PACKAGE_INVALID      1620L // This installation package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer package.
#define ERROR_INSTALL_UI_FAILURE           1621L // There was an error starting the Windows Installer service user interface.  Contact your support personnel.
#define ERROR_INSTALL_LOG_FAILURE          1622L // Error opening installation log file.  Verify that the specified log file location exists and is writable.
#define ERROR_INSTALL_LANGUAGE_UNSUPPORTED 1623L // This language of this installation package is not supported by your system.
#define ERROR_INSTALL_PACKAGE_REJECTED     1625L // The system administrator has set policies to prevent this installation.

#define ERROR_FUNCTION_NOT_CALLED          1626L // Function could not be executed.
#define ERROR_FUNCTION_FAILED              1627L // Function failed during execution.
#define ERROR_INVALID_TABLE                1628L // Invalid or unknown table specified.
#define ERROR_DATATYPE_MISMATCH            1629L // Data supplied is of wrong type.
#define ERROR_UNSUPPORTED_TYPE             1630L // Data of this type is not supported.
#define ERROR_CREATE_FAILED                1631L // The Windows Installer service failed to start.  Contact your support personnel.
#endif

#ifndef ERROR_INSTALL_TEMP_UNWRITABLE      
#define ERROR_INSTALL_TEMP_UNWRITABLE      1632L // The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
#endif

#ifndef ERROR_INSTALL_PLATFORM_UNSUPPORTED
#define ERROR_INSTALL_PLATFORM_UNSUPPORTED 1633L // This installation package is not supported by this processor type. Contact your product vendor.
#endif

#ifndef ERROR_INSTALL_NOTUSED
#define ERROR_INSTALL_NOTUSED              1634L // Component not used on this machine
#endif

#ifndef ERROR_INSTALL_TRANSFORM_FAILURE
#define ERROR_INSTALL_TRANSFORM_FAILURE     1624L // Error applying transforms.  Verify that the specified transform paths are valid.
#endif

#ifndef ERROR_PATCH_PACKAGE_OPEN_FAILED
#define ERROR_PATCH_PACKAGE_OPEN_FAILED    1635L // This patch package could not be opened.  Verify that the patch package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer patch package.
#define ERROR_PATCH_PACKAGE_INVALID        1636L // This patch package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer patch package.
#define ERROR_PATCH_PACKAGE_UNSUPPORTED    1637L // This patch package cannot be processed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service.
#endif

#ifndef ERROR_PRODUCT_VERSION
#define ERROR_PRODUCT_VERSION              1638L // Another version of this product is already installed.  Installation of this version cannot continue.  To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
#endif

#ifndef ERROR_INVALID_COMMAND_LINE
#define ERROR_INVALID_COMMAND_LINE         1639L // Invalid command line argument.  Consult the Windows Installer SDK for detailed command line help.
#endif

// The following three error codes are not returned from MSI version 1.0

#ifndef ERROR_INSTALL_REMOTE_DISALLOWED
#define ERROR_INSTALL_REMOTE_DISALLOWED    1640L // Configuration of this product is not permitted from remote sessions. Contact your administrator.
#endif


#ifndef ERROR_SUCCESS_REBOOT_INITIATED
#define ERROR_SUCCESS_REBOOT_INITIATED     1641L // The requested operation completed successfully.  The system will be restarted so the changes can take effect.
#endif

#ifndef ERROR_PATCH_TARGET_NOT_FOUND
#define ERROR_PATCH_TARGET_NOT_FOUND       1642L // The upgrade patch cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade patch may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade patch.
#endif

#endif // _MSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\stdafx.cpp ===
//------------------------------------------------------------------------------
// <copyright file="stdafx.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   stdafx.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.cpp : source file that includes just the standard includes
// MsHElp.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\stdafx.cpp ===
//------------------------------------------------------------------------------
// <copyright file="stdafx.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   stdafx.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.cpp : source file that includes just the standard includes
// MsHElp.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\include\stdafx.h ===
//------------------------------------------------------------------------------
// <copyright file="stdafx.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   stdafx.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <atlbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <comdef.h>

#include "msi.h"
#include "msiquery.h"

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\mshelpdetection\include\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\setpid.cpp ===
//------------------------------------------------------------------------------
// <copyright file="setpid.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   setpid.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
#define UNICODE 1

#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"


#define MITPIDTemplate              L"MITPIDTemplate"
#define MITPIDKEY                       L"MITPIDKEY"
#define MITPIDSKU                       L"MITPIDSKU"
#define MITProductID                   L"MITProductID"
#define MITDigitalProductID        L"MITDigitalProductID"

#define PIDTemplate                     L"PIDTemplate"
#define PIDKEY                              L"PIDKEY"
#define PIDSKU                              L"PIDSKU"
#define OEMRelease                      L"OEMRelease"

#define PRODUCTID                            L"PID"
#define DIGITALPRODUCTID               L"DPID"
#define MITPRODUCTID                      L"MITPID"
#define MITDIGITALPRODUCTID         L"MITDPID"

#define PRODUCTIDSIZE                       26

#define DIGITALPRODUCTIDSIZE         256 

// PSS provided us with PidCA.dll, which has one custom action ValidateProductID.
// This action will reads values from property table (PIDTemplate, PIDKEY, PIDSKU, OEMRelease) and compute
// ProductID and DigitalProductID assigning these values to properties PID and DPID, respectively.
//
// VS might consume other Merge Modules besides ours that also might need to 
// compute their PID. 
// URT MSM sets all of its properties in run-time, so we are not guaranteed that global properties will be preserved
// until the time we call our ValidateProductID.
//
// Possible action order: SetPIDInfo -> CostInitialize -> ValidateProductID -> GetProductIDs -> CostFinalize

// SetPIDInfo will be invoked right before a call to ValidateProductID to read our PID-related values and store
// them into global properties.
extern "C" __declspec(dllexport) UINT __stdcall  SetPIDInfo(MSIHANDLE hInstaller)
{
    
    WCHAR szPIDTemplate[50];
    DWORD dwPIDTemplate = 50;
    WCHAR szPIDKEY[50];
    DWORD dwPIDKEY = 50;
    WCHAR szPIDSKU[50];
    DWORD dwPIDSKU = 50;
    
    MsiGetProperty(hInstaller, MITPIDTemplate, szPIDTemplate, &dwPIDTemplate);
    MsiGetProperty(hInstaller, MITPIDKEY, szPIDKEY, &dwPIDKEY);
    MsiGetProperty(hInstaller, MITPIDSKU, szPIDSKU, &dwPIDSKU);

    MsiSetProperty(hInstaller, PIDTemplate, szPIDTemplate);
    MsiSetProperty(hInstaller, PIDKEY, szPIDKEY);
    MsiSetProperty(hInstaller, PIDSKU, szPIDSKU);
    MsiSetProperty(hInstaller, OEMRelease, L"0");

    return ERROR_SUCCESS;
}

// GetProductIDs reads global properties that ValidateProductID set and 
// stores them in MIT specific global properties.
extern "C" __declspec(dllexport) UINT __stdcall GetProductIDs(MSIHANDLE hInstaller)
{
    WCHAR szProductID[PRODUCTIDSIZE];
    DWORD dwProductID = PRODUCTIDSIZE;
    
    WCHAR szDigitalProductID[DIGITALPRODUCTIDSIZE];
    DWORD dwDigitalProductID = DIGITALPRODUCTIDSIZE;

    MsiGetProperty(hInstaller, PRODUCTID, szProductID, &dwProductID);
    MsiGetProperty(hInstaller, DIGITALPRODUCTID, szDigitalProductID, &dwDigitalProductID);

    MsiSetProperty(hInstaller, MITPRODUCTID, szProductID);
    MsiSetProperty(hInstaller, MITDIGITALPRODUCTID, szDigitalProductID);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\pidedit.cpp ===
//------------------------------------------------------------------------------
// <copyright file="pidedit.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   pidedit.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#define UNICODE 1

#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"

// attach GUID
#define MITINSTALLDIR            L"MITINSTALLDIR.640F4230_664E_4E0C_A81B_D824BC4AA27B"
// use this instead of PID to avoid name conflict between us and other MSMs that might
// use PID
#define PRODUCTIDPROPERTY   L"MITPID"
#define PIDFILENAME                L"PID.txt"
#define PIDENTRYPREFIX           L"MITPREFIX"
#define PRODUCTLANGUAGE      L"MITLANGUAGE"

extern "C" __declspec(dllexport) UINT __stdcall AddPIDEntry(MSIHANDLE hInstaller)
{
    WCHAR szPIDFile[MAX_PATH + 1];
    WCHAR szTargetDir[MAX_PATH + 1];
    WCHAR szProductID[26];
    WCHAR szMITLanguage[5];
    WCHAR szPIDInfo[33];
    DWORD result;
    DWORD dwSize;
    DWORD dwWritten;
    DWORD dwPIDFileSize;
    OFSTRUCT ofPIDFile;
    HANDLE hPIDFile = NULL;
    

    dwSize = 26;

    if (!SUCCEEDED(MsiGetProperty(hInstaller, PRODUCTIDPROPERTY, szProductID, &dwSize)))
    {
        // too big, non standard size of ProductID
        goto Exit;
    }
    
    dwSize = 5;
    if (!SUCCEEDED(MsiGetProperty(hInstaller, PRODUCTLANGUAGE, szMITLanguage, &dwSize)))
    {
        // just return, no PID
        goto Exit;
    }

    dwSize = MAX_PATH + 1;
    if (!SUCCEEDED(MsiGetProperty(hInstaller, MITINSTALLDIR, szTargetDir, &dwSize)))
    {
        // just return, no PID
        goto Exit;
    }

    // subtract 1 for extra occurence of NULL that is acounted for by MsiGetProperty 
    // add 1 for extra '\\'
    if ((dwSize  + sizeof(PIDFILENAME)) / sizeof(WCHAR) > MAX_PATH + 1)
    {
        // just return, no PID
        goto Exit;
    }
    wcscpy(szPIDFile, szTargetDir);
    wcscat(szPIDFile, L"\\");
    wcscat(szPIDFile, PIDFILENAME);

    SetFileAttributes(szPIDFile, FILE_ATTRIBUTE_NORMAL);
    
    hPIDFile = CreateFile(szPIDFile,
                                    GENERIC_READ | GENERIC_WRITE, 
                                    FILE_SHARE_READ, 
                                    NULL, 
                                    OPEN_ALWAYS, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);

    // make sure the call has not failed and that the file already exists
    if (INVALID_HANDLE_VALUE == hPIDFile || GetLastError() != ERROR_ALREADY_EXISTS)
    {
        hPIDFile = NULL;
        goto Exit;
    }
    
    dwPIDFileSize = GetFileSize(hPIDFile, NULL);

    if (INVALID_FILE_SIZE == dwPIDFileSize)
    {
        goto Exit;
    }

    // size of strings +5 for  "\r\n" and " "
    // look bellow
    dwSize= (wcslen(szProductID) +  wcslen(szMITLanguage) + 3)*sizeof(WCHAR);

    if (INVALID_SET_FILE_POINTER == SetFilePointer(hPIDFile, 0, 0, FILE_END))
    {
        goto Exit;
    }

    wcscpy(szPIDInfo, L"\r\n");
    wcscat(szPIDInfo, szMITLanguage);
    wcscat(szPIDInfo, L" ");
    wcscat(szPIDInfo, szProductID);

    WriteFile(hPIDFile, (LPCVOID)szPIDInfo, dwSize, &dwWritten, NULL);
       
Exit:
    if (hPIDFile)
    {
        CloseHandle(hPIDFile);
        hPIDFile = NULL;
    }
    SetFileAttributes(szPIDFile, FILE_ATTRIBUTE_READONLY);
    return ERROR_SUCCESS;
}

extern "C" __declspec(dllexport) UINT __stdcall RemovePIDEntry(MSIHANDLE hInstaller)
{
    WCHAR szPIDFile[MAX_PATH + 1];
    WCHAR szTargetDir[MAX_PATH + 1];
    WCHAR szProductID[26];
    WCHAR szPrefix[60];
    WCHAR szPIDInfo[33];
    WCHAR *lpBuffer = NULL;
    WCHAR *lpOutBuffer = NULL;
    DWORD result, dwSize, dwWritten;
    DWORD dwPIDFileSize, lenPrefix;
    DWORD dwNewPIDFileSize;
    DWORD dwBufPos, dwOutBufPos;
    BOOL bCompare, bSkipThisLine;
    
    OFSTRUCT ofPIDFile;
    HANDLE hPIDFile = NULL;
    

    dwSize = 26;

    if (!SUCCEEDED(MsiGetProperty(hInstaller, PRODUCTIDPROPERTY, szProductID, &dwSize)))
    {
        // too big, non standard size of ProductID
        goto Exit;
    }
    
    dwSize = 60;
    if (!SUCCEEDED(MsiGetProperty(hInstaller, PIDENTRYPREFIX, szPrefix, &dwSize)))
    {
        // just return, no PID
        goto Exit;
    }

    dwSize = MAX_PATH + 1;
    if (!SUCCEEDED(MsiGetProperty(hInstaller, MITINSTALLDIR, szTargetDir, &dwSize)))
    {
        // just return, no PID
        goto Exit;
    }

    // subtract 1 for extra occurence of NULL that is acounted for by MsiGetProperty 
    // add 1 for extra '\\'
    if ((dwSize  + sizeof(PIDFILENAME)) / sizeof(WCHAR) > MAX_PATH + 1)
    {
        // just return, no PID
        goto Exit;
    }
    wcscpy(szPIDFile, szTargetDir);
    wcscat(szPIDFile, L"\\");
    wcscat(szPIDFile, PIDFILENAME);

    SetFileAttributes(szPIDFile, FILE_ATTRIBUTE_NORMAL);

    hPIDFile = CreateFile(szPIDFile,
                                    GENERIC_READ | GENERIC_WRITE, 
                                    FILE_SHARE_READ, 
                                    NULL, 
                                    OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, 
                                    NULL);

    // make sure the call has not failed and that the file already exists
    if (INVALID_HANDLE_VALUE == hPIDFile)
    {
        // if this was last MIT on the machine, refcount for PID.txt went 
        // down and it got erased, no need to do anything.
        hPIDFile = NULL;
        goto Exit;
    }
    
    dwPIDFileSize = GetFileSize(hPIDFile, NULL);

    if (INVALID_FILE_SIZE == dwPIDFileSize)
    {
        goto Exit;
    }

    lpBuffer = (WCHAR *)malloc(dwPIDFileSize);
    lpOutBuffer = (WCHAR *) malloc(dwPIDFileSize);

    if (NULL == lpBuffer || NULL == lpOutBuffer)
    {
        goto Exit;
    }
    
    if (!ReadFile(hPIDFile, lpBuffer, dwPIDFileSize,  &dwSize, NULL) || 
        dwSize != dwPIDFileSize)
    {
        goto Exit;
    }
    
    dwBufPos = 0;
    dwOutBufPos = 0;
    bCompare = false;
    bSkipThisLine = false;
    lenPrefix = wcslen(szPrefix);    

    while (dwBufPos * sizeof(WCHAR) < dwPIDFileSize)
    {
        // if we found "\r\n" we need to look for prefix
        if (bCompare)
        {
            DWORD cPosition;
            
            //careful that we do not run out of buffer
            for (cPosition = 0; 
                   cPosition < lenPrefix && 
                   (dwBufPos + cPosition)*sizeof(WCHAR) < dwPIDFileSize &&
                   lpBuffer[dwBufPos + cPosition]  ==  szPrefix[cPosition];  
                   cPosition++);
                   
            if (cPosition == lenPrefix)
            {
                //all is fine we found prefix
                // we can forget about preceding "\r\n"
                bSkipThisLine = true;
                //just in case line contains only prefix
                dwBufPos = dwBufPos + cPosition - 1;
            }
            else
            {
                //not the line we are looking for
                //we need to include "\r\n"
                lpOutBuffer[dwOutBufPos++] = L'\r';
                lpOutBuffer[dwOutBufPos++] = L'\n';
            }    
            //do not compare until we run into another "\r\n"
            bCompare = false;
        }


        if (lpBuffer[dwBufPos] == L'\r' && lpBuffer[dwBufPos + 1] == L'\n')
        {        
            //look for prefix, we are on new line
            bCompare = true;
            //skip '\r' for now, if this line is not prefixed with appropriate
            //string we will include '\r\n' in output buffer
            dwBufPos++;
            //to be decided in next iteration
            bSkipThisLine = false;
        } 
        else
        {
            // all other combinations of characters are copied 
            // depending on whether they are in a line with prefix that
            // needs to be removed or not.
            if (!bSkipThisLine)
            {
                lpOutBuffer[dwOutBufPos] = lpBuffer[dwBufPos];
                dwOutBufPos++;
            }
        }
        
        // move on to next character (skipping '\n')
        dwBufPos++;       
    }

    if (INVALID_SET_FILE_POINTER == SetFilePointer(hPIDFile, 0, 0, FILE_BEGIN))
    {
        goto Exit;
    }

    dwNewPIDFileSize = dwOutBufPos * sizeof(WCHAR);
    if (!WriteFile(hPIDFile, 
                        (LPCVOID)lpOutBuffer, 
                        dwNewPIDFileSize, 
                        &dwWritten, 
                        NULL))
    {
        goto Exit;
    }

    // truncate file if necessary
    if (dwNewPIDFileSize != dwPIDFileSize)
    {
        if (INVALID_SET_FILE_POINTER == 
                SetFilePointer(hPIDFile, 
                                     dwNewPIDFileSize, 
                                     0, 
                                     FILE_BEGIN))
        {
            goto Exit;
        }

        SetEndOfFile(hPIDFile);
    }
Exit:
    if (lpBuffer)
    {
        free(lpBuffer);
    }
    if (lpOutBuffer)
    {
        free(lpOutBuffer);
    }
    if (hPIDFile)
    {
        CloseHandle(hPIDFile);
        hPIDFile = NULL;
    }
    SetFileAttributes(szPIDFile, FILE_ATTRIBUTE_READONLY);
    // custom action is never wrong
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\include\stdafx.h ===
//------------------------------------------------------------------------------
// <copyright file="stdafx.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   stdafx.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <atlbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <comdef.h>

#include "msi.h"
#include "msiquery.h"

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\sxscounter.cpp ===
//------------------------------------------------------------------------------
// <copyright file="sxscounter.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   sxscounter.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#define UNICODE 1

#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"

#define SBSCOUNTER L"MITSideBySideCounter"

// We need to maintain a counter of SxS installed MIT1.0 packages installed
// so that after the first one is installed, no new packages will try to merge machine.config.
// Similarly last package removed will remove counter and unmerge machine.config

BOOL RegDBKeyExists(HKEY hKey, LPCWSTR lpValueName)
{
    LONG result;
    HKEY hk;
    result = RegOpenKeyEx(hKey, lpValueName, 0, KEY_READ, &hk);

    if (ERROR_FILE_NOT_FOUND == result)
    {
        return false;
    }
    RegCloseKey(hKey);
    return true;
}

// Opens MIT1.0 key for all access and returns the value stored in SxS counter
LONG OpenRegistrySBSCounter(HKEY *phKey, WCHAR *szSBSCounter, DWORD *pdwSize)
{
    DWORD dwType;
    LONG result;

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        L"SOFTWARE\\Microsoft\\Mobile Internet Toolkit\\1.0",
                                        0,
                                        KEY_ALL_ACCESS,
                                        phKey);

    if (ERROR_SUCCESS != result)
    {
        (*phKey) = NULL;
        goto Exit;
    }

    result = RegQueryValueEx((*phKey), 
                             L"SxSCounter",
                             NULL,
                             &dwType,
                             (LPBYTE)szSBSCounter,
                             pdwSize);

    if (ERROR_FILE_NOT_FOUND != result && (ERROR_SUCCESS != result || dwType != REG_SZ))
    {
        RegCloseKey(*phKey);
        (*phKey) = NULL;
    }
    
Exit:
    return result;

}

// This action is used to set MIT specific propert to current value of SxS Counter
// this property is used to condition calls to (Un)MergeWebConfig
// In case the registry value is bogus, MITSideBySideCounter will be set to that value
// and since this value is not equal to neither 0 nor 1, neither Unmerge nor Merge will be performed.
extern "C" __declspec(dllexport) UINT __stdcall GetRegistrySBSCounter(MSIHANDLE hInstaller)
{
    
    DWORD dwSize;
    WCHAR szSBSCounter[50];
    int result;
    HKEY hKey = NULL;

    dwSize = 50;
    result = OpenRegistrySBSCounter(&hKey, szSBSCounter, &dwSize);
        
    if (result != ERROR_SUCCESS)
    {
        MsiSetProperty(hInstaller, SBSCOUNTER, L"0");
        goto Exit;
    }

    MsiSetProperty(hInstaller, SBSCOUNTER, szSBSCounter);
Exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return ERROR_SUCCESS;
}

// Increment registry SxS counter, invocation of this action is condition on Not Installed 
// Merging of machine.config is conditioned Not Installed And MITSideBySideCounter = 0
// Note that this action does not change Windows Installer properties in run-time
extern "C" __declspec(dllexport) UINT __stdcall IncrementRegistrySBSCounter(MSIHANDLE hInstaller)
{
    
    DWORD dwSize;
    WCHAR szSBSCounter[50];
    int result;
    LONG lSBSCounter;
    HKEY hKey = NULL;

    dwSize = 50;
    result = OpenRegistrySBSCounter(&hKey, szSBSCounter, &dwSize);
    if(result != ERROR_SUCCESS)
    {    
        goto Exit;
    }

    lSBSCounter = _wtoi(szSBSCounter);
    lSBSCounter = lSBSCounter + 1;
    _itow(lSBSCounter, szSBSCounter, 10);
    
Exit:
    if (hKey)
    {
        if(result != ERROR_SUCCESS) 
        {
             result = RegSetValueEx(hKey,
                                    L"SxSCounter",
                                    NULL,
                                    REG_SZ,
                                    (LPBYTE) L"1",
                                    sizeof(L"1"));
        }
        else
        {
             result = RegSetValueEx(hKey,
                                    L"SxSCounter",
                                    NULL,
                                    REG_SZ,
                                    (LPBYTE)szSBSCounter,
                                    (wcslen(szSBSCounter) + 1)*sizeof(WCHAR));
        }
        RegCloseKey(hKey);
    }

    return ERROR_SUCCESS;
}

void RemoveMITRegistryKeys(void)
{
     HKEY hKey;
     WCHAR subKeyName[MAX_PATH];
     DWORD dwSize = MAX_PATH;
     FILETIME fileTime;
     LONG result;
        
     RegDeleteKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Mobile Internet Toolkit\\1.0");
     result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        L"SOFTWARE\\Microsoft\\Mobile Internet Toolkit",
                                        0,
                                        KEY_ALL_ACCESS,
                                        &hKey);
     if (result != ERROR_SUCCESS)
     {
        hKey = NULL;
        goto Exit;
     }
     
     dwSize = MAX_PATH;
     result = RegEnumKeyEx(hKey,
                                         0,
                                         subKeyName,
                                         &dwSize,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &fileTime);

Exit:
     // we just needed return result
     if (hKey)
     {
        RegCloseKey(hKey);
     }
     // RegOpenKeyEx could not have set result to this value
     if (result == ERROR_NO_MORE_ITEMS)
     {
              result = RegDeleteKey(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Mobile Internet Toolkit\\");
     }  

}
   

// Decrement registry SxS counter, invocation of this action is condition on REMOVE="ALL" 
// (this action scheduled well after InstallValidate so REMOVE is updated).
// Unmerging of machine.config is conditioned REMOVE="ALL" And MITSideBySideCounter = 1
// Note that this action does not change Windows Installer properties in run-time
extern "C" __declspec(dllexport) UINT __stdcall DecrementRegistrySBSCounter(MSIHANDLE hInstaller)
{
    
    DWORD dwSize;
    WCHAR szSBSCounter[50];
    LONG lSBSCounter;
    int result;
    HKEY hKey = NULL;
    
    dwSize = 50;
    result = OpenRegistrySBSCounter(&hKey, szSBSCounter, &dwSize);
    
    if(result != ERROR_SUCCESS)
    {
        goto Exit;
    }

    // in case of a bogus string this returns 0
    lSBSCounter = _wtoi(szSBSCounter);

    if (lSBSCounter > 0)
    { 
       lSBSCounter = lSBSCounter - 1;
    }
    else
    {
       lSBSCounter = 0;
    }

    _itow(lSBSCounter, szSBSCounter, 10);
    
Exit:
    if (hKey)
    {
        if (lSBSCounter > 0 || RegDBKeyExists(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Mobile Internet Toolkit\\1.0\\Registration"))
        {
             result = RegSetValueEx(hKey,
                                  L"SxSCounter",
                                  NULL,
                                  REG_SZ,
                                  (LPBYTE)szSBSCounter,
                                  (wcslen(szSBSCounter) + 1)*sizeof(WCHAR));                 
        }
        else
        {
             RemoveMITRegistryKeys();
        }            
        RegCloseKey(hKey);
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\checks.cpp ===
//------------------------------------------------------------------------------
// <copyright file="checks.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   checks.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#define UNICODE 1

#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"


#define NETFXMISSINGERRMSG    L"NetFXMissingErrMsg.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define WRONGNETFXERRMSG    L"WrongNetFXErrMsg.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define ADMINERRMSG                  L"AdminErrMsg.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define VERSION9XERRMSG           L"Version9xErrMsg.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define INSTALLATIONERRORCAPTION        L"InstallationErrorCaption.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define INSTALLATIONWARNINGCAPTION   L"InstallationWarningCaption.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define NETFXVERSION                                L"NETFxVersion"
#define NONREDISTURTVERSION                 L"MsiNetAssemblySupport"
// Each of the exported function pops up a message box and aborts installation
// Conditions:
// Not AdminUser -> AdminErrAbort 
//
// Version9X -> Version9xErrAbort
//
// (NOT MsiNetAssemblySupport) AND (NOT URTVersion = NetFXVersionDirectory) -> NetFXVersionErrAbort
//
// MsiNetAssemblySupport returns version of fusion.dll which matches the version of URT, *not* the assembly versions of assemblies in GAC
// URTVersion is property that is set in URT Redist MSM, this is only global property (Set at run-time) that we can use to detect if our MSM is 
// consumed along with URT Redist MSM. All other property names have GUIDs appended to them. Since URT Redist MSMs for different languages
// have different GUIDs, this is only way to detect if we are in the same package with any URT redist MSM.

void PopUpMessageBox(MSIHANDLE hInstaller, WCHAR *szErrMsg)
{
    WCHAR szErrorCaption[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    MsiGetProperty(hInstaller, INSTALLATIONERRORCAPTION, szErrorCaption, &dwSize);
    MessageBox(0, szErrMsg, szErrorCaption, MB_OK | MB_ICONEXCLAMATION);
}
extern "C" __declspec(dllexport) UINT __stdcall  AdminErrAbort(MSIHANDLE hInstaller)
{
    WCHAR szErrorMessage[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    MsiGetProperty(hInstaller, ADMINERRMSG, szErrorMessage, &dwSize);
    PopUpMessageBox(hInstaller, szErrorMessage);
    return ERROR_INSTALL_FAILURE;
}

extern "C" __declspec(dllexport) UINT __stdcall  Version9xErrAbort(MSIHANDLE hInstaller)
{
    WCHAR szErrorMessage[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    MsiGetProperty(hInstaller, VERSION9XERRMSG, szErrorMessage, &dwSize);
    PopUpMessageBox(hInstaller, szErrorMessage);
    return ERROR_INSTALL_FAILURE;
}

extern "C" __declspec(dllexport) UINT __stdcall  NetFXMissingErrAbort(MSIHANDLE hInstaller)
{
    WCHAR szErrorMessage[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    MsiGetProperty(hInstaller, NETFXMISSINGERRMSG, szErrorMessage, &dwSize);
    PopUpMessageBox(hInstaller, szErrorMessage);
    return ERROR_INSTALL_FAILURE;
}

int GetSubVersion(WCHAR *szVer, WCHAR *szSubVer)
{
    int i =0;
    for (i=0; szVer[i] && szVer[i] != L'.'; i++)
    {
        szSubVer[i]=szVer[i];
    }
    
    if (!szVer[i])
    {
        return 0;
    }
    
    szSubVer[i] = L'\0';
    return i;
    
}

BOOL CompatibleVersions(WCHAR *szVer1, WCHAR *szVer2)
{
    int lenVer1 = wcslen(szVer1);
    int lenVer2 = wcslen(szVer2);
    WCHAR *szSubVer1 = NULL;
    WCHAR *szSubVer2 = NULL;
    int iSubVer1, iSubVer2;
    int cSubVer;
    int cVer1Pos, cVer2Pos;
    BOOL bSame = false;
    WCHAR szBuffer1[MAX_PATH];
    WCHAR szBuffer2[MAX_PATH];
    if (!lenVer1 || !lenVer2)
    {
        goto Exit;
    }

    szSubVer1 = (WCHAR*)malloc(lenVer1*sizeof(WCHAR));
    szSubVer2 = (WCHAR*)malloc(lenVer2*sizeof(WCHAR));

    cVer1Pos = 0;
    cVer2Pos = 0;
    
    for  (cSubVer = 0; cSubVer < 3; cSubVer ++)
    {
        int lenSubVer;
        
        lenSubVer = GetSubVersion(szVer1 + cVer1Pos, szSubVer1);

        // we hit end of string or two dots next to each other
        if (!lenSubVer)
        {
            goto Exit;
        }
        cVer1Pos = cVer1Pos + lenSubVer + 1;
        
        lenSubVer = GetSubVersion(szVer2 + cVer2Pos, szSubVer2);
        
        // we hit end of string or two dots next to each other
        if (!lenSubVer)
        {
            goto Exit;
        }
        cVer2Pos = cVer2Pos + lenSubVer + 1;
        iSubVer1 = _wtoi(szSubVer1);
        iSubVer2 = _wtoi(szSubVer2);

        if (iSubVer1 != iSubVer2)
        {
            goto Exit;
        }
    }

    bSame = true;
Exit:
    if (szSubVer1)
    {
        free(szSubVer1);
    }
    if (szSubVer2)
    {
        free(szSubVer2);
    }
    return bSame;

}

extern "C" __declspec(dllexport) UINT __stdcall  WrongNETFxErrAbort(MSIHANDLE hInstaller)
{
    WCHAR szErrorMessage[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    MsiGetProperty(hInstaller, WRONGNETFXERRMSG, szErrorMessage, &dwSize);
    PopUpMessageBox(hInstaller, szErrorMessage);
    return  ERROR_INSTALL_FAILURE;
}

extern "C" __declspec(dllexport) UINT __stdcall CheckNETFxVersion(MSIHANDLE hInstaller)
{
    WCHAR szTargetURTVersion[50];
    WCHAR szLocalURTVersion[50];
    DWORD dwSize = 50;
    UINT result = ERROR_SUCCESS;
    if (!SUCCEEDED(MsiGetProperty(hInstaller, NONREDISTURTVERSION, szLocalURTVersion, &dwSize)))
    {
        result = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    dwSize = 50;
    if (!SUCCEEDED(MsiGetProperty(hInstaller, NETFXVERSION, szTargetURTVersion, &dwSize)))
    {
        result = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    if (!CompatibleVersions(szLocalURTVersion, szTargetURTVersion))
    {
        result =  WrongNETFxErrAbort(hInstaller);
    }
Exit:
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\getpaths.cpp ===
//------------------------------------------------------------------------------
// <copyright file="getpaths.cpp" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   getpaths.cpp
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

#define UNICODE 1

#include <windows.h>
#include "Include\stdafx.h"
#include <tchar.h>
#include "msi.h"
#include "msiquery.h"


#define NETFXVERSIONDIRECTORY    L"NETFxVersionDirectory"
#define URTINSTALLEDPATH              L"URTINSTALLEDPATH"
#define CORPATH                                L"CORPATH.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define MITINSTALLDIR                     L"MITINSTALLDIR.640F4230_664E_4E0C_A81B_D824BC4AA27B"
#define WINDOWSFOLDER                   L"WindowsFolder"
#define PROGRAMFILESFOLDER           L"ProgramFilesFolder"
#define URTVERSION                           L"URTVERSION"
#define MITSUBDIRECTORY                 L"Microsoft Mobile Internet Toolkit"

// AppSearch will locate through RegLocator
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NetFrameworkSDK\InstallRoot and set it to URTINSTALLEDPATH
// we use this property and our hardocoded NETFxVersionDirectory to rebuild path to URT
extern "C" __declspec(dllexport) UINT __stdcall  GetCLRInfo(MSIHANDLE hInstaller)
{
    WCHAR szURTPath[MAX_PATH + 1];
    WCHAR szVersionDirectory[MAX_PATH + 1];
    DWORD dwURTPath = MAX_PATH + 1;
    DWORD dwVersionDirectory = MAX_PATH + 1;    
    LONG result = ERROR_INSTALL_FAILURE;
   
    MsiGetProperty(hInstaller, URTINSTALLEDPATH, szURTPath, &dwURTPath);
    MsiGetProperty(hInstaller, NETFXVERSIONDIRECTORY, szVersionDirectory, &dwVersionDirectory);

    // extra terminating null cancels out first '\\'
    // +1 for last '\\'
    if ((dwURTPath + dwVersionDirectory)/sizeof(WCHAR) + 1> MAX_PATH)
    {
        goto Exit;
    }
    wcscat(szURTPath,L"\\");    
    wcscat(szURTPath, szVersionDirectory);
    wcscat(szURTPath,L"\\");    

    MsiSetProperty(hInstaller, CORPATH, szURTPath);
    
    result = ERROR_SUCCESS;
Exit:
    return result;
}

extern "C" __declspec(dllexport) UINT __stdcall  SetMITInstallDir(MSIHANDLE hInstaller)
{
    WCHAR szProgramFiles[MAX_PATH + 1];
    WCHAR szMITInstallDir[MAX_PATH + 1];
    DWORD dwSize;

    dwSize = MAX_PATH + 1;

    MsiGetProperty(hInstaller, PROGRAMFILESFOLDER, szProgramFiles, &dwSize);

    if ((dwSize + sizeof(MITSUBDIRECTORY))/sizeof(WCHAR) > MAX_PATH + 1)
    {
        // no way to recover from this
        return ERROR_INSTALL_FAILURE;
    }
    
    wcscpy(szMITInstallDir, szProgramFiles);
    wcscat(szMITInstallDir, L"\\");
    wcscat(szMITInstallDir, MITSUBDIRECTORY);

    MsiSetProperty(hInstaller, MITINSTALLDIR, szMITInstallDir);
    
    return ERROR_SUCCESS;

}

// In case URT redist MSM is consumed in the same package then we can use their global values to rebuild URT path,
// but some values we have to hardcode, since there is no universal way (across different localized redists) to get those 
// values.
extern "C" __declspec(dllexport) UINT __stdcall  GetCLRInfoFromURTRedist(MSIHANDLE hInstaller)
{
    WCHAR szWindowsFolder[MAX_PATH + 1];
    DWORD dwWindowsFolder = MAX_PATH + 1;    

    WCHAR szURTVersion[MAX_PATH + 1];
    DWORD dwURTVersion = MAX_PATH + 1;

    WCHAR szURTPath[MAX_PATH + 1];
    DWORD dwURTPath = MAX_PATH + 1;

    LONG result = ERROR_INSTALL_FAILURE;

    // MsiGetProperty counts terminating null when returning size.
    MsiGetProperty(hInstaller, NETFXVERSIONDIRECTORY, szURTVersion, &dwURTVersion);
    MsiGetProperty(hInstaller, WINDOWSFOLDER, szWindowsFolder, &dwWindowsFolder);

    // extra terminating NULLs cancel out '\\' 
    // +1 for last '\\'
    if ((dwURTPath + dwURTVersion + sizeof(L"Framework") + sizeof(L"Microsoft.NET"))/sizeof(WCHAR) + 1 > MAX_PATH)
    {
        goto Exit;
    }
    
    wcscpy(szURTPath, szWindowsFolder);
    wcscat(szURTPath,L"\\");    
    wcscat(szURTPath,L"Microsoft.NET");    
    wcscat(szURTPath,L"\\");    
    wcscat(szURTPath,L"Framework");    
    wcscat(szURTPath,L"\\");    
    wcscat(szURTPath, szURTVersion);
    wcscat(szURTPath,L"\\");    

    MsiSetProperty(hInstaller, CORPATH, szURTPath);
    
    result = ERROR_SUCCESS;
Exit:
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\scripts\winsvc.h ===
//------------------------------------------------------------------------------
// <copyright file="winsvc.h" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   winsvc.h
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
// InstallShield Script include file -- translated snippet from winsvc.h,tlhelp32.h and some winuser.h
// InstallShield Script does not know how to talk Unicode, so we are using ANSI

// Taken from stdlib.h
#define _MAX_PATH 260

//
// Service database names
//

#define SERVICES_ACTIVE_DATABASEA      "ServicesActive"
#define SERVICES_FAILED_DATABASEA      "ServicesFailed"

//
// Character to designate that a name is a group
//

#define SC_GROUP_IDENTIFIERA           '+'

#define SERVICES_ACTIVE_DATABASE       SERVICES_ACTIVE_DATABASEA
#define SERVICES_FAILED_DATABASE       SERVICES_FAILED_DATABASEA

#define SC_GROUP_IDENTIFIER                  SC_GROUP_IDENTIFIERA

//
// Value to indicate no change to an optional parameter
//
#define SERVICE_NO_CHANGE              0xffffffff

//
// Service State -- for Enum Requests (Bit Mask)
//
#define SERVICE_ACTIVE                 0x00000001
#define SERVICE_INACTIVE               0x00000002
#define SERVICE_STATE_ALL              (SERVICE_ACTIVE   | SERVICE_INACTIVE)

//
// Controls
//
#define SERVICE_CONTROL_STOP                                       0x00000001
#define SERVICE_CONTROL_PAUSE                                     0x00000002
#define SERVICE_CONTROL_CONTINUE                               0x00000003
#define SERVICE_CONTROL_INTERROGATE                         0x00000004
#define SERVICE_CONTROL_SHUTDOWN                             0x00000005
#define SERVICE_CONTROL_PARAMCHANGE                       0x00000006
#define SERVICE_CONTROL_NETBINDADD                          0x00000007
#define SERVICE_CONTROL_NETBINDREMOVE                    0x00000008
#define SERVICE_CONTROL_NETBINDENABLE                     0x00000009
#define SERVICE_CONTROL_NETBINDDISABLE                   0x0000000A
#define SERVICE_CONTROL_DEVICEEVENT                         0x0000000B
#define SERVICE_CONTROL_HARDWAREPROFILECHANGE   0x0000000C
#define SERVICE_CONTROL_POWEREVENT                          0x0000000D

//
// Service State -- for CurrentState
//
#define SERVICE_STOPPED                        0x00000001
#define SERVICE_START_PENDING            0x00000002
#define SERVICE_STOP_PENDING              0x00000003
#define SERVICE_RUNNING                        0x00000004
#define SERVICE_CONTINUE_PENDING      0x00000005
#define SERVICE_PAUSE_PENDING            0x00000006
#define SERVICE_PAUSED                          0x00000007

//
// Service Control Manager object specific access types
//
#define SC_MANAGER_CONNECT                  0x0001
#define SC_MANAGER_CREATE_SERVICE           0x0002
#define SC_MANAGER_ENUMERATE_SERVICE    0x0004
#define SC_MANAGER_LOCK                         0x0008
#define SC_MANAGER_QUERY_LOCK_STATUS    0x0010
#define SC_MANAGER_MODIFY_BOOT_CONFIG   0x0020


//
// Service object specific access type
//
#define SERVICE_QUERY_CONFIG                     0x0001
#define SERVICE_CHANGE_CONFIG                   0x0002
#define SERVICE_QUERY_STATUS                     0x0004
#define SERVICE_ENUMERATE_DEPENDENTS    0x0008
#define SERVICE_START                                   0x0010
#define SERVICE_STOP                                     0x0020
#define SERVICE_PAUSE_CONTINUE                 0x0040
#define SERVICE_INTERROGATE                        0x0080
#define SERVICE_USER_DEFINED_CONTROL     0x0100

//
// Error code imported from Winerror.h
//
#define ERROR_SERVICE_DOES_NOT_EXIST         1060

//
// Snapshot flag from tlhelp32.h
//
#define TH32CS_SNAPPROCESS  0x00000002

//
// Winuser.h constants
//
#define IDCONTINUE                                         11
#define MB_ICONEXCLAMATION                        0x00000030
#define MB_CANCELTRYCONTINUE                    0x00000006
#define MB_TOPMOST                                        0x00040000

//
//
// Service Status Structures
//

typedef SERVICE_STATUS 
begin
    NUMBER   dwServiceType;
    NUMBER   dwCurrentState;
    NUMBER   dwControlsAccepted;
    NUMBER   dwWin32ExitCode;
    NUMBER   dwServiceSpecificExitCode;
    NUMBER   dwCheckPoint;
    NUMBER   dwWaitHint;
end;

typedef SERVICE_STATUS_PROCESS 
begin
    NUMBER   dwServiceType;
    NUMBER   dwCurrentState;
    NUMBER   dwControlsAccepted;
    NUMBER   dwWin32ExitCode;
    NUMBER   dwServiceSpecificExitCode;
    NUMBER   dwCheckPoint;
    NUMBER   dwWaitHint;
    NUMBER   dwProcessId;
    NUMBER   dwServiceFlags;
end;



prototype INT ADVAPI32.CloseServiceHandle(NUMBER);
prototype NUMBER ADVAPI32.OpenSCManagerA(STRING, STRING, NUMBER);
prototype NUMBER ADVAPI32.OpenServiceA(NUMBER, STRING, NUMBER);
prototype INT ADVAPI32.QueryServiceStatus(NUMBER, POINTER);
prototype INT  ADVAPI32.StartServiceA(NUMBER, NUMBER, STRING);
prototype INT ADVAPI32. ControlService(NUMBER, NUMBER, POINTER);
prototype NUMBER KERNEL32.GetLastError();
prototype KERNEL32.SetLastError(NUMBER);


prototype NUMBER KERNEL32.CreateToolhelp32Snapshot(NUMBER, NUMBER);

typedef PROCESSENTRY32
begin
    NUMBER   dwSize;
    NUMBER   cntUsage;
    NUMBER   th32ProcessID;          // this process
    POINTER  th32DefaultHeapID;
    NUMBER   th32ModuleID;           // associated exe
    NUMBER   cntThreads;
    NUMBER   th32ParentProcessID;    // this process's parent process
    LONG       pcPriClassBase;         // Base priority of process's threads
    NUMBER   dwFlags;
    STRING    szExeFile[_MAX_PATH];    // Path
end;

// size is computed by hand (and sizeof(PROCESSENTRY32) in VC)
#define PROCESSENTRY32Size      296

prototype INT KERNEL32.Process32First(NUMBER, POINTER);
prototype INT KERNEL32.Process32Next(NUMBER, POINTER);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\include\msi.h ===
/*****************************************************************************\
*                                                                             *
* msi.h - - Interface for external access to Installer Service                *
*                                                                             *
* Version 1.0 - 1.2                                                           *
*                                                                             *
* NOTES:  All buffers sizes are TCHAR count, null included only on input      *
*         Return argument pointers may be null if not interested in value     *
*                                                                             *
* Copyright (c) 1999-2000, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _MSI_H_
#define _MSI_H_

#ifndef _WIN32_MSI
#if (_WIN32_WINNT >= 0x0500)
#define _WIN32_MSI   110
#else
#define _WIN32_MSI   100
#endif //(_WIN32_WINNT >= 0x0500)
#endif // !_WIN32_MSI

// --------------------------------------------------------------------------
// Installer generic handle definitions
// --------------------------------------------------------------------------

typedef unsigned long MSIHANDLE;     // abstract generic handle, 0 == no handle

#ifdef __cplusplus
extern "C" {
#endif

// Close a open handle of any type
// All handles obtained from API calls must be closed when no longer needed
// Normally succeeds, returning TRUE. 

UINT WINAPI MsiCloseHandle(MSIHANDLE hAny);

// Close all handles open in the process, a diagnostic call
// This should NOT be used as a cleanup mechanism -- use PMSIHANDLE class
// Can be called at termination to assure that all handles have been closed
// Returns 0 if all handles have been close, else number of open handles

UINT WINAPI MsiCloseAllHandles();

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

// C++ wrapper object to automatically free handle when going out of scope

class PMSIHANDLE
{
	MSIHANDLE m_h;
 public:
	PMSIHANDLE():m_h(0){}
	PMSIHANDLE(MSIHANDLE h):m_h(h){}
  ~PMSIHANDLE(){if (m_h!=0) MsiCloseHandle(m_h);}
	void operator =(MSIHANDLE h) {if (m_h) MsiCloseHandle(m_h); m_h=h;}
	operator MSIHANDLE() {return m_h;}
	MSIHANDLE* operator &() {if (m_h) MsiCloseHandle(m_h); m_h = 0; return &m_h;}
};
#endif  //__cplusplus

// Install message type for callback is a combination of the following:
//  A message box style:      MB_*, where MB_OK is the default
//  A message box icon type:  MB_ICON*, where no icon is the default
//  A default button:         MB_DEFBUTTON?, where MB_DEFBUTTON1 is the default
//  One of the following install message types, no default
typedef enum tagINSTALLMESSAGE
{
	INSTALLMESSAGE_FATALEXIT      = 0x00000000L, // premature termination, possibly fatal OOM
	INSTALLMESSAGE_ERROR          = 0x01000000L, // formatted error message
	INSTALLMESSAGE_WARNING        = 0x02000000L, // formatted warning message
	INSTALLMESSAGE_USER           = 0x03000000L, // user request message
	INSTALLMESSAGE_INFO           = 0x04000000L, // informative message for log
	INSTALLMESSAGE_FILESINUSE     = 0x05000000L, // list of files in use that need to be replaced
	INSTALLMESSAGE_RESOLVESOURCE  = 0x06000000L, // request to determine a valid source location
	INSTALLMESSAGE_OUTOFDISKSPACE = 0x07000000L, // insufficient disk space message
	INSTALLMESSAGE_ACTIONSTART    = 0x08000000L, // start of action: action name & description
	INSTALLMESSAGE_ACTIONDATA     = 0x09000000L, // formatted data associated with individual action item
	INSTALLMESSAGE_PROGRESS       = 0x0A000000L, // progress gauge info: units so far, total
	INSTALLMESSAGE_COMMONDATA     = 0x0B000000L, // product info for dialog: language Id, dialog caption
	INSTALLMESSAGE_INITIALIZE     = 0x0C000000L, // sent prior to UI initialization, no string data
	INSTALLMESSAGE_TERMINATE      = 0x0D000000L, // sent after UI termination, no string data
	INSTALLMESSAGE_SHOWDIALOG     = 0x0E000000L, // sent prior to display or authored dialog or wizard
} INSTALLMESSAGE;

// external error handler supplied to installation API functions
typedef int (WINAPI *INSTALLUI_HANDLERA)(LPVOID pvContext, UINT iMessageType, LPCSTR szMessage);
// external error handler supplied to installation API functions
typedef int (WINAPI *INSTALLUI_HANDLERW)(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage);
#ifdef UNICODE
#define INSTALLUI_HANDLER  INSTALLUI_HANDLERW
#else
#define INSTALLUI_HANDLER  INSTALLUI_HANDLERA
#endif // !UNICODE

typedef enum tagINSTALLUILEVEL
{
	INSTALLUILEVEL_NOCHANGE = 0,    // UI level is unchanged
	INSTALLUILEVEL_DEFAULT  = 1,    // default UI is used
	INSTALLUILEVEL_NONE     = 2,    // completely silent installation
	INSTALLUILEVEL_BASIC    = 3,    // simple progress and error handling
	INSTALLUILEVEL_REDUCED  = 4,    // authored UI, wizard dialogs suppressed
	INSTALLUILEVEL_FULL     = 5,    // authored UI with wizards, progress, errors
	INSTALLUILEVEL_ENDDIALOG    = 0x80, // display success/failure dialog at end of install
	INSTALLUILEVEL_PROGRESSONLY = 0x40, // display only progress dialog
} INSTALLUILEVEL;

typedef enum tagINSTALLSTATE
{
	INSTALLSTATE_NOTUSED      = -7,  // component disabled
	INSTALLSTATE_BADCONFIG    = -6,  // configuration data corrupt
	INSTALLSTATE_INCOMPLETE   = -5,  // installation suspended or in progress
	INSTALLSTATE_SOURCEABSENT = -4,  // run from source, source is unavailable
	INSTALLSTATE_MOREDATA     = -3,  // return buffer overflow
	INSTALLSTATE_INVALIDARG   = -2,  // invalid function argument
	INSTALLSTATE_UNKNOWN      = -1,  // unrecognized product or feature
	INSTALLSTATE_BROKEN       =  0,  // broken
	INSTALLSTATE_ADVERTISED   =  1,  // advertised feature
	INSTALLSTATE_REMOVED      =  1,  // component being removed (action state, not settable)
	INSTALLSTATE_ABSENT       =  2,  // uninstalled (or action state absent but clients remain)
	INSTALLSTATE_LOCAL        =  3,  // installed on local drive
	INSTALLSTATE_SOURCE       =  4,  // run from source, CD or net
	INSTALLSTATE_DEFAULT      =  5,  // use default, local or source
} INSTALLSTATE;

typedef enum tagUSERINFOSTATE
{
	USERINFOSTATE_MOREDATA   = -3,  // return buffer overflow
	USERINFOSTATE_INVALIDARG = -2,  // invalid function argument
	USERINFOSTATE_UNKNOWN    = -1,  // unrecognized product
	USERINFOSTATE_ABSENT     =  0,  // user info and PID not initialized
	USERINFOSTATE_PRESENT    =  1,  // user info and PID initialized
} USERINFOSTATE;

typedef enum tagINSTALLLEVEL
{
	INSTALLLEVEL_DEFAULT = 0,      // install authored default
	INSTALLLEVEL_MINIMUM = 1,      // install only required features
	INSTALLLEVEL_MAXIMUM = 0xFFFF, // install all features
} INSTALLLEVEL;                   // intermediate levels dependent on authoring

typedef enum tagREINSTALLMODE  // bit flags
{
	REINSTALLMODE_REPAIR           = 0x00000001,  // Reserved bit - currently ignored
	REINSTALLMODE_FILEMISSING      = 0x00000002,  // Reinstall only if file is missing
	REINSTALLMODE_FILEOLDERVERSION = 0x00000004,  // Reinstall if file is missing, or older version
	REINSTALLMODE_FILEEQUALVERSION = 0x00000008,  // Reinstall if file is missing, or equal or older version
	REINSTALLMODE_FILEEXACT        = 0x00000010,  // Reinstall if file is missing, or not exact version
	REINSTALLMODE_FILEVERIFY       = 0x00000020,  // checksum executables, reinstall if missing or corrupt
	REINSTALLMODE_FILEREPLACE      = 0x00000040,  // Reinstall all files, regardless of version
	REINSTALLMODE_MACHINEDATA      = 0x00000080,  // insure required machine reg entries
	REINSTALLMODE_USERDATA         = 0x00000100,  // insure required user reg entries
	REINSTALLMODE_SHORTCUT         = 0x00000200,  // validate shortcuts items
	REINSTALLMODE_PACKAGE          = 0x00000400,  // use re-cache source install package
} REINSTALLMODE;

typedef enum tagINSTALLOGMODE  // bit flags for use with MsiEnableLog and MsiSetExternalUI
{
	INSTALLLOGMODE_FATALEXIT      = (1 << (INSTALLMESSAGE_FATALEXIT      >> 24)),
	INSTALLLOGMODE_ERROR          = (1 << (INSTALLMESSAGE_ERROR          >> 24)),
	INSTALLLOGMODE_WARNING        = (1 << (INSTALLMESSAGE_WARNING        >> 24)),
	INSTALLLOGMODE_USER           = (1 << (INSTALLMESSAGE_USER           >> 24)),
	INSTALLLOGMODE_INFO           = (1 << (INSTALLMESSAGE_INFO           >> 24)),
	INSTALLLOGMODE_RESOLVESOURCE  = (1 << (INSTALLMESSAGE_RESOLVESOURCE  >> 24)),
	INSTALLLOGMODE_OUTOFDISKSPACE = (1 << (INSTALLMESSAGE_OUTOFDISKSPACE >> 24)),
	INSTALLLOGMODE_ACTIONSTART    = (1 << (INSTALLMESSAGE_ACTIONSTART    >> 24)),
	INSTALLLOGMODE_ACTIONDATA     = (1 << (INSTALLMESSAGE_ACTIONDATA     >> 24)),
	INSTALLLOGMODE_COMMONDATA     = (1 << (INSTALLMESSAGE_COMMONDATA     >> 24)),
	INSTALLLOGMODE_PROPERTYDUMP   = (1 << (INSTALLMESSAGE_PROGRESS       >> 24)), // log only
	INSTALLLOGMODE_VERBOSE        = (1 << (INSTALLMESSAGE_INITIALIZE     >> 24)), // log only
	INSTALLLOGMODE_PROGRESS       = (1 << (INSTALLMESSAGE_PROGRESS       >> 24)), // external handler only
	INSTALLLOGMODE_INITIALIZE     = (1 << (INSTALLMESSAGE_INITIALIZE     >> 24)), // external handler only
	INSTALLLOGMODE_TERMINATE      = (1 << (INSTALLMESSAGE_TERMINATE      >> 24)), // external handler only
	INSTALLLOGMODE_SHOWDIALOG     = (1 << (INSTALLMESSAGE_SHOWDIALOG     >> 24)), // external handler only
} INSTALLLOGMODE;

typedef enum tagINSTALLLOGATTRIBUTES // flag attributes for MsiEnableLog
{
	INSTALLLOGATTRIBUTES_APPEND            = (1 << 0),
	INSTALLLOGATTRIBUTES_FLUSHEACHLINE     = (1 << 1),
} INSTALLLOGATTRIBUTES;

typedef enum tagINSTALLFEATUREATTRIBUTE // bit flags
{
	INSTALLFEATUREATTRIBUTE_FAVORLOCAL             = 1 << 0,
	INSTALLFEATUREATTRIBUTE_FAVORSOURCE            = 1 << 1,
	INSTALLFEATUREATTRIBUTE_FOLLOWPARENT           = 1 << 2,
	INSTALLFEATUREATTRIBUTE_FAVORADVERTISE         = 1 << 3,
	INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE      = 1 << 4,
	INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = 1 << 5,
} INSTALLFEATUREATTRIBUTE;

typedef enum tagINSTALLMODE
{
	INSTALLMODE_NOSOURCERESOLUTION   = -3,  // skip source resolution
	INSTALLMODE_NODETECTION          = -2,  // skip detection
	INSTALLMODE_EXISTING             = -1,  // provide, if available
	INSTALLMODE_DEFAULT              =  0,  // install, if absent
} INSTALLMODE;

#define MAX_FEATURE_CHARS  38   // maximum chars in feature name (same as string GUID)


// Product info attributes: advertised information

#define INSTALLPROPERTY_TRANSFORMS            __TEXT("Transforms")
#define INSTALLPROPERTY_LANGUAGE              __TEXT("Language")
#define INSTALLPROPERTY_PRODUCTNAME           __TEXT("ProductName")
#define INSTALLPROPERTY_ASSIGNMENTTYPE        __TEXT("AssignmentType")
#define INSTALLPROPERTY_PACKAGECODE           __TEXT("PackageCode")
#define INSTALLPROPERTY_VERSION               __TEXT("Version")
#if (_WIN32_MSI >=  110)
#define INSTALLPROPERTY_PRODUCTICON           __TEXT("ProductIcon")
#endif //(_WIN32_MSI >=  110)

// Product info attributes: installed information

#define INSTALLPROPERTY_INSTALLEDPRODUCTNAME  __TEXT("InstalledProductName")
#define INSTALLPROPERTY_VERSIONSTRING         __TEXT("VersionString")
#define INSTALLPROPERTY_HELPLINK              __TEXT("HelpLink")
#define INSTALLPROPERTY_HELPTELEPHONE         __TEXT("HelpTelephone")
#define INSTALLPROPERTY_INSTALLLOCATION       __TEXT("InstallLocation")
#define INSTALLPROPERTY_INSTALLSOURCE         __TEXT("InstallSource")
#define INSTALLPROPERTY_INSTALLDATE           __TEXT("InstallDate")
#define INSTALLPROPERTY_PUBLISHER             __TEXT("Publisher")
#define INSTALLPROPERTY_LOCALPACKAGE          __TEXT("LocalPackage")
#define INSTALLPROPERTY_URLINFOABOUT          __TEXT("URLInfoAbout")
#define INSTALLPROPERTY_URLUPDATEINFO         __TEXT("URLUpdateInfo")
#define INSTALLPROPERTY_VERSIONMINOR          __TEXT("VersionMinor")
#define INSTALLPROPERTY_VERSIONMAJOR          __TEXT("VersionMajor")


typedef enum tagINSTALLTYPE
{
	INSTALLTYPE_DEFAULT            =    0,   // set to indicate default behavior
	INSTALLTYPE_NETWORK_IMAGE      =    1,   // set to indicate network install
}INSTALLTYPE;

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// Functions to set the UI handling and logging. The UI will be used for error,
// progress, and log messages for all subsequent calls to Installer Service
// API functions that require UI.
// --------------------------------------------------------------------------

// Enable internal UI

INSTALLUILEVEL WINAPI MsiSetInternalUI(
	INSTALLUILEVEL  dwUILevel,     // UI level
	HWND  *phWnd);                   // handle of owner window

// Enable external UI handling, returns any previous handler or NULL if none.
// Messages are designated with a combination of bits from INSTALLLOGMODE enum.

INSTALLUI_HANDLERA WINAPI MsiSetExternalUIA(
	INSTALLUI_HANDLERA puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	LPVOID             pvContext);   // application context
INSTALLUI_HANDLERW WINAPI MsiSetExternalUIW(
	INSTALLUI_HANDLERW puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	LPVOID             pvContext);   // application context
#ifdef UNICODE
#define MsiSetExternalUI  MsiSetExternalUIW
#else
#define MsiSetExternalUI  MsiSetExternalUIA
#endif // !UNICODE


// Enable logging to a file for all install sessions for the client process,
// with control over which log messages are passed to the specified log file.
// Messages are designated with a combination of bits from INSTALLLOGMODE enum.

UINT WINAPI MsiEnableLogA(
	DWORD     dwLogMode,           // bit flags designating operations to report
	LPCSTR  szLogFile,           // log file, or NULL to disable logging
	DWORD     dwLogAttributes);    // INSTALLLOGATTRIBUTES flags
UINT WINAPI MsiEnableLogW(
	DWORD     dwLogMode,           // bit flags designating operations to report
	LPCWSTR  szLogFile,           // log file, or NULL to disable logging
	DWORD     dwLogAttributes);    // INSTALLLOGATTRIBUTES flags
#ifdef UNICODE
#define MsiEnableLog  MsiEnableLogW
#else
#define MsiEnableLog  MsiEnableLogA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to query and configure a product as a whole.
// --------------------------------------------------------------------------

// Return the installed state for a product

INSTALLSTATE WINAPI MsiQueryProductStateA(
	LPCSTR  szProduct);
INSTALLSTATE WINAPI MsiQueryProductStateW(
	LPCWSTR  szProduct);
#ifdef UNICODE
#define MsiQueryProductState  MsiQueryProductStateW
#else
#define MsiQueryProductState  MsiQueryProductStateA
#endif // !UNICODE

// Return product info

UINT WINAPI MsiGetProductInfoA(
	LPCSTR   szProduct,      // product code
	LPCSTR   szAttribute,    // attribute name, case-sensitive
	LPSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetProductInfoW(
	LPCWSTR   szProduct,      // product code
	LPCWSTR   szAttribute,    // attribute name, case-sensitive
	LPWSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetProductInfo  MsiGetProductInfoW
#else
#define MsiGetProductInfo  MsiGetProductInfoA
#endif // !UNICODE

// Install a new product.
// Either may be NULL, but the DATABASE property must be specfied

UINT WINAPI MsiInstallProductA(
	LPCSTR      szPackagePath,    // location of package to install
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiInstallProductW(
	LPCWSTR      szPackagePath,    // location of package to install
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiInstallProduct  MsiInstallProductW
#else
#define MsiInstallProduct  MsiInstallProductA
#endif // !UNICODE

// Install/uninstall an advertised or installed product
// No action if installed and INSTALLSTATE_DEFAULT specified

UINT WINAPI MsiConfigureProductA(
	LPCSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
UINT WINAPI MsiConfigureProductW(
	LPCWSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
#ifdef UNICODE
#define MsiConfigureProduct  MsiConfigureProductW
#else
#define MsiConfigureProduct  MsiConfigureProductA
#endif // !UNICODE

// Install/uninstall an advertised or installed product
// No action if installed and INSTALLSTATE_DEFAULT specified

UINT WINAPI MsiConfigureProductExA(
	LPCSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState,    // local/source/default/absent/lock/uncache
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiConfigureProductExW(
	LPCWSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState,    // local/source/default/absent/lock/uncache
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiConfigureProductEx  MsiConfigureProductExW
#else
#define MsiConfigureProductEx  MsiConfigureProductExA
#endif // !UNICODE

// Reinstall product, used to validate or correct problems

UINT WINAPI MsiReinstallProductA(
	LPCSTR      szProduct,        // product code
	DWORD         szReinstallMode); // one or more REINSTALLMODE modes
UINT WINAPI MsiReinstallProductW(
	LPCWSTR      szProduct,        // product code
	DWORD         szReinstallMode); // one or more REINSTALLMODE modes
#ifdef UNICODE
#define MsiReinstallProduct  MsiReinstallProductW
#else
#define MsiReinstallProduct  MsiReinstallProductA
#endif // !UNICODE


// Return the product code for a registered component, called once by apps

UINT WINAPI MsiGetProductCodeA(
	LPCSTR   szComponent,   // component Id registered for this product
	LPSTR    lpBuf39);      // returned string GUID, sized for 39 characters
UINT WINAPI MsiGetProductCodeW(
	LPCWSTR   szComponent,   // component Id registered for this product
	LPWSTR    lpBuf39);      // returned string GUID, sized for 39 characters
#ifdef UNICODE
#define MsiGetProductCode  MsiGetProductCodeW
#else
#define MsiGetProductCode  MsiGetProductCodeA
#endif // !UNICODE

// Return the registered user information for an installed product

USERINFOSTATE WINAPI MsiGetUserInfoA(
	LPCSTR  szProduct,        // product code, string GUID
	LPSTR   lpUserNameBuf,    // return user name           
	DWORD    *pcchUserNameBuf, // in/out buffer character count
	LPSTR   lpOrgNameBuf,     // return company name           
	DWORD    *pcchOrgNameBuf,  // in/out buffer character count
	LPSTR   lpSerialBuf,      // return product serial number
	DWORD    *pcchSerialBuf);  // in/out buffer character count
USERINFOSTATE WINAPI MsiGetUserInfoW(
	LPCWSTR  szProduct,        // product code, string GUID
	LPWSTR   lpUserNameBuf,    // return user name           
	DWORD    *pcchUserNameBuf, // in/out buffer character count
	LPWSTR   lpOrgNameBuf,     // return company name           
	DWORD    *pcchOrgNameBuf,  // in/out buffer character count
	LPWSTR   lpSerialBuf,      // return product serial number
	DWORD    *pcchSerialBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetUserInfo  MsiGetUserInfoW
#else
#define MsiGetUserInfo  MsiGetUserInfoA
#endif // !UNICODE

// Obtain and store user info and PID from installation wizard (first run)

UINT WINAPI MsiCollectUserInfoA(
	LPCSTR  szProduct);     // product code, string GUID
UINT WINAPI MsiCollectUserInfoW(
	LPCWSTR  szProduct);     // product code, string GUID
#ifdef UNICODE
#define MsiCollectUserInfo  MsiCollectUserInfoW
#else
#define MsiCollectUserInfo  MsiCollectUserInfoA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to patch existing products
// --------------------------------------------------------------------------

// Patch all possible installed products.

UINT WINAPI MsiApplyPatchA(
	LPCSTR      szPatchPackage,   // location of patch package
	LPCSTR      szInstallPackage, // location of package for install to patch <optional>
	INSTALLTYPE   eInstallType,     // type of install to patch
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiApplyPatchW(
	LPCWSTR      szPatchPackage,   // location of patch package
	LPCWSTR      szInstallPackage, // location of package for install to patch <optional>
	INSTALLTYPE   eInstallType,     // type of install to patch
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiApplyPatch  MsiApplyPatchW
#else
#define MsiApplyPatch  MsiApplyPatchA
#endif // !UNICODE

// Return patch info

UINT WINAPI MsiGetPatchInfoA(
	LPCSTR   szPatch,        // patch code
	LPCSTR   szAttribute,    // attribute name, case-sensitive
	LPSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetPatchInfoW(
	LPCWSTR   szPatch,        // patch code
	LPCWSTR   szAttribute,    // attribute name, case-sensitive
	LPWSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetPatchInfo  MsiGetPatchInfoW
#else
#define MsiGetPatchInfo  MsiGetPatchInfoA
#endif // !UNICODE

// Enumerate all patches for a product

UINT WINAPI MsiEnumPatchesA(
	LPCSTR szProduct,
	DWORD    iPatchIndex,
	LPSTR  lpPatchBuf,
	LPSTR  lpTransformsBuf,
	DWORD    *pcchTransformsBuf);
UINT WINAPI MsiEnumPatchesW(
	LPCWSTR szProduct,
	DWORD    iPatchIndex,
	LPWSTR  lpPatchBuf,
	LPWSTR  lpTransformsBuf,
	DWORD    *pcchTransformsBuf);
#ifdef UNICODE
#define MsiEnumPatches  MsiEnumPatchesW
#else
#define MsiEnumPatches  MsiEnumPatchesA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to query and configure a feature within a product.
// --------------------------------------------------------------------------

// Return the installed state for a product feature

INSTALLSTATE WINAPI MsiQueryFeatureStateA(
	LPCSTR  szProduct,
	LPCSTR  szFeature);
INSTALLSTATE WINAPI MsiQueryFeatureStateW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature);
#ifdef UNICODE
#define MsiQueryFeatureState  MsiQueryFeatureStateW
#else
#define MsiQueryFeatureState  MsiQueryFeatureStateA
#endif // !UNICODE

// Indicate intent to use a product feature, increments usage count
// Prompts for CD if not loaded, does not install feature

INSTALLSTATE WINAPI MsiUseFeatureA(
	LPCSTR  szProduct,
	LPCSTR  szFeature);
INSTALLSTATE WINAPI MsiUseFeatureW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature);
#ifdef UNICODE
#define MsiUseFeature  MsiUseFeatureW
#else
#define MsiUseFeature  MsiUseFeatureA
#endif // !UNICODE

// Indicate intent to use a product feature, increments usage count
// Prompts for CD if not loaded, does not install feature
// Allows for bypassing component detection where performance is critical

INSTALLSTATE WINAPI MsiUseFeatureExA(
	LPCSTR  szProduct,          // product code
	LPCSTR  szFeature,          // feature ID
	DWORD     dwInstallMode,      // INSTALLMODE_NODETECTION, else 0
	DWORD     dwReserved);        // reserved, must be 0
INSTALLSTATE WINAPI MsiUseFeatureExW(
	LPCWSTR  szProduct,          // product code
	LPCWSTR  szFeature,          // feature ID
	DWORD     dwInstallMode,      // INSTALLMODE_NODETECTION, else 0
	DWORD     dwReserved);        // reserved, must be 0
#ifdef UNICODE
#define MsiUseFeatureEx  MsiUseFeatureExW
#else
#define MsiUseFeatureEx  MsiUseFeatureExA
#endif // !UNICODE

// Return the usage metrics for a product feature

UINT WINAPI MsiGetFeatureUsageA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFeature,        // feature ID
	DWORD        *pdwUseCount,     // returned use count
	WORD         *pwDateUsed);     // last date used (DOS date format)
UINT WINAPI MsiGetFeatureUsageW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFeature,        // feature ID
	DWORD        *pdwUseCount,     // returned use count
	WORD         *pwDateUsed);     // last date used (DOS date format)
#ifdef UNICODE
#define MsiGetFeatureUsage  MsiGetFeatureUsageW
#else
#define MsiGetFeatureUsage  MsiGetFeatureUsageA
#endif // !UNICODE

// Force the installed state for a product feature

UINT WINAPI MsiConfigureFeatureA(
	LPCSTR  szProduct,
	LPCSTR  szFeature,
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
UINT WINAPI MsiConfigureFeatureW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature,
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
#ifdef UNICODE
#define MsiConfigureFeature  MsiConfigureFeatureW
#else
#define MsiConfigureFeature  MsiConfigureFeatureA
#endif // !UNICODE


// Reinstall feature, used to validate or correct problems

UINT WINAPI MsiReinstallFeatureA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFeature,        // feature ID, NULL for entire product
	DWORD         dwReinstallMode); // one or more REINSTALLMODE modes
UINT WINAPI MsiReinstallFeatureW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFeature,        // feature ID, NULL for entire product
	DWORD         dwReinstallMode); // one or more REINSTALLMODE modes
#ifdef UNICODE
#define MsiReinstallFeature  MsiReinstallFeatureW
#else
#define MsiReinstallFeature  MsiReinstallFeatureA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to return a path to a particular component.
// The state of the feature being used should have been checked previously.
// --------------------------------------------------------------------------

// Return full component path, performing any necessary installation
// calls MsiQueryFeatureState to detect that all components are installed
// then calls MsiConfigureFeature if any of its components are uninstalled
// then calls MsiLocateComponent to obtain the path the its key file

UINT WINAPI MsiProvideComponentA(
	LPCSTR     szProduct,    // product code in case install required
	LPCSTR     szFeature,    // feature ID in case install required
	LPCSTR     szComponent,  // component ID
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf);// in/out buffer character count
UINT WINAPI MsiProvideComponentW(
	LPCWSTR     szProduct,    // product code in case install required
	LPCWSTR     szFeature,    // feature ID in case install required
	LPCWSTR     szComponent,  // component ID
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf);// in/out buffer character count
#ifdef UNICODE
#define MsiProvideComponent  MsiProvideComponentW
#else
#define MsiProvideComponent  MsiProvideComponentA
#endif // !UNICODE

// Return full component path for a qualified component, performing any necessary installation. 
// Prompts for source if necessary and increments the usage count for the feature.

UINT WINAPI MsiProvideQualifiedComponentA(
	LPCSTR     szCategory,   // component category ID
	LPCSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
UINT WINAPI MsiProvideQualifiedComponentW(
	LPCWSTR     szCategory,   // component category ID
	LPCWSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiProvideQualifiedComponent  MsiProvideQualifiedComponentW
#else
#define MsiProvideQualifiedComponent  MsiProvideQualifiedComponentA
#endif // !UNICODE

// Return full component path for a qualified component, performing any necessary installation. 
// Prompts for source if necessary and increments the usage count for the feature.
// The szProduct parameter specifies the product to match that has published the qualified
// component. If null, this API works the same as MsiProvideQualifiedComponent. 

UINT WINAPI MsiProvideQualifiedComponentExA(
	LPCSTR     szCategory,   // component category ID
	LPCSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPCSTR     szProduct,    // the product code 
	DWORD        dwUnused1,    // not used, must be zero
	DWORD        dwUnused2,    // not used, must be zero
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
UINT WINAPI MsiProvideQualifiedComponentExW(
	LPCWSTR     szCategory,   // component category ID
	LPCWSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPCWSTR     szProduct,    // the product code 
	DWORD        dwUnused1,    // not used, must be zero
	DWORD        dwUnused2,    // not used, must be zero
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiProvideQualifiedComponentEx  MsiProvideQualifiedComponentExW
#else
#define MsiProvideQualifiedComponentEx  MsiProvideQualifiedComponentExA
#endif // !UNICODE

// Return full path to an installed component

INSTALLSTATE WINAPI MsiGetComponentPathA(
	LPCSTR   szProduct,   // product code for client product
	LPCSTR   szComponent, // component Id, string GUID
	LPSTR    lpPathBuf,   // returned path
	DWORD     *pcchBuf);    // in/out buffer character count
INSTALLSTATE WINAPI MsiGetComponentPathW(
	LPCWSTR   szProduct,   // product code for client product
	LPCWSTR   szComponent, // component Id, string GUID
	LPWSTR    lpPathBuf,   // returned path
	DWORD     *pcchBuf);    // in/out buffer character count
#ifdef UNICODE
#define MsiGetComponentPath  MsiGetComponentPathW
#else
#define MsiGetComponentPath  MsiGetComponentPathA
#endif // !UNICODE



// --------------------------------------------------------------------------
// Functions to iterate registered products, features, and components.
// As with reg keys, they accept a 0-based index into the enumeration.
// --------------------------------------------------------------------------

// Enumerate the registered products, either installed or advertised

UINT WINAPI MsiEnumProductsA(
	DWORD     iProductIndex,    // 0-based index into registered products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumProductsW(
	DWORD     iProductIndex,    // 0-based index into registered products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumProducts  MsiEnumProductsW
#else
#define MsiEnumProducts  MsiEnumProductsA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// Enumerate products with given upgrade code

UINT WINAPI MsiEnumRelatedProductsA(
	LPCSTR  lpUpgradeCode,    // upgrade code of products to enumerate
	DWORD     dwReserved,       // reserved, must be 0
	DWORD     iProductIndex,    // 0-based index into registered products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumRelatedProductsW(
	LPCWSTR  lpUpgradeCode,    // upgrade code of products to enumerate
	DWORD     dwReserved,       // reserved, must be 0
	DWORD     iProductIndex,    // 0-based index into registered products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumRelatedProducts  MsiEnumRelatedProductsW
#else
#define MsiEnumRelatedProducts  MsiEnumRelatedProductsA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

// Enumerate the advertised features for a given product.
// If parent is not required, supplying NULL will improve performance.

UINT WINAPI MsiEnumFeaturesA(
	LPCSTR  szProduct,
	DWORD     iFeatureIndex,  // 0-based index into published features
	LPSTR   lpFeatureBuf,   // feature name buffer,   size=MAX_FEATURE_CHARS+1
	LPSTR   lpParentBuf);   // parent feature buffer, size=MAX_FEATURE_CHARS+1
UINT WINAPI MsiEnumFeaturesW(
	LPCWSTR  szProduct,
	DWORD     iFeatureIndex,  // 0-based index into published features
	LPWSTR   lpFeatureBuf,   // feature name buffer,   size=MAX_FEATURE_CHARS+1
	LPWSTR   lpParentBuf);   // parent feature buffer, size=MAX_FEATURE_CHARS+1
#ifdef UNICODE
#define MsiEnumFeatures  MsiEnumFeaturesW
#else
#define MsiEnumFeatures  MsiEnumFeaturesA
#endif // !UNICODE

// Enumerate the installed components for all products

UINT WINAPI MsiEnumComponentsA(
	DWORD    iComponentIndex,  // 0-based index into installed components
	LPSTR   lpComponentBuf);  // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumComponentsW(
	DWORD    iComponentIndex,  // 0-based index into installed components
	LPWSTR   lpComponentBuf);  // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumComponents  MsiEnumComponentsW
#else
#define MsiEnumComponents  MsiEnumComponentsA
#endif // !UNICODE

// Enumerate the client products for a component

UINT WINAPI MsiEnumClientsA(
	LPCSTR  szComponent,
	DWORD     iProductIndex,    // 0-based index into client products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumClientsW(
	LPCWSTR  szComponent,
	DWORD     iProductIndex,    // 0-based index into client products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumClients  MsiEnumClientsW
#else
#define MsiEnumClients  MsiEnumClientsA
#endif // !UNICODE

// Enumerate the qualifiers for an advertised component.

UINT WINAPI MsiEnumComponentQualifiersA(
	LPCSTR   szComponent,         // generic component ID that is qualified
	DWORD     iIndex,	           // 0-based index into qualifiers
	LPSTR    lpQualifierBuf,      // qualifier buffer
	DWORD     *pcchQualifierBuf,   // in/out qualifier buffer character count
	LPSTR    lpApplicationDataBuf,    // description buffer
	DWORD     *pcchApplicationDataBuf); // in/out description buffer character count
UINT WINAPI MsiEnumComponentQualifiersW(
	LPCWSTR   szComponent,         // generic component ID that is qualified
	DWORD     iIndex,	           // 0-based index into qualifiers
	LPWSTR    lpQualifierBuf,      // qualifier buffer
	DWORD     *pcchQualifierBuf,   // in/out qualifier buffer character count
	LPWSTR    lpApplicationDataBuf,    // description buffer
	DWORD     *pcchApplicationDataBuf); // in/out description buffer character count
#ifdef UNICODE
#define MsiEnumComponentQualifiers  MsiEnumComponentQualifiersW
#else
#define MsiEnumComponentQualifiers  MsiEnumComponentQualifiersA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to obtain product or package information.
// --------------------------------------------------------------------------

// Open the installation for a product to obtain detailed information

UINT WINAPI MsiOpenProductA(
	LPCSTR   szProduct,    // product code
	MSIHANDLE  *hProduct);   // returned product handle, must be closed
UINT WINAPI MsiOpenProductW(
	LPCWSTR   szProduct,    // product code
	MSIHANDLE  *hProduct);   // returned product handle, must be closed
#ifdef UNICODE
#define MsiOpenProduct  MsiOpenProductW
#else
#define MsiOpenProduct  MsiOpenProductA
#endif // !UNICODE

// Open a product package in order to access product properties

UINT WINAPI MsiOpenPackageA(
	LPCSTR    szPackagePath,     // path to package, or database handle: #nnnn
	MSIHANDLE  *hProduct);         // returned product handle, must be closed
UINT WINAPI MsiOpenPackageW(
	LPCWSTR    szPackagePath,     // path to package, or database handle: #nnnn
	MSIHANDLE  *hProduct);         // returned product handle, must be closed
#ifdef UNICODE
#define MsiOpenPackage  MsiOpenPackageW
#else
#define MsiOpenPackage  MsiOpenPackageA
#endif // !UNICODE

// Provide the value for an installation property.

UINT WINAPI MsiGetProductPropertyA(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCSTR    szProperty,     // property name, case-sensitive
	LPSTR     lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetProductPropertyW(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCWSTR    szProperty,     // property name, case-sensitive
	LPWSTR     lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetProductProperty  MsiGetProductPropertyW
#else
#define MsiGetProductProperty  MsiGetProductPropertyA
#endif // !UNICODE


// Determine whether a file is a package
// Returns ERROR_SUCCESS if file is a package.

UINT WINAPI MsiVerifyPackageA(
	LPCSTR      szPackagePath);   // location of package
UINT WINAPI MsiVerifyPackageW(
	LPCWSTR      szPackagePath);   // location of package
#ifdef UNICODE
#define MsiVerifyPackage  MsiVerifyPackageW
#else
#define MsiVerifyPackage  MsiVerifyPackageA
#endif // !UNICODE


// Provide descriptive information for product feature: title and description.
// Returns the install level for the feature, or -1 if feature is unknown.
//   0 = feature is not available on this machine
//   1 = highest priority, feature installed if parent is installed
//  >1 = decreasing priority, feature installation based on InstallLevel property

UINT WINAPI MsiGetFeatureInfoA(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature, using INSTALLFEATUREATTRIBUTE
	LPSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf);  // in/out buffer character count
UINT WINAPI MsiGetFeatureInfoW(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCWSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature, using INSTALLFEATUREATTRIBUTE
	LPWSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPWSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetFeatureInfo  MsiGetFeatureInfoW
#else
#define MsiGetFeatureInfo  MsiGetFeatureInfoA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to access or install missing components and files.
// These should be used as a last resort.
// --------------------------------------------------------------------------

// Install a component unexpectedly missing, provided only for error recovery
// This would typically occur due to failue to establish feature availability
// The product feature having the smallest incremental cost is installed

UINT WINAPI MsiInstallMissingComponentA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState);  // local/source/default, absent invalid
UINT WINAPI MsiInstallMissingComponentW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState);  // local/source/default, absent invalid
#ifdef UNICODE
#define MsiInstallMissingComponent  MsiInstallMissingComponentW
#else
#define MsiInstallMissingComponent  MsiInstallMissingComponentA
#endif // !UNICODE

// Install a file unexpectedly missing, provided only for error recovery
// This would typically occur due to failue to establish feature availability
// The missing component is determined from the product's File table, then
// the product feature having the smallest incremental cost is installed

UINT WINAPI MsiInstallMissingFileA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFile);          // file name, without path
UINT WINAPI MsiInstallMissingFileW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFile);          // file name, without path
#ifdef UNICODE
#define MsiInstallMissingFile  MsiInstallMissingFileW
#else
#define MsiInstallMissingFile  MsiInstallMissingFileA
#endif // !UNICODE

// Return full path to an installed component without a product code
// This function attempts to determine the product using MsiGetProductCode
// but is not guaranteed to find the correct product for the caller.
// MsiGetComponentPath should always be called when possible.

INSTALLSTATE WINAPI MsiLocateComponentA(
	LPCSTR szComponent,  // component Id, string GUID
	LPSTR  lpPathBuf,    // returned path
	DWORD   *pcchBuf);    // in/out buffer character count
INSTALLSTATE WINAPI MsiLocateComponentW(
	LPCWSTR szComponent,  // component Id, string GUID
	LPWSTR  lpPathBuf,    // returned path
	DWORD   *pcchBuf);    // in/out buffer character count
#ifdef UNICODE
#define MsiLocateComponent  MsiLocateComponentW
#else
#define MsiLocateComponent  MsiLocateComponentA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// --------------------------------------------------------------------------
// Functions used to manage the list of valid sources.
// --------------------------------------------------------------------------

// Opens the list of sources for the specified user's install of the product
// and removes all network sources from the list. A NULL or empty value for
// the user name indicates the per-machine install.

UINT WINAPI MsiSourceListClearAllA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
UINT WINAPI MsiSourceListClearAllW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
#ifdef UNICODE
#define MsiSourceListClearAll  MsiSourceListClearAllW
#else
#define MsiSourceListClearAll  MsiSourceListClearAllA
#endif // !UNICODE

// Opens the list of sources for the specified user's install of the product
// and adds the provided source as a new network source. A NULL or empty 
// value for the user name indicates the per-machine install.

UINT WINAPI MsiSourceListAddSourceA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved,         // reserved - must be 0
	LPCSTR szSource);          // new source
UINT WINAPI MsiSourceListAddSourceW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved,         // reserved - must be 0
	LPCWSTR szSource);          // new source
#ifdef UNICODE
#define MsiSourceListAddSource  MsiSourceListAddSourceW
#else
#define MsiSourceListAddSource  MsiSourceListAddSourceA
#endif // !UNICODE

// Forces the installer to reevaluate the list of sources the next time that
// the specified product needs a source.

UINT WINAPI MsiSourceListForceResolutionA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
UINT WINAPI MsiSourceListForceResolutionW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
#ifdef UNICODE
#define MsiSourceListForceResolution  MsiSourceListForceResolutionW
#else
#define MsiSourceListForceResolution  MsiSourceListForceResolutionA
#endif // !UNICODE
	
#endif //(_WIN32_MSI >=  110)

// --------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------

// Give the version string and language for a specified file

UINT WINAPI MsiGetFileVersionA(
	LPCSTR    szFilePath,       // path to the file
	LPSTR     lpVersionBuf,     // returned version string
	DWORD      *pcchVersionBuf,   // in/out buffer byte count
	LPSTR     lpLangBuf,        // returned language string
	DWORD       *pcchLangBuf);    // in/out buffer byte count
UINT WINAPI MsiGetFileVersionW(
	LPCWSTR    szFilePath,       // path to the file
	LPWSTR     lpVersionBuf,     // returned version string
	DWORD      *pcchVersionBuf,   // in/out buffer byte count
	LPWSTR     lpLangBuf,        // returned language string
	DWORD       *pcchLangBuf);    // in/out buffer byte count
#ifdef UNICODE
#define MsiGetFileVersion  MsiGetFileVersionW
#else
#define MsiGetFileVersion  MsiGetFileVersionA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// examine a shortcut, and retrieve its descriptor information 
// if available.

UINT WINAPI MsiGetShortcutTargetA(
	LPCSTR    szShortcutPath,    // full file path for the shortcut
	LPSTR     szProductCode,     // returned product code   - GUID
	LPSTR     szFeatureId,       // returned Feature Id.
	LPSTR     szComponentCode);  // returned component code - GUID
UINT WINAPI MsiGetShortcutTargetW(
	LPCWSTR    szShortcutPath,    // full file path for the shortcut
	LPWSTR     szProductCode,     // returned product code   - GUID
	LPWSTR     szFeatureId,       // returned Feature Id.
	LPWSTR     szComponentCode);  // returned component code - GUID
#ifdef UNICODE
#define MsiGetShortcutTarget  MsiGetShortcutTargetW
#else
#define MsiGetShortcutTarget  MsiGetShortcutTargetA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------
// Error codes for installer access functions - until merged to winerr.h
// --------------------------------------------------------------------------

#ifndef ERROR_INSTALL_FAILURE
#define ERROR_INSTALL_USEREXIT      1602L  // User cancel installation.
#define ERROR_INSTALL_FAILURE       1603L  // Fatal error during installation.
#define ERROR_INSTALL_SUSPEND       1604L  // Installation suspended, incomplete.
#define ERROR_UNKNOWN_PRODUCT       1605L  // This action is only valid for products that are currently installed.
#define ERROR_UNKNOWN_FEATURE       1606L  // Feature ID not registered.
#define ERROR_UNKNOWN_COMPONENT     1607L  // Component ID not registered.
#define ERROR_UNKNOWN_PROPERTY      1608L  // Unknown property.
#define ERROR_INVALID_HANDLE_STATE  1609L  // Handle is in an invalid state.
#define ERROR_BAD_CONFIGURATION     1610L  // The configuration data for this product is corrupt.  Contact your support personnel.
#define ERROR_INDEX_ABSENT          1611L  // Component qualifier not present.
#define ERROR_INSTALL_SOURCE_ABSENT 1612L  // The installation source for this product is not available.  Verify that the source exists and that you can access it.
#define ERROR_PRODUCT_UNINSTALLED   1614L  // Product is uninstalled.
#define ERROR_BAD_QUERY_SYNTAX      1615L  // SQL query syntax invalid or unsupported.
#define ERROR_INVALID_FIELD         1616L  // Record field does not exist.
#endif

#ifndef ERROR_INSTALL_SERVICE_FAILURE
#define ERROR_INSTALL_SERVICE_FAILURE      1601L // The Windows Installer service could not be accessed.  Contact your support personnel to verify that the Windows Installer service is properly registered.
#define ERROR_INSTALL_PACKAGE_VERSION      1613L // This installation package cannot be installed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service.
#define ERROR_INSTALL_ALREADY_RUNNING      1618L // Another installation is already in progress.  Complete that installation before proceeding with this install.
#define ERROR_INSTALL_PACKAGE_OPEN_FAILED  1619L // This installation package could not be opened.  Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
#define ERROR_INSTALL_PACKAGE_INVALID      1620L // This installation package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer package.
#define ERROR_INSTALL_UI_FAILURE           1621L // There was an error starting the Windows Installer service user interface.  Contact your support personnel.
#define ERROR_INSTALL_LOG_FAILURE          1622L // Error opening installation log file.  Verify that the specified log file location exists and is writable.
#define ERROR_INSTALL_LANGUAGE_UNSUPPORTED 1623L // This language of this installation package is not supported by your system.
#define ERROR_INSTALL_PACKAGE_REJECTED     1625L // The system administrator has set policies to prevent this installation.

#define ERROR_FUNCTION_NOT_CALLED          1626L // Function could not be executed.
#define ERROR_FUNCTION_FAILED              1627L // Function failed during execution.
#define ERROR_INVALID_TABLE                1628L // Invalid or unknown table specified.
#define ERROR_DATATYPE_MISMATCH            1629L // Data supplied is of wrong type.
#define ERROR_UNSUPPORTED_TYPE             1630L // Data of this type is not supported.
#define ERROR_CREATE_FAILED                1631L // The Windows Installer service failed to start.  Contact your support personnel.
#endif

#ifndef ERROR_INSTALL_TEMP_UNWRITABLE      
#define ERROR_INSTALL_TEMP_UNWRITABLE      1632L // The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
#endif

#ifndef ERROR_INSTALL_PLATFORM_UNSUPPORTED
#define ERROR_INSTALL_PLATFORM_UNSUPPORTED 1633L // This installation package is not supported by this processor type. Contact your product vendor.
#endif

#ifndef ERROR_INSTALL_NOTUSED
#define ERROR_INSTALL_NOTUSED              1634L // Component not used on this machine
#endif

#ifndef ERROR_INSTALL_TRANSFORM_FAILURE
#define ERROR_INSTALL_TRANSFORM_FAILURE     1624L // Error applying transforms.  Verify that the specified transform paths are valid.
#endif

#ifndef ERROR_PATCH_PACKAGE_OPEN_FAILED
#define ERROR_PATCH_PACKAGE_OPEN_FAILED    1635L // This patch package could not be opened.  Verify that the patch package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer patch package.
#define ERROR_PATCH_PACKAGE_INVALID        1636L // This patch package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer patch package.
#define ERROR_PATCH_PACKAGE_UNSUPPORTED    1637L // This patch package cannot be processed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service.
#endif

#ifndef ERROR_PRODUCT_VERSION
#define ERROR_PRODUCT_VERSION              1638L // Another version of this product is already installed.  Installation of this version cannot continue.  To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
#endif

#ifndef ERROR_INVALID_COMMAND_LINE
#define ERROR_INVALID_COMMAND_LINE         1639L // Invalid command line argument.  Consult the Windows Installer SDK for detailed command line help.
#endif

// The following three error codes are not returned from MSI version 1.0

#ifndef ERROR_INSTALL_REMOTE_DISALLOWED
#define ERROR_INSTALL_REMOTE_DISALLOWED    1640L // Configuration of this product is not permitted from remote sessions. Contact your administrator.
#endif


#ifndef ERROR_SUCCESS_REBOOT_INITIATED
#define ERROR_SUCCESS_REBOOT_INITIATED     1641L // The requested operation completed successfully.  The system will be restarted so the changes can take effect.
#endif

#ifndef ERROR_PATCH_TARGET_NOT_FOUND
#define ERROR_PATCH_TARGET_NOT_FOUND       1642L // The upgrade patch cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade patch may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade patch.
#endif

#endif // _MSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\redisthelpers\include\msiquery.h ===
/*****************************************************************************\
*                                                                             *
* MsiQuery.h - Interface to running installer for custom actions and tools    *
*                                                                             *
* Version 1.0 - 1.2                                                           *
*                                                                             *
* NOTES:  All buffers sizes are TCHAR count, null included only on input      *
*         Return argument pointers may be null if not interested in value     *
*         Returned handles of all types must be closed: MsiCloseHandle(h)     *
*         Functions with UINT return type return a system error code          *
*         Designated functions will set or clear the last error record,       *
*         which is then accessible with MsiGetLastErrorRecord. However,       *
*         the following argument errors do not register an error record:      *
*         ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, ERROR_MORE_DATA.     *
*                                                                             *
* Copyright (c) 1999-2000, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _MSIQUERY_H_
#define _MSIQUERY_H_
#include "msi.h"  // INSTALLSTATE

#define MSI_NULL_INTEGER 0x80000000  // integer value reserved for null

// MsiOpenDatabase persist predefine values, otherwise output database path is used
#define MSIDBOPEN_READONLY     (LPCTSTR)0  // database open read-only, no persistent changes
#define MSIDBOPEN_TRANSACT     (LPCTSTR)1  // database read/write in transaction mode
#define MSIDBOPEN_DIRECT       (LPCTSTR)2  // database direct read/write without transaction
#define MSIDBOPEN_CREATE       (LPCTSTR)3  // create new database, transact mode read/write
#define MSIDBOPEN_CREATEDIRECT (LPCTSTR)4  // create new database, direct mode read/write
#define MSIDBOPEN_PATCHFILE    32/sizeof(*MSIDBOPEN_READONLY) // add flag to indicate patch file

typedef enum tagMSIDBSTATE
{
	MSIDBSTATE_ERROR    =-1,  // invalid database handle
	MSIDBSTATE_READ     = 0,  // database open read-only, no persistent changes
	MSIDBSTATE_WRITE    = 1,  // database readable and updatable
} MSIDBSTATE;

typedef enum tagMSIMODIFY
{
	MSIMODIFY_SEEK             =-1,  // reposition to current record primary key
	MSIMODIFY_REFRESH          = 0,  // refetch current record data
	MSIMODIFY_INSERT           = 1,  // insert new record, fails if matching key exists
	MSIMODIFY_UPDATE           = 2,  // update existing non-key data of fetched record
	MSIMODIFY_ASSIGN           = 3,  // insert record, replacing any existing record
	MSIMODIFY_REPLACE          = 4,  // update record, delete old if primary key edit
	MSIMODIFY_MERGE            = 5,  // fails if record with duplicate key not identical
	MSIMODIFY_DELETE           = 6,  // remove row referenced by this record from table
	MSIMODIFY_INSERT_TEMPORARY = 7,  // insert a temporary record
	MSIMODIFY_VALIDATE         = 8,  // validate a fetched record
	MSIMODIFY_VALIDATE_NEW     = 9,  // validate a new record
	MSIMODIFY_VALIDATE_FIELD   = 10, // validate field(s) of an incomplete record
	MSIMODIFY_VALIDATE_DELETE  = 11, // validate before deleting record
} MSIMODIFY;

typedef enum tagMSICOLINFO
{
	MSICOLINFO_NAMES = 0,  // return column names
	MSICOLINFO_TYPES = 1,  // return column definitions, datatype code followed by width
} MSICOLINFO;

typedef enum tagMSICONDITION
{
	MSICONDITION_FALSE = 0,  // expression evaluates to False
	MSICONDITION_TRUE  = 1,  // expression evaluates to True
	MSICONDITION_NONE  = 2,  // no expression present
	MSICONDITION_ERROR = 3,  // syntax error in expression
} MSICONDITION;

typedef enum tagMSICOSTTREE
{
	MSICOSTTREE_SELFONLY = 0,
	MSICOSTTREE_CHILDREN = 1,
	MSICOSTTREE_PARENTS  = 2,
	MSICOSTTREE_RESERVED = 3,	// Reserved for future use
} MSICOSTTREE;

typedef enum tagMSIDBERROR
{
	MSIDBERROR_INVALIDARG        = -3, //  invalid argument
	MSIDBERROR_MOREDATA          = -2, //  buffer too small
	MSIDBERROR_FUNCTIONERROR     = -1, //  function error
	MSIDBERROR_NOERROR           = 0,  //  no error
	MSIDBERROR_DUPLICATEKEY      = 1,  //  new record duplicates primary keys of existing record in table
	MSIDBERROR_REQUIRED          = 2,  //  non-nullable column, no null values allowed
	MSIDBERROR_BADLINK           = 3,  //  corresponding record in foreign table not found
	MSIDBERROR_OVERFLOW          = 4,  //  data greater than maximum value allowed
	MSIDBERROR_UNDERFLOW         = 5,  //  data less than minimum value allowed
	MSIDBERROR_NOTINSET          = 6,  //  data not a member of the values permitted in the set
	MSIDBERROR_BADVERSION        = 7,  //  invalid version string
	MSIDBERROR_BADCASE           = 8,  //  invalid case, must be all upper-case or all lower-case
	MSIDBERROR_BADGUID           = 9,  //  invalid GUID
	MSIDBERROR_BADWILDCARD       = 10, //  invalid wildcardfilename or use of wildcards
	MSIDBERROR_BADIDENTIFIER     = 11, //  bad identifier
	MSIDBERROR_BADLANGUAGE       = 12, //  bad language Id(s)
	MSIDBERROR_BADFILENAME       = 13, //  bad filename
	MSIDBERROR_BADPATH           = 14, //  bad path
	MSIDBERROR_BADCONDITION      = 15, //  bad conditional statement
	MSIDBERROR_BADFORMATTED      = 16, //  bad format string
	MSIDBERROR_BADTEMPLATE       = 17, //  bad template string
	MSIDBERROR_BADDEFAULTDIR     = 18, //  bad string in DefaultDir column of Directory table
	MSIDBERROR_BADREGPATH        = 19, //  bad registry path string
	MSIDBERROR_BADCUSTOMSOURCE   = 20, //  bad string in CustomSource column of CustomAction table
	MSIDBERROR_BADPROPERTY       = 21, //  bad property string
	MSIDBERROR_MISSINGDATA       = 22, //  _Validation table missing reference to column
	MSIDBERROR_BADCATEGORY       = 23, //  Category column of _Validation table for column is invalid
	MSIDBERROR_BADKEYTABLE       = 24, //  table in KeyTable column of _Validation table could not be found/loaded
	MSIDBERROR_BADMAXMINVALUES   = 25, //  value in MaxValue column of _Validation table is less than value in MinValue column
	MSIDBERROR_BADCABINET        = 26, //  bad cabinet name
	MSIDBERROR_BADSHORTCUT       = 27, //  bad shortcut target
	MSIDBERROR_STRINGOVERFLOW    = 28, //  string overflow (greater than length allowed in column def)
	MSIDBERROR_BADLOCALIZEATTRIB = 29  //  invalid localization attribute (primary keys cannot be localized)

} MSIDBERROR;

typedef enum tagMSIRUNMODE
{
	MSIRUNMODE_ADMIN           =  0, // admin mode install, else product install
	MSIRUNMODE_ADVERTISE       =  1, // installing advertisements, else installing or updating product
	MSIRUNMODE_MAINTENANCE     =  2, // modifying an existing installation, else new installation
	MSIRUNMODE_ROLLBACKENABLED =  3, // rollback is enabled
	MSIRUNMODE_LOGENABLED      =  4, // log file active, enabled prior to install session
	MSIRUNMODE_OPERATIONS      =  5, // spooling execute operations, else in determination phase
	MSIRUNMODE_REBOOTATEND     =  6, // reboot needed after successful installation (settable)
	MSIRUNMODE_REBOOTNOW       =  7, // reboot needed to continue installation (settable)
	MSIRUNMODE_CABINET         =  8, // installing files from cabinets and files using Media table
	MSIRUNMODE_SOURCESHORTNAMES=  9, // source LongFileNames suppressed via PID_MSISOURCE summary property
	MSIRUNMODE_TARGETSHORTNAMES= 10, // target LongFileNames suppressed via SHORTFILENAMES property
	MSIRUNMODE_RESERVED11      = 11, // future use
	MSIRUNMODE_WINDOWS9X       = 12, // operating systems is Windows9?, else Windows NT
	MSIRUNMODE_ZAWENABLED      = 13, // operating system supports demand installation
	MSIRUNMODE_RESERVED14      = 14, // future use
	MSIRUNMODE_RESERVED15      = 15, // future use
	MSIRUNMODE_SCHEDULED       = 16, // custom action call from install script execution
	MSIRUNMODE_ROLLBACK        = 17, // custom action call from rollback execution script
	MSIRUNMODE_COMMIT          = 18, // custom action call from commit execution script
} MSIRUNMODE;

#define INSTALLMESSAGE_TYPEMASK = 0xFF000000L  // mask for type code

// Note: INSTALLMESSAGE_ERROR, INSTALLMESSAGE_WARNING, INSTALLMESSAGE_USER are to or'd
// with a message box style to indicate the buttons to display and return:
// MB_OK,MB_OKCANCEL,MB_ABORTRETRYIGNORE,MB_YESNOCANCEL,MB_YESNO,MB_RETRYCANCEL
// the default button (MB_DEFBUTTON1 is normal default):
// MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3
// and optionally an icon style:
// MB_ICONERROR, MB_ICONQUESTION, MB_ICONWARNING, MB_ICONINFORMATION

typedef enum tagMSITRANSFORM_ERROR
{
	MSITRANSFORM_ERROR_ADDEXISTINGROW   =  0x00000001,
	MSITRANSFORM_ERROR_DELMISSINGROW    =  0x00000002,
	MSITRANSFORM_ERROR_ADDEXISTINGTABLE =  0x00000004,
	MSITRANSFORM_ERROR_DELMISSINGTABLE  =  0x00000008,
	MSITRANSFORM_ERROR_UPDATEMISSINGROW =  0x00000010,
	MSITRANSFORM_ERROR_CHANGECODEPAGE   =  0x00000020,
	MSITRANSFORM_ERROR_VIEWTRANSFORM    =  0x00000100,
} MSITRANSFORM_ERROR;

typedef enum tagMSITRANSFORM_VALIDATE
{
	MSITRANSFORM_VALIDATE_LANGUAGE                   = 0x00000001,
	MSITRANSFORM_VALIDATE_PRODUCT                    = 0x00000002,
	MSITRANSFORM_VALIDATE_PLATFORM                   = 0x00000004,
	MSITRANSFORM_VALIDATE_MAJORVERSION               = 0x00000008,
	MSITRANSFORM_VALIDATE_MINORVERSION               = 0x00000010,
	MSITRANSFORM_VALIDATE_UPDATEVERSION              = 0x00000020,
	MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION         = 0x00000040,
	MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION    = 0x00000080,
	MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION        = 0x00000100,
	MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = 0x00000200,
	MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION      = 0x00000400,
	MSITRANSFORM_VALIDATE_UPGRADECODE                = 0x00000800,
} MSITRANSFORM_VALIDATE;

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// Installer database access functions
// --------------------------------------------------------------------------

// Prepare a database query, creating a view object
// Returns ERROR_SUCCESS if successful, and the view handle is returned,
// else ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_BAD_QUERY_SYNTAX, ERROR_GEN_FAILURE
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseOpenViewA(MSIHANDLE hDatabase,
	LPCSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView);            // returned view if TRUE
UINT WINAPI MsiDatabaseOpenViewW(MSIHANDLE hDatabase,
	LPCWSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView);            // returned view if TRUE
#ifdef UNICODE
#define MsiDatabaseOpenView  MsiDatabaseOpenViewW
#else
#define MsiDatabaseOpenView  MsiDatabaseOpenViewA
#endif // !UNICODE

// Returns the MSIDBERROR enum and name of the column corresponding to the error
// Similar to a GetLastError function, but for the view. NOT the same as MsiGetLastErrorRecord
// Returns errors of MsiViewModify.

MSIDBERROR WINAPI MsiViewGetErrorA(MSIHANDLE hView,
	LPSTR szColumnNameBuffer,  // buffer to hold column name 
	DWORD* pcchBuf);			 // size of buffer
MSIDBERROR WINAPI MsiViewGetErrorW(MSIHANDLE hView,
	LPWSTR szColumnNameBuffer,  // buffer to hold column name 
	DWORD* pcchBuf);			 // size of buffer
#ifdef UNICODE
#define MsiViewGetError  MsiViewGetErrorW
#else
#define MsiViewGetError  MsiViewGetErrorA
#endif // !UNICODE

// Exectute the view query, supplying parameters as required
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_GEN_FAILURE
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiViewExecute(MSIHANDLE hView,
	MSIHANDLE hRecord);             // optional parameter record, or 0 if none

// Fetch the next sequential record from the view
// Result is ERROR_SUCCESS if a row is found, and its handle is returned
// else ERROR_NO_MORE_ITEMS if no records remain, and a null handle is returned
// else result is error: ERROR_INVALID_HANDLE_STATE, ERROR_INVALID_HANDLE, ERROR_GEN_FAILURE

UINT WINAPI MsiViewFetch(MSIHANDLE hView,
	MSIHANDLE  *phRecord);          // returned data record if fetch succeeds

// Modify a database record, parameters must match types in query columns
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_GEN_FAILURE, ERROR_ACCESS_DENIED
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiViewModify(MSIHANDLE hView,
	MSIMODIFY eModifyMode,         // modify action to perform
	MSIHANDLE hRecord);            // record obtained from fetch, or new record

// Return the column names or specifications for the current view
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, or ERROR_INVALID_HANDLE_STATE

UINT WINAPI MsiViewGetColumnInfo(MSIHANDLE hView,
	MSICOLINFO eColumnInfo,        // retrieve columns names or definitions
	MSIHANDLE *phRecord);          // returned data record containing all names or definitions

// Release the result set for an executed view, to allow re-execution
// Only needs to be called if not all records have been fetched
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE

UINT WINAPI MsiViewClose(MSIHANDLE hView);

// Return a record containing the names of all primary key columns for a given table
// Returns an MSIHANDLE for a record containing the name of each column.
// The field count of the record corresponds to the number of primary key columns.
// Field [0] of the record contains the table name.
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_TABLE

UINT WINAPI MsiDatabaseGetPrimaryKeysA(MSIHANDLE hDatabase,
	LPCSTR    szTableName,       // the name of a specific table <case-sensitive>
	MSIHANDLE  *phRecord);         // returned record if ERROR_SUCCESS
UINT WINAPI MsiDatabaseGetPrimaryKeysW(MSIHANDLE hDatabase,
	LPCWSTR    szTableName,       // the name of a specific table <case-sensitive>
	MSIHANDLE  *phRecord);         // returned record if ERROR_SUCCESS
#ifdef UNICODE
#define MsiDatabaseGetPrimaryKeys  MsiDatabaseGetPrimaryKeysW
#else
#define MsiDatabaseGetPrimaryKeys  MsiDatabaseGetPrimaryKeysA
#endif // !UNICODE

// Return an enum defining the state of the table (temporary, unknown, or persistent).
// Returns MSICONDITION_ERROR, MSICONDITION_FALSE, MSICONDITION_TRUE, MSICONDITION_NONE

MSICONDITION WINAPI MsiDatabaseIsTablePersistentA(MSIHANDLE hDatabase,
	LPCSTR szTableName);         // the name of a specific table
MSICONDITION WINAPI MsiDatabaseIsTablePersistentW(MSIHANDLE hDatabase,
	LPCWSTR szTableName);         // the name of a specific table
#ifdef UNICODE
#define MsiDatabaseIsTablePersistent  MsiDatabaseIsTablePersistentW
#else
#define MsiDatabaseIsTablePersistent  MsiDatabaseIsTablePersistentA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Summary information stream management functions
// --------------------------------------------------------------------------

// Integer Property IDs:    1, 14, 15, 16, 19 
// DateTime Property IDs:   10, 11, 12, 13
// Text Property IDs:       2, 3, 4, 5, 6, 7, 8, 9, 18
// Unsupported Propery IDs: 0 (PID_DICTIONARY), 17 (PID_THUMBNAIL)

// Obtain a handle for the _SummaryInformation stream for an MSI database     
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetSummaryInformationA(MSIHANDLE hDatabase, // 0 if not open
	LPCSTR  szDatabasePath,  // path to database, 0 if database handle supplied
	UINT     uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo); // returned handle to summary information data
UINT WINAPI MsiGetSummaryInformationW(MSIHANDLE hDatabase, // 0 if not open
	LPCWSTR  szDatabasePath,  // path to database, 0 if database handle supplied
	UINT     uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo); // returned handle to summary information data
#ifdef UNICODE
#define MsiGetSummaryInformation  MsiGetSummaryInformationW
#else
#define MsiGetSummaryInformation  MsiGetSummaryInformationA
#endif // !UNICODE

// Obtain the number of existing properties in the SummaryInformation stream

UINT WINAPI MsiSummaryInfoGetPropertyCount(MSIHANDLE hSummaryInfo,
	UINT *puiPropertyCount); // pointer to location to return total property count

// Set a single summary information property
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT WINAPI MsiSummaryInfoSetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCSTR szValue);       // text value, used only if string property
UINT WINAPI MsiSummaryInfoSetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCWSTR szValue);       // text value, used only if string property
#ifdef UNICODE
#define MsiSummaryInfoSetProperty  MsiSummaryInfoSetPropertyW
#else
#define MsiSummaryInfoSetProperty  MsiSummaryInfoSetPropertyA
#endif // !UNICODE

// Get a single property from the summary information
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT WINAPI MsiSummaryInfoGetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPSTR  szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiSummaryInfoGetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPWSTR  szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiSummaryInfoGetProperty  MsiSummaryInfoGetPropertyW
#else
#define MsiSummaryInfoGetProperty  MsiSummaryInfoGetPropertyA
#endif // !UNICODE

// Write back changed information to summary information stream

UINT WINAPI MsiSummaryInfoPersist(MSIHANDLE hSummaryInfo);

// --------------------------------------------------------------------------
// Installer database management functions - not used by custom actions
// --------------------------------------------------------------------------

// Open an installer database, specifying the persistance mode, which is a pointer.
// Predefined persist values are reserved pointer values, requiring pointer arithmetic.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiOpenDatabaseA(
	LPCSTR      szDatabasePath,  // path to database, 0 to create temporary database
	LPCSTR      szPersist,       // output database path or one of predefined values
	MSIHANDLE*   phDatabase);     // location to return database handle
UINT WINAPI MsiOpenDatabaseW(
	LPCWSTR      szDatabasePath,  // path to database, 0 to create temporary database
	LPCWSTR      szPersist,       // output database path or one of predefined values
	MSIHANDLE*   phDatabase);     // location to return database handle
#ifdef UNICODE
#define MsiOpenDatabase  MsiOpenDatabaseW
#else
#define MsiOpenDatabase  MsiOpenDatabaseA
#endif // !UNICODE

// Import an MSI text archive table into an open database
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseImportA(MSIHANDLE hDatabase,
	LPCSTR   szFolderPath,     // folder containing archive files
	LPCSTR   szFileName);      // table archive file to be imported
UINT WINAPI MsiDatabaseImportW(MSIHANDLE hDatabase,
	LPCWSTR   szFolderPath,     // folder containing archive files
	LPCWSTR   szFileName);      // table archive file to be imported
#ifdef UNICODE
#define MsiDatabaseImport  MsiDatabaseImportW
#else
#define MsiDatabaseImport  MsiDatabaseImportA
#endif // !UNICODE

// Export an MSI table from an open database to a text archive file
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseExportA(MSIHANDLE hDatabase,
	LPCSTR   szTableName,      // name of table in database <case-sensitive>
	LPCSTR   szFolderPath,     // folder containing archive files
	LPCSTR   szFileName);      // name of exported table archive file
UINT WINAPI MsiDatabaseExportW(MSIHANDLE hDatabase,
	LPCWSTR   szTableName,      // name of table in database <case-sensitive>
	LPCWSTR   szFolderPath,     // folder containing archive files
	LPCWSTR   szFileName);      // name of exported table archive file
#ifdef UNICODE
#define MsiDatabaseExport  MsiDatabaseExportW
#else
#define MsiDatabaseExport  MsiDatabaseExportA
#endif // !UNICODE

// Merge two database together, allowing duplicate rows
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseMergeA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCSTR   szTableName);      // name of non-persistent table to receive errors
UINT WINAPI MsiDatabaseMergeW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCWSTR   szTableName);      // name of non-persistent table to receive errors
#ifdef UNICODE
#define MsiDatabaseMerge  MsiDatabaseMergeW
#else
#define MsiDatabaseMerge  MsiDatabaseMergeA
#endif // !UNICODE

// Generate a transform file of differences between two databases
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseGenerateTransformA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCSTR   szTransformFile,   // name of generated transform file
	int       iReserved1,         // reserved argument, not used
	int       iReserved2);        // reserved argument, not used
UINT WINAPI MsiDatabaseGenerateTransformW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCWSTR   szTransformFile,   // name of generated transform file
	int       iReserved1,         // reserved argument, not used
	int       iReserved2);        // reserved argument, not used
#ifdef UNICODE
#define MsiDatabaseGenerateTransform  MsiDatabaseGenerateTransformW
#else
#define MsiDatabaseGenerateTransform  MsiDatabaseGenerateTransformA
#endif // !UNICODE

// Apply a transform file containing database difference
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseApplyTransformA(MSIHANDLE hDatabase,
	LPCSTR   szTransformFile,    // name of transform file
	int       iErrorConditions);   // errors to suppress, bits from MSITRANSFORM_ERROR
UINT WINAPI MsiDatabaseApplyTransformW(MSIHANDLE hDatabase,
	LPCWSTR   szTransformFile,    // name of transform file
	int       iErrorConditions);   // errors to suppress, bits from MSITRANSFORM_ERROR
#ifdef UNICODE
#define MsiDatabaseApplyTransform  MsiDatabaseApplyTransformW
#else
#define MsiDatabaseApplyTransform  MsiDatabaseApplyTransformA
#endif // !UNICODE

// Create summary information of existing transform to include validation and error conditions
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiCreateTransformSummaryInfoA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCSTR   szTransformFile,    // name of generated transform file
	int       iErrorConditions,    // errors to suppress when applied, from MSITRANSFORM_ERROR
	int       iValidation);        // properties validated when applied, MSITRANSFORM_VALIDATE
UINT WINAPI MsiCreateTransformSummaryInfoW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCWSTR   szTransformFile,    // name of generated transform file
	int       iErrorConditions,    // errors to suppress when applied, from MSITRANSFORM_ERROR
	int       iValidation);        // properties validated when applied, MSITRANSFORM_VALIDATE
#ifdef UNICODE
#define MsiCreateTransformSummaryInfo  MsiCreateTransformSummaryInfoW
#else
#define MsiCreateTransformSummaryInfo  MsiCreateTransformSummaryInfoA
#endif // !UNICODE

// Write out all persistent table data, ignored if database opened read-only
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseCommit(MSIHANDLE hDatabase);

// Return the update state of a database

MSIDBSTATE WINAPI MsiGetDatabaseState(MSIHANDLE hDatabase);

// --------------------------------------------------------------------------
// Record object functions
// --------------------------------------------------------------------------

// Create a new record object with the requested number of fields
// Field 0, not included in count, is used for format strings and op codes
// All fields are initialized to null
// Returns a handle to the created record, or 0 if memory could not be allocated

MSIHANDLE WINAPI MsiCreateRecord(
	UINT cParams);                   // the number of data fields

// Report whether a record field is NULL
// Returns TRUE if the field is null or does not exist
// Returns FALSE if the field contains data, or the handle is invalid

BOOL WINAPI MsiRecordIsNull(MSIHANDLE hRecord,
	UINT iField);

// Return the length of a record field
// Returns 0 if field is NULL or non-existent
// Returns sizeof(int) if integer data
// Returns character count if string data (not counting null terminator)
// Returns bytes count if stream data

UINT WINAPI MsiRecordDataSize(MSIHANDLE hRecord,
	UINT iField);

// Set a record field to an integer value
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT WINAPI MsiRecordSetInteger(MSIHANDLE hRecord,
	UINT iField,
	int iValue);

// Copy a string into the designated field
// A null string pointer and an empty string both set the field to null
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT WINAPI MsiRecordSetStringA(MSIHANDLE hRecord,
	UINT iField,
	LPCSTR      szValue);
UINT WINAPI MsiRecordSetStringW(MSIHANDLE hRecord,
	UINT iField,
	LPCWSTR      szValue);
#ifdef UNICODE
#define MsiRecordSetString  MsiRecordSetStringW
#else
#define MsiRecordSetString  MsiRecordSetStringA
#endif // !UNICODE

// Return the integer value from a record field
// Returns the value MSI_NULL_INTEGER if the field is null
// or if the field is a string that cannot be converted to an integer

int WINAPI MsiRecordGetInteger(MSIHANDLE hRecord,
	UINT iField);

// Return the string value of a record field
// Integer fields will be converted to a string
// Null and non-existent fields will report a value of 0
// Fields containing stream data will return ERROR_INVALID_DATATYPE
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, 
//         ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD, ERROR_BAD_ARGUMENTS

UINT WINAPI MsiRecordGetStringA(MSIHANDLE hRecord,
	UINT iField,
	LPSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf);   // in/out buffer character count
UINT WINAPI MsiRecordGetStringW(MSIHANDLE hRecord,
	UINT iField,
	LPWSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf);   // in/out buffer character count
#ifdef UNICODE
#define MsiRecordGetString  MsiRecordGetStringW
#else
#define MsiRecordGetString  MsiRecordGetStringA
#endif // !UNICODE

// Returns the number of fields allocated in the record
// Does not count field 0, used for formatting and op codes

UINT WINAPI MsiRecordGetFieldCount(MSIHANDLE hRecord);

// Set a record stream field from a file
// The contents of the specified file will be read into a stream object
// The stream will be persisted if the record is inserted into the database
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiRecordSetStreamA(MSIHANDLE hRecord,
	UINT iField,
	LPCSTR      szFilePath);   // path to file containing stream data
UINT WINAPI MsiRecordSetStreamW(MSIHANDLE hRecord,
	UINT iField,
	LPCWSTR      szFilePath);   // path to file containing stream data
#ifdef UNICODE
#define MsiRecordSetStream  MsiRecordSetStreamW
#else
#define MsiRecordSetStream  MsiRecordSetStreamA
#endif // !UNICODE

// Read bytes from a record stream field into a buffer
// Must set the in/out argument to the requested byte count to read
// The number of bytes transferred is returned through the argument
// If no more bytes are available, ERROR_SUCCESS is still returned

UINT WINAPI MsiRecordReadStream(MSIHANDLE hRecord,
	UINT iField,
	char    *szDataBuf,     // buffer to receive bytes from stream
	DWORD   *pcbDataBuf);   // in/out buffer byte count

// Clears all data fields in a record to NULL

UINT WINAPI MsiRecordClearData(MSIHANDLE hRecord);

// --------------------------------------------------------------------------
// Functions to access a running installation, called from custom actions
// The install handle is the single argument passed to custom actions
// --------------------------------------------------------------------------

// Return a handle to the database currently in use by this installer instance

MSIHANDLE WINAPI MsiGetActiveDatabase(MSIHANDLE hInstall); // returns handle to database, 0 if none active

// Set the value for an installer property
// If the property is not defined, it will be created
// If the value is null or an empty string, the property will be removed
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_BAD_ARGUMENTS

UINT WINAPI MsiSetPropertyA(MSIHANDLE hInstall,
	LPCSTR   szName,       // property identifier, case-sensitive
	LPCSTR   szValue);     // property value, null to undefine property
UINT WINAPI MsiSetPropertyW(MSIHANDLE hInstall,
	LPCWSTR   szName,       // property identifier, case-sensitive
	LPCWSTR   szValue);     // property value, null to undefine property
#ifdef UNICODE
#define MsiSetProperty  MsiSetPropertyW
#else
#define MsiSetProperty  MsiSetPropertyA
#endif // !UNICODE

// Get the value for an installer property
// If the property is not defined, it is equivalent to a 0-length value, not error
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, ERROR_INVALID_HANDLE, ERROR_BAD_ARGUMENTS

UINT  WINAPI MsiGetPropertyA(MSIHANDLE hInstall,
	LPCSTR szName,           // property identifier, case-sensitive
	LPSTR  szValueBuf,       // buffer for returned property value
	DWORD   *pcchValueBuf);   // in/out buffer character count
UINT  WINAPI MsiGetPropertyW(MSIHANDLE hInstall,
	LPCWSTR szName,           // property identifier, case-sensitive
	LPWSTR  szValueBuf,       // buffer for returned property value
	DWORD   *pcchValueBuf);   // in/out buffer character count
#ifdef UNICODE
#define MsiGetProperty  MsiGetPropertyW
#else
#define MsiGetProperty  MsiGetPropertyA
#endif // !UNICODE

// Return the numeric language for the currently running install
// Returns 0 if an install not running

LANGID WINAPI MsiGetLanguage(MSIHANDLE hInstall);

// Return one of the boolean internal installer states
// Returns FALSE if the handle is not active or if the mode is not implemented

BOOL WINAPI MsiGetMode(MSIHANDLE hInstall,
	MSIRUNMODE eRunMode);   // particular mode for which the state is returned

// Set an internal install session boolean mode - Note: most modes are read-only
// Returns ERROR_SUCCESS if the mode can be set to the desired state
// Returns ERROR_ACCESS_DENIED if the mode is not settable
// Returns ERROR_INVALID_HANDLE if the handle is not an active install session

UINT WINAPI MsiSetMode(MSIHANDLE hInstall,
	MSIRUNMODE eRunMode,    // particular mode for which state is to be set
	BOOL fState);           // new state for bit flag

// Format record data using a format string containing field markers and/or properties
// Record field 0 must contain the format string
// Other fields must contain data that may be referenced by the format string.

UINT WINAPI MsiFormatRecordA(MSIHANDLE hInstall, // non-zero for property expansion
	MSIHANDLE hRecord,        // handle to record, field 0 contains format string
	LPSTR    szResultBuf,    // buffer to return formatted string
	DWORD    *pcchResultBuf); // in/out buffer character count
UINT WINAPI MsiFormatRecordW(MSIHANDLE hInstall, // non-zero for property expansion
	MSIHANDLE hRecord,        // handle to record, field 0 contains format string
	LPWSTR    szResultBuf,    // buffer to return formatted string
	DWORD    *pcchResultBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiFormatRecord  MsiFormatRecordW
#else
#define MsiFormatRecord  MsiFormatRecordA
#endif // !UNICODE

// Execute another action, either built-in, custom, or UI wizard
// Returns ERROR_FUNCTION_NOT_CALLED if action not found
// Returns ERROR_SUCCESS if action completed succesfully
// Returns ERROR_INSTALL_USEREXIT if user cancelled during action
// Returns ERROR_INSTALL_FAILURE if action failed
// Returns ERROR_INSTALL_SUSPEND if user suspended installation
// Returns ERROR_MORE_DATA if action wishes to skip remaining actions
// Returns ERROR_INVALID_HANDLE_STATE if install session not active
// Returns ERROR_INVALID_DATA if failure calling custom action
// Returns ERROR_INVALID_HANDLE or ERROR_INVALID_PARAMETER if arguments invalid

UINT WINAPI MsiDoActionA(MSIHANDLE hInstall,
	LPCSTR szAction);     // name of action to call, case-sensitive
UINT WINAPI MsiDoActionW(MSIHANDLE hInstall,
	LPCWSTR szAction);     // name of action to call, case-sensitive
#ifdef UNICODE
#define MsiDoAction  MsiDoActionW
#else
#define MsiDoAction  MsiDoActionA
#endif // !UNICODE

// Execute another action sequence, as descibed in the specified table
// Returns the same error codes as MsiDoAction

UINT WINAPI MsiSequenceA(MSIHANDLE hInstall,
	LPCSTR szTable,       // name of table containing action sequence
	INT iSequenceMode);     // for future use, must be 0 in MSI 1.0
UINT WINAPI MsiSequenceW(MSIHANDLE hInstall,
	LPCWSTR szTable,       // name of table containing action sequence
	INT iSequenceMode);     // for future use, must be 0 in MSI 1.0
#ifdef UNICODE
#define MsiSequence  MsiSequenceW
#else
#define MsiSequence  MsiSequenceA
#endif // !UNICODE

// Send an error record to the installer for processing.
// If field 0 (template) is not set, field 1 must be set to the error code,
//   corresponding the the error message in the Error database table,
//   and the message will be formatted using the template from the Error table
//   before passing it to the UI handler for display.
// Returns Win32 button codes: IDOK IDCANCEL IDABORT IDRETRY IDIGNORE IDYES IDNO
//   or 0 if no action taken, or -1 if invalid argument or handle

int WINAPI MsiProcessMessage(MSIHANDLE hInstall,
	INSTALLMESSAGE eMessageType, // type of message
	MSIHANDLE hRecord);          // record containing message format and data

// Evaluate a conditional expression containing property names and values

MSICONDITION WINAPI MsiEvaluateConditionA(MSIHANDLE hInstall,
	LPCSTR  szCondition);
MSICONDITION WINAPI MsiEvaluateConditionW(MSIHANDLE hInstall,
	LPCWSTR  szCondition);
#ifdef UNICODE
#define MsiEvaluateCondition  MsiEvaluateConditionW
#else
#define MsiEvaluateCondition  MsiEvaluateConditionA
#endif // !UNICODE

// Get the installed state and requested action state of a feature
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
UINT WINAPI MsiGetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
#ifdef UNICODE
#define MsiGetFeatureState  MsiGetFeatureStateW
#else
#define MsiGetFeatureState  MsiGetFeatureStateA
#endif // !UNICODE

// Request a feature to be set to a specified state
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	INSTALLSTATE iState);       // requested state for feature
UINT WINAPI MsiSetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	INSTALLSTATE iState);       // requested state for feature
#ifdef UNICODE
#define MsiSetFeatureState  MsiSetFeatureStateW
#else
#define MsiSetFeatureState  MsiSetFeatureStateA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// Set the attribute bits of a specified feature at runtime.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetFeatureAttributesA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	DWORD dwAttributes);        // attributes bits to set for this feature
UINT WINAPI MsiSetFeatureAttributesW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	DWORD dwAttributes);        // attributes bits to set for this feature
#ifdef UNICODE
#define MsiSetFeatureAttributes  MsiSetFeatureAttributesW
#else
#define MsiSetFeatureAttributes  MsiSetFeatureAttributesA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

// Get the installed state and requested action state of a component
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetComponentStateA(MSIHANDLE hInstall,
	LPCSTR     szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
UINT WINAPI MsiGetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR     szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
#ifdef UNICODE
#define MsiGetComponentState  MsiGetComponentStateW
#else
#define MsiGetComponentState  MsiGetComponentStateA
#endif // !UNICODE

// Request a component to be set to a specified state
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetComponentStateA(MSIHANDLE hInstall,
	LPCSTR     szComponent,   // component name within product
	INSTALLSTATE iState);       // requested state for component
UINT WINAPI MsiSetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR     szComponent,   // component name within product
	INSTALLSTATE iState);       // requested state for component
#ifdef UNICODE
#define MsiSetComponentState  MsiSetComponentStateW
#else
#define MsiSetComponentState  MsiSetComponentStateA
#endif // !UNICODE

// Return the disk cost for a feature and related features
// Can specify either current feature state or proposed state
// Can specify extent of related features to cost
// Note that adding costs for several features may produce an
// excessively large cost due to shared components and parents.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiGetFeatureCostA(MSIHANDLE hInstall,
	LPCSTR      szFeature,      // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost);      // returned cost, in units of 512 bytes
UINT  WINAPI MsiGetFeatureCostW(MSIHANDLE hInstall,
	LPCWSTR      szFeature,      // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost);      // returned cost, in units of 512 bytes
#ifdef UNICODE
#define MsiGetFeatureCost  MsiGetFeatureCostW
#else
#define MsiGetFeatureCost  MsiGetFeatureCostA
#endif // !UNICODE

// Set the install level for a full product installation (not a feature request)
// Setting the value to 0 initialized components and features to the default level
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiSetInstallLevel(MSIHANDLE hInstall,
	int iInstallLevel);

// Get the valid install states for a feature, represented by bit flags
// For each valid install state, a bit is set of value: (1 << INSTALLSTATE)
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiGetFeatureValidStatesA(MSIHANDLE hInstall,
	LPCSTR szFeature,
	DWORD  *dwInstallStates);
UINT  WINAPI MsiGetFeatureValidStatesW(MSIHANDLE hInstall,
	LPCWSTR szFeature,
	DWORD  *dwInstallStates);
#ifdef UNICODE
#define MsiGetFeatureValidStates  MsiGetFeatureValidStatesW
#else
#define MsiGetFeatureValidStates  MsiGetFeatureValidStatesA
#endif // !UNICODE

// Return the full source path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetSourcePathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
UINT WINAPI MsiGetSourcePathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetSourcePath  MsiGetSourcePathW
#else
#define MsiGetSourcePath  MsiGetSourcePathA
#endif // !UNICODE

// Return the full target path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetTargetPathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
UINT WINAPI MsiGetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetTargetPath  MsiGetTargetPathW
#else
#define MsiGetTargetPath  MsiGetTargetPathA
#endif // !UNICODE

// Set the full target path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetTargetPathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCSTR     szFolderPath);  // full path for folder, ending in directory separator
UINT WINAPI MsiSetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCWSTR     szFolderPath);  // full path for folder, ending in directory separator
#ifdef UNICODE
#define MsiSetTargetPath  MsiSetTargetPathW
#else
#define MsiSetTargetPath  MsiSetTargetPathA
#endif // !UNICODE

// Check to see if sufficent disk space is present for the current installation
// Returns ERROR_SUCCESS, ERROR_DISK_FULL, ERROR_INVALID_HANDLE_STATE, or ERROR_INVALID_HANDLE

UINT WINAPI MsiVerifyDiskSpace(MSIHANDLE hInstall);

// --------------------------------------------------------------------------
// Functions for rendering UI dialogs from the database representations.
// Purpose is for product development, not for use during installation.
// --------------------------------------------------------------------------

// Enable UI in preview mode to facilitate authoring of UI dialogs.
// The preview mode will end when the handle is closed.

UINT WINAPI MsiEnableUIPreview(MSIHANDLE hDatabase,
	MSIHANDLE* phPreview);       // returned handle for UI preview capability

// Display any UI dialog as modeless and inactive.
// Supplying a null name will remove any current dialog.

UINT WINAPI MsiPreviewDialogA(MSIHANDLE hPreview,
	LPCSTR szDialogName);      // dialog to display, Dialog table key
UINT WINAPI MsiPreviewDialogW(MSIHANDLE hPreview,
	LPCWSTR szDialogName);      // dialog to display, Dialog table key
#ifdef UNICODE
#define MsiPreviewDialog  MsiPreviewDialogW
#else
#define MsiPreviewDialog  MsiPreviewDialogA
#endif // !UNICODE

// Display a billboard within a host control in the displayed dialog.
// Supplying a null billboard name will remove any billboard displayed.

UINT WINAPI MsiPreviewBillboardA(MSIHANDLE hPreview,
	LPCSTR szControlName,      // name of control that accepts billboards
	LPCSTR szBillboard);       // name of billboard to display
UINT WINAPI MsiPreviewBillboardW(MSIHANDLE hPreview,
	LPCWSTR szControlName,      // name of control that accepts billboards
	LPCWSTR szBillboard);       // name of billboard to display
#ifdef UNICODE
#define MsiPreviewBillboard  MsiPreviewBillboardW
#else
#define MsiPreviewBillboard  MsiPreviewBillboardA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Error handling not associated with any particular object
// --------------------------------------------------------------------------

// Return a record handle to the last function that generated an error record
// Only specified functions will set the error record, or clear it if success
// Field 1 of the record will contain the internal MSI error code
// Other fields will contain data specific to the particular error
// The error record is released internally after this function is executed

MSIHANDLE WINAPI MsiGetLastErrorRecord();  // returns 0 if no cached record

#ifdef __cplusplus
}
#endif

#endif // _MSIQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\xslmerge\unmerger.cs ===
//------------------------------------------------------------------------------
// <copyright from='2000' to='2001' company='Microsoft Corporation'>
//    Copyright (c) Microsoft Corporation. All Rights Reserved.
//    Information Contained Herein is Proprietary and Confidential.
// </copyright>
//------------------------------------------------------------------------------

// csc /r:System.dll unmerger.cs

using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Text;
using System.Xml;


public class Unmerger
{
    public static void Main(String[] args)
    {
        if(args.Length < 1)
        {
            Console.WriteLine("Usage:  unmerger <machine.config>");
        }
        
        FileStream file = new FileStream(args[0], FileMode.Open);
        StreamReader reader = new StreamReader(file);
        String text = reader.ReadToEnd();
        text = Regex.Replace(text, 
                             "<!--Inserted by .Net Mobile SDK installer. BEGIN-->.*?<!--Inserted by .Net Mobile SDK installer. END-->", 
                             "",
                             RegexOptions.Singleline);
        text = Regex.Replace(text, 
                             "<!--\\s*?machine.config result element removed by .NET Mobile SDK installer\\.\\s*?-->",
                             "<result type=\"System.Web.HttpBrowserCapabilities\" />",
                             RegexOptions.Singleline);
        // Won't need this when we switch to URT xml.
        text = Regex.Replace(text, 
                             "<\\?xml .*?>",
                             "");

        reader.Close();
        file.Close();
        
        file=new FileStream(args[0], FileMode.Create);
        XmlTextWriter writer = new XmlTextWriter(file, Encoding.UTF8); // UTF-8
        writer.Formatting = Formatting.Indented;
        writer.WriteRaw(text);
        writer.Flush();
        writer.Close();      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\webconfigmerge\webconfigmerge.cs ===
//------------------------------------------------------------------------------
/// <copyright from='1997' to='2001' company='Microsoft Corporation'>           
///    Copyright (c) Microsoft Corporation. All Rights Reserved.                
///    Information Contained Herein is Proprietary and Confidential.            
/// </copyright>                                                                
//------------------------------------------------------------------------------

///     This small utility is used by our setup to merge our entries into the
///     machine.config file.  The command line syntax is as follows:
///
///         webConfigMerge <machine.config> <web.config>
///
///     Will merge the given valid web.config into the root machine.config.
///
///         webConfigMerge <machine.config>
///
///     With one argument it will remove the previously merged machine.config using
///     the _beginComment and _endComment XML comments as delimiters.  


namespace Microsoft.MobileUI.Install
{
    using Microsoft.Win32;
    using System;
    using System.IO;
    using System.Windows.Forms;
    using System.Xml;
    using System.Collections;
    using System.Configuration;
    using System.Text.RegularExpressions;
    using System.Text;

    public class XmlIndentAttributeTextWriter : XmlTextWriter 
    {
        TextWriter	_writer;
        private int _depth;

        public XmlIndentAttributeTextWriter( TextWriter w ) : base( w )
        {
            _writer = w;
        }

        public override void WriteStartElement(String prefix, String localName, String ns)
        {
            _depth++;
            base.WriteStartElement(prefix, localName, ns);
        }

        public override void WriteEndElement()
        {
            _depth--;
            base.WriteEndElement();
        }

        public override void WriteFullEndElement()
        {
            _depth--;
            base.WriteFullEndElement();
        }

        public override void WriteStartAttribute(String prefix, String localName, String ns )
        {
            _writer.Write("\r\n");
            // -1 because base.WriteStartAttribute inserts an extra space in AutoComplete.
            for (int i = 0; i < Indentation * _depth - 1; i++)
            {
                _writer.Write (IndentChar);
            }
            base.WriteStartAttribute( prefix, localName, ns );
        }

        public override void WriteComment(String text)
        {
            base.WriteComment(text);
        }

        public override void WriteStartDocument()
        {
            base.WriteStartDocument();
            _writer.Write("\r\n");
        }
    }
    
    public class ConfigWebMerge
    {
        private static String _removedEltBeginComment = "\r\nBEGIN result element commented by Microsoft Mobile Internet Toolkit installer.\r\nThe element between this and the corresponding END comment\r\nwill be uncommented upon uninstallation of the Mobile Internet Toolkit.\r\n";
        private static String _removedEltEndComment = "\r\nEND result element commented by Microsoft Mobile Internet Toolkit installer.\r\n";        
        private static String _beginComment = "\r\nBEGIN section inserted by Microsoft Mobile Internet Toolkit installer.\r\nAnything inserted between this and the corresponding END comment\r\nwill be lost upon uninstallation of the Mobile Internet Toolkit.\r\n";
        private static String _endComment = "\r\nEND section inserted by Microsoft Mobile Internet Toolkit installer\r\n";
        private static String _exceptionMessage = String.Empty;

        public static void Install(String machineConfigPath, String patchFileName)
        {
            ConfigXmlDocument machineConfig = new ConfigXmlDocument();
            machineConfig.PreserveWhitespace = true;
            machineConfig.Load(machineConfigPath);

            XmlDocument patch = new XmlDocument();
            patch.PreserveWhitespace = true;
            patch.Load(patchFileName);
            
            // Remove original <result type=""> node, replace by
            // comment.  Only one <result> node allowed in machine.config.
            String resultPath ="/configuration/system.web/browserCaps/result";
            String browserCapsPath = "/configuration/system.web/browserCaps";

            XmlNode resultNode = machineConfig.SelectSingleNode(resultPath);
            XmlNode browserCapsNode = machineConfig.SelectSingleNode(browserCapsPath);
            XmlNode patchResultNode = patch.SelectSingleNode(resultPath);
            XmlNode patchBrowserCapsNode = patch.SelectSingleNode(browserCapsPath);
            XmlNode patchResultNodeClone = machineConfig.ImportNode(patchResultNode, true);
            patchBrowserCapsNode.RemoveChild(patchResultNode);

            ArrayList browserCapsLeadingWhitespace = new ArrayList();
            foreach (XmlNode child in browserCapsNode.ChildNodes)
            {
                if (child.NodeType == XmlNodeType.Whitespace)
                {
                    browserCapsLeadingWhitespace.Add(child);
                }
                else
                {
                    break;
                }
            }

            StringBuilder commentText = new StringBuilder();
            if(resultNode != null)
            {   
                XmlTextWriter commentWriter = new XmlTextWriter(new StringWriter(commentText));
                resultNode.WriteTo(commentWriter);
                browserCapsNode.RemoveChild(resultNode);
            }
            
            MergePrepend(machineConfig, patch,
                "/configuration/system.web/httpModules");
            MergePrepend(machineConfig, patch,
                "/configuration/configSections/sectionGroup[@name='system.web']");
            MergePrepend(machineConfig, patch,
                "/configuration/system.web/compilation/assemblies");
            Merge(machineConfig, patch,
                "/configuration/system.web/browserCaps");
            Insert(machineConfig, patch,
                "/configuration/system.web","mobileControls");
            Insert(machineConfig, patch,
                "/configuration/system.web","deviceFilters");

            // Prepend these nodes (in reverse order) so that they occur
            // before any other children.
            if(resultNode != null)
            {
                PrependComment(machineConfig, browserCapsNode, _removedEltEndComment);
                PrependComment(machineConfig, browserCapsNode, commentText.ToString());
                PrependComment(machineConfig, browserCapsNode, _removedEltBeginComment);
            }
            PrependComment(machineConfig, browserCapsNode, _endComment);
            browserCapsNode.PrependChild(patchResultNodeClone);

            // Clone formatting for inserted node.
            foreach(XmlNode child in browserCapsLeadingWhitespace)
            {
                browserCapsNode.PrependChild(child.CloneNode(false /* deep */));
            }
            PrependComment(machineConfig, browserCapsNode, _beginComment);

            // Clone formatting for uninstall.
            foreach(XmlNode child in browserCapsLeadingWhitespace)
            {
                browserCapsNode.PrependChild(child.CloneNode(false /* deep */));
                browserCapsNode.RemoveChild(child);
            }

            RemoveExtraWhitespace(machineConfig);

            StreamWriter s = new StreamWriter(machineConfigPath);
            XmlIndentAttributeTextWriter writer = new XmlIndentAttributeTextWriter(s);
            writer.Formatting = Formatting.Indented;
            writer.Indentation = 4;
            machineConfig.Save(writer);
            writer.Flush();
            writer.Close();
        }

        public static void Insert(XmlDocument machineConfigRoot, XmlDocument
            patchRoot, String xPath, String childToInsert)
        {
            XmlNode machineConfigParent =
                machineConfigRoot.SelectSingleNode(xPath);
            XmlNode webConfigParent =
                patchRoot.SelectSingleNode(xPath + "/" + childToInsert);
            
            if(webConfigParent != null)
            {
                AppendComment(machineConfigRoot, machineConfigParent, _beginComment);
                XmlNode clone = machineConfigRoot.ImportNode(webConfigParent,true);
                machineConfigParent.AppendChild(clone);
                AppendComment(machineConfigRoot, machineConfigParent, _endComment);
            }
        }

        public static void Main(String[] args)
        {
            MergeUtilCommandLineArgs commandLineArgs = new MergeUtilCommandLineArgs(args);

            if (commandLineArgs.MachineConfigPath == String.Empty)
            {
                MergeUtilCommandLineArgs.ShowUsage();
                return;
            }

            try
            {
                if (commandLineArgs.Install)
                {
                    Install(commandLineArgs.MachineConfigPath, commandLineArgs.PatchFilePath);
                } 
                else
                {
                    Uninstall(commandLineArgs.MachineConfigPath, commandLineArgs.IgnoreMissingMachineConfig);
                }

                if (commandLineArgs.DeletePatchFile)
                {
                    File.SetAttributes (commandLineArgs.PatchFilePath, FileAttributes.Normal);
                    File.Delete (commandLineArgs.PatchFilePath);
                }
            }
            catch (Exception e)
            {
                MessageBox.Show(
                    commandLineArgs.ExceptionMessage + "\r\n" + e.ToString(),
                    commandLineArgs.ExceptionCaption,
                    MessageBoxButtons.OK, MessageBoxIcon.Error
                    );
            }
        }

        public static void Merge(XmlDocument machineConfigRoot, XmlDocument
            patchRoot, String xPath)
        {
            XmlNode machineConfigParent =
                machineConfigRoot.SelectSingleNode(xPath);
            XmlNode patchParent =
                patchRoot.SelectSingleNode(xPath);
            if(patchParent !=null && patchParent.HasChildNodes)
            {
                // Prepending (in reverse order) helps preserve preexisting formatting.
                AppendComment(machineConfigRoot, machineConfigParent, _beginComment);
                foreach(XmlNode child in patchParent.ChildNodes)
                {
                    XmlNode clone = machineConfigRoot.ImportNode(child, true);
                    machineConfigParent.AppendChild(clone);
                }
                AppendComment(machineConfigRoot, machineConfigParent, _endComment);
            }
        }

        public static void MergePrepend(XmlDocument machineConfigRoot, XmlDocument
            patchRoot, String xPath)
        {
            XmlNode machineConfigParent =
                machineConfigRoot.SelectSingleNode(xPath);
            XmlNode patchParent =
                patchRoot.SelectSingleNode(xPath);
            if(patchParent !=null && patchParent.HasChildNodes)
            {
                ArrayList childNodes = new ArrayList();
                foreach(XmlNode child in patchParent.ChildNodes)
                {
                    childNodes.Add(child);
                }
                childNodes.Reverse();

                // Prepending (in reverse order) helps preserve preexisting formatting.
                PrependComment(machineConfigRoot, machineConfigParent, _endComment);
                foreach(XmlNode child in childNodes)
                {
                    XmlNode clone = machineConfigRoot.ImportNode(child, true);
                    machineConfigParent.PrependChild(clone);
                }
                PrependComment(machineConfigRoot, machineConfigParent, _beginComment);
            }
        }

        public static void Uninstall(String machineConfigPath, bool ignoreMissingMachineConfig)
        {
            if (ignoreMissingMachineConfig)
            {
                if (!File.Exists(machineConfigPath))
                {
                      return;
                }
            }
            	
            FileStream file = new FileStream(machineConfigPath, FileMode.Open);
            StreamReader reader = new StreamReader(file);

            String text = reader.ReadToEnd();
            text = Regex.Replace(text, 
                "\r\n<!--\\s*?" + _beginComment + ".*?" + _endComment +
                "\\s*?-->\r\n", 
                "",
                RegexOptions.Singleline);
            text = Regex.Replace(text, 
                "\r\n<!--\\s*?" + _removedEltBeginComment + "\\s*?-->\\s*?<!--",
                "",
                RegexOptions.Singleline);
            text = Regex.Replace(text,
                "-->\\s*?<!--\\s*?" + _removedEltEndComment + "\\s*?-->\r\n",
                "",
                RegexOptions.Singleline);
            
            reader.Close();
            file.Close();
            
            file=new FileStream(machineConfigPath, FileMode.Create);
            XmlTextWriter writer = new XmlTextWriter(file, Encoding.UTF8);
            writer.Formatting = Formatting.Indented;
            writer.WriteRaw(text);
            writer.Flush();
            writer.Close();      
        }

        private static void AppendComment(XmlDocument root, XmlNode parent, String comment)
        {
            parent.AppendChild(root.CreateWhitespace("\r\n"));
            parent.AppendChild(root.CreateComment(comment));
            parent.AppendChild(root.CreateWhitespace("\r\n"));
        }

        private static void PrependComment(XmlDocument root, XmlNode parent, String comment)
        {
            parent.PrependChild(root.CreateWhitespace("\r\n"));
            parent.PrependChild(root.CreateComment(comment));
            parent.PrependChild(root.CreateWhitespace("\r\n"));
        }            
    
        // Remove whitespace appearing as 1st gen children of the document node.
        // Proper whitespace is automatically added by the XmlTextWriter.
        private static void RemoveExtraWhitespace(ConfigXmlDocument machineConfig)
        {
            ArrayList whitespaceNodes = new ArrayList();
            foreach (System.Xml.XmlNode child in machineConfig.ChildNodes)
            {
                if (child.NodeType==System.Xml.XmlNodeType.Whitespace)
                {
                    whitespaceNodes.Add(child);
                }
            }
            foreach (XmlNode whitespace in whitespaceNodes)
            {
                machineConfig.RemoveChild(whitespace);
            }
        }

        private class MergeUtilCommandLineArgs
        {
            private bool _deletePatchFile = false;
            private String _exceptionCaption = "Installation Error";
            private String _exceptionMessage = "Microsoft Mobile Internet Toolkit machine.config merge failed.";
            private bool _install = false; // true if we are installing rather than uninstalling.
            private String _machineConfigPath = String.Empty;
            private String _patchFilePath = String.Empty;
            private bool _ignoreMissingMachineConfig = false;

            private static String _exceptionCaptionSwitch = "c:";
            private static String _deletePatchFileSwitch = "d";
            private static String _exceptionMessageSwitch = "e:";
            private static String _installSwitch = "i";
            private static String _machineConfigPathSwitch = "m:";
            private static String _patchFilePathSwitch = "p:";
            private static String _ignoreMissingMachineConfigSwitch = "s";

            public MergeUtilCommandLineArgs(String[] args)
            {
                foreach (String commandLineArg in args)
                {
                    if (commandLineArg[0] != '/' && commandLineArg[0] != '-')
                    {
                        ShowUsage();
                        break;
                    }

                    String arg = commandLineArg.Substring(1);
                    if (arg.StartsWith(_machineConfigPathSwitch))
                    {
                        _machineConfigPath = arg.Substring(_machineConfigPathSwitch.Length);
                    }
                    else if (arg.StartsWith(_exceptionMessageSwitch))
                    {
                        _exceptionMessage = arg.Substring(_exceptionMessageSwitch.Length);
                    }
                    else if (arg.StartsWith(_exceptionCaptionSwitch))
                    {
                        _exceptionCaption = arg.Substring(_exceptionCaptionSwitch.Length);
                    }
                    else if (arg.StartsWith(_patchFilePathSwitch))
                    {
                        _patchFilePath = arg.Substring(_patchFilePathSwitch.Length);
                    }
                    else if (arg == _deletePatchFileSwitch)
                    {
                        _deletePatchFile = true;
                    }
                    else if (arg == _installSwitch)
                    {
                        _install = true;
                    }
                    else if (arg == _ignoreMissingMachineConfigSwitch)
                    {
                    	   _ignoreMissingMachineConfig = true;
                    }
                    else
                    {
                        ShowUsage();
                        break;
                    }
                }
            }

            // For internal setup use only.  Not localized.  
            public static void ShowUsage()
            {
                StringBuilder builder = new StringBuilder();
                builder.Append("/" +
                    _exceptionCaptionSwitch + 
                    "<caption>" +
                    "\tCaption for exception message box.\r\n");
                builder.Append("/" + 
                    _deletePatchFileSwitch + 
                    "\t\tDelete patch file after installation.\r\n");
                builder.Append("/" + 
                    _exceptionMessageSwitch + 
                    "<message>" + 
                    "\tLocalized exception message.\r\n");
                builder.Append("/" + 
                    _installSwitch + 
                    "\t\tInstall.  Merge patch file into machine.config.\r\n");
                builder.Append("/" + 
                    _machineConfigPathSwitch + "<path>" + 
                    "\t(Required) Path to machine.config.\r\n");
                builder.Append("/" + 
                    _patchFilePathSwitch + "<path>" + 
                    "\tPath to patch config file.\r\n");
                builder.Append("/" +
                	_ignoreMissingMachineConfigSwitch +
                	"\t\tSuppress file missing exception when machine.config is not present.");
                
                MessageBox.Show(
                    builder.ToString(),
                    "Usage",
                    MessageBoxButtons.OK, 
                    MessageBoxIcon.Information);                
            }

            public bool DeletePatchFile
            {
                get
                {
                    return _deletePatchFile;
                }
            }

            public String ExceptionCaption
            {
                get
                {
                    return _exceptionCaption;
                }
            }

            public String ExceptionMessage
            {
                get
                {
                    return _exceptionMessage;
                }
            }

            public bool Install
            {
                get
                {
                    return _install;
                }
            }

            public String MachineConfigPath
            {
                get
                {
                    return _machineConfigPath;
                }
            }

            public String PatchFilePath
            {
                get
                {
                    return _patchFilePath;
                }
            }

            public bool IgnoreMissingMachineConfig
            {
                get
                {
                    return _ignoreMissingMachineConfig;   
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\setup\xslmerge\merger.cs ===
//------------------------------------------------------------------------------
// <copyright from='2000' to='2001' company='Microsoft Corporation'>
//    Copyright (c) Microsoft Corporation. All Rights Reserved.
//    Information Contained Herein is Proprietary and Confidential.
// </copyright>
//------------------------------------------------------------------------------

// csc /r:System.dll /r:System.Xml.dll merger.cs

using System;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.IO;
using System.Text;

public class Merger
{
    public static void Main(String[] args)
    {
        if(args.Length < 3)
        {
            Console.WriteLine("Usage: merger <machine.config> <merge.xsl> <web.config>");
            return;
        }
        
        XPathDocument doc = new XPathDocument(new FileStream(args[0], FileMode.Open));
        XPathNavigator nav = ((IXPathNavigable)doc).CreateNavigator();

        XPathDocument stylesheetDoc = new XPathDocument(new FileStream(args[1], FileMode.Open));
        XPathNavigator stylesheetNav = ((IXPathNavigable)doc).CreateNavigator();

        XslTransform transform = new XslTransform();
        transform.Load(stylesheetNav);

        XsltArgumentList arg = new XsltArgumentList();
        arg.AddParam("webConfig", null, args[2]);
        
        FileStream file = new FileStream(args[0], FileMode.Open);
        XmlTextWriter writer = new XmlTextWriter(file, Encoding.UTF8); // UTF-8
        writer.Formatting = Formatting.Indented;

        transform.Transform(nav, arg, writer);
        writer.Flush();
        writer.Close();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\configurationsectionhelper.cs ===
//------------------------------------------------------------------------------
// <copyright file="ConfigurationSectionHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Mobile
{
    using System.Xml;
    using System.Configuration;
    using System.Diagnostics;

    internal class ConfigurationSectionHelper
    {
        private XmlNode _currentNode = null;

        internal ConfigurationSectionHelper() {
        }

        internal /*public*/ XmlNode Node
        {
            get
            {
                return _currentNode;
            }
            
            set
            {
                _currentNode = value;
            }
        }

        private XmlNode GetAndRemoveAttribute(String attributeName, bool required)
        {
            XmlNode attibuteNode = _currentNode.Attributes.RemoveNamedItem(attributeName);

            if (required && attibuteNode == null)
            {
                String msg = SR.GetString(SR.ConfigSect_MissingAttr,
                                          attributeName);
                throw new ConfigurationException(msg, _currentNode);
            }

            return attibuteNode;
        }


        internal /*public*/ String RemoveStringAttribute(String attributeName,
            bool required)
        {
            Debug.Assert(null != _currentNode);

            XmlNode attributeNode = GetAndRemoveAttribute(attributeName, required);
            if(attributeNode != null)
            {
                if(required && attributeNode.Value == String.Empty)
                {
                    String msg = SR.GetString(SR.ConfigSect_MissingValue,
                                              attributeName);
                    throw new ConfigurationException(msg, _currentNode);
                }
                return attributeNode.Value;
            }
            else
            {
                return null;
            }
        }


        internal /*public*/ bool RemoveBoolAttribute(String attributeName,
                                        bool required,
                                        bool defaultValue)
        {
            Debug.Assert(null != _currentNode);

            XmlNode attributeNode = GetAndRemoveAttribute(attributeName, required);
            if(attributeNode != null)
            {
                try
                {
                    return bool.Parse(attributeNode.Value);
                }
                catch
                {
                    String msg =
                        SR.GetString(SR.ConfigSect_InvalidBooleanAttr,
                                     attributeName);
                    throw new ConfigurationException(msg, _currentNode);
                }
            }
            else
            {
                return defaultValue;
            }
            
        }

        internal /*public*/ int RemoveIntAttribute(String attributeName,
                                      bool required,
                                      int defaultValue)
        {
            Debug.Assert(null != _currentNode);

            XmlNode attributeNode = GetAndRemoveAttribute(attributeName, required);
            if(attributeNode != null)
            {
                try
                {
                    return int.Parse(attributeNode.Value);
                }
                catch
                {
                    String msg =
                        SR.GetString(SR.ConfigSect_InvalidIntegerAttr,
                                     attributeName);
                    throw new ConfigurationException(msg, _currentNode);
                }
            }
            else
            {
                return defaultValue;
            }
            
        }


        internal /*public*/ void CheckForUnrecognizedAttributes()
        {
            Debug.Assert(null != _currentNode);

            if(_currentNode.Attributes.Count != 0)
            {
                String msg = SR.GetString(SR.ConfigSect_UnknownAttr,
                                          _currentNode.Attributes[0].Name);
                throw new ConfigurationException(msg, _currentNode);
            }
        }


        internal /*public*/ bool IsWhitespaceOrComment()
        {
            Debug.Assert(null != _currentNode);

            return _currentNode.NodeType == XmlNodeType.Comment ||
                _currentNode.NodeType == XmlNodeType.Whitespace;
        }


        internal /*public*/ void RejectNonElement()
        {
            Debug.Assert(null != _currentNode);

            if(_currentNode.NodeType != XmlNodeType.Element)
            {
                throw new ConfigurationException(SR.GetString(SR.ConfigSect_UnrecognizedXML),
                                                 _currentNode);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\cookielessdata.cs ===
//------------------------------------------------------------------------------
// <copyright file="CookielessData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Mobile
{
    /*
     * CookielessData
     * encapsulates access to data to be persisted in local links
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    using System.Collections.Specialized;
    using System.Web.Security;
    using System.Security.Permissions;

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CookielessData : HybridDictionary
    {
        internal System.Web.UI.MobileControls.Form _form;

        public CookielessData()
        {
            String name = FormsAuthentication.FormsCookieName;
            String inboundValue = HttpContext.Current.Request.QueryString[name];
            if(inboundValue == null)
            {
                inboundValue = HttpContext.Current.Request.Form[name];
            }
            if(inboundValue != null)
            {
                FormsAuthenticationTicket ticket = FormsAuthentication.Decrypt(inboundValue);
                FormsAuthenticationTicket ticket2 = FormsAuthentication.RenewTicketIfOld(ticket);
                this[name] = FormsAuthentication.Encrypt(ticket2);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\mobileerrorinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileErrorInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Specialized;
using System.Text.RegularExpressions;
using System.Security.Permissions;

namespace System.Web.Mobile
{
    /*
     * Mobile Error Info
     * Contains information about an error that occurs in a mobile application.
     * This information can be used to format the error for the target device.
     *
     * BUGBUG: The ParseHttpException part of this class is a terrible hack.
     * We're trying to get the ASP+ guys to change their error APIs to let us hook into it.
     * Until then, we have to get their FINAL OUTPUT, and then do some parsing on it to 
     * get what we need.
     *
     */
    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileErrorInfo
    {
        public static readonly String ContextKey = "MobileErrorInfo";

        private const String _errorType = "Type";
        private const String _errorDescription = "Description";
        private const String _errorMiscTitle = "MiscTitle";
        private const String _errorMiscText = "MiscText";
        private const String _errorFile = "File";
        private const String _errorLineNumber = "LineNumber";
        private static Regex[] _searchExpressions = null;
        private static bool _searchExpressionsBuilt = false;
        private const int _expressionCount = 3;

        private StringDictionary _dictionary = new StringDictionary();

        internal MobileErrorInfo(Exception e)
        {
            // Don't want any failure to escape here...
            try
            {
                // For some reason, the compile exception lives in the
                // InnerException. 
                HttpCompileException compileException =
                    e.InnerException as HttpCompileException;

                if (compileException != null)
                {
                    this.Type = SR.GetString(SR.MobileErrorInfo_CompilationErrorType);
                    this.Description = SR.GetString(SR.MobileErrorInfo_CompilationErrorDescription);                
                    this.MiscTitle = SR.GetString(SR.MobileErrorInfo_CompilationErrorMiscTitle);
                    
                    CompilerErrorCollection errors = compileException.Results.Errors;
                
                    if (errors != null && errors.Count >= 1)
                    {
                        CompilerError error = errors[0];
                        this.LineNumber = error.Line.ToString();
                        this.File = error.FileName;
                        this.MiscText = error.ErrorNumber + ":" + error.ErrorText;
                    }
                    else
                    {
                        this.LineNumber = SR.GetString(SR.MobileErrorInfo_Unknown);
                        this.File = SR.GetString(SR.MobileErrorInfo_Unknown);
                        this.MiscText = SR.GetString(SR.MobileErrorInfo_Unknown);
                    }

                    return;
                }

                HttpParseException parseException = e as HttpParseException; 
                if (parseException != null)
                {
                    this.Type = SR.GetString(SR.MobileErrorInfo_ParserErrorType);
                    this.Description = SR.GetString(SR.MobileErrorInfo_ParserErrorDescription);                
                    this.MiscTitle = SR.GetString(SR.MobileErrorInfo_ParserErrorMiscTitle);
                    this.LineNumber = parseException.Line.ToString();
                    this.File = parseException.FileName;
                    this.MiscText = parseException.Message;
                    return;
                }

                // We try to use the hacky way of parsing an HttpException of an
                // unknown subclass.
                HttpException httpException = e as HttpException;
                if (httpException != null && ParseHttpException(httpException))
                {
                    return;
                }
                
            }
            catch (Exception)
            {
                // Don't need to do anything here, just continue to base case
                // below. 
            }
            
            // Default to the most basic if none of the above succeed.
            this.Type = e.GetType().FullName;
            this.Description = e.Message;
            this.MiscTitle = SR.GetString(SR.MobileErrorInfo_SourceObject);
            String s = e.StackTrace;
            int i = s.IndexOf('\r');
            if (i != -1)
            {
                s = s.Substring(0, i);
            }
            this.MiscText = s;
        }

        public String this[String key]
        {
            get
            {
                String s = _dictionary[key];
                return (s == null) ? String.Empty : s;
            }
            set
            {
                _dictionary[key] = value;
            }
        }

        public String Type
        {
            get
            {
                return this[_errorType];
            }
            set
            {
                this[_errorType] = value;
            }
        }

        public String Description
        {
            get
            {
                return this[_errorDescription];
            }
            set
            {
                this[_errorDescription] = value;
            }
        }

        public String MiscTitle
        {
            get
            {
                return this[_errorMiscTitle];
            }
            set
            {
                this[_errorMiscTitle] = value;
            }
        }

        public String MiscText
        {
            get
            {
                return this[_errorMiscText];
            }
            set
            {                  
                this[_errorMiscText] = value;
            }
        }

        public String File
        {
            get
            {
                return this[_errorFile];
            }
            set
            {
                this[_errorFile] = value;
            }
        }

        public String LineNumber
        {
            get
            {
                return this[_errorLineNumber];
            }
            set
            {
                this[_errorLineNumber] = value;
            }
        }

        // Return true if we succeed
        private bool ParseHttpException(HttpException e)
        {
            int i;
            Match match = null;

            String errorMessage = e.GetHtmlErrorMessage();
            if (errorMessage == null)
            {
                return false;
            }

            // Use regular expressions to scrape the message output
            // for meaningful data. One problem: Some parts of the 
            // output are optional, and any regular expression that
            // uses the ()? syntax doesn't pick it up. So, we have
            // to have all the different combinations of expressions,
            // and use each one in order.

            EnsureSearchExpressions();
            for (i = 0; i < _expressionCount; i++)
            {
                match = _searchExpressions[i].Match(errorMessage);
                if (match.Success)
                {
                    break;
                }
            }

            if (i == _expressionCount)
            {
                return false;
            }

            this.Type        = TrimAndClean(match.Result("${title}"));
            this.Description = TrimAndClean(match.Result("${description}"));
            if (i <= 1)
            {
                // These expressions were able to match the miscellaneous
                // title/text section.
                this.MiscTitle = TrimAndClean(match.Result("${misctitle}"));
                this.MiscText  = TrimAndClean(match.Result("${misctext}"));
            }
            if (i == 0)
            {
                // This expression was able to match the file/line # 
                // section.
                this.File        = TrimAndClean(match.Result("${file}"));
                this.LineNumber  = TrimAndClean(match.Result("${linenumber}"));
            }

            return true;
        }

        private static void EnsureSearchExpressions()
        {
            // Create precompiled search expressions. They're here
            // rather than in static variables, so that we can load
            // them from resources on demand. But once they're loaded,
            // they're compiled and always available.

            lock(typeof(MobileErrorInfo))
            {
                if (!_searchExpressionsBuilt)
                {
                    // TODO: If we have to stick with this hacky way of scraping error
                    // output, we will at least need to localize this, or maybe even put
                    // it in a config.  Note that it's not too much of a
                    // problem, since we only get here after we've determine
                    // this isn't a parser error or a compiler error, and if
                    // these regex's fail, there's still a generic fallback.

                    // Why three similar expressions? See ParseHttpException above.

                    _searchExpressions = new Regex[_expressionCount];

                    _searchExpressions[0] = new Regex(
                        "<title>(?'title'.*?)</title>.*?" +
                            ": </b>(?'description'.*?)<br>.*?" + 
                            "(<b>(?'misctitle'.*?): </b>(?'misctext'.*?)<br)+.*?" +
                            "(Source File:</b>(?'file'.*?)&nbsp;&nbsp; <b>Line:</b>(?'linenumber'.*?)<br)+",
                        RegexOptions.Singleline | 
                            RegexOptions.IgnoreCase | 
                            RegexOptions.CultureInvariant |
                            RegexOptions.Compiled);

                    _searchExpressions[1] = new Regex(
                        "<title>(?'title'.*?)</title>.*?" +
                            ": </b>(?'description'.*?)<br>.*?" + 
                            "(<b>(?'misctitle'.*?): </b>(?'misctext'.*?)<br)+.*?",
                        RegexOptions.Singleline | 
                            RegexOptions.IgnoreCase | 
                            RegexOptions.CultureInvariant |
                            RegexOptions.Compiled);

                    _searchExpressions[2] = new Regex(
                        "<title>(?'title'.*?)</title>.*?: </b>(?'description'.*?)<br>",
                        RegexOptions.Singleline | 
                        RegexOptions.IgnoreCase | 
                        RegexOptions.CultureInvariant |
                            RegexOptions.Compiled);

                    _searchExpressionsBuilt = true;
                }
            }
        }

        private static String TrimAndClean(String s)
        {
            return s.Replace("\r\n", " ").Trim();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\devicefilterdictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceFilterDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Mobile
{
    using System.Web;
    using System.Collections;
    using System.Reflection;
    using System.Diagnostics;
    using System.ComponentModel;

    internal class DeviceFilterDictionary
    {
        internal class ComparisonEvaluator
        {
            internal readonly String capabilityName;
            internal readonly String capabilityArgument;

            internal ComparisonEvaluator(String name, String argument)
            {
                Debug.Assert(name != null);

                capabilityName = name;
                capabilityArgument = argument;
            }
        }

        private Hashtable _comparisonEvaluators = null;
        private Hashtable _delegateEvaluators = null;


        internal DeviceFilterDictionary()
        {
            _comparisonEvaluators = new Hashtable();
            _delegateEvaluators = new Hashtable();
        }


        internal DeviceFilterDictionary(DeviceFilterDictionary original)
        {
            _comparisonEvaluators = (Hashtable)original._comparisonEvaluators.Clone();
            _delegateEvaluators = (Hashtable)original._delegateEvaluators.Clone();
        }


        internal void AddCapabilityDelegate(String delegateName,
            MobileCapabilities.EvaluateCapabilitiesDelegate evaluator)
        {
            _delegateEvaluators[delegateName] = evaluator;
        }


        private void CheckForComparisonDelegateLoops(String delegateName)
        {
            String nextDelegateName = delegateName;
            Hashtable alreadyReferencedDelegates = new Hashtable();

            while(true)
            {
                ComparisonEvaluator nextComparisonEvaluator =
                    (ComparisonEvaluator)_comparisonEvaluators[nextDelegateName];
                if(nextComparisonEvaluator == null)
                {
                    break;
                }

                if(alreadyReferencedDelegates.Contains(nextDelegateName))
                {
                    String msg = SR.GetString(SR.DevFiltDict_FoundLoop,
                                              nextComparisonEvaluator.capabilityName,
                                              delegateName);
                    throw new Exception(msg);
                }

                alreadyReferencedDelegates[nextDelegateName] = null;
                nextDelegateName = nextComparisonEvaluator.capabilityName;
            }
        }


        internal void AddComparisonDelegate(String delegateName, String comparisonName,
            String argument)
        {
            _comparisonEvaluators[delegateName] = new ComparisonEvaluator(comparisonName,
                argument);

            CheckForComparisonDelegateLoops(delegateName);
        }


        internal bool FindComparisonEvaluator(String evaluatorName, out String capabilityName,
            out String capabilityArgument)
        {
            capabilityName = null;
            capabilityArgument = null;

            ComparisonEvaluator evaluator = (ComparisonEvaluator)_comparisonEvaluators[evaluatorName];
            if(evaluator == null)
            {
                return false;
            }

            capabilityName = evaluator.capabilityName;
            capabilityArgument = evaluator.capabilityArgument;

            return true;
        }


        internal bool FindDelegateEvaluator(String evaluatorName,
            out MobileCapabilities.EvaluateCapabilitiesDelegate evaluatorDelegate)
        {
            evaluatorDelegate = null;

            MobileCapabilities.EvaluateCapabilitiesDelegate evaluator;
            evaluator = (MobileCapabilities.EvaluateCapabilitiesDelegate)
                            _delegateEvaluators[evaluatorName];
            if(evaluator == null)
            {
                return false;
            }

            evaluatorDelegate = evaluator;

            return true;
        }


        internal bool IsComparisonEvaluator(String evaluatorName)
        {
            return _comparisonEvaluators.Contains(evaluatorName);
        }

        internal bool IsDelegateEvaluator(String evaluatorName)
        {
            return _delegateEvaluators.Contains(evaluatorName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\mobiledevicecapabilitiessectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileDeviceCapabilitiesSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Mobile
{
    using System.Collections;
    using System.Configuration;
    using System.Reflection;
    using System.Xml;
    using System.Security.Permissions;

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileDeviceCapabilitiesSectionHandler : IConfigurationSectionHandler
    {
        // IConfigurationSectionHandler Methods
        Object IConfigurationSectionHandler.Create(Object parent, Object context,
            XmlNode node)
        {
            // see ASURT 123738
            if (context == null || context.GetType() != typeof(System.Web.Configuration.HttpConfigurationContext)) {
                return null;
            }
            
            DeviceFilterDictionary currentFilterDictionary;
            
            if(parent == null)
            {
                currentFilterDictionary = new DeviceFilterDictionary();
            }
            else
            {
                currentFilterDictionary = new DeviceFilterDictionary(
                    (DeviceFilterDictionary)parent);
            }

            ConfigurationSectionHelper helper = new ConfigurationSectionHelper();
            foreach(XmlNode child in node.ChildNodes)
            {
                helper.Node = child;

                // skip whitespace and comments
                if(helper.IsWhitespaceOrComment())
                {
                    continue;
                }
                    
                // reject nonelements
                helper.RejectNonElement();

                // handle <filter> tags

                if(child.Name.Equals("filter"))
                {
                    String name = helper.RemoveStringAttribute("name", true);
                    String className = helper.RemoveStringAttribute("type", false);

                    if(className != null)
                    {
                        const String methodAttributeName = "method";
                        String methodName = helper.RemoveStringAttribute(methodAttributeName, false);
                        String capabilityName = helper.RemoveStringAttribute("compare", false);
                        String argumentValue = helper.RemoveStringAttribute("argument", false);

                        helper.CheckForUnrecognizedAttributes();

                        if(className == String.Empty)
                        {
                            throw new
                                ConfigurationException(SR.GetString(SR.DevCapSect_EmptyClass), child);
                        }

                        if(methodName == null)
                        {
                            throw new
                                ConfigurationException(SR.GetString(SR.ConfigSect_MissingAttr, methodAttributeName), child);
                        }

                        if(methodName == String.Empty)
                        {
                            throw new
                                ConfigurationException(SR.GetString(SR.ConfigSect_MissingValue, methodAttributeName), child);
                        }

                        if(capabilityName != null || argumentValue != null)
                        {
                            String msg;
                            if (capabilityName != null)
                            {
                                msg = SR.GetString(SR.DevCapSect_ExtraCompareDelegator);
                            }
                            else
                            {
                                msg = SR.GetString(SR.DevCapSect_ExtraArgumentDelegator);
                            }
                            
                            throw new ConfigurationException(msg, child);
                        }

                        MobileCapabilities.EvaluateCapabilitiesDelegate evaluator;

                        Type evaluatorClass = Type.GetType(className);

                        if(null == evaluatorClass)
                        {
                            String msg =
                                SR.GetString(SR.DevCapSect_NoTypeInfo, className);
                            throw new ConfigurationException(msg, child);
                        }

                        try
                        {
                            evaluator =
                                (MobileCapabilities.EvaluateCapabilitiesDelegate)
                                MobileCapabilities.EvaluateCapabilitiesDelegate.CreateDelegate(
                                    typeof(MobileCapabilities.EvaluateCapabilitiesDelegate),
                                    evaluatorClass, methodName);
                        }
                        catch(Exception e)
                        {
                            String msg =
                                SR.GetString(SR.DevCapSect_NoCapabilityEval,
                                             methodName, e.Message);
                            throw new ConfigurationException(msg, child);
                        }

                        currentFilterDictionary.AddCapabilityDelegate(name, evaluator);
                    }
                    else
                    {
                        String capabilityName = helper.RemoveStringAttribute("compare", false);
                        String argumentValue = helper.RemoveStringAttribute("argument", false);
                        String methodName = helper.RemoveStringAttribute("method", false);                        

                        helper.CheckForUnrecognizedAttributes();

                        if((capabilityName == null) || (capabilityName == String.Empty))
                        {
                            throw new ConfigurationException(
                                SR.GetString(SR.DevCapSect_MustSpecify),
                                child);
                        }

                        if(methodName != null)
                        {
                            throw new ConfigurationException(
                                SR.GetString(SR.DevCapSect_ComparisonAlreadySpecified),
                                child);
                        }

                        try
                        {
                            currentFilterDictionary.AddComparisonDelegate(name, capabilityName, argumentValue);
                        }
                        catch(Exception e)
                        {
                            String msg = SR.GetString(SR.DevCapSect_UnableAddDelegate,
                                                      name, e.Message);
                            throw new ConfigurationException(msg, child);
                        }
                    }                    
                }
                else
                {
                    String msg = SR.GetString(SR.DevCapSect_UnrecognizedTag,
                                              child.Name);
                    throw new ConfigurationException(msg, child);
                }

                helper.Node = null;
            }
   
            return currentFilterDictionary;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\mobileformsauthentication.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileFormsAuthentication.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Security;
using System.Web.Security;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

namespace System.Web.Mobile
{
    /*
     * MobileFormsAuthentication
     * provides mobile comopatible version of ASP.Net methods
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileFormsAuthentication
    {
        // Class only contains statics, so make the constructor private.
        private MobileFormsAuthentication()
        {
        }
        
        public static void RedirectFromLoginPage(String userName, bool createPersistentCookie)
        {
            RedirectFromLoginPage(userName, createPersistentCookie, FormsAuthentication.FormsCookiePath);
        }

        public static void RedirectFromLoginPage(String userName, bool createPersistentCookie, String strCookiePath)
        {
            // Disallow redirection to an absolute url.
            String requestReturnUrl = HttpContext.Current.Request["ReturnUrl"];
            if (requestReturnUrl != null && requestReturnUrl.IndexOf (":") != -1)
            {
                throw new SecurityException(SR.GetString(SR.Security_ReturnUrlCannotBeAbsolute, requestReturnUrl));
            }

            // GetRedirectUrl redirects to returnUrl if it exists, current app's default.aspx otherwise.            
            String redirectUrl = FormsAuthentication.GetRedirectUrl(userName, createPersistentCookie);
            Debug.Assert (redirectUrl == requestReturnUrl || requestReturnUrl == null);

            String updatedRedirectUrl = redirectUrl;
            String cookieName = FormsAuthentication.FormsCookieName;
            HttpCookie cookie = FormsAuthentication.GetAuthCookie(userName, createPersistentCookie, strCookiePath);
            String strEncrypted = cookie.Value;

            int ticketLoc = redirectUrl.IndexOf(cookieName + "=");
            if(ticketLoc != -1)
            {
                updatedRedirectUrl = redirectUrl.Substring(0, ticketLoc);
                updatedRedirectUrl += cookieName + "=" + strEncrypted;
                int ampersandLoc = redirectUrl.IndexOf('&', ticketLoc);
                if(ampersandLoc != -1)
                {
                    updatedRedirectUrl += redirectUrl.Substring(ampersandLoc);
                }
            }
            else
            {
                int loc = updatedRedirectUrl.IndexOf('?');
                updatedRedirectUrl += (loc != -1) ? "&" : "?";
                updatedRedirectUrl += cookieName + "=" + strEncrypted;
            }
            MobileRedirect.RedirectToUrl(HttpContext.Current, updatedRedirectUrl, true);
        }

        public static void SignOut()
        {
            MobilePage page = HttpContext.Current.Handler as MobilePage;
            if (page != null)
            {
                page.Adapter.PersistCookielessData = false;
                if (!page.Device.SupportsEmptyStringInCookieValue)
                {
                    // Desktop signout with empty cookie value is not handled properly by the device.
                    InternalSignOut ();
                    return;
                }
            }
            FormsAuthentication.SignOut();
        }

        private static void InternalSignOut ()
        {
            HttpContext context = HttpContext.Current;
            String userName = 
                context.User == null || context.User.Identity == null || context.User.Identity.Name == null ? 
                "" : 
                context.User.Identity.Name;
            FormsAuthenticationTicket ticket = new FormsAuthenticationTicket (
                1, // version
                userName,
                DateTime.Now, // Issue-Date
                new DateTime(1999, 10, 12), // Expiration
                false, // IsPersistent
                "", // User-Data
                FormsAuthentication.FormsCookiePath); 
            String encryptedTicket = FormsAuthentication.Encrypt (ticket);
            if (encryptedTicket == null) { // Encrypt returned null
                encryptedTicket = "x";
            }
            HttpCookie cookie = new HttpCookie (FormsAuthentication.FormsCookieName, encryptedTicket);
            cookie.Path = FormsAuthentication.FormsCookiePath;
            cookie.Expires = new System.DateTime (1999, 10, 12);
            cookie.Secure = FormsAuthentication.RequireSSL;
            context.Response.Cookies.Remove (FormsAuthentication.FormsCookieName);
            context.Response.Cookies.Add (cookie);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\errorhandlermodule.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorHandlerModule.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web; 
using System.Diagnostics;
using System.Collections;
using System.Text;
using System.Security.Permissions;

namespace System.Web.Mobile
{
    /*
     * Error Handler Module
     * An Http Module that traps errors, and formats them for the appropriate
     * device.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ErrorHandlerModule : IHttpModule 
    {
        void IHttpModule.Init(HttpApplication application) 
        { 
            application.BeginRequest += (new EventHandler(this.Application_BeginRequest));
            application.Error += (new EventHandler(this.Application_Error));
            application.EndRequest += (new EventHandler(this.Application_EndRequest));
        }

        private void Application_BeginRequest(Object source, EventArgs e) 
        {
            HttpApplication application = (HttpApplication)source;
            HttpContext context = application.Context;
            if (context != null)
            {
                // Some device/gateway combination sends postdata's charset
                // in a separate header rather than in Content-Type.
                SetCharsetInRequestHeader(context);
            }
        }

        private void SetCharsetInRequestHeader(HttpContext context)
        {
            String userAgent = context.Request.UserAgent;

            if (userAgent != null && userAgent.StartsWith("UP"))
            {
                String postDataCharset = context.Request.Headers["x-up-devcap-post-charset"];
                if (postDataCharset != null && postDataCharset.Length > 0)
                {
                    try
                    {
                        context.Request.ContentEncoding = Encoding.GetEncoding(postDataCharset);
                    }
                    catch
                    {
                        // Exception may be thrown when charset is not valid.
                        // In this case, do nothing, and let the framework
                        // use the configured RequestEncoding setting.
                    }
                }
            }
        }

        private void Application_EndRequest(Object source, EventArgs e) 
        {
            HttpApplication application = (HttpApplication)source;
            HttpContext context = application.Context;
            if (context != null)
            {
                MobileRedirect.CheckForInvalidRedirection(context);
            }
        }

        private void Application_Error(Object source, EventArgs e) 
        {
            HttpApplication application = (HttpApplication)source;
            HttpContext context = null;
            bool useAdaptiveErrorReporting = false;

            try
            {
                context = application.Context;

                if(context.IsCustomErrorEnabled)
                {
                    return;
                }
    
                Exception error = context.Server.GetLastError();

                if ((error == null) || (!RequiresAdaptiveErrorReporting(context, error)))
                {
                    return;
                }

                useAdaptiveErrorReporting = true;
    
                MobileErrorInfo errorInfo = new MobileErrorInfo(error);
                context.Items[MobileErrorInfo.ContextKey] = errorInfo;
    
                context.Response.Clear();
                IHttpHandler errorHandler = CreateErrorFormatter(context);
                errorHandler.ProcessRequest(context);
            }
            catch(Exception e2)
            {
                if (useAdaptiveErrorReporting && context != null)
                {
                    // Failed to format error. Let it continue through
                    // default processing.

                    context.Response.Write(e2.ToString());
                    context.Server.ClearError();
                    return;
                }
                else
                {
                    return;
                }
            }

            context.Server.ClearError();
        }
    
        void IHttpModule.Dispose() 
        {
        }

        private bool RequiresAdaptiveErrorReporting(HttpContext context, Exception error)
        {
            // Check if the error message is a non-500 error.

            HttpException httpError = error as HttpException;
            if (httpError != null && httpError.GetHttpCode() != 500)
            {
                return false;
            }

            bool b;

            // Checks whether custom error formatting is required for the
            // given device.

            MobileCapabilities caps = context.Request.Browser as MobileCapabilities;
            if (caps == null)
            {
                b = false;
            }
            else if (caps.PreferredRenderingMime != "text/html")
            {
                b = true;
            }
            else
            {
                b = caps.RequiresHtmlAdaptiveErrorReporting;
            }
            return b;
        }

        private const String _errorFormatterClass = "System.Web.UI.MobileControls.ErrorFormatterPage";
        private IHttpHandler CreateErrorFormatter(HttpContext context)
        {
            // TODO: Maybe this should be configurable?

            Type type = Type.GetType(_errorFormatterClass);
            return Activator.CreateInstance(type) as IHttpHandler;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\mobileredirect.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileRedirect.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web; 
using System.Web.UI.MobileControls;

namespace System.Web.Mobile
{
    /*
     * Mobile Redirect
     * An internal helper class that provides methods to work around redirection issues with
     * mobile devices.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    
    internal class MobileRedirect 
    {
        internal static readonly String QueryStringVariable = "__redir";
        internal static readonly String QueryStringValue = "1";
        internal static readonly String QueryStringAssignment = QueryStringVariable + "=" + QueryStringValue;

        private static readonly String _redirectQueryString = "?" + QueryStringAssignment;
        private static readonly String _redirectQueryStringInline = QueryStringAssignment + "&";

        private static readonly String _disallowRedirectionKey = "_disallowRedirection";

        internal MobileRedirect() 
        {
        }

        internal static void AllowRedirection(HttpContext context)
        {
            context.Items.Remove(_disallowRedirectionKey);
        }

        internal static void DisallowRedirection(HttpContext context)
        {
            context.Items[_disallowRedirectionKey] = 1;
        }

        internal static void CheckForInvalidRedirection(HttpContext context)
        {
            HttpResponse response = context.Response;
            if (response != null && 
                    response.StatusCode == 302 && 
                    context.Items[_disallowRedirectionKey] != null)
            {
                response.ClearHeaders();
                throw new Exception(SR.GetString(SR.MobileRedirect_RedirectNotAllowed));
            }
        }

        internal static void RedirectToUrl(HttpContext context, String url, bool endResponse)
        {
            //do not add __redir=1 if it already exists
            int i = url.IndexOf(QueryStringAssignment);
            if(i == -1)
            {
                i = url.IndexOf('?');
                if (i >= 0)
                {
                    url = url.Insert(i + 1, _redirectQueryStringInline);
                }
                else
                {
                    url = String.Concat(url, _redirectQueryString);
                }
            }
            AllowRedirection(context);
            MobilePage page = context.Handler as MobilePage;
            
            if ( (page != null) && (!page.Device.SupportsRedirectWithCookie) )
            {
                String formsAuthCookieName = Security.FormsAuthentication.FormsCookieName;
                if(formsAuthCookieName != String.Empty)
                {
                    context.Response.Cookies.Remove(formsAuthCookieName);
                }
            } 
            context.Response.Redirect(url, endResponse);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\urlpath.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlPath.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * UrlPath class.
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */

using System.Text;
using System.Runtime.Serialization.Formatters;
using System.Runtime.InteropServices;
using System.Collections;
using System.Diagnostics;

namespace System.Web.Mobile
{
    /*
     * URL Path library.
     */

    internal class UrlPath
    {
        internal UrlPath() 
        {
        }

        internal static bool IsRooted(String basepath)
        {
            return(basepath == null || basepath.Length == 0 || basepath[0] == '/' || basepath[0] == '\\');
        }

        internal static bool IsRelativeUrl(string url)
        {
            // If it has a protocol, it's not relative
            if (url.IndexOf(":") != -1)
            {
                return false;
            }

            return !IsRooted(url);
        }

        internal static String GetDirectory(String path)
        {
            if (path == null || path.Length == 0)
            {
                throw new ArgumentException(SR.GetString(SR.UrlPath_EmptyPathHasNoDirectory));
            }

            if (path[0] != '/')
            {
                throw new ArgumentException(SR.GetString(SR.UrlPath_PathMustBeRooted));
            }

            // Make sure there is a filename after the last '/'
            Debug.Assert(path[path.Length-1] != '/', "Path should not end with a /");

            string dir = path.Substring(0, path.LastIndexOf('/'));

            // If it's the root dir, we would end up with "".  Return "/" instead
            if (dir.Length == 0)
            {
                return "/";
            }

            return dir;
        }

        private static void FailIfPhysicalPath(string path)
        {
            if (path == null || path.Length < 4)
            {
                return;
            }

            if (path[1] == ':' || (path[0] == '\\' && path[1] == '\\'))
            {
                throw new Exception(SR.GetString(SR.UrlPath_PhysicalPathNotAllowed, path));
            }
        }

        internal static String Combine(String basepath, String relative)
        {
            String path;

            // Make sure the relative path is not a physical path (bug 73641)
            FailIfPhysicalPath(relative);

            if (IsRooted(relative))
            {
                path = relative;
                if (path == null || path.Length == 0)
                {
                    return String.Empty;
                }
            }
            else
            {
                // If the relative path starts with "~/" or "~\", treat it as app root
                // relative (bug 68628)
                if (relative.Length >=3 && relative[0] == '~' && (relative[1] == '/' || relative[1] == '\\'))
                {
                    String appPath = HttpRuntime.AppDomainAppVirtualPath;
                    if (appPath.Length > 1)
                    {
                        path = appPath + "/" + relative.Substring(2);
                    }
                    else
                    {
                        path = "/" + relative.Substring(2);
                    }
                }
                else
                {
                    if (basepath == null || (basepath.Length == 1 && basepath[0] == '/'))
                    {
                        basepath = String.Empty;
                    }

                    path = basepath + "/" + relative;
                }
            }

            return Reduce(path);
        }

        internal static String Reduce(String path)
        {
            // ignore query string
            String queryString = null;
            if (path != null)
            {
                int iqs = path.IndexOf('?');
                if (iqs >= 0)
                {
                    queryString = path.Substring(iqs);
                    path = path.Substring(0, iqs);
                }
            }

            int length = path.Length;
            int examine;

            // Make sure we don't have any back slashes
            path = path.Replace('\\', '/');

            // quickly rule out situations in which there are no . or ..

            for (examine = 0; ; examine++)
            {
                examine = path.IndexOf('.', examine);
                if (examine < 0)
                {
                    return (queryString != null) ? (path + queryString) : path;
                }

                if ((examine == 0 || path[examine - 1] == '/')
                    && (examine + 1 == length || path[examine + 1] == '/' ||
                        (path[examine + 1] == '.' && (examine + 2 == length || path[examine + 2] == '/'))))
                {
                    break;
                }
            }

            // OK, we found a . or .. so process it:

            ArrayList list = new ArrayList();
            StringBuilder sb = new StringBuilder();
            int start;
            examine = 0;

            for (;;)
            {
                start = examine;
                examine = path.IndexOf('/', start + 1);

                if (examine < 0)
                {
                    examine = length;
                }

                if (examine - start <= 3 &&
                    (examine < 1 || path[examine - 1] == '.') &&
                    (start + 1 >= length || path[start + 1] == '.'))
                {
                    if (examine - start == 3)
                    {
                        if (list.Count == 0)
                        {
                            throw new Exception(SR.GetString(SR.UrlPath_CannotExitUpTopDirectory));
                        }

                        sb.Length = (int)list[list.Count - 1];
                        list.RemoveRange(list.Count - 1, 1);
                    }
                }
                else
                {
                    list.Add(sb.Length);

                    sb.Append(path, start, examine - start);
                }

                if (examine == length)
                {
                    break;
                }
            }

            return sb.ToString() + queryString;
        }

        private const string dummyProtocolAndServer = "http://foo";

        // Return the relative vpath path from one rooted vpath to another
        internal static string MakeRelative(string from, string to)
        {
            // Make sure both virtual paths are rooted
            Debug.Assert(IsRooted(from));
            Debug.Assert(IsRooted(to));

            // Uri's need full url's so, we use a dummy root
            Uri fromUri = new Uri(dummyProtocolAndServer + from);
            Uri toUri = new Uri(dummyProtocolAndServer + to);
            return fromUri.MakeRelative(toUri);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\arraylistcollectionbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrayListCollectionBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * ArrayListCollectionBase class. Used as a base class by all collections that
     * use an array list for its contents.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ArrayListCollectionBase : ICollection
    {
        private ArrayList _items;

        protected ArrayList Items
        {
            get
            {
                if (_items == null)
                {
                    _items = new ArrayList ();
                }
                return _items;
            }

            set
            {
                _items = value;
            }
        }

        internal ArrayListCollectionBase()
        {
        }

        internal ArrayListCollectionBase(ArrayList items)
        {
            _items = items;
        }

        public int Count
        {
            get
            {
                return Items.Count;
            }
        }

        public bool IsReadOnly
        {
            get
            {
                return Items.IsReadOnly;
            }
        }

        public bool IsSynchronized
        {
            get
            {
                return false;
            }
        }

        public Object SyncRoot 
        {
            get 
            {
                return this;
            }
        }

        public void CopyTo(Array array, int index) 
        {
            foreach (Object item in Items)
            {
                array.SetValue (item, index++);
            }
        }

        public IEnumerator GetEnumerator()
        {
            return Items.GetEnumerator ();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adrotator.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdRotator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.ComponentModel;
using System.Diagnostics;
using System.Drawing.Design;
using System.Web.Mobile;
using System.Web.UI.WebControls;
using System.Web.Util;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile AdRotator class.
     * The AdRotator control is for rotating advertisement links every time the
     * same page is revisited.
     *
     * This class aggregates the corresponding ASP.NET AdRotator for delegating
     * the random selection task of advertisement info to the aggregated
     * class.  The ad info is selected during the PreRender phase of the
     * aggregated control (So the aggregated control needs to have the
     * property Visible set to true when entering the PreRender process).
     * For markup adapters that collect the selected ad info for rendering,
     * they should subscribe to AdCreated event property and collect the ad
     * info through the event argument.
     *
     * This class also contains a mobile Image control for delegating the
     * rendering since AdRotator's rendering is the same as Image's rendering
     * by setting the corresponding properties on the control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DefaultEvent("AdCreated"),
        DefaultProperty("AdvertisementFile"),
        Designer(typeof(System.Web.UI.Design.MobileControls.AdRotatorDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerAdRotatorAdapter)),
        ToolboxData("<{0}:AdRotator runat=\"server\"></{0}:AdRotator>"),
        ToolboxItem(typeof(System.Web.UI.Design.WebControlToolboxItem))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class AdRotator : MobileControl
    {
        private WebCntrls.AdRotator _webAdRotator;
        private Image _image = new Image();

        private static readonly Object EventAdCreated = new Object();
        private const String ImageKeyDefault = "ImageUrl";
        private const String NavigateUrlKeyDefault = "NavigateUrl";

        public AdRotator() : base()
        {
            _webAdRotator = CreateWebAdRotator();

            _image.EnableViewState = false;

            this.Controls.Add(_webAdRotator);
            this.Controls.Add(_image);

            // The default value of the Target property of the web AdRotator is
            // set to "_top".  Since we are not exposing this property, we need
            // to explicity set it to empty string so this property will not be
            // shown in the rendered markup when the web AdRotator is used to do
            // the rendering.
            _webAdRotator.Target = String.Empty;

            // Due to the fact that C# compiler doesn't allow direct
            // manipulation of event properties outside of the class that
            // defines the event variable, the way we delegate the event
            // handlers to the aggregated web control is to provide a wrapper
            // to capture the raised event from the aggregated control and
            // apply the event argument to the event handlers subscribed to
            // this class.
            AdCreatedEventHandler adCreatedEventHandler =
                new AdCreatedEventHandler(WebAdCreated);

            _webAdRotator.AdCreated += adCreatedEventHandler;
        }

        protected virtual WebCntrls.AdRotator CreateWebAdRotator()
        {
            return new WebCntrls.AdRotator();
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original AdRotator.
        // The properties are got and set directly from the original AdRotator.
        ////////////////////////////////////////////////////////////////////////

        /// <summary>
        ///    <para>
        ///       Gets or sets the path to the XML file that contains advertisement data.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       The path to the XML file containing the properties of the advertisements to
        ///       render in the <see langword='AdRotator'/>.
        ///    </para>
        /// </value>
        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Web.UI.Design.XmlUrlEditor), typeof(UITypeEditor)),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.AdRotator_AdvertisementFile)
        ]
        public String AdvertisementFile
        {
            get
            {
                return _webAdRotator.AdvertisementFile;
            }
            set
            {
                _webAdRotator.AdvertisementFile = value;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets a keyword used to match related advertisements in the ad file.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       The keyword used to identify advertisements within a specific catagory.
        ///    </para>
        /// </value>
        /// <remarks>
        ///    <para>
        ///       If the ad source is AdvertisementFile and this property is not empty, an ad
        ///       with a matching keyword will be selected.
        ///    </para>
        ///    <para>
        ///       If the ad source is AdvertisementFile and this property set, but no match
        ///       exists, a blank image is displayed and a trace warning is generated.
        ///    </para>
        ///    If this property is not set, keyword filtering is not used to select an ad.
        /// </remarks>
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.AdRotator_KeywordFilter)
        ]
        public String KeywordFilter
        {
            get
            {
                return _webAdRotator.KeywordFilter;
            }
            set
            {
                _webAdRotator.KeywordFilter = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(ImageKeyDefault),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.AdRotator_ImageKey)
        ]
        public String ImageKey
        {
            get
            {
                String s = (String) ViewState["ImageKey"];
                return((s != null) ? s : ImageKeyDefault);
            }
            set
            {
                ViewState["ImageKey"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(NavigateUrlKeyDefault),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.AdRotator_NavigateUrlKey)
        ]
        public String NavigateUrlKey
        {
            get
            {
                String s = (String) ViewState["NavigateUrlKey"];
                return((s != null) ? s : NavigateUrlKeyDefault);
            }
            set
            {
                ViewState["NavigateUrlKey"] = value;
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.AdRotator_AdCreated)
        ]
        public event AdCreatedEventHandler AdCreated
        {
            add
            {
                Events.AddHandler(EventAdCreated, value);
            }
            remove
            {
                Events.RemoveHandler(EventAdCreated, value);
            }
        }

        // protected method (which can be overridden by subclasses) for
        // raising user events
        protected virtual void OnAdCreated(AdCreatedEventArgs e)
        {
            AdCreatedEventHandler handler = (AdCreatedEventHandler)Events[EventAdCreated];
            if (handler != null)
            {
                handler(this, e);
            }
        }

        protected override void Render(HtmlTextWriter writer)
        {
            const String accesskeyName = "accesskey";

            // Delegate specific custom attribute to the child Image control
            String accesskey = ((IAttributeAccessor) this).GetAttribute(accesskeyName);
            if (accesskey != null && accesskey != String.Empty)
            {
                _image.CustomAttributes[accesskeyName] = accesskey;
            }

            _image.RenderControl(writer);
        }

        private void WebAdCreated(Object sender, AdCreatedEventArgs e)
        {
            // Override the value since it may have been changed by device
            // select

            // AdProperties can be null when ad file is not specified
            // correctly.
            if (e.AdProperties != null)
            {
                e.ImageUrl = (String) e.AdProperties[ImageKey];
                e.NavigateUrl = (String) e.AdProperties[NavigateUrlKey];
            }

            // Then invoke user events for further manipulation specified by
            // user
            OnAdCreated(e);

            // Finally, set the necessary properties to the base Image class
            _image.ImageUrl = ResolveAdRotatorUrl(e.ImageUrl);
            _image.AlternateText = e.AlternateText;
            _image.NavigateUrl = ResolveAdRotatorUrl(e.NavigateUrl);
        }

        // Helper function adopted from ASP.NET AdRotator class (modified
        // slightly)
        private String ResolveAdRotatorUrl(String relativeUrl)
        {
            if (relativeUrl == null)
            {
                return String.Empty;
            }

            // check if it is already absolute, or points to another form
            if (!UrlPath.IsRelativeUrl(relativeUrl) ||
                relativeUrl.StartsWith(Constants.FormIDPrefix))
            {
                return relativeUrl;
            }

            // For the AdRotator, use the AdvertisementFile directory as the
            // base, and fall back to the page/user control location as the
            // base.
            String absoluteFile = UrlPath.Combine(TemplateSourceDirectory,
                                                  AdvertisementFile);
            String fileDirectory = UrlPath.GetDirectory(absoluteFile);

            String baseUrl = String.Empty;
            if (fileDirectory != null)
            {
                baseUrl = fileDirectory;
            }
            if (baseUrl.Length == 0)
            {
                baseUrl = TemplateSourceDirectory;
            }
            if (baseUrl.Length == 0)
            {
                return relativeUrl;
            }

            // make it absolute
            return UrlPath.Combine(baseUrl, relativeUrl);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\basevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Diagnostics;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile BaseValidator class.
     * The BaseValidator class provides a core implementation common to all
     * specific validator controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultProperty("ErrorMessage"),
        Designer(typeof(System.Web.UI.Design.MobileControls.BaseValidatorDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerValidatorAdapter)),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class BaseValidator : TextControl, IValidator
    {
        private WebCntrls.BaseValidator _webBaseValidator;
        private bool _isValid = true;

        protected BaseValidator()
        {
            StyleReference = Constants.ErrorStyle;

            _webBaseValidator = CreateWebValidator();
            if (_webBaseValidator == null)
            {
                // Create a default web base validator, mainly for storing
                // property values.
                _webBaseValidator = new DefaultWebValidator();
            }

            Controls.Add(_webBaseValidator);

            // Currently by default we render error message in a dynamic way.
            _webBaseValidator.Display = ValidatorDisplay.Dynamic;
        }

        public override int VisibleWeight
        {
            get
            {
                return 0;   // validators are not generally visible
            }
        }

        /// <summary>
        ///    <para>
        ///       Virtual method for subclass to create its own aggregated
        ///       web validator.  The web validator is for getting and
        ///       setting of the common properties of web base validator.
        ///    </para>
        /// </summary>
        protected virtual WebCntrls.BaseValidator CreateWebValidator()
        {
            return null;
        }


        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original BaseValidator.
        ////////////////////////////////////////////////////////////////////////

        [
            Browsable(false),
            DefaultValue(true),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool IsValid
        {
            // Not getting and setting to the corresponding property in the
            // WebForm Base Validator is to differentiate the valid state for
            // Mobile Validator as Mobile Page can have multiple forms where the
            // Mobile Validator is invalid only when the same form is post back.
            //
            // Also, this property shouldn't be persisted in ViewState[] because
            // error message will show up when the form that contains the
            // validator is revisited again and the validator's state should
            // be reset to true as default.  Same implementation is done in
            // WebForm BaseValidator.
            // e.g. Form1 contains a Validator and a TextBox and a Command to
            // Form2 which contains a ValidationSummary.  After a user enters
            // an invalid value and click Command, ValidationSummary will
            // list the error message and provide a link back to Form1.
            // If IsValid property is persisted via ViewState[], Form1 will show
            // error message since IsValid is false and persisted, while the
            // expected behavior is the validator's state on Form1 is reset
            // to true so no error message will be shown.
            get
            {
                return _isValid;
            }
            set
            {
                _isValid = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.BaseValidator_ErrorMessage)
        ]
        public String ErrorMessage
        {
            get
            {
                return _webBaseValidator.ErrorMessage;
            }
            set
            {
                _webBaseValidator.ErrorMessage = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.BaseValidator_ControlToValidate),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.ValidatedMobileControlConverter))
        ]
        public String ControlToValidate
        {
            get
            {
                return _webBaseValidator.ControlToValidate;
            }
            set
            {
                _webBaseValidator.ControlToValidate = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(ValidatorDisplay.Dynamic),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.BaseValidator_Display)
        ]
        public ValidatorDisplay Display
        {
            get
            {
                return _webBaseValidator.Display;
            }
            set
            {
                _webBaseValidator.Display = value;
            }
        }

        // Designer needs to know the correct default value in order to persist it correctly.
        [
            DefaultValue(Constants.ErrorStyle)
        ]
        public override String StyleReference
        {
            get
            {
                return base.StyleReference;
            }
            set
            {
                base.StyleReference = value;
            }
        }

        protected override void OnInit(EventArgs e)
        {
            // Add itself to the Validator list so the Validate() function
            // will be called to validate control
            Page.Validators.Add(this);
            base.OnInit(e);
        }

        protected override void OnPreRender(EventArgs e)
        {
            if(this.Form == MobilePage.ActiveForm)
            {
                bool isValid = ControlPropertiesValid();
                Debug.Assert(isValid,
                    "Exception should have been thrown instead of returning false!");
            }
            base.OnPreRender(e);
        }

        // Common code shared by other validators in the same assembly
        internal bool EvaluateIsValidInternal()
        {
            // At this point all validator's related info should have been
            // redirected to the aggregated Web Validator.  Simply apply the
            // validation logic in the Web Validator to determine if the
            // checked control is valid.

            String idBuffer;

            try
            {
                _webBaseValidator.Validate();
            }
            catch(Exception)
            {
                // Swap IDs with aggregate validator so that is Validate() throws
                // a meaningful ID is included in the exception message.
                idBuffer = ID;
                ID = _webBaseValidator.ID;
                _webBaseValidator.ID = idBuffer;
                
                try
                {
                    _webBaseValidator.Validate();
                }
                finally
                {
                    idBuffer = ID;
                    ID = _webBaseValidator.ID;
                    _webBaseValidator.ID = idBuffer;
                }

                // If the exception does not repro with swapped ID, just re-throw it.
                throw;
            }

            return _webBaseValidator.IsValid;
        }

        // Subclass should provide its own logic for validation
        protected abstract bool EvaluateIsValid();

        public void Validate()
        {
            if (!Visible)
            {
                IsValid = true;
                return;
            }

            // See if we are in an invisible container
            Control parent = Parent;
            while (parent != null)
            {
                if (!parent.Visible)
                {
                    IsValid = true;
                    return;
                }
                parent = parent.Parent;
            }

            IsValid = EvaluateIsValid();
        }

        /////////////////////////////////////////////////////////////////////
        // Helper functions adopted from WebForms base validator
        /////////////////////////////////////////////////////////////////////

        protected virtual bool ControlPropertiesValid()
        {
            // Check for blank control to validate
            String controlToValidate = ControlToValidate;
            if (controlToValidate.Length == 0)
            {
                throw new ArgumentException(SR.GetString(
                    SR.BaseValidator_ControlToValidateBlank, ID));
            }

            // Check that the property points to a valid control.
            // Will throw an exception if not found
            CheckControlValidationProperty(controlToValidate, "ControlToValidate");
            return true;
        }

        protected void CheckControlValidationProperty(String name, String propertyName)
        {
            // Get the control using the relative name
            Control control = NamingContainer.FindControl(name);
            if (control == null)
            {
                throw new ArgumentException(SR.GetString(
                    SR.BaseValidator_ControlNotFound, name, propertyName, ID));
            }

            // Get its validation property
            PropertyDescriptor prop = WebCntrls.BaseValidator.GetValidationProperty(control);
            if (prop == null)
            {
                throw new ArgumentException(SR.GetString(
                    SR.BaseValidator_BadControlType, name, propertyName, ID));
            }
        }

        private class DefaultWebValidator : WebCntrls.BaseValidator
        {
            protected override bool EvaluateIsValid()
            {
                Debug.Assert(false, "Should never be called.");
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\calendar.cs ===
//------------------------------------------------------------------------------
// <copyright file="Calendar.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile Calendar class.
     * The Calendar control allows developers to easily add date picking
     * functionality to a Mobile application.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler(typeof(System.Web.UI.Design.MobileControls.CalendarDataBindingHandler)),
        DefaultEvent("SelectionChanged"),
        DefaultProperty("SelectedDate"),
        Designer(typeof(System.Web.UI.Design.MobileControls.CalendarDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerCalendarAdapter)),
        ToolboxData("<{0}:Calendar runat=\"server\"></{0}:Calendar>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Calendar : MobileControl, IPostBackEventHandler
    {
        private WebCntrls.Calendar _webCalendar;

        // Static objects to identify individual events stored in Events
        // property.
        private static readonly Object EventSelectionChanged = new Object();

        public Calendar() : base()
        {
            _webCalendar = CreateWebCalendar();
            _webCalendar.Visible = false;
            Controls.Add(_webCalendar);

            // Adding wrapper event handlers for event properties exposed by
            // the aggregated control.  For more details about the mechanism,
            // please see the comment in the constructor of
            // Mobile.UI.AdRotator.
            EventHandler eventHandler =
                new EventHandler(WebSelectionChanged);

            _webCalendar.SelectionChanged += eventHandler;
        }

        protected virtual WebCntrls.Calendar CreateWebCalendar()
        {
            return new WebCntrls.Calendar();
        }

        /////////////////////////////////////////////////////////////////////
        // Mimic some of the properties exposed in the original Web Calendar
        // control.  Only those properties that are meaningful and useful to
        // mobile device adapters are exposed.  Other properties, which are
        // used mostly for the complex HTML specific rendering (like the one
        // rendered by WebForms Calendar), can be set via the property that
        // exposed the aggregated WebForms Calendar directly.
        // 
        // Most properties are got and set directly from the original Calendar
        // control.  For event properties, event references are stored locally
        // as they cannot be returned from the aggregated child control.
        /////////////////////////////////////////////////////////////////////

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public WebCntrls.Calendar WebCalendar
        {
            get
            {
                return _webCalendar;
            }
        }

        [
            Bindable(true),
            DefaultValue(FirstDayOfWeek.Default),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Calendar_FirstDayOfWeek)
        ]
        public FirstDayOfWeek FirstDayOfWeek
        {
            get
            {
                return _webCalendar.FirstDayOfWeek;
            }
            set
            {
                _webCalendar.FirstDayOfWeek = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(typeof(DateTime), "1/1/0001"),
            MobileSysDescription(SR.Calendar_SelectedDate)
        ]
        public DateTime SelectedDate
        {
            get
            {
                return _webCalendar.SelectedDate;
            }
            set
            {
                _webCalendar.SelectedDate = value;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]   
        public SelectedDatesCollection SelectedDates
        {
            get
            {
                return _webCalendar.SelectedDates;
            }
        }

        [
            Bindable(true),
            DefaultValue(CalendarSelectionMode.Day),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Calendar_SelectionMode)
        ]
        public CalendarSelectionMode SelectionMode
        {
            get
            {
                return _webCalendar.SelectionMode;
            }
            set
            {
                _webCalendar.SelectionMode = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(true),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Calendar_ShowDayHeader)
        ]
        public bool ShowDayHeader
        {
            get
            {
                return _webCalendar.ShowDayHeader;
            }
            set
            {
                _webCalendar.ShowDayHeader = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(typeof(DateTime), "1/1/0001"),
            MobileSysDescription(SR.Calendar_VisibleDate)
        ]
        public DateTime VisibleDate
        {
            get
            {
                return _webCalendar.VisibleDate;
            }
            set
            {
                _webCalendar.VisibleDate = value;
            }
        } 

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Calendar_CalendarEntryText)
        ]
        public String CalendarEntryText
        {
            get
            {
                String s = (String) ViewState["CalendarEntryText"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["CalendarEntryText"] = value;
            }
        }

        /////////////////////////////////////////////////////////////////////
        //  BEGIN STYLE PROPERTIES
        /////////////////////////////////////////////////////////////////////


        /////////////////////////////////////////////////////////////////////
        //  END STYLE PROPERTIES
        /////////////////////////////////////////////////////////////////////

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.Calendar_OnSelectionChanged)
        ]
        public event EventHandler SelectionChanged
        {
            add
            {
                Events.AddHandler(EventSelectionChanged, value);
            }
            remove
            {
                Events.RemoveHandler(EventSelectionChanged, value);
            }
        }

        // protected method (which can be overridden by subclasses) for
        // raising user events
        protected virtual void OnSelectionChanged()
        {
            EventHandler handler = (EventHandler)Events[EventSelectionChanged];
            if (handler != null)
            {
                handler(this, new EventArgs());
            }
        }

        private void WebSelectionChanged(Object sender, EventArgs e)
        {
            // Invoke user events for further manipulation specified by user
            OnSelectionChanged();
        }

        void IPostBackEventHandler.RaisePostBackEvent(String eventArgument)
        {
            // There can be cases that the original form is
            // involved in the generation of multiple cards in the same WML
            // deck.  Here is to reset the right active form.
            if (MobilePage.ActiveForm != Form)
            {
                MobilePage.ActiveForm = Form;
            }

            Adapter.HandlePostBackEvent(eventArgument);
        }

        // A wrapper to raise the SelectionChangedEvent when a date is selected
        // by the user.  This can be called by different adapters when they have
        // collected the selected date.
        public void RaiseSelectionChangedEvent()
        {
            WebSelectionChanged(this, new EventArgs());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\command.cs ===
//------------------------------------------------------------------------------
// <copyright file="Command.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile Command class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultEvent("Click"),
        DefaultProperty("Text"),
        Designer(typeof(System.Web.UI.Design.MobileControls.CommandDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerCommandAdapter)),
        ToolboxData("<{0}:Command runat=\"server\">Command</{0}:Command>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Command : TextControl, IPostBackEventHandler, IPostBackDataHandler
    {
        private static readonly Object EventClick = new Object ();
        private static readonly Object EventItemCommand = new Object ();

        protected override void OnPreRender(EventArgs e) 
        {
            base.OnPreRender(e);
            // If this control will be rendered as an image
            if (MobilePage != null
                && ImageUrl != String.Empty
                && MobilePage.Device.SupportsImageSubmit)
            {
                // HTML input controls of type image postback as name.x and
                // name.y which is not associated with this control by default
                // in Page.ProcessPostData().
                MobilePage.RegisterRequiresPostBack(this);
            }
        }
        
        bool IPostBackDataHandler.LoadPostData(String key, NameValueCollection data)
        {
            bool dataChanged;
            bool handledByAdapter =
                Adapter.LoadPostData(key, data, null, out dataChanged);

            // If the adapter handled the post back and set dataChanged this
            // was an image button (responds with ID.x and ID.y).
            if (handledByAdapter)
            {
                if(dataChanged)
                {
                    Page.RegisterRequiresRaiseEvent(this);
                }
            }
            // Otherwise if the adapter did not handle the past back, use
            // the same method as Page.ProcessPostData().
            else if(data[key] != null)
            {
                Page.RegisterRequiresRaiseEvent(this);
            }
            return false;  // no need to raise PostDataChangedEvent.
        }

        void IPostBackDataHandler.RaisePostDataChangedEvent()
        {
        }
        
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Command_SoftkeyLabel)
        ]
        public String SoftkeyLabel
        {
            get
            {
                String s = (String) ViewState["Softkeylabel"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["Softkeylabel"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Command_CommandName)
        ]
        public String CommandName
        {
            get
            {
                String s = (String) ViewState["CommandName"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["CommandName"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Command_CommandArgument)
        ]
        public String CommandArgument
        {
            get
            {
                String s = (String) ViewState["CommandArgument"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["CommandArgument"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Web.UI.Design.MobileControls.ImageUrlEditor),
                   typeof(UITypeEditor)),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Image_ImageUrl)
        ]
        public String ImageUrl
        {
            get
            {
                String s = (String) ViewState["ImageUrl"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["ImageUrl"] = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(true),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Command_CausesValidation)
        ]
        public bool CausesValidation
        {
            get
            {
                object b = ViewState["CausesValidation"];
                return((b == null) ? true : (bool)b);
            }
            set
            {
                ViewState["CausesValidation"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(CommandFormat.Button),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Command_Format)
        ]
        public CommandFormat Format
        {
            get
            {
                Object o = ViewState["Format"];
                return((o == null) ? CommandFormat.Button : (CommandFormat)o);
            }
            set
            {
                ViewState["Format"] = value;
            }
        }

        protected virtual void OnClick(EventArgs e)
        {
            EventHandler onClickHandler = (EventHandler)Events[EventClick];
            if (onClickHandler != null)
            {
                onClickHandler(this,e);
            }
        }
        
        protected virtual void OnItemCommand(CommandEventArgs e)
        {
            CommandEventHandler onItemCommandHandler = (CommandEventHandler)Events[EventItemCommand];
            if (onItemCommandHandler != null)
            {
                onItemCommandHandler(this,e);
            }

            RaiseBubbleEvent (this, e);
        }

        [        
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.Command_OnClick)
        ]
        public event EventHandler Click
        {
            add 
            {
                Events.AddHandler(EventClick, value);
            }
            remove 
            {
                Events.RemoveHandler(EventClick, value);
            }
        }

        [        
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.Command_OnItemCommand)
        ]
        public event CommandEventHandler ItemCommand
        {
            add 
            {
                Events.AddHandler(EventItemCommand, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemCommand, value);
            }
        }

        void IPostBackEventHandler.RaisePostBackEvent(String argument)
        {
            if (CausesValidation)
            {
                MobilePage.Validate();
            }

            // It is legitimate to reset the form back to the first page
            // after a form submit.
            Form.CurrentPage = 1;

            OnClick (EventArgs.Empty);
            OnItemCommand (new CommandEventArgs(CommandName, CommandArgument));
        }

        protected override bool IsFormSubmitControl()
        {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\compileliteraltextparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompileLiteralTextParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Web.UI;

namespace System.Web.UI.MobileControls
{
    /*
     * CompileLiteralTextParser class.
     *
     * This is a specialized version of the LiteralTextParser class.
     * It creates a set of control builders from the parsed literal text.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal class CompileLiteralTextParser : LiteralTextParser
    {
        TemplateParser _parser;
        ControlBuilder _parentBuilder;
        String _fileName;
        int _lineNumber;
        IList _tagInnerTextElements = null;

        internal CompileLiteralTextParser(TemplateParser parser, 
                                        ControlBuilder parentBuilder, 
                                        String fileName, 
                                        int lineNumber)
        {
            _parser = parser;
            _parentBuilder = parentBuilder;
            _fileName = fileName;
            _lineNumber = lineNumber;
        }

        protected override void ProcessElement(LiteralElement element)
        {
            ControlBuilder subBuilder;

            switch (element.Type)
            {
                case LiteralElementType.Text:
                    Debug.Assert(_tagInnerTextElements == null);
                    subBuilder = ControlBuilder.CreateBuilderFromType(
                                        _parser, _parentBuilder,
                                        typeof(LiteralText), typeof(LiteralText).Name,
                                        null, 
                                        GetPropertyDictionary(element.Format, element.BreakAfter, null),
                                        _lineNumber, _fileName);
                    break;

                case LiteralElementType.Anchor:
                {
                    String linkUrl = (String)element.GetAttribute("href");
                    subBuilder = ControlBuilder.CreateBuilderFromType(
                                        _parser, _parentBuilder,
                                        typeof(LiteralLink), typeof(LiteralLink).Name,
                                        null, 
                                        GetPropertyDictionary(element.Format, element.BreakAfter, linkUrl),
                                        _lineNumber, _fileName);
                    AddTagInnerTextElements(subBuilder);
                    break;
                }

                default:
                    return;
            }

            _parentBuilder.AppendSubBuilder(subBuilder);

            if (element.Text != String.Empty)
            {
                subBuilder.AppendLiteralString(element.Text);
            }
        }

        private IList TagInnerTextElements
        {
            get
            {
                if (_tagInnerTextElements == null)
                {
                    _tagInnerTextElements = new ArrayList();
                }
                return _tagInnerTextElements;
            }
        }

        private void AddTagInnerTextElements(ControlBuilder builder)
        {
            if (_tagInnerTextElements != null)
            {
                foreach(Object o in _tagInnerTextElements)
                {
                    if (o is String)
                    {
                        builder.AppendLiteralString((String)o);
                    }
                    else
                    {
                        builder.AppendSubBuilder((ControlBuilder)o);
                    }
                }
                _tagInnerTextElements = null;
            }
        }

        protected override void ProcessTagInnerText(String text)
        {
            // Called to add an inner text segment of a multi-segment tag, e.g.
            //      <a ...>some text <%# a databinding %> some more text</a>

            TagInnerTextElements.Add(text);
        }

        internal /*public*/ void AddDataBinding(ControlBuilder builder)
        {
            if (IsInTag)
            {
                TagInnerTextElements.Add(builder);
            }
            else
            {
                ControlBuilder newBuilder = ControlBuilder.CreateBuilderFromType(
                                              _parser, _parentBuilder,
                                              typeof(LiteralText), typeof(LiteralText).Name,
                                            null, 
                                            GetPropertyDictionary(CurrentFormat, false, null),
                                            _lineNumber, _fileName);
                _parentBuilder.AppendSubBuilder(newBuilder);
                newBuilder.AppendSubBuilder(builder);
                OnAfterDataBoundLiteral();
            }
        }

        // Convert formatting and other options into a set of properties, just as if they had been
        // specified in persistence format.

        private ListDictionary GetPropertyDictionary(LiteralFormat format, bool breakAfter, String linkUrl)
        {
            ListDictionary dictionary = null;
            if (format != LiteralFormat.None || !breakAfter || linkUrl != null)
            {
                dictionary = new ListDictionary();
                if ((format & LiteralFormat.Bold) == LiteralFormat.Bold)
                {
                    dictionary.Add("Font-Bold", "True");
                }
                if ((format & LiteralFormat.Italic) == LiteralFormat.Italic)
                {
                    dictionary.Add("Font-Italic", "True");
                }
                if(!breakAfter)
                {
                    dictionary.Add("BreakAfter", "False");
                }
                if (linkUrl != null)
                {
                    dictionary.Add("NavigateUrl", linkUrl);
                }
            }

            return dictionary;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\comparevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompareValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Globalization;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile CompareValidator class.
     * The CompareValidator compares the value of the associated input control
     * with a constant value or another input control.  A data type property
     * specifies how the values being compared should be interpreted: strings,
     * integers, dates, etc.  A comparison operator specifies the nature of the
     * comparison; greater than, less than, etc.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ToolboxData("<{0}:CompareValidator runat=\"server\" ErrorMessage=\"CompareValidator\"></{0}:CompareValidator>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CompareValidator : BaseValidator
    {
        private WebCntrls.CompareValidator _webCompareValidator;

        protected override WebCntrls.BaseValidator CreateWebValidator()
        {
            _webCompareValidator = new WebCntrls.CompareValidator();
            return _webCompareValidator;
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original CompareValidator.
        // The properties are got and set directly from the original CompareValidator.
        ////////////////////////////////////////////////////////////////////////

        [
            Bindable(false),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.CompareValidator_ControlToCompare),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.ValidatedMobileControlConverter))
        ]
        public String ControlToCompare
        {
            get
            {
                return _webCompareValidator.ControlToCompare;
            }
            set
            {
                _webCompareValidator.ControlToCompare = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(ValidationCompareOperator.Equal),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.CompareValidator_Operator)
        ]
        public ValidationCompareOperator Operator
        {
            get
            {
                return _webCompareValidator.Operator;
            }
            set
            {
                _webCompareValidator.Operator = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(ValidationDataType.String),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.CompareValidator_Type)
        ]
        public ValidationDataType Type
        {
            get
            {
                return _webCompareValidator.Type;
            }
            set
            {
                _webCompareValidator.Type = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.CompareValidator_ValueToCompare)
        ]
        public String ValueToCompare
        {
            get
            {
                return _webCompareValidator.ValueToCompare;
            }
            set
            {
                _webCompareValidator.ValueToCompare = value;
            }
        }

        protected override bool EvaluateIsValid()
        {
            return EvaluateIsValidInternal();
        }

        /////////////////////////////////////////////////////////////////////
        // Helper function adopted from WebForms CompareValidator
        /////////////////////////////////////////////////////////////////////

        protected override bool ControlPropertiesValid()
        {
            // Check the control id references 
            if (ControlToCompare.Length > 0)
            {
                CheckControlValidationProperty(ControlToCompare, "ControlToCompare");
                if (String.Compare(ControlToValidate, ControlToCompare, true, CultureInfo.InvariantCulture) == 0)
                {
                    throw new ArgumentException(SR.GetString(
                        SR.CompareValidator_BadCompareControl, ID, ControlToCompare));
                }
            }   
            else
            {
                // Check Values
                if (Operator != ValidationCompareOperator.DataTypeCheck && 
                    !WebCntrls.BaseCompareValidator.CanConvert(ValueToCompare, Type))
                {
                    throw new ArgumentException(SR.GetString(
                        SR.Validator_ValueBadType,
                        ValueToCompare,
                        "ValueToCompare",
                        ID,
                        PropertyConverter.EnumToString(
                            typeof(ValidationDataType), Type)
                    ));
                }
            }
            return base.ControlPropertiesValid();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\mobile\mobilecapabilities.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileCapabilities.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.Mobile
{
    using System.Web;
    using System.Collections;
    using System.Reflection;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.Globalization;
    using System.Security.Permissions;

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileCapabilities : HttpBrowserCapabilities
    {
        internal delegate bool EvaluateCapabilitiesDelegate(MobileCapabilities capabilities,
            String evalParameter);

        private Hashtable _evaluatorResults = Hashtable.Synchronized(new Hashtable());

        private const String _kDeviceFiltersConfig = "system.web/deviceFilters";

        private DeviceFilterDictionary GetCurrentFilters()
        {
            return (DeviceFilterDictionary)
                HttpContext.Current.GetConfig(_kDeviceFiltersConfig);
        }

        private bool HasComparisonEvaluator(String evaluatorName, out bool result)
        {
            result = false;
            String evaluator;
            String argument;

            DeviceFilterDictionary currentFilters = GetCurrentFilters();
            if(currentFilters == null)
            {
                return false;
            }

            if(!currentFilters.FindComparisonEvaluator(evaluatorName, out evaluator, out argument))
            {
                return false;
            }

            result = HasCapability(evaluator, argument);

            return true;
        }


        private bool HasDelegatedEvaluator(String evaluatorName, String parameter,
            out bool result)
        {
            result = false;
            EvaluateCapabilitiesDelegate evaluator;

            DeviceFilterDictionary currentFilters = GetCurrentFilters();
            if(currentFilters == null)
            {
                return false;
            }

            if(!currentFilters.FindDelegateEvaluator(evaluatorName, out evaluator))
            {
                return false;
            }

            result = evaluator(this, parameter);

            return true;
        }


        private bool HasItem(String evaluatorName, String parameter,
            out bool result)
        {
            result = false;
            String item;

            item = this[evaluatorName];
            if(item == null)
            {
                return false;
            }

            result = (item == parameter);
            return true;
        }


        private bool HasProperty(String evaluatorName, String parameter,
            out bool result)
        {
            result = false;
            String propertyValue = null;
            PropertyDescriptor propertyDescriptor =
                TypeDescriptor.GetProperties(this)[evaluatorName];
            if(propertyDescriptor == null)
            {
                return false;
            }

            propertyValue = propertyDescriptor.GetValue(this).ToString();

            if(propertyDescriptor.PropertyType == typeof(bool) && parameter != null)
            {
                propertyValue = propertyValue.ToLower(CultureInfo.InvariantCulture);
                parameter = parameter.ToLower(CultureInfo.InvariantCulture);
            }

            result = (propertyValue == parameter);

            return true;
        }


        private bool IsComparisonEvaluator(String evaluatorName)
        {
            DeviceFilterDictionary currentFilters = GetCurrentFilters();

            if(currentFilters == null)
            {
                return false;
            }
            else
            {
                return currentFilters.IsComparisonEvaluator(evaluatorName) &&
                    !currentFilters.IsDelegateEvaluator(evaluatorName);
            }
        }


        public bool HasCapability(String delegateName, String optionalParameter)
        {   
            bool result;
            bool resultFound;

            if(null == delegateName || delegateName == String.Empty)
            {
                throw new ArgumentException(SR.GetString(SR.MobCap_DelegateNameNoValue),
                                            "delegateName");
            }

            // Check for cached results

            DeviceFilterDictionary currentFilters = GetCurrentFilters();
            String hashKey = ((currentFilters == null) ? "null" : currentFilters.GetHashCode().ToString())
                + delegateName;

            if(optionalParameter != null && !IsComparisonEvaluator(delegateName))
            {
                hashKey += optionalParameter;
            }

            if(_evaluatorResults.Contains(hashKey))
            {
                return (bool)_evaluatorResults[hashKey];
            }

            // Note: The fact that delegate evaluators are checked before comparison evaluators
            // determines the implementation of IsComparisonEvaluator above.

            resultFound = HasDelegatedEvaluator(delegateName, optionalParameter, out result);

            if(!resultFound)
            {
                resultFound = HasComparisonEvaluator(delegateName, out result);

                if(!resultFound)
                {
                    resultFound = HasProperty(delegateName, optionalParameter, out result);

                    if(!resultFound)
                    {
                        resultFound = HasItem(delegateName, optionalParameter, out result);
                    }
                }
            }

            if(resultFound)
            {
                _evaluatorResults.Add(hashKey, result);
            }
            else
            {
                throw new ArgumentOutOfRangeException(
                    "delegateName",
                    SR.GetString(SR.MobCap_CantFindCapability, delegateName));
            }

            return result;
        }


        public virtual String MobileDeviceManufacturer
        {
            get
            {
                if(!_haveMobileDeviceManufacturer)
                {
                    _mobileDeviceManufacturer = this["mobileDeviceManufacturer"];
                    _haveMobileDeviceManufacturer = true;
                }
                return _mobileDeviceManufacturer;
            }
        }


        public virtual String MobileDeviceModel
        {
            get
            {
                if(!_haveMobileDeviceModel)
                {
                    _mobileDeviceModel = this["mobileDeviceModel"];
                    _haveMobileDeviceModel = true;
                }
                return _mobileDeviceModel;
            }
        }


        public virtual String GatewayVersion
        {
            get
            {
                if(!_haveGatewayVersion)
                {
                    _gatewayVersion = this["gatewayVersion"];
                    _haveGatewayVersion = true;
                }
                return _gatewayVersion;
            }
        }


        public virtual int GatewayMajorVersion
        {
            get
            {
                if(!_haveGatewayMajorVersion)
                {
                    _gatewayMajorVersion = Convert.ToInt32(this["gatewayMajorVersion"]);
                    _haveGatewayMajorVersion = true;
                }
                return _gatewayMajorVersion;
            }
        }


        public virtual double GatewayMinorVersion
        {
            get
            {
                if(!_haveGatewayMinorVersion)
                {
                    // The conversion below does not use Convert.ToDouble()  
                    // because it depends on the current locale.  So a german machine it would look for 
                    // a comma as a seperator "1,5" where all user-agent strings use english
                    // decimal points "1.5".  URT11176
                    // 
                    _gatewayMinorVersion = double.Parse(
                                        this["gatewayMinorVersion"], 
                                        NumberStyles.Float | NumberStyles.AllowDecimalPoint, 
                                        NumberFormatInfo.InvariantInfo);
                    _haveGatewayMinorVersion = true;
                }
                return _gatewayMinorVersion;
            }
        }

        public static readonly String PreferredRenderingTypeHtml32 = "html32";
        public static readonly String PreferredRenderingTypeWml11 = "wml11";
        public static readonly String PreferredRenderingTypeWml12 = "wml12";
        public static readonly String PreferredRenderingTypeChtml10 = "chtml10";

        public virtual String PreferredRenderingType
        {
            get
            {
                if(!_havePreferredRenderingType)
                {
                    _preferredRenderingType = this["preferredRenderingType"];
                    _havePreferredRenderingType = true;
                }
                return _preferredRenderingType;
            }
        }

        public virtual String PreferredRenderingMime
        {
            get
            {
                if(!_havePreferredRenderingMime)
                {
                    _preferredRenderingMime = this["preferredRenderingMime"];
                    _havePreferredRenderingMime = true;
                }
                return _preferredRenderingMime;
            }
        }


        public virtual String PreferredImageMime
        {
            get
            {
                if(!_havePreferredImageMime)
                {
                    _preferredImageMime = this["preferredImageMime"];
                    _havePreferredImageMime = true;
                }
                return _preferredImageMime;
            }
        }


        public virtual int ScreenCharactersWidth
        {
            get
            {
                if(!_haveScreenCharactersWidth)
                {
                    if(this["screenCharactersWidth"] == null)
                    {
                        // calculate from best partial information

                        int screenPixelsWidthToUse = 640;
                        int characterWidthToUse = 8;

                        if(this["screenPixelsWidth"] != null && this["characterWidth"] != null)
                        {
                            screenPixelsWidthToUse = Convert.ToInt32(this["screenPixelsWidth"]);
                            characterWidthToUse = Convert.ToInt32(this["characterWidth"]);
                        }
                        else if(this["screenPixelsWidth"] != null)
                        {
                            screenPixelsWidthToUse = Convert.ToInt32(this["screenPixelsWidth"]);
                            characterWidthToUse = Convert.ToInt32(this["defaultCharacterWidth"]);
                        }
                        else if(this["characterWidth"] != null)
                        {
                            screenPixelsWidthToUse = Convert.ToInt32(this["defaultScreenPixelsWidth"]);
                            characterWidthToUse = Convert.ToInt32(this["characterWidth"]);
                        }
                        else if(this["defaultScreenCharactersWidth"] != null)
                        {
                            screenPixelsWidthToUse = Convert.ToInt32(this["defaultScreenCharactersWidth"]);
                            characterWidthToUse = 1;
                        }

                        _screenCharactersWidth = screenPixelsWidthToUse / characterWidthToUse;
                    }
                    else
                    {
                        _screenCharactersWidth = Convert.ToInt32(this["screenCharactersWidth"]);
                    }
                    _haveScreenCharactersWidth = true;
                }
                return _screenCharactersWidth;
            }
        }


        public virtual int ScreenCharactersHeight
        {
            get
            {
                if(!_haveScreenCharactersHeight)
                {
                    if(this["screenCharactersHeight"] == null)
                    {
                        // calculate from best partial information

                        int screenPixelHeightToUse = 480;
                        int characterHeightToUse = 12;

                        if(this["screenPixelsHeight"] != null && this["characterHeight"] != null)
                        {
                            screenPixelHeightToUse = Convert.ToInt32(this["screenPixelsHeight"]);
                            characterHeightToUse = Convert.ToInt32(this["characterHeight"]);
                        }
                        else if(this["screenPixelsHeight"] != null)
                        {
                            screenPixelHeightToUse = Convert.ToInt32(this["screenPixelsHeight"]);
                            characterHeightToUse = Convert.ToInt32(this["defaultCharacterHeight"]);
                        }
                        else if(this["characterHeight"] != null)
                        {
                            screenPixelHeightToUse = Convert.ToInt32(this["defaultScreenPixelsHeight"]);
                            characterHeightToUse = Convert.ToInt32(this["characterHeight"]);
                        }
                        else if(this["defaultScreenCharactersHeight"] != null)
                        {
                            screenPixelHeightToUse = Convert.ToInt32(this["defaultScreenCharactersHeight"]);
                            characterHeightToUse = 1;
                        }

                        _screenCharactersHeight = screenPixelHeightToUse / characterHeightToUse;
                    }
                    else
                    {
                        _screenCharactersHeight = Convert.ToInt32(this["screenCharactersHeight"]);
                    }
                    _haveScreenCharactersHeight = true;
                }
                return _screenCharactersHeight;
            }
        }


        public virtual int ScreenPixelsWidth
        {
            get
            {
                if(!_haveScreenPixelsWidth)
                {
                    if(this["screenPixelsWidth"] == null)
                    {
                        // calculate from best partial information

                        int screenCharactersWidthToUse = 80;
                        int characterWidthToUse = 8;

                        if(this["screenCharactersWidth"] != null && this["characterWidth"] != null)
                        {
                            screenCharactersWidthToUse = Convert.ToInt32(this["screenCharactersWidth"]);
                            characterWidthToUse = Convert.ToInt32(this["characterWidth"]);
                        }
                        else if(this["screenCharactersWidth"] != null)
                        {
                            screenCharactersWidthToUse = Convert.ToInt32(this["screenCharactersWidth"]);
                            characterWidthToUse = Convert.ToInt32(this["defaultCharacterWidth"]);
                        }
                        else if(this["characterWidth"] != null)
                        {
                            screenCharactersWidthToUse = Convert.ToInt32(this["defaultScreenCharactersWidth"]);
                            characterWidthToUse = Convert.ToInt32(this["characterWidth"]);
                        }
                        else if(this["defaultScreenPixelsWidth"] != null)
                        {
                            screenCharactersWidthToUse = Convert.ToInt32(this["defaultScreenPixelsWidth"]);
                            characterWidthToUse = 1;
                        }

                        _screenPixelsWidth = screenCharactersWidthToUse * characterWidthToUse;
                    }
                    else
                    {
                        _screenPixelsWidth = Convert.ToInt32(this["screenPixelsWidth"]);
                    }
                    _haveScreenPixelsWidth = true;
                }
                return _screenPixelsWidth;
            }
        }


        public virtual int ScreenPixelsHeight
        {
            get
            {
                if(!_haveScreenPixelsHeight)
                {
                    if(this["screenPixelsHeight"] == null)
                    {
                        int screenCharactersHeightToUse = 480 / 12;
                        int characterHeightToUse = 12;

                        if(this["screenCharactersHeight"] != null && this["characterHeight"] != null)
                        {
                            screenCharactersHeightToUse = Convert.ToInt32(this["screenCharactersHeight"]);
                            characterHeightToUse = Convert.ToInt32(this["characterHeight"]);
                        }
                        else if(this["screenCharactersHeight"] != null)
                        {
                            screenCharactersHeightToUse = Convert.ToInt32(this["screenCharactersHeight"]);
                            characterHeightToUse = Convert.ToInt32(this["defaultCharacterHeight"]);
                        }
                        else if(this["characterHeight"] != null)
                        {
                            screenCharactersHeightToUse = Convert.ToInt32(this["defaultScreenCharactersHeight"]);
                            characterHeightToUse = Convert.ToInt32(this["characterHeight"]);
                        }
                        else if(this["defaultScreenPixelsHeight"] != null)
                        {
                            screenCharactersHeightToUse = Convert.ToInt32(this["defaultScreenPixelsHeight"]);
                            characterHeightToUse = 1;
                        }

                        _screenPixelsHeight = screenCharactersHeightToUse * characterHeightToUse;
                    }
                    else
                    {
                        _screenPixelsHeight = Convert.ToInt32(this["screenPixelsHeight"]);
                    }
                    _haveScreenPixelsHeight = true;
                }
                return _screenPixelsHeight;
            }
        }


        public virtual int ScreenBitDepth
        {
            get
            {
                if(!_haveScreenBitDepth)
                {
                    _screenBitDepth = Convert.ToInt32(this["screenBitDepth"]);
                    _haveScreenBitDepth = true;
                }
                return _screenBitDepth;
            }
        }


        public virtual bool IsColor
        {
            get
            {
                if(!_haveIsColor)
                {
                    String isColorString = this["isColor"];
                    if(isColorString == null)
                    {
                        _isColor = false;
                    }
                    else
                    {
                        _isColor = Convert.ToBoolean(this["isColor"]);
                    }
                    _haveIsColor = true;
                }
                return _isColor;
            }
        }


        public virtual String InputType
        {
            get
            {
                if(!_haveInputType)
                {
                    _inputType = this["inputType"];
                    _haveInputType = true;
                }
                return _inputType;
            }
        }


        public virtual int NumberOfSoftkeys
        {
            get
            {
                if(!_haveNumberOfSoftkeys)
                {
                    _numberOfSoftkeys = Convert.ToInt32(this["numberOfSoftkeys"]);
                    _haveNumberOfSoftkeys = true;
                }
                return _numberOfSoftkeys;
            }
        }


        public virtual int MaximumSoftkeyLabelLength
        {
            get
            {
                if(!_haveMaximumSoftkeyLabelLength)
                {
                    _maximumSoftkeyLabelLength = Convert.ToInt32(this["maximumSoftkeyLabelLength"]);
                    _haveMaximumSoftkeyLabelLength = true;
                }
                return _maximumSoftkeyLabelLength;
            }
        }


        public virtual bool CanInitiateVoiceCall
        {
            get
            {
                if(!_haveCanInitiateVoiceCall)
                {
                    String canInitiateVoiceCallString = this["canInitiateVoiceCall"];
                    if(canInitiateVoiceCallString == null)
                    {
                        _canInitiateVoiceCall = false;
                    }
                    else
                    {
                        _canInitiateVoiceCall = Convert.ToBoolean(canInitiateVoiceCallString);
                    }
                    _haveCanInitiateVoiceCall = true;
                }
                return _canInitiateVoiceCall;
            }
        }


        public virtual bool CanSendMail
        {
            get
            {
                if(!_haveCanSendMail)
                {
                    String canSendMailString = this["canSendMail"];
                    if(canSendMailString == null)
                    {
                        _canSendMail = true;
                    }
                    else
                    {
                        _canSendMail = Convert.ToBoolean(canSendMailString);
                    }
                    _haveCanSendMail = true;
                }
                return _canSendMail;
            }
        }

        public virtual bool HasBackButton
        {
            get
            {
                if(!_haveHasBackButton)
                {
                    String hasBackButtonString = this["hasBackButton"];
                    if(hasBackButtonString == null)
                    {
                        _hasBackButton = true;
                    }
                    else
                    {
                        _hasBackButton = Convert.ToBoolean(hasBackButtonString);
                    }
                    _haveHasBackButton = true;
                }
                return _hasBackButton;
            }
        }

        public virtual bool RendersWmlDoAcceptsInline
        {
            get
            {
                if(!_haveRendersWmlDoAcceptsInline)
                {
                    String rendersWmlDoAcceptsInlineString = this["rendersWmlDoAcceptsInline"];
                    if(rendersWmlDoAcceptsInlineString == null)
                    {
                        _rendersWmlDoAcceptsInline = true;
                    }
                    else
                    {
                        _rendersWmlDoAcceptsInline = Convert.ToBoolean(rendersWmlDoAcceptsInlineString);
                    }
                    _haveRendersWmlDoAcceptsInline = true;
                }
                return _rendersWmlDoAcceptsInline;
            }
        }

        public virtual bool RendersWmlSelectsAsMenuCards
        {
            get
            {
                if(!_haveRendersWmlSelectsAsMenuCards)
                {
                    String rendersWmlSelectsAsMenuCardsString = this["rendersWmlSelectsAsMenuCards"];
                    if(rendersWmlSelectsAsMenuCardsString == null)
                    {
                        _rendersWmlSelectsAsMenuCards = false;
                    }
                    else
                    {
                        _rendersWmlSelectsAsMenuCards = Convert.ToBoolean(rendersWmlSelectsAsMenuCardsString);
                    }
                    _haveRendersWmlSelectsAsMenuCards = true;
                }
                return _rendersWmlSelectsAsMenuCards;
            }
        }

        public virtual bool RendersBreaksAfterWmlAnchor
        {
            get
            {
                if(!_haveRendersBreaksAfterWmlAnchor)
                {
                    String rendersBreaksAfterWmlAnchorString = this["rendersBreaksAfterWmlAnchor"];
                    if(rendersBreaksAfterWmlAnchorString == null)
                    {
                        _rendersBreaksAfterWmlAnchor = true;
                    }
                    else
                    {
                        _rendersBreaksAfterWmlAnchor = Convert.ToBoolean(rendersBreaksAfterWmlAnchorString);
                    }
                    _haveRendersBreaksAfterWmlAnchor = true;
                }
                return _rendersBreaksAfterWmlAnchor;
            }
        }

        public virtual bool RendersBreaksAfterWmlInput
        {
            get
            {
                if(!_haveRendersBreaksAfterWmlInput)
                {
                    String rendersBreaksAfterWmlInputString = this["rendersBreaksAfterWmlInput"];
                    if(rendersBreaksAfterWmlInputString == null)
                    {
                        _rendersBreaksAfterWmlInput = true;
                    }
                    else
                    {
                        _rendersBreaksAfterWmlInput = Convert.ToBoolean(rendersBreaksAfterWmlInputString);
                    }
                    _haveRendersBreaksAfterWmlInput = true;
                }
                return _rendersBreaksAfterWmlInput;
            }
        }

        public virtual bool RendersBreakBeforeWmlSelectAndInput
        {
            get
            {
                if(!_haveRendersBreakBeforeWmlSelectAndInput)
                {
                    String rendersBreaksBeforeWmlSelectAndInputString = this["rendersBreakBeforeWmlSelectAndInput"];
                    if(rendersBreaksBeforeWmlSelectAndInputString == null)
                    {
                        _rendersBreakBeforeWmlSelectAndInput = false;
                    }
                    else
                    {
                        _rendersBreakBeforeWmlSelectAndInput = Convert.ToBoolean(rendersBreaksBeforeWmlSelectAndInputString);
                    }
                    _haveRendersBreakBeforeWmlSelectAndInput = true;
                }
                return _rendersBreakBeforeWmlSelectAndInput;
            }
        }

        public virtual bool RequiresPhoneNumbersAsPlainText
        {
            get
            {
                if(!_haveRequiresPhoneNumbersAsPlainText)
                {
                    String requiresPhoneNumbersAsPlainTextString = this["requiresPhoneNumbersAsPlainText"];
                    if(requiresPhoneNumbersAsPlainTextString == null)
                    {
                        _requiresPhoneNumbersAsPlainText = false;
                    }
                    else
                    {
                        _requiresPhoneNumbersAsPlainText = Convert.ToBoolean(requiresPhoneNumbersAsPlainTextString);
                    }
                    _haveRequiresPhoneNumbersAsPlainText = true;
                }
                return _requiresPhoneNumbersAsPlainText;
            }
        }

        public virtual bool RequiresUrlEncodedPostfieldValues
        {
            get
            {
                if(!_haveRequiresUrlEncodedPostfieldValues)
                {
                    String requiresUrlEncodedPostfieldValuesString = this["requiresUrlEncodedPostfieldValues"];
                    if(requiresUrlEncodedPostfieldValuesString == null)
                    {
                        _requiresUrlEncodedPostfieldValues = true;
                    }
                    else
                    {
                        _requiresUrlEncodedPostfieldValues = Convert.ToBoolean(requiresUrlEncodedPostfieldValuesString);
                    }
                    _haveRequiresUrlEncodedPostfieldValues = true;
                }
                return _requiresUrlEncodedPostfieldValues;
            }
        }

        public virtual String RequiredMetaTagNameValue
        {
            get
            {
                if(!_haveRequiredMetaTagNameValue)
                {
                    String value = this["requiredMetaTagNameValue"];
                    if(value == null || value == String.Empty)
                    {
                        _requiredMetaTagNameValue = null;
                    }
                    else
                    {
                        _requiredMetaTagNameValue = value;
                    }
                    _haveRequiredMetaTagNameValue = true;
                }
                return _requiredMetaTagNameValue;
            }
        }

        public virtual bool RendersBreaksAfterHtmlLists
        {
            get
            {
                if(!_haveRendersBreaksAfterHtmlLists)
                {
                    String rendersBreaksAfterHtmlListsString = this["rendersBreaksAfterHtmlLists"];
                    if(rendersBreaksAfterHtmlListsString == null)
                    {
                        _rendersBreaksAfterHtmlLists = true;
                    }
                    else
                    {
                        _rendersBreaksAfterHtmlLists = Convert.ToBoolean(rendersBreaksAfterHtmlListsString);
                    }
                    _haveRendersBreaksAfterHtmlLists = true;
                }
                return _rendersBreaksAfterHtmlLists;
            }
        }

        public virtual bool RequiresUniqueHtmlInputNames
        {
            get
            {
                if(!_haveRequiresUniqueHtmlInputNames)
                {
                    String requiresUniqueHtmlInputNamesString = this["requiresUniqueHtmlInputNames"];
                    if(requiresUniqueHtmlInputNamesString == null)
                    {
                        _requiresUniqueHtmlInputNames = false;
                    }
                    else
                    {
                        _requiresUniqueHtmlInputNames = Convert.ToBoolean(requiresUniqueHtmlInputNamesString);
                    }
                    _haveRequiresUniqueHtmlInputNames = true;
                }
                return _requiresUniqueHtmlInputNames;
            }
        }

        public virtual bool RequiresUniqueHtmlCheckboxNames
        {
            get
            {
                if(!_haveRequiresUniqueHtmlCheckboxNames)
                {
                    String requiresUniqueHtmlCheckboxNamesString = this["requiresUniqueHtmlCheckboxNames"];
                    if(requiresUniqueHtmlCheckboxNamesString == null)
                    {
                        _requiresUniqueHtmlCheckboxNames = false;
                    }
                    else
                    {
                        _requiresUniqueHtmlCheckboxNames = Convert.ToBoolean(requiresUniqueHtmlCheckboxNamesString);
                    }
                    _haveRequiresUniqueHtmlCheckboxNames = true;
                }
                return _requiresUniqueHtmlCheckboxNames;
            }
        }

        public virtual bool SupportsCss
        {
            get
            {
                if(!_haveSupportsCss)
                {
                    String supportsCssString = this["supportsCss"];
                    if(supportsCssString == null)
                    {
                        _supportsCss = false;
                    }
                    else
                    {
                        _supportsCss = Convert.ToBoolean(supportsCssString);
                    }
                    _haveSupportsCss = true;
                }
                return _supportsCss;
            }
        }

        public virtual bool HidesRightAlignedMultiselectScrollbars
        {
            get
            {
                if(!_haveHidesRightAlignedMultiselectScrollbars)
                {
                    String hidesRightAlignedMultiselectScrollbarsString = this["hidesRightAlignedMultiselectScrollbars"];
                    if(hidesRightAlignedMultiselectScrollbarsString == null)
                    {
                        _hidesRightAlignedMultiselectScrollbars = false;
                    }
                    else
                    {
                        _hidesRightAlignedMultiselectScrollbars = Convert.ToBoolean(hidesRightAlignedMultiselectScrollbarsString);
                    }
                    _haveHidesRightAlignedMultiselectScrollbars = true;
               }
               return _hidesRightAlignedMultiselectScrollbars;
            }
        }

        public virtual bool IsMobileDevice
        {
            get
            {
                if(!_haveIsMobileDevice)
                {
                    String isMobileDeviceString = this["isMobileDevice"];
                    if(isMobileDeviceString == null)
                    {
                        _isMobileDevice = false;
                    }
                    else
                    {
                        _isMobileDevice = Convert.ToBoolean(isMobileDeviceString);
                    }
                    _haveIsMobileDevice = true;
                }
                return _isMobileDevice;
            }
        }

        public virtual bool RequiresAttributeColonSubstitution
        {
            get
            {
                if(!_haveRequiresAttributeColonSubstitution)
                {
                    String requiresAttributeColonSubstitution = this["requiresAttributeColonSubstitution"];
                    if(requiresAttributeColonSubstitution == null)
                    {
                        _requiresAttributeColonSubstitution = false;
                    }
                    else
                    {
                        _requiresAttributeColonSubstitution = Convert.ToBoolean(requiresAttributeColonSubstitution);
                    }
                    _haveRequiresAttributeColonSubstitution = true;
                }
                return _requiresAttributeColonSubstitution;
            }
        }

        public virtual bool CanRenderOneventAndPrevElementsTogether
        {
            get
            {
                if(!_haveCanRenderOneventAndPrevElementsTogether)
                {
                    String canRenderOneventAndPrevElementsTogetherString = this["canRenderOneventAndPrevElementsTogether"];
                    if(canRenderOneventAndPrevElementsTogetherString == null)
                    {
                        _canRenderOneventAndPrevElementsTogether = true;
                    }
                    else
                    {
                        _canRenderOneventAndPrevElementsTogether = Convert.ToBoolean(canRenderOneventAndPrevElementsTogetherString);
                    }
                    _haveCanRenderOneventAndPrevElementsTogether = true;
                }
                return _canRenderOneventAndPrevElementsTogether;
            }
        }

        public virtual bool CanRenderInputAndSelectElementsTogether
        {
            get
            {
                if(!_haveCanRenderInputAndSelectElementsTogether)
                {
                    String canRenderInputAndSelectElementsTogetherString = this["canRenderInputAndSelectElementsTogether"];
                    if(canRenderInputAndSelectElementsTogetherString == null)
                    {
                        _canRenderInputAndSelectElementsTogether = true;
                    }
                    else
                    {
                        _canRenderInputAndSelectElementsTogether = Convert.ToBoolean(canRenderInputAndSelectElementsTogetherString);
                    }
                    _haveCanRenderInputAndSelectElementsTogether = true;
                }
                return _canRenderInputAndSelectElementsTogether;
            }
        }

        public virtual bool CanRenderAfterInputOrSelectElement
        {
            get
            {
                if(!_haveCanRenderAfterInputOrSelectElement)
                {
                    String canRenderAfterInputOrSelectElementString = this["canRenderAfterInputOrSelectElement"];
                    if(canRenderAfterInputOrSelectElementString == null)
                    {
                        _canRenderAfterInputOrSelectElement = true;
                    }
                    else
                    {
                        _canRenderAfterInputOrSelectElement = Convert.ToBoolean(canRenderAfterInputOrSelectElementString);
                    }
                    _haveCanRenderAfterInputOrSelectElement = true;
                }
                return _canRenderAfterInputOrSelectElement;
            }
        }

        public virtual bool CanRenderPostBackCards
        {
            get
            {
                if(!_haveCanRenderPostBackCards)
                {
                    String canRenderPostBackCardsString = this["canRenderPostBackCards"];
                    if(canRenderPostBackCardsString == null)
                    {
                        _canRenderPostBackCards = true;
                    }
                    else
                    {
                        _canRenderPostBackCards = Convert.ToBoolean(canRenderPostBackCardsString);
                    }
                    _haveCanRenderPostBackCards = true;
                }
                return _canRenderPostBackCards;
            }
        }

        public virtual bool CanRenderMixedSelects
        {
            get
            {
                if(!_haveCanRenderMixedSelects)
                {
                    String canRenderMixedSelectsString = this["canRenderMixedSelects"];
                    if(canRenderMixedSelectsString == null)
                    {
                        _canRenderMixedSelects = true;
                    }
                    else
                    {
                        _canRenderMixedSelects = Convert.ToBoolean(canRenderMixedSelectsString);
                    }
                    _haveCanRenderMixedSelects = true;
                }
                return _canRenderMixedSelects;
            }
        }

        public virtual bool CanCombineFormsInDeck
        {
            get
            {
                if(!_haveCanCombineFormsInDeck)
                {
                    String canCombineFormsInDeckString = this["canCombineFormsInDeck"];
                    if(canCombineFormsInDeckString == null)
                    {
                        _canCombineFormsInDeck = true;
                    }
                    else
                    {
                        _canCombineFormsInDeck = Convert.ToBoolean(canCombineFormsInDeckString);
                    }
                    _haveCanCombineFormsInDeck = true;
                }
                return _canCombineFormsInDeck;
            }
        }

        public virtual bool CanRenderSetvarZeroWithMultiSelectionList
        {
            get
            {
                if(!_haveCanRenderSetvarZeroWithMultiSelectionList)
                {
                    String canRenderSetvarZeroWithMultiSelectionListString = this["canRenderSetvarZeroWithMultiSelectionList"];
                    if(canRenderSetvarZeroWithMultiSelectionListString == null)
                    {
                        _canRenderSetvarZeroWithMultiSelectionList = true;
                    }
                    else
                    {
                        _canRenderSetvarZeroWithMultiSelectionList = Convert.ToBoolean(canRenderSetvarZeroWithMultiSelectionListString);
                    }
                    _haveCanRenderSetvarZeroWithMultiSelectionList = true;
                }
                return _canRenderSetvarZeroWithMultiSelectionList;
            }
        }

        public virtual bool SupportsImageSubmit
        {
            get
            {
                if(!_haveSupportsImageSubmit)
                {
                    String supportsImageSubmitString = this["supportsImageSubmit"];
                    if(supportsImageSubmitString == null)
                    {
                        _supportsImageSubmit = false;
                    }
                    else
                    {
                        _supportsImageSubmit = Convert.ToBoolean(supportsImageSubmitString);
                    }
                    _haveSupportsImageSubmit = true;
                }
                return _supportsImageSubmit;
            }
        }

        public virtual bool RequiresUniqueFilePathSuffix
        {
            get
            {
                if(!_haveRequiresUniqueFilePathSuffix)
                {
                    String requiresUniqueFilePathSuffixString = this["requiresUniqueFilePathSuffix"];
                    if(requiresUniqueFilePathSuffixString == null)
                    {
                        _requiresUniqueFilePathSuffix = false;
                    }
                    else
                    {
                        _requiresUniqueFilePathSuffix = Convert.ToBoolean(requiresUniqueFilePathSuffixString);
                    }
                    _haveRequiresUniqueFilePathSuffix = true;
                }
                return _requiresUniqueFilePathSuffix;
            }
        }

        public virtual bool RequiresNoBreakInFormatting
        {
            get
            {
                if(!_haveRequiresNoBreakInFormatting)
                {
                    String requiresNoBreakInFormatting = this["requiresNoBreakInFormatting"];
                    if(requiresNoBreakInFormatting == null)
                    {
                        _requiresNoBreakInFormatting = false;
                    }
                    else
                    {
                        _requiresNoBreakInFormatting = Convert.ToBoolean(requiresNoBreakInFormatting);
                    }
                    _haveRequiresNoBreakInFormatting = true;
                }
                return _requiresNoBreakInFormatting;
            }
        }

        public virtual bool RequiresLeadingPageBreak
        {
            get
            {
                if(!_haveRequiresLeadingPageBreak)
                {
                    String requiresLeadingPageBreak = this["requiresLeadingPageBreak"];
                    if(requiresLeadingPageBreak == null)
                    {
                        _requiresLeadingPageBreak = false;
                    }
                    else
                    {
                        _requiresLeadingPageBreak = Convert.ToBoolean(requiresLeadingPageBreak);
                    }
                    _haveRequiresLeadingPageBreak = true;
                }
                return _requiresLeadingPageBreak;
            }
        }

        public virtual bool SupportsSelectMultiple
        {
            get
            {
                if(!_haveSupportsSelectMultiple)
                {
                    String supportsSelectMultipleString = this["supportsSelectMultiple"];
                    if(supportsSelectMultipleString == null)
                    {
                        _supportsSelectMultiple = false;
                    }
                    else
                    {
                        _supportsSelectMultiple = Convert.ToBoolean(supportsSelectMultipleString);
                    }
                    _haveSupportsSelectMultiple = true;
                }
                return _supportsSelectMultiple;
            }
        }

        public virtual bool SupportsBold
        {
            get
            {
                if(!_haveSupportsBold)
                {
                    String supportsBold = this["supportsBold"];
                    if(supportsBold == null)
                    {
                        _supportsBold = false;
                    }
                    else
                    {
                        _supportsBold = Convert.ToBoolean(supportsBold);
                    }
                    _haveSupportsBold = true;
                }
                return _supportsBold;
            }
        }

        public virtual bool SupportsItalic
        {
            get
            {
                if(!_haveSupportsItalic)
                {
                    String supportsItalic = this["supportsItalic"];
                    if(supportsItalic == null)
                    {
                        _supportsItalic = false;
                    }
                    else
                    {
                        _supportsItalic = Convert.ToBoolean(supportsItalic);
                    }
                    _haveSupportsItalic = true;
                }
                return _supportsItalic;
            }
        }

        public virtual bool SupportsFontSize
        {
            get
            {
                if(!_haveSupportsFontSize)
                {
                    String supportsFontSize = this["supportsFontSize"];
                    if(supportsFontSize == null)
                    {
                        _supportsFontSize = false;
                    }
                    else
                    {
                        _supportsFontSize = Convert.ToBoolean(supportsFontSize);
                    }
                    _haveSupportsFontSize = true;
                }
                return _supportsFontSize;
            }
        }

        public virtual bool SupportsFontName
        {
            get
            {
                if(!_haveSupportsFontName)
                {
                    String supportsFontName = this["supportsFontName"];
                    if(supportsFontName == null)
                    {
                        _supportsFontName = false;
                    }
                    else
                    {
                        _supportsFontName = Convert.ToBoolean(supportsFontName);
                    }
                    _haveSupportsFontName = true;
                }
                return _supportsFontName;
            }
        }

        public virtual bool SupportsFontColor
        {
            get
            {
                if(!_haveSupportsFontColor)
                {
                    String supportsFontColor = this["supportsFontColor"];
                    if(supportsFontColor == null)
                    {
                        _supportsFontColor = false;
                    }
                    else
                    {
                        _supportsFontColor = Convert.ToBoolean(supportsFontColor);
                    }
                    _haveSupportsFontColor = true;
                }
                return _supportsFontColor;
            }
        }

        public virtual bool SupportsBodyColor
        {
            get
            {
                if(!_haveSupportsBodyColor)
                {
                    String supportsBodyColor = this["supportsBodyColor"];
                    if(supportsBodyColor == null)
                    {
                        _supportsBodyColor = false;
                    }
                    else
                    {
                        _supportsBodyColor = Convert.ToBoolean(supportsBodyColor);
                    }
                    _haveSupportsBodyColor = true;
                }
                return _supportsBodyColor;
            }
        }

        public virtual bool SupportsDivAlign
        {
            get
            {
                if(!_haveSupportsDivAlign)
                {
                    String supportsDivAlign = this["supportsDivAlign"];
                    if(supportsDivAlign == null)
                    {
                        _supportsDivAlign = false;
                    }
                    else
                    {
                        _supportsDivAlign = Convert.ToBoolean(supportsDivAlign);
                    }
                    _haveSupportsDivAlign = true;
                }
                return _supportsDivAlign;
            }
        }

        public virtual bool SupportsDivNoWrap
        {
            get
            {
                if(!_haveSupportsDivNoWrap)
                {
                    String supportsDivNoWrap = this["supportsDivNoWrap"];
                    if(supportsDivNoWrap == null)
                    {
                        _supportsDivNoWrap = false;
                    }
                    else
                    {
                        _supportsDivNoWrap = Convert.ToBoolean(supportsDivNoWrap);
                    }
                    _haveSupportsDivNoWrap = true;
                }
                return _supportsDivNoWrap;
            }
        }

        public virtual bool RequiresContentTypeMetaTag
        {
            get
            {
                if(!_haveRequiresContentTypeMetaTag)
                {
                    String requiresContentTypeMetaTag = this["requiresContentTypeMetaTag"];
                    if(requiresContentTypeMetaTag == null)
                    {
                        _requiresContentTypeMetaTag = false;
                    }
                    else
                    {
                        _requiresContentTypeMetaTag = 
                            Convert.ToBoolean(requiresContentTypeMetaTag);
                    }
                    _haveRequiresContentTypeMetaTag = true;
                }
                return _requiresContentTypeMetaTag;
            }
        }

        public virtual bool RequiresDBCSCharacter
        {
            get
            {
                if(!_haveRequiresDBCSCharacter)
                {
                    String requiresDBCSCharacter = this["requiresDBCSCharacter"];
                    if(requiresDBCSCharacter == null)
                    {
                        _requiresDBCSCharacter = false;
                    }
                    else
                    {
                        _requiresDBCSCharacter = 
                            Convert.ToBoolean(requiresDBCSCharacter);
                    }
                    _haveRequiresDBCSCharacter = true;
                }
                return _requiresDBCSCharacter;
            }
        }

        public virtual bool RequiresHtmlAdaptiveErrorReporting
        {
            get
            {
                if(!_haveRequiresHtmlAdaptiveErrorReporting)
                {
                    String requiresHtmlAdaptiveErrorReporting = this["requiresHtmlAdaptiveErrorReporting"];
                    if(requiresHtmlAdaptiveErrorReporting == null)
                    {
                        _requiresHtmlAdaptiveErrorReporting = false;
                    }
                    else
                    {
                        _requiresHtmlAdaptiveErrorReporting = 
                            Convert.ToBoolean(requiresHtmlAdaptiveErrorReporting);
                    }
                    _haveRequiresHtmlAdaptiveErrorReporting = true;
                }
                return _requiresHtmlAdaptiveErrorReporting;
            }
        }

        public virtual bool RequiresOutputOptimization
        {
            get
            {
                if(!_haveRequiresOutputOptimization)
                {
                    String RequiresOutputOptimizationString = this["requiresOutputOptimization"];
                    if(RequiresOutputOptimizationString == null)
                    {
                        _requiresOutputOptimization = false;
                    }
                    else
                    {
                        _requiresOutputOptimization = Convert.ToBoolean(RequiresOutputOptimizationString);
                    }
                    _haveRequiresOutputOptimization = true;
                }
                return _requiresOutputOptimization;
            }
        }

        public virtual bool SupportsAccesskeyAttribute
        {
            get
            {
                if(!_haveSupportsAccesskeyAttribute)
                {
                    String SupportsAccesskeyAttributeString = this["supportsAccesskeyAttribute"];
                    if(SupportsAccesskeyAttributeString == null)
                    {
                        _supportsAccesskeyAttribute = false;
                    }
                    else
                    {
                        _supportsAccesskeyAttribute = Convert.ToBoolean(SupportsAccesskeyAttributeString);
                    }
                    _haveSupportsAccesskeyAttribute = true;
                }
                return _supportsAccesskeyAttribute;
            }
        }

        public virtual bool SupportsInputIStyle
        {
            get
            {
                if(!_haveSupportsInputIStyle)
                {
                    String SupportsInputIStyleString = this["supportsInputIStyle"];
                    if(SupportsInputIStyleString == null)
                    {
                        _supportsInputIStyle = false;
                    }
                    else
                    {
                        _supportsInputIStyle = Convert.ToBoolean(SupportsInputIStyleString);
                    }
                    _haveSupportsInputIStyle = true;
                }
                return _supportsInputIStyle;
            }
        }

        public virtual bool SupportsInputMode
        {
            get
            {
                if(!_haveSupportsInputMode)
                {
                    String SupportsInputModeString = this["supportsInputMode"];
                    if(SupportsInputModeString == null)
                    {
                        _supportsInputMode = false;
                    }
                    else
                    {
                        _supportsInputMode = Convert.ToBoolean(SupportsInputModeString);
                    }
                    _haveSupportsInputMode = true;
                }
                return _supportsInputMode;
            }
        }

        public virtual bool SupportsIModeSymbols
        {
            get
            {
                if(!_haveSupportsIModeSymbols)
                {
                    String SupportsIModeSymbolsString = this["supportsIModeSymbols"];
                    if(SupportsIModeSymbolsString == null)
                    {
                        _supportsIModeSymbols = false;
                    }
                    else
                    {
                        _supportsIModeSymbols = Convert.ToBoolean(SupportsIModeSymbolsString);
                    }
                    _haveSupportsIModeSymbols = true;
                }
                return _supportsIModeSymbols;
            }
        }

        public virtual bool SupportsJPhoneSymbols
        {
            get
            {
                if(!_haveSupportsJPhoneSymbols)
                {
                    String SupportsJPhoneSymbolsString = this["supportsJPhoneSymbols"];
                    if(SupportsJPhoneSymbolsString == null)
                    {
                        _supportsJPhoneSymbols = false;
                    }
                    else
                    {
                        _supportsJPhoneSymbols = Convert.ToBoolean(SupportsJPhoneSymbolsString);
                    }
                    _haveSupportsJPhoneSymbols = true;
                }
                return _supportsJPhoneSymbols;
            }
        }

        public virtual bool SupportsJPhoneMultiMediaAttributes
        {
            get
            {
                if(!_haveSupportsJPhoneMultiMediaAttributes)
                {
                    String SupportsJPhoneMultiMediaAttributesString = this["supportsJPhoneMultiMediaAttributes"];
                    if(SupportsJPhoneMultiMediaAttributesString == null)
                    {
                        _supportsJPhoneMultiMediaAttributes = false;
                    }
                    else
                    {
                        _supportsJPhoneMultiMediaAttributes = Convert.ToBoolean(SupportsJPhoneMultiMediaAttributesString);
                    }
                    _haveSupportsJPhoneMultiMediaAttributes = true;
                }
                return _supportsJPhoneMultiMediaAttributes;
            }
        }

        public virtual int MaximumRenderedPageSize
        {
            get
            {
                if(!_haveMaximumRenderedPageSize)
                {
                    _maximumRenderedPageSize = Convert.ToInt32(this["maximumRenderedPageSize"]);
                    _haveMaximumRenderedPageSize = true;
                }
                return _maximumRenderedPageSize;
            }
        }

        public virtual bool RequiresSpecialViewStateEncoding
        {
            get
            {
                if(!_haveRequiresSpecialViewStateEncoding)
                {
                    String RequiresSpecialViewStateEncodingString = this["requiresSpecialViewStateEncoding"];
                    if(RequiresSpecialViewStateEncodingString == null)
                    {
                        _requiresSpecialViewStateEncoding = false;
                    }
                    else
                    {
                        _requiresSpecialViewStateEncoding = Convert.ToBoolean(RequiresSpecialViewStateEncodingString);
                    }
                    _haveRequiresSpecialViewStateEncoding = true;
                }
                return _requiresSpecialViewStateEncoding;
            }
        }

        public virtual bool SupportsQueryStringInFormAction
        {
            get
            {
                if(!_haveSupportsQueryStringInFormAction)
                {
                    String SupportsQueryStringInFormActionString = this["supportsQueryStringInFormAction"];
                    if(SupportsQueryStringInFormActionString == null)
                    {
                        _supportsQueryStringInFormAction = true;
                    }
                    else
                    {
                        _supportsQueryStringInFormAction = Convert.ToBoolean(SupportsQueryStringInFormActionString);
                    }
                    _haveSupportsQueryStringInFormAction = true;
                }
                return _supportsQueryStringInFormAction;
            }
        }

        public virtual bool SupportsCacheControlMetaTag
        {
            get
            {
                if(!_haveSupportsCacheControlMetaTag)
                {
                    String SupportsCacheControlMetaTagString = this["supportsCacheControlMetaTag"];
                    if(SupportsCacheControlMetaTagString == null)
                    {
                        _supportsCacheControlMetaTag = true;
                    }
                    else
                    {
                        _supportsCacheControlMetaTag = Convert.ToBoolean(SupportsCacheControlMetaTagString);
                    }
                    _haveSupportsCacheControlMetaTag = true;
                }
                return _supportsCacheControlMetaTag;
            }
        }

        public virtual bool SupportsUncheck
        {
            get
            {
                if(!_haveSupportsUncheck)
                {
                    String SupportsUncheckString = this["supportsUncheck"];
                    if(SupportsUncheckString == null)
                    {
                        _supportsUncheck = true;
                    }
                    else
                    {
                        _supportsUncheck = Convert.ToBoolean(SupportsUncheckString);
                    }
                    _haveSupportsUncheck = true;
                }
                return _supportsUncheck;
            }
        }

        public virtual bool CanRenderEmptySelects
        {
            get
            {
                if(!_haveCanRenderEmptySelects)
                {
                    String CanRenderEmptySelectsString = this["canRenderEmptySelects"];
                    if(CanRenderEmptySelectsString == null)
                    {
                        _canRenderEmptySelects = true;
                    }
                    else
                    {
                        _canRenderEmptySelects = Convert.ToBoolean(CanRenderEmptySelectsString);
                    }
                    _haveCanRenderEmptySelects = true;
                }
                return _canRenderEmptySelects;
            }
        }

        public virtual bool SupportsRedirectWithCookie
        {
            get
            {
                if(!_haveSupportsRedirectWithCookie)
                {
                    String supportsRedirectWithCookie = this["supportsRedirectWithCookie"];
                    if(supportsRedirectWithCookie == null)
                    {
                        _supportsRedirectWithCookie = true;
                    }
                    else
                    {
                        _supportsRedirectWithCookie = Convert.ToBoolean(supportsRedirectWithCookie);
                    }
                    _haveSupportsRedirectWithCookie = true;
                }
                return _supportsRedirectWithCookie;
            }
        }

        public virtual bool SupportsEmptyStringInCookieValue
        {
            get
            {
                if (!_haveSupportsEmptyStringInCookieValue)
                {
                    String supportsEmptyStringInCookieValue = this["supportsEmptyStringInCookieValue"];
                    if (supportsEmptyStringInCookieValue == null)
                    {
                        _supportsEmptyStringInCookieValue = true;
                    }
                    else
                    {
                        _supportsEmptyStringInCookieValue = 
                            Convert.ToBoolean (supportsEmptyStringInCookieValue);
                    }
                    _haveSupportsEmptyStringInCookieValue = true;
                }
                return _supportsEmptyStringInCookieValue;                
            }
        }

        public virtual int DefaultSubmitButtonLimit
        {
            get
            {
                if(!_haveDefaultSubmitButtonLimit)
                {
                    String s = this["defaultSubmitButtonLimit"];
                    _defaultSubmitButtonLimit = s != null ? Convert.ToInt32(this["defaultSubmitButtonLimit"]) : 1;
                    _haveDefaultSubmitButtonLimit = true;
                }
                return _defaultSubmitButtonLimit;
            }
        }


        private String _mobileDeviceManufacturer;
        private String _mobileDeviceModel;
        private String _gatewayVersion;
        private int _gatewayMajorVersion;
        private double _gatewayMinorVersion;
        private String _preferredRenderingType;     // TODO: Should make enumeration of known rend types
        private String _preferredRenderingMime;
        private String _preferredImageMime;
        private String _requiredMetaTagNameValue;
        private int _screenCharactersWidth;
        private int _screenCharactersHeight;
        private int _screenPixelsWidth;
        private int _screenPixelsHeight;
        private int _screenBitDepth;
        private bool _isColor;
        private String _inputType;
        private int _numberOfSoftkeys;
        private int _maximumSoftkeyLabelLength;
        private bool _canInitiateVoiceCall;
        private bool _canSendMail;
        private bool _hasBackButton;
        private bool _rendersWmlDoAcceptsInline;
        private bool _rendersWmlSelectsAsMenuCards;
        private bool _rendersBreaksAfterWmlAnchor;
        private bool _rendersBreaksAfterWmlInput;
        private bool _rendersBreakBeforeWmlSelectAndInput;
        private bool _requiresPhoneNumbersAsPlainText;
        private bool _requiresAttributeColonSubstitution;
        private bool _requiresUrlEncodedPostfieldValues;
        private bool _rendersBreaksAfterHtmlLists;
        private bool _requiresUniqueHtmlCheckboxNames;
        private bool _requiresUniqueHtmlInputNames;
        private bool _supportsCss;
        private bool _hidesRightAlignedMultiselectScrollbars;
        private bool _isMobileDevice;
        private bool _canRenderOneventAndPrevElementsTogether;
        private bool _canRenderInputAndSelectElementsTogether;
        private bool _canRenderAfterInputOrSelectElement;
        private bool _canRenderPostBackCards;
        private bool _canRenderMixedSelects;
        private bool _canCombineFormsInDeck;
        private bool _canRenderSetvarZeroWithMultiSelectionList;
        private bool _supportsImageSubmit;
        private bool _requiresUniqueFilePathSuffix;
        private bool _requiresNoBreakInFormatting;
        private bool _requiresLeadingPageBreak;
        private bool _supportsSelectMultiple;
        private bool _supportsBold;
        private bool _supportsItalic;
        private bool _supportsFontSize;
        private bool _supportsFontName;
        private bool _supportsFontColor;
        private bool _supportsBodyColor;
        private bool _supportsDivAlign;
        private bool _supportsDivNoWrap;
        private bool _requiresHtmlAdaptiveErrorReporting;
        private bool _requiresContentTypeMetaTag;
        private bool _requiresDBCSCharacter;
        private bool _requiresOutputOptimization;
        private bool _supportsAccesskeyAttribute;
        private bool _supportsInputIStyle;
        private bool _supportsInputMode;
        private bool _supportsIModeSymbols;
        private bool _supportsJPhoneSymbols;
        private bool _supportsJPhoneMultiMediaAttributes;
        private int _maximumRenderedPageSize;
        private bool _requiresSpecialViewStateEncoding;
        private bool _supportsQueryStringInFormAction;
        private bool _supportsCacheControlMetaTag;
        private bool _supportsUncheck;
        private bool _canRenderEmptySelects;
        private bool _supportsRedirectWithCookie;
        private bool _supportsEmptyStringInCookieValue;
        private int _defaultSubmitButtonLimit;

        private bool _haveMobileDeviceManufacturer;
        private bool _haveMobileDeviceModel;
        private bool _haveGatewayVersion;
        private bool _haveGatewayMajorVersion;
        private bool _haveGatewayMinorVersion;
        private bool _havePreferredRenderingType;
        private bool _havePreferredRenderingMime;
        private bool _havePreferredImageMime;
        private bool _haveScreenCharactersWidth;
        private bool _haveScreenCharactersHeight;
        private bool _haveScreenPixelsWidth;
        private bool _haveScreenPixelsHeight;
        private bool _haveScreenBitDepth;
        private bool _haveIsColor;
        private bool _haveInputType;
        private bool _haveNumberOfSoftkeys;
        private bool _haveMaximumSoftkeyLabelLength;
        private bool _haveCanInitiateVoiceCall;
        private bool _haveCanSendMail;
        private bool _haveHasBackButton;
        private bool _haveRendersWmlDoAcceptsInline;
        private bool _haveRendersWmlSelectsAsMenuCards;
        private bool _haveRendersBreaksAfterWmlAnchor;
        private bool _haveRendersBreaksAfterWmlInput;
        private bool _haveRendersBreakBeforeWmlSelectAndInput;
        private bool _haveRequiresPhoneNumbersAsPlainText;
        private bool _haveRequiresUrlEncodedPostfieldValues;
        private bool _haveRequiredMetaTagNameValue;
        private bool _haveRendersBreaksAfterHtmlLists;
        private bool _haveRequiresUniqueHtmlCheckboxNames;
        private bool _haveRequiresUniqueHtmlInputNames;
        private bool _haveSupportsCss;
        private bool _haveHidesRightAlignedMultiselectScrollbars;
        private bool _haveIsMobileDevice;
        private bool _haveCanRenderOneventAndPrevElementsTogether;
        private bool _haveCanRenderInputAndSelectElementsTogether;
        private bool _haveCanRenderAfterInputOrSelectElement;
        private bool _haveCanRenderPostBackCards;
        private bool _haveCanCombineFormsInDeck;
        private bool _haveCanRenderMixedSelects;
        private bool _haveCanRenderSetvarZeroWithMultiSelectionList;
        private bool _haveSupportsImageSubmit;
        private bool _haveRequiresUniqueFilePathSuffix;
        private bool _haveRequiresNoBreakInFormatting;
        private bool _haveRequiresLeadingPageBreak;
        private bool _haveSupportsSelectMultiple;
        private bool _haveRequiresAttributeColonSubstitution;
        private bool _haveRequiresHtmlAdaptiveErrorReporting;
        private bool _haveRequiresContentTypeMetaTag;
        private bool _haveRequiresDBCSCharacter;
        private bool _haveRequiresOutputOptimization;
        private bool _haveSupportsAccesskeyAttribute;
        private bool _haveSupportsInputIStyle;
        private bool _haveSupportsInputMode;
        private bool _haveSupportsIModeSymbols;
        private bool _haveSupportsJPhoneSymbols;
        private bool _haveSupportsJPhoneMultiMediaAttributes;
        private bool _haveSupportsRedirectWithCookie;
        private bool _haveSupportsEmptyStringInCookieValue = false;

        private bool _haveSupportsBold;
        private bool _haveSupportsItalic;
        private bool _haveSupportsFontSize;
        private bool _haveSupportsFontName;
        private bool _haveSupportsFontColor;
        private bool _haveSupportsBodyColor;
        private bool _haveSupportsDivAlign;
        private bool _haveSupportsDivNoWrap;
        private bool _haveMaximumRenderedPageSize;
        private bool _haveRequiresSpecialViewStateEncoding;
        private bool _haveSupportsQueryStringInFormAction;
        private bool _haveSupportsCacheControlMetaTag;
        private bool _haveSupportsUncheck;
        private bool _haveCanRenderEmptySelects;
        private bool _haveDefaultSubmitButtonLimit;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\controlpager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlPager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Control pager, a class that provides state as a form is paginated.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ControlPager
    {
        private Form _form;
        private int _pageWeight;
        private int _pageCount = 0;
        private int _remainingWeight = 0;
        private int _maximumPage = -1;

        public static readonly int DefaultWeight = 100;
        public static readonly int UseDefaultWeight = -1;

        public ControlPager(Form form, int pageWeight)
        {
            _form = form;
            _pageWeight = pageWeight;
        }

        public int GetPage(int weight)
        {
            if (weight > _remainingWeight)
            {
                PageCount++;
                RemainingWeight = PageWeight;
            }

            if (weight > _remainingWeight)
            {
                _remainingWeight = 0;
            }
            else
            {
                _remainingWeight -= weight;
            }
            return PageCount;
        }

        public int PageWeight
        {
            get
            {
                return _pageWeight;
            }
        }

        public int RemainingWeight
        {
            get
            {
                return _remainingWeight;
            }
            set
            {
                _remainingWeight = value;
            }
        }

        public int PageCount
        {
            get
            {
                return _pageCount;
            }
            set
            {
                _pageCount = value;
            }
        }

        internal int MaximumPage
        {
            get
            {
                return _maximumPage;
            }
            set
            {
                _maximumPage = value;
            }
        }

        public ItemPager GetItemPager(MobileControl control, int itemCount, int itemsPerPage, int itemWeight)
        {
            return new ItemPager(this, control, itemCount, itemsPerPage, itemWeight);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\controlsconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlsConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.Xml;
using System.Diagnostics;
using System.Configuration;
using System.Globalization;
using System.Web;
using System.Web.Configuration;
using System.Collections.Specialized;

namespace System.Web.UI.MobileControls
{
    // Mobile Controls Configuration class.
    // Includes Mobile Web Forms-specific settings, including a set
    // of device configurations, that can be used to decide what set of
    // adapters to use for a given device.

    internal class ControlsConfig
    {
        private readonly ControlsConfig _parent;

        private readonly StringDictionary _settings = new StringDictionary();
        private readonly ListDictionary _deviceConfigs = new ListDictionary();
        private FactoryGenerator _factoryGenerator;

        internal static ControlsConfig GetFromContext(HttpContext context)
        {
            return (ControlsConfig)context.GetConfig ("system.web/mobileControls");
        }

        internal ControlsConfig() : this(null)
        {
        }

        internal ControlsConfig(ControlsConfig parent)
        {
            _parent = parent;
        }

        // Return false if a device of the same name has already been added.
        internal /*public*/ bool AddDeviceConfig(String configName, IndividualDeviceConfig deviceConfig)
        {
            // Note that GetDeviceConfig also walks the parents configs
            if (GetDeviceConfig(configName) != null)
            {
                return false;
            }
            else
            {
                _deviceConfigs[configName] = deviceConfig;
                return true;
            }
        }

        internal /*public*/ IndividualDeviceConfig GetDeviceConfig(HttpContext context)
        {
            IndividualDeviceConfig deviceConfig = null;

            #if DEBUG
            if (context.Session != null)
            {
                String var = "AdapterOverride";
                bool saveInSession = true;
                String adapterOverride = (String)context.Session[var];
                if (adapterOverride == null)
                {
                    saveInSession = false;
                    adapterOverride = (String)context.Request.QueryString[var];
                }
                if (adapterOverride != null && 
                    (deviceConfig = GetDeviceConfig(adapterOverride)) != null)
                {
                    if (saveInSession)
                    {
                        context.Session[var] = adapterOverride;
                    }
                    return deviceConfig;
                }
            }
            #endif

            foreach (IndividualDeviceConfig candidate in _deviceConfigs.Values) 
            {
                if (candidate.DeviceQualifies(context))
                {
                    deviceConfig = candidate;
                    break;
                }
            }

            if (deviceConfig == null && _parent != null)
            {
                deviceConfig = _parent.GetDeviceConfig (context);
            }

            if (deviceConfig == null)
            {
                throw new Exception(
                    SR.GetString(SR.ControlsConfig_NoDeviceConfigRegistered,
                                 context.Request.UserAgent));
            }

            return deviceConfig;
        }

        internal /*public*/ IndividualDeviceConfig GetDeviceConfig(String configName)
        {
            IndividualDeviceConfig deviceConfig = (IndividualDeviceConfig)_deviceConfigs[configName];
            if (deviceConfig == null && _parent != null)
            {
                deviceConfig = _parent.GetDeviceConfig (configName);
            }
            return deviceConfig;
        }

        // Call this after all the device configs have been entered.  This will
        // resolve the names of the parent classes to inherit from actual
        // classes, and flag an error if there isn't one.  This is done as a
        // second-pass because devices earlier in web.config may inherit from
        // items later in the web.config.  That flexibility is required to get
        // the right behavior for device predicates being evaluated in the order
        // they appear.
        internal void FixupDeviceConfigInheritance(XmlNode configNode)
        {
            foreach (IndividualDeviceConfig config in _deviceConfigs.Values)
            {
                config.FixupInheritance(null, configNode);
            }
        }

        internal /*public*/ String this[String key]
        {
            get
            {
                String s = _settings[key];
                if (s == null && _parent != null)
                {
                    s = _parent[key];
                }
                return s;
            }

            set
            {
                _settings[key] = value;
            }
        }

        internal /*public*/ int SessionStateHistorySize
        {
            get
            {
                String sizeString = this["sessionStateHistorySize"];
                int size = Constants.DefaultSessionsStateHistorySize;
                
                if (sizeString != null)
                {
                    // Enclose in case a numerical value wasn't provided.  In
                    // which case just return the default.
                    try
                    {
                        size = Int32.Parse(sizeString);
                    }
                    catch (Exception)
                    {
                    }
                }

                return size;
            }
        }

        internal /*public*/ Type CookielessDataDictionaryType
        {
            get
            {
                Type cookielessDataType = null;
                String typeString = this["cookielessDataDictionaryType"];
                if((typeString != null) && (typeString != String.Empty))
                {
                    cookielessDataType = Type.GetType(typeString);
                }
                return cookielessDataType;
            }
        }

        internal /*public*/ bool AllowCustomAttributes
        {
            get
            {
                String allow = this["allowCustomAttributes"];
                return String.Compare(allow, "true", true, CultureInfo.InvariantCulture) == 0;
            }
        }

        internal FactoryGenerator AdapterFactoryGenerator
        {
            get
            {
                if (_parent != null)
                {
                    return _parent.AdapterFactoryGenerator;
                }
                else
                {
                    if (_factoryGenerator == null)
                    {
                        _factoryGenerator = new FactoryGenerator(typeof(IControlAdapter), 
                                                                 typeof(IControlAdapterFactory));
                    }
                    return _factoryGenerator;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\designeradapterattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerAdapterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
using System.ComponentModel;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * DesignerAdapter attribute. Can be attached to a control class to 
     * provide a type reference to the adapter that should be used in the
     * designer.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        AttributeUsage(AttributeTargets.Class, Inherited=true)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DesignerAdapterAttribute : Attribute 
    {
        private readonly String _typeName;

        public DesignerAdapterAttribute(String adapterTypeName)
        {
            _typeName = adapterTypeName;
        }

        public DesignerAdapterAttribute(Type adapterType)
        {
            _typeName = adapterType.AssemblyQualifiedName;
        }

        public virtual String TypeName
        {
            get 
            {
                return _typeName;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\datasourcehelper.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSourceHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Data;
using System.Diagnostics;

namespace System.Web.UI.MobileControls 
{

    /*
     * Data Source Helper class. Copied fairly verbatim from ASP.NET code base, and modified
     * to match our coding standards and, more importantly, use our exceptions.
     * The ASP.NET file is /system/web/ui/DataSourceHelper.cs (a private class)
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal sealed class DataSourceHelper 
    {

        private DataSourceHelper() 
        {
        }

        internal static IEnumerable GetResolvedDataSource(Object dataSource, String dataMember) 
        {
            if (dataSource == null)
            {
                return null;
            }

            IListSource listSource = dataSource as IListSource;
            if (listSource != null)
            {
                IList memberList = listSource.GetList();

                if (listSource.ContainsListCollection == false) 
                {
                    // The returned list is itself the list we need to bind to.
                    // (Ignore DataMember parameter.)
                    return (IEnumerable)memberList;
                }

                if ((memberList != null) && (memberList is ITypedList)) 
                {
                    ITypedList typedMemberList = (ITypedList)memberList;

                    PropertyDescriptorCollection propDescs = 
                        typedMemberList.GetItemProperties (new PropertyDescriptor[0]);
                    if ((propDescs != null) && (propDescs.Count != 0)) 
                    {
                        PropertyDescriptor listProperty = null;

                        if ((dataMember == null) || (dataMember.Length == 0)) 
                        {
                            listProperty = propDescs[0];
                        }
                        else 
                        {
                            listProperty = propDescs.Find(dataMember, true);
                        }

                        if (listProperty != null) 
                        {
                            Object listRow = memberList[0];
                            Object list = listProperty.GetValue(listRow);

                            if ((list != null) && (list is IEnumerable)) 
                            {
                                return (IEnumerable)list;
                            }
                        }

                        throw new ArgumentException(
                            SR.GetString(SR.DataSourceHelper_MissingDataMember,
                                         dataMember));
                    }
                    else 
                    {
                        throw new ArgumentException(
                            SR.GetString(SR.DataSourceHelper_DataSourceWithoutDataMember,
                                         "List DataSource"));
                    }
                }
            }

            if (dataSource is IEnumerable) 
            {
                return (IEnumerable)dataSource;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\constants.cs ===
//------------------------------------------------------------------------------
// <copyright file="Constants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    public enum ObjectListViewMode
    {
        List,
        Commands,
        Details
    };

    public enum BooleanOption
    {
        NotSet = -1,
        False,
        True,
    };

    public enum FontSize
    {
        NotSet,
        Normal,
        Small,
        Large
    };

    public enum Alignment
    {
        NotSet,
        Left,
        Center,
        Right
    }

    public enum Wrapping
    {
        NotSet,
        Wrap,
        NoWrap
    }

    public enum ListDecoration
    {
        None,
        Bulleted,
        Numbered
    }

    public enum ListSelectType
    {
        DropDown,
        ListBox,
        Radio,
        MultiSelectListBox,
        CheckBox
    }

    public enum FormMethod
    {
        Get,
        Post,
    }

    public enum CommandFormat
    {
        Button,
        Link,
    }

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Constants
    {
        internal const String ErrorStyle = "error";
        public static readonly String FormIDPrefix = "#";
        public static readonly String UniqueFilePathSuffixVariableWithoutEqual = "__ufps";
        public static readonly String UniqueFilePathSuffixVariable = UniqueFilePathSuffixVariableWithoutEqual + '=';
        public static readonly String PagePrefix = "__PG_";
        public static readonly String EventSourceID = "__ET";
        public static readonly String EventArgumentID = "__EA";

        public static readonly String HeaderTemplateTag = "HeaderTemplate";
        public static readonly String FooterTemplateTag = "FooterTemplate";
        public static readonly String ItemTemplateTag = "ItemTemplate";
        public static readonly String AlternatingItemTemplateTag = "AlternatingItemTemplate";
        public static readonly String SeparatorTemplateTag = "SeparatorTemplate";
        public static readonly String ContentTemplateTag = "ContentTemplate";
        public static readonly String LabelTemplateTag = "LabelTemplate";
        public static readonly String ItemDetailsTemplateTag = "ItemDetailsTemplate";
        public static readonly String ScriptTemplateTag = "ScriptTemplate";

        public static readonly String SymbolProtocol = "symbol:";

        public static readonly char SelectionListSpecialCharacter = '*';

        public static readonly int DefaultSessionsStateHistorySize = 5;

        public static readonly String OptimumPageWeightParameter = "optimumPageWeight";
        public static readonly String ScreenCharactersHeightParameter = "screenCharactersHeight";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\deviceoverridableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceOverridableATtribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.MobileControls
{
    using System;
    using System.Security.Permissions;

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [Obsolete("This attribute will be removed from future Versions, and is not currently used by the runtime.")]
    public class DeviceOverridableAttribute : Attribute
    {
        bool _overridable = false;
    
        public DeviceOverridableAttribute()
        {
        }

        public DeviceOverridableAttribute(bool overridable)
        {
            _overridable = overridable;
        }

        public bool Overridable
        {
            get
            {
                return _overridable;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\designerdeviceconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerDeviceConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


using System;
using System.ComponentModel;
using System.Web.UI.MobileControls.Adapters;

namespace System.Web.UI.MobileControls
{
    // Data structure for a specialized version of IndividualDeviceConfig,
    // used in design mode.

    class DesignerDeviceConfig : IndividualDeviceConfig
    {
        internal DesignerDeviceConfig(String pageAdapterType) : base(Type.GetType (pageAdapterType))
        {
        }

        internal override IControlAdapter NewControlAdapter(Type originalControlType)
        {
            IControlAdapter adapter;
            IControlAdapterFactory adapterFactory = LookupControl(originalControlType);
            
            if (adapterFactory != null)
            {
                adapter = adapterFactory.CreateInstance();
            }
            else
            {
                DesignerAdapterAttribute da;
                da = (DesignerAdapterAttribute)
                    TypeDescriptor.GetAttributes(originalControlType)
                        [typeof(DesignerAdapterAttribute)];
                if (da == null)
                {
                    return new EmptyControlAdapter();
                }

                Type adapterType = Type.GetType(da.TypeName);
                if (adapterType == null)
                {
                    return new EmptyControlAdapter();
                }

                adapter = Activator.CreateInstance(adapterType) as IControlAdapter;
            }

            if (adapter == null)
            {
                adapter = new EmptyControlAdapter();
            }
            return adapter;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\customvalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CustomValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.ComponentModel;
using System.Diagnostics;
using System.Web.UI.WebControls;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile CustomValidator class.
     * The CustomValidator provides the ability to easily write custom server
     * validation logic.  A user-defined function is called via a single-cast
     * delegate to provide server-side custom validation.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DefaultEvent("ServerValidate"),
        ToolboxData("<{0}:CustomValidator runat=\"server\" ErrorMessage=\"CustomValidator\"></{0}:CustomValidator>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class CustomValidator : BaseValidator
    {
        private WebCntrls.CustomValidator _webCustomValidator;

        // Static objects to identify individual events stored in Events
        // property.
        private static readonly Object EventServerValidate = new Object();

        protected override WebCntrls.BaseValidator CreateWebValidator()
        {
            _webCustomValidator = new WebCntrls.CustomValidator();

            // Adding wrapper event handlers for event properties exposed by
            // the aggregated control.  For more details about the mechanism,
            // please see the comment in the constructor of
            // Mobile.UI.AdRotator.
            ServerValidateEventHandler eventHandler =
                new ServerValidateEventHandler(WebServerValidate);

            _webCustomValidator.ServerValidate += eventHandler;

            return _webCustomValidator;
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original CustomValidator.
        ////////////////////////////////////////////////////////////////////////

        [
            Bindable(false),
            DefaultValue(null),
            MobileSysDescription(SR.CustomValidator_OnServerValidate)
        ]
        public event ServerValidateEventHandler ServerValidate
        {
            add
            {
                Events.AddHandler(EventServerValidate, value);
            }
            remove
            {
                Events.RemoveHandler(EventServerValidate, value);
            }
        }

        // protected method (which can be overridden by subclasses) for
        // raising user events
        protected virtual bool OnServerValidate(String value)
        {
            ServerValidateEventHandler handler = (ServerValidateEventHandler)Events[EventServerValidate];
                        if (handler != null) 
                        {
                                ServerValidateEventArgs args = new ServerValidateEventArgs(value, true);
                                handler(this, args);
                                return args.IsValid;
                        }
                        else 
                        {
                                return true;
                        }
        }

        private void WebServerValidate(Object source, ServerValidateEventArgs e)
        {
            // Invoke user events for further manipulation specified by user
                        Debug.Assert(e != null, "Unexpected null parameter!");
                        e.IsValid = OnServerValidate(e.Value);
        }

        protected override bool EvaluateIsValid()
        {
            return EvaluateIsValidInternal();
        }

        /////////////////////////////////////////////////////////////////////
        // Helper function adopted from WebForms CustomValidator
        /////////////////////////////////////////////////////////////////////

        protected override bool ControlPropertiesValid()
        {
            // Need to override the BaseValidator implementation, because for
            // CustomValidator, it is fine for ControlToValidate to be blank.
            String controlToValidate = ControlToValidate;
            if (controlToValidate.Length > 0)
            {
                return base.ControlPropertiesValid();
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\devicespecificchoicecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceSpecificChoiceCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.UI;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Collection of DeviceSpecificChoice objects.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecificChoiceCollection : ArrayListCollectionBase
    {
        DeviceSpecific _owner;

        internal DeviceSpecificChoiceCollection(DeviceSpecific owner)
        {
            _owner = owner;
        }

        public DeviceSpecificChoice this[int index]
        {
            get
            {
                return (DeviceSpecificChoice)Items[index];
            }
        }

        public void Add(DeviceSpecificChoice choice)
        {
            AddAt(-1, choice);
        }

        public void AddAt(int index, DeviceSpecificChoice choice)
        {
            choice.Owner = _owner;
            if (index == -1)
            {
                Items.Add(choice);
            }
            else
            {
                Items.Insert(index, choice);
            }
        }

        public void Clear()
        {
            Items.Clear();
        }

        public void RemoveAt(int index)
        {
            if (index >= 0 && index < Count)
            {
                Items.RemoveAt(index);
            }
        }
        
        public void Remove(DeviceSpecificChoice choice)
        {
            int index = Items.IndexOf(choice, 0, Count);
            if (index != -1)
            {
                Items.RemoveAt(index);
            }
        }

        ///////////////////////////////////////////////////////////
        ///  DESIGNER PROPERTY
        ///////////////////////////////////////////////////////////
        [
            Browsable(false),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public ArrayList All
        {
            get 
            {
                return base.Items;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\dummydatasource.cs ===
//------------------------------------------------------------------------------
// <copyright file="DummyDataSource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;

namespace System.Web.UI.MobileControls
{

    /*
     * Dummy Data Source class.
     * This dummy data source is used when a real data source is not present.
     * A similar class exists in ASP.NET WebControls, but is sealed.
     * This one is slightly more compact, since it only implements IEnumerable.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal class DummyDataSource : IEnumerable
    {
        private int _count;

        internal DummyDataSource(int count)
        {
            _count = count;
        }

        public IEnumerator GetEnumerator()
        {
            return new Enumerator(_count);
        }

        private class Enumerator : IEnumerator
        {
            private int _count;
            private int _index;
    
            public Enumerator(int count)
            {
                _count = count;
                _index = -1;
            }
    
            public Object Current
            {
                get
                {
                    return null;
                }
            }
    
            public bool MoveNext()
            {
                return (++_index < _count);
            }
    
            public void Reset()
            {
                _index = -1;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\errorformatterpage.cs ===
//------------------------------------------------------------------------------
// <copyright file="ErrorFormatterPage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Web.UI;
using System.Web.Mobile;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Error Formatter page class.
     * This is essentially a precompiled Mobile page, that formats error messages
     * for other devices. 
     *
     * NOTE: While there is nothing in the framework to let the developer override
     * this page, it has been written so the developer can do so.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ErrorFormatterPage : MobilePage
    {
        private MobileErrorInfo _errorInfo;

        protected MobileErrorInfo ErrorInfo
        {
            get
            {
                return _errorInfo;
            }
        }

        protected override void OnInit(EventArgs e)
        {
            base.OnInit (e);

            EnableViewState = false;
            _errorInfo = Context.Items[MobileErrorInfo.ContextKey] as MobileErrorInfo;
            if (_errorInfo == null)
            {
                // Don't care what kind of exception, since it'll be handled
                // quietly by the error handler module.
                throw new Exception ();
            }

            InitContent ();
        }

        private MobileControl CreateControlForText(String text)
        {
            if (text.IndexOf('\r') != -1)
            {
                TextView textView = new TextView();
                textView.Text = text;
                return textView;
            }
            else
            {
                Label label = new Label();
                label.Text = text;
                return label;
            }
        }

        protected virtual void InitContent()
        {
            Form form;
            MobileControl ctl;

            // Error form.

            form = new Form();
            form.Title = SR.GetString(SR.ErrorFormatterPage_ServerError,
                                      HttpRuntime.AppDomainAppVirtualPath);
            form.Wrapping = Wrapping.Wrap;
            IParserAccessor formAdd = (IParserAccessor)form;
             
            // Error title.

            ctl = CreateControlForText(ErrorInfo.Type);
            ctl.StyleReference = Constants.ErrorStyle;
            ctl.Font.Size = FontSize.Large;
            ctl.Font.Bold = BooleanOption.True;
            formAdd.AddParsedSubObject(ctl);

            // Error description.

            ctl = CreateControlForText(ErrorInfo.Description);
            formAdd.AddParsedSubObject(ctl);

            // Error miscellaneous text, if there is any.

            if (ErrorInfo.MiscTitle.Length > 0)
            {
                ctl = CreateControlForText(SR.GetString(SR.ErrorFormatterPage_MiscErrorMessage,
                                                        ErrorInfo.MiscTitle,
                                                        ErrorInfo.MiscText));
                formAdd.AddParsedSubObject(ctl);
            }

            // File/Line number info, if any.

            if (ErrorInfo.File.Length > 0)
            {
                Label label;

                label = new Label();
                label.Text = SR.GetString(SR.ErrorFormatterPage_File, ErrorInfo.File);
                formAdd.AddParsedSubObject(label);

                label = new Label();
                label.Text = SR.GetString(SR.ErrorFormatterPage_Line, ErrorInfo.LineNumber.ToString());
                formAdd.AddParsedSubObject(label);
            }

            Controls.Add(form);
        }

        protected override void SavePageStateToPersistenceMedium(Object viewState)
        {
            // Override and ignore. No need to save view state for this page.
        }

        protected override Object LoadPageStateFromPersistenceMedium()
        {
            // Override and ignore. No view state to load for this page.
            return null;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\fontinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.UI;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Design;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * FontInfo class.
     * Encapsulates all of the Style font properties into a single class.
     */
    [
        TypeConverterAttribute(typeof(ExpandableObjectConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class FontInfo
    {

        private Style _style;

        // TODO: At some point, consider not having FontInfo delegate to a
        // Style.  Not as easy as it looks, though, since we rely on the Style
        // for its persistence and inheritance.
        internal FontInfo(Style style)
        {
            _style = style;
        }

        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Drawing.Design.FontNameEditor), typeof(UITypeEditor)),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.FontInfo_Name),
            NotifyParentProperty(true),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.FontNameConverter)),
        ]
        public String Name
        {
            get
            {
                return _style.FontName;
            }
            set
            {
                _style.FontName = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(BooleanOption.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.FontInfo_Bold),
            NotifyParentProperty(true)
        ]
        public BooleanOption Bold
        {
            get
            {
                return _style.Bold;
            }
            set
            {
                _style.Bold = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(BooleanOption.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.FontInfo_Italic),
            NotifyParentProperty(true)
        ]
        public BooleanOption Italic
        {
            get
            {
                return _style.Italic;
            }
            set
            {
                _style.Italic = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(FontSize.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.FontInfo_Size),
            NotifyParentProperty(true)
        ]
        public FontSize Size
        {
            get
            {
                return _style.FontSize;
            }
            set
            {
                _style.FontSize = value;
            }
        }

        /// <summary>
        /// </summary>
        public override String ToString()
        {
            String size = (this.Size.Equals(FontSize.NotSet) ? null : Enum.GetName(typeof(FontSize), this.Size));
            String s = this.Name;

            if (size != null)
            {
                if (s.Length != 0)
                {
                    s += ", " + size;
                }
                else {
                    s = size;
                }
            }
            return s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\devicespecificchoice.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceSpecificChoice.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Web;
using System.Web.UI;
using System.Web.Mobile;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * DeviceSpecificChoice object.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ControlBuilderAttribute(typeof(DeviceSpecificChoiceControlBuilder)),
        PersistName("Choice"),
        PersistChildren(false),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecificChoice : IParserAccessor, IAttributeAccessor
    {
        private String _deviceFilter = String.Empty;
        private String _argument;
        private String _xmlns;
        private IDictionary _contents;
        private IDictionary _templates;
        private DeviceSpecific _owner;

        private static IComparer _caseInsensitiveComparer =
            new CaseInsensitiveComparer();

        [
            DefaultValue("")
        ]
        public String Filter  
        {
            get
            {
                Debug.Assert(_deviceFilter != null);
                return _deviceFilter; 
            }
             
            set
            {
                if (value == null)
                {
                    value = String.Empty;
                }
                _deviceFilter = value; 
            }
        }

        public String Argument  
        {
            get
            {
                return _argument; 
            }
             
            set
            {
                _argument = value; 
            }
        }

        // This property is used by the Designer, and has no runtime effect
        [
            DefaultValue("")
        ]
        public String Xmlns
        {
            get
            {
                return _xmlns;
            }

            set
            {
                _xmlns = value;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
        ]
        public IDictionary Contents
        {
            get
            {
                if (_contents == null)
                {
                    _contents = new ListDictionary(_caseInsensitiveComparer);
                }
                return _contents;
            }
        }

        [
            PersistenceMode(PersistenceMode.InnerProperty),
        ]
        public IDictionary Templates
        {
            get
            {
                if (_templates == null)
                {
                    _templates = new ListDictionary(_caseInsensitiveComparer);
                }
                return _templates;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public bool HasTemplates
        {
            get
            {
                return _templates != null && _templates.Count > 0;
            }
        }

        internal void ApplyProperties()
        {
            IDictionaryEnumerator enumerator = Contents.GetEnumerator();
            while (enumerator.MoveNext())
            {
                Object parentObject = Owner.Owner;
                
                String propertyName = (String)enumerator.Key;
                String propertyValue = enumerator.Value as String;

                // The ID property may not be overridden, according to spec
                // (since it will override the parent's ID, not very useful). 
                if (propertyName.ToLower(CultureInfo.InvariantCulture) == "id")
                {
                    throw new ArgumentException(
                        SR.GetString(SR.DeviceSpecificChoice_InvalidPropertyOverride,
                                     propertyName));
                }
                
                if (propertyValue != null)
                {
                    // Parse through any "-" syntax items.

                    int dash;
                    while ((dash = propertyName.IndexOf("-")) != -1)
                    {   
                        String containingObjectName = propertyName.Substring(0, dash);
                        PropertyDescriptor pd = TypeDescriptor.GetProperties(parentObject).Find(
                                    containingObjectName, true);
                        if (pd == null)
                        {
                            throw new ArgumentException(
                                SR.GetString(SR.DeviceSpecificChoice_OverridingPropertyNotFound,
                                             propertyName));
                        }

                        parentObject = pd.GetValue(parentObject);
                        propertyName = propertyName.Substring(dash + 1);
                    }

                    if (!FindAndApplyProperty(parentObject, propertyName, propertyValue) &&
                        !FindAndApplyEvent(parentObject, propertyName, propertyValue))
                    {
                        // If control supports IAttributeAccessor (which it should)
                        // use it to set a custom attribute.

                        IAttributeAccessor a = parentObject as IAttributeAccessor;
                        if (a != null)
                        {
                            a.SetAttribute(propertyName, propertyValue);
                        }
                        else
                        {
                            throw new ArgumentException(
                                SR.GetString(SR.DeviceSpecificChoice_OverridingPropertyNotFound,
                                         propertyName));
                        }
                    }
                }
            }
        }

        private bool FindAndApplyProperty(Object parentObject, String name, String value)
        {
            PropertyDescriptor pd = TypeDescriptor.GetProperties(parentObject).Find(name, true);
            if (pd == null)
            {
                return false;
            }

            // Make sure the property is declarable.

            if (pd.Attributes.Contains(DesignerSerializationVisibilityAttribute.Hidden)) 
            {
                throw new ArgumentException(
                    SR.GetString(SR.DeviceSpecificChoice_OverridingPropertyNotDeclarable, name));
            }

            Object o;
            Type type = pd.PropertyType;

            if (type.IsAssignableFrom(typeof(String)))
            {
                o = value;
            }
            else if (type.IsAssignableFrom(typeof(int)))
            {
                o = Int32.Parse(value);
            }
            else if (type.IsEnum)
            {
                o = Enum.Parse(type, value, true);
            }
            else if (value.Length == 0)
            {
                o = null;
            }
            else
            {
                TypeConverter converter = pd.Converter;
                if (converter != null)
                {
                    o = converter.ConvertFromInvariantString(value);
                }
                else
                {
                    throw new InvalidCastException(
                        SR.GetString(SR.DeviceSpecificChoice_OverridingPropertyTypeCast, name));
                }
            }
            pd.SetValue(parentObject, o);
            return true;
        }

        private bool FindAndApplyEvent(Object parentObject, String name, String value)
        {
            if (name.Length > 2 &&
                    Char.ToLower(name[0], CultureInfo.InvariantCulture) == 'o' &&
                    Char.ToLower(name[1], CultureInfo.InvariantCulture) == 'n')
            {
                String eventName = name.Substring(2);
                EventDescriptor ed = TypeDescriptor.GetEvents(parentObject).Find(eventName, true);
                if (ed != null)
                {
                    Delegate d = Delegate.CreateDelegate(ed.EventType, Owner.MobilePage, value);
                    ed.AddEventHandler(parentObject, d);
                    return true;
                }
            }
            return false;
        }

        internal DeviceSpecific Owner
        {
            get
            {
                return _owner;
            }

            set
            {
                _owner = value;
            }
        }

        internal bool Evaluate(MobileCapabilities capabilities)
        {
            // Evaluate the <Choice> by first looking to see if it's null, then
            // checking against evaluators defined in code on the page, then by
            // consulting the MobileCapabilities object.
            bool result;
            if (_deviceFilter == String.Empty)
            {
                // indicates device-independent <choice> clause
                result = true;
            }
            else if (CheckOnPageEvaluator(capabilities, out result))
            {
                // result already been set through the out-bound parameter
                // above. 
            }
            else
            {
                // The exception message generated by HasCapability() failing is 
                // inappropriate, so we substitute a more specific one.
                try
                {
                    result = capabilities.HasCapability(_deviceFilter, _argument);
                }
                catch (Exception)
                {
                    throw new ArgumentException(SR.GetString(
                                    SR.DeviceSpecificChoice_CantFindFilter,
                                    _deviceFilter));
                }
                
            }

            return result;
        }

        // Return true if specified evaluator exists on the page with the
        // correct signature.  If it does, return result of invoking it in
        // evaluatorResult. 
        private bool CheckOnPageEvaluator(MobileCapabilities capabilities,
                                          out bool evaluatorResult)
        {
            evaluatorResult = false;
            TemplateControl containingTemplateControl = Owner.ClosestTemplateControl;

            MethodInfo methodInfo =
                containingTemplateControl.GetType().GetMethod(_deviceFilter,
                                                              new Type[]
                                                              {
                                                                  typeof(MobileCapabilities), 
                                                                  typeof(String)
                                                              }
                    );

            if (methodInfo == null || methodInfo.ReturnType != typeof(bool))
            {
                return false;
            }
            else
            {
                evaluatorResult = (bool)
                    methodInfo.Invoke(containingTemplateControl,
                                      new Object[]
                                      {
                                          capabilities,
                                          _argument
                                      }
                                     );

                return true;
            }
        }

        String IAttributeAccessor.GetAttribute(String key)
        {
            Object o = Contents[key];
            if (o != null & !(o is String))
            {
                throw new ArgumentException(SR.GetString(
                            SR.DeviceSpecificChoice_PropertyNotAnAttribute));
            }
            return (String)o;
        }

        void IAttributeAccessor.SetAttribute(String key, String value)
        {
            Contents[key] = value;
        }

        void IParserAccessor.AddParsedSubObject(Object obj)
        {
            DeviceSpecificChoiceTemplateContainer c = obj as DeviceSpecificChoiceTemplateContainer;
            if (c != null)
            {
                Templates[c.Name] = c.Template;
            }
        }
    }

    // TEMPLATE BAG
    //
    // The following classes are public by necessity (since they are exposed to
    // the framework), but all internal to the DeviceSpecificChoice. They have to do with
    // persistence of arbitrary templates in a choice. Here's a description of what is done:
    //
    // ASP.NET provides no way for an object or control to allow an arbitrary bag of 
    // templates. It only allows one way to define templates - the parent object must have
    // a property, of type ITemplate, with the same name as the template name. For example,
    // the code
    //
    //      <ParentCtl>
    //          <FirstTemplate>....</FirstTemplate>
    //          <SecondTemplate>....</SecondTemplate>
    //          <ThirdTemplate>....</ThirdTemplate>
    //      </ParentCtl>
    //
    // only works if the ParentCtl class exposes ITemplate properties with names FirstTemplate,
    // SecondTemplate, and ThirdTemplate.
    //
    // Because Choices apply to any control, that could potentially require any named template,
    // what we really need is something like a "template bag" that takes arbitrary templates.
    //
    // To work around this, here's what is done. First, at compile time:
    //
    // 1) DeviceSpecificChoice has its own control builder at compile time. When it is given a
    //    sub-object (in GetChildControlType), it returns DeviceSpecificChoiceTemplateType, which
    //    is a marker type similar to that used in ASP.NET. However, it is our own class, and
    //    has DeviceSpecificChoiceTemplateBuilder as its builder.
    // 2) DeviceSpecificChoiceTemplateBuilder inherits from TemplateBuilder, and thus has the same
    //    behavior as TemplateBuilder for parsing and compiling a template. However, it has
    //    an overriden Init method, which changes the tag name (and thus, the template name) 
    //    to a constant, "Template". It also saves the real template name in a property.
    // 3) When parsed, the framework calls the AppendSubBuilder method of the 
    //    DeviceSpecificChoiceBuilder, to add the template builder into it. But this builder
    //    first creates an intermediate builder, for the class DeviceSpecificChoiceTemplateContainer,
    //    adding the template name as a property in the builder's attribute dictionary. It then
    //    adds the intermediate builder into itself, and the template builder into it.
    //
    // All this has the net effect of automatically transforming something like
    //
    //      <Choice>
    //          <ItemTemplate>...</ItemTemplate>
    //          <HeaderTemplate>...</HeaderTemplate>
    //      </Choice>
    // 
    // into
    //
    //      <Choice>
    //          <DeviceSpecificChoiceTemplateContainer Name="ItemTemplate">
    //              <Template>...</Template>
    //          </DeviceSpecificChoiceTemplateContainer>
    //          <DeviceSpecificChoiceTemplateContainer Name="HeaderTemplate">
    //              <Template>...</Template>
    //          </DeviceSpecificChoiceTemplateContainer>
    //      </Choice>
    //
    // Now, at runtime the compiled code creates a DeviceSpecificChoiceTemplateContainer object,
    // and calls the AddParsedSubObject method of the DeviceSpecificChoice with it. This code (above)
    // then extracts the template referred to by the Template property of the object, and 
    // uses the Name property to add it to the template bag. Presto, we have a general template bag.

    /*
     * DeviceSpecificChoice control builder. For more information, see note on "Template Bag" above.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecificChoiceControlBuilder : ControlBuilder
    {
        private bool _isDeviceIndependent = false;
        internal bool IsDeviceIndependent()
        {
            return _isDeviceIndependent;
        }

        public override void Init(TemplateParser parser, 
                                  ControlBuilder parentBuilder,
                                  Type type, 
                                  String tagName, 
                                  String id, 
                                  IDictionary attributes) 
        {
            if (!(parentBuilder is DeviceSpecificControlBuilder))
            {
                throw new ArgumentException(
                    SR.GetString(SR.DeviceSpecificChoice_ChoiceOnlyExistInDeviceSpecific));
            }

            _isDeviceIndependent = attributes == null || attributes["Filter"] == null;

            base.Init (parser, parentBuilder, type, tagName, id, attributes);
        }

        public override void AppendLiteralString(String text)
        {
            // Ignore literal strings.
        }

        public override Type GetChildControlType(String tagName, IDictionary attributes) 
        {
            // Assume children are templates.

            return typeof(DeviceSpecificChoiceTemplateType);
        }

        public override void AppendSubBuilder(ControlBuilder subBuilder) 
        {
            DeviceSpecificChoiceTemplateBuilder tplBuilder = 
                subBuilder as DeviceSpecificChoiceTemplateBuilder;
            if (tplBuilder != null)
            {
                // Called to add a template. Insert an intermediate control, 
                // by creating and adding its builder.

                ListDictionary dict = new ListDictionary();

                // Add the template's name as a Name attribute for the control.
                dict["Name"] = tplBuilder.TemplateName;

                // 1 and "xxxx" are bogus filename/line number values.
                ControlBuilder container = ControlBuilder.CreateBuilderFromType(
                                                Parser, this, 
                                                typeof(DeviceSpecificChoiceTemplateContainer),
                                                "Templates",
                                                null, dict, 1, "xxxx");
                base.AppendSubBuilder(container);

                // Now, append the template builder into the new intermediate builder.

                container.AppendSubBuilder(subBuilder);
            }
            else
            {
                base.AppendSubBuilder(subBuilder);
            }
        }
    }

    /*
     * DeviceSpecificChoiceTemplateType - marker type for a template that goes inside
     *      a Choice. Used only at compile time, and never instantiated. See note
     *      on "Template Bag" above.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ControlBuilderAttribute(typeof(DeviceSpecificChoiceTemplateBuilder))
    ]
    internal class DeviceSpecificChoiceTemplateType : Control, IParserAccessor

    {
        private DeviceSpecificChoiceTemplateType()
        {
        }

        void IParserAccessor.AddParsedSubObject(Object o)
        {
        }
    }

    /*
     * DeviceSpecificChoiceTemplateBuilder - builder for a template that goes inside
     *      a Choice. See note on "Template Bag" above.
     *      When a Choice is device-independent, it also parses literal text content.
     *      The code for this is copied from LiteralTextContainerControlBuilder.cs
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecificChoiceTemplateBuilder : TemplateBuilder
    {
        private String _templateName;
        private bool _doLiteralText = false;
        private bool _controlsInserted = false;

        internal String TemplateName
        {
            get
            {
                return _templateName;
            }
        }

        CompileLiteralTextParser _textParser = null;
        internal CompileLiteralTextParser TextParser
        {
            get
            {
                if (_textParser == null)
                {
                    _textParser = 
                        new CompileLiteralTextParser(Parser, this, "xxxx", 1);
                    if (_controlsInserted)
                    {
                        _textParser.ResetBreaking();
                        _textParser.ResetNewParagraph();
                    }
                }
                return _textParser;
            }
        }

        public override void Init(TemplateParser parser, 
                                  ControlBuilder parentBuilder,
                                  Type type, 
                                  String tagName,
                                  String id, 
                                  IDictionary attributes) 
        {
            // Save off template name, and always pass the name "Template" to the base
            // class, because the intermediate object has this property as the name.

            _templateName = tagName;
            base.Init(parser, parentBuilder, type, "Template", id, attributes);

            // Are we a device-independent template?

            if (!InDesigner)
            {
                DeviceSpecificChoiceControlBuilder choiceBuilder = 
                    parentBuilder as DeviceSpecificChoiceControlBuilder;
                _doLiteralText = choiceBuilder != null && choiceBuilder.IsDeviceIndependent();
            }
        }

        public override void AppendLiteralString(String text)
        {
            if (_doLiteralText)
            {
                if (LiteralTextParser.IsValidText(text))
                {
                    TextParser.Parse(text);
                }
            }
            else
            {
                base.AppendLiteralString(text);
            }
        }

        public override void AppendSubBuilder(ControlBuilder subBuilder)
        {
            if (_doLiteralText)
            {
                // The first one is used if ASP.NET is compiled with FAST_DATABINDING off. The second
                // is used if it is compiled with FAST_DATABINDING on. Note: We can't do a type 
                // comparison because CodeBlockBuilder is internal.
                // if (typeof(DataBoundLiteralControl).IsAssignableFrom(subBuilder.ControlType))
                if (subBuilder.GetType().FullName == "System.Web.UI.CodeBlockBuilder")
                {
                    TextParser.AddDataBinding(subBuilder);
                }
                else
                {
                    base.AppendSubBuilder(subBuilder);
                    if (subBuilder.ControlType != typeof(LiteralText))
                    {
                        if (_textParser != null)
                        {
                            _textParser.ResetBreaking();
                        }
                        else
                        {
                            _controlsInserted = true;
                        }
                    }
                }
            }
            else
            {
                base.AppendSubBuilder(subBuilder);
            }
        }

    }

    /*
     * DeviceSpecificChoiceTemplateContainer - "dummy" container object for 
     *      a template that goes inside a Choice. Once the Choice receives and
     *      extracts the information out of it, this object is simply discarded.
     *      See note on "Template Bag" above.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecificChoiceTemplateContainer
    {
        private ITemplate _template;
        private String _name;

        [
            TemplateContainer(typeof(TemplateContainer)),
        ]
        public ITemplate Template
        {
            get
            {
                return _template;
            }
            set
            {
                _template = value;
            }
        }

        public String Name
        {
            get
            {
                return _name;
            }
            set
            {
                _name = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\factorygenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="FactoryGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using System.Security;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Factory Generator class
     * A factory generator is useful for cases where a large number of late-bound
     * classes need to be instantiated.
     *
     * Normally, to create an instance of type t, you call the following code:
     *
     *      ISomeInterface o = Activator.CreateInstance(t);
     *
     * This assumes that the default constructor is used, and that the type t
     * implements the interface ISomeInterface.
     *
     * The factory generator, on the other hand, can use reflection emit APIs
     * to dynamically generate a class factory for t. The generated class has
     * the equivalent of the following code:
     *
     *      class X : ISomeInterfaceFactory
     *      {
     *          public ISomeInterface CreateInstance()
     *          {
     *              return new t();
     *          }
     *      }
     *
     * It then instantiates and returns an object of this type. You can then
     * call CreateInstance to create an instance of the type, which is 
     * significantly faster.
     *
     * A single instance of a FactoryGenerator can generate factories for 
     * multiple types. However, it builds all these types into a single
     * dynamically generated assembly. CLR implementation prevents this
     * assembly from being unloaded until the process exits.
     *
     * The FactoryGenerator is (almost) a templated type. It takes two
     * types in its constructor:
     *
     *   returnedType is the type common to all classes for which factories
     *      are to be generated. In the example above, this would be 
     *      ISomeInterface.
     *   factoryInterface is the interface implemented by the dynamically
     *      generated class factory, and should include a method named
     *      CreateInstance, that takes no parameters and returns an object
     *      of the type specified by returnedType. In the example above,
     *      this would be ISomeInterfaceFactory.
     *
     * Copyright (c) 2001 Microsoft Corporation
     */

    internal class FactoryGenerator
    {
        private Type _factoryInterface;
        private Type _returnedType;
        private MethodInfo _methodToOverride;
        private ModuleBuilder _dynamicModule = null;
        private Type[] _emptyParameterList = new Type[] { };
        private Type[] _interfacesToImplement;

        internal FactoryGenerator(Type returnedType, Type factoryInterface)
        {
            _returnedType = returnedType;
            _factoryInterface = factoryInterface;

            // Get the CreateInstance method, and make sure it has
            // the correct signature.

            _methodToOverride = factoryInterface.GetMethod("CreateInstance");
            if (_methodToOverride.ReturnType != _returnedType ||
                _methodToOverride.GetParameters().Length != 0)
            {
                throw new ArgumentException("factoryInterface");
            }

            // This will be needed later, when building the dynamic class.
            _interfacesToImplement = new Type[1];
            _interfacesToImplement[0] = factoryInterface;
        }

        private static String GetUniqueCompilationName()
        {
            return Guid.NewGuid().ToString().Replace('-', '_');
        }

        internal /*public*/ Object CreateFactory(Type type)
        {
            // Create the dynamic assembly if needed.

            Type factoryType;
            try {
                IStackWalk reflection = new ReflectionPermission(ReflectionPermissionFlag.ReflectionEmit);
                reflection.Assert();

                if (_dynamicModule == null)
                {
                    // Use a unique name for each assembly.
                    String name = GetUniqueCompilationName();
    
                    AssemblyName assemblyName = new AssemblyName();
                    assemblyName.Name = "A_" + name;
    
                    // Create a new assembly.
                    AssemblyBuilder newAssembly =
                        Thread.GetDomain().DefineDynamicAssembly(assemblyName,
                                                                 AssemblyBuilderAccess.Run,
                                                                 null, //directory to persist assembly
                                                                 null, //evidence copied from caller
                                                                 null, //requiredPermissions
                                                                 null, //optionalPermissions
                                                                 null, //refused permissions
                                                                 true  //isSynchronized
                                                                 );
    
                    // Create a single module in the assembly.
                    _dynamicModule = newAssembly.DefineDynamicModule("M_" + name);
                }
    
                // Give the factory a unique name.
    
                String typeName = GetUniqueCompilationName();
                TypeBuilder factoryTypeBuilder = _dynamicModule.DefineType("T_" + typeName, 
                                                                           TypeAttributes.Public,
                                                                           typeof(Object),
                                                                           _interfacesToImplement);
    
                // Define the CreateInstance method. It must be virtual to be an interface implementation.
    
                MethodBuilder method = factoryTypeBuilder.DefineMethod("CreateInstance", 
                                                                       MethodAttributes.Public | 
                                                                            MethodAttributes.Virtual,
                                                                       _returnedType,
                                                                       null);
    
                // Generate IL. The generated IL corresponds to "return new type()"
                //      newobj <type_constructor>
               //      ret

                ILGenerator il = method.GetILGenerator();
                ConstructorInfo cons = type.GetConstructor(_emptyParameterList);
                il.Emit(OpCodes.Newobj, cons);
                il.Emit(OpCodes.Ret);
    
                // Specify that this method implements CreateInstance from the inherited interface.
                factoryTypeBuilder.DefineMethodOverride(method, _methodToOverride);
    
                // Bake in the type.
                factoryType = factoryTypeBuilder.CreateType();
    
                // Create the type. This is the only place where Activator.CreateInstance is used,
                // reducing the calls to it from 1 per adapter instance to 1 per adapter type.
            }
            finally {
                CodeAccessPermission.RevertAssert();
            }
            return Activator.CreateInstance(factoryType);
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\devicespecific.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceSpecific.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.Mobile;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * DeviceSpecific object.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ControlBuilderAttribute(typeof(DeviceSpecificControlBuilder)),
        Designer(typeof(System.Web.UI.Design.MobileControls.DeviceSpecificDesigner)),
        ParseChildren(false),
        PersistChildren(false),
        PersistName("DeviceSpecific"),
        ToolboxData("<{0}:DeviceSpecific runat=\"server\"></{0}:DeviceSpecific>"),
        ToolboxItemFilter("System.Web.UI"),
        ToolboxItemFilter("System.Web.UI.MobileControls", ToolboxItemFilterType.Require),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecific : Control
    {
        private DeviceSpecificChoiceCollection _choices;
        private DeviceSpecificChoice _selectedChoice;
        private bool _haveSelectedChoice;
        private Object _owner;

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public Object Owner
        {
            get
            {
                Debug.Assert(_owner != null, "Owner is null");
                return _owner;
            }
        }

        internal void SetOwner(Object owner)
        {
            Debug.Assert((_owner == null || MobilePage == null || MobilePage.DesignMode), "Owner has already been set");
            _owner = owner;
        }

        [
            Browsable(false),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public DeviceSpecificChoiceCollection Choices
        {
            get
            {
                if (_choices == null)
                {
                    _choices = new DeviceSpecificChoiceCollection(this);
                }
                return _choices;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public bool HasTemplates
        {
            get
            {
                return (SelectedChoice != null) ?
                            _selectedChoice.HasTemplates :
                            false;
            }
        }

        public ITemplate GetTemplate(String templateName)
        {
            return (SelectedChoice != null) ? 
                _selectedChoice.Templates[templateName] as ITemplate : 
                null;
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public DeviceSpecificChoice SelectedChoice
        {
            get
            {
                if (!_haveSelectedChoice)
                {
                    _haveSelectedChoice = true;

                    HttpContext context = HttpContext.Current;
                    if (context == null)
                    {
                        return null;
                    }

                    MobileCapabilities caps = (MobileCapabilities)context.Request.Browser;
                    if (_choices != null)
                    {
                        foreach (DeviceSpecificChoice choice in _choices)
                        {
                            if (choice.Evaluate(caps))
                            {
                                _selectedChoice = choice;
                                break;
                            }
                        }
                    }
                }
                return _selectedChoice;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public MobilePage MobilePage
        {
            get
            {
                if (Owner is Style)
                {
                    return ((Style)Owner).Control.MobilePage;
                }
                else 
                {
                    Debug.Assert(Owner is MobileControl);
                    return ((MobileControl)Owner).MobilePage;
                }
            }
        }

        protected override void AddParsedSubObject(Object obj)
        {
            DeviceSpecificChoice choice = obj as DeviceSpecificChoice; 
            if (choice != null)
            {
                Choices.Add(choice);
            }
        }

        internal void ApplyProperties()
        {
            if (SelectedChoice != null)
            {
                _selectedChoice.ApplyProperties();
            }
        }

        // Walk up the control parent hierarchy until we find either a
        // MobilePage or a UserControl.
        private TemplateControl _closestTemplateControl = null;
        internal TemplateControl ClosestTemplateControl
        {
            get
            {
                if (_closestTemplateControl == null)
                {
                    Style asStyle = Owner as Style;
                    MobileControl control = 
                        (asStyle != null) ? asStyle.Control : (MobileControl)Owner;

                    _closestTemplateControl =
                        control.FindContainingTemplateControl();
                    Debug.Assert(_closestTemplateControl != null);
                }
                return _closestTemplateControl;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN DESIGNER SUPPORT
        /////////////////////////////////////////////////////////////////////////

        [
            Browsable(false),
        ]
        public new event EventHandler Init
        {
            add
            {
                base.Init += value;
            }
            remove
            {
                base.Init -= value;
            }
        }

        [
            Browsable(false),
        ]
        public new event EventHandler Load
        {
            add
            {
                base.Load += value;
            }
            remove
            {
                base.Load -= value;
            }
        }

        [
            Browsable(false),
        ]
        public new event EventHandler Unload
        {
            add
            {
                base.Unload += value;
            }
            remove
            {
                base.Unload -= value;
            }
        }

        [
            Browsable(false),
        ]
        public new event EventHandler PreRender
        {
            add
            {
                base.PreRender += value;
            }
            remove
            {
                base.PreRender -= value;
            }
        }

        [
            Browsable(false),
        ]
        public new event EventHandler Disposed
        {
            add
            {
                base.Disposed += value;
            }
            remove
            {
                base.Disposed -= value;
            }
        }
        
        [
            Browsable(false),
        ]
        public new event EventHandler DataBinding
        {
            add
            {
                base.DataBinding += value;
            }
            remove
            {
                base.DataBinding -= value;
            }
        }

        internal void SetDesignerChoice(DeviceSpecificChoice choice)
        {
            // This will enforce SelectedChoice to return current choice.
            _haveSelectedChoice = true;
            _selectedChoice = choice;
        }

        // Do not expose the Visible property in the Designer
        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override bool Visible 
        {
            get
            {
                return base.Visible;
            }
            set
            {
                base.Visible = value;
            }
        }

        // Do not expose the EnableViewState property in the Designer
        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override bool EnableViewState
        {
            get
            {
                return base.EnableViewState;
            }
            set
            {
                base.EnableViewState = value;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  END DESIGNER SUPPORT
        /////////////////////////////////////////////////////////////////////////
    }

    /*
     * DeviceSpecific control builder.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class DeviceSpecificControlBuilder : ControlBuilder
    {
        public override void AppendLiteralString(String text)
        {
            // Ignore.
        }

        public override Type GetChildControlType(String tagName, IDictionary attributes) 
        {
            if (String.Compare(tagName, "Choice", true, CultureInfo.InvariantCulture) == 0)
            {
                return typeof(DeviceSpecificChoice);
            }
            else 
            {
                throw new Exception(SR.GetString(SR.DeviceSpecific_OnlyChoiceElementsAllowed));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\form.cs ===
//------------------------------------------------------------------------------
// <copyright file="Form.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.Mobile;
using System.Web.UI;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    [
        ControlBuilderAttribute(typeof(FormControlBuilder)),
        DefaultEvent("Activate"),
        Designer(typeof(System.Web.UI.Design.MobileControls.FormDesigner)),
        DesignerAdapter(typeof(System.Web.UI.MobileControls.Adapters.HtmlFormAdapter)),
        PersistChildren(true),
        ToolboxData("<{0}:Form runat=\"server\"></{0}:Form>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Form : Panel, ITemplateable, IPostBackEventHandler
    {

        private static readonly Object EventActivate         = new Object();
        private static readonly Object EventDeactivate       = new Object();
        private static readonly Object EventPaginated        = new Object();

        private PagerStyle _pagerStyle;
        private int _cachedCurrentPage = -1;
        private Panel _headerContainer = null;
        private Panel _footerContainer = null;
        private Panel _scriptContainer = null;

        public Form()
        {
            _pagerStyle = new PagerStyle();
            _pagerStyle.SetControl(this);
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets the title used to identify the form.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       The title may be rendered as part of the form, on devices
        ///       that support a title separate from page content (e.g., on
        ///       the title bar of a browser using the title tag in HTML).
        ///    </para>
        /// </value>
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Form_Title)
        ]
        public String Title
        {
            get
            {
                String s = (String) ViewState["Title"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["Title"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(FormMethod.Post),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Form_Method)
        ]
        public FormMethod Method
        {
            get
            {
                Object o = ViewState["Method"];
                return ((o != null) ? (FormMethod)o : FormMethod.Post);
            }
            set
            {
                ViewState["Method"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Web.UI.Design.UrlEditor),
                typeof(System.Drawing.Design.UITypeEditor)),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Form_Action)
        ]
        public String Action
        {
            get
            {
                String s = (String) ViewState["Action"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["Action"] = value;
            }
        }

        [
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            MobileCategory(SR.Category_Style),
            MobileSysDescription(SR.Form_PagerStyle),
            NotifyParentProperty(true)
        ]
        public PagerStyle PagerStyle
        {
            get
            {
                return _pagerStyle;
            }
        }

        void IPostBackEventHandler.RaisePostBackEvent(String eventArgument)
        {
            // If the event argument is all numeric, then it's a pager event.

            bool notANumber = false;
            int length = eventArgument.Length;
            for (int i = 0; i < length; i++)
            {
                char c = eventArgument[i];
                if (c < '0' || c > '9')
                {
                    notANumber = true;
                    break;
                }
            }

            if (!notANumber && length > 0)
            {
                try
                {
                    int page = Int32.Parse(eventArgument);
                    if (page > 0)
                    {
                        int oldPage = _currentPage;
                        if(_cachedCurrentPage == -1)
                        {
                            _currentPage = page;
                            _cachedCurrentPage = page;
                        }

                        // currentpage may != page if page is invalid
                        OnPageChange(oldPage, _currentPage);
                    }
                    return;
                }
                catch
                {
                    // Argument may be invalid number, so let adapter handle it.
                }
            }

            Adapter.HandlePostBackEvent(eventArgument);
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.Form_OnActivate)
        ]
        public event EventHandler Activate
        {
            add
            {
                Events.AddHandler(EventActivate, value);
            }
            remove
            {
                Events.RemoveHandler(EventActivate, value);
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.Form_OnDeactivate)
        ]
        public event EventHandler Deactivate
        {
            add
            {
                Events.AddHandler(EventDeactivate, value);
            }
            remove
            {
                Events.RemoveHandler(EventDeactivate, value);
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.Form_OnPaginated)
        ]
        public event EventHandler Paginated
        {
            add
            {
                Events.AddHandler(EventPaginated, value);
            }
            remove
            {
                Events.RemoveHandler(EventPaginated, value);
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Panel Header
        {
            get
            {
                return _headerContainer;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Panel Footer
        {
            get
            {
                return _footerContainer;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Panel Script
        {
            get
            {
                return _scriptContainer;
            }
        }

        internal bool Activated = false;

        internal void FireActivate(EventArgs e)
        {
            if (!Activated)
            {
                Activated = true;
                OnActivate(e);
            }
        }

        internal void FireDeactivate(EventArgs e)
        {
            if (Activated)
            {
                Activated = false;
                OnDeactivate(e);
            }
        }

        protected virtual void OnActivate(EventArgs e)
        {
            EventHandler onActivate = (EventHandler)Events[EventActivate];
            if (onActivate != null)
            {
                onActivate(this, e);
            }
        }

        protected virtual void OnDeactivate(EventArgs e)
        {
            EventHandler onDeactivate = (EventHandler)Events[EventDeactivate];
            if (onDeactivate != null)
            {
                onDeactivate(this, e);
            }
        }

        public virtual bool HasActivateHandler()
        {
            return Events[EventActivate] != null;
        }

        public virtual bool HasDeactivateHandler()
        {
            return Events[EventDeactivate] != null;
        }

        protected virtual void OnPaginated(EventArgs e)
        {
            EventHandler onPaginated = (EventHandler)Events[EventPaginated];
            if (onPaginated != null)
            {
                onPaginated(this, e);
            }
        }

        protected override void OnInit(EventArgs e)
        {
            if (MobilePage != null && !MobilePage.DesignMode)
            {
                // Be sure we're not included in any other Forms.
                for (Control control = this.Parent; control != null; control = control.Parent)
                {
                    Form parentForm = control as Form;
                    if (parentForm != null)
                    {
                        throw new Exception(SR.GetString(SR.Form_NestedForms,
                            this.ID,
                            parentForm.ID));
                    }
                }
            }
            
            base.OnInit(e);
        }

        public IList GetLinkedForms(int optimumPageWeight)
        {
            // Always add itself to the list as the first one
            UniqueSet set = new UniqueSet();
            set.Add(this);

            // If the form has a deactivate handler, then we
            // can't send the form with linked forms, because server interaction
            // is necessary to move between forms.

            if (HasDeactivateHandler())
            {
                return set;
            }

            // Will stop once no new forms are added in a pass, or has
            // reached the optimum page weight.

            int totalWeight = 0;
            int i;

            // negative means the caller doesn't care about the weight
            bool checkWeight = optimumPageWeight >= 0;

            for (i = 0; i < set.Count; i++)
            {
                Form form = (Form)set[i];

                if (checkWeight)
                {
                    totalWeight += form.GetVisibleWeight();
                    if (totalWeight > optimumPageWeight)
                    {
                        break;
                    }
                }
                form.AddLinkedForms(set);
            }

            // More forms may have been linked than the total weight allows.
            // Remove these.

            if (i != 0 &&  // i == 0 means only one form is in the list
                i < set.Count)
            {
                for (int j = set.Count - 1; j >= i; j--)
                {
                    set.RemoveAt(j);
                }
            }

            return set;
        }

        public override void CreateDefaultTemplatedUI(bool doDataBind) 
        {
            ITemplate headerTemplate = GetTemplate(Constants.HeaderTemplateTag);
            ITemplate footerTemplate = GetTemplate(Constants.FooterTemplateTag);
            ITemplate scriptTemplate = GetTemplate(Constants.ScriptTemplateTag);

            if (scriptTemplate != null)
            {
                _scriptContainer = new TemplateContainer();
                // The scriptTemplate is not added to the controls tree, so no need to do
                // CheckedInstantiateTemplate to check for infinite recursion.
                scriptTemplate.InstantiateIn(_scriptContainer);
                _scriptContainer.EnablePagination = false;
            }

            if (headerTemplate != null)
            {
                _headerContainer = new TemplateContainer();
                CheckedInstantiateTemplate (headerTemplate, _headerContainer, this);
                _headerContainer.EnablePagination = false;
                Controls.AddAt(0, _headerContainer);
            }
            
            if (footerTemplate != null)
            {
                _footerContainer = new TemplateContainer();
                CheckedInstantiateTemplate (footerTemplate, _footerContainer, this);
                _footerContainer.EnablePagination = false;
                Controls.Add(_footerContainer);
            }

            // Do not call base.CreateDefaultTemplatedUI(), since we don't want
            // Forms to have ContentTemplates as Panels do.
        }

        private int _pageCount = -1;
        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int PageCount
        {
            get
            {
                // If not yet paginated, it's okay to return -1.

                return _pageCount;
            }
        }

        private int _currentPage = 1;
        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int CurrentPage
        {
            get
            {
                return _currentPage;
            }
            set
            {
                if (_currentPage != value) 
                {
                    OnPageChange (_currentPage, value);
                }
                _currentPage = value;
                _cachedCurrentPage = _currentPage;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never)
        ]
        public override bool BreakAfter
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return true;
                }
                throw new Exception(
                    SR.GetString(SR.Form_PropertyNotAccessible, "BreakAfter"));
            }

            set
            {
                throw new Exception(
                    SR.GetString(SR.Form_PropertyNotSettable, "BreakAfter"));
            }
        }

        protected override void OnPreRender(EventArgs e)
        {
            // AUI 3630
            base.OnPreRender(e);

            _pageCount = PaginateForm();

            // Clamp to 1 < _currentPage <= PageCount

            int page = Math.Max(Math.Min(_currentPage, _pageCount), 1);
            if(_currentPage != page)
            {
                _currentPage = page;
            }

            if ((Paginate) || (ControlToPaginate != null))
            {
                OnPaginated(new EventArgs());
            }
        }

        protected override void Render(HtmlTextWriter writer)
        {
            MobilePage.EnterFormRender(this);
            OnRender(writer);
            MobilePage.ExitFormRender();
        }

        private int PaginateForm()
        {
            int pageWeight = MobilePage.Adapter.OptimumPageWeight;
            if (Header != null)
            {
                pageWeight -= Header.VisibleWeight;
            }
            if (Footer != null)
            {
                pageWeight -= Footer.VisibleWeight;
            }
            if (pageWeight <= 0)
            {
                //TODO: if the header and footer more than consume the page
                // perhaps we should throw an error
                // weights are estimated, so just reduce pageWeight by half
                pageWeight = MobilePage.Adapter.OptimumPageWeight / 2;
            }

            if (IsFormPaginationAllowed())
            {
                if ((Paginate) || (ControlToPaginate == this))
                {
                    ControlPager pager = new ControlPager(this, pageWeight);
                    base.PaginateRecursive(pager);
                    return pager.PageCount;
                }
                else if(ControlToPaginate != null)
                {
                    ControlPager pager = new ControlPager(this, pageWeight);
                    SetControlPage(1);
                    Control control = ControlToPaginate;
                    MobileControl ctp = control as MobileControl;
                    if(ctp != null) 
                    {
                        ctp.PaginateRecursive(pager);
                    }
                    else 
                    {
                        int firstAssignedPage = -1;
                        DoPaginateChildren(pager, control, ref firstAssignedPage);
                    }
                    while(control != this)
                    {
                        MobileControl mc = control as MobileControl;
                        if(mc != null)
                        {
                            if(mc is Form)
                            {
                                throw(new Exception(SR.GetString(SR.Form_InvalidControlToPaginateForm)));
                            }
                            if (mc.FirstPage > ctp.FirstPage)
                            {
                                mc.FirstPage = ctp.FirstPage;
                            }
                            if(mc.LastPage < ctp.LastPage)
                            {
                                mc.LastPage = ctp.LastPage;
                            }
                        }
                        control = control.Parent;
                    }
                    this.LastPage = Math.Max(pager.PageCount, 1);
                    if(Header != null)
                    {
                        SetEnablePaginationRecursive(Header, false);
                    }
                    if(Footer != null)
                    {
                        SetEnablePaginationRecursive(Footer, false);
                    }
                    return this.LastPage;
                }
            }
            
            return 1;
        }

        private bool IsFormPaginationAllowed()
        {
            // AUI 4721

            if (Action.Length == 0)
            {
                return true;
            }

            MobileCapabilities device = (MobileCapabilities)Page.Request.Browser;
            String type = device.PreferredRenderingType;
            bool javascriptSupported = device.JavaScript;

            return javascriptSupported || 
                    (type != MobileCapabilities.PreferredRenderingTypeHtml32 &&
                     type != MobileCapabilities.PreferredRenderingTypeChtml10);
        }

        public override void PaginateRecursive(ControlPager pager)
        {
            _pageCount = PaginateForm();
        }

        protected override bool PaginateChildren
        {
            get
            {
                return true;
            }
        }

        private Control _controlToPaginate = null;

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Control ControlToPaginate
        {
            get
            {
                if(_controlToPaginate != null)
                {
                    return _controlToPaginate;
                }
                if(ViewState["ControlToPaginate"] != null)
                {
                    _controlToPaginate = Page.FindControl((ViewState["ControlToPaginate"]).ToString());
                }
                return _controlToPaginate;
            }
            set
            {
                if(value != null)
                {
                    ViewState["ControlToPaginate"] = value.UniqueID;
                }
                else
                {
                    ViewState.Remove("ControlToPaginate");
                }
                _controlToPaginate = value;
            }
        }

        protected override void LoadPrivateViewState(Object state)
        {
            _currentPage = state != null ? (int)state : 1;
        }

        protected override Object SavePrivateViewState()
        {
            int currentPage = _currentPage;
            if (currentPage > 1 && this == MobilePage.ActiveForm)
            {
                return currentPage;
            }
            else
            {
                return null;
            }
        }

        protected override void OnDataBinding(EventArgs e)
        {
            if(Script != null)
            {
                Script.DataBind();
            }
            base.OnDataBinding(e);
        }

        private IPostBackEventHandler _defaultEventHandler = null;
        internal void RegisterEventHandler(IPostBackEventHandler control)
        {
            if (_defaultEventHandler == null)
            {
                _defaultEventHandler = control;
            }
        }

        internal IPostBackEventHandler DefaultEventHandler
        {
            get
            {
                return _defaultEventHandler;
            }
        }

        internal override void InvalidateParentStyles()
        {
            PagerStyle.InvalidateParentStyle();
            base.InvalidateParentStyles();
        }
    }

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class FormControlBuilder : LiteralTextContainerControlBuilder
    {
        public override void AppendSubBuilder(ControlBuilder subBuilder)
        {
            Type controlType = subBuilder.ControlType;
            if(!(
                 (subBuilder.GetType().FullName == "System.Web.UI.CodeBlockBuilder") ||
                 (typeof(MobileControl).IsAssignableFrom(controlType)) ||
                 (typeof(UserControl).IsAssignableFrom(controlType)) ||
                 (typeof(DeviceSpecific).IsAssignableFrom(controlType))
                 ))
            {
                throw(new Exception(SR.GetString(SR.Form_InvalidSubControlType, subBuilder.TagName)));
            }
            base.AppendSubBuilder(subBuilder);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\icontroladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IControlAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Collections.Specialized;

namespace System.Web.UI.MobileControls
{

    /*
     * ControlAdapter Interface.
     * A control adapter handles all of the (potentially) device specific 
     * functionality for a mobile control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    public interface IControlAdapter
    {
        MobileControl Control
        {
            get;
            set;
        }
        MobilePage Page
        {
            get;
        }

        void OnInit(EventArgs e);
        void OnLoad(EventArgs e);
        void OnPreRender(EventArgs e);
        void Render(HtmlTextWriter writer);
        void OnUnload(EventArgs e);
        void CreateTemplatedUI(bool doDataBind);
        bool HandlePostBackEvent(String eventArgument);

        // used by controls that implement IPostBackDataHandler to handle
        // situations where the post data is interpreted based upon generating
        // device.  Returns true if there is no device-specific handling, and
        // the general control should handle it.
        bool LoadPostData(String postDataKey,
                          NameValueCollection postCollection,
                          Object controlPrivateData,
                          out bool dataChanged);
            
        void LoadAdapterState(Object state);
        Object SaveAdapterState();

        int VisibleWeight
        {
            get;
        }
        int ItemWeight
        {
            get;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\icontroladapterfactory.cs ===
//------------------------------------------------------------------------------
// <copyright file="IControlAdapterFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.MobileControls
{
    /*
     * IControlAdapterFactory interface
     *
     * The interface implemented by dynamically generated factories for 
     * instantiating device adapters. This is the factory interface type used 
     * to create the factory generator. For more info, see FactoryGenerator.cs.
     *
     * Copyright (c) 2001 Microsoft Corporation
     */

    internal interface IControlAdapterFactory
    {
        IControlAdapter CreateInstance();
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\ilistcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="IListControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.MobileControls
{
    /*
     * IListControl interface.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal interface IListControl
    {
        void OnItemDataBind(ListDataBindEventArgs e);
        bool TrackingViewState
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\iobjectlistfieldcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="IObjectListFieldCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List Field Collection interface. This provides a read-only base
     * interface for the real object list field collection class, and is used when
     * read-only access to a field collection is desired.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public interface IObjectListFieldCollection : ICollection
    {
        ObjectListField[] GetAll();

        ObjectListField this[int index] 
        {
            get;
        }

        int IndexOf(ObjectListField field);
        int IndexOf(String fieldIDOrTitle);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\image.cs ===
//------------------------------------------------------------------------------
// <copyright file="Image.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.Design.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile Image class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DefaultProperty("ImageUrl"),
        Designer(typeof(System.Web.UI.Design.MobileControls.ImageDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerImageAdapter)),
        ToolboxData("<{0}:Image runat=\"server\"></{0}:Image>"),
        ToolboxItem(typeof(System.Web.UI.Design.WebControlToolboxItem))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Image : MobileControl, IPostBackEventHandler
    {

        // used for linking between panels
        void IPostBackEventHandler.RaisePostBackEvent(String argument)
        {
            MobilePage.ActiveForm = MobilePage.GetForm(argument);
        }
        
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Image_AlternateText)
        ]
        public String AlternateText
        {
            get
            {
                return ToString(ViewState["AlternateText"]);
            }
            set
            {
                ViewState["AlternateText"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Web.UI.Design.MobileControls.ImageUrlEditor),
                   typeof(UITypeEditor)),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Image_ImageUrl)
        ]
        public String ImageUrl
        {
            get
            {
                return ToString(ViewState["ImageUrl"]);
            }
            set
            {
                ViewState["ImageUrl"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Navigation),
            MobileSysDescription(SR.Image_NavigateUrl),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.NavigateUrlConverter))
        ]
        public String NavigateUrl
        {
            get
            {
                return ToString(ViewState["NavigateUrl"]);
            }
            set
            {
                ViewState["NavigateUrl"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Image_SoftkeyLabel)
        ]
        public String SoftkeyLabel
        {
            get
            {
                String s = (String) ViewState["Softkeylabel"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["Softkeylabel"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\ipageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Collections.Specialized;
using System.IO;

namespace System.Web.UI.MobileControls
{
    /*
     * PageAdapter Interface.
     * A control adapter handles all of the (potentially) device specific 
     * functionality for a mobile page.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    public interface IPageAdapter : IControlAdapter
    {
        new MobilePage Page
        {
            get;
            set;
        }

        int OptimumPageWeight
        {
            get;
        }

        IDictionary CookielessDataDictionary
        {
            get;
            set;
        }

        bool PersistCookielessData
        {
            get;
            set;
        }

        //  return null to indicate use base implementation
        HtmlTextWriter CreateTextWriter(TextWriter writer);

        // Each device specific PageAdapter can manipulate the incoming post
        // back value collection and return a new collection.
        NameValueCollection DeterminePostBackMode
        (
            HttpRequest request,
            String postEventSourceID,
            String postEventArgumentID,
            NameValueCollection baseCollection
        );

        // Return a list of additional HTTP headers that want to be keyed for
        // the ASP.NET page output caching mechanism.
        IList CacheVaryByHeaders
        {
            get;
        }

        bool HandleError(Exception e, HtmlTextWriter writer);
        bool HandlePagePostBackEvent(String eventSource, String eventArgument);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\itempager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ItemPager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Item pager, a class that provides state as items of a control are paginated.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ItemPager
    {

        private MobileControl _control;
        private int _firstPageItemCount;
        private int _fullPageItemCount;
        private int _lastPageItemCount;
        private int _firstPage;
        private int _lastPage;

        public ItemPager()
        {
        }

        public ItemPager(ControlPager pager, MobileControl control, int itemCount, int itemsPerPage, int itemWeight)
        {
            _control = control;

            if (itemsPerPage > 0)
            {
                // User-specified pagination behavior, always given
                // number of items per page.

                if (itemCount < itemsPerPage)
                {
                    _firstPageItemCount = itemCount;
                    _firstPage = _lastPage = pager.GetPage(itemCount * itemWeight);
                }
                else
                {
                    int numberOfPages = (itemCount - 1) / itemsPerPage + 1;
                    _firstPageItemCount = itemsPerPage;
                    _fullPageItemCount = itemsPerPage;
                    _lastPageItemCount = itemCount - (numberOfPages - 1) * itemsPerPage;
                    _firstPage = pager.GetPage(itemsPerPage * itemWeight);
                    pager.PageCount += numberOfPages - 1;
                    if (numberOfPages > 1)
                    {
                        pager.RemainingWeight = Math.Max(0, pager.PageWeight - _lastPageItemCount * itemWeight);
                    }
                    _lastPage = _firstPage + numberOfPages - 1;
                }
            }
            else
            {
                int totalItemWeight = itemCount * itemWeight;
                if (totalItemWeight <= pager.RemainingWeight)
                {
                    _firstPageItemCount = itemCount;
                    _firstPage = _lastPage = pager.GetPage(totalItemWeight);
                }
                else
                {
                    _firstPageItemCount = pager.RemainingWeight / itemWeight;
                    int remainingItemCount = itemCount - _firstPageItemCount;
                    _fullPageItemCount  = Math.Max(1, pager.PageWeight / itemWeight);
                    int fullPageCount = remainingItemCount / _fullPageItemCount;
                    _lastPageItemCount  = remainingItemCount % _fullPageItemCount;
    
                    _firstPage = pager.PageCount;
    
                    //  increment for first page
                    pager.PageCount++;
                    pager.RemainingWeight = pager.PageWeight;
    
                    //  increment for full pages
                    pager.PageCount += fullPageCount;
    
                    //  remove remaining weight for last page
                    pager.RemainingWeight -= _lastPageItemCount * itemWeight;
    
                    //  correct if first page is empty
                    if (_firstPageItemCount == 0)
                    {
                        _firstPage++;
                        _firstPageItemCount = Math.Min(_fullPageItemCount, itemCount);
                    }
                    //  correct if last page is empty
                    if (_lastPageItemCount == 0)
                    {
                        pager.PageCount--;
                        _lastPageItemCount = Math.Min(_fullPageItemCount, itemCount);
                        pager.RemainingWeight = 0;
                    }
                    _lastPage = pager.PageCount;
                }
            }
            _control.FirstPage = _firstPage;
            _control.LastPage = _lastPage;
        }

        public int ItemIndex
        {
            get
            {
                int page = _control.Form.CurrentPage;
                if (page < _firstPage || page > _lastPage)
                {
                    return -1;
                }
                if (page == _firstPage)
                {
                    return 0;
                }
                else
                {
                    int fullPageCount = (page - _firstPage) - 1;
                    return fullPageCount * _fullPageItemCount + _firstPageItemCount;
                }
            }
        }

        public int ItemCount
        {
            get
            {
                int page = _control.Form.CurrentPage;
                if (page < _firstPage || page > _lastPage)
                {
                    return -1;
                }
                if (page == _firstPage)
                {
                    return _firstPageItemCount;
                }
                else if (page == _lastPage)
                {
                    return _lastPageItemCount;
                }
                else
                {
                    return _fullPageItemCount;
                }
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\itemplateable.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITemplateable.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Web;
using System.Web.UI;

namespace System.Web.UI.MobileControls
{

    /*
     * Marker interface to indicate that control supports templates.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public interface ITemplateable
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\label.cs ===
//------------------------------------------------------------------------------
// <copyright file="Label.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile Label class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultProperty("Text"),
        Designer(typeof(System.Web.UI.Design.MobileControls.LabelDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerLabelAdapter)),
        ToolboxData("<{0}:Label runat=\"server\">Label</{0}:Label>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Label : TextControl
    {

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\listcommandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * List command event handler - type definition.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void ListCommandEventHandler(Object sender, ListCommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\listcommandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListCommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * List command event arguments
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ListCommandEventArgs : CommandEventArgs 
    {
        protected static readonly String DefaultCommand = "Default";
        private MobileListItem _item;
        private Object _commandSource;

        public ListCommandEventArgs(MobileListItem item, Object commandSource, CommandEventArgs originalArgs) : base(originalArgs) 
        {
            _item = item;
            _commandSource = commandSource;
        }

        public ListCommandEventArgs(MobileListItem item, Object commandSource) : base(DefaultCommand, item) 
        {
            _item = item;
            _commandSource = commandSource;
        }

        public MobileListItem ListItem 
        {
            get 
            {
                return _item;
            }
        }

        public Object CommandSource 
        {
            get 
            {
                return _commandSource;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\link.cs ===
//------------------------------------------------------------------------------
// <copyright file="Link.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile Link class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultProperty("Text"),
        Designer(typeof(System.Web.UI.Design.MobileControls.LinkDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerLinkAdapter)),
        ToolboxData("<{0}:Link runat=server>Link</{0}:Link>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Link : TextControl, IPostBackEventHandler
    {
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Navigation),
            MobileSysDescription(SR.Link_NavigateUrl),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.NavigateUrlConverter))
        ]
        public String NavigateUrl
        {
            get
            {
                String s = (String) ViewState["NavigateUrl"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["NavigateUrl"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.Link_SoftkeyLabel)
        ]
        public String SoftkeyLabel
        {
            get
            {
                String s = (String) ViewState["SoftkeyLabel"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["SoftkeyLabel"] = value;
            }
        }

        // used for linking between panels
        void IPostBackEventHandler.RaisePostBackEvent(String argument)
        {
            MobilePage.ActiveForm = MobilePage.GetForm(argument);
        }

        public override void AddLinkedForms(IList linkedForms)
        {
            String target = NavigateUrl;
            String prefix = Constants.FormIDPrefix;
            if (target.StartsWith(prefix))
            {
                String targetID = target.Substring(prefix.Length);
                Form form = ResolveFormReference(targetID);
                if (form != null && !form.HasActivateHandler())
                {
                    linkedForms.Add(form);
                }
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\list.cs ===
//------------------------------------------------------------------------------
// <copyright file="List.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile List class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ControlBuilderAttribute(typeof(ListControlBuilder)),
        DefaultEvent("ItemCommand"),
        DefaultProperty("DataSource"),
        Designer(typeof(System.Web.UI.Design.MobileControls.ListDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerListAdapter)),
        Editor(typeof(System.Web.UI.Design.MobileControls.ListComponentEditor), typeof(ComponentEditor)),
        ToolboxData("<{0}:List runat=\"server\"></{0}:List>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class List : PagedControl, INamingContainer, IListControl, ITemplateable, IPostBackEventHandler
    {
        private static readonly Object EventItemCommand = new Object();
        private static readonly Object EventItemDataBind = new Object();

        private ListDataHelper _dataHelper;
        private ListDecoration _decoration = ListDecoration.None;

        public List()
        {
            _dataHelper = new ListDataHelper(this, ViewState);
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets the <see langword='DataSource'/> property of the control which is used to populate
        ///       the items within the control.
        ///    </para>
        /// </summary>
        [
            Bindable(true),
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataSource)
        ]
        public virtual Object DataSource 
        {
            get 
            {
                return _dataHelper.DataSource;
            }

            set 
            {
                _dataHelper.DataSource = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataMember),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataMemberConverter))
        ]
        public virtual String DataMember
        {
            get 
            {
                return _dataHelper.DataMember;
            }

            set 
            {
                _dataHelper.DataMember = value;
            }
        }

        [
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataTextField),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataFieldConverter))
        ]
        public String DataTextField 
        {
            get 
            {
                return _dataHelper.DataTextField;
            }
            set 
            {
                _dataHelper.DataTextField = value;
            }
        }

        [
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataValueField),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataFieldConverter))
        ]
        public String DataValueField 
        {
            get 
            {
                return _dataHelper.DataValueField;
            }
            set 
            {
                _dataHelper.DataValueField = value;
            }
        }


        [
            Bindable(true),
            DefaultValue(false),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.List_ItemsAsLinks)
        ]
        public bool ItemsAsLinks
        {
            get
            {
                Object b = ViewState["ItemsAsLinks"];
                return (b != null) ? (bool) b : false;
            }
            set
            {
                ViewState["ItemsAsLinks"] = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(null),
            Editor(typeof(System.Web.UI.Design.MobileControls.ItemCollectionEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileSysDescription(SR.List_Items),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public MobileListItemCollection Items
        {
            get
            {
                return _dataHelper.Items;
            }
        }

        public override void EnsureTemplatedUI()
        {
            EnsureChildControls();
        }

        protected override void AddParsedSubObject(Object obj)
        {
            if (!(obj is LiteralControl))
            {
                if (obj is MobileListItem)
                {
                    _dataHelper.AddItem((MobileListItem)obj);
                } 
                else
                {
                    base.AddParsedSubObject(obj);
                }
            }
        }

        protected override void CreateChildControls() 
        {
            CreateChildControls(false);
        }

        protected override void EnsureChildControls()
        {
            // Whenever EnsureChildControls is called before items are created 
            // (e.g., at LoadPrivateViewState), there are no controls.  
            // Rebuild children for this case by setting ChildControlsCreated to false.
            ChildControlsCreated = ChildControlsCreated && Controls.Count > 0;
            base.EnsureChildControls();
        }

        private void CreateChildControls(bool doDataBind)
        {
            if (IsTemplated && _dataHelper.HasItems() && Items.Count > 0)
            {
                Controls.Clear();
                CreateTemplatedUI(doDataBind);
            }
            ChildControlsCreated = true;
        }
        
        protected override void OnDataBinding(EventArgs e) 
        {
            base.OnDataBinding(e);
            if(_dataHelper.ResolvedDataSource != null)
            {
                Controls.Clear();
                ClearChildViewState();
                CreateItems(_dataHelper.ResolvedDataSource);
                CreateChildControls(true);
            }
        }

        protected virtual void CreateItems(IEnumerable dataSource) 
        {
            _dataHelper.CreateItems(dataSource);
        }

        public override void CreateDefaultTemplatedUI(bool doDataBind) 
        {
            MobileListItemCollection items = Items;

            ITemplate headerTemplate = GetTemplate(Constants.HeaderTemplateTag);
            ITemplate footerTemplate = GetTemplate(Constants.FooterTemplateTag);
            ITemplate itemTemplate = GetTemplate(Constants.ItemTemplateTag);
            ITemplate separatorTemplate = GetTemplate(Constants.SeparatorTemplateTag);
            ITemplate alternatingItemTemplate = GetTemplate(Constants.AlternatingItemTemplateTag);
            if (alternatingItemTemplate == null)
            {
                alternatingItemTemplate = itemTemplate;
            }

            CreateControlItem(MobileListItemType.HeaderItem, 
                              headerTemplate,
                              doDataBind);
            for (int i = 0; i < items.Count; i++)
            {
                if (i > 0)
                {
                    CreateControlItem(MobileListItemType.SeparatorItem, 
                                      separatorTemplate, 
                                      doDataBind);
                }
                AddItemAsControl(i, 
                                 items[i], 
                                 ((i & 1) == 1) ? alternatingItemTemplate : itemTemplate, 
                                 doDataBind);
            }
            CreateControlItem(MobileListItemType.FooterItem, 
                              footerTemplate,
                              doDataBind);
        }

        private void AddItemAsControl(
            int itemIndex,
            MobileListItem item,
            ITemplate itemTemplate, 
            bool doDataBind)
        {
            if (itemTemplate != null)
            {
                item.Controls.Clear();
                CheckedInstantiateTemplate (itemTemplate, item, this);
                Controls.Add(item);
                if (doDataBind)
                {
                    item.DataBind();
                }
            }
        }

        private void CreateControlItem(
            MobileListItemType itemType, 
            ITemplate itemTemplate, 
            bool doDataBind)
        {
            if (itemTemplate != null)
            {
                MobileListItem item = new MobileListItem(itemType);
                AddItemAsControl(-1, item, itemTemplate, doDataBind);
            }
        }

        protected override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);

            if (IsTemplated)
            {
                int firstVisibleItem = FirstVisibleItemIndex;
                int pageSize = VisibleItemCount;
                int lastVisibleItem = firstVisibleItem + pageSize - 1;
                int itemIndex = 0;
                int separatorIndex = 0;
                foreach(MobileListItem item in Controls)
                {
                    if (item.ItemType == MobileListItemType.ListItem)
                    {
                        item.Visible = itemIndex >= firstVisibleItem && itemIndex <= lastVisibleItem;
                        itemIndex++;
                    }
                    else if (item.ItemType == MobileListItemType.SeparatorItem)
                    {
                        item.Visible = separatorIndex >= firstVisibleItem && 
                                            separatorIndex < lastVisibleItem;
                        separatorIndex++;
                    }
                }
            }
        }

        protected override int InternalItemCount
        {
            get
            {
                if (_dataHelper.HasItems())
                {
                    Debug.Assert (Items.Count >= 0);
                    return Items.Count;
                }
                else
                {
                    return 0;
                }
            }
            
        }

        protected override void OnPageChange(int oldPageIndex, int newPageIndex)
        {
            base.OnPageChange(oldPageIndex, newPageIndex);
        }

        /////////////////////////////////////////////////////////////////////////
        //  EVENT HANDLING
        /////////////////////////////////////////////////////////////////////////

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.List_OnItemCommand)
        ]
        public event ListCommandEventHandler ItemCommand 
        {
            add 
            {
                Events.AddHandler(EventItemCommand, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemCommand, value);
            }
        }

        protected virtual void OnItemCommand(ListCommandEventArgs e) 
        {
            ListCommandEventHandler onItemCommandHandler = (ListCommandEventHandler)Events[EventItemCommand];
            if (onItemCommandHandler != null)
            {
                onItemCommandHandler(this, e);
            }
        }


        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public bool HasItemCommandHandler
        {
            get
            {
                return Events[EventItemCommand] != null;
            }
        }

        [
            Bindable(true),
            DefaultValue(ListDecoration.None),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.List_Decoration)
        ]
        public ListDecoration Decoration
        {
            get
            {
                return _decoration;
            }
            set
            {
                _decoration = value;
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.List_OnItemDataBind)
        ]
        public event ListDataBindEventHandler ItemDataBind 
        {
            add 
            {
                Events.AddHandler(EventItemDataBind, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemDataBind, value);
            }
        }

        protected virtual void OnItemDataBind(ListDataBindEventArgs e) 
        {
            ListDataBindEventHandler onItemDataBindHandler = 
                (ListDataBindEventHandler)Events[EventItemDataBind];
            if (onItemDataBindHandler != null)
            {
                onItemDataBindHandler(this, e);
            }
        }

        protected override bool OnBubbleEvent(Object sender, EventArgs e) 
        {
            bool handled = false;

            if (e is ListCommandEventArgs) 
            {
                OnItemCommand((ListCommandEventArgs)e);
                handled = true;
            }

            return handled;
        }

        void IPostBackEventHandler.RaisePostBackEvent(String eventArgument)
        {
            if(!ItemsAsLinks)
            {
                // Non-templated list got a click event. There really
                // isn't a command source, so we'll set it to the 
                // default of null.
                int item = Int32.Parse(eventArgument);
                item = TranslateVirtualItemIndex(item);
                OnItemCommand(new ListCommandEventArgs(Items[item], null));
            }
            else
            {
                MobilePage.ActiveForm = MobilePage.GetForm(eventArgument);
            }
        }

        private int TranslateVirtualItemIndex(int itemIndex)
        {
            // Ensure that the item of the given virtual index is loaded,
            // and translate as necessary to an index within the collection.

            if (ItemCount > 0)
            {
                if (_dataHelper.HasItems() && Items.Count > itemIndex - Items.BaseIndex)
                {
                    itemIndex -= Items.BaseIndex;
                }
                else
                {
                    OnLoadItems(new LoadItemsEventArgs(itemIndex, 1));
                    itemIndex = 0;
                }
            }

            return itemIndex;
        }

        protected override void OnLoadItems(LoadItemsEventArgs e)
        {
            // We should only load items if the base index has changed, or if
            // the desired items do not exist in the list. Otherwise, we are making
            // the app reload the same items over and over.

            if (e.ItemIndex != Items.BaseIndex || e.ItemCount != Items.Count)
            {
                Items.BaseIndex = e.ItemIndex;
                Items.Clear();
                base.OnLoadItems(e);
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        protected override void TrackViewState() 
        {
            base.TrackViewState();
            if (_dataHelper.HasItems())
            {
                ((IStateManager)Items).TrackViewState();
            }
        }

        protected override Object SaveViewState() 
        {
            Object baseState, itemsState;

            if (_dataHelper.HasItems())
            {
                itemsState = ((IStateManager)Items).SaveViewState();
            }
            else
            {
                itemsState = null;
            }
            baseState = base.SaveViewState();

            if (itemsState != null || Decoration != ListDecoration.None )
            {
                return new Object[3] { baseState, itemsState, Decoration };
            }
            else if (baseState != null)
            {
                return new Object[1] { baseState };
            }
            return null;
        }

        protected override void LoadViewState(Object savedState) 
        {
            if (savedState != null) 
            {
                Object[] state = (Object[])savedState;
                base.LoadViewState(state[0]);

                if (state.Length > 1)
                {
                    ((IStateManager)Items).LoadViewState(state[1]);
                    Decoration = (ListDecoration) state[2];
                }
            }
        }

        internal override void InternalItemCountChangedHandler(int newItemCount)
        {
            if (newItemCount == 0)
            {
                Items.Clear();
                Controls.Clear();
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  IListControl
        /////////////////////////////////////////////////////////////////////////

        void IListControl.OnItemDataBind(ListDataBindEventArgs e) 
        {
            OnItemDataBind(e);
        }

        bool IListControl.TrackingViewState
        {
            get
            {
                return IsTrackingViewState;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\individualdeviceconfig.cs ===
//------------------------------------------------------------------------------
// <copyright file="IndividualDeviceConfig.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


// Comment this out to get a version that doesn't need synchronized 
// access. This can be used for profiling, to compare whether the lock
// or the late writing is more useful.

using System;
using System.Web.Configuration;
using System.Configuration;
using System.Xml;
using System.Collections;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Web;
using System.Threading;
using System.Web.Mobile;

namespace System.Web.UI.MobileControls
{

    // Data structure for an individual device configuration.
    // Included predicates, page adapter type, and a list of
    // control/controlAdapter pairs. 
    internal class IndividualDeviceConfig
    {
        internal delegate bool DeviceQualifiesDelegate(HttpContext context);

        private String _name;
        private readonly ControlsConfig _controlsConfig;
        private DeviceQualifiesDelegate  _deviceQualifiesPredicate;
        private Type _pageAdapterType;
        private IControlAdapterFactory _pageAdapterFactory;
        private FactoryGenerator _factoryGenerator;

        // Parent device configuration.

        private IndividualDeviceConfig _parentConfig;
        private String                 _parentConfigName;

        // ControlType --> ControlAdapterType mapping (one of these
        // per individual device config)
        private readonly Hashtable _controlAdapterTypes = new Hashtable();

        // ControlType --> ControlAdapterType mapping cache, used to
        // store mappings that are derived from a complex lookup (one of these
        // per individual device config)
        private readonly Hashtable _controlAdapterLookupCache = new Hashtable();

        // Provide synchronized access to the hashtable, allowing
        // multiple readers but just one writer.  Here we have one per
        // device config.  
        private readonly ReaderWriterLock _controlAdapterTypesLock = new ReaderWriterLock();

        // The highest level to check.

        private static readonly Type _baseControlType = typeof(System.Web.UI.Control);
        
        
        // This constructor takes both a delegate that chooses this
        // device, and a Type to instantiate the appropriate page
        // adapter with.  
        internal IndividualDeviceConfig(ControlsConfig          controlsConfig,
                                      String                  name,
                                      DeviceQualifiesDelegate deviceQualifiesDelegate,
                                      Type                    pageAdapterType,
                                      String                  parentConfigName)
        {
            _controlsConfig = controlsConfig;
            _name = name;
            _deviceQualifiesPredicate = deviceQualifiesDelegate;
            _parentConfigName = parentConfigName;
            _parentConfig = null;
            PageAdapterType = pageAdapterType;
        }

        // This constructor takes just a page adapter for situations
        // where device selection isn't necessary (e.g., the designer).
        internal IndividualDeviceConfig(Type pageAdapterType) : this(null, null, null, pageAdapterType, null)
        {
        }

        // Given a context, see if this device config should handle
        // the given device.  If there is no predicate, return true. 
        internal /*public*/ bool DeviceQualifies(HttpContext context)
        {
            return _deviceQualifiesPredicate == null ?
                true :
                _deviceQualifiesPredicate(context);
        }

        // Register an adapter with the given control.
        internal /*public*/ void AddControl(Type controlType,
                               Type adapterType)
        {
            // Don't need to synchronize, as this is only being called
            // from one thread -- the configuration section handler. 

            _controlAdapterTypes[controlType] = AdapterFactoryGenerator.CreateFactory(adapterType);
        }

        internal Type PageAdapterType
        {
            get
            {
                return _pageAdapterType;
            }
            set
            {
                _pageAdapterType = value;
                if (value != null)
                {
                    _pageAdapterFactory = 
                        (IControlAdapterFactory)AdapterFactoryGenerator.CreateFactory(_pageAdapterType);
                }
            }
        }

        internal DeviceQualifiesDelegate DeviceQualifiesPredicate
        {
            get
            {
                return _deviceQualifiesPredicate;
            }
            set
            {
                _deviceQualifiesPredicate = value;
            }
        }

        protected IControlAdapterFactory LookupControl(Type controlType)
        {
            return LookupControl(controlType, false);
        }

        private IControlAdapterFactory LookupControl(Type controlType, bool lookInTypeCache)
        {
            IControlAdapterFactory factory;

            factory = (IControlAdapterFactory)_controlAdapterTypes[controlType];
            if (factory == null && lookInTypeCache)
            {
                // Grab reader lock...
                using (new ReaderWriterLockResource(_controlAdapterTypesLock,
                                                    false))
                {
                    factory = (IControlAdapterFactory)_controlAdapterLookupCache[controlType];
                } 
            }

            return factory;
        }

        // Create a new page adapter for the device.
        internal /*public*/ IPageAdapter NewPageAdapter()
        {
            IPageAdapter a = _pageAdapterFactory.CreateInstance() as IPageAdapter;
            
            if (a == null)
            {
                throw new Exception(
                    SR.GetString(SR.IndividualDeviceConfig_TypeMustSupportInterface,
                                 _pageAdapterType.FullName, "IPageAdapter"));
            }

            return a;
        }

        // Given a control's type, create a control adapter for it.

        internal virtual IControlAdapter NewControlAdapter(Type originalControlType)
        {
            IControlAdapterFactory factory = GetAdapterFactory(originalControlType);
            
            // Should return non-null, or throw an exception.
            Debug.Assert(factory != null);

            IControlAdapter a = factory.CreateInstance();
            return a;
        }

        // Given a control's type, returns the adapter type to be used.
        // Note that it's legal to not register an adapter type for each
        // control type.  
        //
        // This lookup uses the following steps:
        //
        // (1) Look up the control type directly, to see if an adapter type
        //     has been registered for it.
        // (2) Walk up the control inheritance chain, to see if an adapter type
        //     has been registered for the class. For example, if the passed
        //     control type is a validator, check BaseValidator, Label,
        //     TextControl, and finally MobileControl.
        // (3) If no adapter type has still been found, call the parent configuration,
        //     if any, to look up the adapter type. For example, the CHTML device
        //     configuration would call the HTML device configuration.
        // (4) If an adapter type is found, but is not explicitly registered for
        //     the passed control type, add an entry to the table, so that
        //     subsequent requests do not need to walk the hierarchy.

        protected IControlAdapterFactory GetAdapterFactory(Type originalControlType)
        {
            Debug.Assert(_parentConfigName == null);
            
            Type controlType = originalControlType;
            IControlAdapterFactory factory = LookupControl(controlType, true); // Look in type cache

            // Walk up hierarchy looking for registered adapters.
            // Stop when we get to the base control.

            while (factory == null && controlType != _baseControlType)
            {
                factory = LookupControl(controlType);
                if (factory == null)
                {
                    controlType = controlType.BaseType;
                }
            }

            // Could not find one in the current hierarchy. So, look it up in
            // the parent config if there is one.

            if (factory == null && _parentConfig != null)
            {
                factory = _parentConfig.GetAdapterFactory(originalControlType);
            }

            if (factory == null)
            {
                throw new Exception(
                    SR.GetString(SR.IndividualDeviceConfig_ControlWithIncorrectPageAdapter,
                                 controlType.FullName, _pageAdapterType.FullName));
                
            } 

            if (controlType != originalControlType)
            {
                // Add to lookup cache, so the next lookup won't require
                // traversing the hierarchy.

                // Grab writer lock...
                using (new ReaderWriterLockResource(_controlAdapterTypesLock,
                                                    true))
                {
                    _controlAdapterLookupCache[originalControlType] = factory;
                }
            }

            return factory;
        }

        internal /*public*/ String Name
        {
            get
            {
                return _name;
            }
        }
        
        internal /*public*/ String ParentConfigName
        {
            get
            {
                return _parentConfigName;
            }
            set
            {
                _parentConfigName = null;
            }
        }

        internal /*public*/ IndividualDeviceConfig ParentConfig
        {
            get
            {
                return _parentConfig;
            }
            set
            {
                _parentConfig = value;
            }
        }

        private FactoryGenerator AdapterFactoryGenerator
        {
            get
            {
                if (_factoryGenerator == null)
                {
                    if (_controlsConfig != null)
                    {
                        _factoryGenerator = _controlsConfig.AdapterFactoryGenerator;
                    }
                    else
                    {
                        _factoryGenerator = 
                            new FactoryGenerator(typeof(IControlAdapter), 
                                                 typeof(IControlAdapterFactory));
                    }
                }
                return _factoryGenerator;
            }
        }

        private enum FixupState { NotFixedUp, FixingUp, FixedUp };
        private FixupState _fixup = FixupState.NotFixedUp;

        internal /*public*/ void FixupInheritance(IndividualDeviceConfig referrer, XmlNode configNode)
        {
            if (_fixup == FixupState.FixedUp)
            {
                return;
            }

            if (_fixup == FixupState.FixingUp)
            {
                Debug.Assert(referrer != null);

                // Circular reference
                throw new Exception(SR.GetString(SR.MobileControlsSectionHandler_CircularReference, 
                                                 referrer.Name));
            }

            _fixup = FixupState.FixingUp;

            if (ParentConfigName != null)
            {
                Debug.Assert(ParentConfigName != String.Empty && ParentConfig == null);
                    
                ParentConfig = _controlsConfig.GetDeviceConfig(ParentConfigName);

                if (ParentConfig == null)
                {
                    throw new ConfigurationException(
                        SR.GetString(SR.MobileControlsSectionHandler_DeviceConfigNotFound,
                                     ParentConfigName),
                        configNode);
                }

                // Make sure parent is fixed up.

                ParentConfig.FixupInheritance(this, configNode);

                if (PageAdapterType == null)
                {
                    PageAdapterType = ParentConfig.PageAdapterType;
                }

                if (DeviceQualifiesPredicate == null)
                {
                    DeviceQualifiesPredicate = ParentConfig.DeviceQualifiesPredicate;
                }

                Debug.Assert(PageAdapterType != null);
                Debug.Assert(DeviceQualifiesPredicate != null);

                // Reset this since we don't need it any longer. 
                ParentConfigName = null;
            }

            _fixup = FixupState.FixedUp;
        }
    }

    internal class ReaderWriterLockResource : IDisposable
    {
        private ReaderWriterLock _lock;
        private bool _writerLock;
        
        internal /*public*/ ReaderWriterLockResource(ReaderWriterLock theLock, bool writerLock)
        {
            _lock = theLock;
            _writerLock = writerLock;
            if (_writerLock)
            {
                _lock.AcquireWriterLock(Timeout.Infinite);
            }
            else
            {
                _lock.AcquireReaderLock(Timeout.Infinite);
            }
        }

        /*public*/ void IDisposable.Dispose()
        {
            if (_writerLock)
            {
                _lock.ReleaseWriterLock();
            }
            else
            {
                _lock.ReleaseReaderLock();
            }
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\listcontrolbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListControlBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Globalization;
using System.Web.UI;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Control builder for lists and selection lists, that allows list items to be placed inline.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ListControlBuilder : MobileControlBuilder
    {
        public override Type GetChildControlType(String tagName, IDictionary attributes) 
        {
            if (String.Compare(tagName, "item", true, CultureInfo.InvariantCulture) == 0) 
            {
                return typeof(MobileListItem);
            }
            else
            {
                return base.GetChildControlType(tagName, attributes);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\listdatabindeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListDataBindEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * List item data binding arguments.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ListDataBindEventArgs : EventArgs {

        private MobileListItem _listItem;
        private Object _dataItem;

        public ListDataBindEventArgs(MobileListItem item, Object dataItem)
        {
            _listItem = item;
            _dataItem = dataItem;
        }

        public MobileListItem ListItem 
        {
            get 
            {
                return _listItem;
            }
        }

        public Object DataItem
        {
            get 
            {
                return _dataItem;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\literallink.cs ===
//------------------------------------------------------------------------------
// <copyright file="LiteralLink.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Literal Link class. Although public, this is an internal link class used for
     * literal hyperlinks.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LiteralLink : Link
    {
        internal override bool TrimInnerText
        {
            get
            {
                return false;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\listdatabindeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListDataBindEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * List item data binding handler - type definition.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void ListDataBindEventHandler(Object sender, ListDataBindEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\literaltext.cs ===
//------------------------------------------------------------------------------
// <copyright file="LiteralText.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Literal Text class. This is the control created for literal text in a form.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ControlBuilderAttribute(typeof(LiteralTextControlBuilder)),
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LiteralText : PagedControl
    {
        // Note that this value doesn't relate to device specific info
        // because this is simply a unit size to define how many characters
        // to be counted as an item for pagination.  Depending on each
        // device's page weight, different numbers of items will be returned
        // for display.
        private static int PagingUnitSize = ControlPager.DefaultWeight;  // chars

        [
            Bindable(false),
            Browsable(false),
        ]
        public String Text
        {
            // Override MobileControl default behavior for InnerText

            get
            {
                String s = (String)ViewState[MobileControl.InnerTextViewStateKey];
                return s != null ? s : InnerText;
            }

            set
            {
                ViewState[MobileControl.InnerTextViewStateKey] = value;
            }
        }

        //  this attempts to split on word, return or sentence boundaries.
        //  use of '.' to indicate end of sentence assumes western languages
        //  perhaps if we get rid of '.' logic, '\n' preference will be sufficient
        private int CalculateOffset(int itemIndex)
        {
            if (itemIndex == 0)
            {
                return 0;
            }

            int length = Text.Length;
            int itemSize = (length / InternalItemCount) + 1; 
            int baseOffset = itemSize * itemIndex;

            if (baseOffset >= length)
            {
                return length;
            }

            //  this code scans to find an optimal break location.
            String text = this.Text;
            int scanLength = itemSize / 2;
            int scanStop   = baseOffset - scanLength;
            int foundSpace = -1;
            int foundReturn = -1;
            int lastChar   = -1;
            for (int offset = baseOffset; offset > scanStop; offset--)
            {
                char c = text[offset];
                if (c == '.' && Char.IsWhiteSpace((char)lastChar))
                {
                    //  this may exceed baseOffset by 1, but will never exceed totalChars
                    return offset + 1;
                }
                else if (foundReturn < 0 && c == '\n')
                {
                    foundReturn = offset;
                }
                else if (foundSpace < 0 && Char.IsWhiteSpace(c))   // check performance of this
                {
                    foundSpace = offset;
                }
                lastChar = c;
            }

            if (foundReturn > 0)
            {
                return foundReturn;
            }
            else if (foundSpace > 0)
            {
                return foundSpace;
            }

            return baseOffset;
        }

        public String PagedText
        {
            get
            {
                int index = FirstVisibleItemIndex;
                int count = VisibleItemCount;
                String text = Text;

                if (count > text.Length)
                {
                    return text;
                }

                int start = CalculateOffset(index);
                int stop = CalculateOffset(index + count);

                // If not at the beginning or end, skip spaces.

                if (start > 0)
                {
                    while (start < stop && Char.IsWhiteSpace(text[start]) )
                    {
                        start++;
                    }
                }

                if (stop < text.Length)
                {
                    while (Char.IsWhiteSpace(text[stop - 1]) && stop > start)
                    {
                        stop--;
                    }
                }

                return (stop > start) ? text.Substring(start, stop - start) : String.Empty;
            }
        }
        

        protected override int InternalItemCount
        {
            get
            {
                return ((Text.Length / PagingUnitSize) + (((Text.Length % PagingUnitSize) > 0) ? 1 : 0));
            }
        }

        protected override int ItemWeight
        {
            get
            {
                return PagingUnitSize;
            }
        }

        internal override bool TrimInnerText
        {
            get
            {
                return false;
            }
        }
    }

    /*
     * Control builder for literal text.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LiteralTextControlBuilder : MobileControlBuilder
    {
        public override bool AllowWhitespaceLiterals() 
        {
            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\literaltextparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="LiteralTextParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.Text;
using System.Web;

namespace System.Web.UI.MobileControls
{
    /*
     * LiteralTextParser class.
     *
     * The LiteralTextParser class parses a string of literal text, 
     * containing certain recognizable tags, and creates a set of controls
     * from them. Any unrecognized tags are ignored.
     *
     * This is an abstract base class. RuntimeLiteralTextParser and 
     * CompileTimeLiteralTextParser inherit from this class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal abstract class LiteralTextParser
    {
        // The parsing methods (Parse, ParseTag, ParseTagAttributes, ParseText) 
        // build up LiteralElement objects, which can either be text or tags. 
        // ProcessElementInternal is then called. It combines some other data
        // and calls ProcessElement, a method which is overridable by inherited
        // classes.

        // Literal Element type - includes recognized tags.

        protected enum LiteralElementType
        {
            Unrecognized,
            Text,
            Bold,
            Italic,
            Break,
            Paragraph,
            Anchor,
        }

        // Available formatting options for literal elements. This enum can 
        // be combined with the | operator.

        protected enum LiteralFormat
        {
            None = 0,
            Bold = 1,
            Italic = 2,
        }

        // Literal Element.

        protected class LiteralElement
        {
            public LiteralElementType Type;
            public IDictionary Attributes;
            public String Text;
            public LiteralFormat Format = LiteralFormat.None;
            public bool BreakAfter = false;
            public bool ForceBreakTag = false;

            public LiteralElement(String text)
            {
                Type = LiteralElementType.Text;
                Attributes = null;
                Text = text;
            }

            public LiteralElement(LiteralElementType type, IDictionary attributes)
            {
                Type = type;
                Attributes = attributes;
                Text = String.Empty;
            }

            public bool IsText
            {
                get
                {
                    return Type == LiteralElementType.Text;
                }
            }

            public bool IsEmptyText
            {
                get
                {
                    return IsText && !LiteralTextParser.IsValidText(Text);
                }
            }

            public String GetAttribute(String attributeName)
            {
                Object o = (Attributes != null) ? Attributes[attributeName] : null;
                return (o != null) ? (String)o : String.Empty;
            }
        }

        // Methods overriden by inherited classes.

        protected abstract void ProcessElement(LiteralElement element);
        protected abstract void ProcessTagInnerText(String text);

        private bool           _isBreakingReset   = true;
        private LiteralElement _lastQueuedElement = null;
        private LiteralElement _currentTag        = null;
        private bool           _beginNewParagraph = true;
        private FormatStack    _formatStack       = new FormatStack();
        private bool           _elementsProcessed = false;

        // Static constructor that builds a lookup table of recognized tags.

        private static IDictionary _recognizedTags = new Hashtable();
        static LiteralTextParser()
        {
            // PERF: Add both lowercase and uppercase.

            _recognizedTags.Add("b", LiteralElementType.Bold);
            _recognizedTags.Add("B", LiteralElementType.Bold);

            _recognizedTags.Add("i", LiteralElementType.Italic);
            _recognizedTags.Add("I", LiteralElementType.Italic);

            _recognizedTags.Add("br", LiteralElementType.Break);
            _recognizedTags.Add("BR", LiteralElementType.Break);

            _recognizedTags.Add("p", LiteralElementType.Paragraph);
            _recognizedTags.Add("P", LiteralElementType.Paragraph);

            _recognizedTags.Add("a", LiteralElementType.Anchor);
            _recognizedTags.Add("A", LiteralElementType.Anchor);
        }

        // Convert a tag name to a type.

        private static LiteralElementType TagNameToType(String tagName)
        {
            Object o = _recognizedTags[tagName];
            if (o == null)
            {
                o = _recognizedTags[tagName.ToLower(CultureInfo.InvariantCulture)];
            }
            return (o != null) ? (LiteralElementType)o : LiteralElementType.Unrecognized;
        }

        // Returns true if any valid controls could be generated from the given text.

        internal /*public*/ static bool IsValidText(String validText)
        {
            // BUGBUG: Can we replace this with just (validText.Trim ().Length > 0)?

            if (validText.Length == 0)
            {
                return false;
            }

            foreach (char c in validText)
            {
                if (!Char.IsWhiteSpace(c) &&
                        c != '\t' &&
                        c != '\r' && 
                        c != '\n')
                {
                    return true;
                }
            }

            return false;
        }

        // Main parse routine. Called with a block of text to parse.

        internal /*public*/ void Parse(String literalText)
        {
            int length = literalText.Length;
            int currentPosition = 0;

            while (currentPosition < length)
            {
                // Find start of next tag.

                int nextTag = literalText.IndexOf('<', currentPosition);
                if (nextTag == -1)
                {
                    ParseText(literalText.Substring(currentPosition));
                    break;
                }

                if (nextTag > currentPosition)
                {
                    ParseText(literalText.Substring(currentPosition, nextTag - currentPosition));
                }

                // Find end of tag.

                char quoteChar = '\0';
                int endOfTag;
                for (endOfTag = nextTag + 1; endOfTag < length; endOfTag++)
                {
                    char c = literalText[endOfTag];
                    if (quoteChar == '\0')
                    {
                        if (c == '\'' || c == '\"')
                        {
                            quoteChar = c;
                        }
                        else if (c == '>')
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (c == quoteChar)
                        {
                            quoteChar = '\0';
                        }
                    }
                }

                if (endOfTag == length)
                {
                    // TODO: Parse error?
                    break;
                }

                ParseTag(literalText, nextTag + 1, endOfTag);
                currentPosition = endOfTag + 1;
            }

            Flush();
        }

        internal /*public*/ void ResetBreaking()
        {
            _isBreakingReset = true;
            _elementsProcessed = false;
        }

        internal /*public*/ void ResetNewParagraph()
        {
            _beginNewParagraph = false;
        }

        internal /*public*/ void UnResetBreaking()
        {
            _isBreakingReset = false;
        }

        protected bool ElementsProcessed
        {
            get
            {
                return _elementsProcessed;
            }

            set
            {
                _elementsProcessed = value;
            }
        }

        protected void OnAfterDataBoundLiteral()
        {
            ElementsProcessed = true;
            UnResetBreaking();
        }

        // Parse a single tag.

        private void ParseTag(String literalText, int tagStart, int tagFinish)
        {
            bool isClosingTag;
            if ((isClosingTag = (literalText[tagStart] == '/')) == true) 
            {
                tagStart++;
            }

            // Empty tag?

            if (tagStart == tagFinish)
            {
                return;
            }

            // Look for end of tag name.

            int tagNameFinish = tagStart;
            while (tagNameFinish < tagFinish && 
                   !Char.IsWhiteSpace(literalText[tagNameFinish]) && literalText[tagNameFinish] != '/')
            {
                tagNameFinish++;
            }

            // Extract tag name, and compare to recognized tags.

            String tagName = literalText.Substring(tagStart, tagNameFinish - tagStart);
            LiteralElementType tagType = TagNameToType(tagName);
            if (tagType == LiteralElementType.Unrecognized)
            {
                return;
            }

            // Are we already in a complex tag?

            if (_currentTag != null)
            {
                // Ignore any inner tags, except the closing tag.

                if (_currentTag.Type == tagType && isClosingTag)
                {
                    ProcessElementInternal(_currentTag);
                    _currentTag = null;
                }
                else
                {
                    // TODO: Error?
                }
                return;
            }

            switch (tagType)
            {
                case LiteralElementType.Paragraph:
                    
                    // Do not create two breaks for </p><p> pairs.

                    if (!_isBreakingReset)
                    {
                        _isBreakingReset = true;
                        goto case LiteralElementType.Break;
                    }

                    break;

                case LiteralElementType.Break:

                    // If a break is already pending, insert an empty one.

                    if (_beginNewParagraph)
                    {
                        ParseText("");
                    }
                    if (_lastQueuedElement != null && 
                        _lastQueuedElement.Text.Length == 0)
                    {
                        _lastQueuedElement.ForceBreakTag = true;
                    }
                    _beginNewParagraph = true;
                    break;

                case LiteralElementType.Bold:

                    if (isClosingTag)
                    {
                        _formatStack.Pop(FormatStack.Bold);
                    }
                    else
                    {
                        _formatStack.Push(FormatStack.Bold);
                    }
                    break;

                case LiteralElementType.Italic:

                    if (isClosingTag)
                    {
                        _formatStack.Pop(FormatStack.Italic);
                    }
                    else
                    {
                        _formatStack.Push(FormatStack.Italic);
                    }
                    break;

                default:
                {
                    if (!isClosingTag)
                    {
                        IDictionary attribs = ParseTagAttributes(literalText, tagNameFinish, tagFinish, tagName);
                        _currentTag = new LiteralElement(tagType, attribs);
                    }
                    break;
                }
            }

            if (_isBreakingReset && tagType != LiteralElementType.Paragraph)
            {
                _isBreakingReset = false;
            }
        }

        protected bool IsInTag
        {
            get
            {
                return _currentTag != null;
            }
        }

        protected LiteralFormat CurrentFormat
        {
            get
            {
                return _formatStack.CurrentFormat;
            }
        }

        // Parse attributes of a tag.

        private enum AttributeParseState
        {
            StartingAttributeName,
            ReadingAttributeName,
            ReadingEqualSign,
            StartingAttributeValue,
            ReadingAttributeValue,
            Error,
        }

        private IDictionary ParseTagAttributes(String literalText, int attrStart, int attrFinish, String tagName)
        {
            if (attrFinish > attrStart && literalText[attrFinish - 1] == '/')
            {
                attrFinish--;
            }

            IDictionary dictionary = null;
            int attrPos = attrStart;
            bool skipWhiteSpaces = true;
            int attrNameStart = 0;
            int attrNameFinish = 0; 
            int attrValueStart = 0;
            char quoteChar = '\0';
            AttributeParseState state = AttributeParseState.StartingAttributeName;

            while (attrPos <= attrFinish && state != AttributeParseState.Error)
            {
                char c = attrPos == attrFinish ? '\0' : literalText[attrPos];

                if (skipWhiteSpaces)
                {
                    if (Char.IsWhiteSpace(c))
                    {
                        attrPos++;
                        continue;
                    }
                    else
                    {
                        skipWhiteSpaces = false;
                    }
                }

                switch (state)
                {
                    case AttributeParseState.StartingAttributeName:
                        if (c == '\0')
                        {
                            attrPos = attrFinish + 1;
                        }
                        else
                        {
                            attrNameStart = attrPos;
                            state = AttributeParseState.ReadingAttributeName;
                        }
                        break;

                    case AttributeParseState.ReadingAttributeName:
                        if (c == '=' || Char.IsWhiteSpace(c))
                        {
                            attrNameFinish = attrPos;
                            skipWhiteSpaces = true;
                            state = AttributeParseState.ReadingEqualSign;
                        }
                        else if (c == '\0')
                        {
                            state = AttributeParseState.Error;
                        }
                        else
                        {
                            attrPos++;
                        }
                        break;

                    case AttributeParseState.ReadingEqualSign:
                        if (c == '=')
                        {
                            skipWhiteSpaces = true;
                            state = AttributeParseState.StartingAttributeValue;
                            attrPos++;
                        }
                        else
                        {
                            state = AttributeParseState.Error;
                        }
                        break;

                    case AttributeParseState.StartingAttributeValue:
                        attrValueStart = attrPos;
                        if (c == '\0')
                        {
                            state = AttributeParseState.Error;
                            break;
                        } 
                        else if (c == '\"' || c == '\'')
                        {
                            quoteChar = c;
                            attrValueStart++;
                            attrPos++;
                        }
                        else
                        {
                            quoteChar = '\0';
                        }
                        state = AttributeParseState.ReadingAttributeValue;
                        break;

                    case AttributeParseState.ReadingAttributeValue:
                        if (c == quoteChar || 
                            ((Char.IsWhiteSpace(c) || c == '\0') && quoteChar == '\0'))
                        {
                            if (attrNameFinish == attrNameStart)
                            {
                                state = AttributeParseState.Error;
                                break;
                            }

                            if (dictionary == null)
                            {
                                dictionary = new HybridDictionary(true);
                            }

                            dictionary.Add(
                                literalText.Substring(attrNameStart, attrNameFinish - attrNameStart),
                                literalText.Substring(attrValueStart, attrPos - attrValueStart));

                            skipWhiteSpaces = true;
                            state = AttributeParseState.StartingAttributeName;
                            if (c == quoteChar)
                            {
                                attrPos++;
                            }
                        }
                        else
                        {
                            attrPos++;
                        }
                        break;
                }
            }

            if (state == AttributeParseState.Error)
            {
                throw new Exception(SR.GetString(SR.LiteralTextParser_InvalidTagFormat));
            }

            return dictionary;
        }

        // Parse a plain text literal.

        private void ParseText(String text)
        {
            if (_currentTag != null)
            {
                // Add to inner text of tag.
                _currentTag.Text += text;
            }
            else
            {
                if (_isBreakingReset && IsValidText(text))
                {
                    _isBreakingReset = false;
                }
                ProcessElementInternal(new LiteralElement(text));
            }
        }

        private void ProcessElementInternal(LiteralElement element)
        {
            // This method needs to fill in an element with formatting and
            // breaking information, and calls ProcessElement. However,
            // each element needs to know whether there will be a break
            // AFTER the element, so elements are processed lazily, keeping
            // the last one in a single-element queue.

            LiteralFormat currentFormat = _formatStack.CurrentFormat;

            if (_lastQueuedElement != null)
            {
                // If both the last and current element are text elements, and 
                // the formatting hasn't changed, then just combine the two into
                // a single element.

                if (_lastQueuedElement.IsText && element.IsText && 
                        (_lastQueuedElement.Format == currentFormat) && 
                        !_beginNewParagraph)
                {
                    _lastQueuedElement.Text += element.Text;
                    return;
                }
                else if (_lastQueuedElement.IsEmptyText && 
                         !_beginNewParagraph &&
                         IgnoreWhiteSpaceElement(_lastQueuedElement))
                {
                    // Empty text element with no breaks - so just ignore.
                }
                else
                {
                    _lastQueuedElement.BreakAfter = _beginNewParagraph;
                    ProcessElement(_lastQueuedElement);
                    _elementsProcessed = true;
                }
            }

            _lastQueuedElement = element;
            _lastQueuedElement.Format = currentFormat;
            _beginNewParagraph = false;
        }

        private void Flush()
        {
            if (_currentTag != null)
            {
                // In the middle of a tag. There may be multiple inner text elements inside
                // a tag, e.g.
                //      <a ...>some text <%# a databinding %> some more text</a>
                // and we're being flushed just at the start of the databinding.

                if (!_currentTag.IsEmptyText)
                {
                    ProcessTagInnerText(_currentTag.Text);
                }
                _currentTag.Text = String.Empty;
                return;
            }

            if (_lastQueuedElement == null)
            {
                return;
            }

            // Ignore orphaned whitespace.
                    
            if (!_lastQueuedElement.ForceBreakTag && _lastQueuedElement.IsEmptyText)
            {
                if (!_elementsProcessed)
                {
                    return;
                }
                if (_lastQueuedElement.Text.Length == 0 || _lastQueuedElement.Text[0] != ' ')
                {
                    return;
                }

                _lastQueuedElement.Text = " ";
            }

            _lastQueuedElement.BreakAfter = _beginNewParagraph;
            ProcessElement(_lastQueuedElement);
            _lastQueuedElement = null;
        }

        protected virtual bool IgnoreWhiteSpaceElement(LiteralElement element)
        {
            return true;
        }

        /*
         * FormatStack private class
         *
         * This class maintains a simple stack of formatting directives. As tags and 
         * closing tags are processed, they are pushed on and popped off this stack.
         * The CurrentFormat property returns the current state.
         */

        private class FormatStack
        {
            internal const char Bold = 'b';
            internal const char Italic = 'i';
            
            private StringBuilder _stringBuilder = new StringBuilder(16);

            public void Push(char option)
            {
                _stringBuilder.Append(option);
            }

            public void Pop(char option)
            {
                // Only pop a matching directive - non-matching directives are ignored!

                int length = _stringBuilder.Length;
                if (length > 0 && _stringBuilder[length - 1] == option)
                {
                    _stringBuilder.Remove(length - 1, 1);
                }
            }

            public LiteralFormat CurrentFormat
            {
                get
                {
                    LiteralFormat format = LiteralFormat.None;
                    for (int i = _stringBuilder.Length - 1; i >= 0; i--)
                    {
                        switch (_stringBuilder[i])
                        {
                            case Bold:
                                format |= LiteralFormat.Bold;
                                break;
                            case Italic:
                                format |= LiteralFormat.Italic;
                                break;
                        }
                    }
                    return format;
                }
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\literaltextcontainercontrolbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="LiteralTextContainerControlBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Control builder for containers of literal text
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LiteralTextContainerControlBuilder : MobileControlBuilder
    {
        private CompileLiteralTextParser _textParser = null;
        private bool _controlsInserted = false;

        internal LiteralTextContainerControlBuilder()
        {
        }

        internal CompileLiteralTextParser TextParser
        {
            get
            {
                if (_textParser == null)
                {
                    _textParser = 
                        new CompileLiteralTextParser(Parser, this, "xxxx", 1);
                    if (_controlsInserted)
                    {
                        _textParser.ResetBreaking();
                        _textParser.ResetNewParagraph();
                    }
                }
                return _textParser;
            }
        }

        public override void AppendLiteralString(String text)
        {
            if (InDesigner)
            {
                base.AppendLiteralString(text);
            }
            else
            {
                if (LiteralTextParser.IsValidText(text))
                {
                    TextParser.Parse(text);
                }
            }
        }

        public override void AppendSubBuilder(ControlBuilder subBuilder)
        {
            if (InDesigner)
            {
                base.AppendSubBuilder(subBuilder);
            }

            // The first one is used if ASP.NET is compiled with FAST_DATABINDING off. The second
            // is used if it is compiled with FAST_DATABINDING on. Note: We can't do a type 
            // comparison because CodeBlockBuilder is internal.
            //else if (typeof(DataBoundLiteralControl).IsAssignableFrom(subBuilder.ControlType))
            else if (subBuilder.GetType().FullName == "System.Web.UI.CodeBlockBuilder")
            {
                TextParser.AddDataBinding(subBuilder);
            }
            else
            {
                base.AppendSubBuilder(subBuilder);
                if (subBuilder.ControlType != typeof(LiteralText))
                {
                    if (_textParser != null)
                    {
                        _textParser.ResetBreaking();
                    }
                    else
                    {
                        _controlsInserted = true;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\loaditemseventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="LoadItemsEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * Used for dynamically loading items into a paged control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void LoadItemsEventHandler(Object sender, LoadItemsEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\loaditemseventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="LoadItemsEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Load Items event arguments.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class LoadItemsEventArgs : EventArgs
    {

        public LoadItemsEventArgs(int index, int count)
        {
            _itemIndex = index;
            _itemCount = count;
        }

        private int _itemIndex;
        public int ItemIndex
        {
            get
            {
                return _itemIndex;
            }
        }

        private int _itemCount;
        public int ItemCount
        {
            get
            {
                return _itemCount;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\listdatahelper.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListDataHelper.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Diagnostics;

namespace System.Web.UI.MobileControls
{
    /*
     * List Data Helper class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal sealed class ListDataHelper
    {
        private IListControl _parent;
        private StateBag _parentViewState;
        private MobileListItemCollection _items;
        private Object _dataSource;
        private IEnumerable _resolvedDataSource;
        private int _dataSourceCount = -1;
        private String _dataTextField;
        private String _dataValueField;
        private bool _bindFromFields;

        internal /*public*/ ListDataHelper(IListControl parent, StateBag parentViewState)
        {
            _parent = parent;
            _parentViewState = parentViewState;
        }

        internal /*public*/ MobileListItemCollection Items
        {
            get
            {
                if (_items == null)
                {
                    _items = new MobileListItemCollection();
                    if (_parent.TrackingViewState)
                    {
                        ((IStateManager)_items).TrackViewState();
                    }
                }
                return _items;
            }
        }
        
        internal /*public*/ bool HasItems()
        {
            return _items != null;
        }

        internal /*public*/ Object DataSource 
        {
            get 
            {
                return _dataSource;
            }

            set 
            {
                _dataSource = value;
                _resolvedDataSource = null;
            }
        }

        internal /*public*/ String DataMember
        {
            get 
            {
                String s = (String)_parentViewState["DataMember"];
                return s == null ? String.Empty : s;
            }

            set 
            {
                _parentViewState["DataMember"] = value;
            }
        }

        internal /*public*/ String DataTextField 
        {
            get 
            {
                String s = (String)_parentViewState["DataTextField"];
                return (s != null) ? s : String.Empty;
            }
            set 
            {
                _parentViewState["DataTextField"] = value;
            }
        }

        internal /*public*/ String DataValueField 
        {
            get 
            {
                String s = (String)_parentViewState["DataValueField"];
                return (s != null) ? s : String.Empty;
            }
            set 
            {
                _parentViewState["DataValueField"] = value;
            }
        }

        internal /*public*/ IEnumerable ResolvedDataSource
        {
            get
            {
                if (_resolvedDataSource == null)
                {
                    _resolvedDataSource = 
                        DataSourceHelper.GetResolvedDataSource(DataSource, DataMember);
                }
                return _resolvedDataSource;
            }
        }

        internal int DataSourceCount
        {
            get
            {
                if (_dataSourceCount == -1)
                {
                    IEnumerable dataSource = ResolvedDataSource;
                    if (dataSource != null)
                    {
                        ICollection collection = dataSource as ICollection;
                        if (collection != null)
                        {
                            _dataSourceCount = collection.Count;
                        }
                        else
                        {
                            int count = 0;
                            IEnumerator enumerator = dataSource.GetEnumerator();
                            while (enumerator.MoveNext())
                            {
                                count++;
                            }
                            _dataSourceCount = count;
                        }
                    }
                    else
                    {
                        _dataSourceCount = 0;
                    }
                }
                return _dataSourceCount;
            }
        }

        internal /*public*/ void CreateItems(IEnumerable dataSource) 
        {
            Debug.Assert (dataSource != null);
            Items.Clear();
            _dataTextField = DataTextField;
            _dataValueField = DataValueField;
            _bindFromFields = (_dataTextField.Length > 0) || (_dataValueField.Length > 0);
            foreach (Object dataItem in dataSource)
            {
                MobileListItem listItem = CreateItem(dataItem);

                if (listItem != null) 
                {
                    AddItem(listItem);
                }
            }
            _dataSourceCount = Items.Count;
        }

        private MobileListItem CreateItem(Object dataItem)
        {
            MobileListItem listItem = null;
            String textField = null;
            String valueField = null;

            if (_bindFromFields)
            {
                if (_dataTextField.Length > 0)
                {
                    textField = DataBinder.GetPropertyValue(dataItem, _dataTextField, "{0}");
                }
                if (_dataValueField.Length > 0)
                {
                    valueField = DataBinder.GetPropertyValue(dataItem, _dataValueField, "{0}");
                }
            }
            else
            {
                textField = dataItem.ToString();
            }
            listItem = new MobileListItem(dataItem, textField, valueField);

            // Use delegated data binding, if specified.
            if (dataItem != null)
            {
                _parent.OnItemDataBind(new ListDataBindEventArgs(listItem, dataItem));
            }

            return listItem;
        }

        internal /*public*/ void AddItem(MobileListItem item)
        {
            MobileListItemCollection items = Items;
            items.Add(item);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilelistitemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileListItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile List Item collection class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileListItemCollection : ArrayListCollectionBase, IStateManager
    {
        private bool _marked = false;
        private bool _saveAll = false;
        private bool _saveSelection = false;
        private int _baseIndex = 0;

        public MobileListItemCollection()
        {
        }

        public MobileListItemCollection(ArrayList items) : base(items)
        {
        }

        internal int BaseIndex
        {
            get
            {
                return _baseIndex;
            }

            set
            {
                _baseIndex = value;
            }
        }

        internal bool SaveSelection
        {
            get
            {
                return _saveSelection;
            }
            set
            {
                _saveSelection = value;
            }
        }

        public MobileListItem[] GetAll()
        {
            int n = Count;
            MobileListItem[] result = new MobileListItem[n];
            if (n > 0) 
            {
                Items.CopyTo (0, result, 0, n);
            }
            return result;
        }

        public void SetAll(MobileListItem[] value)
        {
            Items = new ArrayList (value);
            if (_marked)
            {
                _saveAll = true;
            }

            int count = Count;
            for (int i = 0; i < count; i++)
            {
                MobileListItem item = this[i];
                item.SetIndex(i + BaseIndex);
                if (_marked)
                {
                    item.Dirty = true;
                }
            }
        }

        public MobileListItem this[int index]
        {
            get
            {
                return (MobileListItem)Items[index];
            }
        }

        public void Add(MobileListItem item)
        {
            item.SetIndex(Items.Count + BaseIndex);
            Items.Add (item);
            if (_marked)
            {
                item.Dirty = true;
            }
        }

        public virtual void Add(String item)
        {
            Add (new MobileListItem (item));
        }

        public void Clear()
        {
            Items.Clear ();
            if (_marked)
            {
                _saveAll = true;
            }
        }

        public bool Contains(MobileListItem item)
        {
            return Items.Contains (item);
        }


        public int IndexOf(MobileListItem item)
        {
            return Items.IndexOf(item);
        }

        public virtual void Insert(int index, String item) 
        {
            Insert (index, new MobileListItem (item));
        }

        public void Insert(int index, MobileListItem item) 
        {
            Items.Insert (index, item);
            for (int i = index; i < Items.Count; i++)
            {
                ((MobileListItem)Items[i]).SetIndex(i + BaseIndex);
            }
            if (_marked)
            {
                _saveAll = true;
            }
        }

        public void RemoveAt(int index) 
        {
            Items.RemoveAt (index);
            for (int i = index; i < Items.Count; i++)
            {
                ((MobileListItem)Items[i]).SetIndex(i + BaseIndex);
            }
            if (_marked)
            {
                _saveAll = true;
            }
        }
    
        public virtual void Remove(String item) 
        {
            int index = IndexOf (new MobileListItem(item));
            if (index >= 0) 
            {
                RemoveAt (index);
            }
        }

        public void Remove(MobileListItem item) 
        {
            int index = IndexOf(item);
            if (index >= 0) 
            {
                RemoveAt(index);
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        bool IStateManager.IsTrackingViewState
        {
            get
            {
                return _marked;
            }
        }

        void IStateManager.TrackViewState() 
        {
            _marked = true;
            foreach (IStateManager item in Items)
            {
                item.TrackViewState();
            }
        }

        void IStateManager.LoadViewState(Object state) 
        {
            if (state != null)
            {
                Object[] changes = (Object[]) state;
                int length = changes.Length;

                if (length == 5)
                {
                    int count = (int)changes[0];
                    if (count < Count)
                    {
                        throw new Exception(
                            SR.GetString(SR.MobileListItemCollection_ViewStateManagementError));
                    }
                    EnsureCount ((int)changes[0]);
                    int[] changeIndices = (int[])changes[1];
                    Object[] itemChanges = (Object[])changes[2];
                    for (int i = 0; i < changeIndices.Length; i++)
                    {
                        ((IStateManager)Items[changeIndices[i]]).LoadViewState (itemChanges[i]);
                    }
                }
                else if (length == 3)
                {
                    if (changes[0] == null)
                    {
                        Clear ();
                    }
                    else
                    {
                        Object[] itemChanges = (Object[])changes[0];
                        EnsureCount (itemChanges.Length);
                        int i = 0;
                        foreach (IStateManager item in Items)
                        {
                            item.LoadViewState (itemChanges[i++]);
                        }
                    }
                }

                if (length >= 2 && changes[length - 2] != null && _saveSelection)
                {
                    bool[] selection = (bool[])changes[length - 2];
                    for (int i = selection.Length - 1; i >= 0; i--)
                    {
                        ((MobileListItem)Items[i]).Selected = selection[i];
                    }
                }

                int oldBaseIndex = BaseIndex;
                BaseIndex = (int)changes[length - 1];
                if (oldBaseIndex != BaseIndex)
                {
                    int index = BaseIndex;
                    foreach (MobileListItem item in Items)
                    {
                        item.SetIndex(index++);
                    }
                }
            }
        }

        Object IStateManager.SaveViewState() 
        {
            Object[] changes;
            int changedCount = 0;
            bool selectionNeedsSaving = false;

            if (!_saveAll)
            {
                foreach (MobileListItem item in Items)
                {
                    if (item.Dirty)
                    {
                        changedCount++;
                    }

                    if (_saveSelection && item.SelectionDirty)
                    {
                        selectionNeedsSaving = true;
                    }
                }
                if (changedCount == Count)
                {
                    _saveAll = true;
                }
                else if (changedCount == 0 && !selectionNeedsSaving && BaseIndex == 0)
                {
                    return null;
                }
            }

            if (_saveAll)
            {
                // Save all items.

                Object[] itemChanges;
                if (Count > 0)
                {
                    itemChanges = new Object[Count];
                    int i = 0;
                    foreach (MobileListItem item in Items)
                    {
                        item.Dirty = true;
                        itemChanges[i++] = ((IStateManager)item).SaveViewState ();
                    }
                }
                else
                {
                    itemChanges = null;
                }

                changes = new Object[3];
                changes[0] = itemChanges;
                selectionNeedsSaving = true;
            }
            else if (changedCount == 0)
            {
                changes = new Object[selectionNeedsSaving ? 2 : 1];
            }
            else
            {
                // Save changed items.

                int[] changeIndices = new int[changedCount];
                Object[] itemChanges = new Object[changedCount];

                changedCount = 0;
                int i = 0;
                foreach (MobileListItem item in Items)
                {
                    if (item.Dirty)
                    {
                        changeIndices[changedCount] = i;
                        itemChanges[changedCount] = ((IStateManager)item).SaveViewState ();
                        changedCount++;
                    }
                    i++;
                }

                changes = new Object[5];
                changes[0] = (int)Count;
                changes[1] = changeIndices;
                changes[2] = itemChanges;
                changes[3] = null;
            }

            if (selectionNeedsSaving)
            {
                bool[] selection = new bool[Count];
                int i = 0;
                foreach (MobileListItem item in Items)
                {
                    selection[i++] = item.Selected;
                }
                changes[changes.Length - 2] = selection;
            }

            changes[changes.Length - 1] = BaseIndex;
            return changes;
        }

        private void EnsureCount(int count)
        {
            int diff = Count - count;
            if (diff > 0)
            {
                Items.RemoveRange (count, diff);
                if (_marked)
                {
                    _saveAll = true;
                }
            }
            else
            {
                for (int i = Count; i < count; i++)
                {
                    MobileListItem item = new MobileListItem ();
                    item.SetIndex(i + BaseIndex);
                    Add (item);
                }
            }
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilecategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.MobileControls
{
    using System;
    using System.ComponentModel;   
    using System.Diagnostics;

    [
        AttributeUsage(AttributeTargets.All)
    ]
    internal sealed class MobileCategoryAttribute : CategoryAttribute
    {
        private static MobileCategoryAttribute deviceSpecific;
        private const String _categoryDeviceSpecific = "Category_DeviceSpecific";
        private const String _categoryPrefix = "Category_";
        private const String _usCategoryDeviceSpecific = "Device Specific";
        private static readonly int _prefixLength = _categoryPrefix.Length;

        // Initializes a new instance of the CategoryAttribute class.
        internal /*public*/ MobileCategoryAttribute(String category) : base(category) 
        {
        }

        internal /*public*/ static CategoryAttribute DeviceSpecific 
        {
            get 
            {
                if (deviceSpecific == null) 
                {
                    deviceSpecific = new MobileCategoryAttribute(_categoryDeviceSpecific);
                }
                return deviceSpecific;
            }
        }

        // This method is called the first time the category property
        // is accessed.  It provides a way to lookup a localized string for
        // the given category.  Classes may override this to add their
        // own localized names to categories.  If a localized string is
        // available for the given value, the method should return it.
        // Otherwise, it should return null.
        protected override String GetLocalizedString(String value)
        {
            Debug.Assert(value != null);
            String localizedValue = null;

            int index = value.IndexOf(_categoryPrefix);

            // mobile controls have "Category_" prefix.
            if (index == 0)
            {
                String categoryName = value.Substring(_prefixLength);

                // see if already defined in base class.
                localizedValue = base.GetLocalizedString(categoryName);
            }

            // fall back to local resource string.
            if (localizedValue == null)
            {
                localizedValue = (String) SR.GetString(value);
            }

            if (localizedValue == null && value.Equals(_usCategoryDeviceSpecific))
            {
                localizedValue = (String) SR.GetString(SR.Category_DeviceSpecific);
            }

            // This attribute is internal, and we should never have a missing resource string.
            Debug.Assert(localizedValue != null, 
                "All MobileWebForms category attributes should have localized strings.  Category '"
                + value + "' not found.");
            return localizedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilecontrolbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileControlBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Control builder for mobile controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileControlBuilder : ControlBuilder
    {
        public override bool AllowWhitespaceLiterals()
        {
            return false;
        }

        public override Type GetChildControlType(String tagName, IDictionary attributes) 
        {
            Type type;

            if (String.Compare(tagName, typeof(DeviceSpecific).Name, true, CultureInfo.InvariantCulture) == 0) 
            {
                type = typeof(DeviceSpecific);
            }
            else
            {
                type = base.GetChildControlType(tagName, attributes);
                //if (type == null)
                //{
                //    type = Parser.RootBuilder.GetChildControlType(tagName, attributes);
                //}
            }

            //  enforce valid control nesting behaviour

            if (typeof(Form).IsAssignableFrom(type))
            {
                throw new Exception(
                    SR.GetString(SR.MobileControlBuilder_ControlMustBeTopLevelOfPage,
                                 "Form"));
            }

            if (typeof(StyleSheet).IsAssignableFrom(type))
            {
                throw new Exception(
                    SR.GetString(SR.MobileControlBuilder_ControlMustBeTopLevelOfPage,
                                 "StyleSheet"));
            }

            if (typeof(Style).IsAssignableFrom(type) && !typeof(StyleSheet).IsAssignableFrom(ControlType))
            {
                throw new Exception(
                    SR.GetString(SR.MobileControlBuilder_StyleMustBeInStyleSheet));
            }

            return type;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilelistitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileListItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls 
{
    /*
     * List Item type - enumeration.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public enum MobileListItemType
    {
        HeaderItem,
        ListItem,
        FooterItem,
        SeparatorItem
    }

    /*
     * Mobile List Item class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        PersistName("Item"),
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileListItem : TemplateContainer, IStateManager
    {
        private const int SELECTED = 0;
        private const int MARKED = 1;
        private const int TEXTISDIRTY = 2;
        private const int VALUEISDIRTY = 3;
        private const int SELECTIONISDIRTY = 4;

        private int _index;
        private MobileListItemType _itemType;
        private Object _dataItem;
        private String _text;
        private String _value;
        private BitArray _flags;

        public MobileListItem() : this(null, null, null) 
        {
        }

        public MobileListItem(String text) : this(null, text, null) 
        {
        }

        public MobileListItem(String text, String value) : this(null, text, value)
        {
        }

        public MobileListItem(MobileListItemType itemType) : this (null, null, null)
        {
            _itemType = itemType;
        }

        public MobileListItem(Object dataItem, String text, String value)
        {
            _index = -1;
            _dataItem = dataItem;
            _text = text;
            _value = value;
            _flags = new BitArray(5);
            _itemType = MobileListItemType.ListItem;
        }

        internal MobileListItemType ItemType
        {
            get
            {
                return _itemType;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int Index
        {
            get
            {
                return _index;
            }
        }

        internal void SetIndex(int value)
        {
            _index = value;
        }

        public static implicit operator MobileListItem(String s) 
        {
            return new MobileListItem(s);
        }

        [
            DefaultValue("")
        ]        
        public String Text 
        {
            get 
            {
                String s;
                if (_text != null)
                {
                    s = _text;
                }
                else if (_value != null)
                {
                    s = _value;
                }
                else
                {
                    s = String.Empty;
                }
                return s;
            }

            set 
            {
                _text = value;
                if (((IStateManager)this).IsTrackingViewState)
                {
                    _flags.Set (TEXTISDIRTY,true);
                }
            }
        }

        [
            DefaultValue("")
        ]
        public String Value 
        {
            get 
            {
                String s;
                if (_value != null)
                {
                    s = _value;
                }
                else if (_text != null)
                {
                    s = _text;
                }
                else
                {
                    s = String.Empty;
                }
                return s;
            }

            set 
            {
                _value = value;
                if (_flags.Get (MARKED))
                {
                    _flags.Set (VALUEISDIRTY,true);
                }
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public Object DataItem
        {
            get
            {
                return _dataItem;
            }
            set
            {
                _dataItem = value;
            }
        }

        public override bool Equals(Object o) 
        {
            MobileListItem other = o as MobileListItem;
            if (other != null) 
            {
                return Value.Equals(other.Value) && Text.Equals(other.Text);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static MobileListItem FromString(String s) 
        {
            return new MobileListItem(s);
        }

        public override String ToString() 
        {
            return Text;
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT, FOR ITEM'S DATA (NON-CONTROL) STATE.
        /////////////////////////////////////////////////////////////////////////

        internal virtual Object SaveDataState()
        {
            String sa0 = _flags.Get(TEXTISDIRTY) ? _text : null;
            String sa1 = _flags.Get(VALUEISDIRTY) ? _value : null;

            if (sa0 == null && sa1 == null)
            {
                return null;
            }
            else
            {
                return new String[2] { sa0, sa1 };
            }
        }

        internal virtual void LoadDataState(Object state)
        {
            if (state != null) 
            {
                String[] sa = (String[])state;
                if (sa[0] != null)
                {
                    Text = sa[0];
                }
                if (sa[1] != null)
                {
                    Value = sa[1];
                }
            }
        }

        bool IStateManager.IsTrackingViewState
        {   
            get
            {
                return _flags.Get (MARKED);
            }
        }

        void IStateManager.LoadViewState(Object state) 
        {
            LoadDataState (state);
        }

        void IStateManager.TrackViewState() 
        {
            _flags.Set (MARKED, true);
        }

        Object IStateManager.SaveViewState() 
        {
            return SaveDataState ();
        }

        internal virtual bool Dirty 
        {
            get 
            { 
                return (_flags.Get(TEXTISDIRTY) || _flags.Get(VALUEISDIRTY)); 
            }
            set 
            { 
                _flags.Set (TEXTISDIRTY, value); 
                _flags.Set (VALUEISDIRTY, value); 
            }
        }

        internal bool SelectionDirty 
        {
            get 
            { 
                return _flags.Get(SELECTIONISDIRTY);
            }
            set 
            { 
                _flags.Set (SELECTIONISDIRTY, value); 
            }
        }

        /// <include file='doc\listitem.uex' path='docs/doc[@for="ListItem.Selected"]/*' />
        /// <devdoc>
        ///    <para>Specifies a value indicating whether the
        ///       item is selected.</para>
        /// </devdoc>
        [
            DefaultValue(false)
        ]
        public bool Selected {
            get { 
                return _flags.Get(SELECTED); 
            }
            set { 
                _flags.Set(SELECTED,value); 
                if (((IStateManager)this).IsTrackingViewState)
                {
                    _flags.Set (SELECTIONISDIRTY,true);
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  EVENT BUBBLING
        /////////////////////////////////////////////////////////////////////////

        protected override bool OnBubbleEvent(Object source, EventArgs e) 
        {
            if (e is CommandEventArgs) 
            {
                ListCommandEventArgs args = new ListCommandEventArgs(this, source, (CommandEventArgs)e);
                RaiseBubbleEvent (this, args);
                return true;
            }
            return false;
        }

    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilecontrolssectionhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileControlsSectionHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Configuration;
using System.Diagnostics;
using System.Xml;
using System.Web.Mobile;
using System.Reflection;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileControlsSectionHandler : IConfigurationSectionHandler
    {
        // IConfigurationSectionHandler methods
        Object IConfigurationSectionHandler.Create(Object parent, Object context, XmlNode input)
        {
            // see ASURT 123738
            if (context == null || context.GetType() != typeof(System.Web.Configuration.HttpConfigurationContext)) {
                return null;
            }
            
            ControlsConfig config = new ControlsConfig((ControlsConfig)parent);

            // First step through each attribute on the <mobilecontrols> element
            // and update the ControlsConfig dictionary with it.
            XmlAttributeCollection attributes = input.Attributes;
            foreach (XmlNode attribute in attributes)
            {
                config[attribute.Name] = attribute.Value;
            }

            //check validity of cookielessDataDictionary type
            String cookielessDataDictionaryType = config["cookielessDataDictionaryType"];
            if( (cookielessDataDictionaryType != null) &&
                (cookielessDataDictionaryType != String.Empty) )
            {
                Type t = Type.GetType(cookielessDataDictionaryType);
                if (t == null)  
                {
                    throw new ConfigurationException(
                        SR.GetString(SR.MobileControlsSectionHandler_TypeNotFound,
                                 cookielessDataDictionaryType,
                                 "IDictionary"),
                        input);
                }
                if (!(typeof(IDictionary).IsAssignableFrom(t)))
                {
                    throw new ConfigurationException(
                        SR.GetString(SR.MobileControlsSectionHandler_NotAssignable,
                                     cookielessDataDictionaryType,
                                     "IDictionary"),
                        input);
                }

            }

            // Iterate through each <device> tag within the config section
            ConfigurationSectionHelper helper = new ConfigurationSectionHelper();
            foreach(XmlNode nextNode in input)
            {
                helper.Node = nextNode;

                if(helper.IsWhitespaceOrComment())
                {
                    continue;
                }

                helper.RejectNonElement();
                
                // handle <device> tags
                switch(nextNode.Name)
                {
                case "device":
                    String deviceName = helper.RemoveStringAttribute("name", false);
                    
                    IndividualDeviceConfig idc = CreateDeviceConfig(config, helper, deviceName);

                    helper.CheckForUnrecognizedAttributes();

                    // Iterate through every control adapter
                    // within the <device>
                    foreach(XmlNode currentChild in nextNode.ChildNodes)
                    {
                        helper.Node = currentChild;

                        if(helper.IsWhitespaceOrComment())
                        {
                            continue;
                        }

                        helper.RejectNonElement();
                        
                        if (!currentChild.Name.Equals("control"))
                        {
                            throw new ConfigurationException(
                                SR.GetString(SR.MobileControlsSectionHandler_UnknownElementName, "<control>"),
                                currentChild);
                        }
                        else
                        {
                            String controlName = helper.RemoveStringAttribute("name", true);
                            String adapterName = helper.RemoveStringAttribute("adapter", true);
                            helper.CheckForUnrecognizedAttributes();
                            
                            idc.AddControl(CheckedGetType(controlName, "control", helper, typeof(Control), currentChild),
                                           CheckedGetType(adapterName, "adapter", helper, typeof(IControlAdapter), currentChild));

                        }

                        helper.Node = null;
                    }

                    // Add complete device config to master configs.
                    if (deviceName == String.Empty || deviceName == null)
                    {
                        deviceName = Guid.NewGuid().ToString();
                    }
                    
                    if (!config.AddDeviceConfig(deviceName, idc))
                    {
                        // Problem is due to a duplicated name
                        throw new ConfigurationException(
                            SR.GetString(SR.MobileControlsSectionHandler_DuplicatedDeviceName, deviceName),
                            nextNode);
                        
                    }
                    
                    helper.Node = null;
                    break;
                default:
                    throw new ConfigurationException(
                        SR.GetString(SR.MobileControlsSectionHandler_UnknownElementName, "<device>"),
                        nextNode);
                }
            }

            config.FixupDeviceConfigInheritance(input);

            return config;
            
        }

        // Helper to create a device config given the names of methods
        private IndividualDeviceConfig CreateDeviceConfig(ControlsConfig config,
                                                          ConfigurationSectionHelper helper,
                                                          String deviceName)
        {
            String nameOfDeviceToInheritFrom =
                helper.RemoveStringAttribute("inheritsFrom", false);

            if (nameOfDeviceToInheritFrom == String.Empty)
            {
                nameOfDeviceToInheritFrom = null;
            }
            
            bool propertiesRequired = nameOfDeviceToInheritFrom == null;

            String predicateClass = helper.RemoveStringAttribute("predicateClass", propertiesRequired);
            // If a predicate class is specified, so must a method.
            String predicateMethod = helper.RemoveStringAttribute("predicateMethod", predicateClass != null);
            String pageAdapterClass = helper.RemoveStringAttribute("pageAdapter", propertiesRequired);

            IndividualDeviceConfig.DeviceQualifiesDelegate predicateDelegate = null;
            if (predicateClass != null || predicateMethod != null)
            {
                Type predicateClassType = CheckedGetType(predicateClass, "PredicateClass", helper);
                try
                {
                    predicateDelegate =
                        (IndividualDeviceConfig.DeviceQualifiesDelegate)
                        IndividualDeviceConfig.DeviceQualifiesDelegate.CreateDelegate(
                            typeof(IndividualDeviceConfig.DeviceQualifiesDelegate),
                            predicateClassType,
                            predicateMethod);
                }
                catch
                {
                    throw new ConfigurationException(
                        SR.GetString(SR.MobileControlsSectionHandler_CantCreateMethodOnClass,
                                     predicateMethod, predicateClassType.FullName),
                        helper.Node);
                }
            }
                    
            Type pageAdapterType = null;
            if (pageAdapterClass != null)
            {
                pageAdapterType = CheckedGetType(pageAdapterClass, "PageAdapterClass", helper);
            }

            return new IndividualDeviceConfig(config,
                                              deviceName,
                                              predicateDelegate,
                                              pageAdapterType,
                                              nameOfDeviceToInheritFrom);
        }


        // Helper method to encapsulate type lookup followed by
        // throwing a ConfigurationException on failure.
        private Type CheckedGetType(String typename,
                                    String whereUsed,
                                    ConfigurationSectionHelper helper)
        {
            Type t = Type.GetType(typename);
            if (t == null)
            {
                throw new ConfigurationException(
                    SR.GetString(SR.MobileControlsSectionHandler_TypeNotFound,
                                 typename,
                                 whereUsed),
                    helper.Node);
            }

            return t;
        }

        private Type CheckedGetType(String typename,
                                    String whereUsed,
                                    ConfigurationSectionHelper helper,
                                    Type typeImplemented,
                                    XmlNode input)
        {
            Type t = CheckedGetType(typename, whereUsed, helper);
            if(!typeImplemented.IsAssignableFrom(t))
            {
                throw new ConfigurationException(
                    SR.GetString(SR.MobileControlsSectionHandler_NotAssignable,
                                 t,
                                 typeImplemented),
                    input);
            }
            return t;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilepage.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobilePage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Web.SessionState;
using System.Web.Mobile;
using System.Web.Security;
using System.Web.Util;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile page class.
     * The page will use device id to create the appropriate DeviceAdapter,
     * and then delegate all major functions to the adapter.
     *
     * THE MOBILE PAGE CLASS DOES NOT CONTAIN DEVICE-SPECIFIC CODE.
     *
     * All mobile aspx pages MUST extend from this using page inherit directive:
     * <%@ Page Inherits="System.Web.UI.MobileControls.MobilePage" Language="cs" %>
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        Designer("Microsoft.VSDesigner.MobileWebForms.MobileWebFormDesigner, " + AssemblyRef.MicrosoftVSDesignerMobile, typeof(IRootDesigner)),
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobilePage: Page
    {
        public static readonly String HiddenPostEventSourceId = postEventSourceID;
        public static readonly String HiddenPostEventArgumentId = postEventArgumentID;
        public static readonly String ViewStateID = "__VIEWSTATE";
        public static readonly String HiddenVariablePrefix = "__V_";
        public static readonly String PageClientViewStateKey = "__P";

        private const String DesignerAdapter = "System.Web.UI.MobileControls.Adapters.HtmlPageAdapter";
        private IPageAdapter _pageAdapter;
        private bool _debugMode = false;
        private StyleSheet _styleSheet = null;
        private IDictionary _hiddenVariables;
        private Hashtable _clientViewState;
        private String _eventSource;
        private Hashtable _privateViewState = new Hashtable();
        bool _privateViewStateLoaded = false;
        private NameValueCollection _requestValueCollection;
        private bool _isRenderingInForm = false;

        protected override void AddParsedSubObject(Object o)
        {
            // Note : AddParsedSubObject is never called at DesignTime
            if (o is StyleSheet)
            {
                if (_styleSheet != null)
                {
                    throw new
                        Exception(SR.GetString(SR.StyleSheet_DuplicateWarningMessage));
                }
                else
                {
                    _styleSheet = (StyleSheet)o;
                }
            }

            base.AddParsedSubObject(o);
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public virtual MobileCapabilities Device
        {
            get
            {
                if (DesignMode)
                {
                    return new
                        System.Web.UI.Design.MobileControls.DesignerCapabilities();
                }
                return (MobileCapabilities)Request.Browser;
            }
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public StyleSheet StyleSheet
        {
            get
            {
                return (_styleSheet != null) ? _styleSheet : StyleSheet.Default;
            }

            set
            {
                _styleSheet = value;
            }
        }

        private IList _forms;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public IList Forms
        {
            get
            {
                if (_forms == null)
                {
                    int probableFormCount = Controls.Count / 2; // since there are literal controls between each
                    _forms = new ArrayList(probableFormCount);
                    AddForms(this);
                }
                return _forms;
            }
        }

        private void AddForms(Control parent)
        {
            foreach (Control control in parent.Controls)
            {
                if (control is Form)
                {
                    _forms.Add(control);
                }
                else if (control is UserControl)
                {
                    AddForms(control);
                }
            }
        }

        private enum RunMode
        {
            Unknown,
            Design,
            Runtime,
        };
        private RunMode _runMode = RunMode.Unknown;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public bool DesignMode
        {
            get
            {
                if (_runMode == RunMode.Unknown)
                {
                    _runMode = RunMode.Runtime;
                    try
                    {
                        _runMode = (HttpContext.Current == null) ? RunMode.Design : RunMode.Runtime;
                    }       
                    catch (Exception)
                    {
                        _runMode = RunMode.Design;
                    }
                }
                return _runMode == RunMode.Design;
            }
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public IPageAdapter Adapter
        {
            get
            {
                if (_pageAdapter == null)
                {
                    IPageAdapter pageAdapter = RequestingDeviceConfig.NewPageAdapter();
                    pageAdapter.Page = this;
                    _pageAdapter = pageAdapter;
                    if(!DesignMode)
                    {
                        Type t = ControlsConfig.GetFromContext(HttpContext.Current).CookielessDataDictionaryType;
                        if(t != null)
                        {
                            pageAdapter.CookielessDataDictionary = Activator.CreateInstance(t) as IDictionary;
                            pageAdapter.PersistCookielessData = true;
                        }
                    }
                }
                return _pageAdapter;
            }
        }

        String _clientViewStateString;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public String ClientViewState
        {
            get
            {
                if (_clientViewState == null || _clientViewState.Count == 0)
                {
                    return null;
                }

                if (_clientViewStateString == null)
                {
                    StringWriter writer = new StringWriter();
                    StateFormatter.Serialize(writer, _clientViewState);
                    _clientViewStateString = writer.ToString();
                }

                return _clientViewStateString;
            }
        }

        private BooleanOption _allowCustomAttributes = BooleanOption.NotSet;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public bool AllowCustomAttributes
        {
            get
            {
                if (DesignMode)
                {
                    return false;
                }

                if (_allowCustomAttributes == BooleanOption.NotSet)
                {
                    _allowCustomAttributes = 
                        ControlsConfig.GetFromContext(Context).AllowCustomAttributes ?
                                    BooleanOption.True : BooleanOption.False;
                }
                return _allowCustomAttributes == BooleanOption.True;
            }

            set
            {
                _allowCustomAttributes = value ? BooleanOption.True : BooleanOption.False;
            }
        }

        private void AddClientViewState(String id, Object viewState)
        {
            if (_clientViewState == null)
            {
                _clientViewState = new Hashtable();
            }
            _clientViewState[id] = viewState;
            _clientViewStateString = null;
        }

        internal void AddClientViewState(MobileControl control, Object viewState)
        {
            AddClientViewState(control.UniqueID, viewState);
        }

        public virtual IControlAdapter GetControlAdapter(MobileControl control)
        {
            IControlAdapter adapter = RequestingDeviceConfig.NewControlAdapter(control.GetType ());
            adapter.Control = control;
            return adapter;
        }

        private IndividualDeviceConfig _deviceConfig = null;
        private IndividualDeviceConfig RequestingDeviceConfig
        {
            get
            {
                if (_deviceConfig == null)
                {
                    if (DesignMode)
                    {
                        _deviceConfig = new DesignerDeviceConfig(DesignerAdapter);
                    }
                    else
                    {
                        _deviceConfig = 
                            ControlsConfig.GetFromContext(Context).GetDeviceConfig(Context);
                    }
                }
                return _deviceConfig;
            }
        }

        private String _appPath;

        public String MakePathAbsolute(String virtualPath)
        {
            if (virtualPath == null || virtualPath.Length == 0)
            {
                return virtualPath;
            }
             
            if (!UrlPath.IsRelativeUrl(virtualPath))
            {
                // For consistency with ResolveUrl, do not apply app path modifier to rooted paths.
                //return Response.ApplyAppPathModifier(virtualPath);
                return virtualPath;
            }
            else
            {
                if (_appPath == null)
                {
                    String path = Request.CurrentExecutionFilePath;
                    path = Response.ApplyAppPathModifier(path);
                    int slash = path.LastIndexOf('/');
                    if (slash != -1)
                    {
                        path = path.Substring(0, slash);
                    }
                    if (path.IndexOf(' ') != -1)
                    {
                        path = path.Replace(" ", "%20");
                    }
                    _appPath = path;
                }
    
                virtualPath = UrlPath.Combine(_appPath, virtualPath);
                return virtualPath;
            }
        }

        private String _relativeFilePath;

        [
            Browsable(false),
        ]
        public String RelativeFilePath
        {
            get
            {
                // Vs7 Property sig will always try to access public properties with get methods no
                // matter Brosable attribute is off or not. We need to check if is DesignMode in 
                // order to prevent the exception from vs7 at design time.
                if (DesignMode)
                {
                    return String.Empty;
                }

                if (_relativeFilePath == null)
                {
                    String s = Context.Request.CurrentExecutionFilePath;
                    String filePath = Context.Request.FilePath;
                    if(filePath.Equals(s))
                    {
                        int slash = s.LastIndexOf('/');
                        if (slash >= 0)
                        {
                            s = s.Substring(slash+1);
                        }
                        _relativeFilePath = s;
                    }
                    else
                    {
                        _relativeFilePath = Server.UrlDecode(UrlPath.MakeRelative(filePath, s));
                    }
                }
                return _relativeFilePath;
            }
        }

        private String _absoluteFilePath;

        [
            Browsable(false),
        ]
        public String AbsoluteFilePath
        {
            get
            {
                // Vs7 Property sig will always try to access public properties with get methods no
                // matter Brosable attribute is off or not. We need to check if Context is null in
                // order to prevent the exception from vs7 at design time.
                if (_absoluteFilePath == null && Context != null)
                {
                    _absoluteFilePath = Response.ApplyAppPathModifier(Context.Request.CurrentExecutionFilePath);
                }
                return _absoluteFilePath;
            }
        }

        private String _uniqueFilePathSuffix;

        [
            Browsable(false),
        ]
        public String UniqueFilePathSuffix
        {
            // Required for browsers that don't properly handle 
            // self-referential form posts.

            get
            {
                if (_uniqueFilePathSuffix == null)
                {
                    // Only need a few digits, so save space by modulo'ing by a prime.
                    // The chosen prime is the highest of six digits.
                    long ticks = DateTime.Now.Ticks % 999983;
                    _uniqueFilePathSuffix = String.Concat(
                        Constants.UniqueFilePathSuffixVariable,
                        ticks.ToString("D6"));
                }
                return _uniqueFilePathSuffix;
            }
        }

        private static String RemoveQueryStringElement(String queryStringText, String elementName)
        {
            int n = elementName.Length;
            int i = 0;
            for (i = 0; i < queryStringText.Length;)
            {
                i = queryStringText.IndexOf(elementName, i);
                if (i < 0)
                {
                    break;
                }
                if (i == 0 || queryStringText[i-1] == '&')
                {
                    if (i+n < queryStringText.Length && queryStringText[i+n] == '=')
                    {
                        int j = queryStringText.IndexOf('&', i+n);
                        if (j < 0)
                        {
                            if (i == 0)
                            {
                                queryStringText = String.Empty;
                            }
                            else
                            {
                                queryStringText = queryStringText.Substring(0, i-1);
                            }
                            break;
                        }
                        else
                        {
                            queryStringText = queryStringText.Remove(i, j-i+1);
                            continue;
                        }
                    }
                }
                i += n;
            }
            return queryStringText;
        }

        [
            Browsable(false),
        ]
        public String QueryStringText
        {
            // Returns the query string text, stripping off a unique file path
            // suffix as required.  Also assumes that if the suffix is
            // present, the query string part is the text after it.

            get
            {
                // Vs7 Property sig will always try to access public properties with get methods no
                // matter Brosable attribute is off or not. We need to check if Context is null in
                // order to prevent the exception from vs7 at design time.
                if(DesignMode)
                {
                    return String.Empty;
                }

                String fullQueryString;

                if (Request.HttpMethod != "POST")
                {
                    fullQueryString = CreateQueryStringTextFromCollection(Request.QueryString);
                }
                else if (Device.SupportsQueryStringInFormAction)
                {
                    fullQueryString = Request.ServerVariables["QUERY_STRING"];
                }
                else
                {
                    fullQueryString = CreateQueryStringTextFromCollection(_requestValueCollection);
                }

                if(fullQueryString != null && fullQueryString.Length > 0)
                {
                    fullQueryString = RemoveQueryStringElement(fullQueryString, Constants.UniqueFilePathSuffixVariableWithoutEqual);
                    fullQueryString = RemoveQueryStringElement(fullQueryString, MobileRedirect.QueryStringVariable);
                    if (!Adapter.PersistCookielessData)
                    {
                        fullQueryString = RemoveQueryStringElement(fullQueryString, FormsAuthentication.FormsCookieName);
                    }
                }
                return fullQueryString;
            }
        }

        private String _activeFormID;
        private Form _activeForm;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public Form ActiveForm
        {
            get
            {
                //  retrieve form cached in local variable
                if (_activeForm != null)
                {
                    return _activeForm;
                }

                //  else get the id from state and retrieve form
                if (_activeFormID != null)
                {
                    _activeForm = GetForm(_activeFormID);
                    _activeForm.Activated = true;
                    return _activeForm;
                }

                //  else first visit to page, so activate first form
                if (_activeForm == null && Forms.Count > 0)
                {
                    _activeForm = (Form)Forms[0];
                    if(IsPostBack) {
                        _activeForm.Activated = true;
                    }
                    return _activeForm;
                }

                if (DesignMode)
                {
                    return null;
                }
                else
                {
                    throw new Exception(
                        SR.GetString(SR.MobilePage_AtLeastOneFormInPage));
                }
            }
            set
            {
                Form oldForm = ActiveForm;
                Form newForm = value;

                _activeForm = newForm;
                _activeFormID = newForm.UniqueID;

                if (newForm != oldForm)
                {
                    oldForm.FireDeactivate(EventArgs.Empty);
                    newForm.FireActivate(EventArgs.Empty);

                    // AUI 5577
                    newForm.PaginationStateChanged = true;
                }
                else
                {
                    newForm.FireActivate(EventArgs.Empty);
                }
            }
        }

        public Form GetForm(String id)
        {
            Form form = FindControl(id) as Form;
            if (form == null)
            {
                throw new ArgumentException(SR.GetString(
                                        SR.MobilePage_FormNotFound, id));
            }
            return form;
        }


        // Perform a "safe" redirect on postback. 
        // Abstracts away differences between clients in redirect behavior after a 
        // postback. Some clients do a GET to the new URL (treating it as a HTTP 303), 
        // others do a POST, with old data. This method ads a query string parameter to
        // the redirection URL, so that the new target page can determine that it's a result
        // of a redirection.

        public void RedirectToMobilePage(String url)
        {
            RedirectToMobilePage(url, true);
        }

        public void RedirectToMobilePage(String url, bool endResponse)
        {
            bool queryStringWritten = url.IndexOf("?") != -1 ? true : false;
            if(Adapter.PersistCookielessData)
            {
                IDictionary dictionary = Adapter.CookielessDataDictionary;
                if(dictionary != null)
                {
                    foreach(String name in dictionary.Keys)
                    {
                        if(queryStringWritten)
                        {
                            url = String.Concat(url, "&");
                        }
                        else
                        {
                            url = String.Concat(url, "?");
                            queryStringWritten = true;
                        }
                        url = String.Concat(url, name + "=" + dictionary[name]);
                    }
                }
            }
            MobileRedirect.RedirectToUrl(Context, url, endResponse);
        }

        // Override Page.Validate to do the validation only for mobile
        // validators that are in the current active form.  Other validators in
        // Page.Validators collection like aggregated web validators and mobile
        // validators in other forms shouldn't be checked.
        public override void Validate()
        {
            // We can safely remove other validators from the validator list
            // since they shouldn't be checked.
            for (int i = Validators.Count - 1; i >= 0; i--)
            {
                IValidator validator = Validators[i];
                if (!(validator is BaseValidator) ||
                    ((BaseValidator) validator).Form != ActiveForm)
                {
                    Validators.Remove(validator);
                }
            }

            base.Validate();
        }

        [
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override void VerifyRenderingInServerForm(Control control) 
        {
            if (!_isRenderingInForm && !DesignMode)
            {
                throw new Exception(SR.GetString(SR.MobileControl_MustBeInForm, 
                                                 control.UniqueID, 
                                                 control.GetType().Name));
            }
        }

        internal void EnterFormRender(Form form)
        {
            _isRenderingInForm = true;
        }

        internal void ExitFormRender()
        {
            _isRenderingInForm = false;
        }

        // Override Page.InitOutputCache to add additional VaryByHeader
        // keywords to provide correct caching of page outputs since by
        // default ASP.NET only keys on URL for caching.  In the case that
        // different markup devices browse to the same URL, caching key on
        // the URL is not good enough.  So in addition to URL, User-Agent
        // header is also added for the key.  Also any additional headers can
        // be added by the associated page adapter.

        private const String UserAgentHeader = "User-Agent";

        protected override void InitOutputCache(int duration,
                                                String varyByHeader,
                                                String varyByCustom,
                                                OutputCacheLocation location,
                                                String varyByParam)
        {
            base.InitOutputCache(duration, varyByHeader, varyByCustom,
                                 location, varyByParam);
            Response.Cache.SetCacheability(HttpCacheability.ServerAndPrivate);
            Response.Cache.VaryByHeaders[UserAgentHeader] = true;

            IList headerList = Adapter.CacheVaryByHeaders;
            if (headerList != null)
            {
                foreach (String header in headerList)
                {
                    Response.Cache.VaryByHeaders[header] = true;
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  HIDDEN FORM VARIABLES
        /////////////////////////////////////////////////////////////////////////

        public bool HasHiddenVariables()
        {
            return _hiddenVariables != null;
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public IDictionary HiddenVariables
        {
            get
            {
                if (_hiddenVariables == null)
                {
                    _hiddenVariables = new Hashtable();
                }
                return _hiddenVariables;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  DEVICE-INDEPENDENT POSTBACK
        /////////////////////////////////////////////////////////////////////////

        // The functionality required here is to trap and handle 
        // postback events at the page level (delegating to the adapter),
        // rather than expecting a control to handle it. 
        // This has to be done in DeterminePostBackMode, because there isn't
        // anything else overrideable.

        protected override NameValueCollection DeterminePostBackMode() 
        {
            // Ignore the transfer case.
            if (Context.Handler != this)
            {
                return null;
            }

            // Let the specific adapter to manipulate the base collection if
            // necessary.
            NameValueCollection collection =
                Adapter.DeterminePostBackMode(Context.Request,
                                              postEventSourceID,
                                              postEventArgumentID,
                                              base.DeterminePostBackMode());

            // Get hidden variables out of the collection.
            if (collection != null)
            {
                // If the page was posted due to a redirect started by calling
                // RedirectToMobilePage, then ignore the postback. For details,
                // see RedirectToMobilePage method elsewhere in this class.

                if (Page.Request.QueryString[MobileRedirect.QueryStringVariable] == MobileRedirect.QueryStringValue)
                {
                    collection = null;
                }
                else
                {
                    int count = collection.Count;
                    for (int i = 0; i < count; i++)
                    {
                        String key = collection.GetKey(i);
                        if (key.StartsWith(HiddenVariablePrefix))
                        {
                            HiddenVariables[key.Substring(HiddenVariablePrefix.Length)] = collection[i];
                        }
                    }
    
                    String eventSource = collection[postEventSourceID];
                    if (eventSource != null)
                    {
                        // Page level event
                        RaisePagePostBackEvent(eventSource, collection[postEventArgumentID]);
                        _eventSource = eventSource;
                    }
                }
            }

            _requestValueCollection = collection;

            // If doing a postback, don't allow redirections.

            if (collection != null)
            {
                MobileRedirect.DisallowRedirection(Context);
            }

            return collection;
        }       

        private void RaisePagePostBackEvent(String eventSource, String eventArgument)
        {
            // Let the adapter handle it. 
            Adapter.HandlePagePostBackEvent(eventSource, eventArgument);
        }

        protected override void RaisePostBackEvent(IPostBackEventHandler sourceControl, String eventArgument)
        {
            if (eventArgument == null && sourceControl is Form)
            {
                // This is really a default event sent by an HTML browser. Try to find
                // the default event handler from the active form, and call it.

                Form activeForm = ActiveForm;
                if (activeForm != null)
                {
                    IPostBackEventHandler defaultHandler = activeForm.DefaultEventHandler;
                    if (defaultHandler != null)
                    {
                        base.RaisePostBackEvent(defaultHandler, null);
                    }
                }

                // Otherwise, eat the event - there's no one to send it to, and the form 
                // can't use it.
            }
            else
            {
                base.RaisePostBackEvent(sourceControl, eventArgument);
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN ADAPTER PLUMBING
        /////////////////////////////////////////////////////////////////////////

        protected override void OnInit(EventArgs e)
        {
            #if ICECAP
            IceCapAPI.StartProfile(IceCapAPI.PROFILE_THREADLEVEL, IceCapAPI.PROFILE_CURRENTID);
            #endif
            OnDeviceCustomize(new EventArgs());

            // Accessing Request throws exception at designtime
            if(!DesignMode && Request.Headers["__vs_debug"] != null)
            {
                _debugMode = true;
            }

            // ASP.NET requires the following method to be called to have
            // ViewState calculated for the page.
            RegisterViewStateHandler();

            Adapter.OnInit(e);
            base.OnInit(e);
        }

        protected override void OnLoad(EventArgs e)
        {
            // AUI 865

            if (_eventSource != null && _eventSource.Length > 0)
            {
                MobileControl control = FindControl (_eventSource) as MobileControl;
                if (control != null && (control is IPostBackEventHandler))
                {
                    _activeForm = control.Form;
                    _activeForm.Activated = true;
                }
            }

            Adapter.OnLoad(e);
            base.OnLoad(e);

            if (!IsPostBack)
            {
                ActiveForm.FireActivate(EventArgs.Empty);
            }
        }

        protected override void OnPreRender(EventArgs e)
        {
            Adapter.OnPreRender(e);
            base.OnPreRender(e);
        }

        protected override void Render(HtmlTextWriter writer)
        {
            #if TRACE
            DumpSessionViewState();
            #endif
            
            Adapter.Render(writer);
        }

        #if TRACE
        void DumpSessionViewState()
        {
            ArrayList arr;
            _sessionViewState.Dump(this, out arr);
            StringBuilder sb = new StringBuilder();
            foreach (String s in arr)
            {
                sb.Append(s);
                sb.Append("\r\n");
            }
            Trace.Write("SessionViewState", sb.ToString());
        }
        #endif

        protected override void OnUnload(EventArgs e)
        {
            base.OnUnload(e);
            Adapter.OnUnload(e);
            #if ICECAP
            IceCapAPI.StopProfile(IceCapAPI.PROFILE_THREADLEVEL, IceCapAPI.PROFILE_CURRENTID);
            #endif
        }

        protected virtual void OnDeviceCustomize(EventArgs e)
        {
        }

        internal bool PrivateViewStateLoaded
        {
            get
            {
                return _privateViewStateLoaded;
            }
        }

        public Object GetPrivateViewState(MobileControl ctl)
        {   
            return _privateViewState == null ?
                null :
                _privateViewState[ctl.UniqueID];
        }

        private SessionViewState _sessionViewState = new SessionViewState();
        private static readonly String _controlsRequiringPostBackKey = ".PBC";

        protected override Object LoadPageStateFromPersistenceMedium()
        {
            Object state = null;

            String clientViewStateString = _requestValueCollection[ViewStateID];
            if (clientViewStateString != null)
            {
                _privateViewState = 
                    StateFormatter.Deserialize(clientViewStateString) as Hashtable;
                if (_privateViewState != null)
                {
                    String[] arr = _privateViewState[PageClientViewStateKey] as String[];
                    if (arr != null)
                    {
                        _activeFormID = arr[0];
                        
                        String id = arr[1];
                        if (id != null)
                        {
                            _sessionViewState.Load(this, id);
                            state = _sessionViewState.ViewState;
                            if(state == null)
                            {
                                OnViewStateExpire(EventArgs.Empty);
                            }
                            else
                            {
                                Object[] arrState = state as Object[];
                                if (arrState != null)
                                {
                                    _privateViewState = (Hashtable) arrState[1];
                                    state = arrState[0];
                                }
                            }
                        }
                    }
                    _privateViewState.Remove(PageClientViewStateKey);

                    // If the page had no view state, but had controls requiring postback,
                    // this information was saved in client view state.

                    Object controlsRequiringPostBack = 
                            _privateViewState[_controlsRequiringPostBackKey];
                    if (controlsRequiringPostBack != null)
                    {
                        state = new Triplet(GetTypeHashCode().ToString(), 
                                            null, 
                                            controlsRequiringPostBack);  
                        _privateViewState.Remove(_controlsRequiringPostBackKey);
                    }

                    // Apply whatever private view state can be applied now.
        
                    foreach (DictionaryEntry entry in _privateViewState)
                    {
                        if (entry.Value != null)
                        {
                            MobileControl ctl = FindControl((String)entry.Key) as MobileControl;
                            if (ctl != null)
                            {
                                ctl.LoadPrivateViewStateInternal(entry.Value);
                            }
                        }
                    }
                }
            }

            _privateViewStateLoaded = true;

            if (state == null)
            {
                // Give framework back an empty page view state
                state = new Triplet(GetTypeHashCode().ToString(), null, null);  
            }
            return state;
        }

        protected virtual void OnViewStateExpire(EventArgs e)
        {
            throw new Exception(SR.GetString(SR.SessionViewState_ExpiredOrCookieless));
        }
        
        protected override void SavePageStateToPersistenceMedium(Object view)
        {
            Object viewState = null;
            Object privateViewState = null;
            String serverViewStateID;

            SavePrivateViewStateRecursive(this);

            if (!CheckEmptyViewState(view))
            {
                viewState = view;
            }

            if (Device.RequiresOutputOptimization &&
                _clientViewState != null &&
                _clientViewState.Count > 0 &&
                EnableViewState)
            {
                // Here we take over the content in _clientViewState.  It
                // should be reset to null.  Then subsequently any info added
                // will be set to the client accordingly.
                privateViewState = _clientViewState;
                _clientViewState = null;
                _clientViewStateString = null;
            }

            // Are we being asked to save an empty view state?

            if (viewState == null && privateViewState == null)
            {
                serverViewStateID = null;
            }
            else
            {
                // Our view state is dependent on session state. So, make sure session
                // state is available.

                if (!(this is IRequiresSessionState) || (this is IReadOnlySessionState))
                {
                    throw new Exception(SR.GetString(SR.MobilePage_RequiresSessionState));
                }

                _sessionViewState.ViewState = (privateViewState == null) ?
                    viewState : new Object[2] { viewState, privateViewState };

                serverViewStateID = _sessionViewState.Save(this);
                if (Device.PreferredRenderingMime != "text/vnd.wap.wml" && Device["cachesAllResponsesWithExpires"] != "true")
                {
                    if (String.Compare(Request.HttpMethod, "GET", true, CultureInfo.InvariantCulture) == 0)
                    {
                        Response.Expires = 0;
                    }
                    else
                    {
                        Response.Expires = HttpContext.Current.Session.Timeout;
                    }
                }
            }
            
            String activeFormID = ActiveForm == Forms[0] ? null : ActiveForm.UniqueID;

            // Optimize what is written out.

            if (activeFormID != null || serverViewStateID != null)
            {
                AddClientViewState(PageClientViewStateKey,
                    new String[] { activeFormID, serverViewStateID });
            }
        }

        private bool CheckEmptyViewState(Object viewState)
        {
            Triplet triplet = viewState as Triplet;
            if (triplet == null || triplet.Second != null)
            {
                return false;
            }

            if (triplet.Third != null)
            {
                // If the only thing in viewstate is the set of controls 
                // requiring postback, then save the information in client-side 
                // state instead.

                ArrayList arr = (ArrayList)triplet.Third;
                if (!EnableViewState || arr.Count <= 1)
                {
                    AddClientViewState(_controlsRequiringPostBackKey, triplet.Third);
                }
                else
                {
                    return false;
                }
            }

            return true;
        }

        private void SavePrivateViewStateRecursive(Control control)
        {
            if (control.HasControls())
            {
                IEnumerator e = control.Controls.GetEnumerator();
                while (e.MoveNext())
                {
                    MobileControl c = e.Current as MobileControl;
                    if (c != null)
                    {
                        c.SavePrivateViewStateInternal();
                        SavePrivateViewStateRecursive(c);
                    }
                    else
                    {
                        SavePrivateViewStateRecursive((Control)e.Current);
                    }
                }
            }
        }

        protected override void LoadViewState(Object savedState) 
        {
            if (savedState != null)
            {
                Object[] state = (Object[])savedState;
                if (state.Length > 0)
                {
                    base.LoadViewState(state[0]);
                    if (state.Length > 1)
                    {
                        Adapter.LoadAdapterState(state[1]);
                    }
                }
            }
        }

        protected override Object SaveViewState() 
        {
            Object baseState = base.SaveViewState();
            Object adapterState = Adapter.SaveAdapterState();
            if (adapterState == null)
            {
                return (baseState == null) ? null : new Object[1] { baseState };
            }
            else
            {
                return new Object[2] { baseState, adapterState };
            }
        }

        protected override void OnError(EventArgs e)
        {
            // Let the base class deal with it. A user-written error handler
            // may catch and handle it.

            base.OnError(e);

            Exception error = Server.GetLastError();
            if (error == null)
            {
                return;
            }

            if (!_debugMode)
            {
                if(!HttpContext.Current.IsCustomErrorEnabled)
                {
                    Response.Clear();
                    if (Adapter.HandleError(error, CreateHtmlTextWriter(Response.Output)))
                    {
                        Server.ClearError();
                    }
                }
            }
        }

        protected override HtmlTextWriter CreateHtmlTextWriter(TextWriter writer)
        {
            HtmlTextWriter htmlwriter = Adapter.CreateTextWriter(writer);
            if (htmlwriter == null)
            {
                htmlwriter = base.CreateHtmlTextWriter(writer);
            }
            return htmlwriter;
        }

        /////////////////////////////////////////////////////////////////////////
        //  END ADAPTER PLUMBING
        /////////////////////////////////////////////////////////////////////////

        protected override void AddedControl(Control control, int index) 
        {
            if (control is Form || control is UserControl)
            {
                _forms = null;
            }
            base.AddedControl(control, index);
        }

        protected override void RemovedControl(Control control) 
        {
            if (control is Form || control is UserControl)
            {
                _forms = null;
            }
            base.RemovedControl(control);
        }

        private string GetMacKeyModifier() 
        {
            //NOTE:  duplicate of the version in page.cs, keep in sync

            // Use the page's directory and class name as part of the key (ASURT 64044)
            // We need to make sure that the hash is case insensitive, since the file system
            // is, and strange view state errors could otherwise happen (ASURT 128657)
            int pageHashCode = TemplateSourceDirectory.ToLower(CultureInfo.InvariantCulture).GetHashCode();
            pageHashCode += GetType().FullName.ToLower(CultureInfo.InvariantCulture).GetHashCode();

            string strKey = pageHashCode.ToString(NumberFormatInfo.InvariantInfo);

            // Modify the key with the ViewStateUserKey, if any (ASURT 126375)
            if (ViewStateUserKey != null)
                strKey += ViewStateUserKey;

            return strKey;
        }

        private LosFormatter _stateFormatter;
        private LosFormatter StateFormatter
        {
            get
            {
                if (_stateFormatter == null)
                {
                    if(!EnableViewStateMac)
                    {
                        _stateFormatter = new LosFormatter();
                    }
                    else
                    {
                        _stateFormatter = new LosFormatter(true, GetMacKeyModifier());
                    }
                }
                return _stateFormatter;
            }
        }

        private String CreateQueryStringTextFromCollection(
            NameValueCollection collection)
        {
            const String systemPostFieldPrefix = "__";
            StringBuilder stringBuilder = new StringBuilder();

            if (collection == null)
            {
                return String.Empty;
            }

            for (int i = 0; i < collection.Count; i++)
            {
                String name = collection.GetKey(i);

                if (name != null)
                {
                    if (name.StartsWith(systemPostFieldPrefix))
                    {
                        // Remove well-known postback elements
                        if (name == ViewStateID ||
                            name == postEventSourceID ||
                            name == postEventArgumentID ||
                            name == Constants.EventSourceID ||
                            name == Constants.EventArgumentID ||
                            name.StartsWith(HiddenVariablePrefix))
                        {
                            continue;
                        }
                    }
                    else
                    {
                        String controlId = name;
                        if (controlId.EndsWith(".x") ||
                            controlId.EndsWith(".y"))
                        {
                            // Remove the .x and .y coordinates if the control is
                            // an image button
                            controlId = controlId.Substring(0, name.Length - 2);
                        }

                        if (FindControl(controlId) != null)
                        {
                            // Remove control id/value pairs if present
                            continue;
                        }
                    }
                }

                AppendParameters(collection, name, stringBuilder);
            }

            return stringBuilder.ToString();
        }

        private void AppendParameters(NameValueCollection sourceCollection,
                                      String sourceKey,
                                      StringBuilder stringBuilder)
        {
            String [] values = sourceCollection.GetValues(sourceKey);
            foreach (String value in values)
            {
                if (stringBuilder.Length != 0)
                {
                    stringBuilder.Append('&');
                }

                if (sourceKey == null)
                {
                    // name can be null if there is a query name without equal
                    // sign appended
                    stringBuilder.Append(Server.UrlEncode(value));
                }
                else
                {
                    stringBuilder.Append(Server.UrlEncode(sourceKey));
                    stringBuilder.Append('=');
                    stringBuilder.Append(Server.UrlEncode(value));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilecontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Design;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.Util;
using System.Security.Permissions;


namespace System.Web.UI.MobileControls
{

    /*
     * Mobile control base class.
     * All core controls and extension controls extend from this class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ControlBuilderAttribute(typeof(MobileControlBuilder)),
        Designer(typeof(System.Web.UI.Design.MobileControls.MobileControlDesigner)),
        ParseChildren(false),
        PersistChildren(false),
        ToolboxItem(false),
        ToolboxItemFilter("System.Web.UI"),
        ToolboxItemFilter("System.Web.UI.MobileControls", ToolboxItemFilterType.Require),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class MobileControl : Control, IAttributeAccessor
    {
        private IControlAdapter _adapter;
        private DeviceSpecific _deviceSpecific;
        internal const String InnerTextViewStateKey = "_!InnerText";
        private static String[] _ignoredCustomAttributes;

        static MobileControl()
        {
            // Note: These should be in alphabetical order!
            _ignoredCustomAttributes = new String[2];
            _ignoredCustomAttributes[0] = "designtimedragdrop";
            _ignoredCustomAttributes[1] = "name";
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public IControlAdapter Adapter
        {
            get
            {
                if (_adapter == null && MobilePage != null)
                {
                    _adapter = MobilePage.GetControlAdapter(this);
                }
                return _adapter;
            }
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public MobilePage MobilePage
        {
            get
            {
                Page page = Page;
                if (page != null)
                {
                    MobilePage mobilePage = page as MobilePage;
                    if (mobilePage == null)
                    {
                        if (Site == null || !Site.DesignMode)
                        {
                            throw new Exception(
                                SR.GetString(SR.MobileControl_MustBeInMobilePage,
                                             Page));
                        }
                    }
                    return mobilePage;
                }
                else
                {
                    return null;
                }
            }
        }

        private Form _form = null;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public Form Form
        {
            get
            {
                if (_form == null)
                {
                    for (Control control = this; control != null; control = control.Parent)
                    {
                        Form form = control as Form;
                        if (form != null)
                        {
                            _form = form;
                            return _form;
                        }
                    }

                    if (_form == null && RequiresForm)
                    {
                        throw new Exception(SR.GetString(SR.MobileControl_MustBeInForm, 
                                                         UniqueID,
                                                         GetType().Name));
                    }
                }
                return _form;
            }
        }

        public Form ResolveFormReference(String formID)
        {
            Form form = ResolveFormReferenceNoThrow(formID);
            if (form == null)
            {
                throw new ArgumentException(
                    SR.GetString(SR.MobilePage_FormNotFound, formID));
            }

            return form;
        }

        internal Form ResolveFormReferenceNoThrow(String formID)
        {
            for (Control ctl = this; ctl != null; ctl = ctl.Parent)
            {
                if (ctl is TemplateControl)
                {
                    Form childForm = ctl.FindControl(formID) as Form;
                    if (childForm != null)
                    {
                        return childForm;
                    }
                }
            }

            return null;
        }

        protected override void AddedControl(Control control, int index) 
        {
            _cachedInnerText = null;
            base.AddedControl(control, index);
        }

        protected override void RemovedControl(Control control) 
        {
            MobileControl ctl = control as MobileControl;
            if (ctl != null)
            {
                ctl.InvalidateParentStyles();
            }

            _cachedInnerText = null;
            base.RemovedControl(control);
        }

        internal virtual void InvalidateParentStyles()
        {
            Style.InvalidateParentStyle();
        }

        /////////////////////////////////////////////////////////////////////////
        //  TEMPLATES SUPPORT
        /////////////////////////////////////////////////////////////////////////

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public virtual bool IsTemplated
        {
            get
            {
                if (_deviceSpecific != null && _deviceSpecific.HasTemplates)
                {
                    return true;
                }
                else
                {
                    Style referredStyle = Style.ReferredStyle;
                    return referredStyle != null && referredStyle.IsTemplated;
                }
            }
        }

        public virtual ITemplate GetTemplate(String templateName)
        {
            Debug.Assert(this is ITemplateable);
            ITemplate t = null;

            if (_deviceSpecific != null)
            {
                t = _deviceSpecific.GetTemplate(templateName);
            }

            if (t == null)
            {
                Style referredStyle = Style.ReferredStyle;
                if (referredStyle != null)
                {
                    t = referredStyle.GetTemplate(templateName);
                }
            }

            return t;
        }

        public virtual void EnsureTemplatedUI()
        {
        }

        protected virtual void CreateTemplatedUI(bool doDataBind)
        {
            // It is possible for a rogue control to call this even though
            // the control is not templated. Catch and throw an exception for
            // this case.
            if (!IsTemplated)
            {
                throw new Exception(
                    SR.GetString(SR.MobileControl_NoTemplatesDefined));
            }
            Adapter.CreateTemplatedUI(doDataBind);
        }

        public virtual void CreateDefaultTemplatedUI(bool doDataBind)
        {
            // Create nothing by default.
        }

        // Return the nearest containing TemplateControl (UserControl or Page),
        // or null if none.
        internal TemplateControl FindContainingTemplateControl()
        {
            Control control = this;
            while (!(control is TemplateControl) &&
                   control != null)
            {
                control = control.Parent;
            }

            // We assume that the only template controls are Page and
            // UserControl. 
            Debug.Assert(control == null ||
                         control is Page ||
                         control is UserControl);

            return (TemplateControl)control;
        }
        
        public new String ResolveUrl(String relativeUrl)
        {
            int length;

            if (relativeUrl == null || 
                    (length = relativeUrl.Length) == 0 || 
                    !UrlPath.IsRelativeUrl(relativeUrl))
            {
                return relativeUrl;
            }

            String baseUrl = TemplateSourceDirectory;

            // Determine if there are any . or .. sequences.

            bool containsDots = false;
            for (int examine = 0; examine < length; examine++) 
            {
                examine = relativeUrl.IndexOf('.', examine);
                if (examine < 0)
                {
                    break;
                }

                // Expression borrowed from UrlPath.cs
                if ((examine == 0 || relativeUrl[examine - 1] == '/')
                    && (examine + 1 == length || relativeUrl[examine + 1] == '/' ||
                        (relativeUrl[examine + 1] == '.' && 
                            (examine + 2 == length || relativeUrl[examine + 2] == '/'))))
                {
                    containsDots = true;
                    break;
                }
            }

            if (!containsDots)
            {
                if (baseUrl.Length == 0)
                {
                    return relativeUrl;
                }

                TemplateControl parentTemplateControl = FindContainingTemplateControl();
                if (parentTemplateControl == null || parentTemplateControl is MobilePage)
                {
                    return relativeUrl;
                }
            }

            if (baseUrl.IndexOf(' ') != -1)
            {
                baseUrl = baseUrl.Replace(" ", "%20");
            }

            String url = UrlPath.Combine(baseUrl, relativeUrl);
            return Context.Response.ApplyAppPathModifier(url);
        }

        protected override void OnDataBinding(EventArgs e) 
        {
            if (_containsDataboundLiteral)
            {
                _cachedInnerText = null;
            }
            base.OnDataBinding(e);
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN DESIGN TIME TEMPLATES SUPPORT
        /////////////////////////////////////////////////////////////////////////

        // We need to expose the DeviceSpecific in runtime code for two purposes. A. We need to
        // access all components inside DeviceSpecific. B. We have to persist the modified HTML.
        [
            Browsable(false),
            Bindable(false),
            //PersistenceMode(PersistenceMode.InnerDefaultProperty)
            PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public DeviceSpecific DeviceSpecific
        {
            get
            {
                return _deviceSpecific;
            }
            set
            {
                _deviceSpecific = value;
                if (value != null)
                {
                    value.SetOwner(this);
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  CONTROL OVERRIDES
        /////////////////////////////////////////////////////////////////////////

        protected override void AddParsedSubObject(Object obj)
        {
            if (obj is DeviceSpecific)
            {
                if (DeviceSpecific == null)
                {
                    DeviceSpecific = (DeviceSpecific)obj;
                }
                else
                {
                    throw new Exception(
                        SR.GetString(SR.MobileControl_NoMultipleDeviceSpecifics));
                }
            }
            else
            {
                base.AddParsedSubObject(obj);
            }
        }

        internal virtual void ApplyDeviceSpecifics()
        {
            if (_deviceSpecific != null)
            {
                _deviceSpecific.ApplyProperties();
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN ADAPTER PLUMBING
        /////////////////////////////////////////////////////////////////////////

        protected override void OnInit(EventArgs e)
        {
            MobilePage page = MobilePage;
            bool isRuntime = page != null && !page.DesignMode;

            // We don't want to override the properties at design time.
            if (isRuntime)
            {
                ApplyDeviceSpecifics();
            }
            if (Adapter != null)
            {
                Adapter.OnInit(e);
            }
            base.OnInit(e);

            // If we are being created after the first pass 
            // then 

            if (isRuntime && page.PrivateViewStateLoaded)
            {
                Object privateViewState = ((MobilePage)Page).GetPrivateViewState(this);
                if(privateViewState != null)
                {
                    LoadPrivateViewStateInternal(privateViewState);
                }
            }
        }

        protected virtual bool IsFormSubmitControl()
        {
            return false;
        }

        protected override void OnLoad(EventArgs e)
        {
            IPostBackEventHandler eventHandler = this as IPostBackEventHandler;
            if (Form != null && eventHandler != null && IsFormSubmitControl())
            {
                Form.RegisterEventHandler(eventHandler);
            }

            // Handle custom attributes.

            if (_customAttributes != null && !MobilePage.AllowCustomAttributes)
            {
                // AUI 2346

                ICollection keys = CustomAttributes.Keys;
                String illegalCustomAttributes = null;
                if (keys != null)
                {
                    foreach (String key in keys)
                    {
                        String keyLower = key.ToLower();
                        if (Array.BinarySearch(_ignoredCustomAttributes, keyLower) < 0)
                        {
                            if (illegalCustomAttributes != null)
                            {
                                illegalCustomAttributes += "; ";
                            }
                            illegalCustomAttributes += key + "=" + CustomAttributes[key];
                        }
                    }
                }

                if (illegalCustomAttributes != null)
                {
                    throw new Exception(
                        SR.GetString(SR.MobileControl_NoCustomAttributes,
                                     illegalCustomAttributes));
                }
                
            }
            Adapter.OnLoad(e);
            base.OnLoad(e);
        }

        protected override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);
            Adapter.OnPreRender(e);
        }

        protected override void Render(HtmlTextWriter writer)
        {
            if (RequiresForm && Page != null)
            {
                Page.VerifyRenderingInServerForm(this);
            }

            if (IsVisibleOnPage(Form.CurrentPage))
            {
                OnRender(writer);
            }
        }

        internal virtual bool RequiresForm
        {
            get
            {
                return true;
            }
        }

        protected virtual void OnRender(HtmlTextWriter writer)
        {
            Adapter.Render(writer);
        }

        protected override void OnUnload(EventArgs e)
        {
            base.OnUnload(e);
            Adapter.OnUnload(e);
        }

        public new void RenderChildren(HtmlTextWriter writer)
        {
            base.RenderChildren(writer);
        }

        /////////////////////////////////////////////////////////////////////////
        //  VIEW STATE SUPPORT
        /////////////////////////////////////////////////////////////////////////

        protected override void TrackViewState()
        {
            base.TrackViewState();
            ((IStateManager)Style).TrackViewState();
        }

        protected override void LoadViewState(Object savedState) 
        {
            if (savedState != null)
            {
                Object[] state = (Object[])savedState;
                if (state[0] != null)
                {
                    base.LoadViewState(state[0]);
                }
                if (state[1] != null)
                {
                    ((IStateManager)Style).LoadViewState(state[1]);
                }

                // Reset the property if persisted before, done similarly in
                // ASP.NET
                String s = (String)ViewState[InnerTextViewStateKey];
                if (s != null)
                {
                    InnerText = s;
                }
            }
        }

        protected override Object SaveViewState()
        {
            Object baseState = base.SaveViewState();
            Object styleState = ((IStateManager)Style).SaveViewState();

            if (baseState == null && styleState == null)
            {
                return null;
            }

            return new Object[2] { baseState, styleState };
        }

        internal void SavePrivateViewStateInternal()        
        {
            Object privateState = SavePrivateViewState();
            Object adapterState = Adapter.SaveAdapterState();
            if (privateState != null || adapterState != null)
            {
                privateState = new Object[] { privateState, adapterState };
                MobilePage.AddClientViewState(this, privateState);
            }
        }

        internal void LoadPrivateViewStateInternal(Object state)
        {
            Debug.Assert(state != null);
            Object[] privateState = (Object[])state;
            if (privateState[0] != null)
            {
                LoadPrivateViewState(privateState[0]);
            }
            if (privateState[1] != null)
            {
                Adapter.LoadAdapterState(privateState[1]);
            }
        }

        protected virtual void LoadPrivateViewState(Object state)
        {
        }

        protected virtual Object SavePrivateViewState()
        {
            return null;
        }

        /////////////////////////////////////////////////////////////////////////
        //  CUSTOM PROPERTIES
        /////////////////////////////////////////////////////////////////////////

        private StateBag _customAttributes;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public StateBag CustomAttributes
        {
            get
            {
                if (_customAttributes == null)
                {
                    _customAttributes = new StateBag(true); // Ignore case
                    if (IsTrackingViewState)
                    {
                        ((IStateManager)_customAttributes).TrackViewState();
                    }
                }
                return _customAttributes;
            }
        }

        String IAttributeAccessor.GetAttribute(String name) 
        {
            return (_customAttributes != null) ? (String)_customAttributes[name] : null;
        }

        void IAttributeAccessor.SetAttribute(String name, String value) 
        {
            CustomAttributes[name] = value;
        }


        /////////////////////////////////////////////////////////////////////////
        //  BEGIN STYLE PROPERTIES
        /////////////////////////////////////////////////////////////////////////

        Style _style;

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal protected virtual Style Style
        {
            get
            {
                if (_style == null)
                {
                    _style = CreateStyle();
                    _style.SetControl(this);
                }
                return _style;
            }
        }

        protected virtual Style CreateStyle()
        {
            return new Style();
        }

        internal void RefreshStyle()
        {
            this.Style.Refresh();
        }


        [
            Bindable(false),
            DefaultValue(null),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.MobileControl_StyleReference),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.StyleReferenceConverter))
        ]
        public virtual String StyleReference
        {
            get
            {
                return this.Style.StyleReference;
            }
            set
            {
                this.Style.StyleReference = value;
            }
        }

        [
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.MobileControl_Font),
            NotifyParentProperty(true)
        ]
        public virtual FontInfo Font
        {
            get
            {
                return this.Style.Font;
            }
        }

        [
            Bindable(true),
            DefaultValue(Alignment.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.MobileControl_Alignment),
        ]
        public virtual Alignment Alignment
        {
            get
            {
                return this.Style.Alignment;
            }
            set
            {
                this.Style.Alignment = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(Wrapping.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.MobileControl_Wrapping),
        ]
        public virtual Wrapping Wrapping
        {
            get
            {
                return this.Style.Wrapping;
            }
            set
            {
                this.Style.Wrapping = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(typeof(Color), ""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.MobileControl_ForeColor),
            TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public virtual Color ForeColor
        {
            get
            {
                return this.Style.ForeColor;
            }
            set
            {
                this.Style.ForeColor = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(typeof(Color), ""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.MobileControl_BackColor),
            TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public virtual Color BackColor
        {
            get
            {
                return this.Style.BackColor;
            }
            set
            {
                this.Style.BackColor = value;
            }
        }


        /////////////////////////////////////////////////////////////////////////
        //  END STYLE PROPERTIES
        /////////////////////////////////////////////////////////////////////////

        private String _cachedInnerText = null;
        private bool _containsDataboundLiteral = false;
        private static char[] _newlineChars = { '\r', '\n' };

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        protected String InnerText
        {
            get
            {
                String text = null;
                String innerTextAttribute = (String)ViewState[InnerTextViewStateKey];

                if (_cachedInnerText != null)
                {
                    text = _cachedInnerText;
                }
                else if (HasControls())
                {
                    _containsDataboundLiteral = false;

                    bool containTag;

                    bool trimInnerText = TrimInnerText;
                    bool trimNewlines = TrimNewlines;

                    text = GetControlText(out containTag, out _containsDataboundLiteral, trimInnerText);

                    // Cannot throw exceptions from properties at designtime,
                    // this will break property browser.
                    if (containTag && 
                        !AllowInnerMarkup && 
                        (MobilePage == null || !MobilePage.DesignMode))
                    {
                        throw new Exception(
                            SR.GetString(SR.MobileControl_InnerTextCannotContainTags, 
                            GetType().ToString(), 
                            UniqueID));

                    }

                    // Reset text to empty string at design time if the control
                    // contains DataBoundLiteral child control.
                    if (MobilePage != null && 
                        MobilePage.DesignMode && 
                        _containsDataboundLiteral)
                    {
                        text = String.Empty;
                    }


                    if (trimNewlines)
                    {
                        // Need to trim leading and trailing whitespace, but only up to last newline.

                        int start = 0;
                        int finish = text.Length;
                        int length = text.Length;
                        int i;
                        for (i = 0; i < length; i++)
                        {
                            char c = text[i];
                            if (c == '\n')
                            {
                                start = i + 1;
                            }
                            else if (!Char.IsWhiteSpace(c))
                            {
                                break;
                            }
                        }

                        for (int i2 = length - 1; i2 > i; i2--)
                        {
                            char c = text[i2];
                            if (c == '\r')
                            {
                                finish = i2;
                            }
                            else if (!Char.IsWhiteSpace(c))
                            {
                                break;
                            }
                        }

                        text = text.Substring(start, finish - start);
                    }

                    if ((trimInnerText || trimNewlines) && text.IndexOf('\r') != -1)
                    {
                        // Replace newlines with spaces.
                        text = text.Replace("\r\n", " ");
                    }

                    if (trimNewlines && text.Trim().Length == 0)
                    {
                        text = String.Empty;
                    }

                    _cachedInnerText = text;
                }

                if (text == null || text.Length == 0)
                {
                    text = innerTextAttribute;
                    if (text == null)
                    {
                        text = String.Empty;
                    }
                }

                return text;
            }

            set
            {
                if (!AllowMultiLines && value != null && value.IndexOf('\r') >= 0)
                {
                    throw new ArgumentException(
                        SR.GetString(SR.MobileControl_TextCannotContainNewlines, 
                                     GetType().ToString(), 
                                     UniqueID));
                }

                ViewState[InnerTextViewStateKey] = value;

                // There may be other types of child controls and they should
                // be preserved.  Removing the specific controls in backward
                // direction so they can be removed properly.
                for (int i = Controls.Count - 1; i >= 0; i--)
                {
                    Control child = Controls[i];
                    if (child is LiteralControl ||
                        child is DataBoundLiteralControl ||
                        child is DesignerDataBoundLiteralControl)
                    {
                        Controls.RemoveAt(i);
                    }
                }
                _cachedInnerText = null;
            }
        }

        // make this an internal method so designer could reuse the same logic.
        internal String GetControlText(out bool containTag, out bool containDataboundLiteral)
        {
            return GetControlText(out containTag, out containDataboundLiteral, false);
        }


        private String GetControlText(out bool containTag, out bool containDataboundLiteral, bool trim)
        {
            containTag = false;
            containDataboundLiteral = false;
            bool allowInnerMarkup = AllowInnerMarkup;
            String returnedText = null;

            // PERF: Optimized to avoid constructing builder and writer, unless
            // needed.

            StringBuilder builder = null;
            StringWriter writer = null;
            foreach (Control child in Controls)
            {
                String text;
                bool translate;

                if (child is LiteralControl)
                {
                    text = ((LiteralControl)child).Text;
                    containTag = containTag || text.IndexOf('<') != -1;
                    if (allowInnerMarkup)
                    {
                        translate = false;
                    }
                    else
                    {
                        translate = text.IndexOf('&') != -1;
                    }
                }
                else if (child is DataBoundLiteralControl)
                {
                    text = ((DataBoundLiteralControl)child).Text;
                    containDataboundLiteral = true;
                    // Databound text is not in the persistence format, and thus should not
                    // be translated.
                    translate = false;
                }
                else if (child is DesignerDataBoundLiteralControl)
                {
                    text = ((DesignerDataBoundLiteralControl)child).Text;

                    // If the DesignerDataBoundLiteralControl is not databound, we simply
                    // return empty string for the Text property.
                    if (text == null || text.Length == 0)
                    {
                        containDataboundLiteral = true;
                    }

                    // Databound text is not in the persistence format, and thus should not
                    // be translated.
                    translate = false;
                }
                else if (child is HtmlContainerControl)
                {
                    containTag = true;
                    break;
                }
                else
                {
                    continue;
                }

                if (trim)
                {
                    text = text.Trim ();
                }

                if (translate || returnedText != null)
                {
                    builder = new StringBuilder();
                    writer = new StringWriter(builder);
                    if (returnedText != null)
                    {
                        writer.Write(returnedText);
                        returnedText = null;
                    }
                }

                if (writer != null)
                {
                    if (translate)
                    {
                        TranslateAndAppendText(text, writer);
                    }
                    else
                    {
                        writer.Write(text);
                    }
                }
                else
                {
                    returnedText = text;
                }
            }

            if (returnedText != null)
            {
                return returnedText;
            }
            else if (builder == null)
            {
                return String.Empty;
            }
            else
            {
                return builder.ToString();
            }
        }

        static internal void TranslateAndAppendText(String text, StringWriter writer)
        {
            // Can't quite use HtmlDecode, because HtmlDecode doesn't
            // parse &nbsp; the way we'd like it to.

            if (text.IndexOf('&') != -1)
            {
                if (text.IndexOf("&nbsp;") != -1)
                {
                    text = text.Replace("&nbsp;", "\u00A0");
                }

                HttpUtility.HtmlDecode(text, writer);
            }
            else
            {
                writer.Write(text);
            }
        }

        internal virtual bool AllowMultiLines
        {
            get
            {
                return false;
            }
        }

        internal virtual bool AllowInnerMarkup
        {
            get
            {
                return false;
            }
        }

        internal virtual bool TrimInnerText
        {
            get
            {
                return true;
            }
        }

        internal virtual bool TrimNewlines
        {
            get
            {
                return false;
            }
        }

        public virtual void AddLinkedForms(IList linkedForms)
        {
        }

        //  convenience method for returning a non-null string value
        internal String ToString(Object o)
        {
            if (o == null)
                return String.Empty;
            if (o is String)
                return (String)o;
            return o.ToString();
        }

        public bool IsVisibleOnPage(int pageNumber)
        {
            if (!EnablePagination)
            {
                return true;
            }
            if (FirstPage < 0 || LastPage < 0)
            {
                return true;
            }
            return pageNumber >= FirstPage && pageNumber <= LastPage;
        }

        private int _firstPage = -1;
        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int FirstPage
        {
            get
            {
                return _firstPage;
            }
            set
            {
                _firstPage = value;
            }
        }

        private int _lastPage = -1;
        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int LastPage
        {
            get
            {
                return _lastPage;
            }
            set
            {
                _lastPage = value;
            }
        }

        [
            Browsable(false),
            Bindable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public virtual int VisibleWeight
        {
            get
            {
                int weight = 0;
                if (HasControls())
                {
                    foreach (Control child in Controls)
                    {
                        if (child is MobileControl && child.Visible)
                        {
                            MobileControl control = (MobileControl)child;
                            weight += control.GetVisibleWeight();
                        }
                    }
                }
                if (weight == 0)
                {
                    weight = ControlPager.DefaultWeight;
                }
                return weight;
            }
        }

        internal int GetVisibleWeight()
        {
            int weight = Adapter.VisibleWeight;
            if (weight == ControlPager.UseDefaultWeight)
            {
                weight = VisibleWeight;
            }
            return weight;
        }

        private bool _enablePagination = true;

        internal bool EnablePagination
        {
            get
            {
                return _enablePagination;
            }
            set
            {
                _enablePagination = value;
            }
        }

        protected virtual bool PaginateChildren
        {
            get
            {
                return true;
            }
        }

        public virtual void PaginateRecursive(ControlPager pager)
        {
            if (!EnablePagination)
            {
                return;
            }

            if (PaginateChildren || this.Form.ControlToPaginate == this)
            {
                int firstAssignedPage = -1;
                DoPaginateChildren(pager, this, ref firstAssignedPage);
                if (firstAssignedPage != -1)
                {
                    this.FirstPage = firstAssignedPage;
                }
                else
                {
                    this.FirstPage = pager.GetPage(GetVisibleWeight());
                }
                this.LastPage = pager.PageCount;
            }
            else
            {
                int pageNumber = pager.GetPage(GetVisibleWeight());
                SetControlPageRecursive(this, pageNumber);
                this.FirstPage = pageNumber;
                this.LastPage = pageNumber;
            }
        }

        internal static void DoPaginateChildren(ControlPager pager, Control ctl, ref int firstAssignedPage)
        {
            if (ctl.HasControls())
            {
                foreach (Control child in ctl.Controls)
                {
                    if (child.Visible)
                    {
                        MobileControl mobileCtl = child as MobileControl;
                        if (mobileCtl != null)
                        {
                            mobileCtl.PaginateRecursive(pager);
                            if (firstAssignedPage == -1)
                            {
                                firstAssignedPage = mobileCtl.FirstPage;
                            }
                        }
                        else if (child is UserControl)
                        {
                            DoPaginateChildren(pager, child, ref firstAssignedPage);
                        }
                    }
                }
            }
        }

        internal static void SetControlPageRecursive(Control control, int page)
        {
            if (control.HasControls())
            {
                foreach (Control child in control.Controls)
                {
                    MobileControl mobileChild = child as MobileControl;
                    if (mobileChild != null)
                    {
                            mobileChild.SetControlPage(page);
 
                    }
                    else 
                    {
                        SetControlPageRecursive(child, page);
                    }
                }
            }
        }

        internal static void SetEnablePaginationRecursive(Control control, bool pagination) 
        {
            if(control.HasControls()) {
                foreach(Control child in control.Controls) {
                    SetEnablePaginationRecursive(child,pagination);
                }
            }
            MobileControl mobileControl = control as MobileControl;
            if(mobileControl != null) {
                mobileControl.EnablePagination = pagination;
            }
        }

        internal virtual void SetControlPage(int page)
        {
            FirstPage = page;
            LastPage = page;
            SetControlPageRecursive(this, page);
        }

        protected virtual void OnPageChange(int oldPageIndex, int newPageIndex)
        {
            MobileControl.OnPageChangeRecursive(this, oldPageIndex, newPageIndex);
        }

        private static void OnPageChangeRecursive(Control ctl, int oldPageIndex, int newPageIndex)
        {
            if (ctl.HasControls())
            {
                foreach (Control child in ctl.Controls)
                {
                    MobileControl mobileCtl = child as MobileControl;
                    if (mobileCtl != null)
                    {
                        mobileCtl.OnPageChange(oldPageIndex, newPageIndex);
                    }
                    else
                    {
                        OnPageChangeRecursive(child, oldPageIndex, newPageIndex);
                    }
                }
            }
        }

        private bool _breakAfter = true;

        [
            Browsable(true),
            Bindable(true),
            DefaultValue(true),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.MobileControl_BreakAfter)
        ]
        public virtual bool BreakAfter
        {
            get
            {
                return _breakAfter;
            }

            set
            {
                _breakAfter = value;
            }
        }

        // BEGIN: logic to check for infinite cycles when control trees are instantiated
        // through templates.
        
        // InstantiatingTemplate refers to template that instantiated this control
        // (or null if not instantiated by template).
        private ITemplate _instantiatingTemplate = null;
        private ITemplate InstantiatingTemplate
        {
            get
            {
                return _instantiatingTemplate;
            }
        }

        // The prospective parent of this control is passed as a parameter.  Typically this
        // control has not been added to parent.Controls, so cannot use Parent property.
        private void SetInstantiatingTemplateAndVerify (ITemplate instantiatingTemplate, MobileControl parent)
        {
            for (MobileControl c = parent; c != null; c = c.Parent as MobileControl)
            {
                if (c.InstantiatingTemplate == instantiatingTemplate)
                {
                    throw new Exception (SR.GetString(SR.MobileControl_InfiniteTemplateRecursion));
                }
            }
            _instantiatingTemplate = instantiatingTemplate;
        }
        
        // Typically target has not been added to targetParent.Controls collection yet.
        internal void CheckedInstantiateTemplate(ITemplate template, MobileControl target, MobileControl targetParent)
        {
            template.InstantiateIn (target);
            target.SetInstantiatingTemplateAndVerify (template, targetParent);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistcommandcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListCommandCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List Command Collection class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListCommandCollection : ArrayListCollectionBase, IStateManager
    {
        // ObjectListCommandCollection has a special form of viewstate management.
        // In normal operation, if you add, remove or modify commands in the 
        // collection, the results are saved as part of view state.
        //
        // However, when showing the commands for an item, the ObjectList control
        // raises an event that allows the application to alter the commands
        // specifically for the item. These changes are considered local to the
        // item, and are not saved.
        //
        // To do this, the class uses a private state, declared in the MarkState
        // enumeration below. The following sequence of events are used:
        //
        // 1) Class is created. MarkState is set to MarkState.NotMarked.
        // 2) Class is initialized from persistent values.
        // 3) Framework calls TrackViewState. MarkState is set to MarkState.MArked.
        // 4) Properties can be changed. Changes are reflected in viewstate.
        // 5) Just before raising the ShowItemCommands event, the ObjectList control
        //    calls GlobalStateSet. PreSaveViewState is called to create a 
        //    snapshot of viewstate, and MarkState is set to MarkState.PostMarked.
        // 6) If any changes are made after this, they will be ignored for view state
        //    purposes.
        // 7) The framework calls SaveViewState. Instead of the current view state
        //    (which would include the changes made in Step 6), the snapshot view state
        //     from step 5 is returned.

        private enum MarkState
        {
            NotMarked,
            Marked,
            PostMarked,
        }

        private MarkState _markState = MarkState.NotMarked;
        private bool _dirty;
        private String[] _savedState;

        internal ObjectListCommandCollection()
        {
        }

        public ObjectListCommand this[int index]
        {
            get
            {
                return (ObjectListCommand)Items[index];
            }
        }

        public void Clear()
        {
            foreach (ObjectListCommand command in Items)
            {
                command.Owner = null;
            }
            Items.Clear();
            SetDirty();
        }

        public void Add(ObjectListCommand command)
        {
            AddAt(-1, command);
        }

        public void AddAt(int index, ObjectListCommand command)
        {
            if (index == -1)
            {
                Items.Add(command);
            }
            else
            {
                Items.Insert(index, command);
            }
            command.Owner = this;
            SetDirty();
        }

        public void Remove(String s)
        {
            RemoveAt(IndexOf(s));
        }    

        public void RemoveAt(int index)
        {
            (this[index]).Owner = null;
            Items.RemoveAt(index);
            SetDirty();
        }

        public int IndexOf(String s)
        {
            int index = 0;
            foreach (ObjectListCommand command in Items)
            {
                if (String.Compare(command.Name, s, true, CultureInfo.InvariantCulture) == 0)
                {
                    return index;
                }
                index++;
            }
            return -1;
        }

        internal void GlobalStateSet()
        {
            // Base commands have been set. From here, commands will only be
            // modified on a per-item, non-persistent basis.

            PreSaveViewState();
            _markState = MarkState.PostMarked;
        }

        internal void SetDirty()
        {
            if (_markState == MarkState.Marked)
            {
                _dirty = true;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        private void PreSaveViewState()
        {
            if (_dirty)
            {
                ArrayList commands = Items;
                _savedState = new String[commands.Count * 2];
                int i = 0;
                foreach (ObjectListCommand command in commands)
                {
                    _savedState[i] = command.Name;
                    _savedState[i + 1] = command.Text;
                    i += 2;
                }
            }
            else
            {
                _savedState = null;
            }
        }

        bool IStateManager.IsTrackingViewState
        {
            get
            {
                return _markState != MarkState.NotMarked;
            }
        }

        void IStateManager.TrackViewState() 
        {
            _markState = MarkState.Marked;
        }

        void IStateManager.LoadViewState(Object state) 
        {
            if (state != null)
            {
                String[] commandStates = (String[])state;
                int count = commandStates.Length;
                Clear();
                for (int i = 0; i < count; i += 2)
                {
                    Add(new ObjectListCommand(commandStates[i], commandStates[i + 1]));
                }
            }
        }

        Object IStateManager.SaveViewState() 
        {
            if (_markState == MarkState.Marked)
            {
                PreSaveViewState();
            }
            return _savedState;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistcommand.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListCommand.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List Command class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        PersistName("Command")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListCommand
    {
        private String _name;
        private String _text;
        private ObjectListCommandCollection _owner;

        public ObjectListCommand()
        {
        }

        public ObjectListCommand(String name, String text)
        {
            _name = name;
            _text = text;
        }

        [
            DefaultValue("")
        ]
        public String Name
        {
            get
            {
                return (_name == null) ? String.Empty : _name;
            }

            set
            {
                _name = value;
                if (Owner != null)
                {
                    Owner.SetDirty ();
                }
            }
        }

        [
            DefaultValue("")
        ]
        public String Text
        {
            get
            {
                return (_text == null) ? String.Empty : _text;
            }

            set
            {
                _text = value;
                if (Owner != null)
                {
                    Owner.SetDirty ();
                }
            }
        }

        internal ObjectListCommandCollection Owner
        {
            get
            {
                return _owner;
            }

            set
            {
                _owner = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobileusercontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileUserControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Web.UI;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    [
        Designer("Microsoft.VSDesigner.MobileWebForms.MobileWebFormDesigner, Microsoft.VSDesigner.Mobile", typeof(IRootDesigner)),
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileUserControl : UserControl
    {
        protected override void AddParsedSubObject(Object o)
        {
            // Note : AddParsedSubObject is never called at DesignTime
            if (o is StyleSheet)
            {
                if (_styleSheet != null)
                {
                    throw new
                        Exception(SR.GetString(SR.StyleSheet_DuplicateWarningMessage));
                }
                else
                {
                    _styleSheet = (StyleSheet)o;
                }
            }

            base.AddParsedSubObject(o);
        }

        private StyleSheet _styleSheet = null;
        internal StyleSheet StyleSheet
        {
            get
            {
                return (_styleSheet != null) ? _styleSheet : StyleSheet.Default;
            }

            set
            {
                _styleSheet = value;
            }
        }
        
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\mobilesysdescriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileSysDescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;

namespace System.Web.UI.MobileControls
{
    /// <devdoc>
    ///     DescriptionAttribute marks a property, event, or extender with a
    ///     description. Visual designers can display this description when referencing
    ///     the member.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    internal class MobileSysDescriptionAttribute : DescriptionAttribute
    {
        private bool replaced;

        /// <devdoc>
        ///    <para>Constructs a new sys description.</para>
        /// </devdoc>
        internal MobileSysDescriptionAttribute(String description) : base(description)
        {
        }

        /// <devdoc>
        ///    <para>Retrieves the description text.</para>
        /// </devdoc>
        public override String Description
        {
            get
            {
                if (!replaced)
                {
                    replaced = true;
                    DescriptionValue = SR.GetString(base.Description);                
                }
                return base.Description;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistcommandeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * Object List command event handler - type definition.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void ObjectListCommandEventHandler(Object sender, ObjectListCommandEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistdatabindeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListDataBindEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * ObjectList item data binding arguments.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListDataBindEventArgs : EventArgs {

        private ObjectListItem _item;
        private Object _dataItem;

        public ObjectListDataBindEventArgs(ObjectListItem item, Object dataItem)
        {
            _item = item;
            _dataItem = dataItem;
        }

        public ObjectListItem ListItem 
        {
            get 
            {
                return _item;
            }
        }

        public Object DataItem
        {
            get 
            {
                return _dataItem;
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing.Design;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ControlBuilderAttribute(typeof(ObjectListControlBuilder)),
        DefaultEvent("ItemCommand"),
        DefaultProperty("DataSource"),
        Designer(typeof(System.Web.UI.Design.MobileControls.ObjectListDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerObjectListAdapter)),
        Editor(typeof(System.Web.UI.Design.MobileControls.ObjectListComponentEditor), typeof(ComponentEditor)),
        ToolboxData("<{0}:ObjectList runat=\"server\" LabelStyle-StyleReference=\"title\" CommandStyle-StyleReference=\"subcommand\"></{0}:ObjectList>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectList : PagedControl, INamingContainer, ITemplateable, IPostBackEventHandler
    {
        private static readonly Object EventItemDataBind = new Object();
        private static readonly Object EventItemCommand = new Object();
        private static readonly Object EventItemSelect = new Object();
        private static readonly Object EventShowItemCommands = new Object();

        private Object _dataSource;
        private IEnumerable _resolvedDataSource;
        private ObjectListFieldCollection _fields;
        private ObjectListFieldCollection _autoGeneratedFields;
        private ObjectListFieldCollection _allFields;
        private ObjectListItemCollection _items;
        private ObjectListCommandCollection _commands;
        private ObjectListCommandCollection _globalCommands;
        private int _labelFieldIndex = -1;
        private int[] _tableFieldIndices = null;
        private IEnumerator _storedEnumerator = null;
        private Object _firstDataItem = null;
        private bool _storedDataValid = false;
        private ObjectListViewMode _viewMode = ObjectListViewMode.List;
        private bool _ignoreFieldsItemsViewModeViewState = false;
        private Style _commandStyle = null;
        private Style _labelStyle = null;
        private const string _itemCountViewStateKey = "_!ItemCount";
        private int _selectedIndex = -1;
        private bool _selectedIndexDirty = false;
        private bool _loadingItems = false;

        public static String SelectMoreCommand
        {
            get
            {
                return "More";
            }
        }

        [
            Bindable(true),
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_DataSource)
        ]
        public virtual Object DataSource 
        {
            get 
            {
                return _dataSource;
            }
            set 
            {
                _dataSource = value;
                // _allFields and _resolvedDataSource need to be recalculated.  
                _allFields = null;
                _resolvedDataSource = null;
            }
        }

        [
            Bindable(false),
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_DataMember),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataMemberConverter))
        ]
        public virtual String DataMember
        {
            get 
            {
                String s = (String)ViewState["DataMember"];
                return s == null ? String.Empty : s;
            }
            set 
            {
                ViewState["DataMember"] = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(null),
            Editor(typeof(System.Web.UI.Design.MobileControls.FieldCollectionEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_Fields),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual ObjectListFieldCollection Fields
        {
            get
            {
                if (_fields == null)
                {
                    _fields = new ObjectListFieldCollection(this);
                    if (IsTrackingViewState)
                    {
                        ((IStateManager)_fields).TrackViewState();
                    }
                }
                return _fields;
            }
        }

        [
            Bindable(true),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public virtual ObjectListItemCollection Items
        {
            get
            {
                if (_items == null)
                {
                    _items = new ObjectListItemCollection(this);
                    if (IsTrackingViewState)
                    {
                        ((IStateManager)_items).TrackViewState();
                    }
                }
                return _items;
            }
        }

        [
            Bindable(false),
            Editor(typeof(System.Web.UI.Design.MobileControls.CommandCollectionEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_Commands),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public virtual ObjectListCommandCollection Commands
        {
            get
            {
                if (_commands == null)
                {
                    _commands = new ObjectListCommandCollection();
                    if (IsTrackingViewState)
                    {
                        ((IStateManager)_commands).TrackViewState();
                    }
                }
                return _commands;
            }
        }

        [
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_LabelField),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataFieldConverter))
        ]
        public String LabelField 
        {
            get 
            {
                String s = (String)ViewState["LabelField"];
                return (s != null) ? s : String.Empty;
            }
            set 
            {
                ViewState["LabelField"] = value;
                InvalidateDisplayFieldIndices();
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_DefaultCommand),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DefaultCommandConverter))
        ]
        public String DefaultCommand
        {
            get 
            {
                String s = (String)ViewState["DefaultCommand"];
                return (s != null) ? s : String.Empty;
            }
            set 
            {
                ViewState["DefaultCommand"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Web.UI.Design.MobileControls.TableFieldsEditor),
                typeof(UITypeEditor)),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.ObjectList_TableFields)
        ]
        public String TableFields 
        {
            get 
            {
                String s = (String)ViewState["TableFields"];
                return (s != null) ? s : String.Empty;
            }
            set 
            {
                ViewState["TableFields"] = value;
                InvalidateDisplayFieldIndices();
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int SelectedIndex
        {
            get 
            {
                return _selectedIndex;
            }
            set 
            {
                if (value == -1 && ViewMode != ObjectListViewMode.List)
                {
                    throw new Exception(
                        SR.GetString(SR.ObjectList_MustBeInListModeToClearSelectedIndex));
                }                
                int itemCount = ItemCount > 0 ? ItemCount : Items.Count;
                if (value < -1)
                {
                    throw new ArgumentOutOfRangeException("SelectedIndex",
                        SR.GetString(SR.ObjectList_SelectedIndexTooSmall, value));
                }
                else if (itemCount > 0 && value >= itemCount)
                {
                    throw new ArgumentOutOfRangeException("SelectedIndex",
                        SR.GetString(SR.ObjectList_SelectedIndexTooBig, value, itemCount));
                }
                // End of guard clauses.

                _selectedIndexDirty = (value != _selectedIndex) && IsTrackingViewState;
                DeselectItemIfLoaded(_selectedIndex);
                SelectItemIfLoaded(value);
                _selectedIndex = value;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public ObjectListItem Selection
        {
            get 
            {
                if (SelectedIndex == -1)
                {
                    return null;
                }
                EnsureItemLoaded (SelectedIndex);
                int selectedIndex = TranslateVirtualItemIndex(SelectedIndex);
                if (selectedIndex >= 0 && selectedIndex < Items.Count)
                {
                    Debug.Assert (Items[selectedIndex].Selected);
                    return Items[selectedIndex];
                }
                else
                {
                    return null;
                }
            }
        }

        [
            Bindable(false),
            Browsable(true),
            DefaultValue(true),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.ObjectList_AutoGenerateFields)
        ]
        public bool AutoGenerateFields
        {
            get
            {
                Object b = ViewState["AutoGenerateFields"];
                return (b != null) ? (bool)b : true;
            }
            set
            {
                if (value != AutoGenerateFields)
                {
                    ViewState["AutoGenerateFields"] = value;
                    _allFields = null;
                    _autoGeneratedFields = null;
                    _items = null;
                    InvalidateDisplayFieldIndices();
                }
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public IObjectListFieldCollection AllFields
        {
            get
            {
                if (_allFields == null)
                {
                    if (_autoGeneratedFields == null)
                    {
                        if (_fields == null)
                        {
                            return null;
                        }
                        else
                        {
                            _allFields = _fields;
                        }
                    }
                    else 
                    {
                        if (_fields == null)
                        {
                            _allFields = _autoGeneratedFields;
                        }
                        else 
                        {
                            int count = _fields.Count + _autoGeneratedFields.Count;

                            ArrayList list = new ArrayList(count);

                            foreach (ObjectListField field in _fields)
                            {
                                list.Add(field);
                            }

                            foreach (ObjectListField field in _autoGeneratedFields)
                            {
                                list.Add(field);
                            }

                            _allFields = new ObjectListFieldCollection(this, list);
                        }
                    }
                }
                return _allFields;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int LabelFieldIndex
        {
            get
            {
                if (_labelFieldIndex == -1)
                {
                    CalculateDisplayFieldIndices();
                }
                return _labelFieldIndex;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public Panel Details
        {
            get
            {
                EnsureChildControls();
                if (ViewMode != ObjectListViewMode.Details)
                {
                    throw new Exception(SR.GetString(SR.ObjectList_MustBeInDetailsModeToGetDetails));
                }
                return Selection;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int[] TableFieldIndices
        {
            get
            {
                if (_labelFieldIndex == -1)
                {
                    CalculateDisplayFieldIndices();
                }
                Debug.Assert(_tableFieldIndices != null, "_tableFieldIndices is null.");
                return _tableFieldIndices;
            }
        }

        public override void EnsureTemplatedUI()
        {
            EnsureChildControls();
        }

        protected override void EnsureChildControls()
        {
            // if EnsureChildControls is called before items are created (e.g., at
            // LoadPrivateViewState), there will be no controls.  Need to build child
            // controls in this case, so we set ChildControlsCreated to false.
            ChildControlsCreated = ChildControlsCreated && Controls.Count > 0;
            base.EnsureChildControls();
        }

        private void CalculateDisplayFieldIndices()
        {
            String labelField = LabelField;
            if (labelField.Length > 0)
            {
                _labelFieldIndex = GetFieldIndex(labelField);
            }
            else
            {
                _labelFieldIndex = 0;
            }

            String tableFields = TableFields;
            int length = tableFields.Length;

            // Populate the _tableFieldIndices array.
            ArrayList tableFieldIndexList = new ArrayList();
            for (int pos = 0; pos < length; )
            {
                int nextSemicolon = tableFields.IndexOf(';', pos);
                String fieldName = (nextSemicolon == -1) ? 
                    tableFields.Substring(pos) :
                    tableFields.Substring(pos, nextSemicolon - pos);
                tableFieldIndexList.Add(GetFieldIndex(fieldName));
                pos = nextSemicolon == -1 ? length : nextSemicolon + 1;
            }
            _tableFieldIndices = (int[])tableFieldIndexList.ToArray(typeof(int));
        }

        internal void InvalidateDisplayFieldIndices()
        {
            _labelFieldIndex = -1;
            _tableFieldIndices = null;
        }

        private int GetFieldIndex(String field)
        {
            int index = AllFields.IndexOf(field);
            if (index == -1)
            {
                throw new ArgumentException(SR.GetString(
                                        SR.ObjectList_FieldNotFound, field));
            }
            return index;
        }

        protected override void AddParsedSubObject(Object obj)
        {
            if (!(obj is LiteralControl))
            {
                if (obj is ObjectListField)
                {
                    Fields.Add((ObjectListField)obj);
                } 
                else if (obj is ObjectListCommand)
                {
                    Commands.Add((ObjectListCommand)obj);
                }
                else
                {
                    base.AddParsedSubObject(obj);
                }
            }
        }

        private IEnumerable ResolvedDataSource
        {
            get
            {
                if (_resolvedDataSource == null)
                {
                    _resolvedDataSource = 
                        DataSourceHelper.GetResolvedDataSource(DataSource, DataMember);
                }
                return _resolvedDataSource;
            }
        }

        protected override void CreateChildControls() 
        {
            Controls.Clear();
            if (ViewState[_itemCountViewStateKey] != null)
            {
                CreateChildControls(false);
            }
        }

        private void CreateChildControls(bool doDataBind) 
        {
            if (IsTemplated)
            {
                Controls.Clear();
                CreateTemplatedUI(doDataBind);
                ChildControlsCreated = true;
            }
        }

        public override void DataBind() 
        {
            // Do our own databinding
            OnDataBinding(EventArgs.Empty);

            // Contained items will be databound after they have been created,
            // so we don't want to walk the hierarchy here.
        }
        
        protected override void OnDataBinding(EventArgs e) 
        {
            base.OnDataBinding(e);

            if (ResolvedDataSource == null)
            {
                ClearItemsAndControls();
                return;
            }

            if (AutoGenerateFields)
            {
                CreateAutoGeneratedFields(ResolvedDataSource);
            }

            if ((AllFields == null || AllFields.Count == 0) 
                && MobilePage != null 
                && !MobilePage.DesignMode)
            {
                throw new Exception(
                    SR.GetString(SR.ObjectList_MustHaveOneOrMoreFields));
            }
            
            CreateItems(ResolvedDataSource);
            
            if (!_loadingItems)
            {
                // To clear the selected index, the ViewMode must be list.
                ViewMode = ObjectListViewMode.List;
                SelectedIndex = -1;    
            }
            else
            {
                SelectItemIfLoaded(SelectedIndex);
            }
            
            CreateChildControls(true);
        }

        public void CreateTemplatedItemsList(bool doDataBind)
        {
            ObjectListItemCollection items = Items;

            ITemplate headerTemplate = GetTemplate(Constants.HeaderTemplateTag);
            ITemplate footerTemplate = GetTemplate(Constants.FooterTemplateTag);
            ITemplate itemTemplate = GetTemplate(Constants.ItemTemplateTag);
            ITemplate separatorTemplate = GetTemplate(Constants.SeparatorTemplateTag);
            ITemplate alternatingItemTemplate = GetTemplate(Constants.AlternatingItemTemplateTag);
            if (alternatingItemTemplate == null)
            {
                alternatingItemTemplate = itemTemplate;
            }

            CreateControlItem(MobileListItemType.HeaderItem, headerTemplate, doDataBind);
            for (int i = 0; i < items.Count; i++)
            {
                if (i > 0)
                {
                    CreateControlItem(MobileListItemType.SeparatorItem, 
                                      separatorTemplate, 
                                      doDataBind);
                }
                AddItemAsControl(i, items[i], 
                                   ((i & 1) == 1) ? alternatingItemTemplate : itemTemplate, 
                                   doDataBind);
            }
            CreateControlItem(MobileListItemType.FooterItem, footerTemplate, doDataBind);
        }

        private void AddItemAsControl(
            int itemIndex,
            MobileListItem item,
            ITemplate itemTemplate, 
            bool doDataBind)
        {
            if (itemTemplate != null)
            {
                // No need to do it again, since CreateItems already does it.
                item.Controls.Clear();                
                item.ID = null;
                Controls.Add(item);
                CheckedInstantiateTemplate (itemTemplate, item, this);
                if (doDataBind)
                {
                    item.DataBind();
                }
            }
        }

        private void CreateControlItem(
            MobileListItemType itemType, 
            ITemplate itemTemplate, 
            bool doDataBind)
        {
            if (itemTemplate != null)
            {
                MobileListItem item = new MobileListItem(itemType);
                AddItemAsControl(-1, item, itemTemplate, doDataBind);
            }
        }

        public void CreateTemplatedItemDetails(bool doDataBind)
        {
            ITemplate detailsTemplate = GetTemplate(Constants.ItemDetailsTemplateTag);
            Selection.Controls.Clear();

            // Selection ID must be the same on each request.  AUI 8007.
            Selection.ID = "_ctl";

            if (detailsTemplate != null)
            {
                if (!Controls.Contains (Selection))
                {
                    Controls.Add (Selection);
                }
                CheckedInstantiateTemplate (detailsTemplate, Selection, this);
                if (doDataBind)
                {
                    Selection.DataBind();
                }
            }
        }

        protected virtual void CreateItems(IEnumerable dataSource) 
        {
            Debug.Assert (dataSource != null, "dataSource is null");

            Items.Clear();

            int count = 0;
            IEnumerator enumerator;

            if(_storedDataValid  && _firstDataItem != null)
            {
                enumerator = _storedEnumerator;
                ObjectListItem item = CreateItem(_firstDataItem);
                item.SetIndex(count + Items.BaseIndex);
                Items.Add(item);
                count++;
                _storedDataValid = false;
                _firstDataItem = null;
                _storedEnumerator = null;
            }
            else
            {
                enumerator = dataSource.GetEnumerator();
            }

            while(enumerator.MoveNext())
            {
                Object dataItem = enumerator.Current;
                ObjectListItem item = CreateItem(dataItem);
                item.SetIndex(count + Items.BaseIndex);
                Items.Add(item);
                count++;
            }
        }

        protected virtual ObjectListItem CreateItem(Object dataItem)
        {
            ObjectListItem item = new ObjectListItem(this, dataItem);
            
            // Set fields.

            IObjectListFieldCollection allFields = AllFields;
            int fieldIndex = 0;
            foreach (ObjectListField field in AllFields)
            {
                field.DataBindItem(fieldIndex, item);
                fieldIndex++;
            }

            // Use delegated data binding, if specified.

            if (dataItem != null)
            {
                OnItemDataBind(new ObjectListDataBindEventArgs(item, dataItem));
            }

            return item;
        }

        protected override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);

            if (IsTemplated)
            {
                int firstVisibleItem = FirstVisibleItemIndex;
                int pageSize = VisibleItemCount;
                int lastVisibleItem = firstVisibleItem + pageSize - 1;
                int itemIndex = 0;
                int separatorIndex = 0;
                foreach(Control ctl in Controls)
                {
                    MobileListItem item = ctl as MobileListItem;
                    if (item != null)
                    {
                        if (item.ItemType == MobileListItemType.ListItem)
                        {
                            item.Visible = itemIndex >= firstVisibleItem && itemIndex <= lastVisibleItem;
                            itemIndex++;
                        }
                        else if (item.ItemType == MobileListItemType.SeparatorItem)
                        {
                            item.Visible = separatorIndex >= firstVisibleItem && 
                                                separatorIndex < lastVisibleItem;
                            separatorIndex++;
                        }
                    }
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  FIELD AUTO-GENERATION
        /////////////////////////////////////////////////////////////////////////

        protected void CreateAutoGeneratedFields(IEnumerable dataSource)
        {
            if (dataSource == null)
            {
                return;
            }

            ArrayList list = new ArrayList();
            PropertyDescriptorCollection propertyDescriptors = null;

            if (dataSource is ITypedList)
            {
                propertyDescriptors = 
                    ((ITypedList)dataSource).GetItemProperties(new PropertyDescriptor[0]);
            }

            if (propertyDescriptors == null)
            {
                IEnumerator enumerator = dataSource.GetEnumerator();
                if (enumerator.MoveNext())
                {
                    Object sampleItem = enumerator.Current;
                    StoreEnumerator(enumerator, sampleItem);
                    if (IsBindableType(sampleItem.GetType()))
                    {
                        list.Add(CreateAutoGeneratedField(
                                        SR.GetString(SR.ObjectList_ItemTitle), 
                                        null));
                    }
                    else
                    {
                        propertyDescriptors = TypeDescriptor.GetProperties(sampleItem);
                    }
                }
            }

            if (propertyDescriptors != null && propertyDescriptors.Count > 0)
            {
                foreach (PropertyDescriptor pd in propertyDescriptors)
                {
                    if (IsBindableType(pd.PropertyType))
                    {
                        String title;
                        ObjectListTitleAttribute attr = 
                            (ObjectListTitleAttribute)pd.Attributes[typeof(ObjectListTitleAttribute)];
                        if (attr != null)
                        {
                            title = attr.Title;
                        }
                        else
                        {
                            title = pd.Name;
                        }
                        list.Add(CreateAutoGeneratedField(title, pd.Name));
                    }
                }
            }

            _autoGeneratedFields = new ObjectListFieldCollection(this, list);
        }

        ///  Caches the fact that we have already consumed the first item from the enumeration
        ///  and must use it first during our item creation.
        internal void StoreEnumerator(IEnumerator enumerator, object firstDataItem) 
        {
            _storedEnumerator = enumerator;
            _firstDataItem = firstDataItem;
            _storedDataValid = true;
        }

        private bool IsBindableType(Type type)
        {
            return(type.IsPrimitive ||
                   (type == typeof(String)) ||
                   (type == typeof(DateTime)) ||
                   (type == typeof(Decimal)));
        }

        private ObjectListField CreateAutoGeneratedField(String title, String dataField)
        {
            ObjectListField field = new ObjectListField();
            ((IStateManager)field).TrackViewState();
            field.Title = title;
            if (dataField != null)
            {
                field.DataField = dataField;
            }
            else
            {
                field.SelfReference = true;
            }
            return field;
        }

        Object SaveAutoFieldsState()
        {
            int autoGeneratedCount = (_autoGeneratedFields != null) ? _autoGeneratedFields.Count : 0;
            if (autoGeneratedCount != 0)
            {
                Object[] fieldStates = new Object[autoGeneratedCount];
                for (int i = 0; i < autoGeneratedCount; i++)
                {
                    fieldStates[i] = ((IStateManager)_autoGeneratedFields[i]).SaveViewState();
                }
                return fieldStates;
            }
            else
            {
                return null;
            }
        }

        void LoadAutoFieldsState(Object state)
        {
            if (state != null)
            {
                Object[] fieldStates = (Object[])state;
                int count = fieldStates.Length;
                ArrayList list = new ArrayList(count);
                foreach (Object fieldState in fieldStates)
                {
                    ObjectListField field = new ObjectListField();
                    ((IStateManager)field).TrackViewState();
                    ((IStateManager)field).LoadViewState (fieldState);
                    list.Add(field);
                }
                _autoGeneratedFields = new ObjectListFieldCollection(this, list);
            }
        }

        internal void OnFieldChanged(bool fieldAddedOrRemoved)
        {
            // Called when a field is added, removed, etc.
            if (IsTrackingViewState)
            {
                _items = null;
                // avoid view state being out of sync with fields.
                _ignoreFieldsItemsViewModeViewState = true;
                if (fieldAddedOrRemoved)
                {
                    _allFields = null;
                }
                InvalidateDisplayFieldIndices();
            }
        }

        protected override int InternalItemCount
        {
            get
            {
                if (_items != null && Items.Count > 0)
                {
                    return Items.Count;
                }
                else
                {
                    return 0;
                }
            }
            
        }

        /////////////////////////////////////////////////////////////////////////
        //  EVENT HANDLING
        /////////////////////////////////////////////////////////////////////////

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.ObjectList_OnItemDataBind)
        ]
        public event ObjectListDataBindEventHandler ItemDataBind 
        {
            add
            {
                Events.AddHandler(EventItemDataBind, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemDataBind, value);
            }
        }

        protected virtual void OnItemDataBind(ObjectListDataBindEventArgs e) 
        {
            ObjectListDataBindEventHandler onItemDataBindHandler = 
                (ObjectListDataBindEventHandler)Events[EventItemDataBind];
            if (onItemDataBindHandler != null)
            {
                onItemDataBindHandler(this, e);
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.ObjectList_OnItemCommand)
        ]
        public event ObjectListCommandEventHandler ItemCommand 
        {
            add
            {
                Events.AddHandler(EventItemCommand, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemCommand, value);
            }
        }

        protected virtual void OnItemCommand(ObjectListCommandEventArgs e) 
        {
            ObjectListCommandEventHandler onItemCommandHandler = (ObjectListCommandEventHandler)Events[EventItemCommand];
            if (onItemCommandHandler != null)
            {
                onItemCommandHandler(this, e);
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.ObjectList_OnItemSelect)
        ]
        public event ObjectListSelectEventHandler ItemSelect 
        {
            add
            {
                Events.AddHandler(EventItemSelect, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemSelect, value);
            }
        }

        protected virtual void OnItemSelect(ObjectListSelectEventArgs e) 
        {
            ObjectListSelectEventHandler onItemSelectHandler = (ObjectListSelectEventHandler)Events[EventItemSelect];
            if (onItemSelectHandler != null)
            {
                onItemSelectHandler(this, e);
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public bool HasItemCommandHandler
        {
            get
            {
                return Events[EventItemCommand] != null;
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.ObjectList_OnShowItemCommands)
        ]
        public event ObjectListShowCommandsEventHandler ShowItemCommands 
        {
            add 
            {
                Events.AddHandler(EventShowItemCommands, value);
            }
            remove
            {
                Events.RemoveHandler(EventShowItemCommands, value);
            }
        }

        protected virtual void OnShowItemCommands(ObjectListShowCommandsEventArgs e) 
        {
            ObjectListShowCommandsEventHandler onShowItemCommandsHandler
                = (ObjectListShowCommandsEventHandler)Events[EventShowItemCommands];
            if (onShowItemCommandsHandler != null)
            {
                onShowItemCommandsHandler(this, e);
            }
        }

        protected override bool OnBubbleEvent(Object sender, EventArgs e) 
        {
            bool handled = false;

            if (e is CommandEventArgs)
            {
                if (e is ObjectListCommandEventArgs) 
                {
                    OnItemCommand((ObjectListCommandEventArgs)e);
                    handled = true;
                }
            }

            return handled;
        }

        void IPostBackEventHandler.RaisePostBackEvent(String eventArgument)
        {
            if (!Adapter.HandlePostBackEvent(eventArgument))
            {
                OnItemCommand(new ObjectListCommandEventArgs(Selection, eventArgument));
            }
        }

        public void RaiseDefaultItemEvent(int itemIndex)
        {
            EnsureItemLoaded (itemIndex);
            int itemCollIndex = TranslateVirtualItemIndex(itemIndex);
            SelectedIndex = itemIndex;
            OnItemCommand(new ObjectListCommandEventArgs(Items[itemCollIndex], DefaultCommand));
        }

        public bool SelectListItem(int itemIndex, bool selectMore)
        {
            EnsureItemLoaded (itemIndex);
            int itemCollIndex = TranslateVirtualItemIndex(itemIndex);

            ObjectListSelectEventArgs args = new ObjectListSelectEventArgs(
                                                        Items[itemCollIndex], 
                                                        selectMore);
            SelectedIndex = itemIndex;
            OnItemSelect(args);
            return args.UseDefaultHandling;
        }

        public void PreShowItemCommands(int itemIndex)
        {
            // Called just before commands are shown for a given item. We call 
            // an event handler that can modify (or even replace) the commands collection,
            // but first we mark the collection, and save it off, so that we can 
            // save the state of the collection at this point.

            if (_commands != null)
            {
                _globalCommands = _commands;
                _commands.GlobalStateSet();
            }

            SelectedIndex = itemIndex;

            ObjectListShowCommandsEventArgs eventArgs = 
                new ObjectListShowCommandsEventArgs(Selection, Commands);
            OnShowItemCommands(eventArgs);
            if (eventArgs.Commands != _commands)
            {
                _commands = eventArgs.Commands;
            }
        }

        private void EnsureItemLoaded(int virtualIndex)
        {
            Debug.Assert (virtualIndex >= 0, "virtualIndex < 0");
            if (ItemCount > 0 &&
                    (_items == null || 
                    virtualIndex < Items.BaseIndex || 
                    Items.Count <= virtualIndex - Items.BaseIndex))
            {
                OnLoadItems(new LoadItemsEventArgs(virtualIndex, 1));
            }
        }

        private int TranslateVirtualItemIndex(int virtualIndex)
        {
            Debug.Assert(ItemCount > 0 || Items.BaseIndex == 0);

            // Translate virtual index to true index within collection.            
            // If custom pagination is off, virtual index is the true index.
            return virtualIndex - Items.BaseIndex;
        }

        protected override void OnLoadItems(LoadItemsEventArgs e)
        {
            // We should only load items if the base index has changed, or if
            // the desired items do not exist in the list. Otherwise, we are making
            // the app reload the same items over and over.

            if (e.ItemIndex != Items.BaseIndex || e.ItemCount != Items.Count)
            {
                _loadingItems = true;
                Items.BaseIndex = e.ItemIndex;
                Items.Clear();
                base.OnLoadItems(e);
                _loadingItems = false;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        protected override void TrackViewState()
        {
            base.TrackViewState();
            if (_fields != null)
            {
                ((IStateManager)_fields).TrackViewState();
            }
            if (_commands != null)
            {
                ((IStateManager)_commands).TrackViewState();
            }
            if (_items != null)
            {
                ((IStateManager)_items).TrackViewState();
            }
        }

        protected override Object SavePrivateViewState()
        {
            Object baseState = base.SavePrivateViewState();
            if (ViewMode != ObjectListViewMode.List || _selectedIndexDirty)
            {
                return new Triplet(baseState, (int) ViewMode, SelectedIndex);
            }
            else if (baseState != null)
            {
                return baseState;
            }
            return null;
        }

        protected override void LoadPrivateViewState(Object state)
        {
            if (state != null)
            {
                Triplet stateTriplet = state as Triplet;
                if (stateTriplet != null)
                {
                    base.LoadPrivateViewState (stateTriplet.First);
                    ObjectListViewMode originalViewMode = _viewMode;
                    
                    // use private field because property get calls CreateChildControls.
                    _viewMode = (ObjectListViewMode) stateTriplet.Second;
                    
                    // use property to insure we load items if necessary and set selected index dirty.
                    SelectedIndex = (int)stateTriplet.Third;
                    
                    bool viewModeChanged = (originalViewMode != _viewMode);
                    if (ChildControlsCreated && viewModeChanged)
                    {
                        // This is before items loaded in LVS, so we only do this if
                        // child controls already created in init (e.g., no VS.)
                        CreateChildControls (true);
                    }
                }
                else
                {
                    base.LoadPrivateViewState(state);
                }
            }
        }

        protected override Object SaveViewState() 
        {
            Object baseState, fieldsState, autoFieldsState, commandsState, itemsState;
        
            Debug.Assert (Items != null, "get_Items should initialize Items collection.");
            int count = Items.Count;
            // HasControls implies DataBound on this or a prev req (but not converse).
            if (count > 0 || HasControls()) 
            {
                ViewState[_itemCountViewStateKey] = count;
            }
            baseState = base.SaveViewState();
            fieldsState = (_fields != null) ? ((IStateManager)_fields).SaveViewState() : null;
            autoFieldsState = SaveAutoFieldsState();
            commandsState = (_commands != null) ? ((IStateManager)_commands).SaveViewState() : null;
            itemsState = (_items != null) ? ((IStateManager)_items).SaveViewState() : null;

            if (itemsState != null || 
                fieldsState != null || 
                autoFieldsState != null || 
                commandsState != null )
            {
                return new Object[5]
                { 
                    baseState, 
                    fieldsState, 
                    autoFieldsState, 
                    commandsState, 
                    itemsState
                };
            }
            else if (baseState != null)
            {
                return new Object[1] { baseState };
            }
            return null;
        }

        protected override void LoadViewState(Object savedState) 
        {
            // copy locally (can change during Fields.LVS).
            bool ignoreFieldsItemsViewModeViewState = _ignoreFieldsItemsViewModeViewState;
            if (savedState != null) 
            {
                Object[] state = (Object[])savedState;
                base.LoadViewState(state[0]);

                if (state.Length > 1)
                {
                    // Always load items after loading fields, because field changes can wipe out
                    // items!
                    if(!ignoreFieldsItemsViewModeViewState)
                    {
                        ((IStateManager)Fields).LoadViewState(state[1]);
                        LoadAutoFieldsState(state[2]);
                    }
                    ((IStateManager)Commands).LoadViewState(state[3]);
                    if(!ignoreFieldsItemsViewModeViewState)
                    {
                        ((IStateManager)Items).LoadViewState(state[4]);
                        SelectItemIfLoaded(SelectedIndex);
                    }
                }
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public ObjectListViewMode ViewMode
        {
            get
            {
                return _viewMode;
            }
            set
            {   
                if (SelectedIndex == -1 && value != ObjectListViewMode.List)
                {
                    throw new Exception(SR.GetString(
                        SR.ObjectList_CannotSetViewModeWithNoSelectedItem));
                }
                if (value == ObjectListViewMode.List)
                {
                    // Set pagination state changed to refresh pagination.
                    Form.PaginationStateChanged = true;
                }
                _viewMode = value;
                CreateChildControls(true);
            }
        }

        [
            Bindable(true),
            Browsable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.ObjectList_DetailsCommandText),
        ]
        public String DetailsCommandText
        {
            get
            {
                String detailsCommandText = (String)ViewState["DetailsCommandText"];
                return detailsCommandText != null ? detailsCommandText : String.Empty;
            }
            set
            {
                ViewState["DetailsCommandText"] = value;
            }
        }

        [
            Bindable(true),
            Browsable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.ObjectList_BackCommandText),
        ]
        public String BackCommandText
        {
            get
            {
                String backCommandText = (String) ViewState["BackCommandText"];
                return backCommandText != null ? backCommandText : String.Empty;
            }
            set
            {
                ViewState["BackCommandText"] = value;
            }
        }

        [
            Bindable(true),
            Browsable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.ObjectList_MoreText)
        ]
        public String MoreText
        {
            get
            {
                String moreText = (String)ViewState["MoreText"];
                return moreText != null ? moreText : String.Empty;
            }
            set
            {
                ViewState["MoreText"] = value;
            }
        }

        [
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            MobileCategory(SR.Category_Style),
            MobileSysDescription(SR.ObjectList_CommandStyle),
            NotifyParentProperty(true)
        ]
        public Style CommandStyle
        {
            get
            {
                if (_commandStyle == null)
                {
                    _commandStyle = new Style();
                    _commandStyle.SetControl(this);
                    _commandStyle.StyleReference = "subcommand";
                }
                return _commandStyle;
            }
            set
            {
                _commandStyle = value;
            }
        }

        [
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            MobileCategory(SR.Category_Style),
            MobileSysDescription(SR.ObjectList_LabelStyle),
            NotifyParentProperty(true)
        ]
        public Style LabelStyle
        {
            get
            {
                if (_labelStyle == null)
                {
                    _labelStyle = new Style();
                    _labelStyle.SetControl(this);
                    _labelStyle.StyleReference = "title";
                }
                return _labelStyle;
            }
            set
            {
                _labelStyle = value;
            }
        }

        internal override void InvalidateParentStyles()
        {
            if (_commandStyle != null)
            {
                _commandStyle.InvalidateParentStyle();
            }
            if (_labelStyle != null)
            {
                _labelStyle.InvalidateParentStyle();
            }
            base.InvalidateParentStyles();
        }

        internal override void InternalItemCountChangedHandler(int newItemCount)
        {
            if (newItemCount == 0)
            {
                ClearItemsAndControls();
            }
        }

        private void ClearItemsAndControls()
        {
            ViewMode = ObjectListViewMode.List;
            SelectedIndex = -1;
            Items.Clear();
            Controls.Clear();
        }

        // Wrapper to increase intelligibility at point of call.
        private void SelectItemIfLoaded(int virtualIndex)
        {
            SetItemSelectedPropertyIfItemLoaded(virtualIndex, true);
        }

        // Wrapper to increase intelligibility at point of call.
        private void DeselectItemIfLoaded(int virtualIndex)
        {
            SetItemSelectedPropertyIfItemLoaded(virtualIndex, false);
        }

        private void SetItemSelectedPropertyIfItemLoaded(int virtualIndex, bool newValue)
        {
            if (virtualIndex < 0)
            {
                return;
            }
            int physicalIndex = TranslateVirtualItemIndex(virtualIndex);
            if (physicalIndex >= 0 && physicalIndex < Items.Count)
            {
                Items[physicalIndex].Selected = newValue;
            }
        }
    }


    /*
     * Control builder for object lists.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListControlBuilder : MobileControlBuilder
    {
        public override Type GetChildControlType(String tagName, IDictionary attributes) 
        {
            if (String.Compare(tagName, "Field", true, CultureInfo.InvariantCulture) == 0) 
            {
                return typeof(ObjectListField);
            }
            else if (String.Compare(tagName, "Command", true, CultureInfo.InvariantCulture) == 0) 
            {
                return typeof(ObjectListCommand);
            }
            else
            {
                return base.GetChildControlType(tagName, attributes);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistcommandeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListCommandEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Object List command event arguments
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListCommandEventArgs : CommandEventArgs 
    {
        protected static readonly String DefaultCommand = "Default";
        private ObjectListItem _item;
        private Object _commandSource;

        public ObjectListCommandEventArgs(ObjectListItem item, Object commandSource, CommandEventArgs originalArgs) : base(originalArgs) 
        {
            _item = item;
            _commandSource = commandSource;
        }

        public ObjectListCommandEventArgs(ObjectListItem item, String commandName) : base(commandName, item)
        {
            _item = item;
            _commandSource = null;
        }

        public ObjectListItem ListItem 
        {
            get 
            {
                return _item;
            }
        }

        public Object CommandSource 
        {
            get 
            {
                return _commandSource;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistitemcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls 
{

    /*
     * Object List Item collection class. Does not derive from MobileListItemCollection,
     * because much of the functionality there is disallowed here.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListItemCollection : ArrayListCollectionBase, IStateManager
    {
        private bool _marked = false;
        private bool _dirty = false;
        private ObjectList _owner;
        private int _baseIndex = 0;

        internal ObjectListItemCollection(ObjectList owner)
        {
            _owner = owner;
        }

        internal int BaseIndex
        {
            get
            {
                return _baseIndex;
            }

            set
            {
                _baseIndex = value;
            }
        }

        public ObjectListItem[] GetAll()
        {
            int n = Count;
            ObjectListItem[] result = new ObjectListItem[n];
            if (n > 0) 
            {
                Items.CopyTo (0, result, 0, n);
            }
            return result;
        }

        public ObjectListItem this[int index]
        {
            get
            {
                return (ObjectListItem)Items[index];
            }
        }

        internal void Add(ObjectListItem item)
        {
            Items.Add (item);
            if (_marked)
            {
                _dirty = true;
                item.Dirty = true;
            }
        }

        public void Clear()
        {
            Items.Clear ();
            if (_marked)
            {
                _dirty = true;
            }
        }

        public bool Contains(ObjectListItem item)
        {
            return Items.Contains (item);
        }

        public int IndexOf(ObjectListItem item)
        {
            return Items.IndexOf(item);
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        bool IStateManager.IsTrackingViewState
        {
            get
            {
                return _marked;
            }
        }

        void IStateManager.TrackViewState() 
        {
            _marked = true;
            foreach (IStateManager item in Items)
            {
                item.TrackViewState();
            }
        }

        void IStateManager.LoadViewState(Object state) 
        {
            if (state != null)
            {
                Object[] changes = (Object[])state;
                Debug.Assert (changes.Length == 2);
                if (changes[0] == null)
                {
                    Clear ();
                }
                else
                {
                    Object[] itemChanges = (Object[])changes[0];
                    EnsureCount (itemChanges.Length);
                    int i = 0;
                    foreach (IStateManager item in Items)
                    {
                        item.LoadViewState (itemChanges[i++]);
                    }
                }

                int oldBaseIndex = BaseIndex;
                BaseIndex = (int)changes[1];
                if (oldBaseIndex != BaseIndex)
                {
                    int index = BaseIndex;
                    foreach (ObjectListItem item in Items)
                    {
                        item.SetIndex(index++);
                    }
                }
            }
        }

        Object IStateManager.SaveViewState() 
        {
            if (!_dirty)
            {
                return null;
            }

            Object[] itemChanges;
            if (Count > 0)
            {
                itemChanges = new Object[Count];
                int i = 0;
                foreach (IStateManager item in Items)
                {
                    itemChanges[i++] = item.SaveViewState ();
                }
            }
            else
            {
                itemChanges = null;
            }

            if (itemChanges == null && BaseIndex == 0)
            {
                return null;
            }
            else
            {
                return new Object[2] { itemChanges, BaseIndex };
            }
        }

        private void EnsureCount(int count)
        {
            int diff = Count - count;
            if (diff > 0)
            {
                Items.RemoveRange (count, diff);
                if (_marked)
                {
                    _dirty = true;
                }
            }
            else
            {
                for (int i = Count; i < count; i++)
                {
                    ObjectListItem item = new ObjectListItem(_owner);
                    item.SetIndex(i + BaseIndex);
                    Add (item);
                }
            }
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistfieldcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListFieldCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List Field Collection class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListFieldCollection : ArrayListCollectionBase, IObjectListFieldCollection, IStateManager
    {
        private ObjectList _owner;
        private bool _marked = false;
        private bool _fieldsSetDirty = false;
        // Used for primary field collection (the one modified by the user).

        internal ObjectListFieldCollection(ObjectList owner) : base(new ArrayList())
        {
            _owner = owner;
        }

        // Used for autogenerated field collections.

        internal ObjectListFieldCollection(ObjectList owner, ArrayList fields) : base(fields)
        {
            _owner = owner;
            foreach (ObjectListField field in fields)
            {
                field.Owner = owner;
            }
        }

        public ObjectListField[] GetAll()
        {
            int n = Count;
            ObjectListField[] allFields = new ObjectListField[n];
            if (n > 0) 
            {
                Items.CopyTo(0, allFields, 0, n);
            }
            return allFields;
        }

        public void SetAll(ObjectListField[] value)
        {
            Items = new ArrayList(value);
            foreach(ObjectListField field in Items)
            {
                field.Owner = _owner;
            }
            if(_marked)
            {
                SetFieldsDirty();
            }
        }

        public ObjectListField this[int index] 
        {
            get 
            {
                return (ObjectListField)Items[index];
            }
        }

        public void Add(ObjectListField field)
        {
            AddAt(-1, field);
        }

        public void AddAt(int index, ObjectListField field)
        {
            if (index == -1)
            {
                Items.Add(field);
            }
            else
            {
                Items.Insert(index, field);
            }
            if (_marked)
            {
                if (!_fieldsSetDirty && index > -1)
                {
                    SetFieldsDirty();
                }
                else
                {
                    ((IStateManager)field).TrackViewState();
                    field.SetDirty();
                }
            }
            field.Owner = _owner;
            NotifyOwnerChange();
        }

        private void SetFieldsDirty()
        {
            foreach (ObjectListField fld in Items)
            {
                ((IStateManager)fld).TrackViewState();
                fld.SetDirty();
            }
            _fieldsSetDirty = true;
        }

        public void Clear()
        {
            Items.Clear();
            if (_marked)
            {
                // Each field will be marked dirty as it is added.
                _fieldsSetDirty = true;
            }
            NotifyOwnerChange();
        }

        public void RemoveAt(int index) 
        {
            if ((index >= 0) && (index < Count)) 
            {
                Items.RemoveAt(index);
            }
            if(_marked && !_fieldsSetDirty)
            {
                SetFieldsDirty();
            }
            NotifyOwnerChange();
        }

        public void Remove(ObjectListField field)
        {
            int index = IndexOf(field);
            if (index >= 0) 
            {
                RemoveAt(index);
            }
        }

        public int IndexOf(ObjectListField field)
        {
            if (field != null) 
            {
                return Items.IndexOf(field, 0, Count);
            }
            return -1;
        }

        public int IndexOf(String fieldIDOrName)
        {
            ArrayList fields = Items;
            int i = 0;
            foreach (ObjectListField field in fields)
            {
                String id = field.UniqueID;
                if (id != null && String.Compare(id, fieldIDOrName, true, CultureInfo.InvariantCulture) == 0)
                {
                    return i;
                }
                i++;
            }
            return -1;
        }

        private void NotifyOwnerChange()
        {
            if (_owner != null)
            {
                _owner.OnFieldChanged(true);    // fieldAddedOrRemoved = true
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        bool IStateManager.IsTrackingViewState
        {
            get
            {
                return _marked;
            }
        }

        void IStateManager.TrackViewState()
        {
            _marked = true;
            foreach (IStateManager field in Items)
            {
                field.TrackViewState();
            }
        }

        void IStateManager.LoadViewState(Object savedState)
        {
            if (savedState != null)
            {
                Object[] stateArray = (Object[]) savedState;
                bool allFieldsSaved = (bool) stateArray[0];
                if (allFieldsSaved) 
                {
                    // All fields are in view state.  Any fields loaded until now are invalid.
                    ClearFieldsViewState();
                }
                Object[] fieldStates = (Object[])stateArray[1];
                EnsureCount(fieldStates.Length);
                for (int i = 0; i < fieldStates.Length; i++)
                {
                    ((IStateManager)Items[i]).LoadViewState(fieldStates[i]);
                }
                if (allFieldsSaved)
                {
                    SetFieldsDirty();
                }
            }
        }

        Object IStateManager.SaveViewState()
        {
            int fieldsCount = Count;
            if (fieldsCount > 0)
            {
                Object[] fieldStates = new Object[fieldsCount];
                bool haveState = _fieldsSetDirty;
                for (int i = 0; i < fieldsCount; i++)
                {
                    fieldStates[i] = ((IStateManager)Items[i]).SaveViewState();
                    if (fieldStates[i] != null)
                    {
                        haveState = true;
                    }
                }
                if (haveState)
                {
                    return new Object[]{_fieldsSetDirty, fieldStates};
                }
            }
            return null;
        }

        private void EnsureCount(int count)
        {

            int diff = Count - count;
            if (diff > 0)
            {
                Items.RemoveRange(count, diff);
                NotifyOwnerChange();
            }
            else
            {
                // Set owner = null, to avoid multiple change notifications. 
                // We'll call it just once later.

                ObjectList prevOwner = _owner;
                _owner = null;
                for (int i = diff; i < 0; i++)
                {
                    ObjectListField field = new ObjectListField();
                    Add(field);
                    field.Owner = prevOwner;
                }
                _owner = prevOwner;
                NotifyOwnerChange();
            }
        }

        private void ClearFieldsViewState()
        {
            foreach (ObjectListField field in Items)
            {
                field.ClearViewState();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistfield.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListField.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List Field class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        PersistName("Field")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public sealed class ObjectListField : IStateManager
    {
        private StateBag _stateBag = new StateBag();
        private bool _marked;
        private PropertyDescriptor _dataFieldDescriptor;
        private ObjectList _owner;
        private bool _selfReference = false;

        [
            DefaultValue("")
        ]
        public String Name
        {
            get
            {
                String s = (String)ViewState["Name"];
                return (s == null) ? String.Empty : s;
            }
            set
            {
                ViewState["Name"] = value;
            }
        }

        [
            DefaultValue("")
        ]
        public String DataField
        {
            get
            {
                String s = (String)ViewState["DataField"];
                return (s == null) ? String.Empty : s;
            }
            set
            {
                ViewState["DataField"] = value;
                NotifyOwnerChange();
            }
        }

        [
            DefaultValue("")
        ]
        public String DataFormatString
        {
            get
            {
                String s = (String)ViewState["DataFormatString"];
                return (s == null) ? String.Empty : s;
            }
            set
            {
                ViewState["DataFormatString"] = value;
                NotifyOwnerChange();
            }
        }

        [
            DefaultValue("")
        ]
        public String Title
        {
            get
            {
                String s = (String)ViewState["Title"];
                return (s == null) ? String.Empty : s;
            }
            set
            {
                ViewState["Title"] = value;
            }
        }

        [
            DefaultValue(true)
        ]
        public bool Visible
        {
            get
            {
                Object b = ViewState["Visible"];
                return (b == null) ? true : (bool)b;
            }
            set
            {
                ViewState["Visible"] = value;
            }
        }

        internal bool SelfReference
        {
            get
            {
                return _selfReference;
            }
            set
            {
                _selfReference = value;
            }
        }

        internal String UniqueID
        {
            get
            {
                Object o = ViewState["Name"];
                if (o != null)
                {
                    return (String)o;
                }
                return (String)ViewState["DataField"];
            }
        }

        private void NotifyOwnerChange()
        {
            // Only called if databinding behavior of the field changes.
            if (_owner != null)
            {
                _owner.OnFieldChanged(false);   // fieldAddedOrRemoved = false;
            }
        }

        private StateBag ViewState
        {
            get
            {
                return _stateBag;
            }
        }

        internal ObjectList Owner
        {
            get
            {
                return _owner;
            }
            set
            {
                _owner = value;
            }
        }

        public void DataBindItem(int fieldIndex, ObjectListItem item)
        {
            Object dataItem = item.DataItem;
            if (dataItem == null)
            {
                return;
            }
                
            if (!SelfReference)
            {
                String dataField = DataField;
                if (dataField.Length == 0)
                {
                    return;
                }

                _dataFieldDescriptor = TypeDescriptor.GetProperties(dataItem).Find(dataField, true);
                if (_dataFieldDescriptor == null && !_owner.MobilePage.DesignMode)
                {
                    throw new Exception(
                        SR.GetString(SR.ObjectListField_DataFieldNotFound, dataField));
                }
            }

            Object data;
            if (_dataFieldDescriptor != null)
            {
                data = _dataFieldDescriptor.GetValue(dataItem);
            }
            // Use fake databound text if the datasource is not accessible at designtime.
            else if (_owner.MobilePage.DesignMode)
            {
                data = SR.GetString(SR.ObjectListField_DataBoundText);
            }
            else
            {
                Debug.Assert(SelfReference, "Shouldn't get this far if !SelfReference");
                data = dataItem;
            }

            String dataText;
            if ((data != null) && (data != System.DBNull.Value))
            {
                String dataFormatString = DataFormatString;
                if (dataFormatString.Length > 0)
                {
                    dataText = String.Format(dataFormatString, data);
                }
                else
                {
                    dataText = data.ToString();
                }
            }
            else
            {
                dataText = String.Empty;
            }
            item[fieldIndex] = dataText;
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        bool IStateManager.IsTrackingViewState
        {
            get
            {
                return _marked;
            }
        }

        void IStateManager.TrackViewState()
        {
            _marked = true;
            ((IStateManager)ViewState).TrackViewState();
        }

        void IStateManager.LoadViewState(Object state)
        {
            if (state != null)
            {
                ((IStateManager)ViewState).LoadViewState(state);
            }
        }

        Object IStateManager.SaveViewState()
        {
            return ((IStateManager)ViewState).SaveViewState();
        }

        internal void SetDirty()
        {
            foreach (StateItem item in _stateBag.Values)
            {
                item.IsDirty = true;
            }
        }

        internal void ClearViewState()
        {
            ViewState.Clear();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistdatabindeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListDataBindEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * ObjectList item data binding handler - type definition.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void ObjectListDataBindEventHandler(Object sender, ObjectListDataBindEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistselecteventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListSelectEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Object List select event arguments
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListSelectEventArgs : EventArgs 
    {
        private ObjectListItem _item;
        private bool _selectMore;
        private bool _useDefaultHandling = true;

        public ObjectListSelectEventArgs(ObjectListItem item, bool selectMore)
        {
            _item = item;
            _selectMore = selectMore;
        }

        public ObjectListItem ListItem 
        {
            get 
            {
                return _item;
            }
        }

        public bool SelectMore
        {
            get 
            {
                return _selectMore;
            }
        }

        public bool UseDefaultHandling
        {
            get
            {
                return _useDefaultHandling;
            }

            set
            {
                _useDefaultHandling = value;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls 
{
    /*
     * Object List Item class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListItem : MobileListItem
    {
        private String[] _fields;
        private bool _dirty;
        private ObjectList _owner;
            
        internal ObjectListItem(ObjectList owner) : this(owner, null)
        {
        }

        internal ObjectListItem(ObjectList owner, Object dataItem) : base(dataItem, null, null)
        {
            _owner = owner;
            _fields = new String[owner.AllFields.Count];
        }

        private int FieldIndexFromKey(String key)
        {
            int index = _owner.AllFields.IndexOf (key);
            if (index == -1)
            {
                throw new ArgumentException(
                    SR.GetString(SR.ObjectList_FieldNotFound, key));
            }
            return index;
        }

        public String this[String key]
        {
            get
            {
                return this[FieldIndexFromKey (key)];
            }

            set
            {
                this[FieldIndexFromKey (key)] = value;
            }
        }

        public String this[int index]
        {
            get
            {
                String s = _fields[index];
                return (s != null) ? s : String.Empty;
            }

            set
            {
                _fields[index] = value;
                if (IsTrackingViewState)
                {
                    _dirty = true;
                }
            }
        }

        public override bool Equals(Object obj) 
        {
            ObjectListItem other = obj as ObjectListItem;
            
            if (other == null)
            {
                return false;
            }

            if (_fields == null && other._fields == null)
            {
                return true;
            }
            else if (_fields == null || other._fields == null)
            {
                return false;
            }

            if (_fields.Length != other._fields.Length)
            {
                return false;
            }

            for (int i = 0; i < _fields.Length; i++)
            {
                if (this[i] != other[i])
                {
                    return false;
                }
            }

            if(!Value.Equals(other.Value) || !Text.Equals(other.Text))
            {
                return false;
            }
            
            return true;
        }

        public override int GetHashCode()
        {
            if (_fields.Length > 0)
            {
                return _fields[0].GetHashCode();
            }
            else
            {
                return Value.GetHashCode();
            }
        }

        
        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT, FOR ITEM'S DATA (NON-CONTROL) STATE.
        /////////////////////////////////////////////////////////////////////////

        internal override Object SaveDataState()
        {
            Object baseState = base.SaveDataState ();
            if (_dirty && _fields != null)
            {
                int fieldCount = _fields.Length;
                Object[] itemState = new Object[fieldCount + 1];
                itemState[0] = baseState;
                for (int i = 0; i < fieldCount; i++)
                {
                    itemState[i + 1] = _fields[i];
                }
                return itemState;
            }
            else if (baseState != null)
            {
                return new Object[1] { baseState };
            }
            else
            {
                return null;
            }
        }

        internal override void LoadDataState(Object state)
        {
            if (state != null)
            {
                Object[] itemState = (Object[])state;
                int fieldCount = itemState.Length;
                base.LoadDataState (itemState[0]);
                _fields = new String[fieldCount - 1];
                for (int i = 1; i < fieldCount; i++)
                {
                    _fields[i - 1] = (String)itemState[i];
                }
            }
        }

        internal override bool Dirty 
        {
            get 
            { 
                return _dirty || base.Dirty;
            }
            set { 
                _dirty = true;
                base.Dirty = value;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  EVENT BUBBLING
        /////////////////////////////////////////////////////////////////////////

        protected override bool OnBubbleEvent(Object source, EventArgs e) 
        {
            if (e is CommandEventArgs) 
            {
                ObjectListCommandEventArgs args = new ObjectListCommandEventArgs(this, source, (CommandEventArgs)e);
                RaiseBubbleEvent (this, args);
                return true;
            }
            return false;
        }

    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistselecteventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListSelectEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * Object List select event handler - type definition.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void ObjectListSelectEventHandler(Object sender, ObjectListSelectEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistshowcommandseventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListShowCommandsEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Object List show command event arguments
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListShowCommandsEventArgs : EventArgs
    {
        private ObjectListItem _item;
        private ObjectListCommandCollection _commands;

        public ObjectListShowCommandsEventArgs(ObjectListItem item, ObjectListCommandCollection commands)
        {
            _item = item;
            _commands = commands;
        }

        public ObjectListCommandCollection Commands
        {
            get
            {
                return _commands;
            }
        }

        public ObjectListItem ListItem
        {
            get
            {
                return _item;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\pagedcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="PagedControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Diagnostics;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Paged control. Abstract control class inherited by all classes 
     * that are internally paginated.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class PagedControl : MobileControl
    {
        private static readonly Object EventLoadItems = new Object();
        private const String _itemCountViewStateKey = "_!PagedControlItemCount";
        private bool _pagingCharacteristicsChanged = false;
        int _lastItemIndexLoaded = -1;
        int _lastItemCountLoaded = -1;
        Pair _stateLoadItemsArgs = null;

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.PagedControl_OnLoadItems)
        ]
        public event LoadItemsEventHandler LoadItems
        {
            add
            {
                Events.AddHandler(EventLoadItems, value);
            }
            remove 
            {
                Events.RemoveHandler(EventLoadItems, value);
            }
        }

        private void OnLoadItems()
        {
            int index, count;

            if (_itemPager != null)
            {
                index = PagerItemIndex;
                count = PagerItemCount;
            }
            else
            {
                index = 0;
                count = ItemCount;
            }

            OnLoadItems(new LoadItemsEventArgs(index, count));
        }

        protected virtual void OnLoadItems(LoadItemsEventArgs e)
        {
            if (LoadItemsHandler != null)
            {
                _lastItemIndexLoaded = e.ItemIndex;
                _lastItemCountLoaded = e.ItemCount;
                LoadItemsHandler(this, e);
            }
        }

        private bool IsCustomPaging
        {
            get
            {
                return ItemCount > 0;
            }
        }

        private LoadItemsEventHandler LoadItemsHandler
        {
            get
            {
                return (LoadItemsEventHandler)Events[EventLoadItems];
            }
        }

        protected abstract int InternalItemCount { get; }
        

        [
            Bindable(true),
            DefaultValue(0),
            MobileCategory(SR.Category_Paging),
            MobileSysDescription(SR.PagedControl_ItemCount)
        ]
        public int ItemCount
        {
            get
            {
                Object count = ViewState[_itemCountViewStateKey];
                return  count == null ? 0 : (int) count;
            }
            set
            {
                if (value < 0)
                {
                    throw new ArgumentOutOfRangeException("ItemCount",
                        SR.GetString(SR.PagedControl_ItemCountCantBeNegative,
                                     value));
                }
                bool changed = (ItemCount != value);
                ViewState[_itemCountViewStateKey] = value;
                if (changed)
                {
                    InternalItemCountChangedHandler(value);
                }
                ConditionalLoadItemsFromPersistedArgs();
            }
        }

        // Allows special handling of set_ItemCount in derived class, 
        // while maintaining API backward compatibility.
        internal virtual void InternalItemCountChangedHandler(int newItemCount)
        {}

        [
            Bindable(true),
            DefaultValue(0),
            MobileCategory(SR.Category_Paging),
            MobileSysDescription(SR.PagedControl_ItemsPerPage)
        ]
        public int ItemsPerPage
        {
            get
            {
                object o = ViewState["ItemsPerPage"];
                return (o != null) ? (int)o : 0;
            }
            set
            {
                if (value < 0)
                {
                    throw new ArgumentOutOfRangeException("ItemsPerPage",
                        SR.GetString(SR.PagedControl_ItemsPerPageCantBeNegative,
                                     value));
                }
                ViewState["ItemsPerPage"] = value;
            }
        }

        protected virtual int ItemWeight
        {
            get
            {
                return ControlPager.DefaultWeight;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int FirstVisibleItemIndex
        {
            get
            {
                return (IsCustomPaging || !EnablePagination) ? 0 : PagerItemIndex;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int VisibleItemCount
        {
            get
            {
                return (IsCustomPaging || !EnablePagination) ? InternalItemCount : PagerItemCount;
            }
        }

        public override int VisibleWeight
        {
            get
            {
                // Paged control should count the weight as sum of its items
                int count = VisibleItemCount;
                if (count == -1)
                {
                    return 0;  // -1 means control not on the current page
                }
                else
                {
                    return count * GetItemWeight();
                }
            }
        }

        private ItemPager _itemPager;
        public override void PaginateRecursive(ControlPager pager)
        {
            int itemCount = IsCustomPaging ? ItemCount : InternalItemCount;
            int itemsPerPage = ItemsPerPage;
            _itemPager = pager.GetItemPager(this, itemCount, itemsPerPage, GetItemWeight());
        }

        internal int GetItemWeight()
        {
            int weight = Adapter.ItemWeight;
            if (weight == ControlPager.UseDefaultWeight)
            {
                weight = ItemWeight;
            }
            return weight;
        }

        private int PagerItemIndex
        {
            get
            {
                return (_itemPager == null) ? 0 : _itemPager.ItemIndex;
            }
        }

        private int PagerItemCount
        {
            get
            {
                return (_itemPager == null) ? InternalItemCount : _itemPager.ItemCount;
            }
        }

        protected override void OnPageChange(int oldPageIndex, int newPageIndex)
        {
            _pagingCharacteristicsChanged = true;
        }

        protected override void OnPreRender(EventArgs e)
        {
            if (IsCustomPaging && 
                IsVisibleOnPage(Form.CurrentPage) &&
                    (!Page.IsPostBack || 
                    Form.PaginationStateChanged || 
                    _pagingCharacteristicsChanged ||
                    !IsViewStateEnabled()))
            {
                OnLoadItems();
            }

            base.OnPreRender(e);
        }

        internal override void SetControlPage(int page)
        {
            // Custom pagination being turned off.

            _itemPager = null;
            _pagingCharacteristicsChanged = true;
            base.SetControlPage(page);
        }

        private bool IsViewStateEnabled()
        {
            for (Control ctl = this; ctl != null; ctl = ctl.Parent)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
            }
            return true;
        }

        protected override Object SavePrivateViewState()
        {
            // If the base state is non-null, we always return a Pair with the base state as the
            // first item.
            Object baseState = base.SavePrivateViewState();            
            if (IsCustomPaging && IsTemplated && !IsViewStateEnabled() && _lastItemCountLoaded != -1)
            {
                return new Pair(baseState, new Pair(_lastItemIndexLoaded, _lastItemCountLoaded));
            }

            if (baseState != null)
            {
                return new Pair(baseState, null);
            }

            // baseState is null
            return null;
        }

        protected override void LoadPrivateViewState(Object state)
        {
            Debug.Assert (state == null || state.GetType() == typeof(Pair), 
               "If the base state is non-null, private viewstate should always be saved as a pair");

            Pair statePair = state as Pair;
            if (statePair != null)
            {
                base.LoadPrivateViewState(statePair.First); 
                _stateLoadItemsArgs = statePair.Second as Pair;
                ConditionalLoadItemsFromPersistedArgs();
            }
        }

        // Loads items using view state pair in templated case where custom paging 
        // on, view state off.  In this special case, load items early as 
        // possible to enable events to be raised.
        private void ConditionalLoadItemsFromPersistedArgs()
        {
            if (_stateLoadItemsArgs != null && IsCustomPaging && IsTemplated && !IsViewStateEnabled())
            {
                OnLoadItems(
                    new LoadItemsEventArgs((int) _stateLoadItemsArgs.First, (int) _stateLoadItemsArgs.Second));
                _stateLoadItemsArgs = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlistshowcommandseventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListShowCommandEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

using System;

namespace System.Web.UI.MobileControls
{

    /*
     * Object List show commands event handler - type definition.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public delegate void ObjectListShowCommandsEventHandler(Object sender, ObjectListShowCommandsEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\objectlisttitleattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectListTitleAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.ComponentModel;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Object List Title attribute. Can be attached to a property to provide its
     * title in an object list field
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        AttributeUsage(AttributeTargets.Property)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ObjectListTitleAttribute : Attribute 
    {
        private readonly String _title;

        public ObjectListTitleAttribute(String title)
        {
            _title = title;
        }

        public virtual String Title
        {
            get 
            {
                return _title;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\phonecall.cs ===
//------------------------------------------------------------------------------
// <copyright file="PhoneCall.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile PhoneCall class.
     * The PhoneCall control is for initiating a voice call on a cell phone.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultProperty("Text"),
        Designer(typeof(System.Web.UI.Design.MobileControls.PhoneCallDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerLabelAdapter)),
        ToolboxData("<{0}:PhoneCall runat=\"server\">PhoneCall</{0}:PhoneCall>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class PhoneCall : TextControl, IPostBackEventHandler
    {
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Navigation),
            MobileSysDescription(SR.PhoneCall_PhoneNumber)
        ]
        public String PhoneNumber
        {
            get
            {
                String s = (String) ViewState["PhoneNumber"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                const String PhoneNumberFormat = "[\\+#]?[ \\d\\(\\)\\.-]*\\d[ \\d\\(\\)\\.-]*";

                // Empty string is the default value, no need to check
                // (same as null)
                if (value != null && value != String.Empty)
                {
                    // phone number format checking using RegularExpression
                    Match match = Regex.Match(value, PhoneNumberFormat);

                    // we are looking for an exact match, not just a search hit
                    if (!match.Success || match.Index != 0 ||
                        match.Length != value.Length)
                    {
                        throw new ArgumentException(
                            SR.GetString(SR.PhoneCall_InvalidPhoneNumberFormat,
                                         "PhoneNumber", value));
                    }
                }

                ViewState["PhoneNumber"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue("{0} {1}"),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.PhoneCall_AlternateFormat)
        ]
        public String AlternateFormat
        {
            get
            {
                String s = (String) ViewState["AlternateFormat"];
                return((s != null) ? s : "{0} {1}");
            }
            set
            {
                ViewState["AlternateFormat"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Navigation),
            MobileSysDescription(SR.PhoneCall_AlternateUrl),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.NavigateUrlConverter)),
        ]
        public String AlternateUrl
        {
            get
            {
                String s = (String) ViewState["AlternateUrl"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["AlternateUrl"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.PhoneCall_SoftkeyLabel)
        ]
        public String SoftkeyLabel
        {
            get
            {
                String s = (String) ViewState["Softkeylabel"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["Softkeylabel"] = value;
            }
        }

        void IPostBackEventHandler.RaisePostBackEvent(String argument)
        {
            MobilePage.ActiveForm = MobilePage.GetForm(argument);
        }

        protected override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);

            if (PhoneNumber == String.Empty)
            {
                throw new ArgumentException(
                            SR.GetString(SR.PhoneCall_EmptyPhoneNumber, ID));
            }
        }

        public override void AddLinkedForms(IList linkedForms)
        {
            String target = AlternateUrl;
            String prefix = Constants.FormIDPrefix;
            if (target.StartsWith(prefix))
            {
                String targetID = target.Substring(prefix.Length);
                Form form = ResolveFormReference(targetID);
                if (form != null && !form.HasActivateHandler())
                {
                    linkedForms.Add(form);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\persistnameattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="PersistNameAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.MobileControls 
{
    using System;
    using System.ComponentModel;
    using System.Globalization;
    using System.Security.Permissions;

    [
        AttributeUsage(AttributeTargets.Class)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class PersistNameAttribute : Attribute 
    {
        public static readonly PersistNameAttribute Default = new PersistNameAttribute(String.Empty);

        private String _name = String.Empty;

        public String Name 
        {
            get
            {
                return this._name;
            }
        }

        public PersistNameAttribute(String name)
        {
            this._name = name;
        }

        public override bool Equals(Object obj)
        {
            if (obj == this) 
            {
                return true;
            }

            if ((obj != null) && (obj is PersistNameAttribute)) 
            {
                return(String.Compare(((PersistNameAttribute)obj).Name, _name, true, CultureInfo.InvariantCulture) == 0);
            }

            return false;
        }

        public override int GetHashCode()
        {
            return _name.ToLower().GetHashCode();
        }

        public override bool IsDefaultAttribute() 
        {
            return this.Equals(Default);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\pagerstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Pager Style class. Style properties used to render a form pagination UI.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class PagerStyle : Style
    {
        public static readonly Object
            NextPageTextKey = RegisterStyle("NextPageText", typeof(String), String.Empty, false),
            PreviousPageTextKey = RegisterStyle("PreviousPageText", typeof(String), String.Empty, false),
            PageLabelKey = RegisterStyle("PageLabel", typeof(String), String.Empty, false);

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.PagerStyle_NextPageText),
            NotifyParentProperty(true),
        ]
        public String NextPageText
        {
            get
            {
                return (String)this[NextPageTextKey];
            }
            set
            {
                this[NextPageTextKey] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.PagerStyle_PreviousPageText),
            NotifyParentProperty(true),
        ]
        public String PreviousPageText
        {
            get
            {
                return (String)this[PreviousPageTextKey];
            }
            set
            {
                this[PreviousPageTextKey] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.PagerStyle_PageLabel),
            NotifyParentProperty(true),
        ]
        public String PageLabel
        {
            get
            {
                return (String)this[PageLabelKey];
            }
            set
            {
                this[PageLabelKey] = value;
            }
        }

        public String GetNextPageText(int currentPageIndex)
        {
            String s = (String)this[NextPageTextKey, true];
            if (s != null && s.Length > 0)
            {
                return String.Format (s, currentPageIndex + 1);
            }
            else
            {
                return SR.GetString(SR.PagerStyle_NextPageText_DefaultValue);
            }
        }

        public String GetPreviousPageText(int currentPageIndex)
        {
            String s = (String)this[PreviousPageTextKey, true];
            if (s != null && s.Length > 0)
            {
                return String.Format (s, currentPageIndex - 1);
            }
            else
            {
                return SR.GetString(SR.PagerStyle_PreviousPageText_DefaultValue);
            }
        }

        public String GetPageLabelText(int currentPageIndex, int pageCount)
        {
            String s = (String)this[PageLabelKey, true];
            if (s == null)
            {
                s = String.Empty;
            }
            if (s != String.Empty)
            {
                s = String.Format (s, currentPageIndex, pageCount);
            }
            return s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\rangevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RangeValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile RangeValidator class.
     * The RangeValidator checks that the value of the associated input control
     * is within a minimum and maximum value.  These can either be constant
     * values or other input controls.  A data type property specifies how the
     * values being compared should be interpreted: Strings, integers, dates,
     * etc.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ToolboxData("<{0}:RangeValidator runat=\"server\" ErrorMessage=\"RangeValidator\"></{0}:RangeValidator>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RangeValidator : BaseValidator
    {
        private WebCntrls.RangeValidator _webRangeValidator;

        protected override WebCntrls.BaseValidator CreateWebValidator()
        {
            _webRangeValidator = new WebCntrls.RangeValidator();
            return _webRangeValidator;
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original RangeValidator.
        // The properties are got and set directly from the original RangeValidator.
        ////////////////////////////////////////////////////////////////////////

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.RangeValidator_MaximumValue)
        ]
        public String MaximumValue
        {
            get
            {
                return _webRangeValidator.MaximumValue;
            }
            set
            {
                _webRangeValidator.MaximumValue = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.RangeValidator_MinimumValue)
        ]
        public String MinimumValue
        {
            get
            {
                return _webRangeValidator.MinimumValue;
            }
            set
            {
                _webRangeValidator.MinimumValue = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(ValidationDataType.String),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.RangeValidator_Type)
        ]
        public ValidationDataType Type
        {
            get
            {
                return _webRangeValidator.Type;
            }
            set
            {
                _webRangeValidator.Type = value;
            }
        }

        protected override bool EvaluateIsValid()
        {
            return EvaluateIsValidInternal();
        }

        /////////////////////////////////////////////////////////////////////
        // Helper function adopted from WebForms RangeValidator
        /////////////////////////////////////////////////////////////////////

        protected override bool ControlPropertiesValid()
        {
            // Check if the control values can be converted to data type
            String maximumValue = MaximumValue;
            if (!WebCntrls.BaseCompareValidator.CanConvert(maximumValue, Type))
            {
                throw new ArgumentException(SR.GetString(
                        SR.Validator_ValueBadType,
                        maximumValue,
                        "MaximumValue",
                        ID,
                        PropertyConverter.EnumToString(
                            typeof(ValidationDataType), Type)
                ));
            }
            String minumumValue = MinimumValue;
            if (!WebCntrls.BaseCompareValidator.CanConvert(minumumValue, Type))
            {
                throw new ArgumentException(SR.GetString(
                        SR.Validator_ValueBadType,
                        minumumValue,
                        "MinimumValue",
                        ID,
                        PropertyConverter.EnumToString(
                            typeof(ValidationDataType), Type)
                ));
            }
            // Check for overlap.
            if (WebBaseCompareValidator.Compare(minumumValue, maximumValue,
                                ValidationCompareOperator.GreaterThan, Type))
            {
                throw new ArgumentException(SR.GetString(
                        SR.RangeValidator_RangeOverlap, maximumValue,
                        minumumValue, ID));
            }
            return base.ControlPropertiesValid();            
        }

        // The reason of having this class is to expose the method
        // BaseCompareValidator.Compare which is a protected method in the
        // base class.  Since the implementation of the method is not
        // trivial, instead of copying the code to this file, the following
        // subclass inherits the base class and expose a new public method
        // which calls its base implementation.  While this solution doesn't
        // look elegant, it helps eliminate the code maintanence issue of
        // copying the code.
        private class WebBaseCompareValidator : BaseCompareValidator
        {
            // Have to define this method since it is abstract in the base
            // class.
            protected override bool EvaluateIsValid()
            {
                Debug.Assert(false, "Should never be called.");
                return true;
            }

            public static new bool Compare(
                String leftText, String rightText,
                ValidationCompareOperator op, ValidationDataType type)
            {
                return BaseCompareValidator.Compare(leftText, rightText, op, type);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\panel.cs ===
//------------------------------------------------------------------------------
// <copyright file="Panel.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;                    
using System.Web.UI;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    [
        ControlBuilderAttribute(typeof(PanelControlBuilder)),
        Designer(typeof(System.Web.UI.Design.MobileControls.PanelDesigner)),
        DesignerAdapter(typeof(System.Web.UI.MobileControls.Adapters.HtmlPanelAdapter)),
        PersistChildren(true),
        ToolboxData("<{0}:Panel runat=\"server\"></{0}:Panel>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Panel: MobileControl, ITemplateable
    {
        Panel _deviceSpecificContents = null;

        public Panel() : base()
        {
            Form frm = this as Form;
            if(frm == null)
            {
                BreakAfter = false;
            }
        }

        public override void AddLinkedForms(IList linkedForms)
        {
            foreach (Control child in Controls)
            {
                if (child is MobileControl)
                {
                    ((MobileControl)child).AddLinkedForms(linkedForms);
                }
            }
        }

        [
            DefaultValue(false),
        ]
        public override bool BreakAfter
        {
            get
            {
                return base.BreakAfter;
            }

            set
            {
                base.BreakAfter = value;
            }
        }

        protected override bool PaginateChildren
        {
            get
            {
                return Paginate;
            }
        }

        private bool _paginationStateChanged = false;
        internal bool PaginationStateChanged
        {
            get
            {
                return _paginationStateChanged;
            }
            set
            {
                _paginationStateChanged = value;
            }
        }

        [
          Bindable(true),
          DefaultValue(false),
          MobileCategory(SR.Category_Behavior),
          MobileSysDescription(SR.Panel_Paginate)
        ]
        public virtual bool Paginate
        {
            get
            {
                Object o = ViewState["Paginate"];
                return o != null ? (bool)o : false;
            }

            set
            {
                bool wasPaginating = Paginate;
                ViewState["Paginate"] = value;
                if (IsTrackingViewState)
                {
                    PaginationStateChanged = true;
                    if (value == false && wasPaginating == true )
                    {
                        SetControlPageRecursive(this, 1);
                    }
                }
            }
        }

        protected override void OnInit(EventArgs e)
        {
            base.OnInit(e);
            if (IsTemplated)
            {
                ClearChildViewState();
                CreateTemplatedUI(false);
                ChildControlsCreated = true;
            }
        }

        public override void PaginateRecursive(ControlPager pager)
        {
            if (!EnablePagination)
            {
                return;
            }

            if (Paginate && Content != null)
            {
                Content.Paginate = true;
                Content.PaginateRecursive(pager);
                this.FirstPage = Content.FirstPage;
                this.LastPage = pager.PageCount;
            }
            else
            {
                base.PaginateRecursive(pager);
            }        
        }

        public override void CreateDefaultTemplatedUI(bool doDataBind)
        {
            ITemplate contentTemplate = GetTemplate(Constants.ContentTemplateTag);
            if (contentTemplate != null)
            {
                _deviceSpecificContents = new TemplateContainer();
                CheckedInstantiateTemplate (contentTemplate, _deviceSpecificContents, this);
                Controls.AddAt(0, _deviceSpecificContents);
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public Panel Content
        {
            get
            {
                return _deviceSpecificContents;
            }
        }
    }

    /*
     * Control builder for panels. 
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class PanelControlBuilder : LiteralTextContainerControlBuilder
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\runtimeliteraltextparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="RuntimeLiteralTextParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Web.UI;

namespace System.Web.UI.MobileControls
{
    /*
     * RuntimeLiteralTextParser class.
     *
     * This is a specialized version of the LiteralTextParser class.
     * It creates a set of controls from the parsed literal text at.
     * runtime. This class can be used by the TextView control to
     * accept and render dynamic formatted text.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal class RuntimeLiteralTextParser : LiteralTextParser
    {
        Control _parentControl;
        bool _elementsAdded = false;

        internal RuntimeLiteralTextParser(Control parentControl)
        {
            _parentControl = parentControl;
        }

        protected override void ProcessElement(LiteralElement element)
        {
            MobileControl ctl;

            switch (element.Type)
            {
                case LiteralElementType.Text:
                {
                    LiteralText textCtl = new LiteralText();
                    textCtl.BreakAfter = element.BreakAfter;
                    ctl = textCtl;
                    break;
                }

                case LiteralElementType.Anchor:
                {
                    Link link = new LiteralLink();
                    link.NavigateUrl = element.GetAttribute ("href");
                    link.BreakAfter = element.BreakAfter;

                    ctl = link;
                    break;
                }

                default:
                    return;
            }

            // Need to add text as a child, so that it can be written out unscathed.

            if (element.Text != null)
            {
                ctl.Controls.Add(new LiteralControl(element.Text));
            }

            if ((element.Format & LiteralFormat.Bold) == LiteralFormat.Bold)
            {
                ctl.Font.Bold = BooleanOption.True;
            }
            if ((element.Format & LiteralFormat.Italic) == LiteralFormat.Italic)
            {
                ctl.Font.Italic = BooleanOption.True;
            }

            _parentControl.Controls.Add (ctl);
            _elementsAdded = true;
        }

        protected override void ProcessTagInnerText(String text)
        {
            Debug.Assert(false);
        }

        protected override bool IgnoreWhiteSpaceElement(LiteralElement element)
        {
            return !_elementsAdded;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\requiredfieldvalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RequiredFieldValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile RequiredFieldValidator class.
     * The RequiredFieldValidator makes the input control it is associated with
     * a required field.  Validation fails if the value of the input control is
     * no different from its initial value.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ToolboxData("<{0}:RequiredFieldValidator runat=\"server\" ErrorMessage=\"RequiredFieldValidator\"></{0}:RequiredFieldValidator>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RequiredFieldValidator : BaseValidator
    {
        private WebCntrls.RequiredFieldValidator _webRequiredFieldValidator;

        protected override WebCntrls.BaseValidator CreateWebValidator()
        {
            _webRequiredFieldValidator = new WebCntrls.RequiredFieldValidator();
            return _webRequiredFieldValidator;
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original RequiredFieldValidator.
        // The properties are got and set directly from the original RequiredFieldValidator.
        ////////////////////////////////////////////////////////////////////////

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.RequiredFieldValidator_InitialValue)
        ]
        public String InitialValue
        {
            get
            { 
                return _webRequiredFieldValidator.InitialValue;
            }
            set
            {
                _webRequiredFieldValidator.InitialValue = value;
            }
        }

        protected override bool EvaluateIsValid()
        {
            return EvaluateIsValidInternal();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\regularexpressionvalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="RegularExpressionValidator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Text.RegularExpressions;
using WebCntrls = System.Web.UI.WebControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile RegularExpressionValidator class.
     * The RegularExpressionValidator provides validation using a regular
     * expression as the validation criteria.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ToolboxData("<{0}:RegularExpressionValidator runat=\"server\" ErrorMessage=\"RegularExpressionValidator\"></{0}:RegularExpressionValidator>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]    
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class RegularExpressionValidator : BaseValidator
    {
        private WebCntrls.RegularExpressionValidator _webRegularExpressionValidator;

        protected override WebCntrls.BaseValidator CreateWebValidator()
        {
            _webRegularExpressionValidator = new WebCntrls.RegularExpressionValidator();
            return _webRegularExpressionValidator;
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic the properties exposed in the original RegularExpressionValidator.
        // The properties are got and set directly from the original RegularExpressionValidator.
        ////////////////////////////////////////////////////////////////////////

        [
            Bindable(true),
            DefaultValue(""),
            Editor("System.Web.UI.Design.WebControls.RegexTypeEditor, " + AssemblyRef.SystemDesign, typeof(UITypeEditor)),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.RegularExpressionValidator_ValidationExpression)
        ]
        public String ValidationExpression
        {
            get
            {
                return _webRegularExpressionValidator.ValidationExpression;
            }
            set
            {
                _webRegularExpressionValidator.ValidationExpression = value;
            }
        }

        protected override bool EvaluateIsValid()
        {
            return EvaluateIsValidInternal();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\sr.cs ===
//------------------------------------------------------------------------------
// <copyright file="SR.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.Web.UI.MobileControls
{
    // This class exists solely to make the class SR available members of this
    // namespace.  It delegates completely to System.Web.Mobile.SR.
    internal class SR : System.Web.Mobile.SR
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\selectionlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="SelectionList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile SelectionList class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ControlBuilderAttribute(typeof(ListControlBuilder)),
        DefaultEvent("SelectedIndexChanged"),
        DefaultProperty("DataSource"),
        Designer(typeof(System.Web.UI.Design.MobileControls.SelectionListDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerSelectionListAdapter)),
        Editor(typeof(System.Web.UI.Design.MobileControls.SelectionListComponentEditor), typeof(ComponentEditor)),
        ToolboxData("<{0}:SelectionList runat=\"server\"></{0}:SelectionList>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign),
        ValidationProperty("Selection")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class SelectionList : MobileControl, IPostBackDataHandler, IListControl
    {
        private static readonly Object EventItemDataBind = new Object();
        private static readonly Object EventSelectedIndexChanged = new Object();

        private ListDataHelper _dataHelper;
        private int _cachedSelectedIndex = -1;
        
        public SelectionList()
        {
            _dataHelper = new ListDataHelper(this, ViewState);
        }

        /////////////////////////////////////////////////////////////////////////
        //  IListControl
        /////////////////////////////////////////////////////////////////////////

        void IListControl.OnItemDataBind(ListDataBindEventArgs e) 
        {
            OnItemDataBind(e);
        }

        bool IListControl.TrackingViewState
        {
            get
            {
                return IsTrackingViewState;
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets or sets the <see langword='DataSource'/> property of the control which is used to populate
        ///       the items within the control.
        ///    </para>
        /// </summary>
        [
            Bindable(true),
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataSource)
        ]
        public virtual Object DataSource 
        {
            get 
            {
                return _dataHelper.DataSource;
            }

            set 
            {
                _dataHelper.DataSource = value;
            }
        }

        private IEnumerable ResolvedDataSource
        {
            get
            {
                return _dataHelper.ResolvedDataSource;
            }
        }

        [
            Bindable(false),
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataMember),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataMemberConverter))
        ]
        public virtual String DataMember
        {
            get 
            {
                return _dataHelper.DataMember;
            }

            set 
            {
                _dataHelper.DataMember = value;
            }
        }

        [
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataTextField),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataFieldConverter))
        ]
        public String DataTextField 
        {
            get 
            {
                return _dataHelper.DataTextField;
            }
            set 
            {
                _dataHelper.DataTextField = value;
            }
        }

        [
            DefaultValue(""),
            MobileCategory(SR.Category_Data),
            MobileSysDescription(SR.List_DataValueField),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.DataFieldConverter))
        ]
        public String DataValueField 
        {
            get 
            {
                return _dataHelper.DataValueField;
            }
            set 
            {
                _dataHelper.DataValueField = value;
            }
        }
        
        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public bool IsMultiSelect
        {
            get
            {
                return (SelectType == ListSelectType.MultiSelectListBox  || 
                        SelectType == ListSelectType.CheckBox);
            }
        }

        [
            Bindable(true),
            Browsable(true),
            DefaultValue(4),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.SelectionList_Rows)
        ]
        public int Rows
        {
            get
            {
                Object o = ViewState["Rows"];
                return o != null ? (int)o : 4;
            }
            set
            {
                if (value < 1)
                {
                    throw new ArgumentOutOfRangeException("Rows");
                }
                ViewState["Rows"] = value;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public int SelectedIndex 
        {
            get 
            {
                for (int i = 0; i < Items.Count; i++) 
                {
                    if (Items[i].Selected)
                    {
                        return i;
                    }
                }
                return -1;
            }
            set 
            {
                // if we have no items, save the selectedindex
                // for later databinding
                if (Items.Count == 0) 
                {
                    _cachedSelectedIndex = value;
                }
                else 
                {
                    if (value < -1 || value >= Items.Count)
                    {
                        throw new ArgumentOutOfRangeException(
                            "SelectedIndex",
                            SR.GetString(SR.SelectionList_OutOfRange,value));
                    }
                    ClearSelection();
                    if (value >= 0)
                    {
                        Items[value].Selected = true;
                    }
                }
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public MobileListItem Selection
        {
            get
            {
                int selectedIndex = SelectedIndex;
                if (selectedIndex >= 0 && selectedIndex < Items.Count)
                {
                    return Items[selectedIndex];
                }
                else
                {
                    return null;
                }
            }
        }

        [
            Bindable(false),
            DefaultValue(null),
            Editor(typeof(System.Web.UI.Design.MobileControls.ItemCollectionEditor), typeof(UITypeEditor)),
            MergableProperty(false),
            MobileSysDescription(SR.List_Items),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public MobileListItemCollection Items
        {
            get
            {
                return _dataHelper.Items;
            }
        }

        protected override void AddParsedSubObject(Object obj)
        {
            if (!(obj is LiteralControl))
            {
                if (obj is MobileListItem)
                {
                    _dataHelper.AddItem((MobileListItem)obj);
                    if(_cachedSelectedIndex != -1 && 
                       _dataHelper.Items.Count > _cachedSelectedIndex)
                    {
                        SelectedIndex = _cachedSelectedIndex;
                        _cachedSelectedIndex = -1;
                    }
                } 
                else
                {
                    base.AddParsedSubObject(obj);
                }
            }
        }

        protected override void OnPreRender(EventArgs e) 
        {
            base.OnPreRender(e);
            if (Page != null && IsMultiSelect) 
            {
                // ensure postback when no item is selected
                Page.RegisterRequiresPostBack(this);
            }
        }

        protected override void OnDataBinding(EventArgs e) 
        {
            base.OnDataBinding(e);

            if (ResolvedDataSource != null)
            {
                CreateItems(ResolvedDataSource);
            }

            if (_cachedSelectedIndex != -1) 
            {
                SelectedIndex = _cachedSelectedIndex;
                _cachedSelectedIndex = -1;
            }
        }

        protected virtual void CreateItems(IEnumerable dataSource) 
        {
            _dataHelper.CreateItems(dataSource);
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.SelectionList_OnSelectedIndexChanged)
        ]
        public event EventHandler SelectedIndexChanged
        {
            add 
            {
                Events.AddHandler(EventSelectedIndexChanged, value);
            }
            remove 
            {
                Events.RemoveHandler(EventSelectedIndexChanged, value);
            }
        }

        protected virtual void OnSelectedIndexChanged(EventArgs e) 
        {
            EventHandler onSelectedIndexChangedHandler = (EventHandler)Events[EventSelectedIndexChanged];
            if (onSelectedIndexChangedHandler != null)
            {
                onSelectedIndexChangedHandler(this, e);
            }
        }

        [
            MobileCategory(SR.Category_Action),
            MobileSysDescription(SR.List_OnItemDataBind)
        ]
        public event ListDataBindEventHandler ItemDataBind 
        {
            add 
            {
                Events.AddHandler(EventItemDataBind, value);
            }
            remove 
            {
                Events.RemoveHandler(EventItemDataBind, value);
            }
        }

        protected virtual void OnItemDataBind(ListDataBindEventArgs e) 
        {
            ListDataBindEventHandler onItemDataBindHandler = (ListDataBindEventHandler)Events[EventItemDataBind];
            if (onItemDataBindHandler != null)
            {
                onItemDataBindHandler(this, e);
            }
        }

        bool IPostBackDataHandler.LoadPostData(String postDataKey, NameValueCollection postCollection) 
        {
            bool dataChanged;
            bool handledByAdapter =
                Adapter.LoadPostData(postDataKey,
                                     postCollection,
                                     SelectedIndicesInternal.ToArray(typeof(int)),
                                     out dataChanged);

            if (!handledByAdapter)
            {
                throw new
                    Exception(SR.GetString(SR.SelectionList_AdapterNotHandlingLoadPostData));
            }

            return dataChanged;
        }

        void IPostBackDataHandler.RaisePostDataChangedEvent() 
        {
            OnSelectedIndexChanged(EventArgs.Empty);
        }

        [
            Bindable(true),
            DefaultValue(ListSelectType.DropDown),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.SelectionList_SelectType)
        ]
        public ListSelectType SelectType
        {
            get
            {
                Object o = ViewState["SelectType"];
                return (o != null) ? (ListSelectType)o : ListSelectType.DropDown;
            }
            set
            {
                ViewState["SelectType"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.SelectionList_Title)
        ]
        public String Title
        {
            get
            {
                return ToString(ViewState["Title"]);
            }
            set
            {
                ViewState["Title"] = value;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  STATE MANAGEMENT
        /////////////////////////////////////////////////////////////////////////

        protected override void TrackViewState() 
        {
            base.TrackViewState();
            if (_dataHelper.HasItems())
            {
                ((IStateManager)Items).TrackViewState();
            }
        }

        protected override Object SaveViewState() 
        {
            Object baseState = base.SaveViewState();
            Items.SaveSelection = true;
            Object items = ((IStateManager)Items).SaveViewState();

            if (items != null || baseState != null)
            {
                return new Object[] { baseState, items };
            }
            
            return null;
        }

        protected override void LoadViewState(Object savedState) 
        {
            if (savedState != null) 
            {
                Object[] state = (Object[])savedState;
                if (state[0] != null)
                {
                    base.LoadViewState(state[0]);
                }
                
                // restore state of items
                Items.SaveSelection = true;
                ((IStateManager)Items).LoadViewState(state[1]);
            }
        }

        private ArrayList SelectedIndicesInternal 
        {
            get 
            {
                int count = Items.Count;
                ArrayList selectedIndices = new ArrayList(count); 
                for (int i = 0; i < count; i++) 
                {
                    if (Items[i].Selected)  
                    {
                        selectedIndices.Add(i);
                    }
                }
                return selectedIndices;
            }
        }

        internal void ClearSelection() 
        {
            for (int i = 0; i < Items.Count; i++)
            {
                Items[i].Selected = false;
            }
        }

        private void SelectInternal(ArrayList selectedIndices) 
        {
            ClearSelection();
            for (int i = 0; i < selectedIndices.Count; i++) 
            {
                int n = (int) selectedIndices[i];
                if (n >= 0 && n < Items.Count)
                {
                    Items[n].Selected = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\sessionviewstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionViewState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Web;
using System.Web.SessionState;
using System.Web.Util;
using System.Web.UI;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Session-based view state.
     *
     * When saving view state on the server as session data, some critical problems
     * arise. The core issue behind most of these is how to handle the user 
     * clicking the Back button. When the user does this, there is no corresponding
     * notification to the server, and the client and server session state are thrown
     * out of sync. 
     *
     * This class attempts to alleviate this by storing a small history of view states
     * in session data. 
     *
     * To save session view state, construct a new object, set the ViewState and ActiveForm
     * properties, and call Save. You'll get back a reference that contains the 
     * state reference to write out.
     *
     * To load session view state, construct a new object, and call Load. The class will
     * attempt to construct the view state from its history.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal class SessionViewState
    {
        private static readonly String ViewStateKey = "ViewState";
        private Object _state;

        internal SessionViewState() {
        }

        internal /*public*/ Object ViewState
        {
            get
            {
                return _state;
            }
            set
            {
                _state = value;
            }
        }

        internal /*public*/ String Save(MobilePage page)
        {
            SessionViewStateHistory history = (SessionViewStateHistory)page.Session[ViewStateKey];
            if (history == null)
            {
                history = new SessionViewStateHistory(HttpContext.Current);
                page.Session[ViewStateKey] = history;
            }

            SessionViewStateHistoryItem historyItem = new SessionViewStateHistoryItem();
            SaveTo(historyItem);
            #if TRACE
            historyItem.Url = page.Request.FilePath;
            #endif
            return history.Push(historyItem);
        }

        internal /*public*/ void Load(MobilePage page, String id)
        {
            _state = null;

            SessionViewStateHistory history = (SessionViewStateHistory)page.Session[ViewStateKey];
            if (history != null)
            {
                SessionViewStateHistoryItem historyItem = history.Find(id);
                if (historyItem != null)
                {
                    LoadFrom(historyItem);
                }
            }
        }

        private void SaveTo(SessionViewStateHistoryItem historyItem)
        {
            historyItem.ViewState = _state;
        }

        private void LoadFrom(SessionViewStateHistoryItem historyItem)
        {
            _state = historyItem.ViewState;
        }

        #if TRACE
        internal /*public*/ void Dump(MobilePage page, out ArrayList arr)
        {
            SessionViewStateHistory history;
            if ((page is IRequiresSessionState) && !(page is IReadOnlySessionState))
            {
                history = (SessionViewStateHistory)page.Session[ViewStateKey];
            }
            else
            {
                history = null;
            }

            if (history != null)
            {
                history.Dump(out arr);
            }
            else
            {
                arr = new ArrayList();
            }
        }
        #endif

        [
            Serializable
        ]
        private class SessionViewStateHistoryItem : ISerializable
        {
            #if TRACE
            public String Url;
            public String Id;
            #endif
            public Object ViewState;

            public SessionViewStateHistoryItem()
            {
            }

            public SessionViewStateHistoryItem(SerializationInfo info, StreamingContext context)
            {
                String s = (String)info.GetString("s");
                if (s.Length > 0)
                {
                    ViewState = new LosFormatter().Deserialize(s);
                }
                else
                {
                    ViewState = null;
                }
            }

            [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter=true)]
            void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
            {
                if (ViewState != null)
                {
                    StringWriter s = new StringWriter();
                    new LosFormatter().Serialize(s, ViewState);
                    info.AddValue("s", s.ToString());
                }
                else
                {
                    info.AddValue("s", String.Empty);
                }
            }
        }

        // Session view state history. This is the history record kept in each session.

        [
            Serializable
        ]
        private class SessionViewStateHistory
        {
            private int _historySize;
            private SessionViewStateHistoryItem[] _history;
            private int _currentHistoryIndex = 0;
            private int _historyUsed = 0;
            private String _sessionUniqueID = Int64ToString(DateTime.Now.Ticks);
            private int _currentHistoryID = 0;

            public SessionViewStateHistory(HttpContext context)
            {
                _historySize = ControlsConfig.GetFromContext(context).SessionStateHistorySize;
                if (_historySize < 1)
                {
                    throw new Exception(
                        SR.GetString(SR.SessionViewState_InvalidSessionStateHistory));
                }

                _history = new SessionViewStateHistoryItem[_historySize];
            }

            public String Push(SessionViewStateHistoryItem item)
            {
                String id = _sessionUniqueID + "," + _currentHistoryID.ToString();
                _currentHistoryID++;

                _history[_currentHistoryIndex] = item;
                _currentHistoryIndex = (_currentHistoryIndex + 1) % _historySize;
                if (_historyUsed < _historySize)
                {
                    _historyUsed++;
                }

                #if TRACE
                item.Id = _currentHistoryID.ToString();
                #endif
                
                return id;
            }

            public SessionViewStateHistoryItem Find(String id)
            {
                // First make sure that the page is from the current session.
                int separator = id.IndexOf(',');
                if (separator != _sessionUniqueID.Length || 
                    separator == id.Length - 1 ||
                    String.Compare(_sessionUniqueID, 0, id, 0, separator) != 0)
                {
                    return null;
                }

                // Now check if we actually still have it.
                int historyID = Int32.Parse(id.Substring(separator + 1));
                int distance = _currentHistoryID - historyID;

                if (distance <= 0)
                {
                    // Shouldn't happen, but this would be a forward jump.
                    return null;
                }
                else if (distance > _historyUsed)
                {
                    // Gone way back. Empty history, but return null.
                    _historyUsed = 0;
                    return null;
                }
                else
                {
                    int foundIndex = (_currentHistoryIndex + _historySize - distance) % 
                                     _historySize;
                    // Make the found item the top of the stack.
                    _currentHistoryIndex = (foundIndex + 1) % _historySize;
                    _currentHistoryID = historyID + 1;
                    _historyUsed -= distance - 1;
                    return _history[foundIndex];
                }
            }

            private static String Int64ToString(Int64 number)
            {
                // Since each Unicode char is 16 bits, for the best encoding
                // to String we take 2^16 - 1 for the base.  The reason of -1
                // is to eliminate the case of having 0x0000 as the encoded
                // value since it is a String terminator.
                const int EncodingBase = 65535;
                StringBuilder stringBuilder = new StringBuilder();
                Int64 quotient = number;
                char remainder;

                while (quotient != 0)
                {
                    // REVIEW: Is there any better algorithm on doing such
                    // encoding?

                    // +1 is to eliminate the case of having remainder as 0
                    // (String terminator)
                    remainder = (char) ((quotient % EncodingBase) + 1);
                    stringBuilder.Append(remainder);
                    quotient = quotient / EncodingBase;
                }

                return stringBuilder.ToString();
            }

            #if TRACE
            public void Dump(out ArrayList arr)
            {
                arr = new ArrayList();
                int n = _currentHistoryIndex;
                for (int i = 0; i < _historyUsed; i++)
                {
                    n = n - 1;
                    if (n == -1)
                    {
                        n = _history.Length - 1;
                    }

                    SessionViewStateHistoryItem item = _history[n];
                    if (item != null)
                    {
                        arr.Add(String.Format("{0}({1})", item.Url, item.Id));
                    }
                    else
                    {
                        arr.Add("(null)");
                    }
                }
            }
            #endif
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\style.cs ===
//------------------------------------------------------------------------------
// <copyright file="Style.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Design;
using System.Diagnostics;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;

using WebCtrlStyle = System.Web.UI.WebControls.Style;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile Style class.
     * This class can be used to define external styles that can be referenced by other controls.
     */
    [
        ControlBuilderAttribute(typeof(MobileControlBuilder)),
        TypeConverterAttribute(typeof(ExpandableObjectConverter))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class Style : IParserAccessor, ITemplateable, IStateManager, ICloneable
    {
        //  registers styles and retrieves keys used for storing properties in internal hashtable
        public static readonly Object
            AlignmentKey = RegisterStyle("Alignment", typeof(Alignment)    , System.Web.UI.MobileControls.Alignment.NotSet, true),
            WrappingKey  = RegisterStyle("Wrapping" , typeof(Wrapping)     , System.Web.UI.MobileControls.Wrapping.NotSet , true),
            BoldKey      = RegisterStyle("Bold",      typeof(BooleanOption), BooleanOption.NotSet, true),
            ItalicKey    = RegisterStyle("Italic",    typeof(BooleanOption), BooleanOption.NotSet, true),
            FontSizeKey  = RegisterStyle("FontSize" , typeof(FontSize)     , System.Web.UI.MobileControls.FontSize.NotSet , true),
            FontNameKey  = RegisterStyle("FontName" , typeof(String)       , String.Empty    , true),
            ForeColorKey = RegisterStyle("ForeColor", typeof(Color)        , Color.Empty     , true),
            BackColorKey = RegisterStyle("BackColor", typeof(Color)        , Color.Empty     , false);

        private bool _marked = false;       //  used by IStateManager
        private MobileControl _control;     //  containing control
        private Style _referredStyle;       //  referred style
        private bool _checkedStyleReference;//  referred style is valid.
        private StateBag _state;            //  name => object pairs
        private DeviceSpecific _deviceSpecific;
        private FontInfo _font;
        private Style _cachedParentStyle;

        public Style()
        {
        }

        public object Clone()
        {
            Style clone = new Style();
            foreach(String key in State.Keys)
            {
                clone.State[key] = State[key];
            }
            clone._control = _control;
            return clone;
        }

        public void ApplyTo(WebControl control)
        {
            control.Font.Name = (String)this[FontNameKey, true];
            switch ((FontSize)this[FontSizeKey, true])
            {
                case FontSize.Small:
                    control.Font.Size = FontUnit.Small;
                    break;
                case FontSize.Large:
                    control.Font.Size = FontUnit.Large;
                    break;
                default:
                    control.Font.Size = FontUnit.Medium;
                    break;
            }
            control.Font.Bold   = ((BooleanOption)this[BoldKey, true]) == BooleanOption.True;
            control.Font.Italic = ((BooleanOption)this[ItalicKey, true]) == BooleanOption.True;
            control.ForeColor   = (Color)this[ForeColorKey, true];
            control.BackColor   = (Color)this[BackColorKey, true];
        }

        internal void ApplyTo(WebCtrlStyle style)
        {
            style.Font.Bold     = ((BooleanOption)this[BoldKey, true]) == BooleanOption.True;
            style.Font.Italic   = ((BooleanOption)this[ItalicKey, true]) == BooleanOption.True;
            style.Font.Name     = (String)this[FontNameKey, true];
            style.ForeColor     = (Color)this[ForeColorKey, true];
            style.BackColor     = (Color)this[BackColorKey, true];

            switch ((FontSize)this[FontSizeKey, true])
            {
                case FontSize.Large :
                    style.Font.Size = FontUnit.Larger;
                    break;

                case FontSize.Small :
                    style.Font.Size = FontUnit.Smaller;
                    break;

                default :
                    break;
            }
        }

        protected internal StateBag State
        {
            get
            {
                if (_state == null)
                {
                    _state = new StateBag();
                    if (((IStateManager)this).IsTrackingViewState)
                    {
                        ((IStateManager)_state).TrackViewState();
                    }
                }

                return _state;
            }
        }

        bool IStateManager.IsTrackingViewState
        {
            get
            {
                return _marked;
            }
        }

        void IStateManager.TrackViewState()
        {
            _marked = true;
            if (_state != null)
            {
                ((IStateManager)_state).TrackViewState();
            }
        }

        Object IStateManager.SaveViewState()
        {
            return _state != null ? ((IStateManager)_state).SaveViewState() : null;
        }

        void IStateManager.LoadViewState(Object state)
        {
            if (state != null)
            {
                // mark _referredStyle as dirty to force reload from viewstate.
                Refresh();
                
                ((IStateManager)State).LoadViewState(state);
            }
        }

        internal void SetDirty()
        {
            foreach (StateItem item in State.Values)
            {
                item.IsDirty = true;
            }
        }

        internal void Refresh()
        {
            _referredStyle = null;
            _checkedStyleReference = false;
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public MobileControl Control
        {
            get
            {
                return _control;
            }
        }

        internal void SetControl(MobileControl control)
        {
            _control = control;
            _cachedParentStyle = null;
        }

        [
            Browsable(false),
            DefaultValue(""),
            MobileSysDescription(SR.Style_Name),
            NotifyParentProperty(true),
        ]
        public String Name
        {
            get
            {
                String name = (String)State["Name"];
                return name != null ? name : String.Empty;
            }
            set
            {
                State["Name"] = value;
            }
        }

        [
            Bindable(false),
            DefaultValue(null),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Style_Reference),
            NotifyParentProperty(true),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.StyleReferenceConverter)),
        ]
        public virtual String StyleReference
        {
            get
            {
                return (String)State["StyleReference"];
            }
            set
            {
                State["StyleReference"] = value;
                Refresh();      // mark referred style as dirty
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal Style ReferredStyle
        {
            get
            {
                if (_checkedStyleReference)
                {
                    return _referredStyle;
                }

                _checkedStyleReference = true;
                String reference = StyleReference;

                if (reference == null || reference.Length == 0)
                {
                    _referredStyle = null;
                    return null;
                }

                Debug.Assert(_referredStyle == null ||
                             reference.ToLower(CultureInfo.InvariantCulture) == _referredStyle.Name.ToLower(CultureInfo.InvariantCulture),
                             "Inconsistency in style names - _referredStyle must be dirty.");
                
                if (_referredStyle == null)
                {
                    // Look in the stylesheet in the nearest templated control
                    TemplateControl nearestTemplatedControl =
                        _control.FindContainingTemplateControl();

                    StyleSheet stylesheet = null;
                    MobilePage mobilePage = nearestTemplatedControl as MobilePage;
                    if (mobilePage != null)
                    {
                        stylesheet = mobilePage.StyleSheet;
                    }
                    else
                    {
                        MobileUserControl mobileUserControl =
                            nearestTemplatedControl as MobileUserControl;
                        if (mobileUserControl != null)
                        {
                            stylesheet = mobileUserControl.StyleSheet;

                            // If stylesheet is in mobileUserControl at designtime, 
                            // simply use the one in MobilePage
                            if (_control.MobilePage.DesignMode)
                            {
                                Debug.Assert(stylesheet == StyleSheet.Default);
                                stylesheet = _control.MobilePage.StyleSheet;
                            }
                        }

                        // Stylesheets won't be recognized in regular user
                        // controls.
                    }

                    if (stylesheet != null)
                    {
                        // when page does not contain StyleSheet
                        // controls, Default stylesheet will search twice. 
                        _referredStyle = stylesheet[reference];
                    }

                    if (_referredStyle == null)
                    {
                        // built in styles
                        _referredStyle = StyleSheet.Default[reference];

                        // No exceptions in Designer, will handle differently.
                        if (_referredStyle == null && !_control.MobilePage.DesignMode)
                        {
                            String exceptionResource;
                            if (nearestTemplatedControl is UserControl &&
                                !(nearestTemplatedControl is MobileUserControl))
                            {
                                // Throw a specific error message in this case
                                exceptionResource =
                                    SR.Style_StyleNotFoundOnGenericUserControl;
                            }
                            else
                            {
                                exceptionResource =
                                    SR.Style_StyleNotFound;
                            }
                                
                            throw new Exception(SR.GetString(exceptionResource,
                                                             reference)); 
                        }
                    }
                }

                return _referredStyle;
            }
        }

        //  late bound method for accessing style properties
        public Object this[Object key]
        {
            get
            {
                return GetValue((Property)key, false, true, null);
            }
            set
            {
                Property property = (Property)key;
                Object defaultValue = property.DefaultValue;
                State[property.Name] = defaultValue.Equals(value) ? null : value;
            }
        }

        public Object this[Object key, bool inherit]
        {
            get
            {
                return GetValue((Property)key, inherit, true, null);
            }
        }

        private Object this[Object key, bool inherit, bool returnDefault]
        {
            get
            {
                return GetValue((Property)key, inherit, returnDefault, null);
            }
        }

        private Object GetValue(Property property, bool inherit, bool returnDefault, Hashtable stylesEncountered)
        {
            //  try to retrieve from internal value
            Object value = State[property.Name];

            if (stylesEncountered == null)
            {
                stylesEncountered = new Hashtable(); 
            }

            if (value == null)
            {
                //  else retrieve from style reference
                if (inherit)
                {
                    Style style = this.ReferredStyle;
                    if (style != null)
                    {
                        if (stylesEncountered.ContainsKey(style))
                        {
                            if (_control.MobilePage != null && _control.MobilePage.DesignMode)
                            {
                                return property.DefaultValue;
                            }
                            else
                            {
                                throw new Exception(SR.GetString(SR.Style_CircularReference, this.Name));
                            }
                        }
                        stylesEncountered[style] = true;
                        value = style.GetValue(property, inherit, false, stylesEncountered);
                    }
                }

                if (value == null)
                {
                    //  else retrieve from control ancestor
                    if (inherit && property.Inherit && _control != null)
                    {
                        Style parentStyle = null;
                        if (_cachedParentStyle == null)
                        {
                            if (_control.Parent is MobileControl)
                            {
                                parentStyle = ((MobileControl)_control.Parent).Style;
                                _cachedParentStyle = parentStyle;
                            }
                            // DeviceSpecific is treated as control at design time, however, we need to get
                            // the styles from devicespecific's parent.
                            else if (_control.MobilePage != null &&
                                _control.MobilePage.DesignMode && 
                                _control.Parent is DeviceSpecific &&
                                _control.Parent.Parent is MobileControl)
                            {
                                parentStyle = ((MobileControl)_control.Parent.Parent).Style;
                            }
                            else if(!(_control is Form))
                            {
                                Control _tempControl = _control.Parent;
                                while(!(_tempControl is MobileControl) && (_tempControl != null))
                                {
                                    _tempControl = _tempControl.Parent;
                                }
                                if(_tempControl != null)
                                {
                                    parentStyle = ((MobileControl)_tempControl).Style;
                                }
                            }
                        }
                        else
                        {
                            parentStyle = _cachedParentStyle;
                        }

                        if (parentStyle != null)
                        {
                            value = parentStyle.GetValue(property, inherit, false, null);
                        }
                    }

                    //  else retrieve default value
                    if (value == null && returnDefault)
                    {
                        value = property.DefaultValue;
                    }
                }
            }
            return value;
        }

        internal void InvalidateParentStyle()
        {
            _cachedParentStyle = null;
        }

        internal void ValidateReference()
        {
            Style s = ReferredStyle;
            
            // No need to check further, since the Stylesheet has been separately validated.
        }

        ////////////////////////////////////////////////////////////////////////////
        //  BEGIN STYLES
        ////////////////////////////////////////////////////////////////////////////

        [
            DefaultValue(null),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Style_Font),
            NotifyParentProperty(true)
        ]
        public FontInfo Font
        {
            get
            {
                if (_font == null)
                {
                    _font = new FontInfo(this);
                }
                return _font;
            }
        }

        // FontSize and FontName internal
        // we still need these methods on style due to their inheritance and
        // persistence behavior, they're referenced from FontInfo.cs.
        // TODO: At some point, look into truly separating inheritance and
        // persistence of these out so they needn't live in Style. (Also applies
        // to Bold and Italic)
        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal String FontName
        {
            get
            {
                return (String)this[FontNameKey];
            }
            set
            {
                this[FontNameKey] = value;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal BooleanOption Bold
        {
            get
            {
                return (BooleanOption)this[BoldKey];
            }
            set
            {
                this[BoldKey] = value;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal BooleanOption Italic
        {
            get
            {
                return (BooleanOption)this[ItalicKey];
            }
            set
            {
                this[ItalicKey] = value;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal FontSize FontSize
        {
            get
            {
                return (FontSize)this[FontSizeKey];
            }
            set
            {
                this[FontSizeKey] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(Alignment.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Style_Alignment),
            NotifyParentProperty(true),
        ]
        public Alignment Alignment
        {
            get
            {
                return (Alignment)this[AlignmentKey];
            }
            set
            {
                this[AlignmentKey] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(Wrapping.NotSet),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Style_Wrapping),
            NotifyParentProperty(true),
        ]
        public Wrapping Wrapping
        {
            get
            {
                return (Wrapping)this[WrappingKey];
            }
            set
            {
                this[WrappingKey] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(typeof(Color), ""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Style_ForeColor),
            NotifyParentProperty(true),
            TypeConverterAttribute(typeof(WebColorConverter)),
        ]
        public Color ForeColor
        {
            get
            {
                return (Color)this[ForeColorKey];
            }
            set
            {
                this[ForeColorKey] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(typeof(Color), ""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.Style_BackColor),
            NotifyParentProperty(true),
            TypeConverterAttribute(typeof(WebColorConverter))
        ]
        public Color BackColor
        {
            get
            {
                return (Color)this[BackColorKey];
            }
            set
            {
                this[BackColorKey] = value;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  TEMPLATES SUPPORT
        /////////////////////////////////////////////////////////////////////////


        void IParserAccessor.AddParsedSubObject(Object o)
        {
            if (o is DeviceSpecific)
            {
                if (DeviceSpecific != null)
                {
                    throw new Exception(
                        SR.GetString(SR.MobileControl_NoMultipleDeviceSpecifics));
                }
                DeviceSpecific = (DeviceSpecific)o;

                // This code works by assuming that the time this
                // method is called, that Control has not yet been
                // set.  Thus, we set the DeviceSpecific's parent
                // control when the Control itself is set.  If Control
                // != null here, then we won't get that opportunity. 
                Debug.Assert(Control == null);
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public bool IsTemplated
        {
            get
            {
                return IsTemplatedInternal(null);
            }
        }

        internal bool IsTemplatedInternal(Hashtable stylesEncountered)
        {
            if (_deviceSpecific != null && _deviceSpecific.HasTemplates)
            {
                return true;
            }

            Style referredStyle = ReferredStyle;
            if (referredStyle == null)
            {
                return false;
            }

            if (stylesEncountered == null)
            {
                stylesEncountered = new Hashtable(); 
            }
            if (stylesEncountered.ContainsKey(referredStyle))
            {
                if (_control.MobilePage != null && _control.MobilePage.DesignMode)
                {
                    return false;
                }
                else
                {
                    throw new Exception(SR.GetString(SR.Style_CircularReference, this.Name));
                }
            }
            // referredStyle != null
            stylesEncountered[referredStyle] = true;
            return referredStyle.IsTemplatedInternal(stylesEncountered);
        }

        public ITemplate GetTemplate(String templateName)
        {
            return GetTemplateInternal(templateName, null);
        }

        internal ITemplate GetTemplateInternal(String templateName, Hashtable stylesEncountered)
        {
            ITemplate t = null;
            if (_deviceSpecific != null)
            {
                t = (ITemplate)_deviceSpecific.GetTemplate (templateName);
            }

            Style referredStyle = ReferredStyle;
            if (t == null && referredStyle != null)
            {
                // Check for cyclical style references.
                if (stylesEncountered == null)
                {
                    stylesEncountered = new Hashtable ();
                }
                if (stylesEncountered.ContainsKey(referredStyle))
                {
                    if (_control.MobilePage != null && _control.MobilePage.DesignMode)
                    {
                        return null;
                    }
                    else
                    {
                        throw new Exception(SR.GetString(SR.Style_CircularReference, this.Name));
                    }
                }

                // No cycle detected.
                stylesEncountered[referredStyle] = true;                
                t = referredStyle.GetTemplateInternal(templateName, stylesEncountered);
            }

            return t;
        }

        // Design-time only property
        [
            Browsable(false),
            PersistenceMode(PersistenceMode.InnerProperty)
        ]
        public DeviceSpecific DeviceSpecific
        {
            get
            {
                return _deviceSpecific;
            }
            set
            {
                _deviceSpecific = value;
                if (null != value)
                {
                    value.SetOwner(this);
                }
            }
        }

        //  registers a new type of style and returns the KEY for accessing it
        public static Object RegisterStyle(String name, Type type, Object defaultValue, bool inherit)
        {
            return new Property(name, type, defaultValue, inherit);
        }

        class Property
        {
            public String Name;
            public Type   Type;
            public Object DefaultValue;
            public bool   Inherit;        // can be inherited from parent?

            public Property(String name, Type type, Object defaultValue, bool inherit)
            {
                this.Name = name;
                this.Type = type;
                this.DefaultValue = defaultValue;
                this.Inherit = inherit;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\textbox.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextBox.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile TextBox class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ControlBuilderAttribute(typeof(TextBoxControlBuilder)),
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultEvent("TextChanged"),
        DefaultProperty("Text"),
        Designer(typeof(System.Web.UI.Design.MobileControls.TextBoxDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerTextBoxAdapter)),
        ToolboxData("<{0}:TextBox runat=\"server\"></{0}:TextBox>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign),
        ValidationProperty("Text")
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TextBox : TextControl, IPostBackDataHandler
    {
        private static readonly Object EventTextChanged = new Object();

        bool IPostBackDataHandler.LoadPostData(String key, NameValueCollection data)
        {
            bool dataChanged = false;
            bool handledByAdapter =
                Adapter.LoadPostData(key, data, null, out dataChanged);

            if (!handledByAdapter)
            {
                String value = data[key];
                if (Text != value)
                {
                    Text = value;
                    dataChanged = true;    // this will cause a RaisePostDataChangedEvent()
                }
            }

            return dataChanged;
        }

        void IPostBackDataHandler.RaisePostDataChangedEvent()
        {
            OnTextChanged(EventArgs.Empty);
        }

        protected virtual void OnTextChanged(EventArgs e)
        {
            EventHandler onTextChangedHandler = (EventHandler)Events[EventTextChanged];
            if (onTextChangedHandler != null)
            {
                onTextChangedHandler(this,e);
            }
        }

        [
            Bindable(true),
            Browsable(true),
            DefaultValue(false),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.TextBox_Password)
        ]
        public bool Password
        {
            get
            {
                Object b = ViewState["Password"];
                return (b != null) ? (bool)b : false;
            }
            set
            {
                ViewState["Password"] = value;
            }
        }

        [
            Bindable(true),
            Browsable(true),
            DefaultValue(false),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.TextBox_Numeric)
        ]
        public bool Numeric
        {
            get
            {
                Object b = ViewState["Numeric"];
                return (b != null) ? (bool)b : false;
            }
            set
            {
                ViewState["Numeric"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(0),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.TextBox_Size)
        ]
        public int Size
        {
            get
            {
                Object i = ViewState["Size"];
                return((i != null) ? (int)i : 0);
            }
            set
            {
                if (value < 0)
                {
                    throw new ArgumentOutOfRangeException("Size", value,
                        SR.GetString(SR.TextBox_NotNegativeNumber));
                }
                ViewState["Size"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(0),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.TextBox_MaxLength)
        ]
        public int MaxLength
        {
            get
            {
                Object i = ViewState["MaxLength"];
                return((i != null) ? (int)i : 0);
            }
            set
            {
                if (value < 0)
                {
                    throw new ArgumentOutOfRangeException("MaxLength", value,
                        SR.GetString(SR.TextBox_NotNegativeNumber));
                }
                ViewState["MaxLength"] = value;
            }
        }

        [
            MobileSysDescription(SR.TextBox_OnTextChanged)
        ]
        public event EventHandler TextChanged
        {
            add
            {
                Events.AddHandler(EventTextChanged, value);
            }
            remove
            {
                Events.RemoveHandler(EventTextChanged, value);
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.TextBox_Title)
        ]
        public String Title
        {
            get
            {
                return ToString(ViewState["Title"]);
            }
            set
            {
                ViewState["Title"] = value;
            }
        }

        internal override bool TrimInnerText
        {
            get
            {
                return false;
            }
        }

        internal override bool TrimNewlines
        {
            get
            {
                return true;
            }
        }
    }

    /*
     * TextBox Control Builder
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TextBoxControlBuilder : MobileControlBuilder
    {
        // Textbox allows whitespace inside text.

        public override bool AllowWhitespaceLiterals()
        {
            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\stylesheet.cs ===
//------------------------------------------------------------------------------
// <copyright file="StyleSheet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Design;
using System.Globalization;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.Util;
using System.Reflection;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile StyleSheet class.
     */
    [
        ControlBuilderAttribute(typeof(StyleSheetControlBuilder)),
        Designer(typeof(System.Web.UI.Design.MobileControls.StyleSheetDesigner)),
        Editor(typeof(System.Web.UI.Design.MobileControls.StyleSheetComponentEditor),
            typeof(ComponentEditor)),
        ToolboxData("<{0}:StyleSheet runat=\"server\"></{0}:StyleSheet>"),
        ToolboxItem(typeof(System.Web.UI.Design.WebControlToolboxItem))
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class StyleSheet : MobileControl
    {
        private readonly static StyleSheet _default = new StyleSheet();
        private StyleCollection _styles = new StyleCollection();
        private StyleSheet _externalStyleSheet;
        private ArrayList _duplicateStyles = new ArrayList();
        private StyleSheet _referrer;
        private String _resolvedPath;
        private bool _saveAll = false;

        static StyleSheet()
        {
            //  initialize default stylesheet
            {
                Style title = new Style();
                title.Bold = BooleanOption.True;
                title.Font.Size = FontSize.Large;
                title.Name = "title";
                _default.AddParsedSubObject(title);

                Style error = new Style();
                error.ForeColor = Color.Red;
                error.Name = Constants.ErrorStyle;
                _default.AddParsedSubObject(error);

                Style subCommand = new Style();
                subCommand.Font.Size = FontSize.Small;
                subCommand.Name = "subcommand";
                subCommand.Alignment = Alignment.Center;
                _default.AddParsedSubObject(subCommand);
            }
        }

        public static StyleSheet Default
        {
            get
            {
                return _default;
            }
        }

        protected override void AddParsedSubObject(Object o)
        {
            if (o is Style)
            {
                Style style = (Style)o;
                style.SetControl(this);
                String name = style.Name;
                if (name == null || name == String.Empty)
                {
                    throw new Exception(
                        SR.GetString(SR.StyleSheet_MustContainID));
                }
                // Remember any duplicate styles we encounter.  Validate()
                // will throw if this list is not empty.
                String lowerName = name.ToLower(CultureInfo.InvariantCulture);
                if (_styles[lowerName] != null)
                {
                    _duplicateStyles.Add(style);
                }
                else
                {
                    // Do not overwrite hash table with duplicate style or we
                    // will loose the overwritten style in the designer.
                    this[name] = style;
                }
            }
            else
            {
                base.AddParsedSubObject(o);
            }
        }

        public Style this[String name]
        {
            get
            {
                Style style = (Style)_styles[name.ToLower(CultureInfo.InvariantCulture)];
                if (style == null && ExternalStyleSheet != null)
                {
                    style = _externalStyleSheet[name];
                }
                return style;
            }
            set
            {
                if (name == null || name.Length == 0)
                {
                    throw new ArgumentException(SR.GetString(SR.Style_EmptyName));
                }

                String lowerName = name.ToLower(CultureInfo.InvariantCulture);
                
                if (lowerName != value.Name.ToLower(CultureInfo.InvariantCulture))
                {
                    // If the Style doesn't yet have a name, assign it the one that
                    // it's being set as in the Stylesheet.
                    if (value.Name == String.Empty)
                    {
                        value.Name = name;
                    }
                    else
                    {
                        throw new ArgumentException(
                            SR.GetString(SR.StyleSheet_InvalidStyleName,
                                         value.Name, name));
                    }
                }

                if (value.Control == null)
                {
                    // Necessary for programmatically generated styles...  need
                    // to have their stylesheet set when inserted.
                    value.SetControl(this);
                }
                else if (value.Control != this && MobilePage != null && !MobilePage.DesignMode)
                {
                    // In the rare event that someone tries to share a
                    // style between stylesheets.  (Don't do this check in
                    // design mode, as they do share styles, although in a very
                    // careful way that doesn't cause problems.)
                    throw new Exception(
                        SR.GetString(SR.StyleSheet_StyleAlreadyOwned,
                                     value.Name,
                                     value.Control.ID));
                }

                if (_styles[lowerName] != null)
                {
                    _saveAll = true;
                }
                else if (IsTrackingViewState)
                {
                    value.SetDirty();
                    ((IStateManager)value).TrackViewState();
                }
                
                _styles[lowerName] = value;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public ICollection Styles
        {
            get
            {
                return (ICollection)_styles;
            }
        }

        public void Remove(String name)
        {
            _saveAll = true;
            if (!_styles.Remove (name))
            {
                throw new ArgumentException(SR.GetString(SR.Style_StyleNotFound, name));
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            Editor(typeof(System.Web.UI.Design.MobileControls.StyleSheetRefUrlEditor), typeof(UITypeEditor)),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.StyleSheet_ReferencePath)
        ]
        public String ReferencePath
        {
            get
            {
                String s = (String)ViewState["ReferencePath"];
                return s != null ? s : String.Empty;
            }
            set
            {
                ViewState["ReferencePath"] = value;
                _externalStyleSheet = null;
            }
        }

        private StyleSheet ExternalStyleSheet
        {
            get
            {
                // If page is null then this is the default stylesheet
                if (Page == null || MobilePage.DesignMode)
                {
                    return null;
                }

                if (_externalStyleSheet == null && ReferencePath.Length > 0)
                {
                    // Should load relative to parent template control (which 
                    // may be a page or a user control).

                    TemplateControl parent = (TemplateControl)Parent;

                    // First check if there are any circular references.

                    String resolvedPath = UrlPath.Combine(parent.TemplateSourceDirectory,
                                                          ReferencePath);
                    for (StyleSheet ss = Referrer; ss != null; ss = ss.Referrer)
                    {
                        if (ss.ResolvedPath != null &&
                                String.Compare(ss.ResolvedPath, resolvedPath, true, CultureInfo.InvariantCulture) == 0)
                        {
                            throw new Exception(SR.GetString(SR.StyleSheet_LoopReference, 
                                                             ResolvedPath));
                        }
                    }

                    Control control = parent.LoadControl(ReferencePath);

                    // By adding it as a child of this control, the user
                    // control returned above is instantiated and its
                    // children are accessible below.
                    Controls.Add(control);

                    foreach (Control child in control.Controls)
                    {
                        _externalStyleSheet = child as StyleSheet;
                        if (_externalStyleSheet != null)
                        {
                            break;
                        }
                    }
                    if (_externalStyleSheet == null)
                    {
                        throw new Exception(
                            SR.GetString(SR.StyleSheet_NoStyleSheetInExternalFile));
                    }

                    _externalStyleSheet.ResolvedPath = resolvedPath;
                    _externalStyleSheet.Referrer = this;
                }
                return _externalStyleSheet;
            }
        }

        internal override void ApplyDeviceSpecifics()
        {
            // Apply our own device specifics first

            base.ApplyDeviceSpecifics();

            // Iterate over the Styles, invoking ApplyProperties on each Style's
            // DeviceSpecific.

            foreach (String key in _styles.Keys)
            {
                Style style = _styles[key];
                if (style.DeviceSpecific != null)
                {
                    style.DeviceSpecific.ApplyProperties();
                }
            }
        }

        private StyleSheet Referrer
        {
            get
            {
                return _referrer;
            }

            set
            {
                _referrer = value;
            }
        }

        private String ResolvedPath
        {
            get
            {
                return _resolvedPath;
            }

            set
            {
                _resolvedPath = value;
            }
        }

        protected override void TrackViewState()
        {
            for (int i = 0; i < _styles.Count; i++)
            {
                ((IStateManager)_styles.GetAt(i)).TrackViewState();
            }
            base.TrackViewState();
        }

        internal override bool RequiresForm
        {
            get
            {
                return false;
            }
        }

        protected override Object SaveViewState()
        {
            Object baseState = base.SaveViewState();

            int styleCount = _styles.Count;
            Object[] stylesState = new Object[styleCount];

            if (_saveAll)
            {
                for (int i = 0; i < styleCount; i++)
                {
                    Style style = (Style)_styles.GetAt(i);
                    style.SetDirty();
                    stylesState[i] = ((IStateManager)style).SaveViewState();
                }
            }
            else
            {
                bool anySaved = false;
                for (int i = 0; i < styleCount; i++)
                {
                    Style style = (Style)_styles.GetAt(i);
                    stylesState[i] = ((IStateManager)style).SaveViewState();
                    if (stylesState[i] != null)
                    {
                        anySaved = true;
                    }
                }

                if (!anySaved)
                {
                    stylesState = null;
                }
            }

            if (stylesState != null || baseState != null)
            {
                return new Object[] { baseState, _saveAll, stylesState };
            }
            else
            {
                return null;
            }
        }

        protected override void LoadViewState(Object savedState)
        {
            if (savedState != null)
            {
                Object[] o = (Object[])savedState;
                base.LoadViewState(o[0]);

                if (o[2] != null)
                {
                    bool savedAll = (bool)o[1];
                    Object[] stylesState = (Object[])o[2];

                    if (savedAll)
                    {
                        _saveAll = true;
                        _styles.Clear();
                    }

                    int stylesCount = _styles.Count;
                    for (int i = 0; i < stylesState.Length; i++)
                    {
                        if (i >= stylesCount)
                        {
                            Style style = new Style();
                            IStateManager styleStateMgr = (IStateManager)style;

                            styleStateMgr.LoadViewState(stylesState[i]);
                            styleStateMgr.TrackViewState();
                            style.SetControl(this);
                            _styles[style.Name.ToLower(CultureInfo.InvariantCulture)] = style;
                        }
                        else if (stylesState != null)
                        {
                            ((IStateManager)_styles.GetAt(i)).LoadViewState(stylesState[i]);
                        }
                    }
                }
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN DESIGNER SUPPORT
        /////////////////////////////////////////////////////////////////////////

        public void Clear()
        {
            _styles.Clear();
        }

        // Do not expose the Visible property in the Designer
        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override bool Visible 
        {
            get
            {
                // REVIEW: the stylesheet control should be invisible.
                // Should we just return 'false' here?
                return base.Visible;
            }
            set
            {
                base.Visible = value;
            }
        }

        // Do not expose the EnableViewState property in the Designer
        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public override bool EnableViewState
        {
            get
            {
                return base.EnableViewState;
            }
            set
            {
                base.EnableViewState = value;
            }
        }


        /////////////////////////////////////////////////////////////////////////
        //  END DESIGNER SUPPORT
        /////////////////////////////////////////////////////////////////////////

        /////////////////////////////////////////////////////////////////////////
        //  BEGIN STYLE PROPERTIES
        /////////////////////////////////////////////////////////////////////////

        // Style properties are not applicable in the stylesheet control

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override String StyleReference
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return String.Empty;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "StyleReference"));
            }
            set
            {
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotSettable, "StyleReference"));
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override FontInfo Font
        {
            get
            {
                // The checking if MobilePage null is necessary because Font is a
                // expandable property, the property browser still check the inner
                // Font properties although it is not browsable. When designer is
                // first loaded, MobilePage is still unassigned.
                if (MobilePage == null || MobilePage.DesignMode)
                {
                    return null;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "Font"));
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override Alignment Alignment
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return Alignment.NotSet;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "Alignment"));
            }
            set
            {
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotSettable, "Alignment"));
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override Wrapping Wrapping
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return Wrapping.NotSet;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "Wrapping"));
            }
            set
            {
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotSettable, "Wrapping"));
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override Color ForeColor
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return Color.Empty;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "ForeColor"));
            }
            set
            {
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotSettable, "ForeColor"));
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override Color BackColor
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return Color.Empty;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "BackColor"));
            }
            set
            {
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotSettable, "BackColor"));
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
            EditorBrowsable(EditorBrowsableState.Never),
        ]
        public override bool BreakAfter
        {
            get
            {
                if (MobilePage.DesignMode)
                {
                    return true;
                }
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotAccessible, "BreakAfter"));
            }
            set
            {
                throw new Exception(
                    SR.GetString(SR.StyleSheet_PropertyNotSettable, "BreakAfter"));
            }
        }

        internal ICollection DuplicateStyles
        {
            get
            {
                return _duplicateStyles;
            }
        }

        /////////////////////////////////////////////////////////////////////////
        //  END STYLE PROPERTIES
        /////////////////////////////////////////////////////////////////////////

        /*
         * Private style collection class, that allows by-name or by-index access to
         * a set of styles.
         */

        private class StyleCollection : NameObjectCollectionBase
        {
            public Style this[String name]
            {
                get
                {
                    return (Style)BaseGet(name);
                }

                set
                {
                    BaseSet(name, value);
                }
            }

            public Style GetAt(int i)
            {
                return (Style)BaseGet(i);
            }

            public bool Remove(String name)
            {
                if (this[name] == null)
                {
                    return false;
                }
                else
                {
                    this[name].SetControl(null);
                    BaseRemove(name);
                    return true;
                }
            }

            public void Clear()
            {
                BaseClear();
            }
            


        }
    }

    /*
     * StyleSheet Control builder.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class StyleSheetControlBuilder : MobileControlBuilder
    {
        public override Type GetChildControlType(String name, IDictionary attributes) 
        {
            String lowerCaseName = name.ToLower(CultureInfo.InvariantCulture);

            if (lowerCaseName.EndsWith(":style"))
            {
                return typeof(Style);
            }

            // Any extender to Style *MUST* be added in here to be recognized in
            // a StyleSheet.
            // NOTE: Currently no way for third party extenders to add their
            // own styles.  They'll need to specify complete name and
            // runat=server. 

            Type type = null;
            switch (lowerCaseName)
            {
              case "style":
                if(InDesigner)
                {
                    // Indicate to the designer that it needs to add a prefix.
                    System.Web.UI.Design.MobileControls.StyleSheetDesigner.SetRequiresDesignTimeChanges();
                }
                type = typeof(Style);
                break;

              case "pagerstyle":
                type = typeof(PagerStyle);
                break;

              default:
                type = base.GetChildControlType(name, attributes);
                break;
            }

            return type;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\templatecontainer.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateContainer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;                    
using System.Web.UI;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * TemplateContainer class. A specialized version of Panel that is
     * also a naming container. This class must be used by all mobile controls
     * as the container for instantiating templates.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TemplateContainer : Panel, INamingContainer
    {
        public TemplateContainer()
        {
            BreakAfter = false;
        } 

        // Override this property to change the default value attribute.
        [
            DefaultValue(false)    
        ]
        public override bool BreakAfter
        {
            get
            {
                return base.BreakAfter;
            }

            set
            {
                base.BreakAfter = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\textcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.ComponentModel;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile TextControl class.
     * All controls which contain embedded text extend from this control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        ToolboxItem(false)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class TextControl : MobileControl
    {
        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.TextControl_Text),
            PersistenceMode(PersistenceMode.EncodedInnerDefaultProperty)
        ]
        public String Text
        {
            get
            {
                return InnerText;
            }

            set
            {
                InnerText = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\validationsummary.cs ===
//------------------------------------------------------------------------------
// <copyright file="ValidationSummary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Globalization;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Diagnostics;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{
    /*
     * Mobile ValidationSummary class.
     * The ValidationSummary shows all the validation errors in a Form in a
     * summary view.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DefaultProperty("FormToValidate"),
        Designer(typeof(System.Web.UI.Design.MobileControls.ValidationSummaryDesigner)),
        DesignerAdapter(typeof(System.Web.UI.Design.MobileControls.Adapters.DesignerValidationSummaryAdapter)),
        ToolboxData("<{0}:ValidationSummary runat=\"server\"></{0}:ValidationSummary>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ValidationSummary : MobileControl
    {
        private bool _callValidate = true;

        public ValidationSummary()
        {
            StyleReference = Constants.ErrorStyle;
        }

        ////////////////////////////////////////////////////////////////////////
        // Mimic some properties exposed in the original ValidatorSummary.
        ////////////////////////////////////////////////////////////////////////

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.ValidationSummary_HeaderText)
        ]
        public String HeaderText
        {
            get
            {
                String s = (String) ViewState["HeaderText"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["HeaderText"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Behavior),
            MobileSysDescription(SR.ValidationSummary_FormToValidate),
            TypeConverter(typeof(System.Web.UI.Design.MobileControls.Converters.FormConverter))
        ]
        public String FormToValidate
        {
            get
            {
                String s = (String) ViewState["FormToValidate"];
                return((s != null) ? s : String.Empty);
            }
            set
            {
                ViewState["FormToValidate"] = value;
            }
        }

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.ValidationSummary_BackLabel)
        ]
        public String BackLabel
        {
            get
            {
                return ToString(ViewState["BackLabel"]);
            }
            set
            {
                ViewState["BackLabel"] = value;
            }
        }

        // Designer needs to know the correct default value in order to persist it correctly.
        [
            DefaultValue(Constants.ErrorStyle)
        ]
        public override String StyleReference
        {
            get
            {
                return base.StyleReference;
            }
            set
            {
                base.StyleReference = value;
            }
        }

        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            // There are cases that we don't want to call the Validate()
            // method on individual validators that the ValidationSummary is
            // targeting to.
            // This first case is when the page is hit at the first time.
            // And the second case is when FormToValidate is the same as the
            // form ValidationSummary is on and this form is a postback from
            // the same form.  In this case, the validators' validate()
            // method should have been called by MobilePage if needed.

            if (!MobilePage.IsPostBack ||
                String.Compare(Form.UniqueID, FormToValidate, true, CultureInfo.InvariantCulture) == 0)
            {
                _callValidate = false;
            }
        }

        private void GetErrorValidators_Helper(Control parent, ArrayList errorValidators)
        {
            foreach(Control control in parent.Controls)
            {
                BaseValidator baseVal = control as BaseValidator;
                if (baseVal != null && baseVal.ErrorMessage.Length != 0)
                {
                    if (_callValidate)
                    {
                        baseVal.Validate();
                    }

                    if (!baseVal.IsValid)
                    {
                        errorValidators.Add(baseVal);
                    }
                }
                GetErrorValidators_Helper(control, errorValidators);
            }
        }
        
        public String[] GetErrorMessages()
        {
            String[] errorDescriptions = null;
            ArrayList errorValidators = new ArrayList();

            Form targetForm = ResolveFormReferenceNoThrow(FormToValidate);

            if (targetForm == null)
            {
                throw new ArgumentException(
                    SR.GetString(SR.ValidationSummary_InvalidFormToValidate,
                                 FormToValidate,
                                 ID));
            }
            // Recursively find all validators with error messages to display.
            GetErrorValidators_Helper(targetForm, errorValidators);

            int count = errorValidators.Count;
            
            if (count > 0)
            {
                // get the messages;
                errorDescriptions = new String[count];
                int iMessage = 0;
                foreach (BaseValidator val in errorValidators)
                {
                    Debug.Assert(val != null, "Null reference unexpected!");
                    Debug.Assert(val.ErrorMessage.Length != 0, "Programmatic error: error message here shouldn't be empty!");
                    errorDescriptions[iMessage] = String.Copy(val.ErrorMessage);
                    iMessage++;
                }
                Debug.Assert(count == iMessage, "Not all messages were found!");
            }

            return errorDescriptions;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\textviewelement.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextViewElement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Text;
using System.Diagnostics;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Design;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile TextView Element class.
     * The TextView control stores its contents as a series of elements. This
     * class encapsulates an element.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TextViewElement
    {
        private String _text;
        private String _url;
        private bool _isBold;
        private bool _isItalic;
        private bool _breakAfter;

        public String Text
        {
            get
            {
                return _text;
            }
        }

        public String Url
        {
            get
            {
                return _url;
            }
        }

        public bool IsBold
        {
            get
            {
                return _isBold;
            }
        }

        public bool IsItalic
        {
            get
            {
                return _isItalic;
            }
        }

        public bool BreakAfter
        {
            get
            {
                return _breakAfter;
            }
        }

        internal TextViewElement(String text, String url, bool isBold, bool isItalic, bool breakAfter)
        {
            _text       = text;
            _url        = url;
            _isBold     = isBold;
            _isItalic   = isItalic;
            _breakAfter = breakAfter;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\uniqueset.cs ===
//------------------------------------------------------------------------------
// <copyright file="UniqueSet.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace System.Web.UI.MobileControls
{
    /*
     * UniqueSet class. An array of objects that are unique.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    internal sealed class UniqueSet : ArrayList
    {
        internal UniqueSet() {
        }

        public override int Add(Object o)
        {
            if (!Contains(o))
            {
                return base.Add(o);
            }
            else
            {
                return -1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\textview.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextView.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Text;
using System.Diagnostics;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Drawing;
using System.Drawing.Design;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.Design.WebControls;
using System.Web.UI.HtmlControls;
using System.Security.Permissions;

namespace System.Web.UI.MobileControls
{

    /*
     * Mobile TextView class.
     * The TextView control is for displaying large fields of text data.
     * It supports internal pagination.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [
        DataBindingHandler("System.Web.UI.Design.TextDataBindingHandler, " + AssemblyRef.SystemDesign),
        DefaultProperty("Text"),
        Designer(typeof(System.Web.UI.Design.MobileControls.TextViewDesigner)),
        DesignerAdapter("System.Web.UI.Design.MobileControls.Adapters.DesignerTextViewAdapter"),
        ToolboxData("<{0}:TextView runat=\"server\">TextView</{0}:TextView>"),
        ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, " + AssemblyRef.SystemDesign)
    ]
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class TextView : PagedControl
    {
        private bool _haveContent = false;
        private ArrayList _elements = new ArrayList();

        [
            Bindable(true),
            DefaultValue(""),
            MobileCategory(SR.Category_Appearance),
            MobileSysDescription(SR.TextView_Text),
            PersistenceMode(PersistenceMode.InnerDefaultProperty)
        ]
        public String Text
        {

            get
            {
                return InnerText;
            }

            set
            {
                InnerText = value;
                if (_haveContent)
                {
                    _elements = null;
                    _haveContent = false;
                }
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public new int ItemCount
        {
            get
            {
                return base.ItemCount;
            }
            set
            {
                base.ItemCount = value;
            }
        }

        [
            Bindable(false),
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),            
        ]
        public new int ItemsPerPage
        {
            get
            {
                return base.ItemsPerPage;
            }
            set
            {
                base.ItemsPerPage = value;
            }
        }

        [
            Browsable(false)
        ]
        public new event LoadItemsEventHandler LoadItems
        {
            add
            {
                base.LoadItems += value;
            }
            remove
            {
                base.LoadItems -= value;
            }
        }

        // Note that this value doesn't relate to device specific info
        // because this is simply a unit size to define how many characters
        // to be counted as an item for pagination.  Depending on each
        // device's page weight, different numbers of items will be returned
        // for display.
        private static int PagingUnitSize = ControlPager.DefaultWeight;  // chars

        private int _length = 0;
        private int _pageBeginElement;
        private int _pageBeginOffset;
        private int _pageEndElement;
        private int _pageEndOffset;
        private bool _paginated = false;

        private ArrayList Elements
        {
            get
            {
                if (_elements == null)
                {
                    _elements = new ArrayList();
                }
                return _elements;
            }
        }

        private void InternalPaginate()
        {
            if (_paginated)
            {
                return;
            }

            _paginated = true;

            _pageBeginElement = 0;
            _pageEndOffset = 0;
            _pageEndElement = 0;
            _pageBeginOffset = 0;

            if (_elements == null || _elements.Count == 0)
            {
                return;
            }

            int firstBlockIndex = FirstVisibleItemIndex;
            int visibleBlockCount = VisibleItemCount;
            int blockLimit = firstBlockIndex + visibleBlockCount;
            bool isLastPage = blockLimit >= InternalItemCount;

            int block = 0;
            int blockElement = 0;
            int blockOffset = 0;
            int currentPosition = 0;
            int elementIndex = 0;
            TextViewElement element = GetElement(0);
            int elementLength = element.Text.Length;
            int blockSize = 0;

            //fill the number of blocks for this page
            while (block < blockLimit)
            {
                if (block == firstBlockIndex)
                {
                    _pageBeginElement = blockElement;
                    _pageBeginOffset = blockOffset;
                    if (isLastPage)
                    {
                        _pageEndElement = _elements.Count - 1;
                        _pageEndOffset = GetElement(_pageEndElement).Text.Length;
                        return;
                    }
                }

                while (elementLength - currentPosition <= PagingUnitSize - blockSize ||
                            (blockElement == elementIndex && element.Url != null))
                {
                    elementIndex++;
                    if (elementIndex == _elements.Count)
                    {
                        break;
                    }
                    blockSize += elementLength - currentPosition;
                    element = GetElement(elementIndex);
                    elementLength = element.Text.Length;
                    currentPosition = 0;
                }

                if (elementIndex == _elements.Count)
                {
                    _pageEndElement = _elements.Count - 1;
                    _pageEndOffset = GetElement(_pageEndElement).Text.Length;
                    return;
                }

                int nextBlockStart;
                if (element.Url != null)
                {
                    nextBlockStart = 0;
                }
                else
                {
                    int i;
                    for (i = currentPosition + (PagingUnitSize - blockSize) - 1; i >= currentPosition; i--)
                    {
                        char c = element.Text[i];
                        if (Char.IsWhiteSpace(c) || Char.IsPunctuation(c))
                        {
                            break;
                        }
                    }

                    if (i < currentPosition)
                    {
                        nextBlockStart = currentPosition;
                    }
                    else
                    {
                        nextBlockStart = i + 1;
                    }
                }

                block++;
                blockElement = elementIndex;
                blockOffset = nextBlockStart;
                currentPosition = nextBlockStart;
                blockSize = 0;
            }

            _pageEndElement = blockElement;
            _pageEndOffset = blockOffset;
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int FirstVisibleElementIndex
        {
            get
            {
                return _pageBeginElement;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int FirstVisibleElementOffset
        {
            get
            {
                return _pageBeginOffset;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]    
        public int LastVisibleElementIndex
        {
            get
            {
                return _pageEndElement;
            }
        }

        [
            Browsable(false),
            DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public int LastVisibleElementOffset
        {
            get
            {
                return _pageEndOffset;
            }
        }

        protected override void OnRender(HtmlTextWriter writer)
        {
            BuildContents();
            InternalPaginate();
            base.OnRender(writer);
        }

        public TextViewElement GetElement(int index)
        {
            return (TextViewElement)_elements[index];
        }

        private StringBuilder _translateBuilder;
        private StringWriter _translateWriter;

        internal void AddElement(String text, String href, bool isBold, bool isUnderline, bool breakAfter)
        {
            _length += text.Length;

            // Convert text if it has special characters.

            if (text.IndexOf('&') >= 0)
            {
                if (_translateWriter != null)
                {
                    _translateBuilder.Length = 0;
                }
                else
                {
                    _translateBuilder = new StringBuilder();
                    _translateWriter = new StringWriter(_translateBuilder);
                }

                TranslateAndAppendText(text, _translateWriter);
                _translateWriter.Flush();
                text = _translateBuilder.ToString();
            }

            Elements.Add(new TextViewElement(text, href, isBold, isUnderline, breakAfter));
        }

        protected override int InternalItemCount
        {
            get
            {
                return (_length + PagingUnitSize - 1) / PagingUnitSize;
            }
        }

        protected override int ItemWeight
        {
            get
            {
                return PagingUnitSize;
            }
        }

        public override void PaginateRecursive(ControlPager pager)
        {
            BuildContents();
            base.PaginateRecursive(pager);
        }

        private void BuildContents()
        {
            if (!_haveContent)
            {
                _haveContent = true;
                String text = Text;

                if (text.Length > 0)
                {
                    TextViewLiteralTextParser parser = new TextViewLiteralTextParser(this);
                    parser.Parse(text);
                }
            }
        }

        internal override bool AllowMultiLines
        {
            get
            {
                return true;
            }
        }

        internal override bool AllowInnerMarkup
        {
            get
            {
                return true;
            }
        }

        internal override bool TrimInnerText
        {
            get
            {
                return false;
            }
        }

        private class TextViewLiteralTextParser : LiteralTextParser
        {
            TextView _parent;
            bool _hasElements = false;

            public TextViewLiteralTextParser(TextView parent)
            {
                _parent = parent;
            }

            protected override void ProcessElement(LiteralElement element)
            {
                String text = element.Text != null ? element.Text : String.Empty;
                String href = null;

                if(element.Type == LiteralElementType.Anchor) {
                    href = element.GetAttribute("href");
                }
                _parent.AddElement(text,
                           href,
                           ((element.Format & LiteralFormat.Bold) == LiteralFormat.Bold),
                           ((element.Format & LiteralFormat.Italic) == LiteralFormat.Italic),
                           element.BreakAfter);
                _hasElements = true;
            }

            protected override void ProcessTagInnerText(String text)
            {
                Debug.Assert(false);
            }

            protected override bool IgnoreWhiteSpaceElement(LiteralElement element)
            {
                return !_hasElements;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlcommandadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlCommandAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * ChtmlCommandAdapter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlCommandAdapter : HtmlCommandAdapter
    {
        public override bool RequiresFormTag
        {
            get
            {
                return true;
            }
        }

        protected override void AddAttributes(HtmlMobileTextWriter writer)
        {
            AddAccesskeyAttribute(writer);
            AddJPhoneMultiMediaAttributes(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlcalendaradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlCalendarAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Web.UI.WebControls;
using System.Diagnostics;
using System.Collections;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{
    /*
     * ChtmlCalendarAdapter provides the cHTML device functionality for Calendar
     * control.  It is using secondary UI support to provide internal screens
     * to allow the user to pick or enter a date.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlCalendarAdapter : HtmlControlAdapter
    {
        private SelectionList _selectList;
        private TextBox _textBox;
        private Command _command;
        private List _optionList;
        private List _monthList;
        private List _weekList;
        private List _dayList;
        private int _chooseOption = FirstPrompt;
        private int _monthsToDisplay;
        private int _eraCount = 0;
        private bool _requireFormTag = false;

        /////////////////////////////////////////////////////////////////////
        // Globalization of Calendar Information:
        // Similar to the globalization support of the ASP.NET Calendar control,
        // this support is done via COM+ thread culture info/object.
        // Specific example can be found from ASP.NET Calendar spec.
        /////////////////////////////////////////////////////////////////////

        // This member variable is set each time when calendar info needs to
        // be accessed and be shared for other helper functions.
        private Globalization.Calendar _threadCalendar;

        private String _textBoxErrorMessage;

        // Since SecondaryUIMode is an int type, we use constant integers here
        // instead of enum so the mode can be compared without casting.
        private const int FirstPrompt = NotSecondaryUIInit;
        private const int OptionPrompt = NotSecondaryUIInit + 1;
        private const int TypeDate = NotSecondaryUIInit + 2;
        private const int DateOption = NotSecondaryUIInit + 3;
        private const int WeekOption = NotSecondaryUIInit + 4;
        private const int MonthOption = NotSecondaryUIInit + 5;
        private const int ChooseMonth = NotSecondaryUIInit + 6;
        private const int ChooseWeek = NotSecondaryUIInit + 7;
        private const int ChooseDay = NotSecondaryUIInit + 8;
        private const int DefaultDateDone = NotSecondaryUIInit + 9;
        private const int TypeDateDone = NotSecondaryUIInit + 10;
        private const int Done = NotSecondaryUIInit + 11;

        private const String DaySeparator = " - ";
        private const String Space = " ";

        protected new Calendar Control
        {
            get
            {
                return (Calendar)base.Control;
            }
        }

        public override bool RequiresFormTag
        {
            get
            {
                return _requireFormTag;
            }
        }

        public override void OnInit(EventArgs e)
        {
            ListCommandEventHandler listCommandEventHandler;

            // Create secondary child controls for rendering secondary UI.
            // Note that their ViewState is disabled because they are used
            // for rendering only.
            //---------------------------------------------------------------

            _selectList = new SelectionList();
            _selectList.Visible = false;
            _selectList.EnableViewState = false;
            Control.Controls.Add(_selectList);

            _textBox = new TextBox();
            _textBox.Visible = false;
            _textBox.EnableViewState = false;
            EventHandler eventHandler = new EventHandler(this.TextBoxEventHandler);
            _textBox.TextChanged += eventHandler;
            Control.Controls.Add(_textBox);

            _command = new Command();
            _command.Visible = false;
            _command.EnableViewState = false;
            Control.Controls.Add(_command);

            // Below are initialization of several list controls.  A note is
            // that here the usage of DataMember is solely for remembering
            // how many items a particular list control is bounded to.  The
            // property is not used as originally designed.
            //---------------------------------------------------------------

            _optionList = new List();
            _optionList.DataMember = "5";
            listCommandEventHandler = new ListCommandEventHandler(this.OptionListEventHandler);
            InitList(_optionList, listCommandEventHandler);

            // Use MobileCapabilities to check screen size and determine how
            // many months should be displayed for different devices.
            _monthsToDisplay = MonthsToDisplay(Device.ScreenCharactersHeight);

            // Create the list of months, including [Next] and [Prev] links
            _monthList = new List();
            _monthList.DataMember = Convert.ToString(_monthsToDisplay + 2);
            listCommandEventHandler = new ListCommandEventHandler(this.MonthListEventHandler);
            InitList(_monthList, listCommandEventHandler);

            _weekList = new List();
            _weekList.DataMember = "6";
            listCommandEventHandler = new ListCommandEventHandler(this.WeekListEventHandler);
            InitList(_weekList, listCommandEventHandler);

            _dayList = new List();
            _dayList.DataMember = "7";
            listCommandEventHandler = new ListCommandEventHandler(this.DayListEventHandler);
            InitList(_dayList, listCommandEventHandler);

            // Initialize the VisibleDate which will be used to keep track
            // the ongoing selection of year, month and day from multiple
            // secondary UI screens.  If the page is loaded for the first
            // time, it doesn't need to be initialized (since it is not used
            // yet) so no unnecessary viewstate value will be generated.
            if (Page.IsPostBack && Control.VisibleDate == DateTime.MinValue)
            {
                Control.VisibleDate = DateTime.Today;
            }
        }

        public override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            // Here we check to see which list control should be initialized
            // with items so postback event can be handled properly.
            if (Page.IsPostBack)
            {
                String controlId = Page.Request[Constants.EventSourceID];
                if (controlId != null && controlId.Length != 0)
                {
                    List list = Page.FindControl(controlId) as List;
                    if (list != null &&
                        Control.Controls.Contains(list))
                    {
                        DataBindListWithEmptyValues(
                            list, Convert.ToInt32(list.DataMember));
                    }
                }
            }
        }

        public override void LoadAdapterState(Object state)
        {
            if (state != null)
            {
                if (state is Pair)
                {
                    Pair pair = (Pair)state;
                    base.LoadAdapterState(pair.First);
                    _chooseOption = (int)pair.Second;
                }
                else if (state is Triplet)
                {
                    Triplet triplet = (Triplet)state;
                    base.LoadAdapterState(triplet.First);
                    _chooseOption = (int)triplet.Second;
                    Control.VisibleDate = new DateTime(Int64.Parse((String)triplet.Third));
                }
                else if (state is Object[])
                {
                    Object[] viewState = (Object[])state;
                    base.LoadAdapterState(viewState[0]);
                    _chooseOption = (int)viewState[1];
                    Control.VisibleDate = new DateTime(Int64.Parse((String)viewState[2]));
                    _eraCount = (int)viewState[3];

                    if (SecondaryUIMode == TypeDate)
                    {
                        // Create a placeholder list for capturing the selected era
                        // in postback data.
                        for (int i = 0; i < _eraCount; i++)
                        {
                            _selectList.Items.Add(String.Empty);
                        }
                    }
                }
                else
                {
                    _chooseOption = (int)state;
                }
            }
        }

        public override Object SaveAdapterState()
        {
            DateTime visibleDate = Control.VisibleDate;

            bool saveVisibleDate = visibleDate != DateTime.MinValue &&
                                        DateTime.Compare(visibleDate, DateTime.Today) != 0 && 
                                        !IsViewStateEnabled();
            Object baseState = base.SaveAdapterState();

            if (baseState == null && !saveVisibleDate && _eraCount == 0)
            {
                if (_chooseOption != FirstPrompt)
                {
                    return _chooseOption;
                }
                else
                {
                    return null;
                }
            }
            else if (!saveVisibleDate && _eraCount == 0)
            {
                return new Pair(baseState, _chooseOption);
            }
            else if (_eraCount == 0)
            {
                return new Triplet(baseState, _chooseOption, visibleDate.Ticks.ToString());
            }
            else
            {
                return new Object[] { baseState,
                                      _chooseOption,
                                      visibleDate.Ticks.ToString(),
                                      _eraCount };
            }
        }

        public override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);

            // We specially binding eras of the current calendar object here
            // when the UI of typing date is display.  We do it only if the
            // calendar supports more than one era.
            if (SecondaryUIMode == TypeDate)
            {
                DateTimeFormatInfo currentInfo = DateTimeFormatInfo.CurrentInfo;

                int [] ints = currentInfo.Calendar.Eras;

                if (ints.Length > 1)
                {
                    // Save the value in private view state
                    _eraCount = ints.Length;

                    int currentEra;
                    if (_selectList.SelectedIndex != -1)
                    {
                        currentEra = ints[_selectList.SelectedIndex];
                    }
                    else
                    {
                        currentEra =
                            currentInfo.Calendar.GetEra(Control.VisibleDate);
                    }

                    // Clear the placeholder item list if created in LoadAdapterState
                    _selectList.Items.Clear();

                    for (int i = 0; i < ints.Length; i++)
                    {
                        int era = ints[i];

                        _selectList.Items.Add(currentInfo.GetEraName(era));

                        // There is no association between the era value and
                        // its index in the era array, so we need to check it
                        // explicitly for the default selected index.
                        if (currentEra == era)
                        {
                            _selectList.SelectedIndex = i;
                        }
                    }
                    _selectList.Visible = true;
                }
                else
                {
                    // disable viewstate since no need to save any data for
                    // this control
                    _selectList.EnableViewState = false;
                }
            }
            else
            {
                _selectList.EnableViewState = false;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            ArrayList arr;
            DateTime tempDate;
            DateTimeFormatInfo currentDateTimeInfo = DateTimeFormatInfo.CurrentInfo;
            String abbreviatedMonthDayPattern = AbbreviateMonthPattern(currentDateTimeInfo.MonthDayPattern);
            _threadCalendar = currentDateTimeInfo.Calendar;
            bool breakAfter = false;

            writer.EnterStyle(Style);

            Debug.Assert(NotSecondaryUI == NotSecondaryUIInit);
            switch (SecondaryUIMode)
            {
                case FirstPrompt:
                    String promptText = Control.CalendarEntryText;
                    if (promptText == String.Empty)
                    {
                        promptText = SR.GetString(SR.CalendarAdapterFirstPrompt);
                    }

                    // Link to input option selection screen
                    RenderPostBackEventAsAnchor(writer,
                                                OptionPrompt.ToString(),
                                                promptText);

                    // We should honor BreakAfter property here as the first
                    // UI is shown with other controls on the same form.
                    // For other secondary UI, it is not necessary.
                    if (Control.BreakAfter)
                    {
                        breakAfter = true;
                    }
                    break;

                // Render the first secondary page that provides differnt
                // options to select a date.
                case OptionPrompt:
                    writer.Write(SR.GetString(SR.CalendarAdapterOptionPrompt));
                    writer.WriteBreak();

                    arr = new ArrayList();

                    // Option to select the default date
                    arr.Add(Control.VisibleDate.ToString(
                        currentDateTimeInfo.ShortDatePattern));

                    // Option to another page that can enter a date by typing
                    arr.Add(SR.GetString(SR.CalendarAdapterOptionType));

                    // Options to a set of pages for selecting a date, a week
                    // or a month by picking month/year, week and day
                    // accordingly.  Available options are determined by
                    // SelectionMode.
                    arr.Add(SR.GetString(SR.CalendarAdapterOptionChooseDate));

                    if (Control.SelectionMode == CalendarSelectionMode.DayWeek ||
                        Control.SelectionMode == CalendarSelectionMode.DayWeekMonth)
                    {
                        arr.Add(SR.GetString(SR.CalendarAdapterOptionChooseWeek));

                        if (Control.SelectionMode == CalendarSelectionMode.DayWeekMonth)
                        {
                            arr.Add(SR.GetString(SR.CalendarAdapterOptionChooseMonth));
                        }
                    }

                    DataBindAndRender(writer, _optionList, arr);
                    break;

                // Render a title and textbox to capture a date entered by user
                case TypeDate:
                    if (_textBoxErrorMessage != null)
                    {
                        writer.Write(_textBoxErrorMessage);
                        writer.WriteBreak();
                    }

                    if (_selectList.Visible)
                    {
                        writer.Write(SR.GetString(SR.CalendarAdapterOptionEra));
                        writer.WriteBreak();
                        _selectList.RenderControl(writer);
                    }

                    String numericDateFormat = GetNumericDateFormat();

                    writer.Write(SR.GetString(SR.CalendarAdapterOptionType));
                    writer.Write(":");
                    writer.WriteBreak();
                    writer.Write("(");
                    writer.Write(numericDateFormat.ToUpper());
                    writer.Write(")");

                    if (!_selectList.Visible)
                    {
                        writer.Write(GetEra(Control.VisibleDate));
                    }
                    writer.WriteBreak();

                    _textBox.Numeric = true;
                    _textBox.Size = numericDateFormat.Length;
                    _textBox.MaxLength = numericDateFormat.Length;
                    _textBox.Text = Control.VisibleDate.ToString(numericDateFormat);
                    _textBox.Visible = true;
                    _textBox.RenderControl(writer);

                    // Command button for sending the textbox value back to the server
                    _command.Text = GetDefaultLabel(OKLabel);
                    _command.Visible = true;
                    _command.RenderControl(writer);

                    break;

                // Render a paged list for choosing a month
                case ChooseMonth:
                    writer.Write(SR.GetString(SR.CalendarAdapterOptionChooseMonth));
                    writer.Write(":");
                    writer.WriteBreak();

                    tempDate = Control.VisibleDate;

                    String abbreviatedYearMonthPattern = AbbreviateMonthPattern(currentDateTimeInfo.YearMonthPattern);

                    // This is to be consistent with ASP.NET Calendar control
                    // on handling YearMonthPattern:
                    // Some cultures have a comma in their YearMonthPattern,
                    // which does not look right in a calendar.  Here we
                    // strip the comma off.
                    int indexComma = abbreviatedYearMonthPattern.IndexOf(',');
                    if (indexComma >= 0)
                    {
                        abbreviatedYearMonthPattern =
                            abbreviatedYearMonthPattern.Remove(indexComma, 1);
                    }

                    arr = new ArrayList();
                    for (int i = 0; i < _monthsToDisplay; i++)
                    {
                        arr.Add(tempDate.ToString(abbreviatedYearMonthPattern));
                        tempDate = _threadCalendar.AddMonths(tempDate, 1);
                    }
                    arr.Add(GetDefaultLabel(NextLabel));
                    arr.Add(GetDefaultLabel(PreviousLabel));

                    DataBindAndRender(writer, _monthList, arr);
                    break;

                // Based on the month selected in case ChooseMonth above, render a list of
                // availabe weeks of the month.
                case ChooseWeek:
                    String monthFormat = (GetNumericDateFormat()[0] == 'y') ? "yyyy/M" : "M/yyyy";
                    writer.Write(SR.GetString(SR.CalendarAdapterOptionChooseWeek));
                    writer.Write(" (");
                    writer.Write(Control.VisibleDate.ToString(monthFormat));
                    writer.Write("):");
                    writer.WriteBreak();

                    // List weeks of days of the selected month.  May include
                    // days from the previous and the next month to fill out
                    // all six week choices.  This is consistent with the
                    // ASP.NET Calendar control.

                    // Note that the event handling code of this list control
                    // should be implemented according to the index content
                    // generated here.

                    tempDate = FirstCalendarDay(Control.VisibleDate);

                    arr = new ArrayList();
                    String weekDisplay;
                    for (int i = 0; i < 6; i++)
                    {
                        weekDisplay = tempDate.ToString(abbreviatedMonthDayPattern);
                        weekDisplay += DaySeparator;
                        tempDate = _threadCalendar.AddDays(tempDate, 6);
                        weekDisplay += tempDate.ToString(abbreviatedMonthDayPattern);
                        arr.Add(weekDisplay);
                        tempDate = _threadCalendar.AddDays(tempDate, 1);
                    }

                    DataBindAndRender(writer, _weekList, arr);
                    break;

                // Based on the month and week selected in case ChooseMonth and ChooseWeek above,
                // render a list of the dates in the week.
                case ChooseDay:
                    writer.Write(SR.GetString(SR.CalendarAdapterOptionChooseDate));
                    writer.Write(":");
                    writer.WriteBreak();

                    tempDate = Control.VisibleDate;

                    arr = new ArrayList();
                    String date;
                    String dayName;
                    StringBuilder dayDisplay = new StringBuilder();
                    bool dayNameFirst = (GetNumericDateFormat()[0] != 'y');

                    for (int i = 0; i < 7; i++)
                    {
                        date = tempDate.ToString(abbreviatedMonthDayPattern);

                        if (Control.ShowDayHeader)
                        {
                            // Use the short format for displaying day name
                            dayName = GetAbbreviatedDayName(tempDate);
                            dayDisplay.Length = 0;

                            if (dayNameFirst)
                            {
                                dayDisplay.Append(dayName);
                                dayDisplay.Append(Space);
                                dayDisplay.Append(date);
                            }
                            else
                            {
                                dayDisplay.Append(date);
                                dayDisplay.Append(Space);
                                dayDisplay.Append(dayName);
                            }
                            arr.Add(dayDisplay.ToString());
                        }
                        else
                        {
                            arr.Add(date);
                        }
                        tempDate = _threadCalendar.AddDays(tempDate, 1);
                    }

                    DataBindAndRender(writer, _dayList, arr);
                                        break;

                default:
                    Debug.Assert(false, "Unexpected Secondary UI Mode");
                                        break;
            }

            writer.ExitStyle(Style, breakAfter);
        }

        public override bool HandlePostBackEvent(String eventArgument)
        {
            // This is mainly to capture the option picked by the user on
            // secondary pages and manipulate SecondaryUIMode accordingly so
            // Render() can generate the appropriate UI.
            // It also capture the state "Done" which can be set when a date,
            // a week or a month is selected or entered in some secondary
            // page.

            SecondaryUIMode = Int32.Parse(eventArgument);

            Debug.Assert(NotSecondaryUI == NotSecondaryUIInit);
            switch (SecondaryUIMode)
            {
            case DefaultDateDone:
                SelectRange(Control.VisibleDate, Control.VisibleDate);
                goto case Done;

            case TypeDate:
                _requireFormTag = true;
                break;

            case TypeDateDone:
                try
                {
                    String dateText = _textBox.Text;
                    String dateFormat = GetNumericDateFormat();
                    DateTimeFormatInfo currentInfo = DateTimeFormatInfo.CurrentInfo;
                    int eraIndex = _selectList.SelectedIndex;

                    if (eraIndex >= 0 &&
                        eraIndex < currentInfo.Calendar.Eras.Length)
                    {
                        dateText += currentInfo.GetEraName(currentInfo.Calendar.Eras[eraIndex]);
                        dateFormat += "gg";
                    }

                    DateTime dateTime = DateTime.ParseExact(dateText, dateFormat, null);
                    SelectRange(dateTime, dateTime);
                    Control.VisibleDate = dateTime;
                }
                catch
                {
                    _textBoxErrorMessage = SR.GetString(SR.CalendarAdapterTextBoxErrorMessage);
                    SecondaryUIMode = TypeDate;
                    goto case TypeDate;
                }
                goto case Done;

            case Done:
                // Set the secondary exit code and raise the selection event for
                // web page developer to manipulate the selected date.
                ExitSecondaryUIMode();
                _chooseOption = FirstPrompt;
                break;

            case DateOption:
            case WeekOption:
            case MonthOption:
                _chooseOption = SecondaryUIMode;  // save in the ViewState

                // In all 3 cases, continue to the UI that chooses a month
                SecondaryUIMode = ChooseMonth;
                break;
            }

            return true;
        }

        /////////////////////////////////////////////////////////////////////
        // Misc. helper and wrapper functions
        /////////////////////////////////////////////////////////////////////

        private int MonthsToDisplay(int screenCharactersHeight)
        {
            const int MinMonthsToDisplay = 4;
            const int MaxMonthsToDisplay = 12;

            if (screenCharactersHeight < MinMonthsToDisplay)
            {
                return MinMonthsToDisplay;
            }
            else if (screenCharactersHeight > MaxMonthsToDisplay)
            {
                return MaxMonthsToDisplay;
            }
            return screenCharactersHeight;
        }

        // A helper function to initialize and add a child list control
        private void InitList(List list,
                              ListCommandEventHandler eventHandler)
        {
            list.Visible = false;
            list.ItemCommand += eventHandler;
            list.EnableViewState = false;
            Control.Controls.Add(list);
        }

        private void DataBindListWithEmptyValues(List list, int arraySize)
        {
            ArrayList arr = new ArrayList();
            for (int i = 0; i < arraySize; i++)
            {
                arr.Add("");
            }
            list.DataSource = arr;
            list.DataBind();
        }

        // A helper function to do the common code for DataBind and
        // RenderChildren.
        private void DataBindAndRender(HtmlMobileTextWriter writer,
                                       List list,
                                       ArrayList arr)
        {
            list.DataSource = arr;
            list.DataBind();
            list.Visible = true;
            list.RenderControl(writer);
        }

        // Abbreviate the Month format from "MMMM" (full
        // month name) to "MMM" (three-character month abbreviation)
        private String AbbreviateMonthPattern(String pattern)
        {
            const String FullMonthFormat = "MMMM";

            int i = pattern.IndexOf(FullMonthFormat);
            if (i != -1)
            {
                pattern = pattern.Remove(i, 1);
            }
            return pattern;
        }

        private String GetAbbreviatedDayName(DateTime dateTime)
        {
            return DateTimeFormatInfo.CurrentInfo.GetAbbreviatedDayName(
                        _threadCalendar.GetDayOfWeek(dateTime));
        }

        private String GetEra(DateTime dateTime)
        {
            // We shouldn't need to display the era for the common Gregorian
            // Calendar
            if (DateTimeFormatInfo.CurrentInfo.Calendar.GetType() ==
                typeof(GregorianCalendar))
            {
                return String.Empty;
            }
            else
            {
                return dateTime.ToString("gg");
            }
        }

        private static readonly char[] formatChars =
                                            new char[] { 'M', 'd', 'y' };

        private String GetNumericDateFormat()
        {
            String shortDatePattern =
                DateTimeFormatInfo.CurrentInfo.ShortDatePattern;

            // Guess on what short date pattern should be used
            int i = shortDatePattern.IndexOfAny(formatChars);

            char firstFormatChar;
            if (i == -1)
            {
                firstFormatChar = 'M';
            }
            else
            {
                firstFormatChar = shortDatePattern[i];
            }

            // We either use two or four digits for the year
            String yearPattern;
            if (shortDatePattern.IndexOf("yyyy") == -1)
            {
                yearPattern = "yy";
            }
            else
            {
                yearPattern = "yyyy";
            }

            switch (firstFormatChar)
            {
            case 'M':
            default:
                return "MMdd" + yearPattern;
            case 'd':
                return "ddMM" + yearPattern;
            case 'y':
                return yearPattern + "MMdd";
            }
        }

        /////////////////////////////////////////////////////////////////////
        // Helper functions
        /////////////////////////////////////////////////////////////////////

        // Return the first date of the input year and month
        private DateTime EffectiveVisibleDate(DateTime visibleDate)
        {
            return _threadCalendar.AddDays(
                        visibleDate,
                        -(_threadCalendar.GetDayOfMonth(visibleDate) - 1));
        }

        // Return the beginning date of a calendar that includes the
        // targeting month.  The date can actually be in the previous month.
        private DateTime FirstCalendarDay(DateTime visibleDate)
        {
            DateTime firstDayOfMonth = EffectiveVisibleDate(visibleDate);
            int daysFromLastMonth =
                ((int)_threadCalendar.GetDayOfWeek(firstDayOfMonth)) -
                NumericFirstDayOfWeek();

            // Always display at least one day from the previous month
            if (daysFromLastMonth <= 0)
            {
                daysFromLastMonth += 7;
            }
            return _threadCalendar.AddDays(firstDayOfMonth, -daysFromLastMonth);
        }

        private int NumericFirstDayOfWeek()
        {
            // Used globalized value by default
            return(Control.FirstDayOfWeek == FirstDayOfWeek.Default)
            ? (int) DateTimeFormatInfo.CurrentInfo.FirstDayOfWeek
            : (int) Control.FirstDayOfWeek;
        }

        /////////////////////////////////////////////////////////////////////
        // The followings are event handlers to capture the selection from
        // the corresponding list control in an secondary page.  The index of
        // the selection is used to determine which and how the next
        // secondary page is rendered.  Some event handlers below update
        // Calendar.VisibleDate and set SecondaryUIMode with appropriate
        // values.
        ////////////////////////////////////////////////////////////////////////

        private void TextBoxEventHandler(Object source, EventArgs e)
        {
            HandlePostBackEvent(TypeDateDone.ToString());
        }

        private static readonly int[] Options =
            {DefaultDateDone, TypeDate, DateOption, WeekOption, MonthOption};

        private void OptionListEventHandler(Object source, ListCommandEventArgs e)
        {
            SecondaryUIMode = Options[e.ListItem.Index];
            HandlePostBackEvent(SecondaryUIMode.ToString());
        }

        private void MonthListEventHandler(Object source, ListCommandEventArgs e)
        {
            _threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;

            if (e.ListItem.Index == _monthsToDisplay)
            {
                // Next was selected
                Control.VisibleDate = _threadCalendar.AddMonths(
                                        Control.VisibleDate, _monthsToDisplay);
                SecondaryUIMode = ChooseMonth;
            }
            else if (e.ListItem.Index == _monthsToDisplay + 1)
            {
                // Prev was selected
                Control.VisibleDate = _threadCalendar.AddMonths(
                                        Control.VisibleDate, -_monthsToDisplay);
                SecondaryUIMode = ChooseMonth;
            }
            else
            {
                // A month was selected
                Control.VisibleDate = _threadCalendar.AddMonths(
                                        Control.VisibleDate,
                                        e.ListItem.Index);

                if (_chooseOption == MonthOption)
                {
                    // Add the whole month to the date list
                    DateTime beginDate = EffectiveVisibleDate(Control.VisibleDate);
                    Control.VisibleDate = beginDate;

                    DateTime endDate = _threadCalendar.AddMonths(beginDate, 1);
                    endDate = _threadCalendar.AddDays(endDate, -1);

                    SelectRange(beginDate, endDate);
                    HandlePostBackEvent(Done.ToString());
                }
                else
                {
                    SecondaryUIMode = ChooseWeek;
                }
            }
        }

        private void WeekListEventHandler(Object source, ListCommandEventArgs e)
        {
            // Get the first calendar day and adjust it to the week the user
            // selected (to be consistent with the index setting in Render())
            _threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;

            DateTime tempDate = FirstCalendarDay(Control.VisibleDate);

            Control.VisibleDate = _threadCalendar.AddDays(tempDate, e.ListItem.Index * 7);

            if (_chooseOption == WeekOption)
            {
                // Add the whole week to the date list
                DateTime endDate = _threadCalendar.AddDays(Control.VisibleDate, 6);

                SelectRange(Control.VisibleDate, endDate);
                HandlePostBackEvent(Done.ToString());
            }
            else
            {
                SecondaryUIMode = ChooseDay;
            }
        }

        private void DayListEventHandler(Object source, ListCommandEventArgs e)
        {
            _threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;

            // VisibleDate should have been set with the first day of the week
            // so the selected index can be used to adjust to the selected day.
            Control.VisibleDate = _threadCalendar.AddDays(Control.VisibleDate, e.ListItem.Index);

            SelectRange(Control.VisibleDate, Control.VisibleDate);
            HandlePostBackEvent(Done.ToString());
        }

        private void SelectRange(DateTime dateFrom, DateTime dateTo)
        {
            Debug.Assert(dateFrom <= dateTo, "Bad Date Range");

            // see if this range differs in any way from the current range
            // these checks will determine this because the colleciton is sorted
            TimeSpan ts = dateTo - dateFrom;
            SelectedDatesCollection selectedDates = Control.SelectedDates;
            if (selectedDates.Count != ts.Days + 1 
                || selectedDates[0] != dateFrom
                || selectedDates[selectedDates.Count - 1] != dateTo)
            {
                selectedDates.SelectRange(dateFrom, dateTo);
                Control.RaiseSelectionChangedEvent();
            }
        }

        private bool IsViewStateEnabled()
        {
            Control ctl = Control;
            while (ctl != null)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
                ctl = ctl.Parent;
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlimageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlImageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * ChtmlImageAdapter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlImageAdapter : HtmlImageAdapter
    {
        protected internal override void RenderImage(HtmlMobileTextWriter writer)
        {
            String source = Control.ImageUrl;

            if (source.StartsWith(Constants.SymbolProtocol) &&
                (Device.SupportsIModeSymbols || Device.SupportsJPhoneSymbols))
            {
                if (Device.SupportsIModeSymbols)
                {
                    writer.Write("&#");
                    writer.Write(
                        source.Substring(Constants.SymbolProtocol.Length));
                    writer.Write(";");
                }
                else
                {
                    // The ImageUrl should be in the format "symbol:xyyy",
                    // where x is group picture character (either G, E or F),
                    // and yyy (length can vary) is the picture's character
                    // code (in decimal).
                    String symbolChars = source.Substring(
                                            Constants.SymbolProtocol.Length);
                    char code = DecimalStringToChar(symbolChars.Substring(1));

                    writer.Write("\u001B$");
                    writer.Write(Char.ToUpper(symbolChars[0]));
                    writer.Write(code);
                    writer.Write('\u000F');
                }
            }
            else
            {
                base.RenderImage(writer);
            }
        }

        // Convert decimal string "xxx" to '\u00xx'
        private char DecimalStringToChar(String decimalString)
        {
            int codeValue = 0;
            int adj = 1;

            for (int i = decimalString.Length - 1; i >= 0; i--)
            {
                codeValue += DecimalCharToInt(decimalString[i]) * adj;
                adj *= 10;
            }

            return (char) codeValue;
        }

        // Convert decimal char 'x' to decimal integer value x
        private int DecimalCharToInt(char decimalChar)
        {
            int i;

            if (decimalChar >= '0' && decimalChar <= '9')
            {
                i = decimalChar - '0';
            }
            else
            {
                throw new ArgumentException(
                    SR.GetString(SR.ChtmlImageAdapterDecimalCodeExpectedAfterGroupChar),
                    "ImageUrl");
            }

            return i;
        }

        protected override void AddAttributes(HtmlMobileTextWriter writer)
        {
            AddAccesskeyAttribute(writer);
            AddJPhoneMultiMediaAttributes(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlpageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlPageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Web.Mobile;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * ChtmlPageAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlPageAdapter : HtmlPageAdapter
    {
        private const int DefaultPageWeight = 800;
        private const String _postedFromOtherFile = ".";

        public ChtmlPageAdapter() : base(DefaultPageWeight)
        {
        }

        /////////////////////////////////////////////////////////////////////
        //  Static method used for determining if device should use
        //  this adapter
        /////////////////////////////////////////////////////////////////////

        public new static bool DeviceQualifies(HttpContext context)
        {
            String type = ((MobileCapabilities)context.Request.Browser).PreferredRenderingType;
            bool javascriptSupported = context.Request.Browser.JavaScript;
            bool qualifies = (type == MobileCapabilities.PreferredRenderingTypeHtml32 ||
                              type == MobileCapabilities.PreferredRenderingTypeChtml10)
                             && !javascriptSupported;
            return qualifies;
        }
        
        /////////////////////////////////////////////////////////////////////
        //  IControlAdapter implementation
        /////////////////////////////////////////////////////////////////////

        public override void RenderPostBackEvent(HtmlMobileTextWriter writer, 
                                                String target, 
                                                String argument)
        {
            // Since it doesn't have scripts, the CHTML adapter
            // only supports URL postback events.

            RenderUrlPostBackEvent(writer, target, argument);
        }

        protected override String EventSourceKey
        {
            get
            {
                return Constants.EventSourceID;
            }
        }

        protected override String EventArgumentKey
        {
            get
            {
                return Constants.EventArgumentID;
            }
        }

        public override void RenderPostBackHeader(HtmlMobileTextWriter writer, Form form)
        {
            bool postBack = form.Action.Length == 0;

            RenderPageState(writer);
            if (!postBack)
            {
                writer.WriteHiddenField(EventSourceKey, _postedFromOtherFile);
            }
            else if (Page.ClientViewState == null)
            {
                // The empty event source variable is used to identify a
                // postback request
                writer.WriteHiddenField(EventSourceKey, String.Empty);
            }

            RenderHiddenVariables(writer);
        }

        /////////////////////////////////////////////////////////////////////
        //  IPageAdapter implementation
        /////////////////////////////////////////////////////////////////////

        // ==================================================================
        // For browser that doesn't support javascript, like cHTML browser,
        // control id and its corresponding value are specially encoded in
        // the post back data collection.  This method is to extract the
        // encoded info and put the info back to the collection in an
        // expected format that is understood by ASP.NET Frameworks so post
        // back event is raised correctly.
        // Note other control adapters should do the encoding accordinly so
        // the data can be decoded properly here.
        //
        public override NameValueCollection DeterminePostBackMode
        (
            HttpRequest request,
            String postEventSourceID,
            String postEventArgumentID,
            NameValueCollection baseCollection
        )
        {
            if (baseCollection != null && baseCollection[EventSourceKey] == _postedFromOtherFile)
            {
                return null;
            }
            else if (request == null)
            {
                return baseCollection;
            }
            else if (String.Compare(request.HttpMethod, "POST", true, CultureInfo.InvariantCulture) == 0)
            {
                return CollectionFromForm(request.Form,
                                          postEventSourceID,
                                          postEventArgumentID);
            }
            else if (request.QueryString.Count == 0)
            {
                return baseCollection;
            }
            else
            {
                return CollectionFromQueryString(request.QueryString,
                                                 postEventSourceID,
                                                 postEventArgumentID);
            }
        }

        public override HtmlTextWriter CreateTextWriter(TextWriter writer)
        {
            return new ChtmlMobileTextWriter(writer, Device);
        }

        private NameValueCollection CollectionFromQueryString(
            NameValueCollection queryString,
            String postEventSourceID,
            String postEventArgumentID)
        {
            NameValueCollection collection = new NameValueCollection();
            bool isPostBack = false;

            for (int i = 0; i < queryString.Count; i++)
            {
                String name = queryString.GetKey(i);

                // Supposingly, we should double check if the control id
                // is real or not by checking against the control tree.
                // However, the tree can't be checked because it hasn't
                // been built at this stage.  And this is the only place
                // we can override the value collection.  We just need to
                // assume the control adapters are setting the id and
                // value accordingly.

                // ASSUMPTION: In query string, besides the expected
                // name/value pairs (ViewStateID, EventSource and
                // EventArgument), there are hidden variables, control
                // id/value pairs (if the form submit method is GET), unique
                // file path suffix variable and custom query string text.
                // They will be in the above order if any of them present.
                // Hidden variables and control id/value pairs should be added
                // back to the collection intactly, but the other 2 items
                // should not be added to the collection.

                // name can be null if there is a query name without equal
                // sign appended.  We should just ignored it in this case.
                if (name == null)
                {
                    continue;
                }
                else if (name == MobilePage.ViewStateID)
                {
                    collection.Add(MobilePage.ViewStateID, queryString.Get(i));
                    isPostBack = true;
                }
                else if (name == Constants.EventSourceID)
                {
                    collection.Add(postEventSourceID, queryString.Get(i));
                    isPostBack = true;
                }
                else if (name == Constants.EventArgumentID)
                {
                    collection.Add(postEventArgumentID, queryString.Get(i));
                }
                else if (Constants.UniqueFilePathSuffixVariable.StartsWith(name))
                {
                    // At this point we know that the rest of them is
                    // the custom query string text, so we are done.
                    break;
                }
                else
                {
                    AddValues(queryString, name, collection);
                }
            }

            if (collection.Count == 0 || !isPostBack)
            {
                // Returning null to indicate this is not a postback
                return null;
            }
            else
            {
                return collection;
            }
        }

        // ==================================================================
        // The complexity (multiple if statements) of this method is due to
        // workarounds for different targeted devices and limitation on non-
        // javascript html browser.
        //
        private NameValueCollection CollectionFromForm(
            NameValueCollection form,
            String postEventSourceID,
            String postEventArgumentID)
        {
            int i;
            int count = form.Count;
            NameValueCollection collection = new NameValueCollection();
            bool isPostBack = false;

            // continue statements are used below to simplify the logic and
            // make people easier to follow and maintain the code.
            for (i = 0; i < count; i++)
            {
                String name = form.GetKey(i);

                // 1. Some browser returns the name of a password textbox
                // only without the expected character "=" if the textbox is
                // empty.  This causes the key to be null and the name to be
                // the value of the collection item when the returned form
                // content is parsed in HttpValueCollection.  In this case,
                // we need to reverse the setting with the value as the name
                // and empty string as the value so subsequent manipulations
                // of the collection work correctly.
                if (name == null)
                {
                    AddEmptyStringValues(form.GetValues(i), collection);
                    continue;
                }

                // 2. Pager navigation is rendered by buttons which have the
                // targeted page number appended to the form id after
                // PagePrefix which is a constant string to identify this
                // special case.  E.g. ControlID__PG_2
                int index = name.LastIndexOf(Constants.PagePrefix);
                if (index != -1)
                {
                    // We need to associate the form id with the event source
                    // id and the page number with the event argument id in
                    // order to have the event raised properly by ASP.NET
                    int pageBeginPos = index + Constants.PagePrefix.Length;
                    collection.Add(postEventSourceID,
                                   name.Substring(0, index));
                    collection.Add(postEventArgumentID,
                                   name.Substring(pageBeginPos,
                                              name.Length - pageBeginPos));
                    continue;
                }

                // 3. This special case happens when A. SelectionList control is
                // with property SelectType equal to CheckBox or
                // MultiSelectListBox, and the device itself doesn't handle
                // multiple check boxes correctly. or B. Browser requires the
                // ID of the input element to be unique during postbacks.
                //
                // In this case, the control (SelectionList or TextBox) adapter 
                // appended special characters as a suffix of the actual control
                // id. That should be stripped off when detected.
                if (Device.RequiresUniqueHtmlCheckboxNames ||
                    Device.RequiresUniqueHtmlInputNames)
                {
                    index = name.LastIndexOf(
                        Constants.SelectionListSpecialCharacter);

                    if (index != -1)
                    {
                        String value = form.Get(i);
                        if (value != null && value != String.Empty)
                        {
                            if(Device.RequiresAttributeColonSubstitution)
                            {
                                collection.Add(name.Substring(0, index).Replace(',',':'), value);
                            }
                            else
                            {
                                collection.Add(name.Substring(0, index), value);
                            }
                            continue;
                        }
                    }
                }

                // 4. This is to determine if the request is a postback from
                // the same mobile page.
                if (name == MobilePage.ViewStateID ||
                    name == EventSourceKey)
                {
                    isPostBack = true;
                }

                // Default case, just preserve the value(s)
                AddValues(form, name, collection);
            }

            if (collection.Count == 0 || !isPostBack)
            {
                // Returning null to indicate this is not a postback
                return null;
            }
            else
            {
                return collection;
            }
        }

        // Helper function to add empty string as value for the keys
        private void AddEmptyStringValues(String [] keys,
                                        NameValueCollection targetCollection)
        {
            foreach (String key in keys)
            {
                targetCollection.Add(key, String.Empty);
            }
        }

        // Helper function to add multiple values for the same key
        private void AddValues(NameValueCollection sourceCollection,
                               String sourceKey,
                               NameValueCollection targetCollection)
        {
            String [] values = sourceCollection.GetValues(sourceKey);
            foreach (String value in values)
            {
                if(Device.RequiresAttributeColonSubstitution)
                {
                    targetCollection.Add(sourceKey.Replace(',',':'), value);
                }
                else
                {
                    targetCollection.Add(sourceKey, value);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmllinkadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlLinkAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * ChtmlLinkAdapter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlLinkAdapter : HtmlLinkAdapter
    {
        protected override void AddAttributes(HtmlMobileTextWriter writer)
        {
            AddAccesskeyAttribute(writer);
            AddJPhoneMultiMediaAttributes(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlformadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlFormAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{
    /*
     * ChtmlFormAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlFormAdapter : HtmlFormAdapter
    {
        private static String _contentTypeMetaTag = "<meta http-equiv=\"Content-Type\" content=\"{0}; charset={1}\">\r\n";
        
        protected override bool ShouldRenderFormTag()
        {
            if (!Device.RequiresOutputOptimization || Control.PageCount > 1)
            {
                return true;
            }

            return IsFormTagNeeded(Control);
        }

        // Recursive method to check if there is any descendant control
        // requires the form tag.  For unknown cases, the method returns true
        // in case the unknown rendering requires the form tag.
        private bool IsFormTagNeeded(Control control)
        {
            // Check itself first
            if (!control.Visible)
            {
                return false;
            }

            MobileControl mobileControl = control as MobileControl;
            if (mobileControl != null)
            {
                // Since we don't have control over what content is included
                // in the template, to be safe we just generate the form tag.
                if (mobileControl.IsTemplated)
                {
                    return true;
                }

                HtmlControlAdapter adapter = mobileControl.Adapter as HtmlControlAdapter;
                if (adapter != null && adapter.RequiresFormTag)
                {
                    return true;
                }
            }
            else if (!(control is UserControl) &&
                     !(control is LiteralControl))
            {
                // UserControl simply acts as a container, so the checking
                // should be delegated to its children below.
                // LiteralControl is a plain text control.  Also, it is
                // generated for the spaces in between mobile control tags so
                // we don't want to consider it as a form required control.
                // For other cases, we should generate form tag as we don't
                // know the content that will be generated.
                return true;
            }

            // No problem with the current control so far, now recursively
            // check its children.
            if (control.HasControls())
            {
                foreach (Control child in control.Controls)
                {
                    if (IsFormTagNeeded(child))
                    {
                        // This is to get out of recursive loop without
                        // further checking on other controls.
                        return true;
                    }
                }
            }

            return false;
        }

        protected override bool RenderExtraHeadElements(HtmlMobileTextWriter writer)
        {
            bool result = false;
            
            String metaTagName = Device.RequiredMetaTagNameValue;
            if (metaTagName != null)
            {
                if (writer != null)
                {
                    writer.Write("<meta NAME=\"" + metaTagName + "\" CONTENT=\"True\">\r\n");
                }
                result = true;
            }

            String charset = Page.Response.Charset;
            if (Device.RequiresContentTypeMetaTag &&
                charset != null && charset.Length > 0)
            {
                if (writer != null)
                {
                    writer.Write(String.Format(_contentTypeMetaTag, Device.PreferredRenderingMime, charset));
                }
                result = true;
            }

            return result;
        }

        protected internal override void RenderPagerTag(
            HtmlMobileTextWriter writer,
            int pageToNavigate,
            String text)
        {
            writer.EnterLayout(Style);
            writer.EnterFormat(Style);
            writer.WriteBeginTag("input");

            // Specially encode the page number with the control id.
            // The corresponding code that handles postback should know how
            // to extract the page number correctly.
            writer.Write(" name=\"");
            writer.Write(Control.UniqueID);
            writer.Write(Constants.PagePrefix);
            writer.Write(pageToNavigate.ToString());
            writer.Write("\"");

            writer.WriteAttribute("type", "submit");
            writer.WriteAttribute("value", text, true);
            writer.Write("/>");
            writer.ExitFormat(Style);
            writer.ExitLayout(Style);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlselectionlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlSelectionListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * ChtmlSelectionListAdapter provides the chtml device functionality for SelectionList controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlSelectionListAdapter : HtmlSelectionListAdapter
    {
        public override bool RequiresFormTag
        {
            get
            {
                // Some browsers require the form tag to display the selection
                // list properly
                return true;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            ListSelectType selectType = Control.SelectType;
            if (selectType == ListSelectType.MultiSelectListBox && 
                Device.SupportsSelectMultiple == false)
            {
                // Render occurs after SaveViewState.  Here we make a temp
                // change which is not persisted to the view state.
                Control.SelectType = selectType = ListSelectType.CheckBox;
            }

            if (!Device.RequiresUniqueHtmlCheckboxNames ||
                selectType != ListSelectType.CheckBox)
            {
                base.Render(writer);
            }
            else
            { 
                MobileListItemCollection items = Control.Items;
                if (items.Count == 0)
                {
                    return;
                }
                writer.EnterStyle(Style);
                bool writeBreak = false;
                foreach (MobileListItem item in items)
                {
                    int index = items.IndexOf(item);
                    if(writeBreak)
                    {
                        writer.WriteBreak();
                    }

                    writer.Write("<input type=\"checkbox\" name=\"");
                    if(Device.RequiresAttributeColonSubstitution)
                    {
                        writer.Write(Control.UniqueID.Replace(':', ','));
                    }
                    else
                    {
                        writer.Write(Control.UniqueID);
                    }
                    writer.Write(Constants.SelectionListSpecialCharacter);
                    writer.Write(index);
                    writer.Write("\" value=\"");
                    if (Control.Form.Action != String.Empty)
                    {
                        writer.WriteEncodedText(item.Value);
                    }
                    else
                    {
                        writer.Write(item.Index.ToString());
                    }
                    if (item.Selected &&
                        Device.SupportsUncheck)
                    {
                        writer.Write("\" checked>");
                    }
                    else
                    {
                        writer.Write("\">");
                    }

                    writer.WriteText(item.Text, true);
                    writeBreak = true;
                }
                writer.ExitStyle(Style, Control.BreakAfter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlphonecalladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlPhoneCallAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * ChtmlPhoneCallAdapter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlPhoneCallAdapter : HtmlPhoneCallAdapter
    {
        protected override void AddAttributes(HtmlMobileTextWriter writer)
        {
            AddAccesskeyAttribute(writer);
            AddJPhoneMultiMediaAttributes(writer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmlmobiletextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlMobileTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.IO;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * ChtmlMobileTextWriter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlMobileTextWriter : HtmlMobileTextWriter
    {
        public ChtmlMobileTextWriter(TextWriter writer, MobileCapabilities device) 
            : base(writer, device)
        {
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\emptytextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="EmptyTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.IO;
using System.Text;
using System.Web.Mobile;
using System.Web.UI.MobileControls;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * EmptyTextWriter class. Like the Null text writer, but keeps track of whether
     * anything was written or not.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    
    internal class EmptyTextWriter : TextWriter
    {
        bool _writeCalled = false;
        bool _nonWhiteSpaceWritten = false;

        internal EmptyTextWriter() 
        {
        }

        internal /*public*/ bool WriteCalled
        {
            get
            {
                return _writeCalled;
            }
        }

        internal /*public*/ bool NonWhiteSpaceWritten
        {
            get
            {
                return _nonWhiteSpaceWritten;
            }
        }

        internal /*public*/ void Reset()
        {
            _writeCalled = false;
            _nonWhiteSpaceWritten = false;
        }

        public override void Write(string s) 
        {
            _writeCalled = true;
            if (!IsWhiteSpace(s))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void Write(bool value) 
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void Write(char value) 
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void Write(char[] buffer) 
        {
            _writeCalled = true;
            if (!IsWhiteSpace(buffer))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void Write(char[] buffer, int index, int count) 
        {
            _writeCalled = true;
            if (!IsWhiteSpace(buffer, index, count))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void Write(double value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void Write(float value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void Write(int value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void Write(long value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void Write(Object value)
        {
            _writeCalled = true;
            if (value != null && !IsWhiteSpace(value.ToString()))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void Write(String format, Object arg0)
        {
            _writeCalled = true;
            if (!IsWhiteSpace(format) && !IsWhiteSpace(String.Format(format, arg0)))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void Write(String format, Object arg0, Object arg1)
        {
            _writeCalled = true;
            if (!IsWhiteSpace(format) && !IsWhiteSpace(String.Format(format, arg0, arg1)))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void Write(String format, params object[] arg)
        {
            _writeCalled = true;
            if (!IsWhiteSpace(format) && !IsWhiteSpace(String.Format(format, arg)))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(string s) 
        {
            _writeCalled = true;
            if (!IsWhiteSpace(s))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(bool value) 
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void WriteLine(char value) 
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void WriteLine(char[] buffer) 
        {
            _writeCalled = true;
            if (!IsWhiteSpace(buffer))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(char[] buffer, int index, int count) 
        {
            _writeCalled = true;
            if (!IsWhiteSpace(buffer, index, count))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(double value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void WriteLine(float value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void WriteLine(int value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void WriteLine(long value)
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override void WriteLine(Object value)
        {
            _writeCalled = true;
            if (value != null && !IsWhiteSpace(value.ToString()))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(String format, Object arg0)
        {
            _writeCalled = true;
            if (!IsWhiteSpace(format) && !IsWhiteSpace(String.Format(format, arg0)))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(String format, Object arg0, Object arg1)
        {
            _writeCalled = true;
            if (!IsWhiteSpace(format) && !IsWhiteSpace(String.Format(format, arg0, arg1)))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        public override void WriteLine(String format, params object[] arg)
        {
            _writeCalled = true;
            if (!IsWhiteSpace(format) && !IsWhiteSpace(String.Format(format, arg)))
            {
                _nonWhiteSpaceWritten = true;
            }
        }

        [CLSCompliant(false)]
        public override void WriteLine(UInt32 value) 
        {
            _writeCalled = true;
            _nonWhiteSpaceWritten = true;
        }

        public override Encoding Encoding 
        {
            get 
            {
                return Encoding.UTF8;
            }
        }

        private static bool IsWhiteSpace(String s)
        {
            if (s == null)
            {
                return true;
            }

            for (int i = s.Length - 1; i >= 0; i--)
            {
                char c = s[i];
                if (c != '\r' && c != '\n' && !Char.IsWhiteSpace(c))
                {
                    return false;
                }
            }

            return true;
        }

        private static bool IsWhiteSpace(char[] buffer)
        {
            if (buffer == null)
            {
                return true;
            }

            return IsWhiteSpace(buffer, 0, buffer.Length);
        }

        private static bool IsWhiteSpace(char[] buffer, int index, int count)
        {
            if (buffer == null)
            {
                return true;
            }

            for (int i = 0; i < count; i++)
            {
                char c = buffer[index + i];
                if (c != '\r' && c != '\n' && !Char.IsWhiteSpace(c))
                {
                    return false;
                }
            }

            return true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\chtmltextboxadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ChtmlTextBoxAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * ChtmlTextBoxAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class ChtmlTextBoxAdapter : HtmlTextBoxAdapter
    {
        private static Random _random = new Random();

        protected override void AddAttributes(HtmlMobileTextWriter writer)
        {
            if (Control.Numeric)
            {
                if (Device.SupportsInputIStyle)
                {
                    // The default input mode is always numeric if the
                    // type is password.
                    if (!Control.Password)
                    {
                        writer.WriteAttribute("istyle", "4");
                    }
                }
                else if (Device.SupportsInputMode)
                {
                    writer.WriteAttribute("mode", "numeric");
                }
            }

            AddAccesskeyAttribute(writer);
            AddJPhoneMultiMediaAttributes(writer);
        }

        public override bool RequiresFormTag
        {
            get
            {
                return true;
            }
        }

        private String GetRandomID(int length)
        {
            Byte[] randomBytes = new Byte[length];
            _random.NextBytes(randomBytes);

            char[] randomChars = new char[length];
            for (int i = 0; i < length; i++)
            {
                randomChars[i] = (char)((((int)randomBytes[i]) % 26) + 'a');
            }

            return new String(randomChars);
        }

        internal override String GetRenderName()
        {
            String renderName = base.GetRenderName();

            if (Device.RequiresUniqueHtmlInputNames)
            {
                renderName += Constants.SelectionListSpecialCharacter + GetRandomID(4);
            }

            return renderName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlcalendaradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlCalendarAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.IO;
using System.Drawing;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * HtmlCalendarAdapter provides the html device functionality for
     * Calendar control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlCalendarAdapter : HtmlControlAdapter
    {
        // Insert bgcolor="Silver" right after td tag
        private const int _bgColorInsertionPointInPattern = 4;
        // Defines a disk in which the color White is chosen instead of Silver
        private const int _bgColorDistanceTreshold = 1000;
        // Search patterns for locating cells of selected dates
        private const String _selectedDateSearchTableTag = "<table ";
        private const String _selectedDateSearchCellTag = "<td ";
        private const String _selectedDateSearchAttr = "background-color:Silver;";

        protected new Calendar Control
        {
            get
            {
                return (Calendar)base.Control;
            }
        }

        private int LocateNextSelectedDate(String webCalendarHtml, int startingIndex)
        {
            int tagBeginIndex = startingIndex;
            do
            {
                tagBeginIndex = webCalendarHtml.IndexOf(_selectedDateSearchCellTag, tagBeginIndex);
                if (tagBeginIndex >= 0)
                {
                    int tagEndIndex = webCalendarHtml.IndexOf(">", tagBeginIndex + _bgColorInsertionPointInPattern);
                    Debug.Assert(tagEndIndex >= 0);
                    String tagComplete = webCalendarHtml.Substring(tagBeginIndex, tagEndIndex-tagBeginIndex+1);
                    if (tagComplete.IndexOf(_selectedDateSearchAttr) >= 0)
                    {
                        return tagBeginIndex;
                    }
                    else
                    {
                        tagBeginIndex += _bgColorInsertionPointInPattern;
                    }
                }
            }
            while (tagBeginIndex >= 0);
            return -1;
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            System.Web.UI.WebControls.WebControl webCalendar = Control.WebCalendar;
            
            Style.ApplyTo(webCalendar);

            // Delegate the rendering effort to the child Web Calendar
            // control for HTML browser
            webCalendar.Visible = true;

            // There is no explicit property for alignment on WebForms
            // Calendar, so we need some special code to set it.
            writer.EnterLayout(Style);
            writer.EnsureStyle();
            Alignment align = (Alignment) Style[Style.AlignmentKey, true];
            if (!Device.SupportsDivAlign)
            {
                webCalendar.Attributes["align"] = align.ToString();
            }

            if (Device.SupportsCss)
            {
                // Target device supports CSS - simply delegate the rendering
                // to the underlying Web Calendar control
                webCalendar.RenderControl(writer);
            }
            else
            {
                // Insert bgcolor attributes in cells that correspond to selected dates
                StringWriter sw = new StringWriter();
                HtmlTextWriter tmpWriter = new HtmlTextWriter(sw);
                webCalendar.RenderControl(tmpWriter);
                String webCalendarHtml = sw.ToString();
                int index = 0, indexLastTable = 0;
                // Search for offset of last <table> tag in the Web Calendar HTML.
                // That table contains the various days.
                do
                {
                    index = webCalendarHtml.IndexOf(_selectedDateSearchTableTag, index);
                    if (index >= 0)
                    {
                        indexLastTable = index;
                        index += 5;
                    }
                } 
                while (index >= 0);
                index = LocateNextSelectedDate(webCalendarHtml, indexLastTable);
                if (index >= 0)
                {
                    // Determine the background color of the containing Form control
                    HtmlControlAdapter formAdapter = (HtmlControlAdapter) Control.Form.Adapter;
                    Color backColor = (Color)formAdapter.Style[Style.BackColorKey, true];
                    int deltaR = System.Math.Abs(backColor.R - 0xC0);
                    int deltaG = System.Math.Abs(backColor.G - 0xC0);
                    int deltaB = System.Math.Abs(backColor.B - 0xC0);
                    // Determine the distance between Silver and the Form's background color
                    int bgColorDistance = deltaR * deltaR + deltaG * deltaG + deltaB * deltaB;
                    // Choose Silver or White depending on that distance
                    String selectedDateBGColor = 
                        String.Format("bgcolor=\"{0}\" ", bgColorDistance < _bgColorDistanceTreshold ? "White" : "Silver");
                    while (index >= 0)
                    {
                        // Insert the bgcolor attribute for each selected date cell
                        webCalendarHtml = webCalendarHtml.Insert(index + _bgColorInsertionPointInPattern, selectedDateBGColor);
                        index = LocateNextSelectedDate(webCalendarHtml, index + _bgColorInsertionPointInPattern);
                    }
                }
                // Use the HTML after insertions
                writer.Write(webCalendarHtml);
            }

            if(Control.BreakAfter)
            {
                writer.WriteBreak();
            }
            writer.ExitLayout(Style);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\controladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.Mobile;
using RootMobile = System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Security.Permissions;

// We don't recompile this base class in the shipped source samples, as it
// accesses some internal functionality and is a core utility (rather than an
// extension itself).
#if !COMPILING_FOR_SHIPPED_SOURCE

namespace System.Web.UI.MobileControls.Adapters
{

    /*
     * ControlAdapter base class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class ControlAdapter : IControlAdapter
    {
        private static readonly String[] LabelIDs = new String[] {
                                                RootMobile.SR.ControlAdapter_BackLabel,
                                                RootMobile.SR.ControlAdapter_GoLabel,
                                                RootMobile.SR.ControlAdapter_OKLabel,
                                                RootMobile.SR.ControlAdapter_MoreLabel,
                                                RootMobile.SR.ControlAdapter_OptionsLabel,
                                                RootMobile.SR.ControlAdapter_NextLabel,
                                                RootMobile.SR.ControlAdapter_PreviousLabel,
                                                RootMobile.SR.ControlAdapter_LinkLabel,
                                                RootMobile.SR.ControlAdapter_PhoneCallLabel
                                           };

        protected static readonly int BackLabel     = 0;
        protected static readonly int GoLabel       = 1;
        protected static readonly int OKLabel       = 2;
        protected static readonly int MoreLabel     = 3;
        protected static readonly int OptionsLabel  = 4;
        protected static readonly int NextLabel     = 5;
        protected static readonly int PreviousLabel = 6;
        protected static readonly int LinkLabel     = 7;
        protected static readonly int CallLabel     = 8;

        private MobileControl _control;

        public MobileControl Control
        {
            get
            {
                return _control;
            }
            set
            {
                _control = value;
            }
        }

        public virtual MobilePage Page
        {
            get
            {
                return Control.MobilePage;
            }
            set
            {
                // Do not expect to be called directly.  Subclasses should
                // override this when needed.
                throw new Exception(
                    SR.GetString(
                        SR.ControlAdapterBasePagePropertyShouldNotBeSet));
            }
        }

        public virtual MobileCapabilities Device
        {
            get
            {
                return (MobileCapabilities)Page.Request.Browser;
            }
        }

        public virtual void OnInit(EventArgs e){}
        public virtual void OnLoad(EventArgs e){}
        public virtual void OnPreRender(EventArgs e){}
        
        public virtual void Render(HtmlTextWriter writer)
        {
            RenderChildren(writer);
        }

        public virtual void OnUnload(EventArgs e){}

        public virtual bool HandlePostBackEvent(String eventArgument)
        {
            return false;
        }

        // By default, always return false, so the control itself will handle
        // it. 
        public virtual bool LoadPostData(String key,
                                         NameValueCollection data,
                                         Object controlPrivateData,
                                         out bool dataChanged)
        {
            dataChanged = false;
            return false;
        }

        public virtual void LoadAdapterState(Object state)
        {
        }

        public virtual Object SaveAdapterState()
        { 
            return null;
        }

        public virtual void CreateTemplatedUI(bool doDataBind)
        {
            // No device specific templated UI to create.

            Control.CreateDefaultTemplatedUI(doDataBind);
        }

        //  convenience methods here
        public Style Style
        {
            get
            {
                return Control.Style;
            }
        }

        protected void RenderChildren(HtmlTextWriter writer)
        {
            if (Control.HasControls())
            {
                foreach (Control child in Control.Controls)
                {
                    child.RenderControl(writer);
                }
            }
        }

        public virtual int VisibleWeight
        {
            get
            {
                return ControlPager.UseDefaultWeight;
            }
        }

        public virtual int ItemWeight
        {
            get
            {
                return ControlPager.UseDefaultWeight;
            }
        }

        // The following method is used by PageAdapter subclasses of
        // ControlAdapter for determining the optimum page weight for
        // a given device.  Algorithm is as follows:
        //     1) First look for the "optimumPageWeight" parameter set
        //        for the device.  If it exists, and can be converted
        //        to an integer, use it.
        //     2) Otherwise, look for the "screenCharactersHeight" parameter.
        //        If it exists, and can be converted to an integer, multiply
        //        it by 100 and use the result.
        //     3) As a last resort, use the default provided by the calling
        //        PageAdapter.
        protected virtual int CalculateOptimumPageWeight(int defaultPageWeight)
        {
            int optimumPageWeight = 0;

            // Pull OptimumPageWeight from the web.config parameter of the same
            // name, when present.
            String pageWeight = Device[Constants.OptimumPageWeightParameter]; 

            if (pageWeight != null)
            {
                try
                {
                    optimumPageWeight = Convert.ToInt32(pageWeight);
                }
                catch
                {
                    optimumPageWeight = 0;
                }
            }

            if (optimumPageWeight <= 0)
            {
                // If OptimumPageWeight isn't established explicitly, attempt to
                // construct it as 100 * number of lines of characters.
                String numLinesStr = Device[Constants.ScreenCharactersHeightParameter];
                if (numLinesStr != null)
                {
                    try
                    {
                        int numLines = Convert.ToInt32(numLinesStr);
                        optimumPageWeight = 100 * numLines;
                    }
                    catch
                    {
                        optimumPageWeight = 0;
                    }
                }
            }

            if (optimumPageWeight <= 0)
            {
                optimumPageWeight = defaultPageWeight;
            }

            return optimumPageWeight;
        }

        private String[] _defaultLabels = null;

        protected String GetDefaultLabel(int labelID)
        {
            if ((labelID < 0) || (labelID >= LabelIDs.Length))
            {
                throw new ArgumentException(System.Web.Mobile.SR.GetString(
                                                System.Web.Mobile.SR.ControlAdapter_InvalidDefaultLabel));
            }

            MobilePage page = Page;
            if (page != null)
            {
                ControlAdapter pageAdapter = (ControlAdapter)page.Adapter;
                if (pageAdapter._defaultLabels == null)
                {
                    pageAdapter._defaultLabels = new String[LabelIDs.Length];
                }

                String labelValue = pageAdapter._defaultLabels[labelID];
                if (labelValue == null)
                {
                    labelValue = System.Web.Mobile.SR.GetString(LabelIDs[labelID]);
                    pageAdapter._defaultLabels[labelID] = labelValue;
                }

                return labelValue;
            }
            else
            {
                return System.Web.Mobile.SR.GetString(LabelIDs[labelID]);
            }
        }
    }

    internal class EmptyControlAdapter : ControlAdapter {
        internal EmptyControlAdapter() {}
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlcommandadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlCommandAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlCommandAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlCommandAdapter : HtmlControlAdapter
    {
        protected new Command Control
        {
            get
            {
                return (Command)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            bool renderLink = false;
            bool renderImage = false;

            // If image is defined and renderable, just do it.  Otherwise,
            // render as a link if specified.
            if (Control.ImageUrl != String.Empty &&
                Device.SupportsImageSubmit)
            {
                renderImage = true;
            }
            else if (Control.Format == CommandFormat.Link &&
                     Device.JavaScript)
            {
                renderLink = true;
            }


            if (renderLink)
            {
                writer.EnterStyle(Style);
                Form form = Control.Form;
                if (form.Action.Length > 0)
                {
                    writer.Write("<a href=\"javascript:document.");
                    writer.Write(form.ClientID);
                    writer.Write(".submit()\"");
                    AddAttributes(writer);
                    writer.Write(">");
                    writer.WriteText(Control.Text, true);
                    writer.WriteEndTag("a");
                }
                else
                {
                    RenderBeginLink(writer, Constants.FormIDPrefix + form.UniqueID);
                    writer.WriteText(Control.Text, true);
                    RenderEndLink(writer);
                }
                writer.ExitStyle(Style, Control.BreakAfter);
            }
            else
            {
                writer.EnterLayout(Style);
                writer.WriteBeginTag("input");
                writer.WriteAttribute("name", Control.UniqueID);

                if (renderImage)
                {
                    writer.WriteAttribute("type", "image");
                    writer.WriteAttribute("src", Control.ResolveUrl(Control.ImageUrl), true);
                    writer.WriteAttribute("alt", Control.Text, true);
                }
                else
                {
                    writer.WriteAttribute("type", "submit");
                    writer.Write(" value=\"");
                    writer.WriteText(Control.Text, true);
                    writer.Write("\"");
                }

                AddAttributes(writer);
                writer.Write("/>");
                writer.ExitLayout(Style, Control.BreakAfter);
            }

        }

        public override bool LoadPostData(String key,
                                          NameValueCollection data,
                                          Object controlPrivateData,
                                          out bool dataChanged)
        {
            dataChanged = false;
            
            // HTML input tags of type image postback with the coordinates
            // of the click rather than the name of the control.
            String name = Control.UniqueID;
            String postX = data[name + ".x"];
            String postY = data[name + ".y"];
            if (postX != null && postY != null
                && postX.Length > 0 && postY.Length > 0)
            {
                // set dataChannged to cause RaisePostDataChangedEvent()
                dataChanged = true;
                return true;
            }
            // For other command control, defer to default logic in control.
            return false;     
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlcontroladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlControlAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Diagnostics;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * HtmlControlAdapter base class contains html specific methods.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlControlAdapter : ControlAdapter
    {
        protected HtmlPageAdapter PageAdapter
        {
            get
            {
                return ((HtmlPageAdapter)Page.Adapter);
            }
        }

        protected HtmlFormAdapter FormAdapter
        {
            get
            {
                return (HtmlFormAdapter)Control.Form.Adapter;
            }
        }

        public virtual bool RequiresFormTag
        {
            get
            {
                return false;
            }
        }

        public override void Render(HtmlTextWriter writer)
        {
            HtmlMobileTextWriter htmlWriter = (HtmlMobileTextWriter)writer;
            Render(htmlWriter);
        }

        public virtual void Render(HtmlMobileTextWriter writer)
        {
            RenderChildren(writer);
        }

        protected void RenderPostBackEventReference(HtmlMobileTextWriter writer, String argument)
        {
            PageAdapter.RenderPostBackEvent(writer, Control.UniqueID, argument);
        }

        protected void RenderPostBackEventAsAttribute(
            HtmlMobileTextWriter writer, 
            String attributeName, 
            String argument)
        {
            writer.Write(" ");
            writer.Write(attributeName);
            writer.Write("=\"");
            RenderPostBackEventReference(writer, argument);
            writer.Write("\" ");
        }

        protected void RenderPostBackEventAsAnchor(
            HtmlMobileTextWriter writer,
            String argument,
            String linkText)
        {
            writer.EnterStyle(Style);
            writer.WriteBeginTag("a");
            RenderPostBackEventAsAttribute(writer, "href", argument);
            writer.Write(">");
            writer.WriteText(linkText, true);
            writer.WriteEndTag("a");
            writer.ExitStyle(Style);
        }

        protected void RenderBeginLink(HtmlMobileTextWriter writer, String target)
        {
            bool queryStringWritten = false;
            bool appendCookieless = (PageAdapter.PersistCookielessData)  && 
                    (!( (target.StartsWith("http:")) || (target.StartsWith("https:")) ));
            writer.WriteBeginTag("a");
            writer.Write(" href=\"");

            String targetUrl = null;
            String prefix = Constants.FormIDPrefix;
            if (target.StartsWith(prefix))
            {
                String name = target.Substring(prefix.Length);
                Form form = Control.ResolveFormReference(name);

                if (writer.SupportsMultiPart)
                {
                    if (form != null && PageAdapter.IsFormRendered(form))
                    {
                        targetUrl = PageAdapter.GetFormUrl(form);
                    }
                }
                
                if (targetUrl == null)
                {
                    RenderPostBackEventReference(writer, form.UniqueID);
                    appendCookieless = false;
                }
                else
                {
                    writer.Write(targetUrl);
                    queryStringWritten = targetUrl.IndexOf('?') != -1;
                }
            }
            else
            {
                MobileControl control = Control;

                // There is some adapter that Control is not set.  And we
                // don't do any url resolution then.  E.g. a page adapter
                if (control != null)
                {
                    // AUI 3652
                    target = control.ResolveUrl(target);
                }

                writer.Write(target);
                queryStringWritten = target.IndexOf('?') != -1;
            }

            IDictionary dictionary = PageAdapter.CookielessDataDictionary;
            if((dictionary != null) && (appendCookieless))
            {
                foreach(String name in dictionary.Keys)
                {
                    if(queryStringWritten)
                    {
                        writer.Write('&');
                    }
                    else
                    {
                        writer.Write('?');
                        queryStringWritten = true;
                    }
                    writer.Write(name);
                    writer.Write('=');
                    writer.Write(dictionary[name]);
                }
            }

            writer.Write("\"");
            AddAttributes(writer);
            writer.Write(">");
        }

        protected void RenderEndLink(HtmlMobileTextWriter writer)
        {
            writer.WriteEndTag("a");
        }

        // Can be used by adapter that allow its subclass to add more
        // specific attributes
        protected virtual void AddAttributes(HtmlMobileTextWriter writer)
        {
        }

        // Can be used by adapter that adds the custom attribute "accesskey"
        protected virtual void AddAccesskeyAttribute(HtmlMobileTextWriter writer)
        {
            if (Device.SupportsAccesskeyAttribute)
            {
                AddCustomAttribute(writer, "accesskey");
            }
        }

        // Can be used by adapter that adds custom attributes for
        // multi-media functionalities

        private readonly static String [] _multiMediaAttributes =
            { "src",
              "soundstart",
              "loop",
              "volume",
              "vibration",
              "viblength" };

        protected virtual void AddJPhoneMultiMediaAttributes(
            HtmlMobileTextWriter writer)
        {
            if (Device.SupportsJPhoneMultiMediaAttributes)
            {
                for (int i = 0; i < _multiMediaAttributes.Length; i++)
                {
                    AddCustomAttribute(writer, _multiMediaAttributes[i]);
                }
            }
        }

        private void AddCustomAttribute(HtmlMobileTextWriter writer,
                                        String attributeName)
        {
            String attributeValue = ((IAttributeAccessor)Control).GetAttribute(attributeName);
            if (attributeValue != null && attributeValue != String.Empty)
            {
                writer.WriteAttribute(attributeName, attributeValue);
            }
        }

        protected virtual void RenderAsHiddenInputField(HtmlMobileTextWriter writer)
        {
        }

        // Renders hidden variables for IPostBackDataHandlers which are
        // not displayed due to pagination or secondary UI.
        internal void RenderOffPageVariables(HtmlMobileTextWriter writer, Control ctl, int page)
        {
            if (ctl.HasControls())
            {
                foreach (Control child in ctl.Controls)
                {
                    // Note: Control.Form != null.
                    if (!child.Visible || child == Control.Form.Header || child == Control.Form.Footer)
                    {
                        continue;
                    }

                    MobileControl mobileCtl = child as MobileControl;

                    if (mobileCtl != null)
                    {
                        if (mobileCtl.IsVisibleOnPage(page)
                            && (mobileCtl == ((HtmlFormAdapter)mobileCtl.Form.Adapter).SecondaryUIControl ||
                            null == ((HtmlFormAdapter)mobileCtl.Form.Adapter).SecondaryUIControl))
                        {
                            if (mobileCtl.FirstPage == mobileCtl.LastPage)
                            {
                                // Entire control is visible on this page, so no need to look
                                // into children.
                                continue;
                            }

                            // Control takes up more than one page, so it may be possible that
                            // its children are on a different page, so we'll continue to
                            // fall through into children.
                        }
                        else if (mobileCtl is IPostBackDataHandler)
                        {
                            HtmlControlAdapter adapter = mobileCtl.Adapter as HtmlControlAdapter;
                            if (adapter != null)
                            {
                                adapter.RenderAsHiddenInputField(writer);
                            }
                        }
                    }

                    RenderOffPageVariables(writer, child, page);
                }
            }
        }

        /////////////////////////////////////////////////////////////////////
        //  SECONDARY UI SUPPORT
        /////////////////////////////////////////////////////////////////////

        internal const int NotSecondaryUIInit = -1;  // For initialization of private consts in derived classes.
        protected static readonly int NotSecondaryUI = NotSecondaryUIInit;

        protected int SecondaryUIMode
        {
            get
            {
                if (Control == null || Control.Form == null) 
                {
                    return NotSecondaryUI;
                }
                else
                {
                    return ((HtmlFormAdapter)Control.Form.Adapter).GetSecondaryUIMode(Control);
                }
            }
            set
            {
                ((HtmlFormAdapter)Control.Form.Adapter).SetSecondaryUIMode(Control, value);
            }
        }

        protected void ExitSecondaryUIMode()
        {
            SecondaryUIMode = NotSecondaryUI;
        }

        public override void LoadAdapterState(Object state)
        {
            if (state != null)
            {
                SecondaryUIMode = (int)state;
            }
        }

        public override Object SaveAdapterState()
        {
            int mode = SecondaryUIMode;
            if (mode != NotSecondaryUI) 
            {
                return mode;
            }
            else
            {
                return null;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlformadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlFormAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{

    /*
     * HtmlFormAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlFormAdapter : HtmlControlAdapter
    {
        private static String _contentTypeMetaTag = "<meta http-equiv=\"Content-Type\" content=\"{0}; charset={1}\">\r\n";

        protected new Form Control
        {
            get
            {
                return (Form)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            Color backColor = (Color)Style[Style.BackColorKey, true];
            String title = Control.Title;

            bool willWriteHeadElements =
                title != String.Empty ||
                RenderExtraHeadElements(null);

            if (willWriteHeadElements)
            {
                writer.Write("\r\n");
                writer.WriteFullBeginTag("head");
            }

            if (title != String.Empty)
            {
                writer.Write("\r\n");
                writer.WriteFullBeginTag("title");
                writer.Write(title);
                writer.WriteEndTag("title");
                writer.Write("\r\n");
            }

            _renderPager = true;

            RenderExtraHeadElements(writer);

            if (willWriteHeadElements)
            {
                writer.WriteEndTag("head");
                writer.Write("\r\n");
            }

            IDictionary bodyAttributes = new ListDictionary();
            if ((backColor != Color.Empty) && (writer.RenderBodyColor))
            {
                bodyAttributes.Add("bgcolor", ColorTranslator.ToHtml(backColor));
            }
            RenderBodyTag(writer, bodyAttributes);

            bool formTagRequired = ShouldRenderFormTag();
            if (formTagRequired)
            {
                writer.WriteBeginTag("form");
                writer.WriteAttribute("id", Control.ClientID);
                writer.WriteAttribute("name", Control.ClientID);
                writer.WriteAttribute("method", Control.Method.ToString().ToLower(CultureInfo.InvariantCulture));
                writer.Write(" action=\"");

                if (Control.Action.Length > 0)
                {
                    // AUI 3652
                    String url = Control.ResolveUrl(Control.Action);

                    if (!Device.SupportsQueryStringInFormAction)
                    {
                        // If query string is not supported, we don't write
                        // it here, and the query string will be added as
                        // hidden variables later.
                        int i = url.IndexOf('?');
                        if (i != -1)
                        {
                            url = url.Substring(0, i);
                        }
                    }

                    writer.Write(url);
                }
                else
                {
                    writer.WriteEncodedUrl(Page.RelativeFilePath);

                    if (Device.SupportsQueryStringInFormAction)
                    {
                        writer.Write("?");
                        writer.Write(Page.UniqueFilePathSuffix);
                        if (Control.Method != FormMethod.Get)
                        {
                            String queryStringText = Page.QueryStringText;
                            if (queryStringText != null && queryStringText.Length > 0)
                            {
                                writer.Write('&');
                                writer.Write(queryStringText);
                            }
                        }
                    }
                }

                writer.Write("\"");
                writer.Write(">\r\n");

                PageAdapter.RenderPostBackHeader(writer, Control);

                // Renders hidden variables for IPostBackDataHandlers which are
                // not displayed due to pagination or secondary UI.
                RenderOffPageVariables(writer, Control, Control.CurrentPage);
            }

            writer.EnterStyle(Style);

            writer.BeforeFirstControlWritten = true;

            MobileControl secondaryUIControl = SecondaryUIControl as MobileControl;

            if (secondaryUIControl != null && secondaryUIControl.Form == Control)
            {
                bool secondaryUIInHeaderOrFooter = IsControlInFormHeader(secondaryUIControl) 
                    || IsControlInFormFooter(secondaryUIControl);


                SetControlPageRecursive(secondaryUIControl, -1);
                if(Control.Header != null && !secondaryUIInHeaderOrFooter)
                {
                     Control.Header.RenderControl(writer);
                }
                secondaryUIControl.RenderControl(writer);
                if(Control.Footer != null && !secondaryUIInHeaderOrFooter)
                {
                    Control.Footer.RenderControl(writer);
                }
            }
            else
            {

                bool pagerRendered = false;
                if(Control.HasControls())
                {
                    foreach(Control child in Control.Controls)
                    {
                        if(Control.Footer == child)
                        {
                            RenderPager(writer);
                            pagerRendered = true;
                        }
                        child.RenderControl(writer);
                    }
                }
                if(!pagerRendered)
                {
                    RenderPager(writer);
                }
            }

            writer.ExitStyle(Style, false);

            if (formTagRequired)
            {
                if (!Device.SupportsQueryStringInFormAction)
                {
                    // Add query string parameters at the end of the form if
                    // there are any
                    RenderQueryParametersAsHiddenFields(writer);
                }
                writer.WriteEndTag("form");
            }
            writer.WriteEndTag("body");
        }

        // Return true if actually wrote any head elements.  If called with
        // null, this returns whether head elements would be written if called
        // with a real writer.
        protected virtual bool RenderExtraHeadElements(HtmlMobileTextWriter writer)
        {
            bool result = false;
            
            String metaTagName = Device.RequiredMetaTagNameValue;
            if (metaTagName != null)
            {
                if (writer != null)
                {
                    writer.Write("<meta NAME=\"" + metaTagName + "\" CONTENT=\"True\">\r\n");
                }
                result = true;
            }

            String charset = Page.Response.Charset;
            if (Device.RequiresContentTypeMetaTag &&
                charset != null && charset.Length > 0)
            {
                if (writer != null)
                {
                    writer.Write(String.Format(_contentTypeMetaTag, Device.PreferredRenderingMime, charset));
                }
                result = true;
            }
            
            Form form = this.Control as Form;
            if(writer == null)
            {
                if((form != null) && (form.Script != null))
                {
                    result = true;
                }
            }
            else if ((form != null) && (form.Script != null))
            {
                 foreach(Control childControl in form.Script.Controls)
                 {
                     LiteralControl lc = childControl as LiteralControl;
                     if(lc != null)
                     {
                         writer.Write(lc.Text);
                     }
                     else
                     {
                         DataBoundLiteralControl dlc = childControl as DataBoundLiteralControl;
                         if(dlc != null)
                         {
                             writer.Write(dlc.Text);
                         }
                     }
                 }
                 result = true;
            }
            return result;
        }

        protected virtual void RenderBodyTag(HtmlMobileTextWriter writer, IDictionary attributes)
        {
            writer.WriteBeginTag("body");
            foreach (DictionaryEntry entry in attributes)
            {
                writer.WriteAttribute((String)entry.Key, (String)entry.Value, true);
            }
            writer.WriteLine(">");
        }

        protected virtual bool ShouldRenderFormTag()
        {
            return true;
        }

        private bool _renderPager = true;

        protected internal void DisablePager()
        {
            _renderPager = false;
        }

        protected virtual void RenderPager(HtmlMobileTextWriter writer)
        {
            if(!_renderPager)
            {
                return;
            }
            PagerStyle pagerStyle = Control.PagerStyle;

            int pageCount = Control.PageCount;
            if (pageCount <= 1)
            {
                return;
            }
            int page = Control.CurrentPage;
            String text = pagerStyle.GetPageLabelText(page, pageCount);

            if((page > 1) || (text.Length > 0) || (page < pageCount))
            {
                writer.EnterStyle(pagerStyle);
            }

            if (page > 1)
            {
                RenderPagerTag(writer, page - 1,
                               pagerStyle.GetPreviousPageText(page));
                writer.Write(" ");
            }

            if (text.Length > 0)
            {
                writer.WriteEncodedText(text);
                writer.Write(" ");
            }

            if (page < pageCount)
            {
                RenderPagerTag(writer, page + 1,
                               pagerStyle.GetNextPageText(page));
            }

            if((page > 1) || (text.Length > 0) || (page < pageCount))
            {
                writer.ExitStyle(pagerStyle, true);
            }
        }

        protected internal virtual void RenderPagerTag(
            HtmlMobileTextWriter writer,
            int pageToNavigate,
            String text)
        {
            RenderPostBackEventAsAnchor(writer, pageToNavigate.ToString(),
                                        text);
        }

        private void RenderQueryParametersAsHiddenFields(
            HtmlMobileTextWriter writer)
        {
            String action = Page.ActiveForm.Action;
            int indexOfQueryStringText = action.IndexOf('?');

            if (indexOfQueryStringText != -1 ||
                Page.QueryStringText != String.Empty ||
                Control.Method == FormMethod.Get)
            {
                // We use __ufps as the delimiter in the collection.
                writer.WriteHiddenField(
                    Constants.UniqueFilePathSuffixVariable.Substring(
                        0, Constants.UniqueFilePathSuffixVariable.Length - 1),
                    String.Empty);

                String queryString;

                // If there is some query string on the Action attribute,
                // it takes the precedence.
                if (indexOfQueryStringText != -1)
                {
                    queryString = action.Substring(indexOfQueryStringText + 1);
                }
                else
                {
                    queryString = Page.QueryStringText;
                }

                if (queryString != null && queryString.Length != 0)
                {
                    NameValueCollection collection =
                            ParseQueryStringIntoCollection(queryString);

                    for (int i = 0; i < collection.Count; i++)
                    {
                        writer.WriteHiddenField(collection.GetKey(i),
                                                collection.Get(i));
                    }
                }
            }
        }

        private NameValueCollection ParseQueryStringIntoCollection(
            String queryString)
        {
            Debug.Assert(queryString != null && queryString.Length > 0,
                         "queryString is null or empty");

            NameValueCollection collection = new NameValueCollection();

            int l = queryString.Length;
            int i = 0;

            while (i < l)
            {
                // find next & while noting first = on the way (and if there are more)
                int si = i;
                int ti = -1;

                while (i < l)
                {
                    char b = queryString[i];

                    if (b == '=')
                    {
                        if (ti < 0)
                        {
                            ti = i;
                        }
                    }
                    else if (b == '&')
                    {
                        break;
                    }

                    i++;
                }

                // extract the name / value pair
                String name, value;
                if (ti >= 0)
                {
                    name  = Page.Server.UrlDecode(queryString.Substring(si, ti-si));
                    value = Page.Server.UrlDecode(queryString.Substring(ti+1, i-ti-1));
                }
                else
                {
                    name = null;
                    value = Page.Server.UrlDecode(queryString.Substring(si, i-si));
                }

                // add name / value pair to the collection
                collection.Add(name, value);

                // trailing '&'
                if (i == l-1 && queryString[i] == '&')
                {
                    collection.Add(null, "");
                }

                i++;
            }

            return collection;
        }

        /////////////////////////////////////////////////////////////////////////
        //  SECONDARY UI SUPPORT
        /////////////////////////////////////////////////////////////////////////

        private Control _secondaryUIControl;
        private int _secondaryUIMode;

        internal int GetSecondaryUIMode(Control control)
        {
            return (control != null && _secondaryUIControl == control) ? _secondaryUIMode : NotSecondaryUI;
        }

        internal void SetSecondaryUIMode(Control control, int mode)
        {
            if (mode != NotSecondaryUI)
            {
                if (_secondaryUIControl != null && _secondaryUIControl != control)
                {
                    throw new Exception(
                        SR.GetString(SR.FormAdapterMultiControlsAttemptSecondaryUI));
                }
                _secondaryUIControl = control;
                _secondaryUIMode = mode;
                return;
            }

            if (control == _secondaryUIControl)
            {
                _secondaryUIControl = null;
            }
        }

        internal Control SecondaryUIControl
        {
            get
            {
                return _secondaryUIControl;
            }
        }

        //identical to method in wmlformadapter
        private static void SetControlPageRecursive(Control control, int page)
        {
            MobileControl mc = control as MobileControl;
            if(mc != null)
            {
                mc.FirstPage = page;
                mc.LastPage = page;
            }
            if (control.HasControls())
            {
                foreach (Control child in control.Controls)
                {
                    MobileControl mobileChild = child as MobileControl;
                    if (mobileChild != null)
                    {
                            mobileChild.FirstPage = page;
                            mobileChild.LastPage = page;
                    }
                    else 
                    {
                        SetControlPageRecursive(child, page);
                    }
                }
            }
        }

        private bool IsControlInFormHeader(MobileControl control)
        {
            return IsAncestor(Control.Header, control);
        }

        private bool IsControlInFormFooter(MobileControl control)
        {
            return IsAncestor(Control.Footer, control);
        }

        private bool IsAncestor(MobileControl ancestor, MobileControl descendant)
        {
            for (Control i = descendant; i != null; i = i.Parent)
            {
                if (i == ancestor)
                {
                    return true;
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlimageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlImageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{
    /*
     * HtmlImageAdapter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlImageAdapter : HtmlControlAdapter
    {
        protected new Image Control
        {
            get
            {
                return (Image)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            String target = Control.NavigateUrl;

            writer.EnterLayout(Style);
            if (target != String.Empty)
            {
                RenderBeginLink(writer, target);
            }

            if (Control.ImageUrl == String.Empty)
            {
                // Just write the alternate as text
                writer.EnsureStyle();
                writer.MarkStyleContext();
                writer.EnterFormat(Style);
                writer.WriteText(Control.AlternateText, true);
                writer.ExitFormat(Style);
                writer.UnMarkStyleContext();
            }
            else
            {
                RenderImage(writer);
            }

            if (target != String.Empty)
            {
                RenderEndLink(writer);
            }
            writer.ExitLayout(Style, Control.BreakAfter);
        }

        protected internal virtual void RenderImage(HtmlMobileTextWriter writer)
        {
            String source = Control.ImageUrl;

            writer.WriteBeginTag("img");

            if (source != String.Empty)
            {
                // AUI 3652
                source = Control.ResolveUrl(source);

                writer.WriteAttribute("src", source, true /*encode*/);
                writer.AddResource(source);
            }

            if (Control.AlternateText != String.Empty)
            {
                writer.WriteAttribute("alt", Control.AlternateText, true);
            }

            writer.WriteAttribute("border", "0");
            writer.Write(" />");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmllabeladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlLabelAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * HtmlLabelAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlLabelAdapter : HtmlControlAdapter
    {
        protected new TextControl Control
        {
            get
            {
                return (TextControl)base.Control;
            }
        }

        protected internal bool WhiteSpace(String s)
        {
            if (s == null)
            {
                return true;
            }
            int length = s.Length;
            for(int i = 0; i < length; i++)
            {
                char c = s[i];
                if(!Char.IsWhiteSpace(c))
                {
                    return false;
                }
            }
            return true;
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.EnterStyle(Style);
            if( (writer.BeforeFirstControlWritten) &&
                (Device.RequiresLeadingPageBreak)  &&
                ((Control.Text == String.Empty) || WhiteSpace(Control.Text) ) )
            {
                writer.WriteBreak();
            }
            else
            {
                writer.WriteText(Control.Text, true);
            }
            writer.ExitStyle(Style, Control.BreakAfter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmllistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * HtmlListAdapter provides the html device functionality for List controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlListAdapter : HtmlControlAdapter
    {
        protected new List Control
        {
            get
            {
                return (List)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            if(Control.HasControls())
            {
                RenderChildren(writer);
                return;
            }
            RenderList(writer);
        }

        protected virtual void RenderList(HtmlMobileTextWriter writer)
        {
            MobileListItemCollection items = Control.Items;
            Wrapping wrap = Style.Wrapping; // used for tables, no decoration case.
            if (items.Count == 0)
            {
                return;
            }

            int pageStart = Control.FirstVisibleItemIndex;
            int pageSize = Control.VisibleItemCount;

            // Determine what markup to use.

            String listSuffix, itemPrefix, itemSuffix;
            ListDecoration decoration = Control.Decoration;
            bool insideStyle = true;

            // We know that for table tag, outer style doesn't carry over
            // into inside tags so style state needs to be reset.
            // For other cases, we enter the style here once and exit at the
            // end once.
            if (decoration != ListDecoration.None || !Device.Tables)
            {
                writer.EnterStyle(Style);
                insideStyle = false;
            }

            switch (decoration)
            {
                case ListDecoration.Bulleted:
                    writer.WriteLine("<ul>");
                    listSuffix = "</ul>";
                    itemPrefix = "<li>";
                    itemSuffix = "</li>";

                    if (!Device.RendersBreaksAfterHtmlLists)
                    {
                        listSuffix += "<br>";
                    }
                    break;
                case ListDecoration.Numbered:
                    if (pageStart == 0)
                    {
                        writer.WriteLine("<ol>");
                    }
                    else
                    {
                        writer.Write("<ol start=\"");
                        writer.Write(pageStart + 1);
                        writer.WriteLine("\">");
                    }
                    listSuffix = "</ol>";
                    itemPrefix = "<li>";
                    itemSuffix = "</li>";

                    if (!Device.RendersBreaksAfterHtmlLists)
                    {
                        listSuffix += "<br>";
                    }
                    break;
                default:
                    if (Device.Tables)
                    {
                        listSuffix = "</table>";
                        Style.Wrapping = Wrapping.NotSet;
                        writer.EnterLayout(Style);
                        writer.WriteLine("<table>");
                        if(wrap == Wrapping.NoWrap)
                        {
                            itemPrefix = "<tr nowrap><td>";
                        }
                        else
                        {
                            itemPrefix = "<tr><td>";
                        }
                        itemSuffix = "</td></tr>";
                    }
                    else
                    {
                        listSuffix = String.Empty;
                        itemPrefix = String.Empty;
                        itemSuffix = "<br>";
                    }
                    break;
            }

            bool hasCmdHandler = Control.HasItemCommandHandler;

            for (int i = 0; i < pageSize; i++)
            {
                MobileListItem item = items[pageStart + i];
                writer.Write(itemPrefix);

                if(insideStyle)
                {
                    writer.BeginStyleContext();
                    writer.EnterFormat(Style);
                }

                if(Control.ItemsAsLinks)
                {
                    RenderBeginLink(writer, item.Value);
                }
                else if(hasCmdHandler) 
                {
                    writer.WriteBeginTag("a");
                    RenderPostBackEventAsAttribute(writer, "href", item.Index.ToString());
                    writer.Write(">");
                } 
                writer.WriteEncodedText(item.Text);
                
                if (hasCmdHandler || Control.ItemsAsLinks)
                {
                    RenderEndLink(writer);
                }

                if(insideStyle)
                {
                    writer.ExitFormat(Style);
                    writer.EndStyleContext();
                }
                writer.WriteLine(itemSuffix);
            }

            if (listSuffix != String.Empty)
            {
                writer.WriteLine(listSuffix);
            }

            if (decoration != ListDecoration.None || !Device.Tables)
            {
                writer.ExitStyle(Style);
            }
            else
            {
                writer.ExitLayout(Style);
                Style.Wrapping = wrap;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlliteraltextadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlLiteralTextAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlLiteralTextAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlLiteralTextAdapter : HtmlControlAdapter
    {

        protected new LiteralText Control
        {
            get
            {
                return (LiteralText)base.Control;
            }
        }

        //  calls the more specific render methods
        public override void Render(HtmlMobileTextWriter writer)
        {
            String text = Control.PagedText;
            
            writer.EnterStyle(Style);
            writer.WriteText(text, true);
            writer.ExitStyle(Style, Control.BreakAfter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmllinkadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlLinkAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif
{
    /*
     * HtmlLinkAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlLinkAdapter : HtmlControlAdapter
    {
        protected new Link Control
        {
            get
            {
                return (Link)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.EnterStyle(Style);
            RenderBeginLink(writer, Control.NavigateUrl);
            writer.WriteText((Control.Text == String.Empty) ? Control.NavigateUrl : Control.Text, true);
            RenderEndLink(writer);
            writer.ExitStyle(Style, Control.BreakAfter);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlobjectlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlObjetListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Globalization;
using System.Drawing;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Diagnostics;
using System.Security.Permissions;

using SR=System.Web.UI.MobileControls.Adapters.SR;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif
{

    /*
     * HtmlObjectListAdapter provides HTML rendering of Object List control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlObjectListAdapter : HtmlControlAdapter
    {
        internal protected static readonly String BackToList = "__back";
        internal protected static readonly String ShowMoreFormat = "__more{0}";
        internal protected static readonly String ShowMore = "__more";
        private const int _modeDetails = 1;

        protected new ObjectList Control
        {
            get
            {
                return (ObjectList)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
        }

        public override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);
            if(Control.MobilePage.ActiveForm == Control.Form && 
                Control.Visible && 
                (Control.ViewMode == ObjectListViewMode.Commands || 
                    Control.ViewMode == ObjectListViewMode.Details))
            {
                SecondaryUIMode = _modeDetails;
                if (Control.Items.Count > 0)
                {
                    int itemIndex = Control.SelectedIndex;
                    Debug.Assert(itemIndex >= 0, "itemIndex is negative");                
                    Control.PreShowItemCommands(itemIndex);
                }
            }
            else
            {
                SecondaryUIMode = NotSecondaryUI;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            if (Control.ViewMode == ObjectListViewMode.List)
            {
                if (Control.HasControls())
                {
                    RenderChildren(writer);
                }
                else
                {
                    RenderItemsList(writer);
                }
            }
            else
            {
                if (Control.Selection.HasControls())
                {
                    Control.Selection.RenderChildren(writer);
                }
                else
                {
                    RenderItemDetails(writer, Control.Selection);
                }
                FormAdapter.DisablePager();
            }
        }

        public override void CreateTemplatedUI(bool doDataBind)
        {
            if (Control.ViewMode == ObjectListViewMode.List)
            {
                Control.CreateTemplatedItemsList(doDataBind);
            }
            else
            {
                Control.CreateTemplatedItemDetails(doDataBind);
            }
        }

        protected virtual void RenderItemsList(HtmlMobileTextWriter writer)
        {
            Debug.Assert (Control.VisibleItemCount <= Control.Items.Count);

            if (Control.VisibleItemCount == 0)
            {
                return;
            }
            
            Debug.Assert (Control.AllFields != null && Control.AllFields.Count > 0,
                "Should never have items but no fields.");

            if (Device.Tables)
            {
                RenderItemsListWithTableTags(writer);
            }
            else
            {
                RenderItemsListWithoutTableTags(writer);
            }
        }

        private void RenderItemsListWithTableTags(HtmlMobileTextWriter writer)
        {
            int pageStart = Control.FirstVisibleItemIndex;
            int pageSize = Control.VisibleItemCount;
            ObjectListItemCollection items = Control.Items;

            // Determine how to render.
            bool shouldRenderAsTable = ShouldRenderAsTable();
            bool hasDefaultCommand = HasDefaultCommand();
            bool onlyHasDefaultCommand = OnlyHasDefaultCommand();
            bool requiresDetailsScreen = HasItemDetails() || (!onlyHasDefaultCommand && HasCommands());
            bool itemRequiresHyperlink = requiresDetailsScreen || hasDefaultCommand;
            bool itemRequiresMoreButton = requiresDetailsScreen && hasDefaultCommand;

            int fieldCount;
            int[] fieldIndices = new int[]{};
            if (shouldRenderAsTable)
            {
                fieldIndices = Control.TableFieldIndices;
            }
            Debug.Assert(fieldIndices != null, "fieldIndices is null");
            fieldCount = fieldIndices.Length;

            if(fieldCount == 0)
            {
                fieldIndices = new int[1];
                fieldIndices[0] = Control.LabelFieldIndex;
                fieldCount = 1;
            }

            Style style = this.Style;
            Style subCommandStyle = Control.CommandStyle;
            Style labelStyle = Control.LabelStyle;
            Color foreColor = (Color)style[Style.ForeColorKey, true];

            writer.BeginStyleContext();
            writer.WriteLine("<table border=0 width=\"100%\">\r\n<tr>");
            for (int field = 0; field < fieldCount; field++)
            {
                writer.Write("<td>");
                writer.BeginStyleContext();
                writer.EnterStyle(labelStyle);
                writer.WriteText(Control.AllFields[fieldIndices[field]].Title, true);
                writer.ExitStyle(labelStyle);
                writer.EndStyleContext();
                writer.Write("</td>");
            }
            if (itemRequiresMoreButton)
            {
                writer.WriteLine("<td/>");
            }
            writer.WriteLine("\r\n</tr>");
            RenderRule(writer, foreColor, fieldCount + 1);

            for (int i = 0; i < pageSize; i++)
            {
                ObjectListItem item = items[pageStart + i];
                writer.WriteLine("<tr>");
                for (int field = 0; field < fieldCount; field++)
                {
                    writer.Write("<td>");
                    if (field == 0 && itemRequiresHyperlink)
                    {
                        writer.BeginStyleContext();
                        writer.EnterStyle(style);
                        String eventArgument =
                            hasDefaultCommand ?
                                item.Index.ToString() :
                                String.Format(ShowMoreFormat, item.Index.ToString());
                        RenderPostBackEventAsAnchor(writer,
                            eventArgument,
                            item[fieldIndices[0]]);
                        writer.ExitStyle(style);
                        writer.EndStyleContext();
                    }
                    else
                    {
                        writer.BeginStyleContext();
                        writer.EnterStyle(style);
                        writer.WriteText(item[fieldIndices[field]], true);
                        writer.ExitStyle(style);
                        writer.EndStyleContext();
                    }
                    writer.WriteLine("</td>");
                }

                if (itemRequiresMoreButton)
                {
                    writer.Write("<td align=right>");
                    writer.BeginStyleContext();
                    writer.EnterFormat(subCommandStyle);
                    String moreText = Control.MoreText == String.Empty ?
                        GetDefaultLabel(MoreLabel) :
                        Control.MoreText;
                    RenderPostBackEventAsAnchor(writer,
                        String.Format(ShowMoreFormat, item.Index), 
                        moreText,
                        subCommandStyle);
                    writer.ExitFormat(subCommandStyle);
                    writer.EndStyleContext();
                    writer.Write("</td>\r\n");
                }

                writer.WriteLine("</tr>");
            }

            RenderRule(writer, foreColor, fieldCount + 1);

            writer.Write("</table>\r\n");
            writer.EndStyleContext();
        }

        private void RenderItemsListWithoutTableTags(HtmlMobileTextWriter writer)
        {
            int startIndex = Control.FirstVisibleItemIndex;
            int pageSize = Control.VisibleItemCount;
            ObjectListItemCollection items = Control.Items;
            IObjectListFieldCollection allFields = Control.AllFields;
            int count = allFields.Count;
            
            int nextStartIndex =  startIndex + pageSize;
            int labelFieldIndex = Control.LabelFieldIndex;

             
            Style style = this.Style;
            Style labelStyle = Control.LabelStyle;
            writer.EnterStyle(labelStyle);
            writer.WriteText(Control.AllFields[labelFieldIndex].Title, true);
            writer.ExitStyle(labelStyle, true);

            bool hasDefaultCommand = HasDefaultCommand();
            bool onlyHasDefaultCommand = OnlyHasDefaultCommand();
            bool requiresDetailsScreen = !onlyHasDefaultCommand && HasCommands();
            // if there is > 1 visible field, need a details screen
            for (int visibleFields = 0, i = 0; !requiresDetailsScreen && i < count; i++)
            {
                visibleFields += allFields[i].Visible ? 1 : 0;
                requiresDetailsScreen = 
                    requiresDetailsScreen || visibleFields > 1;
            }   
            bool itemRequiresHyperlink = requiresDetailsScreen || hasDefaultCommand;
            bool itemRequiresMoreButton = requiresDetailsScreen && hasDefaultCommand;
            

            Style subCommandStyle = Control.CommandStyle;
            subCommandStyle.Alignment = style.Alignment;
            subCommandStyle.Wrapping = style.Wrapping;

            writer.EnterStyle(style);
            for (int i = startIndex; i < nextStartIndex; i++)
            {
                ObjectListItem item = items[i];

                if (itemRequiresHyperlink)
                {
                    RenderPostBackEventAsAnchor(writer,
                        hasDefaultCommand ?
                        item.Index.ToString() :
                        String.Format(ShowMoreFormat, item.Index),
                        item[labelFieldIndex]);
                }
                else
                {
                    writer.WriteText(item[labelFieldIndex], true);
                }

                if (itemRequiresMoreButton)
                {
                    BooleanOption cachedItalic = subCommandStyle.Font.Italic;
                    subCommandStyle.Font.Italic = BooleanOption.False;
                    writer.EnterFormat(subCommandStyle);
                    writer.Write(" [");
                    writer.ExitFormat(subCommandStyle);
                    subCommandStyle.Font.Italic = cachedItalic;
                    writer.EnterFormat(subCommandStyle);
                    String moreText = Control.MoreText == String.Empty ?
                        GetDefaultLabel(MoreLabel) :
                        Control.MoreText;
                    writer.WriteBeginTag("a");
                    RenderPostBackEventAsAttribute(writer, "href", String.Format(ShowMoreFormat, item.Index));
                    writer.Write(">");
                    writer.WriteText(moreText, true);
                    writer.WriteEndTag("a");                  
                    writer.ExitFormat(subCommandStyle);
                    subCommandStyle.Font.Italic = BooleanOption.False;
                    writer.EnterFormat(subCommandStyle);
                    writer.Write("]");
                    writer.ExitFormat(subCommandStyle);
                    subCommandStyle.Font.Italic = cachedItalic;
                }
                
                if(i < (nextStartIndex - 1))
                {
                    writer.WriteBreak();            
                }
            }
            writer.ExitStyle(style, Control.BreakAfter);
        }

        protected virtual void RenderItemDetails(HtmlMobileTextWriter writer, ObjectListItem item)
        {
            if (Control.AllFields.Count == 0)
            {
                return;
            }
            if(Device.Tables)
            {
                RenderItemDetailsWithTableTags(writer, item);
            }
            else
            {
                RenderItemDetailsWithoutTableTags(writer, item); 
            }
        }

        private void RenderItemDetailsWithTableTags(HtmlMobileTextWriter writer, ObjectListItem item)
        {
            Style style = this.Style;
            Style labelStyle = Control.LabelStyle;
            Style subCommandStyle = Control.CommandStyle;
            Color foreColor = (Color)style[Style.ForeColorKey, true];

            writer.Write("<table border=0 width=\"100%\">\r\n<tr><td colspan=2>");
            writer.BeginStyleContext();
            writer.EnterStyle(labelStyle);
            writer.WriteText(item[Control.LabelFieldIndex], true);
            writer.ExitStyle(labelStyle);
            writer.EndStyleContext();
            writer.Write("</td></tr>\r\n<tr>");
            RenderRule(writer, foreColor, 2);

            IObjectListFieldCollection fields = Control.AllFields;
            int fieldIndex = 0;

            foreach (ObjectListField field in fields)
            {
                if (field.Visible)
                {
                    writer.Write("<tr><td>");
                    writer.BeginStyleContext();
                    writer.EnterStyle(Style);
                    writer.WriteText(field.Title, true);
                    writer.ExitStyle(Style);
                    writer.EndStyleContext();
                    writer.Write("</td><td>");
                    writer.BeginStyleContext();
                    writer.EnterStyle(style);
                    writer.WriteText(item[fieldIndex], true);
                    writer.ExitStyle(style);
                    writer.EndStyleContext();
                    writer.Write("</td></tr>\r\n");
                }
                fieldIndex++;
            }

            RenderRule(writer, foreColor, 2);

            writer.Write("<tr><td colspan=2>");
            writer.BeginStyleContext();
            BooleanOption cachedItalic = subCommandStyle.Font.Italic;
            subCommandStyle.Font.Italic = BooleanOption.False;
            writer.EnterStyle(subCommandStyle);
            writer.Write("[&nbsp;");
            writer.ExitStyle(subCommandStyle);
            subCommandStyle.Font.Italic = cachedItalic;
            writer.EnterStyle(subCommandStyle);

            ObjectListCommandCollection commands = Control.Commands;

            foreach (ObjectListCommand command in commands)
            {
                RenderPostBackEventAsAnchor(writer, command.Name, command.Text, subCommandStyle);
                writer.Write("&nbsp;|&nbsp;");
            }
            String backCommandText = Control.BackCommandText == String.Empty ?
                GetDefaultLabel(BackLabel) :
                Control.BackCommandText;

            RenderPostBackEventAsAnchor(writer, BackToList, backCommandText, subCommandStyle);
            writer.ExitStyle(subCommandStyle);
            subCommandStyle.Font.Italic = BooleanOption.False;
            writer.EnterStyle(subCommandStyle);
            writer.Write("&nbsp;]");
            writer.ExitStyle(subCommandStyle);
            subCommandStyle.Font.Italic = cachedItalic;

            writer.EndStyleContext();
            writer.Write("</td></tr></table>");
        }

        private void RenderItemDetailsWithoutTableTags(HtmlMobileTextWriter writer, ObjectListItem item)
        {
            Style style = this.Style;
            Style labelStyle = Control.LabelStyle;
            Style subCommandStyle = Control.CommandStyle;

            writer.EnterStyle(labelStyle);
            writer.WriteText(item[Control.LabelFieldIndex], true);
            writer.ExitStyle(labelStyle, true);

            IObjectListFieldCollection fields = Control.AllFields;
            int fieldIndex = 0;
            bool boldInStyle =
                (style.Font.Bold == BooleanOption.True) ? true : false;

            writer.EnterStyle(style);
            foreach (ObjectListField field in fields)
            {
                if (field.Visible)
                {
                    if (!boldInStyle)
                    {
                        writer.Write("<b>");
                    }
                    writer.WriteText(field.Title + ":", true);
                    if (!boldInStyle)
                    {
                        writer.Write("</b>");
                    }
                    writer.Write("&nbsp;");
                    writer.WriteText(item[fieldIndex], true);
                    writer.WriteBreak();
                }
                fieldIndex++;
            }
            writer.ExitStyle(style);

            BooleanOption cachedItalic = subCommandStyle.Font.Italic;
            subCommandStyle.Font.Italic = BooleanOption.False;
            writer.EnterStyle(subCommandStyle);
            writer.Write("[&nbsp;");
            writer.ExitStyle(subCommandStyle);
            subCommandStyle.Font.Italic = cachedItalic;
            writer.EnterStyle(subCommandStyle);

            ObjectListCommandCollection commands = Control.Commands;
            foreach (ObjectListCommand command in commands)
            {
                RenderPostBackEventAsAnchor(writer, command.Name, command.Text, subCommandStyle);
                writer.Write("&nbsp;|&nbsp;");
            }
            String backCommandText = Control.BackCommandText == String.Empty ?
                GetDefaultLabel(BackLabel) :
                Control.BackCommandText;

            RenderPostBackEventAsAnchor(writer, BackToList, backCommandText, subCommandStyle);
            writer.ExitStyle(subCommandStyle);
            subCommandStyle.Font.Italic = BooleanOption.False;
            writer.EnterStyle(subCommandStyle);
            writer.Write("&nbsp;]");
            writer.ExitStyle(subCommandStyle, Control.BreakAfter);
            subCommandStyle.Font.Italic = cachedItalic;
        }

        // Private overload for use with subcommands.
        // Style, Enter/ExitFormat included only for completeness because style
        // is already set for subcommands.
        private void RenderPostBackEventAsAnchor(
            HtmlMobileTextWriter writer,
            String argument,
            String linkText,
            Style style)
        {
            writer.EnterFormat(style);
            writer.WriteBeginTag("a");
            RenderPostBackEventAsAttribute(writer, "href", argument);
            writer.Write(">");
            writer.WriteText(linkText, true);
            writer.WriteEndTag("a");
            writer.ExitFormat(style);
        }

        private void RenderRule(HtmlMobileTextWriter writer, Color foreColor, int columnSpan)
        {
            writer.Write("<tr><td colspan=");
            writer.Write(columnSpan.ToString());
            writer.Write(" bgcolor=\"");
            writer.Write((foreColor != Color.Empty) ? ColorTranslator.ToHtml(foreColor) : "#000000");
            writer.Write("\"></td></tr>");
        }

        public override bool HandlePostBackEvent(String eventArgument)
        {
            switch (Control.ViewMode)
            {
                case ObjectListViewMode.List:

                    // DCR 2493 - raise a selection event, and only continue
                    // handling if asked to.

                    if (eventArgument.StartsWith(ShowMore))
                    {
                        int itemIndex = ParseItemArg(eventArgument);

                        if (Control.SelectListItem(itemIndex, true))
                        {
                            if (Control.SelectedIndex > -1)
                            {
                                // ObjectListViewMode.Commands and .Details same for HTML,
                                // but cannot access ObjLst.Details in Commands mode.
                                Control.ViewMode = ObjectListViewMode.Details;
                            }                    
                        }
                    }
                    else
                    {
                        int itemIndex = -1;
                        try
                        {
                            itemIndex = Int32.Parse(eventArgument);
                        }
                        catch (System.FormatException)
                        {
                            throw new Exception (SR.GetString(SR.ObjectListAdapter_InvalidPostedData));
                        }
                        if (Control.SelectListItem(itemIndex, false))
                        {
                            Control.RaiseDefaultItemEvent(itemIndex);
                        }
                    }
                    return true;

                case ObjectListViewMode.Commands:
                case ObjectListViewMode.Details:

                    if (eventArgument == BackToList)
                    {
                        Control.ViewMode = ObjectListViewMode.List;
                        return true;
                    }
                    break;
            }

            return false;
        }

        private static int ParseItemArg(String arg)
        {
            return Int32.Parse(arg.Substring(ShowMore.Length));
        }

        protected virtual bool ShouldRenderAsTable()
        {
            return true;
        }

        private BooleanOption _hasItemDetails = BooleanOption.NotSet;
        protected bool HasItemDetails()
        {
            if (_hasItemDetails == BooleanOption.NotSet)
            {
                // Calculate how many visible fields are shown in list view.

                int visibleFieldsInListView;
                int[] tableFieldIndices = Control.TableFieldIndices;
                if (ShouldRenderAsTable() && tableFieldIndices.Length != 0)
                {
                    visibleFieldsInListView = VisibleTableFieldsCount;
                    Debug.Assert (visibleFieldsInListView >= 0, "visibleFieldsInListView is negative");
                }
                else
                {
                    visibleFieldsInListView = Control.AllFields[Control.LabelFieldIndex].Visible ?
                                                    1 : 0;
                }


                // Calculate the number of visible fields.

                _hasItemDetails = BooleanOption.False;
                int visibleFieldCount = 0;
                foreach (ObjectListField field in Control.AllFields)
                {
                    if (field.Visible)
                    {
                        visibleFieldCount++;
                        if (visibleFieldCount > visibleFieldsInListView)
                        {
                            _hasItemDetails = BooleanOption.True;
                            break;
                        }
                    }
                }
            }

            return _hasItemDetails == BooleanOption.True;
        }

        protected bool HasCommands()
        {
            return Control.Commands.Count > 0;
        }

        protected bool HasDefaultCommand()
        {
            return Control.DefaultCommand.Length > 0;
        }

        private BooleanOption _onlyHasDefaultCommand = BooleanOption.NotSet;
        protected bool OnlyHasDefaultCommand()
        {
            if (_onlyHasDefaultCommand == BooleanOption.NotSet)
            {
                String defaultCommand = Control.DefaultCommand;
                if (defaultCommand.Length > 0)
                {
                    int commandCount = Control.Commands.Count;
                    if (commandCount == 0 ||
                        (commandCount == 1 &&
                            String.Compare(defaultCommand, Control.Commands[0].Name, true, CultureInfo.InvariantCulture) == 0))
                    {
                        _onlyHasDefaultCommand = BooleanOption.True;
                    }
                    else
                    {
                        _onlyHasDefaultCommand = BooleanOption.False;
                    }
                }
                else
                {
                    _onlyHasDefaultCommand = BooleanOption.False;
                }
            }

            return _onlyHasDefaultCommand == BooleanOption.True;
        }
        
        // This appears in both Html and Wml adapters, is used in
        // ShouldRenderAsTable().  In adapters rather than control
        // because specialized rendering method.
        private int _visibleTableFieldsCount = -1;
        private int VisibleTableFieldsCount
        {
            get
            {
                if (_visibleTableFieldsCount == -1)
                {
                    int[] tableFieldIndices = Control.TableFieldIndices;
                    _visibleTableFieldsCount = 0;
                    for (int i = 0; i < tableFieldIndices.Length; i++)
                    {
                        if (Control.AllFields[tableFieldIndices[i]].Visible)
                        {
                            _visibleTableFieldsCount++;
                        }
                    }
                }
                return _visibleTableFieldsCount;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlselectionlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlSelectionListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{
    /*
     * HtmlSelectionListAdapter provides the html device functionality for SelectionList controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlSelectionListAdapter : HtmlControlAdapter
    {
        protected new SelectionList Control
        {
            get
            {
                return (SelectionList)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            MobileListItemCollection items = Control.Items;
            ListSelectType selectType = Control.SelectType;

            if (items.Count == 0 && 
                selectType != ListSelectType.ListBox && 
                selectType != ListSelectType.MultiSelectListBox)
            {
                return;
            }
            
            int selectedIndex = Control.SelectedIndex;
            String renderName;
            if(Device.RequiresAttributeColonSubstitution)
            {
                renderName = Control.UniqueID.Replace(':', ',');
            }
            else
            {
                renderName = Control.UniqueID;
            }

            switch(selectType)
            {
                case ListSelectType.DropDown:
                case ListSelectType.ListBox:
                case ListSelectType.MultiSelectListBox:

                    if (items.Count == 0 && !Device.CanRenderEmptySelects)
                    {
                        break;
                    }

                    writer.EnterLayout(Style);
                    writer.WriteBeginTag("select");

                    if (selectType == ListSelectType.MultiSelectListBox)
                    {
                        writer.Write(" multiple");
                    }

                    if (selectType == ListSelectType.ListBox || selectType == ListSelectType.MultiSelectListBox)
                    {
                        writer.WriteAttribute("size", Control.Rows.ToString());
                    }

                    writer.WriteAttribute("name", renderName);
                    writer.Write(">");

                    for(int itemIndex = 0; itemIndex < items.Count; itemIndex++)
                    {
                        MobileListItem item = items[itemIndex];
                        writer.WriteBeginTag("option");
                        WriteItemValueAttribute(writer, itemIndex, item.Value);
                        if (item.Selected && (Control.IsMultiSelect || itemIndex == selectedIndex))
                        {
                            writer.Write(" selected>");
                        }
                        else
                        {
                            writer.Write(">");
                        }
                        writer.WriteEncodedText(item.Text);
                        writer.WriteLine("");
                    }
                    writer.Write("</select>");
            
                    if(Device.HidesRightAlignedMultiselectScrollbars &&
                        selectType == ListSelectType.MultiSelectListBox)
                    {
                        // nested if for perf
                        if((Alignment)Style[Style.AlignmentKey, true] == Alignment.Right)
                        {                                                
                            writer.Write("&nbsp;&nbsp;&nbsp;&nbsp;");
                        }
                    }
                    writer.WriteLine("");
                    
                    if (!Page.DesignMode)
                    {
                        writer.ExitLayout(Style, Control.BreakAfter);
                    }
                    else
                    {
                        writer.ExitLayout(Style, false);
                    }
                    break;

                case ListSelectType.Radio:
                case ListSelectType.CheckBox:

                    String selectTypeString =
                        (selectType == ListSelectType.Radio) ?
                        "radio" :
                        "checkbox";
                    Alignment alignment = (Alignment)Style[Style.AlignmentKey, true];
                    if(!Device.Tables || alignment == Alignment.Left || alignment == Alignment.NotSet)
                    {
                        writer.EnterStyle(Style);
                        bool breakAfter = false;
                        for(int itemIndex = 0; itemIndex < items.Count; itemIndex++)
                        {
                            if(breakAfter)
                            {
                                writer.WriteBreak();
                            }
                            MobileListItem item = items[itemIndex];

                            writer.WriteBeginTag("input");
                            writer.WriteAttribute("type", selectTypeString);
                            writer.WriteAttribute("name", renderName);
                            WriteItemValueAttribute(writer, itemIndex, item.Value);
                            if (item.Selected && 
                                (Control.IsMultiSelect || itemIndex == selectedIndex) &&
                                Device.SupportsUncheck)
                            {
                                writer.Write(" checked>");
                            }
                            else
                            {
                                writer.Write(">");
                            }
                            writer.WriteEncodedText(item.Text);
                            breakAfter = true;
                        }
                        writer.ExitStyle(Style, Control.BreakAfter);
                    }
                    else // Device supports tables and alignment is non default.
                    {
                        Wrapping  wrapping  = (Wrapping) Style[Style.WrappingKey , true];
                        bool nowrap = (wrapping == Wrapping.NoWrap);

                        writer.EnterLayout(Style);
                        writer.WriteFullBeginTag("table");
                        writer.BeginStyleContext();
                        for(int itemIndex = 0; itemIndex < items.Count; itemIndex++)
                        {
                            MobileListItem item = items[itemIndex];
                            writer.WriteFullBeginTag("tr");
                            writer.WriteBeginTag("td");
                            if(nowrap)
                            {
                                writer.WriteAttribute("nowrap","true");
                            }
                            writer.Write(">");

                            writer.WriteBeginTag("input");
                            writer.WriteAttribute("type", selectTypeString);
                            writer.WriteAttribute("name", renderName);
                            WriteItemValueAttribute(writer, itemIndex, item.Value);
                            if (item.Selected && 
                                (Control.IsMultiSelect || itemIndex == selectedIndex) &&
                                Device.SupportsUncheck)
                            {
                                writer.Write(" checked>");
                            }
                            else
                            {
                                writer.Write(">");
                            }

                            writer.MarkStyleContext();
                            writer.EnterFormat(Style);
                            writer.WriteEncodedText(item.Text);
                            writer.ExitFormat(Style);
                            writer.UnMarkStyleContext();
                            writer.WriteEndTag("td");
                            writer.WriteEndTag("tr");
                        }
                        writer.WriteEndTag("table");
                        writer.EndStyleContext();
                        writer.ExitFormat(Style, Control.BreakAfter);
                    }
                break;
            }
        }

        // Parse the HTML posted data appropriately.
        public override bool LoadPostData(String key,
                                          NameValueCollection data,
                                          Object controlPrivateData,
                                          out bool dataChanged)
        {
            String[] selectedItems = data.GetValues(key);
            Debug.Assert (Control.Form.Action == String.Empty, 
                "Cross page post (!IsPostBack) assumed when Form.Action nonempty." +
                "LoadPostData should not have been be called.");

            // If no post data is included, and the control is either not visible, or
            // not on active form, this call should be ignored (the lack of post data 
            // is not due to there being no selection, but due to there being no 
            // markup rendered that could generate the post data).

            if (selectedItems == null && 
                    (!Control.Visible || Control.Form != Control.MobilePage.ActiveForm))
            {
                dataChanged = false;
                return true;
            }

            // Case where nothing is selected.
            if(selectedItems == null ||
               (selectedItems.Length == 1 && selectedItems[0] == String.Empty))
            {
                selectedItems = new String[]{};
            }

            int[] selectedItemIndices = new int[selectedItems.Length];

            // Note: controlPrivateData is selected indices from the viewstate.
            int[] originalSelectedIndices = (int[])controlPrivateData;
            dataChanged = false;

            // If SelectType is DropDown && nothing was selected, select
            // first elt.  (Non-mobile DropDown does same by getting SelectedIndex).
            if(Control.SelectType == ListSelectType.DropDown &&
               originalSelectedIndices.Length == 0 &&
               Control.Items.Count > 0)
            {
                Control.Items[0].Selected = true;
                originalSelectedIndices = new int[]{0};
            }

            for(int i = 0; i < selectedItems.Length; i++)
            {
                selectedItemIndices[i] = Int32.Parse(selectedItems[i]);
            }

            // Do not assume posted selected indices are ascending.
            // We do know originalSelectedIndices are ascending.
            Array.Sort(selectedItemIndices);

            // Check whether selections have changed.
            if(selectedItemIndices.Length != originalSelectedIndices.Length)
            {
                dataChanged = true;
            }
            else
            {
                for(int i = 0; i < selectedItems.Length; i++)
                {
                    if(selectedItemIndices[i] != originalSelectedIndices[i])
                    {
                        dataChanged = true;
                    }
                }
            }

            for (int i = 0; i < Control.Items.Count; i++)
            {
                Control.Items[i].Selected = false;
            }

            for(int i = 0; i < selectedItemIndices.Length; i++)
            {
                Control.Items[selectedItemIndices[i]].Selected = true;
            }
            return true;
        }

        private void WriteItemValueAttribute(HtmlTextWriter writer, int index, String value)
        {
            if (Page.DesignMode || Control.Form.Action == String.Empty)
            {
                writer.WriteAttribute("value", index.ToString());
            }
            else
            {
                writer.WriteAttribute("value", value, true /*encode*/);
            }
        }

        protected override void RenderAsHiddenInputField(HtmlMobileTextWriter writer)
        {
            // Optimization - if viewstate is enabled for this control, and the
            // postback returns to this page, we just let it do the trick.
            // One catch though - if the control is multiselect, it always 
            // interprets return values, so we do need to write out.

            if (Control.IsMultiSelect || Control.Form.Action.Length > 0 || !IsViewStateEnabled())
            {
                String uniqueID = Control.UniqueID;
                MobileListItemCollection items = Control.Items;
                for (int i = 0; i < items.Count; i++)
                {
                    if (items[i].Selected)
                    {
                        writer.WriteHiddenField(uniqueID, i.ToString());
                    }
                }
            }
        }

        private bool IsViewStateEnabled()
        {
            Control ctl = Control;
            while (ctl != null)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
                ctl = ctl.Parent;
            }
            return true;
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmltextviewadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTextViewAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlTextViewAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTextViewAdapter : HtmlControlAdapter
    {
        protected new TextView Control
        {
            get
            {
                return (TextView)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            int beginElement = Control.FirstVisibleElementIndex;
            int beginOffset = Control.FirstVisibleElementOffset;
            int endElement = Control.LastVisibleElementIndex;
            int endOffset = Control.LastVisibleElementOffset;

            writer.EnterStyle(Style);
            for (int i = beginElement; i <= endElement; i++)
            {
                int begin = (i == beginElement) ? beginOffset : 0;
                int end;
                if (i == endElement)
                {
                    if (endOffset <= begin)
                    {
                        break;
                    }
                    end = endOffset;
                }
                else
                {
                    end = -1;
                }

                RenderElement(writer, i, begin, end);
            }
            writer.ExitStyle(Style, Control.BreakAfter);
        }

        private void RenderElement(HtmlMobileTextWriter writer, int index, int begin, int end)
        {
            TextViewElement element = Control.GetElement(index);
            if (end == -1)
            {
                end = element.Text.Length;
            }

            String text = element.Text;
            if (begin > 0 || end < text.Length)
            {
                text = text.Substring(begin, end - begin);
            }

            BooleanOption previousBold   = Style.Font.Bold;
            BooleanOption previousItalic = Style.Font.Italic;
            if (element.IsBold)
            {
                Style.Font.Bold = BooleanOption.True;
            }
            if (element.IsItalic)
            {
                Style.Font.Italic = BooleanOption.True;
            }
            
            writer.EnterStyle(Style);
            if (element.Url != null)
            {
                RenderBeginLink(writer, element.Url);
                writer.WriteText(text, true);
                RenderEndLink(writer);
            }
            else
            {
                writer.WriteText(text, true);
            }
            writer.ExitStyle(Style, element.BreakAfter);

            Style.Font.Bold   = previousBold;
            Style.Font.Italic = previousItalic;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlmobiletextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlMobileTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.IO;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Collections;
using System.Diagnostics;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{

    /*
     * HtmlMobileTextWriter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlMobileTextWriter : MobileTextWriter
    {
        private bool _shouldEnsureStyle = true;

        //  mobile device type constants (should be defined somewhere else eventually)
        internal WriterState _currentState;

        public HtmlMobileTextWriter(TextWriter writer, MobileCapabilities device)
            : base(writer, device)
        {
            RenderBold = device.SupportsBold;
            RenderItalic = device.SupportsItalic;
            RenderFontSize = device.SupportsFontSize;
            RenderFontName = device.SupportsFontName;
            RenderFontColor = device.SupportsFontColor;
            RenderBodyColor = device.SupportsBodyColor;
            RenderDivAlign = device.SupportsDivAlign;
            RenderDivNoWrap = device.SupportsDivNoWrap;
            RequiresNoBreakInFormatting = device.RequiresNoBreakInFormatting;
            _currentState = new WriterState(this);
        }

        /*
         * the following TextWriter methods are overridden to 
         * first call EnsureStyle before delegating to the base 
         * class implementation 
         */
        public override void WriteBeginTag(String tag)
        {
            EnsureStyle();
            base.WriteBeginTag(tag);
        }
        public override void WriteFullBeginTag(String tag)
        {
            EnsureStyle();
            base.WriteFullBeginTag(tag);
        }
        public override void Write(char c)
        {
            EnsureStyle();
            base.Write(c);
        }
        public override void Write(String text)
        {
            EnsureStyle();
            base.Write(text);
        }
        public override void WriteEncodedText(String text)
        {
            EnsureStyle();
            if(Device["supportsCharacterEntityEncoding"] != "false") {
                base.WriteEncodedText(text);
                return;
            }
            if (null == text || String.Empty == text) {
                return;
            }

            int length = text.Length;
            int start = -1;
            for(int pos = 0; pos < length; pos++) {
                int ch = text[pos];
                if(ch > 160 && ch < 256) {
                    if(start != -1) {
                        base.WriteEncodedText(text.Substring(start, pos - start));
                        start = -1;
                    }
                    base.Write(text[pos]);
                }
                else {
                    if(start == -1) {
                        start = pos;
                    }
                }
            }
            if(start != -1) {
                if(start == 0) {
                    base.WriteEncodedText(text);
                }
                else {
                    base.WriteEncodedText(text.Substring(start, length - start));
                }
            }
        }

        public override void WriteLine(String text)
        {
            EnsureStyle();
            base.WriteLine(text);
        }

        public void WriteBreak()
        {
            //Do not EnsureStyle for the break
            base.WriteLine("<br>");
        }

        public override void EnterLayout(Style style)
        {
            WriterStyle writerStyle = new WriterStyle(style);
            writerStyle.Format = false;
            EnterStyle(writerStyle);
        }

        public override void ExitLayout(Style style, bool breakAfter)
        {
            ExitStyle(style, breakAfter);
        }

        public override void ExitLayout(Style style)
        {
            ExitStyle(style, false);
        }

        protected internal void MarkStyleContext()
        {
            _shouldEnsureStyle = true;
            _currentState.MarkStyleContext();
        }

        protected internal void UnMarkStyleContext()
        {
            _shouldEnsureStyle = true;
            _currentState.UnMarkStyleContext();
        }

        public override void EnterFormat(Style style)
        {
            WriterStyle writerStyle = new WriterStyle(style);
            writerStyle.Layout = false;
            EnterStyle(writerStyle);
        }                                                                   

        public override void ExitFormat(Style style)
        {
            ExitStyle(style);
        }

        public override void ExitFormat(Style style, bool breakAfter)
        {
            ExitStyle(style, breakAfter);
        }

        public void BeginStyleContext()
        {
            if(_currentState.BreakPending)
            {
                WriteBreak();
                _currentState.BreakPending = false;
            }
            _currentState.PushState();
            EnterStyle(new WriterStyle());
        }

        public void EndStyleContext()
        {
            if(_currentState.BreakPending)
            {
                WriteBreak();
                _currentState.BreakPending = false;
            }
            _currentState.PopState();
            _currentState.Pop();
            _currentState.Transition(new WriterStyle());
        }

        /* all calls to Enter... converge to this */
        private void EnterStyle(WriterStyle style)
        {
            _currentState.Push(style);
        }

        public new void EnterStyle(Style style)
        {
            EnterStyle(new WriterStyle(style));
        }

        public new void ExitStyle(Style style)
        {
            ExitStyle(style, false);

        }

        internal bool ShouldEnsureStyle
        {
            get
            {
                return _shouldEnsureStyle;
            }
            set
            {
                _shouldEnsureStyle = value;
            }
        }

        /*
        all calls to Exit... converge to this 
        */
        public void ExitStyle(Style style, bool breakAfter)
        {
            _currentState.Pop();
            if((_currentState.BreakPending) && (_currentState.Count > 0))
            {
                EnsureStyle();
            }
            _currentState.BreakPending = breakAfter;
            if((_currentState.Count == 0) || (RequiresNoBreakInFormatting))
            {
                _currentState.Transition(new WriterStyle());
            }
            InputWritten = false;
        }

        internal bool _inputWritten = false;
        internal bool InputWritten
        {
            get { return _inputWritten; }
            set { _inputWritten = value; }
        }

        internal void EnsureStyle()
        {
            if (_shouldEnsureStyle)
            {
                if(_currentState.Count > 0)
                {
                    _currentState.Transition(_currentState.Peek());
                }
                _shouldEnsureStyle = false;
            }
            if(BeforeFirstControlWritten)
            {
                BeforeFirstControlWritten = false;
            }
        }

        public void WriteText(String text, bool encodeText)
        {
            if(text == String.Empty)
            {
                return;
            }
            EnsureStyle();
            if (encodeText)
            {
                WriteEncodedText(text);
            }
            else
            {
                Write(text);
            }
        }

        public void WriteUrlParameter(String name, String value)
        {
            WriteEncodedUrlParameter(name);
            Write("=");
            WriteEncodedUrlParameter(value);
        }

        public void WriteHiddenField(String name, String value)
        {
            WriteBeginTag("input");
            WriteAttribute("type", "hidden");
            WriteAttribute("name", name);
            WriteAttribute("value", value, true);
            Write(">\r\n");
        }


        // AUI 2285
        private bool _beforeFirstControlWritten = true;
        internal bool BeforeFirstControlWritten
        {
            get
            {
                return _beforeFirstControlWritten;
            }

            set
            {
                _beforeFirstControlWritten = value;
            }
        }

        private bool _maintainState = true;

        internal bool MaintainState
        {
            get
            {
                return _maintainState;
            }
            set
            {
                _maintainState = value;
            }
        }

        protected internal bool RenderBold
        {
            get
            {
                return _renderBold;
            }
            set
            {
                _renderBold = value;
            }
        }

        protected internal bool RenderItalic
        {
            get
            {
                return _renderItalic;
            }
            set
            {
                _renderItalic = value;
            }
        }

        protected internal bool RenderFontSize
        {
            get
            {
                return _renderFontSize;
            }
            set
            {
                _renderFontSize = value;
            }
        }

        protected internal bool RenderFontName
        {
            get
            {
                return _renderFontName;
            }

            set
            {
                _renderFontName = value;
            }
        }

        protected internal bool RenderFontColor
        {
            get
            {
                return _renderFontColor;
            }
            set
            {
                _renderFontColor = value;
            }
        }

        protected internal bool RenderBodyColor
        {
            get
            {
                return _renderBodyColor;
            }
            set
            {
                _renderBodyColor = value;
            }
        }

        protected internal bool RenderDivAlign
        {
            get
            {
                return _renderDivAlign;
            }
            set
            {
                _renderDivAlign = value;
            }
        }

        protected internal bool RenderDivNoWrap
        {
            get
            {
                return _renderDivNoWrap;
            }
            set
            {
                _renderDivNoWrap = value;
            }
        }

        protected internal bool RequiresNoBreakInFormatting
        {
            get
            {
                return _requiresNoBreakInFormatting;
            }
            set
            {
                _requiresNoBreakInFormatting = value;
            }
        }

        private bool _renderBold = true;
        private bool _renderItalic = true;
        private bool _renderFontSize = true;
        private bool _renderFontName = true;
        private bool _renderFontColor = true;
        private bool _renderBodyColor = true;
        private bool _renderDivAlign = true;
        private bool _renderDivNoWrap = false;
        private bool _requiresNoBreakInFormatting = false;
    }

    /*
     * the WriterStyle class is used to store and
     * control state for rendering format and layout
     */
    internal class WriterStyle
    {
        private Wrapping    _wrapping;
        private Alignment   _alignment;
        private String      _fontName;
        private Color       _fontColor;
        private FontSize    _fontSize;
        private bool        _bold;
        private bool        _italic;

        private bool _format;
        private bool _layout;

        internal WriterStyle()
        {
            _wrapping = Wrapping.Wrap;
            _alignment = Alignment.Left;
            _fontName = String.Empty;
            _fontColor = Color.Empty;
            _fontSize = FontSize.Normal;
            _bold = false;
            _italic = false;

            _format = true;
            _layout = true;
        }

        internal WriterStyle(Style style)
        {
            Debug.Assert(style != null, "writer style is null");
            _alignment = (Alignment)         style[Style.AlignmentKey, true];
            if(_alignment == Alignment.NotSet)
            {
                _alignment = Alignment.Left;
            }
            _wrapping = (Wrapping)           style[Style.WrappingKey, true];
            if(_wrapping == Wrapping.NotSet)
            {
                _wrapping = Wrapping.Wrap;
            }

            _fontSize  = (FontSize)         style[Style.FontSizeKey , true];
            if(_fontSize == FontSize.NotSet)
            {
                _fontSize = FontSize.Normal;
            }
            _fontName  = (String)           style[Style.FontNameKey , true];
            _fontColor = (Color)            style[Style.ForeColorKey, true]; 

            _bold = ((BooleanOption)        style[Style.BoldKey, true] == BooleanOption.True);
            _italic = ((BooleanOption)      style[Style.ItalicKey, true] == BooleanOption.True);

            _format = true;
            _layout = true;

        }


        internal bool Format
        {
            get { return _format; }
            set { _format = value; }
        }

        internal bool Layout
        {
            get { return _layout; }
            set { _layout = value; }
        }

        internal Wrapping Wrapping
        {
            get { return _wrapping; }
            set { _wrapping = value; }
        }
        internal Alignment Alignment
        {
            get { return _alignment; }
            set { _alignment = value; }
        }
        internal String FontName
        {
            get { return _fontName; }
            set { _fontName = value; }
        }
        internal Color FontColor
        {
            get { return _fontColor; }
            set { _fontColor = value; }
        }
        internal FontSize FontSize
        {
            get { return _fontSize; }
            set { _fontSize = value; }
        }
        internal bool Bold
        {
            get { return _bold; }
            set { _bold = value; }
        }
        internal bool Italic
        {
            get { return _italic; }
            set { _italic = value; }
        }
    }

    /*
     * The StyleTag class is extended for specific tags
     */
    internal abstract class StyleTag
    {
        private int _level = -1;

        internal StyleTag() 
        {
        }
        internal StyleTag(int level)
        {
            _level = level;
        }

        internal virtual int Level
        {
            get
            {
                return _level;
            }
            set
            {
                _level = value;
            }
        }

        internal abstract void CloseTag(WriterState state);
    }

    internal class BoldStyleTag : StyleTag
    {
        internal BoldStyleTag(int level) : base(level)
        {
        }

        internal override void CloseTag(WriterState state)
        {
            state.Writer.WriteEndTag("b");
            state.Current.Bold = false;
        }
    }

    internal class ItalicStyleTag : StyleTag
    {
        internal ItalicStyleTag(int level) : base(level)
        {
        }

        internal override void CloseTag(WriterState state)
        {
            state.Writer.WriteEndTag("i");
            state.Current.Italic = false;
        }
    }

    internal class FontStyleTag : StyleTag
    {
        private String _name;
        private Color _color;
        private FontSize _size;

        internal FontStyleTag(int level) : base(level)
        {
            _name = String.Empty;
            _color = Color.Empty;
            _size = FontSize.Normal;
        }

        internal FontStyleTag(int level, String name, Color color, FontSize size) : base(level)
        {
            Name = _name;
            Color = color;
            FontSize = size;
        }

        internal String Name
        {
            get { return _name; }
            set { _name = value; }
        }
        internal Color Color
        {
            get { return _color; }
            set { _color = value; }
        }
        internal FontSize FontSize
        {
            get { return _size; }
            set { _size = value; }
        }

        internal override void CloseTag(WriterState state)
        {
            state.Writer.WriteEndTag("font");
            //reset FontLevel and rebuild state info
            state.FontLevel = -1;
            state.Current.FontColor = Color.Empty;
            state.Current.FontName = String.Empty;
            state.Current.FontSize = FontSize.Normal;

            //reset the FontLevel
            Stack tmpStack = new Stack();
            while(state.TagsWritten.Count > 0)
            {
                Object o = state.TagsWritten.Pop();
                tmpStack.Push(o);
                if(o is FontStyleTag)
                {
                    state.FontLevel = ((FontStyleTag)o).Level;
                    break;
                }
            }

            while(tmpStack.Count > 0)
            {
                state.TagsWritten.Push(tmpStack.Pop());
            }

            //there is a font tag in the stack
            if(state.FontLevel > -1)
            {
                if(Color != Color.Empty)
                {
                    //reset font color to something further down the stack
                    Stack tempStack = new Stack();
                    while(state.TagsWritten.Count > 0)
                    {
                        Object o = state.TagsWritten.Pop();
                        tempStack.Push(o);
                        if(o is FontStyleTag)
                        {
                            if(((FontStyleTag)o).Color != Color.Empty)
                            {
                                state.Current.FontColor = ((FontStyleTag)o).Color;
                                break;
                            }
                        }
                    }
                    while(tempStack.Count > 0)
                    {
                        state.TagsWritten.Push(tempStack.Pop());
                    }
                }
                if(Name != String.Empty)
                {
                    //reset font name to something futher down the stack
                    Stack tempStack = new Stack();
                    while(state.TagsWritten.Count > 0)
                    {
                        Object o = state.TagsWritten.Pop();
                        tempStack.Push(o);
                        if(o is FontStyleTag)
                        {
                            if(((FontStyleTag)o).Name != String.Empty)
                            {
                                state.Current.FontName = ((FontStyleTag)o).Name;
                                break;
                            }
                        }
                    }
                    while(tempStack.Count > 0)
                    {
                        state.TagsWritten.Push(tempStack.Pop());
                    }
                }
                    //reset font size to something further down the stack
                while(state.TagsWritten.Count > 0)
                {
                    Object o = state.TagsWritten.Pop();
                    tmpStack.Push(o);
                    if (o is FontStyleTag)
                    {
                        if(((FontStyleTag)o).FontSize != FontSize.Normal)
                        {
                            state.Current.FontSize = ((FontStyleTag)o).FontSize;
                            break;
                        }
                    }
                }
                while(tmpStack.Count > 0)
                {
                    state.TagsWritten.Push(tmpStack.Pop());
                }
            }
        }
    }

    internal class DivStyleTag : StyleTag
    {
        private Wrapping _wrapping;
        private Alignment _alignment;
        private bool _alignWritten;
        internal DivStyleTag(int level) : base(level)
        {
            _wrapping = Wrapping.Wrap;
            _alignment = Alignment.Left;
            _alignWritten = false;
        }

        internal Wrapping Wrapping
        {
            get { return _wrapping; }
            set { _wrapping = value; }
        }
        internal Alignment Alignment
        {
            get { return _alignment; }
            set { _alignment = value; }
        }
        internal bool AlignmentWritten
        {
            get { return _alignWritten; }
            set { _alignWritten = value; }
        }

        internal override void CloseTag(WriterState state)
        {
            state.Writer.WriteEndTag("div");
            state.BreakPending = false;

            //reset current div info and rebuild
            state.DivLevel = -1;
            state.Current.Alignment = Alignment.Left;
            state.Current.Wrapping = Wrapping.Wrap;
            Stack tempStack = new Stack();
            //reset alignment : ideally these resets could be combined
            //in practice, the number of items on the stack is small
            //so it may be comparable


            //reset wrapping
            while(state.TagsWritten.Count > 0)
            {
                Object o = state.TagsWritten.Pop();
                tempStack.Push(o);
                if(o is DivStyleTag)
                {
                    if(((DivStyleTag)o).Wrapping == Wrapping.NoWrap)
                    {
                        state.Current.Wrapping = Wrapping.NoWrap;
                        break;
                    }
                }
            }
            while(tempStack.Count > 0)
            {
                state.TagsWritten.Push(tempStack.Pop());
            }

            //reset alignment
            while(state.TagsWritten.Count > 0)
            {
                Object o = state.TagsWritten.Pop();
                tempStack.Push(o);
                if(o is DivStyleTag)
                {
                    if(((DivStyleTag)o).Alignment != Alignment.NotSet)
                    {
                        state.Current.Alignment = ((DivStyleTag)o).Alignment;
                        break;
                    }
                }
            }
            while(tempStack.Count > 0)
            {
                state.TagsWritten.Push(tempStack.Pop());
            }

            //reset divLevel
            while(state.TagsWritten.Count > 0)
            {
                Object o = state.TagsWritten.Pop();
                tempStack.Push(o);
                if(o is DivStyleTag)
                {
                    state.DivLevel = ((DivStyleTag)o).Level;
                    break;
                }
            }
            while(tempStack.Count > 0)
            {
                state.TagsWritten.Push(tempStack.Pop());
            }
        }
    }

    /*
     * the StyleStack class maintains WriterStyle objects
     * pushed on the stack from Enter[Style/Format/Layout]
     * and removed using Exit[Style/Format/Layout]
     */
    internal class StyleStack
    {
        private HtmlMobileTextWriter _writer;
        private Stack _stack;

        protected StyleStack(HtmlMobileTextWriter writer)
        {
            _writer = writer;
            _stack = new Stack();
        }

        internal void Push(WriterStyle style)
        {
            _stack.Push(style);
            _writer.ShouldEnsureStyle = true;
        }

        internal WriterStyle Pop()
        {
            _writer.ShouldEnsureStyle = true;
            return (WriterStyle)_stack.Pop();
        }

        internal WriterStyle Peek()
        {
            if(_stack.Count == 0)
            {
                return new WriterStyle(); //retrieves default values
            }
            return (WriterStyle)_stack.Peek();
        }

        internal int Count
        {
            get
            {
                return _stack.Count;
            }
        }
    }

    /* the WriterState tracks what styles have been entered, what tags have been written
        and controls transitions from the current state to a desired state
    */
    internal class WriterState : StyleStack
    {
        private bool _inTransition = false; //prevent recursion
        private Stack _stack;  //stack of WriterStyle objects
        private Stack _tagsWritten; //stack of StyleTag objects for written tags
        private bool _breakPending = false; //track if we owe a <br>

        private WriterStyle _current; //the current style
        private HtmlMobileTextWriter _writer; //the output stream

        private int _fontLevel = -1;
        private int _divLevel = -1;
        
        private int _mark = 0;

        internal WriterState(HtmlMobileTextWriter writer) : base(writer)
        {
            _writer = writer;
            _stack = new Stack();
            _current = new WriterStyle();
            _tagsWritten = new Stack();
        }

        internal WriterStyle Current
        {
            get
            {
                return _current;
            }
        }

        /*
        Pushes the current WriterStyle and tagsWritten stack for later use,
        starts using a new default WriterStyle
        */
        internal void PushState()
        {
            _writer.ShouldEnsureStyle = true;
            _stack.Push(_current);
            _current = new WriterStyle();
            _stack.Push(_tagsWritten);
            _tagsWritten = new Stack();
            _stack.Push(BreakPending);
            BreakPending = false;

        }

        internal int FontLevel 
        {
            get { return _fontLevel; }
            set { _fontLevel = value; }
        }

        internal int DivLevel
        {
            get { return _divLevel; }
            set { _divLevel = value; }
        }

        /*
        Pops the last WriterStyle pushed and makes it current
        and restores the tagsWritten stack
        */
        internal WriterStyle PopState()
        {
            _writer.ShouldEnsureStyle = true;
            BreakPending = (bool)_stack.Pop();
            //close all open tags
            while(_tagsWritten.Count > 0)
            {
                CloseTag();
            }
            _tagsWritten = (Stack)_stack.Pop();
            _current = (WriterStyle)_stack.Pop();
            return _current;
        }

        /*
        BreakPending property accessor
        */
        internal bool BreakPending
        {
            get { return _breakPending; }
            set { _breakPending = value; }
        }

        internal HtmlTextWriter Writer
        {
            get
            {
                return _writer;
            }
        }

        internal Stack TagsWritten
        {
            get
            {
                return _tagsWritten;
            }
        }



        /*
        pop a tag from the stack of StyleTags,
        adjust state accordingly
        */
        internal void CloseTag()
        {
            StyleTag tag = (StyleTag)_tagsWritten.Pop();
            tag.CloseTag(this);
        }

        internal void MarkStyleContext()
        {
            _mark = _tagsWritten.Count;
        }

        internal void UnMarkStyleContext()
        {
            while(_tagsWritten.Count > _mark)
            {
                CloseTag();
            }
        }

        private bool FontChange(WriterStyle newStyle)
        {
            return (
            (( _current.FontColor != newStyle.FontColor ) && (_writer.RenderFontColor)) ||
             (( _current.FontSize != newStyle.FontSize ) && (_writer.RenderFontSize)) ||
             (( _current.FontName != newStyle.FontName ) && (_writer.RenderFontName))
            );
        }

        private bool DivChange(WriterStyle newStyle)
        {
            return (
             (newStyle.Layout) &&
             (((newStyle.Wrapping != _current.Wrapping) && (_writer.RenderDivNoWrap)) ||
              ((newStyle.Alignment != _current.Alignment) && (_writer.RenderDivAlign)) )
             );
        }

        internal void Transition(WriterStyle newStyle)
        {
            Transition(newStyle, true);
        }

        private const String _pocketPC = "Pocket IE";

        internal void Transition(WriterStyle newStyle, bool captureOutput)
        {
            HtmlMobileTextWriter tempWriter = _writer;
            try
            {
                if(!captureOutput)
                {
                    tempWriter = _writer;
                    _writer = new HtmlMobileTextWriter(
                        new HtmlTextWriter(new StringWriter()), tempWriter.Device);
                }

                if(_inTransition)
                {
                    return;
                }
                else
                {
                    _inTransition = true;
                }

                if(Count == 0)
                {
                    while(_tagsWritten.Count > 0)
                    {
                        CloseTag();
                    }
                    _inTransition= false;
                    return;
                }

                //close italic if target format !italic
                if(( _current.Italic && !newStyle.Italic ) && (_writer.RenderItalic))
                {
                    while(_current.Italic)
                    {
                        CloseTag();
                    }
                }

                //close bold if target format !bold
                if(( _current.Bold && !newStyle.Bold ) && (_writer.RenderBold))
                {
                    while(_current.Bold)
                    {
                        CloseTag();
                    }
                }

                //if the target FontColor is Color.Empty, then we need to 
                //close all open color tags
                if(
                    (newStyle.FontColor == Color.Empty) && 
                    (_current.FontColor != Color.Empty) && 
                    (_writer.RenderFontColor) )
                {
                    while(_current.FontColor != Color.Empty)
                    {
                        CloseTag();
                    }
                }

                //if the target FontName is String.Empty, then we need to
                //close all open name tags
                if(
                    (newStyle.FontName == String.Empty) && 
                    (_current.FontName != String.Empty) && 
                    (_writer.RenderFontName) )
                {
                    while(_current.FontName != String.Empty)
                    {
                        CloseTag();
                    }
                }

                //close the font if it is of the same or a later generation
                //and differs

                bool newFont = FontChange(newStyle);

                if(newFont)
                {
                    while( FontLevel >= Count )
                    {
                        CloseTag();
                    }
                }

                //if the new wrapping is Wrap, and the current is NoWrap
                //the outer NoWrap must be removed
                if(
                    (newStyle.Wrapping == Wrapping.Wrap) && 
                    (_current.Wrapping == Wrapping.NoWrap) && 
                    (_writer.RenderDivNoWrap) )
                {
                    while(_current.Wrapping != Wrapping.Wrap)
                    {
                        CloseTag();
                    }
                }
                //if the alignment differs for the same generation, close any divs at this level
                if(( newStyle.Alignment != _current.Alignment ) && ( _writer.RenderDivAlign))
                {
                    while( DivLevel >= Count )
                    {
                        CloseTag();
                    }
                }

                //determine if we will be opening a div before writing any break
                bool newDiv = DivChange(newStyle);

                //an opening div will function as a logical break
                if((BreakPending) && (!(newDiv)))  
                {
                    ((HtmlMobileTextWriter)_writer).WriteBreak();
                    BreakPending = false;
                }

                if(newDiv)
                {
                    while(_current.Bold || _current.Italic || (FontLevel == Count))
                    {
                        CloseTag();
                    }
                }

                newFont = FontChange(newStyle);
                newDiv = DivChange(newStyle);

                //open div
                if(newDiv && newStyle.Layout)
                {
                    DivStyleTag div = new DivStyleTag(Count);
                    BreakPending = false;
                    if(
                        ((_writer.BeforeFirstControlWritten) || (_writer.InputWritten)) &&
                        (_writer.Device.Type == _pocketPC) &&
                        (_writer.Device.MinorVersion == 0) &&
                        (_writer.Device.MajorVersion == 4) &&
                        (newStyle.Alignment != _current.Alignment) )
                    {
                        _writer.WriteBreak();
                        _writer.InputWritten = false;
                    }

                        
                    _writer.WriteBeginTag("div");
                    DivLevel = Count;

                    if(newStyle.Wrapping == Wrapping.NoWrap)
                    {
                        if(_writer.RenderDivNoWrap)
                        {
                            _writer.Write(" nowrap");
                        }
                        div.Wrapping = Wrapping.NoWrap;
                        _current.Wrapping = Wrapping.NoWrap;
                    }
                    else
                    {
                        div.Wrapping = Wrapping.Wrap;
                        _current.Wrapping = Wrapping.Wrap;
                    }

                    if(newStyle.Alignment != _current.Alignment)
                    {
                        if(_writer.RenderDivAlign)
                        {
                            _writer.WriteAttribute(
                                "align", 
                                Enum.GetName(typeof(Alignment), newStyle.Alignment));
                        }
                        _current.Alignment = newStyle.Alignment;
                        div.Alignment = newStyle.Alignment;
                        div.AlignmentWritten = true;
                    }
                    _tagsWritten.Push(div);
                    _writer.Write(">");
                }

                //open font
                if(newFont && newStyle.Format)
                {
                    FontStyleTag fontTag = new FontStyleTag(Count);
                    _writer.WriteBeginTag("font");
                    if(_current.FontSize != newStyle.FontSize)
                    {
                        String relativeSize;
                        if(newStyle.FontSize == FontSize.Large)
                        {
                            relativeSize = (
                               ((HtmlMobileTextWriter)_writer).Device.Type == _pocketPC) ? "+2" : "+1";
                            _current.FontSize = FontSize.Large;
                            fontTag.FontSize = FontSize.Large;
                        }
                        else if(newStyle.FontSize == FontSize.Small)
                        {
                            relativeSize = "-1";
                            _current.FontSize = FontSize.Small;
                            fontTag.FontSize = FontSize.Small;
                        }
                        else //(newStyle.FontSize == FontSize.Normal)
                        {
                            relativeSize = "+0";
                            _current.FontSize = FontSize.Normal;
                            fontTag.FontSize = FontSize.Normal;
                        }
                        if(_writer.RenderFontSize)
                        {
                            _writer.WriteAttribute("size", relativeSize);
                        }
                    }

                    if(_current.FontColor != newStyle.FontColor)
                    {
                        if(_writer.RenderFontColor)
                        {
                            _writer.WriteAttribute(
                                "color", 
                                ColorTranslator.ToHtml(newStyle.FontColor));
                        }
                        _current.FontColor = newStyle.FontColor;
                        fontTag.Color = newStyle.FontColor;
                    }
                    if(_current.FontName != newStyle.FontName)
                    {
                        if(_writer.RenderFontName)
                        {
                            _writer.WriteAttribute("face", newStyle.FontName);
                        }
                        _current.FontName = newStyle.FontName;
                        fontTag.Name = newStyle.FontName;
                    }
                    _writer.Write(">");
                    _tagsWritten.Push(fontTag);
                    FontLevel = Count;
                }

                //open bold
                if(newStyle.Format)
                {
                    if( newStyle.Bold && !_current.Bold && _writer.RenderBold )
                    {
                        _writer.WriteFullBeginTag("b");
                        _current.Bold = true;
                        _tagsWritten.Push(new BoldStyleTag(Count));
                    }

                    //open italic
                    if( newStyle.Italic && !_current.Italic && _writer.RenderItalic )
                    {
                        _writer.WriteFullBeginTag("i");
                        _current.Italic = true;
                        _tagsWritten.Push(new ItalicStyleTag(Count));
                    }
                }
                _inTransition = false;
            }
            finally
            {
                _writer = tempWriter;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlpaneladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlPanelAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlPanelAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlPanelAdapter : HtmlControlAdapter
    {
        protected new Panel Control
        {
            get
            {
                return (Panel)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
        }       

        public override void Render(HtmlMobileTextWriter writer)
        {
            if (Control.Content != null)
            {
                Control.Content.RenderControl(writer);
            }
            else
            {
                writer.EnterStyle(Style);
                RenderChildren(writer);
                writer.ExitStyle(Style, Control.BreakAfter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlphonecalladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlPhoneCallAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlPhoneCallAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlPhoneCallAdapter : HtmlControlAdapter
    {
        protected new PhoneCall Control
        {
            get
            {
                return (PhoneCall)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.EnterStyle(Style);
            if (Device.CanInitiateVoiceCall)
            {
                String text = Control.Text;
                String phoneNumber = Control.PhoneNumber;

                if (text == String.Empty)
                {
                    text = phoneNumber;
                }

                writer.WriteBeginTag("a");
                writer.Write(" href=\"tel:");

                foreach (char ch in phoneNumber)
                {
                    if (ch >= '0' && ch <= '9' || ch == '#')
                    {
                        writer.Write(ch);
                    }
                }
                writer.Write("\"");
                AddAttributes(writer);
                writer.Write(">");
                writer.WriteText(text, true);
                writer.WriteEndTag("a");
            }
            else
            {
                // Format the text string based on properties
                String text = String.Format(Control.AlternateFormat, Control.Text,
                                            Control.PhoneNumber);
                String url = Control.AlternateUrl;

                // If URI specified, create a link.  Otherwise, only text is displayed.
                if (url != String.Empty)
                {
                    RenderBeginLink(writer, url);
                    writer.WriteText(text, true);
                    RenderEndLink(writer);
                }
                else
                {
                    writer.WriteText(text, true);
                }
            }
            writer.ExitStyle(Style, Control.BreakAfter);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlvalidationsummaryadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlValidationSummaryAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Diagnostics;
using System.Collections;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlValidationSummaryAdapter provides the html device functionality for
     * ValidationSummary control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlValidationSummaryAdapter : HtmlControlAdapter
    {
        private List _list;  // to paginate error messages
        private Link _link;  // to go back to the form validated by this control

        protected new ValidationSummary Control
        {
            get
            {
                return (ValidationSummary)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
            // Create child controls to help on rendering
            _list = new List();
            Control.Controls.Add(_list);
            _link = new Link();
            Control.Controls.Add(_link);
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            String[] errorMessages = null;

            if (Control.Visible)
            {
                errorMessages = Control.GetErrorMessages();
            }

            if (errorMessages != null)
            {
                writer.EnterStyle(Style);
                if (Control.HeaderText.Length > 0)
                {
                    writer.WriteText(Control.HeaderText, true);
                }

                ArrayList arr = new ArrayList();
                foreach (String errorMessage in errorMessages)
                {
                    Debug.Assert(errorMessage != null && errorMessage.Length > 0, "Bad Error Messages");
                    arr.Add(errorMessage);
                }

                _list.Decoration = ListDecoration.Bulleted;
                _list.DataSource = arr;
                _list.DataBind();

                if (String.Compare(Control.FormToValidate, Control.Form.UniqueID, true, CultureInfo.InvariantCulture) != 0)
                {
                    _link.NavigateUrl = Constants.FormIDPrefix + Control.FormToValidate;
                    _link.Text = Control.BackLabel == String.Empty? GetDefaultLabel(BackLabel) : Control.BackLabel;
                    // Summary writes its own break so last control should write one.
                    _link.BreakAfter = false;
                }
                else
                {
                    _link.Visible = false;
                    // Summary writes its own break so last control should write one.
                    _list.BreakAfter = false;
                }

                // Render the child controls to display error message list and a
                // link for going back to the Form that is having error
                RenderChildren(writer);
                writer.ExitStyle(Style, Control.BreakAfter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlpageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlPageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Web.Mobile;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlPageAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlPageAdapter : HtmlControlAdapter, IPageAdapter
    {
        private IList _renderableForms = null;

        private int _optimumPageWeight = 0;
        private const int DefaultPageWeight = 4000;
        private readonly int _defaultPageWeight;
        private const String _postedFromOtherFile = ".";
        private IDictionary _cookielessDataDictionary = null;

        public HtmlPageAdapter() : this(DefaultPageWeight)
        {
        }

        protected internal HtmlPageAdapter(int defaultPageWeight)
        {
            _defaultPageWeight = defaultPageWeight;
        }

        public virtual int OptimumPageWeight
        {
            get
            {
                if (_optimumPageWeight == 0)
                {
                    _optimumPageWeight = CalculateOptimumPageWeight(_defaultPageWeight);
                }
                return _optimumPageWeight;
            }
        }


        ///////////////////////////////////////////////////////////////////////////
        //  Static method used for determining if device should use
        //  this adapter
        ///////////////////////////////////////////////////////////////////////////

        public static bool DeviceQualifies(HttpContext context)
        {
            String type = ((MobileCapabilities)context.Request.Browser).PreferredRenderingType;
            bool javascriptSupported = context.Request.Browser.JavaScript;
            bool qualifies = (type == MobileCapabilities.PreferredRenderingTypeHtml32) && javascriptSupported;
            return qualifies;
        }
        
        ///////////////////////////////////////////////////////////////////////////
        //  IControlAdapter implementation
        ///////////////////////////////////////////////////////////////////////////

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.BeginResponse();

            if (RequiresPragmaNoCacheHeader())
            {
                Page.Response.AppendHeader("Pragma", "no-cache");
            }

            if (writer.SupportsMultiPart)
            {
                // -1 means it doesn't care about forms' total weight
                _renderableForms = Page.ActiveForm.GetLinkedForms(-1);
                Debug.Assert(_renderableForms != null, "_renderableForms is null");

                foreach (Form form in _renderableForms)
                {
                    RenderForm(writer, form);
                }
            }
            else
            {
                RenderForm(writer, Page.ActiveForm);
            }

            writer.EndResponse();
        }

        private bool RequiresPragmaNoCacheHeader()
        {
            String protocol = Page.Request.ServerVariables["SERVER_PROTOCOL"];
            if (protocol == "HTTP/1.0")
            {
                return true;
            }
            return false;
        }

        public virtual void RenderForm(HtmlMobileTextWriter writer, Form form)
        {
            writer.BeginFile(GetFormUrl(form), "text/html", Page.Response.Charset);
            writer.WriteFullBeginTag("html");
            form.RenderControl(writer);
            if (Device.RequiresDBCSCharacter)
            {
                // Insert a comment with a space
                writer.Write("<!--\u3000-->");
            }
            writer.WriteEndTag("html");
            writer.EndFile();
        }

        public virtual bool IsFormRendered(Form form)
        {
            Debug.Assert(_renderableForms != null, "_renderableForms is null");
            return _renderableForms.Contains(form);
        }

        public String GetFormUrl(Form form)
        {
            if (form == Page.ActiveForm)
            {
                return Page.Request.Url.ToString();
            }
            else
            {
                return form.ClientID + ".html";
            }
        }

        public virtual void RenderPostBackEvent(HtmlMobileTextWriter writer, 
                                                String target, 
                                                String argument)
        {
            writer.Write("javascript:__doPostBack('");
            writer.Write(target);
            writer.Write("','");
            writer.Write(argument);
            writer.Write("')");
        }

        public virtual void RenderUrlPostBackEvent(HtmlMobileTextWriter writer,
                                                   String target, 
                                                   String argument)
        {
            writer.WriteEncodedUrl(Page.RelativeFilePath);
            writer.Write("?");

            // Encode ViewStateID=.....&__ET=controlid&__EA=value in URL
            // Note: the encoding needs to be agreed with the page
            // adapter which handles the post back info
            String pageState = Page.ClientViewState;
            if (pageState != null)
            {
                writer.WriteUrlParameter(MobilePage.ViewStateID, pageState);
                writer.Write("&");
            }
            writer.WriteUrlParameter(EventSourceKey, target);
            writer.Write("&");
            writer.WriteUrlParameter(EventArgumentKey, argument);
            RenderHiddenVariablesInUrl(writer);

            // Unique file path suffix is used for identify if query
            // string text is present.  Corresponding code needs to agree
            // on this.  Even if the query string is empty, we still need
            // to output the suffix to indicate this. (this corresponds
            // to the code that handles the postback)
            writer.Write('&');
            writer.Write(Constants.UniqueFilePathSuffixVariable);

            String queryStringText = Page.QueryStringText;
            if (queryStringText != null && queryStringText.Length > 0)
            {
                writer.Write('&');
                writer.Write(queryStringText);
            }
        }

        protected virtual String EventSourceKey
        {
            get
            {
                return MobilePage.HiddenPostEventSourceId;
            }
        }

        protected virtual String EventArgumentKey
        {
            get
            {
                return MobilePage.HiddenPostEventArgumentId;
            }
        }

        protected void RenderHiddenVariables(HtmlMobileTextWriter writer)
        {
            if (Page.HasHiddenVariables())
            {
                String hiddenVariablePrefix = MobilePage.HiddenVariablePrefix;
                foreach (DictionaryEntry entry in Page.HiddenVariables)
                {
                    if (entry.Value != null)
                    {
                        writer.WriteHiddenField(hiddenVariablePrefix + (String)entry.Key, 
                                            (String)entry.Value);
                    }
                }
            }
        }

        private void RenderHiddenVariablesInUrl(HtmlMobileTextWriter writer)
        {
            if (Page.HasHiddenVariables())
            {
                String hiddenVariablePrefix = MobilePage.HiddenVariablePrefix;
                foreach (DictionaryEntry entry in Page.HiddenVariables)
                {
                    writer.Write("&");
                    writer.WriteUrlParameter(hiddenVariablePrefix + (String)entry.Key,
                                             (String)entry.Value);
                }
            }
        }

        public virtual void RenderPostBackHeader(HtmlMobileTextWriter writer, Form form)
        {
            bool postBack = form.Action.Length == 0;

            RenderPageState(writer);

            writer.WriteHiddenField(EventSourceKey, postBack ? "" : _postedFromOtherFile);
            writer.WriteHiddenField(EventArgumentKey, "");
            RenderHiddenVariables(writer);

            writer.Write("<script language=javascript><!--\r\n");
            writer.Write("function __doPostBack(target, argument){\r\n");
            writer.Write("  var theform = document.");
            writer.Write(form.ClientID);
            writer.Write("\r\n");
            if (form.Action.Length > 0)
            {
                writer.Write("  theform.action = \"\"\r\n");
            }
            writer.Write("  theform.");
            writer.Write(EventSourceKey);
            writer.Write(".value = target\r\n");
            writer.Write("  theform.");
            writer.Write(EventArgumentKey);
            writer.Write(".value = argument\r\n");
            writer.Write("  theform.submit()\r\n");
            writer.Write("}\r\n");
            writer.Write("// -->\r\n");
            writer.Write("</script>\r\n");
        }

        ///////////////////////////////////////////////////////////////////////////
        //  IPageAdapter implementation
        ///////////////////////////////////////////////////////////////////////////

        private MobilePage _page;
        
        public override MobilePage Page
        {
            get
            {
                return _page;
            }
            set
            {
                _page = value;
            }
        }

        public IDictionary CookielessDataDictionary
        {
            get
            {
                return _cookielessDataDictionary;
            }

            set
            {
                _cookielessDataDictionary = value;
            }
        }

        private bool _persistCookielessData = true;
        public bool PersistCookielessData
        {
            get
            {
                return _persistCookielessData;
            }
            
            set
            {
                _persistCookielessData = value;
            }
        }

        public virtual HtmlTextWriter CreateTextWriter(TextWriter writer)
        {
            return new HtmlMobileTextWriter(writer, Device);
        }

        public virtual NameValueCollection DeterminePostBackMode(
            HttpRequest request,
            String postEventSourceID,
            String postEventArgumentID,
            NameValueCollection baseCollection)
        {
            if (baseCollection != null && 
                baseCollection[EventSourceKey] == _postedFromOtherFile)
            {
                return null;
            }
            return baseCollection;
        }

        public virtual IList CacheVaryByHeaders
        {
            get
            {
                return null;
            }
        }

        public virtual bool HandleError(Exception e, HtmlTextWriter writer)
        {
            return false;
        }

        internal void RenderPageState(HtmlMobileTextWriter writer)
        {
            String viewState = Page.ClientViewState;
            if (viewState != null)
            {
                writer.WriteHiddenField(MobilePage.ViewStateID, viewState);
            }
        }

        public virtual bool HandlePagePostBackEvent(String eventSource, String eventArgument)
        {
            return false;
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmltextboxadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlTextBoxAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * HtmlTextBoxAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlTextBoxAdapter : HtmlControlAdapter
    {
        private String _staticValue;

        protected new TextBox Control
        {
            get
            {
                return (TextBox)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
            _staticValue = Control.Text;
            base.OnInit(e);
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            writer.EnterLayout(Style); 

            writer.WriteBeginTag("input");

            writer.WriteAttribute("name", GetRenderName());

            if (Control.Text != "" && !Control.Password)
            {
                writer.Write(" value=\"");
                writer.WriteText(Control.Text, true);
                writer.Write("\"");
            }
            if (Control.Size > 0)
            {
                writer.WriteAttribute("size", Control.Size.ToString());
            }
            if (Control.MaxLength > 0)
            {
                writer.WriteAttribute("maxlength", Control.MaxLength.ToString());
            }
            if (Control.Password)
            {
                writer.WriteAttribute("type", "password");
            }
            AddAttributes(writer);
            writer.Write("/>");

            writer.ExitLayout(Style, Control.BreakAfter);
            writer.InputWritten = true;
        }

        internal virtual String GetRenderName()
        {
            String renderName;
            if(Device.RequiresAttributeColonSubstitution)
            {
                renderName = Control.UniqueID.Replace(':', ',');
            }
            else
            {
                renderName = Control.UniqueID;
            }

            return renderName;
        }

        protected override void RenderAsHiddenInputField(HtmlMobileTextWriter writer)
        {
            // Optimization - if viewstate is enabled for this control, and the
            // postback returns to this page, we just let it do the trick.

            if (Control.Form.Action.Length > 0 || (!IsViewStateEnabled() && Control.Text != _staticValue))
            {
                writer.WriteHiddenField(Control.UniqueID, Control.Text);
            }
        }

        private bool IsViewStateEnabled()
        {
            Control ctl = Control;
            while (ctl != null)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
                ctl = ctl.Parent;
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\mobiletextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MobileTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.IO;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif

{

    /*
     * MobileTextWriter class. All device-specific mobile text writers
     * inherit from this class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class MobileTextWriter : MultiPartWriter
    {
        private MobileCapabilities _device;
        private MultiPartWriter _multiPartWriter;
        private bool _partStarted = false;

        public MobileCapabilities Device
        {
            get
            {
                return _device;
            }
        }

        public MobileTextWriter(TextWriter writer, MobileCapabilities device) : base(writer)
        {
            _multiPartWriter = writer as MultiPartWriter;
            _device = device;
        }

        public virtual void WriteEncodedText(String text)
        {
            const char NBSP = '\u00A0';

            // When inner text is retrieved for a text control, &nbsp; is
            // decoded to 0x00A0 (code point for nbsp in Unicode).
            // HtmlEncode doesn't encode 0x00A0  to &nbsp;, we need to do it
            // manually here.
            int length = text.Length;
            int pos = 0;
            while (pos < length)
            {
                int nbsp = text.IndexOf(NBSP, pos);
                if (nbsp < 0)
                {
                    HttpUtility.HtmlEncode(pos == 0 ? text : text.Substring(pos, length - pos), this);
                    pos = length;
                }
                else
                {
                    if (nbsp > pos)
                    {
                        HttpUtility.HtmlEncode(text.Substring(pos, nbsp - pos), this);
                    }
                    Write("&nbsp;");
                    pos = nbsp + 1;
                }
            }
        }

        public virtual void WriteEncodedUrl(String url)
        {
            int i = url.IndexOf('?');
            if (i != -1)
            {
                WriteUrlEncodedString(url.Substring(0, i), false);
                Write(url.Substring(i));
            }
            else
            {
                WriteUrlEncodedString(url, false);
            }
        }

        public virtual void WriteEncodedUrlParameter(String urlText)
        {
            WriteUrlEncodedString(urlText, true);
        }

        public virtual void EnterLayout(Style style)
        {
        }

        public virtual void ExitLayout(Style style, bool breakAfter)
        {
        }

        public virtual void ExitLayout(Style style)
        {
            ExitLayout(style, false);
        }

        public virtual void EnterFormat(Style style)
        {
        }

        public virtual void ExitFormat(Style style)
        {
        }

        public virtual void ExitFormat(Style style, bool breakAfter)
        {
        }

        public void EnterStyle(Style style)
        {
            EnterLayout(style);
            EnterFormat(style);
        }

        public void ExitStyle(Style style)
        {
            ExitFormat(style);
            ExitLayout(style);
        }

        protected void WriteUrlEncodedString(String s, bool argument)
        {
            int length = s.Length;
            for (int i = 0; i < length; i++)
            {
                char ch = s[i];
                if (IsSafe(ch))
                {
                    Write(ch);
                }
                else if ( !argument &&
                           (ch == '/' ||
                            ch == ':' ||
                            ch == '#' ||
                            ch == ','
                           )
                        )
                {
                    Write(ch);
                }
                else if (ch == ' ' && argument)
                {
                    Write('+');
                }
                // for chars that their code number is less than 128 and have
                // not been handled above
                else if ((ch & 0xff80) == 0)
                {
                    Write('%');
                    Write(IntToHex((ch >>  4) & 0xf));
                    Write(IntToHex((ch      ) & 0xf));
                }
                else
                {
                    Write("%u");
                    Write(IntToHex((ch >> 12) & 0xf));
                    Write(IntToHex((ch >>  8) & 0xf));
                    Write(IntToHex((ch >>  4) & 0xf));
                    Write(IntToHex((ch      ) & 0xf));
                }
            }
        }

        private static char IntToHex(int n)
        {
            Debug.Assert(n < 0x10);

            if (n <= 9)
            {
                return(char)(n + (int)'0');
            }
            else
            {
                return(char)(n - 10 + (int)'a');
            }
        }

        private static bool IsSafe(char ch)
        {
            if (ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9')
            {
                return true;
            }

            switch (ch)
            {
                case '-':
                case '_':
                case '.':
                case '!':
                case '*':
                case '\'':
                case '(':
                case ')':
                    return true;
            }

            return false;
        }

        /////////////////////////////////////////////////////////////////////////
        //  MultiPartWriter implementation. The MobileTextWriter class itself
        //  does not support multipart writing, unless it is wrapped on top
        //  of another writer that does.
        /////////////////////////////////////////////////////////////////////////

        public override bool SupportsMultiPart
        {
            get
            {
                return _multiPartWriter != null && _multiPartWriter.SupportsMultiPart;
            }
        }

        public override void BeginResponse()
        {
            if (_multiPartWriter != null)
            {
                _multiPartWriter.BeginResponse();
            }
        }

        public override void EndResponse()
        {
            if (_multiPartWriter != null)
            {
                _multiPartWriter.EndResponse();
            }
        }

        public override void BeginFile(String url, String contentType, String charset)
        {
            if (_multiPartWriter != null)
            {
                _multiPartWriter.BeginFile(url, contentType, charset);
            }
            else if (_partStarted)
            {
                throw new Exception(SR.GetString(SR.MobileTextWriterNotMultiPart));
            }
            else
            {
                if (contentType != null && contentType.Length > 0)
                {
                    HttpContext.Current.Response.ContentType = contentType;
                }
                _partStarted = true;
            }
        }

        public override void EndFile()
        {
            if (_multiPartWriter != null)
            {
                _multiPartWriter.EndFile();
            }
        }

        public override void AddResource(String url, String contentType)
        {
            if (_multiPartWriter != null)
            {
                _multiPartWriter.AddResource(url, contentType);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\multipartwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MultiPartWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.IO;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * MultiPartWriter class. Base class for writers that can 
     * handle multipart documents, like MHTML or Palm clippings.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public abstract class MultiPartWriter : HtmlTextWriter
    {
        protected MultiPartWriter(TextWriter writer) : base(writer)
        {
        }

        public virtual bool SupportsMultiPart
        {
            get
            {
                return true;
            }
        }

        public virtual String NewUrl(String filetype)
        {
            return Guid.NewGuid().ToString() + filetype;
        }

        public abstract void BeginResponse();

        public abstract void EndResponse();

        public abstract void BeginFile(String url, String contentType, String charset);

        public abstract void EndFile();

        public abstract void AddResource(String url, String contentType);

        public void AddResource(String url)
        {
            AddResource (url, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\htmlvalidatoradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlValidatorAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Web.UI.WebControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * HtmlValidatorAdapter provides the html device functionality for
     * Validator controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class HtmlValidatorAdapter : HtmlControlAdapter
    {
        protected new BaseValidator Control
        {
            get
            {
                return (BaseValidator)base.Control;
            }
        }

        public override void Render(HtmlMobileTextWriter writer)
        {
            if (!Control.IsValid && Control.Display != ValidatorDisplay.None)
            {
                writer.EnterStyle(Style);
                if (Control.Text != String.Empty)
                {
                    writer.WriteText(Control.Text, true);
                }
                else if (Control.ErrorMessage != String.Empty)
                {
                    writer.WriteText(Control.ErrorMessage, true);
                }
                writer.ExitStyle(Style, Control.BreakAfter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\upwmlmobiletextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpWmlMobileTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

using SR=System.Web.UI.MobileControls.Adapters.SR;

#if COMPILING_FOR_SHIPPED_SOURCE
using Adapters=System.Web.UI.MobileControls.ShippedAdapterSource;
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
using Adapters=System.Web.UI.MobileControls.Adapters;
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * UpWmlMobileTextWriter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class UpWmlMobileTextWriter : WmlMobileTextWriter
    {
        private int       _screenWidth;
        private int       _screenHeight;
        private bool      _inHyperlink = false;
        private bool      _inPostBack = false;
        private bool      _inSoftkey = false;
        private Alignment _lastAlignment = Alignment.Left;
        private Wrapping  _lastWrapping = Wrapping.Wrap;
        private int       _currentCardIndex = -1;
        private ArrayList _cards = new ArrayList();
        private int       _currentCardAnchorCount = 0;
        private int       _currentCardPostBacks = 0;
        private int       _currentCardSubmits = 0;
        private bool      _canRenderMixedSelects = false;
        private bool      _requiresOptionSubmitCard = false;
        private int       _optionSubmitCardIndex = 0;
        private String    _optionMenuName = null;
        
        private String    _linkText = null;
        private String    _targetUrl = null;
        private String    _softkeyLabel = null;
        private bool      _encodeUrl = false;
        private bool      _useMenuOptionTitle = false;
        
        public UpWmlMobileTextWriter(TextWriter writer, MobileCapabilities device, MobilePage page) 
            : base(writer, device, page)
        {
            _screenWidth = device.ScreenCharactersWidth;
            _screenHeight = device.ScreenCharactersHeight;
            _canRenderMixedSelects = device.CanRenderMixedSelects;
        }

        private UpCard CurrentCard
        {
            get
            {
                return (UpCard)_cards[_currentCardIndex];
            }
        }

        public override void BeginForm(Form form)
        {
            ResetState();
            if (AnalyzeMode)
            {
                AllocateNewCard();
                base.BeginForm(form);
            }
            else
            {
                if (form == form.MobilePage.ActiveForm)
                {
                    PreRenderActiveForm();
                }

                base.BeginForm(form);
                RenderCardOpening(0);
            }
        }

        private static readonly int _filePathSuffixLength = 
            Constants.UniqueFilePathSuffixVariableWithoutEqual.Length + 1;
        private int _sessionCount = -1;
        private int SessionCount
        {
            get
            {
                if (_sessionCount == -1)
                {
                    _sessionCount = 0;
                    String filePathSuffix = 
                        Page.Request.QueryString[Constants.UniqueFilePathSuffixVariableWithoutEqual];

                    if (filePathSuffix != null && filePathSuffix.Length == _filePathSuffixLength)
                    {
                        Char c = filePathSuffix[_filePathSuffixLength - 1];
                        if (Char.IsDigit(c))
                        {
                            _sessionCount = (int)Char.GetNumericValue(c);
                        }
                    }
                }

                return _sessionCount;
            }
        }

        private bool RequiresLoopDetectionCard
        {
            get
            {
                IDictionary dictionary = Page.Adapter.CookielessDataDictionary;
                if((dictionary != null) && (dictionary.Count > 0))
                {
                    return true;
                }
                return SessionCount == 9;
            }
        }

        private void PreRenderActiveForm()
        {
            if (Device.RequiresUniqueFilePathSuffix && RequiresLoopDetectionCard)
            {
                Debug.Assert(!AnalyzeMode);
                Write(String.Format(_loopDetectionCard, Page.ActiveForm.ClientID));
            }
        }

        private String _cachedFormQueryString;
        protected override String CalculateFormQueryString()
        {
            if(_cachedFormQueryString != null)
            {
                return _cachedFormQueryString;
            }
            String queryString = null;
            if (CurrentForm.Method != FormMethod.Get)
            {
                queryString = Page.QueryStringText;
            }

            if (Device.RequiresUniqueFilePathSuffix)
            {
                String ufps = Page.UniqueFilePathSuffix;
                if(this.HasFormVariables)
                {
                    if (SessionCount == 9)
                    {
                        ufps += '0';
                    }
                    else
                    {
                        ufps += (SessionCount + 1).ToString();
                    }
                }
                if (queryString != null && queryString.Length > 0)
                {
                    queryString = String.Concat(ufps, "&", queryString);
                }
                else
                {
                    queryString = ufps;
                }
            }
            _cachedFormQueryString = queryString;
            return queryString;
        }

        private const String _loopDetectionCard = 
            "<card ontimer=\"#{0}\"><onevent type=\"onenterbackward\"><prev /></onevent><timer value=\"1\" /></card>";

        internal override bool ShouldWriteFormID(Form form)
        {
            if (RequiresLoopDetectionCard)
            {
                return true;
            }
            return base.ShouldWriteFormID(form);
        }

        public override void EndForm()
        {
            if (AnalyzeMode)
            {
                CheckRawOutput();
                CurrentCard.AnchorCount = _currentCardAnchorCount;
                base.EndForm();
            }
            else
            {
                RenderCardClosing(_currentCardIndex);
                base.EndForm();
            }
        }

        protected override void RenderEndForm()
        {
            base.RenderEndForm();
            if (_requiresOptionSubmitCard)
            {
                Write("<card id=\"");
                Write(_postBackCardPrefix);
                Write("0");
                Write(_optionSubmitCardIndex++);
                WriteLine("\">");

                Write("<onevent type=\"onenterforward\">");
                RenderGoAction(null, _postBackEventArgumentVarName, WmlPostFieldType.Variable, true);
                WriteLine("</onevent>");

                WriteLine("<onevent type=\"onenterbackward\"><prev /></onevent>");
                WriteLine("</card>");
            }
        }

        public override void RenderText(String text, bool breakAfter, bool encodeText)
        {
            if (AnalyzeMode)
            {
                if (CurrentCard.HasInputElements && !Device.CanRenderAfterInputOrSelectElement)
                {
                    BeginNextCard();
                }

                CheckRawOutput();
                if (_inHyperlink || _inPostBack)
                {
                    // When analyzing, accumulate link text for use in figuring
                    // out softkey.
                    if (_inSoftkey)
                    {
                        _linkText += text;
                    }
                }
                else
                {
                    // Text cannot come after a menu.
                    if (CurrentCard.RenderAsMenu)
                    {
                        CurrentCard.RenderAsMenu = false;
                        CurrentCard.MenuCandidate = false;
                    }
                    else if (CurrentCard.MenuCandidate)
                    {
                        // Calculate weight of static items before a menu.
                        // This is used to check for screens that scroll past their
                        // initial content.

                        int weight = text != null ? text.Length : 0;
                        if (breakAfter)
                        {
                            weight = ((weight - 1) / _screenWidth + 1) * _screenWidth;
                        }
                        CurrentCard.StaticItemsWeight += weight;
                    }
                }
            }
            else
            {
                bool willRenderText = false;
                if (_inHyperlink || _inPostBack)
                {
                    // If rendering in menu, simply accumulate text.
                    if (CurrentCard.RenderAsMenu)
                    {
                        _linkText += text;
                    }
                    else if (!CurrentCard.UsesDefaultSubmit)
                    {
                        willRenderText = true;
                    }
                }
                else
                {
                    willRenderText = true;
                }

                if (willRenderText)
                {
                    // Some browsers that
                    // RendersBreakBeforeWmlSelectAndInput have the odd behavior
                    // of *not* rendering a break if there is nothing on the
                    // card before it, and entering an explicit <br> creates two
                    // breaks.  Therefore, we just render a &nbsp; in this
                    // situation.
                    
                    if (!CurrentCard.RenderedTextElementYet &&
                        Device.RendersBreakBeforeWmlSelectAndInput &&
                        !((WmlPageAdapter)Page.Adapter).IsKDDIPhone())
                    {
                        CurrentCard.RenderedTextElementYet = true;
                        if (breakAfter && text == String.Empty)
                        {
                            base.RenderText("&nbsp;", false, false);
                        } 
                    }
                    base.RenderText(text, breakAfter, encodeText);
                }
                
            }
        }

        public override void RenderBeginHyperlink(String targetUrl, 
                                                  bool encodeUrl, 
                                                  String softkeyLabel, 
                                                  bool implicitSoftkeyLabel,
                                                  bool mapToSoftkey)
        {
            if (_inHyperlink || _inPostBack)
            {
                throw new Exception();
            }

            // AUI 4137
            if (targetUrl != null && targetUrl.Length > 0 && targetUrl[0] != '#')
            {
                targetUrl = Page.MakePathAbsolute(targetUrl);
            }

            if (AnalyzeMode)
            {
                if (CurrentCard.HasInputElements && !Device.CanRenderAfterInputOrSelectElement)
                {
                    BeginNextCard();
                }

                CheckRawOutput();

                // Try to map to softkey if possible.
                if (mapToSoftkey && CurrentCard.SoftkeysUsed < NumberOfSoftkeys)
                {
                    _inSoftkey = true;
                    _targetUrl = targetUrl;
                    _softkeyLabel = softkeyLabel;
                    _encodeUrl = encodeUrl;
                    _linkText = String.Empty;
                }
            }
            else
            {
                if (CurrentCard.RenderAsMenu)
                {
                    if (!CurrentCard.MenuOpened)
                    {
                        OpenMenu();
                    }

                    // In menu mode, actual rendering is done on RenderEndHyperlink,
                    // when we have all available info.

                    _targetUrl = targetUrl;
                    _softkeyLabel = softkeyLabel;
                    _useMenuOptionTitle = mapToSoftkey && !implicitSoftkeyLabel;
                    _encodeUrl = encodeUrl;
                    _linkText = String.Empty;
                }
                else if (!CurrentCard.UsesDefaultSubmit)
                {
                    base.RenderBeginHyperlink(targetUrl, 
                                              encodeUrl, 
                                              softkeyLabel, 
                                              implicitSoftkeyLabel, 
                                              mapToSoftkey);
                }
            }
            _inHyperlink = true;
        }

        public override void RenderEndHyperlink(bool breakAfter)
        {
            if (!_inHyperlink)
            {
                throw new Exception();
            }

            _inHyperlink = false;
            if (AnalyzeMode)
            {
                CheckRawOutput();
                if (CurrentCard.MenuCandidate)
                {
                    CurrentCard.RenderAsMenu = true;
                }
                CurrentCard.HasNonStaticElements = true;

                if (_inSoftkey)
                {
                    // Add a softkey if possible.

                    _inSoftkey = false;
                    UpHyperlinkSoftkey softkey = new UpHyperlinkSoftkey();
                    softkey.TargetUrl = _targetUrl;
                    softkey.EncodeUrl = _encodeUrl;
                    if (_softkeyLabel == null || _softkeyLabel.Length == 0)
                    {
                        _softkeyLabel = _linkText;
                    }
                    softkey.Label = _softkeyLabel;
                    CurrentCard.Softkeys[CurrentCard.SoftkeysUsed++] = softkey;
                }
            }
            else
            {
                if (CurrentCard.RenderAsMenu)
                {
                    Write("<option onpick=\"");
                    if (_targetUrl.StartsWith(Constants.FormIDPrefix))
                    {
                        // no encoding needed if pointing to another form id
                        Write(_targetUrl);
                    }
                    else if (!_encodeUrl)
                    {
                        Write(EscapeAmpersand(_targetUrl));
                    }
                    else
                    {
                        WriteEncodedUrl(_targetUrl);
                    }
                    Write("\"");

                    if (_useMenuOptionTitle && IsValidSoftkeyLabel(_softkeyLabel))
                    {
                        WriteTextEncodedAttribute("title", _softkeyLabel);
                    }

                    Write(">");
                    WriteEncodedText(_linkText);
                    WriteEndTag("option");
                }
                else if (!CurrentCard.UsesDefaultSubmit)
                {
                    base.RenderEndHyperlink(breakAfter);
                }

            }
            _currentCardAnchorCount++;
            
            if (!AnalyzeMode &&
                    _currentCardAnchorCount == CurrentCard.AnchorCount && 
                    _currentCardIndex < _cards.Count - 1)
            {
                BeginNextCard();
            }
        }

        public override void RenderTextBox(String id, 
                                           String value,
                                           String format, 
                                           String title,
                                           bool password, 
                                           int size, 
                                           int maxLength, 
                                           bool generateRandomID,
                                           bool breakAfter)
        {
            if (AnalyzeMode)
            {
                CheckRawOutput();

                // If an anchor precedes this control, then break to the
                // next card.
                if (_currentCardAnchorCount > 0)
                {
                    BeginNextCard();
                }
                else if (CurrentCard.HasInputElements && 
                            (!Device.CanRenderInputAndSelectElementsTogether ||
                                !Device.CanRenderAfterInputOrSelectElement))
                {
                    BeginNextCard();
                }

                CurrentCard.RenderAsMenu = false;
                CurrentCard.MenuCandidate = false;
                CurrentCard.HasNonStaticElements = true;
                CurrentCard.HasInputElements = true;
            }
            else
            {
                // Don't write breaks after textboxes on UP.
                base.RenderTextBox(id, value, format, title, password, size, maxLength, generateRandomID, false);

                // If we can't render more than one input element on this card, and
                // there are no anchors left to render, break here.

                if (!Device.CanRenderAfterInputOrSelectElement && _currentCardIndex < _cards.Count - 1)
                {
                    CurrentCard.NoOKLink = true;
                    BeginNextCard();
                }
                else if (CurrentCard.AnchorCount == 0 && _currentCardIndex < _cards.Count - 1 &&
                        !Device.CanRenderInputAndSelectElementsTogether)
                {
                    CurrentCard.NoOKLink = true;
                    BeginNextCard();
                }
            }
        }

        public override void RenderImage(String source, 
                                         String localSource, 
                                         String alternateText, 
                                         bool breakAfter)
        {
            if (AnalyzeMode)
            {
                if (CurrentCard.HasInputElements && !Device.CanRenderAfterInputOrSelectElement)
                {
                    BeginNextCard();
                }

                CheckRawOutput();

                if (_inHyperlink || _inPostBack)
                {
                    CurrentCard.RenderAsMenu = false;
                    CurrentCard.MenuCandidate = false;
                }
                else
                {
                    if (CurrentCard.RenderAsMenu)
                    {
                        // Images cannot come after a menu on a card.
                        CurrentCard.RenderAsMenu = false;
                        CurrentCard.MenuCandidate = false;
                    }
                    else if (CurrentCard.MenuCandidate)
                    {
                        CurrentCard.StaticItemsWeight += _screenWidth;
                    }
                }
            }
            else
            {
                // AUI 4137
                if (source != null)
                {
                    source = Page.MakePathAbsolute(source);
                }

                if (_inHyperlink || _inPostBack)
                {
                    if (CurrentCard.RenderAsMenu)
                    {
                        _linkText += alternateText;
                    }
                    else if (!CurrentCard.UsesDefaultSubmit)
                    {
                        base.RenderImage(source, localSource, alternateText, breakAfter);
                    }
                }
                else
                {
                    base.RenderImage(source, localSource, alternateText, breakAfter);
                }
            }
        }

        public override void RenderBeginPostBack(String softkeyLabel, 
                                                 bool implicitSoftkeyLabel, 
                                                 bool mapToSoftkey)
        {
            if (_inHyperlink || _inPostBack)
            {
                throw new Exception();
            }

            if (AnalyzeMode)
            {
                if (CurrentCard.HasInputElements && !Device.CanRenderAfterInputOrSelectElement)
                {
                    BeginNextCard();
                }

                CheckRawOutput();

                // Try to map to softkey if possible.
                if (mapToSoftkey && CurrentCard.SoftkeysUsed < NumberOfSoftkeys)
                {
                    _inSoftkey = true;
                    _softkeyLabel = softkeyLabel;
                    _linkText = String.Empty;
                }

            }
            else
            {
                if (CurrentCard.RenderAsMenu)
                {
                    if (!CurrentCard.MenuOpened)
                    {
                        OpenMenu();
                    }

                    // In menu mode, actual rendering is done on RenderEndPostBack,
                    // when we have all available info.
                    _softkeyLabel = softkeyLabel;
                    _useMenuOptionTitle = mapToSoftkey && !implicitSoftkeyLabel;
                    _linkText = String.Empty;
                }
                else if (!CurrentCard.UsesDefaultSubmit)
                {
                    base.RenderBeginPostBack(softkeyLabel, implicitSoftkeyLabel, mapToSoftkey);
                }
            }
            _inPostBack = true;
        }

        public override void RenderEndPostBack(String target, String argument, WmlPostFieldType postBackType, bool includeVariables, bool breakAfter)
        {
            if (!_inPostBack)
            {
                throw new Exception();
            }

            _inPostBack = false;
            if (AnalyzeMode)
            {
                CheckRawOutput();

                if (CurrentCard.MenuCandidate)
                {
                    // If all postback menu items go to one target, we can write the do
                    // to hit that target. Otherwise, we must post back to the form.

                    if (CurrentCard.RenderAsMenu)
                    {
                        if (CurrentCard.MenuTarget != target)
                        {
                            CurrentCard.MenuTarget = null;
                        }
                    }
                    else
                    {
                        CurrentCard.MenuTarget = target;
                        CurrentCard.RenderAsMenu = true;
                    }
                }
                CurrentCard.HasNonStaticElements = true;

                if (_inSoftkey)
                {
                    // Map to softkey.
                    _inSoftkey = false;
                    UpPostBackSoftkey softkey = new UpPostBackSoftkey();
                    softkey.Target = target;
                    softkey.Argument = argument;
                    softkey.PostBackType = postBackType;
                    softkey.IncludeVariables = includeVariables;
                    if (_softkeyLabel == null || _softkeyLabel.Length == 0)
                    {
                        _softkeyLabel = _linkText;
                    }
                    softkey.Label = _softkeyLabel;
                    CurrentCard.Softkeys[CurrentCard.SoftkeysUsed++] = softkey;
                }
                AnalyzePostBack(includeVariables, postBackType);
            }
            else
            {
                if (CurrentCard.RenderAsMenu)
                {
                    // Render as a menu item.

                    WriteBeginTag("option");
                    if (!_canRenderMixedSelects)
                    {
                        if (_useMenuOptionTitle && IsValidSoftkeyLabel(_softkeyLabel))
                        {
                            WriteTextEncodedAttribute("title", _softkeyLabel);
                        }

                        _requiresOptionSubmitCard = true;
                        Write("><onevent type=\"onpick\"><go href=\"#");
                        Write(_postBackCardPrefix);
                        Write("0");
                        Write(_optionSubmitCardIndex);
                        Write("\">");
                        Write("<setvar name=\"");
                        Write(_postBackEventTargetVarName);
                        Write("\" value=\"");
                        if (_optionMenuName != null)
                        {
                            Write(_optionMenuName);
                        }
                        Write("\" />");
                        Write("<setvar name=\"");
                        Write(_postBackEventArgumentVarName);
                        Write("\" value=\"");
                    }
                    else
                    {
                        Write(" value=\"");
                    }

                    if (CurrentCard.MenuTarget != null)
                    {
                        if (argument != null)
                        {
                            WriteEncodedText(argument);
                        }
                    }
                    else
                    {
                        WriteEncodedText(target);
                        if (argument != null)
                        {
                            Write(",");
                            WriteEncodedText(argument);
                        }
                    }
                    if (!_canRenderMixedSelects)
                    {
                        Write("\" /></go></onevent>");
                    }
                    else
                    {
                        Write("\"");
                        if (_useMenuOptionTitle && IsValidSoftkeyLabel(_softkeyLabel))
                        {
                            WriteTextEncodedAttribute("title", _softkeyLabel);
                        }
                        Write(">");
                    }

                    WriteEncodedText(_linkText);
                    WriteEndTag("option");
                }
                else if (!CurrentCard.UsesDefaultSubmit)
                {
                    base.RenderEndPostBack(target, argument, postBackType, 
                            includeVariables, breakAfter);
                }
            }
            _currentCardAnchorCount++;

            if (!AnalyzeMode &&
                    _currentCardAnchorCount == CurrentCard.AnchorCount && 
                    _currentCardIndex < _cards.Count - 1)
            {
                BeginNextCard();
            }
        }

        public override void BeginCustomMarkup()
        {
            if (!AnalyzeMode && !CurrentCard.MenuOpened)
            {
                EnsureLayout();
            }
        }


        protected override void AnalyzePostBack(bool includeVariables, WmlPostFieldType postBackType)
        {
            base.AnalyzePostBack(includeVariables, postBackType);
            if (CurrentForm.Action.Length > 0)
            {
                if (postBackType == WmlPostFieldType.Submit)
                {
                    _currentCardSubmits++;
                    CurrentCard.ExternalSubmitMenu = true;
                }
                else
                {
                    _currentCardPostBacks++;
                }
                if (_currentCardPostBacks > 0 && _currentCardSubmits > 0)
                {
                    // Posts to more than one target, so we can't use a menu card.

                    CurrentCard.RenderAsMenu = false;
                    CurrentCard.MenuCandidate = false;
                }
            }
        }

        public override void RenderBeginSelect(String name, String iname, String ivalue, String title, bool multiSelect)
        {
            if (AnalyzeMode)
            {
                CheckRawOutput();
                if (_currentCardAnchorCount > 0)
                {
                    // If an anchor precedes this control, then break to the
                    // next card.
                    BeginNextCard();
                }
                else if (CurrentCard.HasInputElements &&
                            (!Device.CanRenderInputAndSelectElementsTogether ||
                                !Device.CanRenderAfterInputOrSelectElement))
                {
                    BeginNextCard();
                }

                CurrentCard.RenderAsMenu = false;
                CurrentCard.MenuCandidate = false;
                CurrentCard.HasNonStaticElements = true;
                CurrentCard.HasInputElements = true;
            }
            else
            {
                base.RenderBeginSelect(name, iname, ivalue, title, multiSelect);
            }
        }

        public override void RenderEndSelect(bool breakAfter)
        {
            if (AnalyzeMode)
            {
                CheckRawOutput();
            }
            else
            {
                // Don't write breaks after selects on UP.
                base.RenderEndSelect(false);

                // If we can't render more than one input element on this card, and
                // there are no anchors left to render, break here.

                if (!Device.CanRenderAfterInputOrSelectElement && _currentCardIndex < _cards.Count - 1)
                {
                    CurrentCard.NoOKLink = true;
                    BeginNextCard();
                } 
                else if (CurrentCard.AnchorCount == 0 && _currentCardIndex < _cards.Count - 1 &&
                        !Device.CanRenderInputAndSelectElementsTogether)
                {
                    CurrentCard.NoOKLink = true;
                    BeginNextCard();
                }
            }
        }

        public override void RenderSelectOption(String text)
        {
            if (AnalyzeMode)
            {
                CheckRawOutput();
            }
            else
            {
                base.RenderSelectOption(text);
            }
        }

        public override void RenderSelectOption(String text, String value)
        {
            if (AnalyzeMode)
            {
                CheckRawOutput();
            }
            else
            {
                base.RenderSelectOption(text, value);
            }
        }

        private void OpenMenu()
        {
            // Close any character formatting tags before starting a <do>.
            CloseCharacterFormat();

            String menuTarget;
            String menuTargetClientID;
            WmlPostFieldType postFieldType;

            if (CurrentCard.ExternalSubmitMenu)
            {
                menuTarget = null;
                menuTargetClientID = null;
                postFieldType = WmlPostFieldType.Submit;
            }
            else
            {
                if (CurrentCard.MenuTarget != null)
                {
                    menuTarget = CurrentCard.MenuTarget;
                    if (menuTarget.IndexOf(":") >= 0) 
                    {
                        menuTargetClientID = menuTarget.Replace(":", "_");
                    }
                    else
                    {
                        menuTargetClientID = menuTarget;
                    }
                }
                else
                {
                    menuTarget = CurrentForm.UniqueID;
                    menuTargetClientID = CurrentForm.ClientID;
                }

                postFieldType = WmlPostFieldType.Variable;
            }

            if (!_canRenderMixedSelects)
            {
                _optionMenuName = menuTarget;
                menuTargetClientID = null;
            }
            else
            {
                String GoLabel = SR.GetString(SR.WmlMobileTextWriterGoLabel);
                RenderDoEvent("accept", 
                              menuTarget, 
                              menuTargetClientID != null ? MapClientIDToShortName(menuTargetClientID, false) : null,
                              postFieldType,
                              GoLabel,
                              true);
            }

            base.RenderBeginSelect(menuTargetClientID, null, null, null, false);

            CurrentCard.MenuOpened = true;
        }

        private void CloseMenu()
        {
            base.RenderEndSelect(false);
            CurrentCard.MenuOpened = false;
        }

        // Overriden to convert relative file paths to absolute file paths,
        // due to a redirection issue on UP phones.

        protected override String CalculateFormPostBackUrl(bool externalSubmit, ref bool encode)
        {
            String url = CurrentForm.Action;
            if (externalSubmit && url.Length > 0)
            {
                // Not only do we need to resolve the URL, but we need to make it absolute.
                url = Page.MakePathAbsolute(CurrentForm.ResolveUrl(url));
                encode = false;
            }
            else
            {
                url = Page.AbsoluteFilePath;
                encode = true;
            }
            return url;
        }

        // Captures raw output written to the writers during analyze mode.

        private void CheckRawOutput()
        {
            Debug.Assert(AnalyzeMode);

            EmptyTextWriter innerWriter = (EmptyTextWriter)InnerWriter;
            if (innerWriter.NonWhiteSpaceWritten)
            {
                CurrentCard.RenderAsMenu = false;
                CurrentCard.MenuCandidate = false;
            }
            innerWriter.Reset();
        }

        // Overriden to always write the "align" or "wrap" attributes when
        // they are changing, even if they are set to defaults.

        protected override void OpenParagraph(WmlLayout layout, bool writeAlignment, bool writeWrapping)
        {
            base.OpenParagraph(layout,
                               writeAlignment || layout.Align != _lastAlignment,
                               writeWrapping  || layout.Wrap != _lastWrapping);
            _lastAlignment = layout.Align;
            _lastWrapping = layout.Wrap;
        }

        // Resets writer state between forms.

        private void ResetState()
        {
            if (AnalyzeMode)
            {
                _currentCardPostBacks = 0;
                _currentCardSubmits = 0;
                _inHyperlink = false;
                _inPostBack = false;
                _inSoftkey = false;
                if (_cards.Count > 0)
                {
                    _cards.Clear();
                }
            }
            _currentCardAnchorCount = 0;
            _currentCardIndex = 0;
            _currentCardPostBacks = 0;
            _currentCardSubmits = 0;
            _requiresOptionSubmitCard = false;
        }

        private UpCard AllocateNewCard()
        {
            UpCard card = new UpCard();
            card.Softkeys = new UpSoftkey[NumberOfSoftkeys];
            _cards.Add(card);
            return card;
        }

        // Analyze an individual card.

        private void PostAnalyzeCard(int cardIndex)
        {
            UpCard card = (UpCard)_cards[cardIndex];
            if (card.RenderAsMenu)
            {
                // If the card is the last card, and has only
                // one anchor that can be mapped to a softkey, 
                // ignore the 

                if (card.AnchorCount == 1 && cardIndex == _cards.Count - 1 && card.SoftkeysUsed == 1)
                {
                    card.RenderAsMenu = false;
                }

                // If the card has a lot of static content followed by
                // a number of links, don't render it as a menu card, 
                // because the card would scroll off the static content
                // to get to the menu.

                else if (card.StaticItemsWeight >= 3 * _screenWidth)
                {
                    card.RenderAsMenu = false;
                }
            }
        }

        protected override void PostAnalyzeForm()
        {
            base.PostAnalyzeForm();

            for(int i = 0; i < _cards.Count; i++)
            {
                PostAnalyzeCard(i);
            }

            // If the last card ends with an input element and an anchor
            // then use the anchor as a do tag to submit the form, and
            // don't render as a separate anchor (otherwise, the user would
            // see an extra screen at the end with a single anchor)
            UpCard lastCard = CurrentCard;
            if (lastCard.HasInputElements && _currentCardAnchorCount >= 1 && 
                    _currentCardAnchorCount <= Device.DefaultSubmitButtonLimit)
            {
                lastCard.UsesDefaultSubmit = true;
            }
        }

        private void RenderCardOpening(int cardIndex)
        {
            UpCard card = (UpCard)_cards[cardIndex];
            if (card.RenderAsMenu)
            {
            }
            else
            {
                // Render softkeys
                if (card.HasNonStaticElements)
                {
                    for (int i = 0; i < card.SoftkeysUsed; i++)
                    {
                        RenderSoftkey(i == 0 ? "accept" : "options", card.Softkeys[i]);
                    }
                }
                else if (cardIndex == _cards.Count - 1)
                {
                    // Render the last card with an extra <do>, so that
                    // it overrides the default function of the OK button,
                    // which is to go back a screen.
                    //EnsureLayout();
                    Write("<do type=\"accept\"><noop /></do>");
                }
            }
        }

        private void RenderCardClosing(int cardIndex)
        {
            UpCard card = (UpCard)_cards[cardIndex];

            if (cardIndex < _cards.Count - 1 && !card.NoOKLink)
            {
                // Add a link to go to the next card.

                UpCard nextCard = (UpCard)_cards[cardIndex + 1];
                String OkLabel = SR.GetString(SR.WmlMobileTextWriterOKLabel);
                RenderBeginHyperlink("#" + nextCard.Id, false, OkLabel, true, true);
                RenderText(OkLabel);
                RenderEndHyperlink(true);
            }

            if (card.RenderAsMenu)
            {
                CloseMenu();
            }
        }

        private void BeginNextCard()
        {
            if (AnalyzeMode)
            {
                // Add a softkey on the current card, to go to the new card.

                String nextCardId = "card" + (_currentCardIndex + 1).ToString();

                UpHyperlinkSoftkey softkey = new UpHyperlinkSoftkey();
                softkey.TargetUrl = "#" + nextCardId;
                softkey.EncodeUrl = false;
                softkey.Label = "OK";
                SetPrimarySoftkey(softkey);

                CurrentCard.AnchorCount = _currentCardAnchorCount;

                UpCard card = AllocateNewCard();
                card.Id = nextCardId;
                _currentCardIndex++;
            }
            else
            {
                RenderCardClosing(_currentCardIndex);
                CloseParagraph();
                WriteEndTag("card");
                WriteLine();
    
                _currentCardIndex++;
                _lastAlignment = Alignment.Left;
                _lastWrapping = Wrapping.NoWrap;
    
                WriteBeginTag("card");
                WriteAttribute("id", CurrentCard.Id);
                String formTitle = CurrentForm.Title;
                if (formTitle != null && formTitle.Length > 0)
                {
                    WriteTextEncodedAttribute("title", formTitle);
                }
                WriteLine(">");
                RenderCardOpening(_currentCardIndex);
            }

            _currentCardAnchorCount = 0;
            _currentCardPostBacks = 0;
            _currentCardSubmits = 0;
        }

        private void SetPrimarySoftkey(UpSoftkey softkey)
        {
            for (int i = NumberOfSoftkeys - 1; i > 0; i--)
            {
                CurrentCard.Softkeys[i] = CurrentCard.Softkeys[i - 1];
            }
            CurrentCard.Softkeys[0] = softkey;
            if (CurrentCard.SoftkeysUsed < NumberOfSoftkeys)
            {
                CurrentCard.SoftkeysUsed++;
            }
        }

        private void RenderSoftkey(String doType, UpSoftkey softkey)
        {
            UpHyperlinkSoftkey linkSoftkey = softkey as UpHyperlinkSoftkey;
            if (linkSoftkey != null)
            {
                WriteBeginTag("do");
                WriteAttribute("type", doType);
                WriteTextEncodedAttribute("label", linkSoftkey.Label);
                Write(">");
                WriteBeginTag("go");
                Write(" href=\"");

                if (linkSoftkey.EncodeUrl)
                {
                    WriteEncodedUrl(linkSoftkey.TargetUrl);
                }
                else
                {
                    Write(EscapeAmpersand(linkSoftkey.TargetUrl));
                }
                Write("\" />");
                WriteEndTag("do");
                return;
            }

            UpPostBackSoftkey postBackSoftkey = softkey as UpPostBackSoftkey;
            if (postBackSoftkey != null)
            {
                RenderDoEvent(doType, 
                              postBackSoftkey.Target, 
                              postBackSoftkey.Argument, 
                              postBackSoftkey.PostBackType, 
                              postBackSoftkey.Label,
                              postBackSoftkey.IncludeVariables); 
                return;
            }
        }

        private class UpSoftkey
        {
            public String Label;
        }

        private class UpHyperlinkSoftkey : UpSoftkey
        {
            public String TargetUrl;
            public bool EncodeUrl;
        }

        private class UpPostBackSoftkey : UpSoftkey
        {
            public String Target;
            public String Argument;
            public WmlPostFieldType PostBackType;
            public bool IncludeVariables;
        }

        private class UpCard
        {
            public String Id;
            public bool MenuCandidate = true;
            public bool RenderAsMenu = false;
            public int StaticItemsWeight = 0;
            public bool HasNonStaticElements = false;
            public bool MenuOpened = false;
            public bool HasInputElements = false;
            public bool UsesDefaultSubmit = false;
            public int SoftkeysUsed = 0;
            public UpSoftkey[] Softkeys = null;
            public int AnchorCount = 0;
            public String MenuTarget = null;
            public bool ExternalSubmitMenu = false;
            public bool NoOKLink = false;
            public bool RenderedTextElementYet = false;
            
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlcontroladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlControlAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Diagnostics;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Web.Security;
using System.Text;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlControlAdapter base class contains wml specific methods.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlControlAdapter : ControlAdapter
    {
        protected WmlPageAdapter PageAdapter
        {
            get
            {
                return ((WmlPageAdapter)Page.Adapter);
            }
        }

        protected WmlFormAdapter FormAdapter
        {
            get
            {
                return (WmlFormAdapter)Control.Form.Adapter;
            }
        }

        public override void Render(HtmlTextWriter writer)
        {
            Render((WmlMobileTextWriter)writer);
        }

        public virtual void Render(WmlMobileTextWriter writer)
        {
            RenderChildren(writer);
        }

        protected void RenderLink(WmlMobileTextWriter writer, 
                                  String targetUrl, 
                                  String softkeyLabel, 
                                  bool implicitSoftkeyLabel,
                                  bool mapToSoftkey, 
                                  String text, 
                                  bool breakAfter)
        {
            RenderBeginLink(writer, targetUrl, softkeyLabel, implicitSoftkeyLabel, mapToSoftkey);
            writer.RenderText(text);
            RenderEndLink(writer, targetUrl, breakAfter);
        }

        protected void RenderBeginLink(WmlMobileTextWriter writer, 
                                       String targetUrl, 
                                       String softkeyLabel, 
                                       bool implicitSoftkeyLabel,
                                       bool mapToSoftkey)
        {
            if (mapToSoftkey && !writer.IsValidSoftkeyLabel(softkeyLabel))
            {
                // If softkey label was specified explicitly, then truncate.
                if (!implicitSoftkeyLabel && softkeyLabel.Length > 0)
                {
                    softkeyLabel = softkeyLabel.Substring(0, Device.MaximumSoftkeyLabelLength);
                }
                else
                {
                    softkeyLabel = GetDefaultLabel(LinkLabel);
                    implicitSoftkeyLabel = true;
                }
            }

            String postback = DeterminePostBack(targetUrl);
            
            if (postback != null)
            {
                writer.RenderBeginPostBack(softkeyLabel, implicitSoftkeyLabel, mapToSoftkey);
            }
            else
            {
                String prefix = Constants.FormIDPrefix;
                if (targetUrl.StartsWith(prefix))
                {
                    String formID = targetUrl.Substring(prefix.Length);
                    Form form = Control.ResolveFormReference(formID);
                    targetUrl = prefix + form.ClientID;
                }
                else
                {
                    bool absoluteUrl = ( (targetUrl.StartsWith("http:")) || (targetUrl.StartsWith("https:")) );
                    // AUI 3652
                    targetUrl = Control.ResolveUrl(targetUrl);
                    bool queryStringWritten = targetUrl.IndexOf('?') != -1; 
                    IDictionary dictionary = PageAdapter.CookielessDataDictionary;
                    String formsAuthCookieName = FormsAuthentication.FormsCookieName;
                    if((dictionary != null) && (!absoluteUrl) && (Control.MobilePage.Adapter.PersistCookielessData))
                    {
                        StringBuilder sb = new StringBuilder(targetUrl);

                        foreach(String name in dictionary.Keys)
                        {
                            if(queryStringWritten)
                            {
                                sb.Append("&amp;");
                            }
                            else
                            {
                                sb.Append("?");
                                queryStringWritten = true;
                            }

                            if(name.Equals(formsAuthCookieName) && Device.CanRenderOneventAndPrevElementsTogether )
                            {
                                sb.Append(name);
                                sb.Append("=$(");
                                sb.Append(writer.MapClientIDToShortName("__facn",false));
                                sb.Append(")");
                            }
                            else
                            {
                                sb.Append(name);
                                sb.Append("=");
                                sb.Append(dictionary[name]);
                            }
                        }
                        targetUrl = sb.ToString();
                    }
                }

                writer.RenderBeginHyperlink(targetUrl, 
                                            false, 
                                            softkeyLabel, 
                                            implicitSoftkeyLabel, 
                                            mapToSoftkey);
            }
        }

        protected void RenderEndLink(WmlMobileTextWriter writer, String targetUrl, bool breakAfter)
        {
            String postback = DeterminePostBack(targetUrl);
            
            if (postback != null)
            {
                writer.RenderEndPostBack(Control.UniqueID, postback, WmlPostFieldType.Normal, false, breakAfter);
            }
            else
            {
                writer.RenderEndHyperlink(breakAfter);
            }
        }

        protected String DeterminePostBack(String target)
        {
            String postback = null;
            String prefix = Constants.FormIDPrefix;
            if (target.StartsWith(prefix))     //  link to another form
            {
                String formID = target.Substring(prefix.Length);
                Form form = Control.ResolveFormReference(formID);
                Form thisForm = Control.Form;
                
                //  must postback to forms not rendered in deck (not visible) or links to same form,
                // as long as it's safe to do so.
                if (form == thisForm ||
                    !PageAdapter.IsFormRendered(form) || 
                    thisForm.HasDeactivateHandler() ||
                    form.HasActivateHandler())
                {
                    postback = form.UniqueID;
                }
            }
            return postback;
        }

        protected void RenderSubmitEvent(
            WmlMobileTextWriter writer,
            String softkeyLabel,
            String text,
            bool breakAfter)
        {
            RenderPostBackEvent(writer, null, softkeyLabel, true,
                                text, breakAfter, WmlPostFieldType.Submit);
        }

        protected void RenderPostBackEvent(
            WmlMobileTextWriter writer,
            String argument,
            String softkeyLabel,
            bool mapToSoftkey,
            String text,
            bool breakAfter)
        {
            RenderPostBackEvent(writer, argument, softkeyLabel, mapToSoftkey,
                                text, breakAfter, WmlPostFieldType.Normal);
        }

        protected void RenderPostBackEvent(
            WmlMobileTextWriter writer,
            String argument,
            String softkeyLabel,
            bool mapToSoftkey,
            String text,
            bool breakAfter,
            WmlPostFieldType postBackType)
        {
            bool implicitSoftkeyLabel = false;
            if (mapToSoftkey)
            {
                if (softkeyLabel == null || softkeyLabel.Length == 0)
                {
                    softkeyLabel = text;
                    implicitSoftkeyLabel = true;
                }

                if (!writer.IsValidSoftkeyLabel(softkeyLabel))
                {
                    // If softkey label was specified explicitly, then truncate.
                    if (!implicitSoftkeyLabel && softkeyLabel.Length > 0)
                    {
                        softkeyLabel = softkeyLabel.Substring(0, Device.MaximumSoftkeyLabelLength);
                    }
                    else
                    {
                        softkeyLabel = GetDefaultLabel(GoLabel);
                        implicitSoftkeyLabel = true;
                    }
                }
            }

            writer.RenderBeginPostBack(softkeyLabel, implicitSoftkeyLabel, mapToSoftkey);
            writer.RenderText(text);
            writer.RenderEndPostBack(Control.UniqueID, argument, postBackType, true, breakAfter);
        }

        protected virtual String GetPostBackValue()
        {
            return null;
        }

        internal String GetControlPostBackValue(MobileControl ctl)
        {
            WmlControlAdapter adapter = ctl.Adapter as WmlControlAdapter;
            return adapter != null ? adapter.GetPostBackValue() : null;
        }

        /////////////////////////////////////////////////////////////////////////
        //  SECONDARY UI SUPPORT
        /////////////////////////////////////////////////////////////////////////

        internal const int NotSecondaryUIInit = -1;  // For initialization of private consts in derived classes.
        protected static readonly int NotSecondaryUI = NotSecondaryUIInit;

        protected int SecondaryUIMode
        {
            get
            {
                if (Control == null || Control.Form == null) 
                {
                    return NotSecondaryUI;
                }
                else
                {
                    return ((WmlFormAdapter)Control.Form.Adapter).GetSecondaryUIMode(Control);
                }
            }
            set
            {
                ((WmlFormAdapter)Control.Form.Adapter).SetSecondaryUIMode(Control, value);
            }
        }

        protected void ExitSecondaryUIMode()
        {
            SecondaryUIMode = NotSecondaryUI;
        }

        public override void LoadAdapterState(Object state)
        {
            if (state != null)
            {
                SecondaryUIMode = (int)state;
            }
        }

        public override Object SaveAdapterState()
        {
            int mode = SecondaryUIMode;
            if (mode != NotSecondaryUI) 
            {
                return mode;
            }
            else
            {
                return null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlcommandadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlCommandAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlCommandAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlCommandAdapter : WmlControlAdapter
    {
        protected new Command Control
        {
            get
            {
                return (Command)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            writer.EnterStyle(Style);
            RenderSubmitEvent(writer, Control.SoftkeyLabel, Control.Text, Control.BreakAfter);
            writer.ExitStyle(Style);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\upwmlpageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="UpWmlPageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * UpWmlPageAdapter base class contains wml specific methods.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class UpWmlPageAdapter : WmlPageAdapter
    {
        public static new bool DeviceQualifies(HttpContext context)
        {
            MobileCapabilities capabilities = ((MobileCapabilities)context.Request.Browser);
            bool qualifies = capabilities.Browser == "Phone.com";
            return qualifies;
        }

        public override HtmlTextWriter CreateTextWriter(TextWriter writer)
        {
            return new UpWmlMobileTextWriter(writer, Device, Page);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlformadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlFormAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Web.Security;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlFormAdapter base class contains wml specific methods.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlFormAdapter : WmlControlAdapter
    {
        private IDictionary _postBackVariables = null;

        protected new Form Control
        {
            get
            {
                return (Form)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            String formsAuthCookieName = FormsAuthentication.FormsCookieName;
            if(!Device.SupportsRedirectWithCookie)
            {
                if(formsAuthCookieName != String.Empty)
                {
                    HttpContext.Current.Response.Cookies.Remove(formsAuthCookieName);
                }
            }

            writer.BeginForm(Control);
            if (Page.Adapter.PersistCookielessData &&
                Device.CanRenderOneventAndPrevElementsTogether &&
                formsAuthCookieName != null &&
                formsAuthCookieName != String.Empty &&
                Control == Page.ActiveForm )
            {
                IDictionary dictionary = PageAdapter.CookielessDataDictionary;
                if(dictionary != null)
                {
                    String value = (String)dictionary[formsAuthCookieName];
                    if((value != null) && (value != String.Empty))
                    {
                        writer.AddFormVariable("__facn", value, false);
                    }
                }
            }
            MobileControl secondaryUIControl = SecondaryUIControl as MobileControl;
            writer.EnterLayout(Style);
            if (secondaryUIControl != null && secondaryUIControl.Form == Control)
            {
                SetControlPageRecursive(secondaryUIControl, -1);
                secondaryUIControl.RenderControl(writer);
            }
            else
            {
                if (Control.HasControls())
                {
                    Panel header = Control.Header;
                    Panel footer = Control.Footer;

                    if (header != null)
                    {
                        writer.BeginCustomMarkup();
                        header.RenderControl(writer);
                        writer.EndCustomMarkup();
                    }

                    foreach(Control control in Control.Controls)
                    {
                        if (control != header && control != footer)
                        {
                            control.RenderControl(writer);
                        }
                    }

                    RenderPager(writer);

                    if (footer != null)
                    {
                        writer.BeginCustomMarkup();
                        footer.RenderControl(writer);
                        writer.EndCustomMarkup();
                    }
                }
                else
                {
                    RenderPager(writer);
                }
            }
            writer.ExitLayout(Style);
            writer.EndForm();
        }

        protected virtual void RenderPager(WmlMobileTextWriter writer)
        {
            PagerStyle pagerStyle = Control.PagerStyle;
            int pageCount = Control.PageCount;
            if (pageCount <= 1)
            {
                return;
            }
            int page = Control.CurrentPage;

            writer.EnterStyle(pagerStyle);
            if (page < pageCount)
            {
                String nextPageText = pagerStyle.GetNextPageText(page);
                RenderPostBackEvent(writer, 
                                    (page + 1).ToString(), 
                                    writer.IsValidSoftkeyLabel(nextPageText) ? nextPageText 
                                                                             : GetDefaultLabel(NextLabel),
                                    true,
                                    nextPageText, 
                                    true);
            }

            if (page > 1)
            {
                String prevPageText = pagerStyle.GetPreviousPageText(page);
                RenderPostBackEvent(writer, 
                                    (page - 1).ToString(), 
                                    writer.IsValidSoftkeyLabel(prevPageText) ? prevPageText
                                                                             : GetDefaultLabel(PreviousLabel),
                                    true,
                                    prevPageText, 
                                    true);
            }
            writer.ExitStyle(pagerStyle);
        }

        public virtual IDictionary CalculatePostBackVariables()
        {
            if (_postBackVariables == null)
            {
                _postBackVariables = new ListDictionary();
                BuildControlPostBacksRecursive(Control);
            }
            return _postBackVariables;
        }

        private void BuildControlPostBacksRecursive(Control control)
        {
            if (control is IPostBackDataHandler
                && !(control is IPostBackEventHandler)
                && control.Visible && control != Control)
            {
                MobileControl mobileCtl = control as MobileControl;

                if (mobileCtl != null && !mobileCtl.IsVisibleOnPage(Control.CurrentPage))
                {
                    String s = GetControlPostBackValue(mobileCtl);
                    if (s != null)
                    {
                        _postBackVariables[control] = s;
                    }
                }
                else
                {
                    _postBackVariables[control] = null;
                }
            }

            if (control.HasControls())
            {
                foreach (Control child in control.Controls)
                {
                    BuildControlPostBacksRecursive(child);
                }
            }
        }

        public override bool HandlePostBackEvent(String eventArgument)
        {
            String eventSource = eventArgument;
            int comma = eventSource.IndexOf(',');
            if (comma == -1)
            {
                eventArgument = null;
            }
            else
            {
                eventArgument = eventSource.Substring(comma + 1);
                eventSource = eventSource.Substring(0, comma);
            }

            if (eventSource.Length > 0)
            {
                Control sourceControl = Page.FindControl(eventSource);
                if (sourceControl != null && sourceControl is IPostBackEventHandler)
                {
                    ((IPostBackEventHandler)sourceControl).RaisePostBackEvent(eventArgument);
                }
            }

            return true;
        }

        protected internal virtual void RenderExtraCardElements(WmlMobileTextWriter writer)
        {
            Form form = this.Control as Form;
            if((form != null) && (form.Script != null))
            {
                foreach(Control childControl in form.Script.Controls)
                {
                    LiteralControl lc = childControl as LiteralControl;
                    if(lc != null)
                    {
                        writer.Write(lc.Text);
                    }
                    else
                    {
                        DataBoundLiteralControl dlc = childControl as DataBoundLiteralControl;
                        if(dlc != null)
                        {
                            writer.Write(dlc.Text);
                        }
                    }
                }
            }
         }

        protected internal virtual void RenderCardTag(WmlMobileTextWriter writer, IDictionary attributes)
        {
            writer.WriteBeginTag("card");
            if (attributes != null)
            {
                foreach (DictionaryEntry entry in attributes)
                {
                    writer.WriteAttribute((String)entry.Key, (String)entry.Value, true);
                }
            }
            writer.WriteLine(">");
        }

        /////////////////////////////////////////////////////////////////////////
        //  SECONDARY UI SUPPORT
        /////////////////////////////////////////////////////////////////////////

        private Control _secondaryUIControl;
        private int _secondaryUIMode;

        internal int GetSecondaryUIMode(Control control)
        {
            return (control != null && _secondaryUIControl == control) ? _secondaryUIMode : NotSecondaryUI;
        }

        internal void SetSecondaryUIMode(Control control, int mode)
        {
            if (mode != NotSecondaryUI)
            {
                if (_secondaryUIControl != null && _secondaryUIControl != control)
                {
                    throw new Exception(
                        SR.GetString(SR.FormAdapterMultiControlsAttemptSecondaryUI));
                }
                _secondaryUIControl = control;
                _secondaryUIMode = mode;
                return;
            }

            if (control == _secondaryUIControl)
            {
                _secondaryUIControl = null;
            }
        }

        internal Control SecondaryUIControl
        {
            get
            {
                return _secondaryUIControl;
            }
        }

        //identical to method in htmlformadapter
        private static void SetControlPageRecursive(Control control, int page)
        {
            MobileControl mc = control as MobileControl;
            if(mc != null)
            {
                mc.FirstPage = page;
                mc.LastPage = page;
            }
            if (control.HasControls())
            {
                foreach (Control child in control.Controls)
                {
                    MobileControl mobileChild = child as MobileControl;
                    if (mobileChild != null)
                    {
                            mobileChild.FirstPage = page;
                            mobileChild.LastPage = page;
                    }
                    else 
                    {
                        SetControlPageRecursive(child, page);
                    }
                }
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlcalendaradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlCalendarAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Web.UI.WebControls;
using System.Diagnostics;
using System.Collections;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * WmlCalendarAdapter provides the wml device functionality for Calendar
     * control.  It is using secondary UI support to provide internal screens
     * to allow the user to pick or enter a date.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlCalendarAdapter : WmlControlAdapter
    {
        private SelectionList _selectList;
        private TextBox _textBox;
        private List _optionList;
        private List _monthList;
        private List _weekList;
        private List _dayList;
        private int _chooseOption = FirstPrompt;
        private int _monthsToDisplay;
        private int _eraCount = 0;

        /////////////////////////////////////////////////////////////////////
        // Globalization of Calendar Information:
        // Similar to the globalization support of the ASP.NET Calendar control,
        // this support is done via COM+ thread culture info/object.
        // Specific example can be found from ASP.NET Calendar spec.
        /////////////////////////////////////////////////////////////////////

        // This member variable is set each time when calendar info needs to
        // be accessed and be shared for other helper functions.
        private Globalization.Calendar _threadCalendar;

        private String _textBoxErrorMessage;

        // Since SecondaryUIMode is an int type, we use constant integers here
        // instead of enum so the mode can be compared without casting.
        private const int FirstPrompt = NotSecondaryUIInit;
        private const int OptionPrompt = NotSecondaryUIInit + 1;
        private const int TypeDate = NotSecondaryUIInit + 2;
        private const int DateOption = NotSecondaryUIInit + 3;
        private const int WeekOption = NotSecondaryUIInit + 4;
        private const int MonthOption = NotSecondaryUIInit + 5;
        private const int ChooseMonth = NotSecondaryUIInit + 6;
        private const int ChooseWeek = NotSecondaryUIInit + 7;
        private const int ChooseDay = NotSecondaryUIInit + 8;
        private const int DefaultDateDone = NotSecondaryUIInit + 9;
        private const int TypeDateDone = NotSecondaryUIInit + 10;
        private const int Done = NotSecondaryUIInit + 11;

        private const String DaySeparator = " - ";
        private const String Space = " ";

        protected new Calendar Control
        {
            get
            {
                return (Calendar)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
            ListCommandEventHandler listCommandEventHandler;

            // Create secondary child controls for rendering secondary UI.
            // Note that their ViewState is disabled because they are used
            // for rendering only.
            //---------------------------------------------------------------

            _selectList = new SelectionList();
            _selectList.Visible = false;
            _selectList.EnableViewState = false;
            Control.Controls.Add(_selectList);

            _textBox = new TextBox();
            _textBox.Visible = false;
            _textBox.EnableViewState = false;
            Control.Controls.Add(_textBox);

            // Below are initialization of several list controls.  A note is
            // that here the usage of DataMember is solely for remembering
            // how many items a particular list control is bounded to.  The
            // property is not used as originally designed.
            //---------------------------------------------------------------

            _optionList = new List();
            _optionList.DataMember = "5";
            listCommandEventHandler = new ListCommandEventHandler(this.OptionListEventHandler);
            InitList(_optionList, listCommandEventHandler);

            // Use MobileCapabilities to check screen size and determine how
            // many months should be displayed for different devices.
            _monthsToDisplay = MonthsToDisplay(Device.ScreenCharactersHeight);

            // Create the list of months, including [Next] and [Prev] links
            _monthList = new List();
            _monthList.DataMember = Convert.ToString(_monthsToDisplay + 2);
            listCommandEventHandler = new ListCommandEventHandler(this.MonthListEventHandler);
            InitList(_monthList, listCommandEventHandler);

            _weekList = new List();
            _weekList.DataMember = "6";
            listCommandEventHandler = new ListCommandEventHandler(this.WeekListEventHandler);
            InitList(_weekList, listCommandEventHandler);

            _dayList = new List();
            _dayList.DataMember = "7";
            listCommandEventHandler = new ListCommandEventHandler(this.DayListEventHandler);
            InitList(_dayList, listCommandEventHandler);

            // Initialize the VisibleDate which will be used to keep track
            // the ongoing selection of year, month and day from multiple
            // secondary UI screens.  If the page is loaded for the first
            // time, it doesn't need to be initialized (since it is not used
            // yet) so no unnecessary viewstate value will be generated.
            if (Page.IsPostBack && Control.VisibleDate == DateTime.MinValue)
            {
                Control.VisibleDate = DateTime.Today;
            }
        }

        public override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            // Here we check to see which list control should be initialized
            // with items so postback event can be handled properly.
            if (Page.IsPostBack)
            {
                String controlId = Page.Request[MobilePage.HiddenPostEventSourceId];
                if (controlId != null && controlId.Length != 0)
                {
                    List list = Page.FindControl(controlId) as List;
                    if (list != null &&
                        Control.Controls.Contains(list))
                    {
                        DataBindListWithEmptyValues(
                            list, Convert.ToInt32(list.DataMember));
                    }
                }
            }
        }

        public override void LoadAdapterState(Object state)
        {
            if (state != null)
            {
                if (state is Pair)
                {
                    Pair pair = (Pair)state;
                    base.LoadAdapterState(pair.First);
                    _chooseOption = (int)pair.Second;
                }
                else if (state is Triplet)
                {
                    Triplet triplet = (Triplet)state;
                    base.LoadAdapterState(triplet.First);
                    _chooseOption = (int)triplet.Second;
                    Control.VisibleDate = new DateTime(Int64.Parse((String)triplet.Third));
                }
                else if (state is Object[])
                {
                    Object[] viewState = (Object[])state;
                    base.LoadAdapterState(viewState[0]);
                    _chooseOption = (int)viewState[1];
                    Control.VisibleDate = new DateTime(Int64.Parse((String)viewState[2]));
                    _eraCount = (int)viewState[3];

                    if (SecondaryUIMode == TypeDate)
                    {
                        // Create a placeholder list for capturing the selected era
                        // in postback data.
                        for (int i = 0; i < _eraCount; i++)
                        {
                            _selectList.Items.Add(String.Empty);
                        }
                    }
                }
                else
                {
                    _chooseOption = (int)state;
                }
            }
        }

        public override Object SaveAdapterState()
        {
            DateTime visibleDate = Control.VisibleDate;

            bool saveVisibleDate = visibleDate != DateTime.MinValue &&
                                        DateTime.Compare(visibleDate, DateTime.Today) != 0 && 
                                        !IsViewStateEnabled();
            Object baseState = base.SaveAdapterState();

            if (baseState == null && !saveVisibleDate && _eraCount == 0)
            {
                if (_chooseOption != FirstPrompt)
                {
                    return _chooseOption;
                }
                else
                {
                    return null;
                }
            }
            
            else if (!saveVisibleDate && _eraCount == 0)
            {
                return new Pair(baseState, _chooseOption);
            }
            else if (_eraCount == 0)
            {
                return new Triplet(baseState, _chooseOption, visibleDate.Ticks.ToString());
            }
            else
            {
                return new Object[] { baseState,
                                      _chooseOption,
                                      visibleDate.Ticks.ToString(),
                                      _eraCount };
            }
        }

        public override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);

            // We specially binding eras of the current calendar object here
            // when the UI of typing date is display.  We do it only if the
            // calendar supports more than one era.
            if (SecondaryUIMode == TypeDate)
            {
                DateTimeFormatInfo currentInfo = DateTimeFormatInfo.CurrentInfo;

                int [] ints = currentInfo.Calendar.Eras;

                if (ints.Length > 1)
                {
                    // Save the value in private view state
                    _eraCount = ints.Length;

                    int currentEra;
                    if (_selectList.SelectedIndex != -1)
                    {
                        currentEra = ints[_selectList.SelectedIndex];
                    }
                    else
                    {
                        currentEra =
                            currentInfo.Calendar.GetEra(Control.VisibleDate);
                    }

                    // Clear the placeholder item list if created in LoadAdapterState
                    _selectList.Items.Clear();

                    for (int i = 0; i < ints.Length; i++)
                    {
                        int era = ints[i];

                        _selectList.Items.Add(currentInfo.GetEraName(era));

                        // There is no association between the era value and
                        // its index in the era array, so we need to check it
                        // explicitly for the default selected index.
                        if (currentEra == era)
                        {
                            _selectList.SelectedIndex = i;
                        }
                    }
                    _selectList.Visible = true;
                }
                else
                {
                    // disable viewstate since no need to save any data for
                    // this control
                    _selectList.EnableViewState = false;
                }
            }
            else
            {
                _selectList.EnableViewState = false;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            ArrayList arr;
            DateTime tempDate;
            DateTimeFormatInfo currentDateTimeInfo = DateTimeFormatInfo.CurrentInfo;
            String abbreviatedMonthDayPattern = AbbreviateMonthPattern(currentDateTimeInfo.MonthDayPattern);
            _threadCalendar = currentDateTimeInfo.Calendar;

            // RendersWmlSelectsAsMenuCards is true means the list control will be
            // rendered as select/option tags, where the break tag before
            // them will become an extra line which doesn't like good.
            bool addBreakBeforeListControl = Device.RendersWmlSelectsAsMenuCards;

            writer.EnterStyle(Style);
            
            Debug.Assert(NotSecondaryUI == NotSecondaryUIInit);
            switch (SecondaryUIMode)
            {
                case FirstPrompt:
                    String promptText = Control.CalendarEntryText;
                    if (promptText == String.Empty)
                    {
                        promptText = SR.GetString(SR.CalendarAdapterFirstPrompt);
                    }

                    // Link to input option selection screen
                    RenderPostBackEvent(writer,
                                        OptionPrompt.ToString(),
                                        GetDefaultLabel(GoLabel),
                                        true,
                                        promptText,
                                        true);
                    break;

                // Render the first secondary page that provides differnt
                // options to select a date.
                case OptionPrompt:
                    writer.RenderText(SR.GetString(SR.CalendarAdapterOptionPrompt),
                                      !addBreakBeforeListControl);

                    arr = new ArrayList();

                    // Option to select the default date
                    arr.Add(Control.VisibleDate.ToString(
                        currentDateTimeInfo.ShortDatePattern));

                    // Option to another page that can enter a date by typing
                    arr.Add(SR.GetString(SR.CalendarAdapterOptionType));

                    // Options to a set of pages for selecting a date, a week
                    // or a month by picking month/year, week and day
                    // accordingly.  Available options are determined by
                    // SelectionMode.
                    arr.Add(SR.GetString(SR.CalendarAdapterOptionChooseDate));

                    if (Control.SelectionMode == CalendarSelectionMode.DayWeek ||
                        Control.SelectionMode == CalendarSelectionMode.DayWeekMonth)
                    {
                        arr.Add(SR.GetString(SR.CalendarAdapterOptionChooseWeek));

                        if (Control.SelectionMode == CalendarSelectionMode.DayWeekMonth)
                        {
                            arr.Add(SR.GetString(SR.CalendarAdapterOptionChooseMonth));
                        }
                    }
                    DataBindAndRender(writer, _optionList, arr);
                    break;

                // Render a title and textbox to capture a date entered by user
                case TypeDate:
                    if (_textBoxErrorMessage != null)
                    {
                        writer.RenderText(_textBoxErrorMessage, true);
                    }

                    if (_selectList.Visible)
                    {
                        writer.RenderText(SR.GetString(SR.CalendarAdapterOptionEra), true);
                        _selectList.RenderControl(writer);
                    }

                    String numericDateFormat = GetNumericDateFormat();

                    writer.RenderText(SR.GetString(SR.CalendarAdapterOptionType) + ":", true);
                    writer.RenderText("(");
                    writer.RenderText(numericDateFormat.ToUpper());
                    writer.RenderText(")");

                    if (!_selectList.Visible)
                    {
                        writer.RenderText(GetEra(Control.VisibleDate));
                    }
                    writer.RenderText(String.Empty, true);

                    _textBox.Numeric = true;
                    _textBox.Size = numericDateFormat.Length;
                    _textBox.MaxLength = numericDateFormat.Length;
                    _textBox.Text = Control.VisibleDate.ToString(numericDateFormat);
                    _textBox.Visible = true;
                    _textBox.RenderControl(writer);

                    String okLabel = GetDefaultLabel(OKLabel);

                    // accept softkey for sending the textbox value back to the server
                    RenderPostBackEvent(writer, 
                                        TypeDateDone.ToString(),
                                        okLabel,
                                        true,
                                        okLabel,
                                        true,
                                        WmlPostFieldType.Raw);
                    break;

                // Render a paged list for choosing a month
                case ChooseMonth:
                {
                    String displayText = String.Format("{0}:", SR.GetString(SR.CalendarAdapterOptionChooseMonth));
                    writer.RenderText(displayText, !addBreakBeforeListControl);

                    tempDate = Control.VisibleDate;

                    String abbreviatedYearMonthPattern = AbbreviateMonthPattern(currentDateTimeInfo.YearMonthPattern);

                    // This is to be consistent with ASP.NET Calendar control
                    // on handling YearMonthPattern:
                    // Some cultures have a comma in their YearMonthPattern,
                    // which does not look right in a calendar.  Here we
                    // strip the comma off.
                    int indexComma = abbreviatedYearMonthPattern.IndexOf(',');
                    if (indexComma >= 0)
                    {
                        abbreviatedYearMonthPattern =
                            abbreviatedYearMonthPattern.Remove(indexComma, 1);
                    }

                    arr = new ArrayList();
                    for (int i = 0; i < _monthsToDisplay; i++)
                    {
                        arr.Add(tempDate.ToString(abbreviatedYearMonthPattern));
                        tempDate = _threadCalendar.AddMonths(tempDate, 1);
                    }
                    arr.Add(GetDefaultLabel(NextLabel));
                    arr.Add(GetDefaultLabel(PreviousLabel));
                    DataBindAndRender(writer, _monthList, arr);
                    break;
                }

                // Based on the month selected in case ChooseMonth above, render a list of
                // availabe weeks of the month.
                case ChooseWeek:
                {
                    String monthFormat = (GetNumericDateFormat()[0] == 'y') ? "yyyy/M" : "M/yyyy";
                    String displayText = String.Format("{0} ({1}):",
                                                       SR.GetString(SR.CalendarAdapterOptionChooseWeek),
                                                       Control.VisibleDate.ToString(monthFormat));
                    writer.RenderText(displayText, !addBreakBeforeListControl);

                    // List weeks of days of the selected month.  May include
                    // days from the previous and the next month to fill out
                    // all six week choices.  This is consistent with the
                    // ASP.NET Calendar control.

                    // Note that the event handling code of this list control
                    // should be implemented according to the index content
                    // generated here.

                    tempDate = FirstCalendarDay(Control.VisibleDate);

                    arr = new ArrayList();
                    String weekDisplay;
                    for (int i = 0; i < 6; i++)
                    {
                        weekDisplay = tempDate.ToString(abbreviatedMonthDayPattern);
                        weekDisplay += DaySeparator;
                        tempDate = _threadCalendar.AddDays(tempDate, 6);
                        weekDisplay += tempDate.ToString(abbreviatedMonthDayPattern);
                        arr.Add(weekDisplay);
                        tempDate = _threadCalendar.AddDays(tempDate, 1);
                    }
                    DataBindAndRender(writer, _weekList, arr);
                    break;
                }

                // Based on the month and week selected in case ChooseMonth and ChooseWeek above,
                // render a list of the dates in the week.
                case ChooseDay:
                {
                    String displayText = String.Format("{0}:", SR.GetString(SR.CalendarAdapterOptionChooseDate));
                    writer.RenderText(displayText, !addBreakBeforeListControl);

                    tempDate = Control.VisibleDate;

                    arr = new ArrayList();
                    String date;
                    String dayName;
                    StringBuilder dayDisplay = new StringBuilder();
                    bool dayNameFirst = (GetNumericDateFormat()[0] != 'y');

                    for (int i = 0; i < 7; i++)
                    {
                        date = tempDate.ToString(abbreviatedMonthDayPattern);

                        if (Control.ShowDayHeader)
                        {
                            // Use the short format for displaying day name
                            dayName = GetAbbreviatedDayName(tempDate);
                            dayDisplay.Length = 0;

                            if (dayNameFirst)
                            {
                                dayDisplay.Append(dayName);
                                dayDisplay.Append(Space);
                                dayDisplay.Append(date);
                            }
                            else
                            {
                                dayDisplay.Append(date);
                                dayDisplay.Append(Space);
                                dayDisplay.Append(dayName);
                            }
                            arr.Add(dayDisplay.ToString());
                        }
                        else
                        {
                            arr.Add(date);
                        }
                        tempDate = _threadCalendar.AddDays(tempDate, 1);
                    }
                    DataBindAndRender(writer, _dayList, arr);
                    break;
                }

                default:
                    Debug.Assert(false, "Unexpected Secondary UI Mode");
                    break;
            }
            writer.ExitStyle(Style);
        }

        public override bool HandlePostBackEvent(String eventArgument)
        {
            // This is mainly to capture the option picked by the user on
            // secondary pages and manipulate SecondaryUIMode accordingly so
            // Render() can generate the appropriate UI.
            // It also capture the state "Done" which can be set when a date,
            // a week or a month is selected or entered in some secondary
            // page.

            SecondaryUIMode = Int32.Parse(eventArgument);

            Debug.Assert(NotSecondaryUI == NotSecondaryUIInit);
            switch (SecondaryUIMode)
            {
            case DefaultDateDone:
                SelectRange(Control.VisibleDate, Control.VisibleDate);
                goto case Done;

            case TypeDateDone:
                try
                {
                    String dateText = _textBox.Text;
                    String dateFormat = GetNumericDateFormat();
                    DateTimeFormatInfo currentInfo = DateTimeFormatInfo.CurrentInfo;
                    int eraIndex = _selectList.SelectedIndex;

                    if (eraIndex >= 0 &&
                        eraIndex < currentInfo.Calendar.Eras.Length)
                    {
                        dateText += currentInfo.GetEraName(currentInfo.Calendar.Eras[eraIndex]);
                        dateFormat += "gg";
                    }

                    DateTime dateTime = DateTime.ParseExact(dateText, dateFormat, null);
                    SelectRange(dateTime, dateTime);
                    Control.VisibleDate = dateTime;
                }
                catch
                {
                    _textBoxErrorMessage = SR.GetString(SR.CalendarAdapterTextBoxErrorMessage);
                    SecondaryUIMode = TypeDate;
                    break;
                }
                goto case Done;

            case Done:
                // Set the secondary exit code and raise the selection event for
                // web page developer to manipulate the selected date.
                ExitSecondaryUIMode();
                _chooseOption = FirstPrompt;
                break;

            case DateOption:
            case WeekOption:
            case MonthOption:
                _chooseOption = SecondaryUIMode;  // save in the ViewState

                // In all 3 cases, continue to the UI that chooses a month
                SecondaryUIMode = ChooseMonth;
                break;
            }

            return true;
        }

        /////////////////////////////////////////////////////////////////////
        // Misc. helper and wrapper functions
        /////////////////////////////////////////////////////////////////////

        private int MonthsToDisplay(int screenCharactersHeight)
        {
            const int MinMonthsToDisplay = 4;
            const int MaxMonthsToDisplay = 12;

            if (screenCharactersHeight < MinMonthsToDisplay)
            {
                return MinMonthsToDisplay;
            }
            else if (screenCharactersHeight > MaxMonthsToDisplay)
            {
                return MaxMonthsToDisplay;
            }
            return screenCharactersHeight;
        }

        // A helper function to initialize and add a child list control
        private void InitList(List list,
                              ListCommandEventHandler eventHandler)
        {
            list.Visible = false;
            list.ItemCommand += eventHandler;
            list.EnableViewState = false;
            Control.Controls.Add(list);
        }

        private void DataBindListWithEmptyValues(List list, int arraySize)
        {
            ArrayList arr = new ArrayList();
            for (int i = 0; i < arraySize; i++)
            {
                arr.Add("");
            }
            list.DataSource = arr;
            list.DataBind();
        }

        // A helper function to do the common code for DataBind and
        // RenderChildren.
        private void DataBindAndRender(WmlMobileTextWriter writer,
                                       List list,
                                       ArrayList arr)
        {
            list.DataSource = arr;
            list.DataBind();
            list.Visible = true;
            list.RenderControl(writer);
        }

        // Abbreviate the Month format from "MMMM" (full
        // month name) to "MMM" (three-character month abbreviation)
        private String AbbreviateMonthPattern(String pattern)
        {
            const String FullMonthFormat = "MMMM";

            int i = pattern.IndexOf(FullMonthFormat);
            if (i != -1)
            {
                pattern = pattern.Remove(i, 1);
            }
            return pattern;
        }

        private String GetAbbreviatedDayName(DateTime dateTime)
        {
            return DateTimeFormatInfo.CurrentInfo.GetAbbreviatedDayName(
                        _threadCalendar.GetDayOfWeek(dateTime));
        }

        private String GetEra(DateTime dateTime)
        {
            // We shouldn't need to display the era for the common Gregorian
            // Calendar
            if (DateTimeFormatInfo.CurrentInfo.Calendar.GetType() ==
                typeof(GregorianCalendar))
            {
                return String.Empty;
            }
            else
            {
                return dateTime.ToString("gg");
            }
        }

        private static readonly char[] formatChars =
                                            new char[] { 'M', 'd', 'y' };

        private String GetNumericDateFormat()
        {
            String shortDatePattern =
                DateTimeFormatInfo.CurrentInfo.ShortDatePattern;

            // Guess on what short date pattern should be used
            int i = shortDatePattern.IndexOfAny(formatChars);

            char firstFormatChar;
            if (i == -1)
            {
                firstFormatChar = 'M';
            }
            else
            {
                firstFormatChar = shortDatePattern[i];
            }

            // We either use two or four digits for the year
            String yearPattern;
            if (shortDatePattern.IndexOf("yyyy") == -1)
            {
                yearPattern = "yy";
            }
            else
            {
                yearPattern = "yyyy";
            }

            switch (firstFormatChar)
            {
            case 'M':
            default:
                return "MMdd" + yearPattern;
            case 'd':
                return "ddMM" + yearPattern;
            case 'y':
                return yearPattern + "MMdd";
            }
        }

        /////////////////////////////////////////////////////////////////////
        // Helper functions
        /////////////////////////////////////////////////////////////////////

        // Return the first date of the input year and month
        private DateTime EffectiveVisibleDate(DateTime visibleDate)
        {
            return _threadCalendar.AddDays(
                        visibleDate,
                        -(_threadCalendar.GetDayOfMonth(visibleDate) - 1));
        }

        // Return the beginning date of a calendar that includes the
        // targeting month.  The date can actually be in the previous month.
        private DateTime FirstCalendarDay(DateTime visibleDate)
        {
            DateTime firstDayOfMonth = EffectiveVisibleDate(visibleDate);
            int daysFromLastMonth =
                ((int)_threadCalendar.GetDayOfWeek(firstDayOfMonth)) -
                NumericFirstDayOfWeek();

            // Always display at least one day from the previous month
            if (daysFromLastMonth <= 0)
            {
                daysFromLastMonth += 7;
            }
            return _threadCalendar.AddDays(firstDayOfMonth, -daysFromLastMonth);
        }

        private int NumericFirstDayOfWeek()
        {
            // Used globalized value by default
            return(Control.FirstDayOfWeek == FirstDayOfWeek.Default) 
            ? (int) DateTimeFormatInfo.CurrentInfo.FirstDayOfWeek
            : (int) Control.FirstDayOfWeek;
        }

        /////////////////////////////////////////////////////////////////////
        // The followings are event handlers to capture the selection from
        // the corresponding list control in an secondary page.  The index of
        // the selection is used to determine which and how the next
        // secondary page is rendered.  Some event handlers below update
        // Calendar.VisibleDate and set SecondaryUIMode with appropriate
        // values.
        ////////////////////////////////////////////////////////////////////////

        private static readonly int[] Options =
            {DefaultDateDone, TypeDate, DateOption, WeekOption, MonthOption};

        private void OptionListEventHandler(Object source, ListCommandEventArgs e)
        {
            SecondaryUIMode = Options[e.ListItem.Index];
            HandlePostBackEvent(SecondaryUIMode.ToString());
        }

        private void MonthListEventHandler(Object source, ListCommandEventArgs e)
        {
            _threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;

            if (e.ListItem.Index == _monthsToDisplay)
            {
                // Next was selected
                Control.VisibleDate = _threadCalendar.AddMonths(
                                        Control.VisibleDate, _monthsToDisplay);
                SecondaryUIMode = ChooseMonth;
            }
            else if (e.ListItem.Index == _monthsToDisplay + 1)
            {
                // Prev was selected
                Control.VisibleDate = _threadCalendar.AddMonths(
                                        Control.VisibleDate, -_monthsToDisplay);
                SecondaryUIMode = ChooseMonth;
            }
            else
            {
                // A month was selected
                Control.VisibleDate = _threadCalendar.AddMonths(
                                        Control.VisibleDate,
                                        e.ListItem.Index);

                if (_chooseOption == MonthOption)
                {
                    // Add the whole month to the date list
                    DateTime beginDate = EffectiveVisibleDate(Control.VisibleDate);
                    Control.VisibleDate = beginDate;

                    DateTime endDate = _threadCalendar.AddMonths(beginDate, 1);
                    endDate = _threadCalendar.AddDays(endDate, -1);

                    SelectRange(beginDate, endDate);
                    HandlePostBackEvent(Done.ToString());
                }
                else
                {
                    SecondaryUIMode = ChooseWeek;
                }
            }
        }

        private void WeekListEventHandler(Object source, ListCommandEventArgs e)
        {
            // Get the first calendar day and adjust it to the week the user
            // selected (to be consistent with the index setting in Render())
            _threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;

            DateTime tempDate = FirstCalendarDay(Control.VisibleDate);

            Control.VisibleDate = _threadCalendar.AddDays(tempDate, e.ListItem.Index * 7);

            if (_chooseOption == WeekOption)
            {
                // Add the whole week to the date list
                DateTime endDate = _threadCalendar.AddDays(Control.VisibleDate, 6);

                SelectRange(Control.VisibleDate, endDate);
                HandlePostBackEvent(Done.ToString());
            }
            else
            {
                SecondaryUIMode = ChooseDay;
            }
        }

        private void DayListEventHandler(Object source, ListCommandEventArgs e)
        {
            _threadCalendar = DateTimeFormatInfo.CurrentInfo.Calendar;

            // VisibleDate should have been set with the first day of the week
            // so the selected index can be used to adjust to the selected day.
            Control.VisibleDate = _threadCalendar.AddDays(Control.VisibleDate, e.ListItem.Index);

            SelectRange(Control.VisibleDate, Control.VisibleDate);
            HandlePostBackEvent(Done.ToString());
        }

        private void SelectRange(DateTime dateFrom, DateTime dateTo)
        {
            Debug.Assert(dateFrom <= dateTo, "Bad Date Range");

            // see if this range differs in any way from the current range
            // these checks will determine this because the colleciton is sorted
            TimeSpan ts = dateTo - dateFrom;
            SelectedDatesCollection selectedDates = Control.SelectedDates;
            if (selectedDates.Count != ts.Days + 1 
                || selectedDates[0] != dateFrom
                || selectedDates[selectedDates.Count - 1] != dateTo)
            {
                selectedDates.SelectRange(dateFrom, dateTo);
                Control.RaiseSelectionChangedEvent();
            }
        }

        private bool IsViewStateEnabled()
        {
            Control ctl = Control;
            while (ctl != null)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
                ctl = ctl.Parent;
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlimageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlImageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * WmlImageAdapter class.
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlImageAdapter : WmlControlAdapter
    {
        protected new Image Control
        {
            get
            {
                return (Image)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            String source = Control.ImageUrl;
            String target = Control.NavigateUrl;
            String text   = Control.AlternateText;
            bool   breakAfterContents = Control.BreakAfter;
            String softkeyLabel = Control.SoftkeyLabel;
            bool implicitSoftkeyLabel = false;
            if (softkeyLabel.Length == 0)
            {
                implicitSoftkeyLabel = true;
                softkeyLabel = text;
            }

            writer.EnterLayout(Style);
            if (target != String.Empty)
            {
                RenderBeginLink(writer, target, softkeyLabel, implicitSoftkeyLabel, true);
                breakAfterContents = false;
            }

            if (source == String.Empty)
            {
                // Just write the alternate as text
                writer.RenderText(text, breakAfterContents);
            }
            else
            {
                String localSource;

                if (source.StartsWith(Constants.SymbolProtocol))
                {
                    // src is required according to WML
                    localSource = source.Substring(Constants.SymbolProtocol.Length);
                    source = String.Empty;
                }
                else
                {
                    localSource = null;

                    // AUI 3652
                    source = Control.ResolveUrl(source);

                    writer.AddResource(source);
                }

                writer.RenderImage(source, localSource, text, breakAfterContents);
            }

            if (target != String.Empty)
            {
                RenderEndLink(writer, target, Control.BreakAfter);
            }
            writer.ExitLayout(Style);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmllabeladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlLabelAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlLabelAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlLabelAdapter : WmlControlAdapter
    {
        protected new TextControl Control
        {
            get
            {
                return (TextControl)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            writer.EnterStyle(Style);
            writer.RenderText(Control.Text, Control.BreakAfter);
            writer.ExitStyle(Style);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmllistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * WmlListAdapter provides the wml device functionality for List controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlListAdapter : WmlControlAdapter
    {
        protected new List Control
        {
            get
            {
                return (List)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            if(Control.HasControls())
            {
                writer.BeginCustomMarkup();
                RenderChildren(writer);
                writer.EndCustomMarkup();
                return;
            }

            int pageStart = Control.FirstVisibleItemIndex;
            int pageSize = Control.VisibleItemCount;
            if (pageSize == 0)
            {
                return;
            }

            MobileListItemCollection items = Control.Items;
            if (items.Count == 0)
            {
                return;
            }

            bool itemsAsLinks = Control.ItemsAsLinks;
            bool hasCmdHandler = Control.HasItemCommandHandler;

            writer.EnterStyle(Style);
            for (int i = 0; i < pageSize; i++)
            {                        
                MobileListItem item = items[pageStart + i];

                if (itemsAsLinks)
                {
                    RenderLink(writer, item.Value, null, false, false, item.Text, true);
                }
                else if (hasCmdHandler)
                {
                    RenderPostBackEvent(writer, item.Index.ToString(), null, true, item.Text, true); 
                }
                else
                {
                    writer.RenderText(item.Text, true);
                }
            }
            writer.ExitStyle(Style);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlliteraltextadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlLiteralTextAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Drawing;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlLiteralTextAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlLiteralTextAdapter : WmlControlAdapter
    {
        protected new LiteralText Control
        {
            get
            {
                return (LiteralText)base.Control;
            }
        }

        String _pagedText;

        public override void Render(WmlMobileTextWriter writer)
        {
            // Cache value, because Render is called twice.
            if (_pagedText == null)
            {
                _pagedText = Control.PagedText;
            }
            writer.EnterFormat(Style);
            writer.RenderText(_pagedText, Control.BreakAfter);
            writer.ExitFormat(Style);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmllinkadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlLinkAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlLinkAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlLinkAdapter : WmlControlAdapter
    {
        protected new Link Control
        {
            get
            {
                return (Link)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            String targetUrl = Control.NavigateUrl;
            String text = (Control.Text == String.Empty) ? targetUrl : Control.Text;
            bool breakAfter = Control.BreakAfter && !Device.RendersBreaksAfterWmlAnchor;
            String softkeyLabel = Control.SoftkeyLabel;
            bool implicitSoftkeyLabel = false;
            if (softkeyLabel.Length == 0)
            {
                implicitSoftkeyLabel = true;
                softkeyLabel = Control.Text;
            }

            writer.EnterStyle(Style);
            RenderLink(writer, targetUrl, softkeyLabel, implicitSoftkeyLabel, true, text, breakAfter);
            writer.ExitStyle(Style);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlobjectlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlObjectListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlObjectListAdapter provides WML rendering of Object List control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlObjectListAdapter : WmlControlAdapter
    {
        private const String _backToList = "__back";
        private const String _showMenu = "__menu";
        private const String _showDetails = "__details";
        private const String _showMoreFormat = "__more$({0})";
        private const String _showMoreFormatAnchor = "__more{0}";
        private const String _showMore = "__more";
        private const int _modeItemMenu = 1;
        private const int _modeItemDetails = 2;

        protected new ObjectList Control
        {
            get
            {
                return (ObjectList)base.Control;
            }
        }

        public override void OnPreRender(EventArgs e)
        {
            base.OnPreRender(e);
            switch (Control.ViewMode)
            {
                case ObjectListViewMode.List:
                    SecondaryUIMode = NotSecondaryUI;
                    break;

                case ObjectListViewMode.Commands:
                    SecondaryUIMode = _modeItemMenu;
                    break;

                case ObjectListViewMode.Details:
                    SecondaryUIMode = _modeItemDetails;
                    break;
            }

            if(Control.MobilePage.ActiveForm == Control.Form && 
                Control.Visible && 
                Control.ViewMode == ObjectListViewMode.Commands &&
                Control.Items.Count > 0)
            {
                Control.PreShowItemCommands (Control.SelectedIndex);
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            switch (Control.ViewMode)
            {
                case ObjectListViewMode.List:
                    if (Control.HasControls())
                    {
                        writer.BeginCustomMarkup();
                        RenderChildren(writer);
                        writer.EndCustomMarkup();
                        return;
                    }
                    RenderItemsList(writer);
                    break;

                case ObjectListViewMode.Commands:
                    RenderItemMenu(writer, Control.Selection);
                    break;

                case ObjectListViewMode.Details:
                    if (Control.Selection.HasControls())
                    {
                        writer.BeginCustomMarkup();
                        Control.Selection.RenderChildren(writer);
                        writer.EndCustomMarkup();
                        return;
                    }
                    RenderItemDetails(writer, Control.Selection);
                    break;
            }
        }

        public override void CreateTemplatedUI(bool doDataBind)
        {
            if (Control.ViewMode == ObjectListViewMode.List)
            {
                Control.CreateTemplatedItemsList(doDataBind);
            }
            else
            {
                Control.CreateTemplatedItemDetails(doDataBind);
            }
        }

        protected virtual void RenderItemsList(WmlMobileTextWriter writer)
        {
            bool rendersAcceptsInline = Device.RendersWmlDoAcceptsInline;
            bool rendersSelectsAsMenuCards = Device.RendersWmlSelectsAsMenuCards;
            bool rendersBreaksAfterAnchor = Device.RendersBreaksAfterWmlAnchor;
            int pageStart = Control.FirstVisibleItemIndex;
            int pageSize = Control.VisibleItemCount;
            ObjectListItemCollection items = Control.Items;

            if (pageSize == 0 || items.Count == 0)
            {
                return;
            }

            bool hasDefaultCommand = HasDefaultCommand();
            bool onlyHasDefaultCommand = OnlyHasDefaultCommand();
            bool requiresSecondScreen = HasItemDetails() || (!onlyHasDefaultCommand && HasCommands());
            bool itemRequiresHyperlink = requiresSecondScreen || hasDefaultCommand;

            writer.EnterLayout(Style);

            int[] tableFieldIndices = null;
            if (ShouldRenderAsTable() && (tableFieldIndices = Control.TableFieldIndices).Length != 0)
            {
                writer.BeginCustomMarkup();
                int fieldCount = tableFieldIndices.Length;
                writer.Write("<table columns=\"");
                writer.Write(fieldCount.ToString());
                writer.WriteLine("\">");

                if (ShouldRenderTableHeaders())
                {
                    writer.Write("<tr>");
                    foreach (int fieldIndex in tableFieldIndices)
                    {
                        writer.Write("<td>");
                        writer.RenderText(Control.AllFields[fieldIndex].Title);
                        writer.Write("</td>");
                    }
                    writer.WriteLine("</tr>");
                }

                for (int i = 0; i < pageSize; i++)
                {
                    ObjectListItem item = items[pageStart + i];
                    writer.Write("<tr>");
                    for (int field = 0; field < fieldCount; field++)
                    {
                        writer.Write("<td>");
                        if (field == 0 && itemRequiresHyperlink)
                        {
                            RenderPostBackEvent(writer, 
                                requiresSecondScreen ?
                                    String.Format(_showMoreFormatAnchor, item.Index) :
                                    item.Index.ToString(),
                                GetDefaultLabel(GoLabel),
                                false,
                                item[tableFieldIndices[0]],
                                false,
                                WmlPostFieldType.Raw);
                        }
                        else
                        {
                            writer.RenderText(item[tableFieldIndices[field]]);
                        }
                        writer.Write("</td>");
                    }
                    writer.WriteLine("</tr>");
                }
                writer.WriteLine("</table>");
                writer.EndCustomMarkup();
            }
            else
            {
                int labelFieldIndex = Control.LabelFieldIndex;
                ObjectListField labelField = Control.AllFields[labelFieldIndex];

                writer.EnterFormat(Style);
                for (int i = 0; i < pageSize; i++)
                {
                    ObjectListItem item = items[pageStart + i];
                    if (itemRequiresHyperlink)
                    {
                        RenderPostBackEvent(writer, 
                            requiresSecondScreen ?
                                String.Format(_showMoreFormatAnchor, item.Index) :
                                item.Index.ToString(),
                            GetDefaultLabel(GoLabel),
                            false,
                            item[labelFieldIndex],
                            true,
                            WmlPostFieldType.Raw);
                    }
                    else
                    {
                        writer.RenderText(item[labelFieldIndex], true);
                    }
                }
                writer.ExitFormat(Style);
            }

            writer.ExitLayout(Style);
        }

        protected virtual void RenderItemMenu(WmlMobileTextWriter writer, ObjectListItem item)
        {
            bool requiresDetails = HasItemDetails();

            String detailsCommandText = Control.DetailsCommandText == String.Empty ?
                SR.GetString(SR.WmlObjectListAdapterDetails) :
                Control.DetailsCommandText;
            String softkeyLabel = detailsCommandText.Length <= Device.MaximumSoftkeyLabelLength ?
                detailsCommandText :
                null;
            Style commandStyle = Control.CommandStyle;
            if (commandStyle.Alignment == Alignment.NotSet)
            {
                commandStyle.Alignment = Alignment.Left;
            }
            writer.EnterStyle(commandStyle);
            if (requiresDetails)
            {
                RenderPostBackEvent(writer, _showDetails,
                        softkeyLabel, true, detailsCommandText, true, WmlPostFieldType.Raw);
            }

            ObjectListCommandCollection commands = Control.Commands;
            foreach (ObjectListCommand command in commands)
            {
                RenderPostBackEvent(writer, command.Name, 
                    GetDefaultLabel(GoLabel), false, command.Text, true, WmlPostFieldType.Raw);
            }
            writer.ExitStyle(commandStyle);
        }

        protected virtual void RenderItemDetails(WmlMobileTextWriter writer, ObjectListItem item)
        {
            String backCommandText = Control.BackCommandText == String.Empty ?
                GetDefaultLabel(BackLabel) :
                Control.BackCommandText;
            String softkeyLabel = backCommandText.Length <= Device.MaximumSoftkeyLabelLength ?
                backCommandText :
                null;

            Style labelStyle = Control.LabelStyle;
            writer.EnterStyle(labelStyle);
            writer.RenderText(item[Control.LabelFieldIndex], true);
            writer.ExitStyle(labelStyle);

            writer.EnterStyle(Style);
            IObjectListFieldCollection fields = Control.AllFields;
            int fieldIndex = 0;
            foreach (ObjectListField field in fields)
            {
                if (field.Visible)
                {
                    String displayText = String.Format("{0}: {1}", field.Title, item[fieldIndex]);
                    writer.RenderText(displayText, true);
                }
                fieldIndex++;
            }
            RenderPostBackEvent(writer, _backToList, softkeyLabel, true, backCommandText, true);
            writer.ExitStyle(Style);
        }

        public override bool HandlePostBackEvent(String eventArgument)
        {
            switch (Control.ViewMode)
            {
                case ObjectListViewMode.List:

                    // DCR 2493 - raise a selection event, and only continue
                    // handling if asked to.

                    if (eventArgument.StartsWith(_showMore))
                    {
                        int itemIndex = ParseItemArg(eventArgument);

                        if (Control.SelectListItem(itemIndex, true))
                        {
                            if (HasCommands())
                            {
                                Control.ViewMode = ObjectListViewMode.Commands;
                            }
                            else
                            {
                                Control.ViewMode = ObjectListViewMode.Details;
                            }
                        }
                    }
                    else
                    {
                        int itemIndex = -1;
                        try
                        {
                            itemIndex = Int32.Parse(eventArgument);
                        }
                        catch (System.FormatException)
                        {
                            throw new Exception (SR.GetString(SR.ObjectListAdapter_InvalidPostedData));
                        }
                        if (Control.SelectListItem(itemIndex, false))
                        {
                            Control.RaiseDefaultItemEvent(itemIndex);
                        }
                    }
                    return true;

                case ObjectListViewMode.Commands:

                    if (eventArgument == _backToList)
                    {
                        Control.ViewMode = ObjectListViewMode.List;
                        return true;
                    }
                    else if (eventArgument == _showDetails)
                    {
                        Control.ViewMode = ObjectListViewMode.Details;
                        return true;
                    }
                    break;

                case ObjectListViewMode.Details:

                    if (eventArgument == _backToList)
                    {
                        Control.ViewMode = ObjectListViewMode.List;
                        return true;
                    }
                    else if (eventArgument == _showMenu)
                    {
                        Control.ViewMode = ObjectListViewMode.Commands;
                        return true;
                    }
                    break;
            }

            return false;
        }

        private static int ParseItemArg(String arg)
        {
            return Int32.Parse(arg.Substring(_showMore.Length));
        }

        protected virtual bool ShouldRenderAsTable()
        {
            int avgFieldWidth = 10; // an arbitrary estimate.
            return Device.ScreenCharactersHeight > 4 && VisibleTableFieldsCount * avgFieldWidth < Device.ScreenCharactersWidth;
        }

        private bool ShouldRenderTableHeaders()
        {
            return true;
        }

        private BooleanOption _hasItemDetails = BooleanOption.NotSet;
        protected bool HasItemDetails()
        {
            if(Control.Items.Count == 0)
            {
                return false;
            }
            if (_hasItemDetails == BooleanOption.NotSet)
            {
                // Calculate how many visible fields are shown in list view.

                int visibleFieldsInListView;
                int[] tableFieldIndices;
                if (ShouldRenderAsTable() && (tableFieldIndices = Control.TableFieldIndices).Length != 0)
                {
                    visibleFieldsInListView = 0;
                    for (int i = 0; i < tableFieldIndices.Length; i++)
                    {
                        if (Control.AllFields[tableFieldIndices[i]].Visible)
                        {
                            visibleFieldsInListView++;
                        }
                    }
                }
                else
                {
                    visibleFieldsInListView = Control.AllFields[Control.LabelFieldIndex].Visible ?
                                                    1 : 0;
                }


                // Calculate the number of visible fields.

                _hasItemDetails = BooleanOption.False;
                int visibleFieldCount = 0;
                foreach (ObjectListField field in Control.AllFields)
                {
                    if (field.Visible)
                    {
                        visibleFieldCount++;
                        if (visibleFieldCount > visibleFieldsInListView)
                        {
                            _hasItemDetails = BooleanOption.True;
                            break;
                        }
                    }
                }
            }

            return _hasItemDetails == BooleanOption.True;
        }

        protected bool HasCommands()
        {
            return Control.Commands.Count > 0;
        }

        protected bool HasDefaultCommand()
        {
            return Control.DefaultCommand.Length > 0;
        }

        private BooleanOption _onlyHasDefaultCommand = BooleanOption.NotSet;
        protected bool OnlyHasDefaultCommand()
        {
            if (_onlyHasDefaultCommand == BooleanOption.NotSet)
            {
                String defaultCommand = Control.DefaultCommand;
                if (defaultCommand.Length > 0)
                {
                    int commandCount = Control.Commands.Count;
                    if (commandCount == 0 || 
                        (commandCount == 1 && 
                            String.Compare(defaultCommand, Control.Commands[0].Name, true, CultureInfo.InvariantCulture) == 0))
                    {
                        _onlyHasDefaultCommand = BooleanOption.True;
                    }
                    else
                    {
                        _onlyHasDefaultCommand = BooleanOption.False;
                    }
                }
                else
                {
                    _onlyHasDefaultCommand = BooleanOption.False;
                }
            }

            return _onlyHasDefaultCommand == BooleanOption.True;
        }
        
        // This appears in both Html and Wml adapters, is used in
        // ShouldRenderAsTable().  In adapters rather than control
        // because specialized rendering method.
        private int _visibleTableFieldsCount = -1;
        private int VisibleTableFieldsCount
        {
            get
            {
                if (_visibleTableFieldsCount == -1)
                {
                    int[] tableFieldIndices = Control.TableFieldIndices;
                    _visibleTableFieldsCount = 0;
                    for (int i = 0; i < tableFieldIndices.Length; i++)
                    {
                        if (Control.AllFields[tableFieldIndices[i]].Visible)
                        {
                            _visibleTableFieldsCount++;
                        }
                    }
                }
                return _visibleTableFieldsCount;
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlpaneladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlPanelAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlPanelAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlPanelAdapter : WmlControlAdapter
    {
        protected new Panel Control
        {
            get
            {
                return (Panel)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            if (Control.Content != null)
            {
                writer.BeginCustomMarkup();
                Control.Content.RenderControl(writer);
                writer.EndCustomMarkup();
            }
            else
            {
                writer.EnterLayout(Style);
                RenderChildren(writer);
                writer.ExitLayout(Style, Control.BreakAfter);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlphonecalladapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlPhoneCallAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlPhoneCallAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlPhoneCallAdapter : WmlControlAdapter
    {
        protected new PhoneCall Control
        {
            get
            {
                return (PhoneCall)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            String text, url, phoneNumber;
            String controlText = Control.Text;

            // Always strip off optional separators for PhoneNumber before it
            // is added in markup.

            String originalNumber = Control.PhoneNumber;
            char[] plainNumber = new char[originalNumber.Length];  // allocate enough buffer size

            // Loop to strip out optional separators
            int sizeOfPlainNumber = 0;
            foreach (char ch in originalNumber)
            {
                if ((ch >= '0' && ch <= '9') || ch == '+')
                {
                    plainNumber[sizeOfPlainNumber] = ch;
                    sizeOfPlainNumber++;
                }
            }

            // Assign the number string with the right size
            phoneNumber = new String(plainNumber, 0, sizeOfPlainNumber);

            // Construct text and url based on device capabilities
            //
            if (!Device.CanInitiateVoiceCall)
            {
                text = String.Format(Control.AlternateFormat,
                                     controlText,
                                     originalNumber);
                url = Control.AlternateUrl;
            }
            else
            {
                // Some WML browsers require the phone number
                // showing as text so it can be selected.  If it is not
                // formatted in the text yet, append it to the end of the
                // text.
                if(Device.RequiresPhoneNumbersAsPlainText)
                {
                    text = controlText + " " + phoneNumber;
                    url = String.Empty;
                }
                else
                {
                    text = (controlText != String.Empty) ?
                                controlText : originalNumber;
                    url = "wtai://wp/mc;" + phoneNumber;
                }
            }

            // Write out plain text or corresponding link/softkey command
            // accordingly
            //
            writer.EnterStyle(Style);
            if (url.Length == 0)
            {
                writer.RenderText(text, Control.BreakAfter);
            }
            else
            {
                String softkeyLabel = Control.SoftkeyLabel;
                bool implicitSoftkeyLabel = false;
                if (softkeyLabel.Length == 0)
                {
                    implicitSoftkeyLabel = true;
                    softkeyLabel = text;
                }
                if (!writer.IsValidSoftkeyLabel(softkeyLabel))
                {
                    if (!implicitSoftkeyLabel && softkeyLabel.Length > 0)
                    {
                        softkeyLabel = softkeyLabel.Substring(0, Device.MaximumSoftkeyLabelLength);
                    }
                    else
                    {
                        implicitSoftkeyLabel = true;
                        softkeyLabel = GetDefaultLabel(CallLabel);
                    }
                }
                RenderBeginLink(writer, url, softkeyLabel, implicitSoftkeyLabel, true);
                writer.RenderText(text);
                RenderEndLink(writer, url, Control.BreakAfter);
            }
            writer.ExitStyle(Style);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlpostfieldtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlPostFieldType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Drawing;
using System.IO;
using System.Web;
using System.Web.Mobile;
using System.Web.UI;
using System.Web.UI.MobileControls;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{
    /*
     * WmlPostFieldType enumeration.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    public enum WmlPostFieldType
    {
        Normal,
        Submit,
        Variable,
        Raw
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlselectionlistadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlSelectionListAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Collections.Specialized;
using System.Text.RegularExpressions;
using System.Collections;
using System.Text;
using System.Diagnostics;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlSelectionListAdapter provides the wml device functionality for SelectionList controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlSelectionListAdapter : WmlControlAdapter
    {
        private String _ivalue = null;
        private const String ClientPrefix = "__slst_";

        protected new SelectionList Control
        {
            get
            {
                return (SelectionList)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
        }

        public override void OnPreRender(EventArgs e)
        {
            int firstSelectedIndex;
            MobileListItemCollection items = Control.Items;
            int count = items.Count;
            for(firstSelectedIndex = 0; firstSelectedIndex < count; firstSelectedIndex++)
            {
                if(items[firstSelectedIndex].Selected)
                {
                    break;
                }
            }
            if(firstSelectedIndex < count)
            {
                StringBuilder ivalue=new StringBuilder();
                ivalue.Append((firstSelectedIndex + 1).ToString());
                if(Control.IsMultiSelect) 
                {
                    for(int i = firstSelectedIndex + 1; i < count; i++)
                    {
                        if(items[i].Selected)
                        {
                            ivalue.Append(";");
                            ivalue.Append((i + 1).ToString());
                        }
                    }
                }

                _ivalue = ivalue.ToString();
            }
            else
            {
                String defaultValue = null;

                if (!Control.IsMultiSelect)
                {
                    // 1 is the first index of a single selection list
                    defaultValue = "1";
                }
                else if (Device.CanRenderSetvarZeroWithMultiSelectionList)
                {
                    // 0 means no items have been selected, for MultiSelect case
                    defaultValue = "0";
                }

                if (defaultValue != null)
                {
                    _ivalue = defaultValue;
                }
            }            
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            MobileListItemCollection items = Control.Items;
            int count = items.Count;
            if (count == 0)
            {
                return;
            }           

            writer.EnterLayout(Style);
            bool crossPagePost = Control.Form.Action != String.Empty;

            if (crossPagePost)
            {
                if (_ivalue != null)
                {
                    String formVariable = ClientPrefix + Control.ClientID;
                    writer.AddFormVariable (formVariable, _ivalue, false);
                    // does not render _ivalue if null or form variables written.
                    writer.RenderBeginSelect(Control.ClientID, formVariable, _ivalue, Control.Title, Control.IsMultiSelect);
                }
                else // _ivalue == null
                {
                    writer.RenderBeginSelect(Control.ClientID, null, null, Control.Title, Control.IsMultiSelect);
                }
            }
            else // !crossPagePost
            {
                if (_ivalue != null)
                {
                    writer.AddFormVariable (Control.ClientID, _ivalue, false);
                }
                // does not render _ivalue if null or form variables written.
                writer.RenderBeginSelect(null, Control.ClientID, _ivalue, Control.Title, Control.IsMultiSelect);            
            }

            foreach (MobileListItem item in items)
            {
                if (crossPagePost)
                {
                    writer.RenderSelectOption(item.Text, item.Value);
                }
                else
                {
                    writer.RenderSelectOption(item.Text);
                }
            }
            writer.RenderEndSelect(Control.BreakAfter);
            writer.ExitLayout(Style);
        }

        // Parse the WML posted data appropriately.
        public override bool LoadPostData(String key,
                                          NameValueCollection data,
                                          Object controlPrivateData,
                                          out bool dataChanged)
        {
            int[] selectedItemIndices;
            String[] selectedItems = data.GetValues(key);
            Debug.Assert (Control.Form.Action == String.Empty, 
                "Cross page post (!IsPostBack) assumed when Form.Action nonempty." +
                "LoadPostData should not have been be called.");
            // Note: controlPrivateData is selectedIndices from viewstate.
            int[] originalSelectedIndices = (int[])controlPrivateData;

            dataChanged = false;

            if (selectedItems == null)
            {
                // This shouldn't happen if we're posting back from the form that
                // contains the selection list. It could happen when being called 
                // as the result of a postback from another form on the page,
                // so we just return quietly.

                return true;
            }

            if (Control.Items.Count == 0)
            {
                return true;
            }

            // If singleselect && nothing was selected, select
            // first elt.  (Non-mobile DropDown does same by getting SelectedIndex).
            if(!Control.IsMultiSelect &&
               originalSelectedIndices.Length == 0 && 
               Control.Items.Count > 0)
            {
                Control.Items[0].Selected = true;
                originalSelectedIndices = new int[]{0};
            }

            
            // Case where nothing is selected.
            if(selectedItems == null ||
                (selectedItems.Length == 1 && 
                    selectedItems[0] == String.Empty) ||
                (selectedItems.Length == 1 && 
                    selectedItems[0] == "0"))  // non-selected MultiSelect case
            {
                selectedItems = new String[]{};
            }

            // WML multiselect case with more than one selection.
            if(selectedItems.Length == 1 && selectedItems[0].IndexOf(';') > -1)
            {
                String selected = selectedItems[0];
                // Eliminate trailing semicolon, if there is one.
                selected = Regex.Replace(selected, ";$", "");
                selectedItems = Regex.Split(selected, ";");
            }

            selectedItemIndices = new int[selectedItems.Length];
            for(int i = 0; i < selectedItems.Length; i++)
            {
                // WML iname gives index + 1, so subtract one back out. 
                selectedItemIndices[i] = Int32.Parse(selectedItems[i]) - 1;
            }

            // Do not assume posted selected indices are ascending.  
            // We do know originalSelectedIndices are ascending.
            Array.Sort(selectedItemIndices);

            // Check whether selections have changed.
            if(selectedItemIndices.Length != originalSelectedIndices.Length)
            {
                dataChanged = true;
            }
            else
            {
                for(int i = 0; i < selectedItemIndices.Length; i++)
                {
                    if(selectedItemIndices[i] != originalSelectedIndices[i])
                    {
                        dataChanged = true;
                    }
                }
            }
            
            for (int i = 0; i < Control.Items.Count; i++)
            {
                Control.Items[i].Selected = false;
            }

            for(int i = 0; i < selectedItemIndices.Length; i++)
            {
                Control.Items[selectedItemIndices[i]].Selected = true;
            }
            
            return true;
        }

        protected override String GetPostBackValue()
        {
            // Optimization - if viewstate is enabled for this control, and the
            // postback returns to this page, we just let it do the trick.

            if (Control.Form.Action.Length > 0 || !IsViewStateEnabled())
            {
                return _ivalue != null ? _ivalue : String.Empty;
            }
            else
            {
                return null;
            }
        }

        private bool IsViewStateEnabled()
        {
            Control ctl = Control;
            while (ctl != null)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
                ctl = ctl.Parent;
            }
            return true;
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlmobiletextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlMobileTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Web.Security;
using System.Security.Permissions;

using SR=System.Web.UI.MobileControls.Adapters.SR;

#if COMPILING_FOR_SHIPPED_SOURCE
using Adapters=System.Web.UI.MobileControls.ShippedAdapterSource;
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
using Adapters=System.Web.UI.MobileControls.Adapters;
namespace System.Web.UI.MobileControls.Adapters
#endif

{
    /*
     * WmlMobileTextWriter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */

    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlMobileTextWriter : MobileTextWriter
    {
        private TextWriter      _realInnerWriter;
        private EmptyTextWriter _analyzeWriter;
        private bool            _analyzeMode = false;
        private MobilePage      _page;
        private Form            _currentForm;
        private bool[]          _usingPostBackType   = new bool[] { false, false };
        private bool[]          _writtenPostBackType = new bool[] { false, false };
        private int             _numberOfPostBacks;
        private bool            _postBackCardsEfficient = false;
        private IDictionary     _formVariables = null;
        private IDictionary     _controlShortNames = null;
        private Stack           _layoutStack = new Stack();
        private Stack           _formatStack = new Stack();
        private WmlLayout       _currentWrittenLayout = null;
        private WmlFormat       _currentWrittenFormat = null;
        private bool            _pendingBreak = false;
        private bool            _inAnchor = false;
        private int             _numberOfSoftkeys;
        private bool            _provideBackButton = false;
        private bool            _writtenFormVariables = false;
        private bool            _alwaysScrambleClientIDs = false;

        private const String    _largeTag  = "big";
        private const String    _smallTag  = "small";
        private const String    _boldTag   = "b";
        private const String    _italicTag = "i";
        internal const String   _postBackCardPrefix = "__pbc";
        private const String    _postBackWithVarsCardId = "__pbc1";
        private const String    _postBackWithoutVarsCardId = "__pbc2";
        internal const String   _postBackEventTargetVarName = "mcsvt";
        internal const String   _postBackEventArgumentVarName = "mcsva";
        private const String    _shortNamePrefix = "mcsv";
        private const int       _maxShortNameLength = 16;
        private static Random   _random = new Random();

        public WmlMobileTextWriter(TextWriter writer, MobileCapabilities device, MobilePage page) 
            : base(writer, device)
        {
            _realInnerWriter = writer;
            _page = page;

            _numberOfSoftkeys = Device.NumberOfSoftkeys;
            if (_numberOfSoftkeys > 2)
            {
                _numberOfSoftkeys = 2;
            }

            // For phones that don't have a back button, assign a softkey.

            if (_numberOfSoftkeys == 2 && !Device.HasBackButton)
            {
                _numberOfSoftkeys = 1;
                _provideBackButton = true;
                _alwaysScrambleClientIDs = _provideBackButton && 
                                                !device.CanRenderOneventAndPrevElementsTogether;
            }
        }

        // AnalyzeMode is set to true during first analysis pass of rendering.

        public bool AnalyzeMode
        {
            get
            {
                return _analyzeMode;
            }
            set
            {
                _analyzeMode = value;
                if (value)
                {
                    _analyzeWriter = new EmptyTextWriter();
                    InnerWriter = _analyzeWriter;
                }
                else
                {
                    InnerWriter = _realInnerWriter;
                }
            }
        }

        internal bool HasFormVariables
        {
            get
            {
                return _writtenFormVariables;
            }
        }

        public override void EnterLayout(Style style)
        {
            if (AnalyzeMode)
            {
                return;
            }

            WmlLayout newLayout = new WmlLayout(style, CurrentLayout);
            _layoutStack.Push(newLayout);
        }

        public override void ExitLayout(Style style, bool breakAfter)
        {
            if (!AnalyzeMode)
            {
                if (breakAfter)
                {
                    PendingBreak = true;
                }
                _layoutStack.Pop();
            }
        }

        public override void EnterFormat(Style style)
        {
            if (AnalyzeMode)
            {
                return;
            }

            WmlFormat newFormat = new WmlFormat(style, CurrentFormat);
            _formatStack.Push(newFormat);
        }

        public override void ExitFormat(Style style)
        {
            if (AnalyzeMode)
            {
                return;
            }
            _formatStack.Pop();
        }

        public virtual void BeginForm(Form form)
        {
            _cachedFormQueryString = null;
            _currentForm = form;

            _writtenFormVariables = false;

            // To keep track of postbacks which submit form variables,
            // and postbacks that don't. Used for postback cards
            // (see UsePostBackCards)

            _usingPostBackType[0] = _usingPostBackType[1] = false;

            if (AnalyzeMode)
            {
                _numberOfPostBacks = 0;
                _postBackCardsEfficient = false;
                _controlShortNames = null;
            }
            else
            {
                PendingBreak = false;
                _currentWrittenLayout = null;
                _currentWrittenFormat = null;

                RenderBeginForm(form);
            }
        }

        public virtual void EndForm()
        {
            if (AnalyzeMode)
            {
                // Analyze form when done.
                PostAnalyzeForm();
            }
            else
            {
                RenderEndForm();
            }
        }

        // Single parameter - used for rendering ordinary inline text 
        // (with encoding but without breaks).
        public void RenderText(String text)
        {
            RenderText(text, false, true);
        }

        // Two parameters - used for rendering encoded text with or without breaks)
        public void RenderText(String text, bool breakAfter)
        {
            RenderText(text, breakAfter, true);
        }

        public virtual void RenderText(String text, bool breakAfter, bool encodeText)
        {
            if (!AnalyzeMode)
            {
                EnsureLayout();

                // Don't use formatting tags inside anchor.
                if (!_inAnchor)
                {
                    EnsureFormat();
                }

                WriteText(text, encodeText);
                if (breakAfter)
                {
                    PendingBreak = true;
                }
            }
        }

        // Escape '&' in XML if it hasn't been
        internal String EscapeAmpersand(String url)
        {
            const char ampersand = '&';
            const String ampEscaped = "amp;";

            if (url == null)
            {
                return null;
            }

            int ampPos = url.IndexOf(ampersand);
            while (ampPos != -1)
            {
                if (url.Length - ampPos <= ampEscaped.Length ||
                    url.Substring(ampPos + 1, ampEscaped.Length) != ampEscaped)
                {
                    url = url.Insert(ampPos + 1, ampEscaped);
                }
                ampPos = url.IndexOf(ampersand, ampPos + ampEscaped.Length + 1);
            }

            return url;
        }

        public virtual void RenderBeginHyperlink(String targetUrl, 
                                                 bool encodeUrl, 
                                                 String softkeyLabel, 
                                                 bool implicitSoftkeyLabel,
                                                 bool mapToSoftkey)
        {
            if (!AnalyzeMode)
            {
                EnsureLayout();
                EnsureFormat();

                WriteBeginTag("a");
                Write(" href=\"");
                if (encodeUrl)
                {
                    WriteEncodedUrl(targetUrl);
                }
                else
                {
                    Write(EscapeAmpersand(targetUrl));
                }
                Write("\"");
                if (softkeyLabel != null && softkeyLabel.Length > 0 && !RequiresNoSoftkeyLabels())
                {
                    WriteTextEncodedAttribute("title", softkeyLabel);
                }
                Write(">");
                _inAnchor = true;
            }
        }

        public virtual void RenderEndHyperlink(bool breakAfter)
        {
            if (!AnalyzeMode)
            {
                WriteEndTag("a");
                if (breakAfter)
                {
                    PendingBreak = true;
                }
                _inAnchor = false;
            }
        }

        public virtual void RenderTextBox(String id, 
                                          String value,
                                          String format,
                                          String title,
                                          bool password, 
                                          int size, 
                                          int maxLength, 
                                          bool generateRandomID,
                                          bool breakAfter)
        {
            if (!AnalyzeMode)
            {
                // Input tags cannot appear inside character formatting tags,
                // so close any character formatting.
                
                CloseCharacterFormat();

                // Certain devices always render a break before a <select>.  If
                // we're on such a device, cancel any pending breaks so as not
                // to get an extra line of whitespace.
                if (Device.RendersBreakBeforeWmlSelectAndInput)
                {
                    PendingBreak = false;
                }
                
                EnsureLayout();
                WriteBeginTag("input");
                // Map the client ID to a short name. See
                // MapClientIDToShortName for details.
                WriteAttribute("name", MapClientIDToShortName(id, generateRandomID));
                if (password)
                {
                    WriteAttribute("type", "password");
                }
                if (format != null && format.Length > 0)
                {
                    WriteAttribute("format", format);
                }
                if (title != null && title.Length > 0)
                {
                    WriteTextEncodedAttribute("title", title);
                }
                if (size > 0)
                {
                    WriteAttribute("size", size.ToString());
                }
                if (maxLength > 0)
                {
                    WriteAttribute("maxlength", maxLength.ToString());
                }
                if ((!_writtenFormVariables || ((WmlPageAdapter) Page.Adapter).RequiresValueAttributeInInputTag()) &&
                    value != null &&
                    (value.Length > 0 || password))
                {
                    WriteTextEncodedAttribute("value", value);
                }
                WriteLine(" />");
                if (breakAfter && !Device.RendersBreaksAfterWmlInput)
                {
                    PendingBreak = true;
                }
            }
        }

        public virtual void RenderImage(String source, 
                                        String localSource, 
                                        String alternateText, 
                                        bool breakAfter)
        {
            if (!AnalyzeMode)
            {
                EnsureLayout();

                WriteBeginTag("img");
                WriteAttribute("src", source, true /*encode*/);
                if (localSource != null)
                {
                    WriteAttribute("localsrc", localSource, true /*encode*/);
                }
                WriteTextEncodedAttribute("alt", alternateText != null ? alternateText : String.Empty);
                Write(" />");
                if (breakAfter)
                {
                    PendingBreak = true;
                }
            }
        }

        public virtual void RenderBeginPostBack(String softkeyLabel, 
                                                bool implicitSoftkeyLabel, 
                                                bool mapToSoftkey)
        {
            if (!AnalyzeMode)
            {
                EnsureLayout();
                EnsureFormat();

                WriteBeginTag("anchor");
                if (softkeyLabel != null && softkeyLabel.Length > 0 && !RequiresNoSoftkeyLabels())
                {
                    WriteTextEncodedAttribute("title", softkeyLabel);
                }
                Write(">");
                _inAnchor = true;
            }
        }

        public virtual void RenderEndPostBack(String target, 
                                              String argument, 
                                              WmlPostFieldType postBackType, 
                                              bool includeVariables, 
                                              bool breakAfter)
        {
            if (AnalyzeMode)
            {
                // Analyze postbacks to see if postback cards should
                // be rendered.

                AnalyzePostBack(includeVariables, postBackType);
            }
            else
            {
                RenderGoAction(target, argument, postBackType, includeVariables);
    
                WriteEndTag("anchor");
                if (breakAfter)
                {
                    PendingBreak = true;
                }
                _inAnchor = false;
            }
        }

        public virtual void RenderBeginSelect(String name, String iname, String ivalue, String title, bool multiSelect)
        {
            if (!AnalyzeMode)
            {

                // Select tags cannot appear inside character formatting tags,
                // so close any character formatting.
                CloseCharacterFormat();

                // Certain devices always render a break before a <select>.  If
                // we're on such a device, cancel any pending breaks so as not
                // to get an extra line of whitespace.
                if (Device.RendersBreakBeforeWmlSelectAndInput)
                {
                    PendingBreak = false;
                }
                
                EnsureLayout();
                WriteBeginTag("select");
                if (name != null && name.Length > 0)
                {
                    // Map the client ID to a short name. See
                    // MapClientIDToShortName for details.
                    WriteAttribute("name", MapClientIDToShortName(name,  false));
                }
                if (iname != null && iname.Length > 0)
                {
                    // Map the client ID to a short name. See
                    // MapClientIDToShortName for details.
                    WriteAttribute("iname", MapClientIDToShortName(iname, false));
                }
                if (!_writtenFormVariables && ivalue != null && ivalue.Length > 0)
                {
                    WriteTextEncodedAttribute("ivalue", ivalue);
                }
                if (title != null && title.Length >0)
                {
                    WriteTextEncodedAttribute("title", title);
                }
                if (multiSelect)
                {
                    WriteAttribute("multiple", "true");               
                }
                Write(">");
            }
        }

        public virtual void RenderEndSelect(bool breakAfter)
        {
            if (!AnalyzeMode)
            {
                WriteEndTag("select");
                if (breakAfter && !Device.RendersBreaksAfterWmlInput)
                {
                    PendingBreak = true;
                }
            }
        }

        public virtual void RenderSelectOption(String text)
        {
            if (!AnalyzeMode)
            {
                WriteFullBeginTag("option");
                WriteEncodedText(text);
                WriteEndTag("option");
            }
        }

        public virtual void RenderSelectOption(String text, String value)
        {
            if (!AnalyzeMode)
            {
                WriteBeginTag("option");
                WriteAttribute("value", value, true);
                Write(">");
                WriteEncodedText(text);                    
                WriteEndTag("option");
            }
        }

        public virtual void BeginCustomMarkup()
        {
            if (!AnalyzeMode)
            {
                EnsureLayout();
            }
        }

        public virtual void EndCustomMarkup()
        {
        }

        public void AddFormVariable(String clientID, String value, bool generateRandomID)
        {
            // On first (analyze) pass, form variables are added to
            // an array. On second pass, they are rendered. This ensures
            // that only visible controls generate variables.

            if (AnalyzeMode)
            {
                if (_formVariables == null)
                {
                    _formVariables = new ListDictionary();
                }

                // Map the client ID to a short name. See
                // MapClientIDToShortName for details.
                _formVariables[MapClientIDToShortName(clientID, generateRandomID)] = value;
            }
        }

        // Call to reset formatting state before outputting custom stuff.

        public virtual void ResetFormattingState()
        {
            if (!AnalyzeMode)
            {
                CloseCharacterFormat();
            }
        }

        public virtual void RenderExtraCards()
        {
            RenderPostBackCards();
        }

        public virtual bool IsValidSoftkeyLabel(String label)
        {
            return label != null &&
                   label.Length > 0 &&
                   label.Length <= Device.MaximumSoftkeyLabelLength;
        }

        public virtual void RenderGoAction(String target, 
                                           String argument, 
                                           WmlPostFieldType postBackType, 
                                           bool includeVariables)
        {

            WriteBeginTag("go");
            Write(" href=\"");

            IDictionary postBackVariables = null;
            if (includeVariables)
            {
                postBackVariables = ((WmlFormAdapter)CurrentForm.Adapter).CalculatePostBackVariables();
                if (postBackVariables == null || postBackVariables.Count == 0)
                {
                    includeVariables = false;
                }
            }

            bool externalSubmit;
            if (postBackType == WmlPostFieldType.Submit)
            {
                externalSubmit = CurrentForm.Action.Length > 0;
                postBackType = WmlPostFieldType.Normal;
            }
            else
            {
                externalSubmit = false;
            }

            if (target != null && !externalSubmit && UsePostBackCard(includeVariables))
            {
                _writtenPostBackType[includeVariables ? 0 : 1] = true;

                // If using postback cards, render a go action to the given
                // postback card, along with setvars setting the target and
                // argument.

                Write("#");
                Write(includeVariables ? _postBackWithVarsCardId : _postBackWithoutVarsCardId);
                Write("\">");
                WriteBeginTag("setvar");
                WriteAttribute("name", _postBackEventTargetVarName);
                WriteAttribute("value", target);
                Write("/>");
                WriteBeginTag("setvar");
                WriteAttribute("name", _postBackEventArgumentVarName);
                Write(" value=\"");
                if (argument != null)
                {
                    if (postBackType == WmlPostFieldType.Variable)
                    {
                        Write("$(");
                        Write(argument);
                        Write(")");
                    }
                    else
                    {
                        WriteEncodedText(argument);
                    }
                }
                Write("\"/>");
            }
            else
            {
                // This is the real postback.

                bool encode = false;
                String url = CalculateFormPostBackUrl(externalSubmit, ref encode);
                FormMethod method = CurrentForm.Method;
                String queryString = CalculateFormQueryString();

                if (encode)
                {
                    WriteEncodedUrl(url);
                }
                else
                {
                    Write(url);
                }

                // Add any query string.
                if (queryString != null && queryString.Length > 0)
                {
                    Write("?");
                    if (queryString.IndexOf('$') != -1)
                    {
                        queryString = queryString.Replace("$", "$$");
                    }    
                    if(Page.Adapter.PersistCookielessData && Device.CanRenderOneventAndPrevElementsTogether)
                    {
                        queryString = ReplaceFormsCookieWithVariable(queryString);
                    } 
                    base.WriteEncodedText(queryString);
                }
                Write("\"");

                // Method defaults to get in WML, so write it if it's not.
                if (method == FormMethod.Post)
                {
                    WriteAttribute("method", "post");
                }
                Write(">");
    
                // Write the view state as a postfield.
                if (!externalSubmit)
                {
                    String pageState = Page.ClientViewState;
                    if (pageState != null)
                    {
                        if (Device.RequiresSpecialViewStateEncoding)
                        {
                            pageState =
                                ((WmlPageAdapter) Page.Adapter).EncodeSpecialViewState(pageState);
                        }
                        WritePostField(MobilePage.ViewStateID, pageState);
                    }
    
                    // Write the event target.
                    if (target != null)
                    {
                        WritePostField(MobilePage.HiddenPostEventSourceId, target);
                    }
                    else
                    {
                        // Target is null when the action is generated from a postback
                        // card itself. In this case, set the event target to whatever
                        // the original event target was.
    
                        WritePostFieldVariable(MobilePage.HiddenPostEventSourceId, _postBackEventTargetVarName);
                    }

                    // Write the event argument, if valid.
    
                    if (argument != null)
                    {
                        WritePostField(MobilePage.HiddenPostEventArgumentId, argument, postBackType);
                    }
                }
    
                // Write postfields for form variables, if desired. Commands, for example,
                // include form variables. Links do not.

                if (includeVariables)
                {
                    if (postBackVariables != null)
                    {
                        foreach (DictionaryEntry entry in postBackVariables)
                        {
                            Control ctl = (Control)entry.Key;
                            Object value = entry.Value;

                            if (value == null)
                            {
                                // Dynamic value.
                                // Map the client ID to a short name. See
                                // MapClientIDToShortName for details.
                                // Note: Because this is called on the second pass, 
                                // we can just pass false as the second parameter
                                WritePostFieldVariable(ctl.UniqueID, MapClientIDToShortName(ctl.ClientID, false));
                            }
                            else
                            {
                                // Static value.
                                WritePostField(ctl.UniqueID, (String)value);
                            }
                        }
                    }
                }
    
                // Always include page hidden variables.
    
                if (Page.HasHiddenVariables())
                {
                    String hiddenVariablePrefix = MobilePage.HiddenVariablePrefix;
                    foreach (DictionaryEntry entry in Page.HiddenVariables)
                    {
                        if (entry.Value != null)
                        {
                            WritePostField(hiddenVariablePrefix + (String)entry.Key, (String)entry.Value);
                        }
                    }
                }
            }

            WriteEndTag("go");
        }

        // Called after form is completed to analyze.

        protected virtual void PostAnalyzeForm()
        {
            // Use postback cards if the number of postbacks exceeds the number
            // of required postback cards.
            // REVIEW: Should perhaps be hiked by one, since postback card output
            // is typically longer than the postbacks themselves?

            int numberOfCardsRequired = (_usingPostBackType[0] ? 1 : 0) +
                                        (_usingPostBackType[1] ? 1 : 0);
            if (_numberOfPostBacks > numberOfCardsRequired)
            {
                _postBackCardsEfficient = true;
            }
        }

        // Calculates the URL to output for the postback. Other writers may
        // override.

        protected virtual String CalculateFormPostBackUrl(bool externalSubmit, ref bool encode)
        {
            String url = CurrentForm.Action;
            if (externalSubmit && url.Length > 0)
            {
                url = CurrentForm.ResolveUrl(url);
                encode = false;
            }
            else
            {
                url = Page.RelativeFilePath;
                encode = true;
            }
            return url;
        }

        // Calculates the query string to output for the postback. Other
        // writers may override.

        internal String ReplaceFormsCookieWithVariable(String queryString)
        {
            String formsAuthCookieName = FormsAuthentication.FormsCookieName;
            if(formsAuthCookieName != String.Empty)
            {
                int index = queryString.IndexOf(formsAuthCookieName + "=");
                if(index != -1)
                {
                    int valueStart = index + formsAuthCookieName.Length + 1;
                    int valueEnd = queryString.IndexOf('&', valueStart);
                    if(valueStart < queryString.Length)
                    {
                        int length = ((valueEnd != -1) ? valueEnd : queryString.Length) - valueStart;
                        queryString = queryString.Remove(valueStart, length);
                        queryString = queryString.Insert(valueStart, "$(" + MapClientIDToShortName("__facn", false) + ")");
                    }
                }
            }
            return queryString;
        }

        private String _cachedFormQueryString;
        protected virtual String CalculateFormQueryString()
        {
            if (_cachedFormQueryString != null)
            {
                return _cachedFormQueryString;
            }

            String queryString = null;
            if (CurrentForm.Method != FormMethod.Get)
            {
                queryString = Page.QueryStringText;
            }

            if (Device.RequiresUniqueFilePathSuffix)
            {
                String ufps = Page.UniqueFilePathSuffix;
                if (queryString != null && queryString.Length > 0)
                {
                    queryString = String.Concat(ufps, "&", queryString);
                }
                else
                {
                    queryString = ufps;
                }
            }

            _cachedFormQueryString = queryString;
            return queryString;
        }

        internal virtual bool ShouldWriteFormID(Form form)
        {
            WmlPageAdapter pageAdapter = (WmlPageAdapter)CurrentForm.MobilePage.Adapter;
            
            return (form.ID != null && pageAdapter.RendersMultipleForms());
        }

        // Renders the beginning of a form.
        // REVIEW: May need a separate overridable for rendering the card tag.

        protected virtual void RenderBeginForm(Form form)
        {
            WmlFormAdapter formAdapter = (WmlFormAdapter)CurrentForm.Adapter;

            IDictionary attributes = new ListDictionary();
            if (ShouldWriteFormID(form))
            {
                attributes.Add("id", form.ClientID);
            }

            String title = form.Title;
            if (title.Length > 0)
            {
                attributes.Add("title", title);
            }

            // Let the form adapter render the tag. This bit of indirection is 
            // somewhat horky, but necessary so that people can subclass adapters
            // without worrying about the fact that much of the real work is done
            // in the writer.

            formAdapter.RenderCardTag(this, attributes);

            // Write form variables.

            if ((_formVariables != null && _formVariables.Count > 0) &&
                    (!_provideBackButton ||
                 Device.CanRenderOneventAndPrevElementsTogether))
            {
                _writtenFormVariables = true;
                Write("<onevent type=\"onenterforward\"><refresh>");
                foreach (DictionaryEntry entry in _formVariables)
                {
                    WriteBeginTag("setvar");
                    WriteAttribute("name", (String)entry.Key);
                    WriteTextEncodedAttribute("value", (String)entry.Value);
                    Write(" />");
                }
                WriteLine("</refresh></onevent>");

            }

            formAdapter.RenderExtraCardElements(this);

            if (_provideBackButton)
            {
                Write("<do type=\"prev\" label=\"");
                Write(SR.GetString(SR.WmlMobileTextWriterBackLabel));
                WriteLine("\"><prev /></do>");
            }
        }

        // Renders the ending of a form.

        protected virtual void RenderEndForm()
        {
            CloseParagraph();
            WriteEndTag("card");
            WriteLine();
        }

        // Postback cards provide an alternate, space-efficient way of doing 
        // postbacks, on forms that have a lot of postback links. Instead of
        // posting back directly, postback links switch to a postback card, setting
        // variables for event target and argument. The postback card has
        // an onenterforward event that submits the postback. It also has
        // an onenterbackward, so that it becomes transparent in the card history.
        // (Clicking Back to enter the postback card immediately takes you
        // to the previous card)

        protected virtual bool UsePostBackCard(bool includeVariables)
        {
            bool b = _postBackCardsEfficient && Device.CanRenderPostBackCards;
            if (b && includeVariables)
            {
                WmlPageAdapter pageAdapter = (WmlPageAdapter)CurrentForm.MobilePage.Adapter;
                if (pageAdapter.RendersMultipleForms())
                {
                    b = false;
                }
            }

            return b;
        }


        // Renders postback cards. 

        private void RenderPostBackCards()
        {
            for (int i = 0; i < 2; i++)
            {
                if (_writtenPostBackType[i])
                {
                    WriteBeginTag("card");
                    WriteAttribute("id", i == 0 ? _postBackWithVarsCardId : _postBackWithoutVarsCardId);
                    WriteLine(">");
        
                    Write("<onevent type=\"onenterforward\">");
                    RenderGoAction(null, _postBackEventArgumentVarName, WmlPostFieldType.Variable, i == 0);
                    WriteLine("</onevent>");
        
                    WriteLine("<onevent type=\"onenterbackward\"><prev /></onevent>");
                    WriteLine("</card>");
                }
            }
        }

        protected void RenderFormDoEvent(String doType, String arg, WmlPostFieldType postBackType, String text)
        {
            RenderDoEvent(doType, CurrentForm.UniqueID, arg, postBackType, text, true);
        }

        protected void RenderDoEvent(String doType, String target, String arg, WmlPostFieldType postBackType, String text, bool includeVariables)
        {
            //EnsureLayout();
            WriteBeginTag("do");
            WriteAttribute("type", doType);
            if (text != null && text.Length > 0)
            {
                WriteTextEncodedAttribute("label", text);
            }
            Write(">");
            RenderGoAction(target, arg, postBackType, includeVariables);
            WriteEndTag("do");
        }

        // Makes sure the writer has rendered a paragraph tag corresponding to
        // the current layout.

        protected virtual void EnsureLayout()
        {
            WmlLayout layout = CurrentLayout;

            if (_currentWrittenLayout != null && layout.Compare(_currentWrittenLayout))
            {
                // Same layout as before. Only write any pending break.
                if (PendingBreak)
                {
                    // Avoid writing tags like </b> AFTER the <br/>, instead
                    // writing them before.

                    if (_currentWrittenFormat != null && !CurrentFormat.Compare(_currentWrittenFormat))
                    {
                        CloseCharacterFormat();
                    }
                    WriteBreak();
                }
            }
            else
            {
                // Layout has changed. Close current layout, and open new one.
                CloseParagraph();
                OpenParagraph(layout, 
                              layout.Align != Alignment.Left, 
                              layout.Wrap != Wrapping.Wrap);
            }
            PendingBreak = false;
        }

        // Makes sure the writer has rendered character formatting tags
        // corresponding to the current format.

        protected virtual void EnsureFormat()
        {
            WmlFormat format = CurrentFormat;

            if (_currentWrittenFormat == null || !format.Compare(_currentWrittenFormat))
            {
                CloseCharacterFormat();
                OpenCharacterFormat(format,
                                    format.Bold,
                                    format.Italic,
                                    format.Size != FontSize.Normal);
            }
        }

        // Opens a paragraph with the given layout. Only the specified 
        // attributes are used.

        protected virtual void OpenParagraph(WmlLayout layout, bool writeAlignment, bool writeWrapping)
        {
            if (_currentWrittenLayout == null)
            {
                WriteBeginTag("p");
                if (writeAlignment)
                {
                    String alignment;
                    switch (layout.Align)
                    {
                        case Alignment.Right:
                            alignment = "right";
                            break;

                        case Alignment.Center:
                            alignment = "center";
                            break;

                        default:
                            alignment = "left";
                            break;
                    }

                    WriteAttribute("align", alignment);
                }
                if (writeWrapping)
                {
                    WriteAttribute("mode",
                                   layout.Wrap == Wrapping.NoWrap ? "nowrap" : "wrap");
                }
                Write(">");
                _currentWrittenLayout = layout;
            }
        }

        // Close any open paragraph.

        protected virtual void CloseParagraph()
        {
            if (_currentWrittenLayout != null)
            {
                CloseCharacterFormat();
                WriteEndTag("p");
                _currentWrittenLayout = null;
            }
        }

        // Renders tags to enter the given character format. Only the specified 
        // attributes are used.

        protected virtual void OpenCharacterFormat(WmlFormat format, bool writeBold, bool writeItalic, bool writeSize)
        {
            if (_currentWrittenFormat == null)
            {
                if (writeBold && format.Bold)
                {
                    WriteFullBeginTag(_boldTag);
                    format.WrittenBold = true;
                }
                if (writeItalic && format.Italic)
                {
                    WriteFullBeginTag(_italicTag);
                    format.WrittenItalic = true;
                }
                if (writeSize && format.Size != FontSize.Normal)
                {
                    WriteFullBeginTag(format.Size == FontSize.Large ? _largeTag : _smallTag);
                    format.WrittenSize = true;
                }
                _currentWrittenFormat = format;
            }
        }

        // Close any open character formatting tags.

        protected virtual void CloseCharacterFormat()
        {
            if (_currentWrittenFormat != null)
            {
                if (_currentWrittenFormat.WrittenSize)
                {
                    WriteEndTag(_currentWrittenFormat.Size == FontSize.Large ? _largeTag : _smallTag);
                }
                if (_currentWrittenFormat.WrittenItalic)
                {
                    WriteEndTag(_italicTag);
                }
                if (_currentWrittenFormat.WrittenBold)
                {
                    WriteEndTag(_boldTag);
                }
                _currentWrittenFormat = null;
            }
        }

        private static readonly char[] _attributeCharacters = new char[] {'"', '&', '<', '>', '$'};

        public override void WriteAttribute(String attribute, String value, bool encode)
        {
            // If in analyze mode, we don't actually have to perform the conversion, because
            // it's not getting written anyway.

            // If the value is null, we return without writing anything.  This is different
            // from HtmlTextWriter, which writes the name of the attribute, but no value at all.
            // A name with no value is illegal in Wml.
            if (value == null)
            {
                return;
            }

            if (AnalyzeMode)
            {
                encode = false;
            }
            
            if (encode)
            {
                // Unlike HTML encoding, we need to replace $ with $$, and <> with &lt; and &gt;. 
                // We can't do this by piggybacking HtmlTextWriter.WriteAttribute, because it 
                // would translate the & in &lt; or &gt; to &amp;. So we more or less copy the 
                // ASP.NET code that does similar encoding.

                Write(' ');
                Write(attribute);
                Write("=\"");

                int cb = value.Length;
                int pos = value.IndexOfAny(_attributeCharacters);
                if (pos == -1) 
                {
                    Write(value);
                }
                else
                {
                    char[] s = value.ToCharArray();
                    int startPos = 0;
                    while (pos < cb) 
                    {
                        if (pos > startPos) 
                        {
                            Write(s, startPos, pos - startPos);
                        }

                        char ch = s[pos];
                        switch (ch) 
                        {
                            case '\"':
                                Write("&quot;");
                                break;
                            case '&':
                                Write("&amp;");
                                break;
                            case '<':
                                Write("&lt;");
                                break;
                            case '>':
                                Write("&gt;");
                                break;
                            case '$':
                                Write("$$");
                                break;
                        }

                        startPos = pos + 1;
                        pos = value.IndexOfAny(_attributeCharacters, startPos);
                        if (pos == -1) 
                        {
                            Write(s, startPos, cb - startPos);
                            break;
                        }
                    }
                }

                Write('\"');
            }
            else
            {
                base.WriteAttribute(attribute, value, encode);
            }
        }

        protected void WriteTextEncodedAttribute(String attribute, String value)
        {
            WriteAttribute(attribute, value, true);
        }

        protected Form CurrentForm
        {
            get
            {
                return _currentForm;
            }
        }

        protected MobilePage Page
        {
            get
            {
                return _page;
            }
        }

        protected int NumberOfSoftkeys
        {
            get
            {
                return _numberOfSoftkeys;
            }
        }

        protected virtual void AnalyzePostBack(bool includeVariables, WmlPostFieldType postBackType)
        {
            _usingPostBackType[includeVariables ? 0 : 1] = true;
            if (postBackType != WmlPostFieldType.Submit || CurrentForm.Action.Length == 0)
            {
                _numberOfPostBacks++;
            }
        }

        public override void WriteEncodedUrl(String url)
        {
            if (url == null)
            {
                return;
            }

            int i = url.IndexOf('?');
            if (i != -1)
            {
                WriteUrlEncodedString(url.Substring(0, i), false);

                String s = url.Substring(i);
                if (s.IndexOf('$') != -1)
                {
                    s = s.Replace("$", "%24");
                }
                base.WriteEncodedText(s);
                //WriteEncodedText(url.Substring(i));
            }
            else
            {
                WriteUrlEncodedString(url, false);
            }
        }

        public override void WriteEncodedText(String text)
        {
            if (text == null)
            {
                return;
            }

            if (text.IndexOf('$') != -1)
            {
                text = text.Replace("$", "$$");
            }

            base.WriteEncodedText(text);
        }

        public void WriteText(String text, bool encodeText)
        {
            if (encodeText)
            {
                WriteEncodedText(text);
            }
            else
            {
                WritePlainText(text);
            }
        }

        private void WritePlainText(String text)
        {
            if (text == null)
            {
                return;
            }

            if (text.IndexOf('$') != -1)
            {
                text = text.Replace("$", "$$");
            }
            Write(text);
        }

        protected void WriteBreak()
        {
            Write("<br/>\r\n");
        }

        public void WritePostField(String name, String value)
        {
            WritePostField(name, value, WmlPostFieldType.Normal);
        }

        public void WritePostFieldVariable(String name, String arg)
        {
            WritePostField(name, arg, WmlPostFieldType.Variable);
        }

        public void WritePostField(String name, String value, WmlPostFieldType type)
        {
            Write("<postfield name=\"");
            Write(name);
            Write("\" value=\"");
            if (type == WmlPostFieldType.Variable)
            {
                Write("$(");
            }
            if (type == WmlPostFieldType.Normal)
            {
                if (Device.RequiresUrlEncodedPostfieldValues)
                {
                    WriteEncodedUrlParameter(value);
                }
                else
                {
                    WriteEncodedText(value);
                }
            }
            else
            {
                Write(value);
            }
            if (type == WmlPostFieldType.Variable)
            {
                Write(")");
            }
            Write("\" />");
        }

        // MapClientIDToShortName provides a unique map of control ClientID properties
        // to shorter names. In cases where a control has a very long ClientID, a 
        // shorter unique name is used. All references to the client ID on the page
        // are mapped, resulting in the same postback regardless of mapping.
        // MapClientIDToShortName also scrambles client IDs that need to be 
        // scrambled for security reasons.

        protected internal String MapClientIDToShortName(String clientID, bool generateRandomID)
        {
            if (_alwaysScrambleClientIDs)
            {
                generateRandomID = true;
            }

            if (_controlShortNames != null)
            {
                String lookup = (String)_controlShortNames[clientID];
                if (lookup != null)
                {
                    return lookup;
                }
            }

            if (!generateRandomID)
            {
                bool shortID = clientID.Length < _maxShortNameLength;
                // Map names with underscores and conflicting names regardless of length.
                bool goodID = (clientID.IndexOf('_') == -1) && !NameConflicts(clientID);

                if (shortID && goodID)
                {
                    return clientID;
                }
            }

            if (_controlShortNames == null)
            {
                _controlShortNames = new ListDictionary();
            }
            
            String shortName;
            if (generateRandomID)
            {
                shortName = GetRandomID(5);
            }
            else
            {
                shortName = String.Empty;
            }

            shortName = String.Concat(_shortNamePrefix, shortName, _controlShortNames.Count.ToString());
            _controlShortNames[clientID] = shortName;
            return shortName;
        }

        private String GetRandomID(int length)
        {
            Byte[] randomBytes = new Byte[length];
            _random.NextBytes(randomBytes);

            char[] randomChars = new char[length];
            for (int i = 0; i < length; i++)
            {
                randomChars[i] = (char)((((int)randomBytes[i]) % 26) + 'a');
            }

            return new String(randomChars);
        }

        private bool NameConflicts(String name)
        {
            if (name == null)
            {
                return false;
            }

            Debug.Assert(_postBackEventTargetVarName.ToLower(CultureInfo.InvariantCulture) == _postBackEventTargetVarName &&
                _postBackEventArgumentVarName.ToLower(CultureInfo.InvariantCulture) == _postBackEventArgumentVarName &&
                _shortNamePrefix.ToLower(CultureInfo.InvariantCulture) == _shortNamePrefix);
        
            name = name.ToLower(CultureInfo.InvariantCulture);
            return name == _postBackEventTargetVarName ||
                name == _postBackEventArgumentVarName || 
                name.StartsWith(_shortNamePrefix);
        }

        private static readonly WmlLayout _defaultLayout = 
                                    new WmlLayout(Alignment.Left, Wrapping.Wrap);

        protected virtual WmlLayout DefaultLayout
        {
            get
            {
                return _defaultLayout;
            }
        }

        private WmlLayout CurrentLayout
        {
            get
            {
                if (_layoutStack.Count > 0)
                {
                    return (WmlLayout)_layoutStack.Peek();
                }
                else
                {
                    return DefaultLayout;
                }
            }
        }

        protected bool PendingBreak
        {
            get
            {
                return _pendingBreak;
            }
            set
            {
                _pendingBreak = value;
            }
        }

        private static readonly WmlFormat _defaultFormat = 
                                    new WmlFormat(false, false, FontSize.Normal);

        protected virtual WmlFormat DefaultFormat
        {
            get
            {
                return _defaultFormat;
            }
        }

        private WmlFormat CurrentFormat
        {
            get
            {
                if (_formatStack.Count > 0)
                {
                    return (WmlFormat)_formatStack.Peek();
                }
                else
                {
                    return DefaultFormat;
                }
            }
        }

        private bool _requiresNoSoftkeyLabels = false;
        private bool _haveRequiresNoSoftkeyLabels = false;

        private bool RequiresNoSoftkeyLabels()
        {
            if (!_haveRequiresNoSoftkeyLabels)
            {
                String RequiresNoSoftkeyLabelsString = Device["requiresNoSoftkeyLabels"];
                if (RequiresNoSoftkeyLabelsString == null)
                {
                    _requiresNoSoftkeyLabels = false;
                }
                else
                {
                    _requiresNoSoftkeyLabels = Convert.ToBoolean(RequiresNoSoftkeyLabelsString);
                }
                _haveRequiresNoSoftkeyLabels = true;
            }
            return _requiresNoSoftkeyLabels;
        }


        protected class WmlLayout
        {
            private Wrapping _wrap;
            private Alignment _align;

            public WmlLayout(Style style, WmlLayout currentLayout)
            {
                Alignment align = (Alignment)style[Style.AlignmentKey, true];
                Align = (align != Alignment.NotSet) ? align : currentLayout.Align;
                Wrapping wrap = (Wrapping)style[Style.WrappingKey , true];
                Wrap = (wrap != Wrapping.NotSet) ? wrap : currentLayout.Wrap;
            }

            public WmlLayout(Alignment alignment, Wrapping wrapping)
            {
                Align = alignment;
                Wrap = wrapping;
            }

            public Wrapping Wrap
            {
                get
                {
                    return _wrap;
                }
                set
                {
                    _wrap = value;
                }
            }

            public Alignment Align
            {
                get
                {
                    return _align;
                }
                set
                {
                    _align = value;
                }
            }

            public virtual bool Compare(WmlLayout layout)
            {
                return Wrap == layout.Wrap && Align == layout.Align;
            }
        }

        protected class WmlFormat
        {
            private bool _bold;
            private bool _italic;
            private FontSize _size;
            private bool _writtenBold = false;
            private bool _writtenItalic = false;
            private bool _writtenSize = false;

            public WmlFormat(Style style, WmlFormat currentFormat)
            {
                BooleanOption bold = (BooleanOption)style[Style.BoldKey, true];
                Bold = (bold != BooleanOption.NotSet) ? bold == BooleanOption.True : currentFormat.Bold;
                BooleanOption italic = (BooleanOption)style[Style.ItalicKey, true];
                Italic = (italic != BooleanOption.NotSet) ? italic == BooleanOption.True : currentFormat.Italic;
                FontSize fontSize  = (FontSize)style[Style.FontSizeKey, true];
                Size = (fontSize != FontSize.NotSet) ? fontSize : currentFormat.Size;
            }

            public WmlFormat(bool bold, bool italic, FontSize size)
            {
                Bold = bold;
                Italic = italic;
                Size = size;
            }

            public bool Bold
            {
                get
                {
                    return _bold;
                }
                set
                {
                    _bold = value;
                }
            }


            public bool Italic
            {
                get
                {
                    return _italic;
                }
                set
                {
                    _italic = value;
                }
            }


            public FontSize Size
            {
                get
                {
                    return _size;
                }
                set
                {
                    _size = value;
                }
            }

            public bool WrittenBold
            {
                get
                {
                    return _writtenBold;
                }
                set
                {
                    _writtenBold = value;
                }
            }

            public bool WrittenItalic
            {
                get
                {
                    return _writtenItalic;
                }
                set
                {
                    _writtenItalic = value;
                }
            }

            public bool WrittenSize
            {
                get
                {
                    return _writtenSize;
                }
                set
                {
                    _writtenSize = value;
                }
            }

            public virtual bool Compare(WmlFormat format)
            {
                return Bold == format.Bold &&
                       Italic == format.Italic &&
                       Size == format.Size;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmltextviewadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlTextViewAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlTextViewAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlTextViewAdapter : WmlControlAdapter
    {
        protected new TextView Control
        {
            get
            {
                return (TextView)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            writer.EnterLayout(Style);

            int beginElement = Control.FirstVisibleElementIndex;
            int beginOffset = Control.FirstVisibleElementOffset;
            int endElement = Control.LastVisibleElementIndex;
            int endOffset = Control.LastVisibleElementOffset;

            for (int i = beginElement; i <= endElement; i++)
            {
                int begin = (i == beginElement) ? beginOffset : 0;
                int end;
                if (i == endElement)
                {
                    if (endOffset <= begin)
                    {
                        break;
                    }
                    end = endOffset;
                }
                else
                {
                    end = -1;
                }

                RenderElement(writer, i, begin, end);
            }

            writer.RenderText("", true);
            writer.ExitLayout(Style);
        }

        private void RenderElement(WmlMobileTextWriter writer, int index, int begin, int end)
        {
            TextViewElement element = Control.GetElement(index);
            if (end == -1)
            {
                end = element.Text.Length;
            }

            String text = element.Text;
            if (begin > 0 || end < text.Length)
            {
                text = text.Substring(begin, end - begin);
            }

            BooleanOption previousBold   = Style.Font.Bold;
            BooleanOption previousItalic = Style.Font.Italic;
            if (element.IsBold)
            {
                Style.Font.Bold = BooleanOption.True;
            }
            if (element.IsItalic)
            {
                Style.Font.Italic = BooleanOption.True;
            }
            
            writer.EnterStyle(Style);
            if (element.Url != null)
            {
                RenderLink(writer, element.Url, null, true, true, text, element.BreakAfter);
            }
            else
            {
                writer.RenderText(text, element.BreakAfter);
            }
            writer.ExitStyle(Style);

            Style.Font.Bold   = previousBold;
            Style.Font.Italic = previousItalic;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlvalidatoradapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlValidatorAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Web.UI.WebControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    
{

    /*
     * WmlValidatorAdapter provides the wml device functionality for
     * Validator controls.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlValidatorAdapter : WmlControlAdapter
    {
        protected new BaseValidator Control
        {
            get
            {
                return (BaseValidator)base.Control;
            }
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            writer.EnterStyle(Style);
            if (!Control.IsValid && Control.Display != ValidatorDisplay.None)
            {
                String text = Control.Text;
                if (text == String.Empty)
                {
                    text = Control.ErrorMessage;
                }
                
                if (text != String.Empty)
                {
                    writer.RenderText(text, Control.BreakAfter);
                }
            }
            writer.ExitStyle(Style);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlpageadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlPageAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Web.Mobile;
using System.Web.UI.MobileControls;
using System.Web.UI.MobileControls.Adapters;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlPageAdapter base class contains wml specific methods.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlPageAdapter : WmlControlAdapter, IPageAdapter
    {
        private IList _renderableForms;
        private static String _headerBegin = "<?xml version='1.0'";
        private static String _headerEncoding = " encoding ='{0}'";
        private static String _headerEnd
            = "?>\r\n"
            + "<!DOCTYPE wml PUBLIC '-//WAPFORUM//DTD WML 1.1//EN' 'http://www.wapforum.org/DTD/wml_1.1.xml'>";
        private static String _cacheExpiry
            = "<head>\r\n"
            + "<meta http-equiv=\"Cache-Control\" content=\"max-age=0\" />\r\n"
            + "</head>\r\n";
        private static String _contentType = "text/vnd.wap.wml";

        private IDictionary _cookielessDataDictionary = null;


        ///////////////////////////////////////////////////////////////////////////
        //  Static method used for determining if device should use
        //  this adapter
        ///////////////////////////////////////////////////////////////////////////

        public static bool DeviceQualifies(HttpContext context)
        {
            MobileCapabilities capabilities = ((MobileCapabilities)context.Request.Browser);
            String type = capabilities.PreferredRenderingType;
            bool qualifies = (type == MobileCapabilities.PreferredRenderingTypeWml11) ||
                             (type == MobileCapabilities.PreferredRenderingTypeWml12);

            return qualifies;
        }

        ///////////////////////////////////////////////////////////////////////////
        //  IPageAdapter implementation
        ///////////////////////////////////////////////////////////////////////////

        private MobilePage _page;
        
        public override MobilePage Page
        {
            get
            {
                return _page;
            }
            set
            {
                _page = value;
            }
        }

        public IDictionary CookielessDataDictionary
        {
            get
            {
                return _cookielessDataDictionary;
            }

            set
            {
                _cookielessDataDictionary = value;
            }
        }

        private bool _persistCookielessData = false;

        public bool PersistCookielessData
        {
            get
            {
                return _persistCookielessData;
            }
            
            set
            {
                _persistCookielessData = value;
            }
        }

        private int _optimumPageWeight = 0;
        private const int DefaultPageWeight = 800;

        public virtual int OptimumPageWeight
        {
            get
            {
                if (_optimumPageWeight == 0)
                {
                    _optimumPageWeight = CalculateOptimumPageWeight(DefaultPageWeight);
                }
                return _optimumPageWeight;
            }
        }

        public virtual HtmlTextWriter CreateTextWriter(TextWriter writer)
        {
            return new WmlMobileTextWriter(writer, Device, Page);
        }

        public virtual NameValueCollection DeterminePostBackMode(
            HttpRequest request,
            String postEventSourceID,
            String postEventArgumentID,
            NameValueCollection baseCollection)
        {
            NameValueCollection collection = baseCollection;

            if (collection != null)
            {
                if (Device.RequiresSpecialViewStateEncoding)
                {
                    // Reverse the special character replacement done when
                    // writing out the viewstate value.
                    String speciallyEncodedState =
                                    baseCollection[MobilePage.ViewStateID];

                    if (speciallyEncodedState != null)
                    {
                        speciallyEncodedState = EncodeSpecialViewState(speciallyEncodedState);

                        // We need to regenerate the collection since the
                        // original baseCollection is readonly.
                        collection = new NameValueCollection();
                        bool viewStateAdded = false;

                        for (int i = 0; i < baseCollection.Count; i++)
                        {
                            String name = baseCollection.GetKey(i);

                            if (!viewStateAdded && name == MobilePage.ViewStateID)
                            {
                                // This is the viewstate value we want to change.
                                collection.Add(MobilePage.ViewStateID, speciallyEncodedState);
                                viewStateAdded = true;
                            }
                            else
                            {
                                collection.Add(name, baseCollection.Get(i));
                            }
                        }
                    }
                }
            }

            return collection;
        }

        public virtual IList CacheVaryByHeaders
        {
            get
            {
                return null;
            }
        }

        public virtual bool HandleError(Exception e, HtmlTextWriter writer)
        {
            WmlMobileTextWriter wmlWriter = (WmlMobileTextWriter)writer;

            bool renderBackButton = Device.NumberOfSoftkeys > 2 && !Device.HasBackButton;

            //  set mime type, in case init() has not been called yet
            Page.Response.ContentType = _contentType;

            Exception ex;
            if ((e is HttpException && e.InnerException != null) || 
                (e is System.Reflection.TargetInvocationException && e.InnerException != null))
            {
                ex = e.InnerException;
            }
            else
            {
                ex = e;
            }

            if (RequiresUTF8ContentEncoding())
            {
                Page.Response.ContentEncoding = UTF8Encoding;
            }

            wmlWriter.BeginResponse();
            wmlWriter.BeginFile(Page.Request.Url.ToString(), _contentType, Page.Response.Charset);

            RenderXmlHeader(writer);

            // First card.

            writer.WriteFullBeginTag("wml");

            if (Device.SupportsCacheControlMetaTag)
            {
                writer.Write(_cacheExpiry);
            }
            else
            {
                Page.Response.AppendHeader("Cache-Control", "max-age=0");
            }

            writer.WriteFullBeginTag("card");

            writer.WriteFullBeginTag("p");
            writer.WriteFullBeginTag("big");
            writer.WriteFullBeginTag("b");
            wmlWriter.WriteEncodedText(SR.GetString(SR.WmlPageAdapterServerError,
                                       HttpRuntime.AppDomainAppVirtualPath));
            writer.WriteEndTag("b");
            writer.WriteEndTag("big");
            writer.WriteEndTag("p");

            writer.WriteFullBeginTag("p");
            writer.Write("<do type=\"accept\" label=\"");
            writer.Write(GetDefaultLabel(MoreLabel));
            writer.Write("\"><go href=\"#more\" /></do>");
            if (renderBackButton)
            {
                writer.Write("<do type=\"prev\" label=\"");
                writer.Write(GetDefaultLabel(BackLabel));
                writer.WriteLine("\"><prev /></do>");
            }
            wmlWriter.WriteEncodedText(ex.GetType().ToString());
            writer.Write("<br />");
            wmlWriter.WriteEncodedText(ex.Message);
            writer.Write("<br />");
            wmlWriter.WriteEncodedText(SR.GetString(SR.WmlPageAdapterMethod));
            wmlWriter.WriteEncodedText(ex.TargetSite.Name);
            writer.Write("<br />");
            writer.WriteEndTag("p");

            writer.WriteEndTag("card");

            // Stack trace card.

            writer.Write("<card id=\"more\">");
            writer.Write("<p mode=\"nowrap\">");

            if (renderBackButton)
            {
                writer.Write("<do type=\"prev\" label=\"");
                wmlWriter.WriteEncodedText(GetDefaultLabel(BackLabel));
                writer.WriteLine("\"><prev /></do>");
            }

            String stackTrace = ex.StackTrace;
            int maximumStackTrace = OptimumPageWeight / 2;
            if (stackTrace.Length > maximumStackTrace)
            {
                wmlWriter.WriteEncodedText(SR.GetString(SR.WmlPageAdapterStackTrace));
                writer.Write("<br />");
                stackTrace = stackTrace.Substring(0, maximumStackTrace);
            }
            else
            {
                wmlWriter.WriteEncodedText(SR.GetString(SR.WmlPageAdapterPartialStackTrace));
                writer.Write("<br />");
            }

            int lineBegin = 0;
            int lineEnd;
            while (lineBegin < stackTrace.Length)
            {
                lineEnd = stackTrace.IndexOf("\r\n", lineBegin);
                if (lineEnd == -1)
                {
                    lineEnd = stackTrace.Length;
                }

                wmlWriter.WriteEncodedText(stackTrace.Substring(lineBegin, lineEnd - lineBegin));
                writer.Write("<br />");

                lineBegin = lineEnd + 2;
            }

            writer.WriteEndTag("p");
            writer.WriteEndTag("card");
            writer.WriteEndTag("wml");

            wmlWriter.EndFile();
            wmlWriter.EndResponse();
            return true;
        }

        public virtual bool HandlePagePostBackEvent(String eventSource, String eventArgument)
        {
            return false;
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            if (RequiresUTF8ContentEncoding())
            {
                Page.Response.ContentEncoding = UTF8Encoding;
            }

            writer.BeginResponse();
            writer.BeginFile(Page.Request.Url.ToString(), _contentType, Page.Response.Charset);

            RenderXmlHeader(writer);

            writer.WriteFullBeginTag("wml");

            if (Device.SupportsCacheControlMetaTag)
            {
                writer.Write(_cacheExpiry);
            }
            else
            {
                Page.Response.AppendHeader("Cache-Control", "max-age=0");
            }

            if (Device.CanCombineFormsInDeck)
            {
                _renderableForms = Page.ActiveForm.GetLinkedForms(OptimumPageWeight);
                Debug.Assert(_renderableForms != null, "_renderableForms is null");
            }
            else
            {
                _renderableForms = new ArrayList();
                _renderableForms.Add(Page.ActiveForm);
            }

            foreach (Form form in _renderableForms)
            {
                RenderForm(writer, form);
            }

            writer.RenderExtraCards();

            writer.WriteEndTag("wml");

            writer.EndFile();
            writer.EndResponse();
        }

        protected virtual void RenderForm(WmlMobileTextWriter writer, Form form)
        {
            writer.AnalyzeMode = true;
            form.RenderControl(writer);
            writer.AnalyzeMode = false;
            form.RenderControl(writer);
        }

        // Should be called by controls/adapters after _renderableForms is
        // set in this.Render()
        public virtual bool IsFormRendered(Form form)
        {
            Debug.Assert(_renderableForms != null, "_renderableForms is null");
            return _renderableForms.Contains(form);
        }

        private void RenderXmlHeader(HtmlTextWriter writer)
        {
            writer.Write(_headerBegin);
            String charset = Page.Response.Charset;
            if (charset != null && charset.Length > 0 && 
                String.Compare(charset, "utf-8", true, CultureInfo.InvariantCulture) != 0)
            {
                writer.Write(String.Format(_headerEncoding, charset));
            }
            writer.Write(_headerEnd);
        }

        public virtual bool RendersMultipleForms()
        {
            return _renderableForms.Count > 1;
        }

        // '+' <-> '-'
        // '=' <-> '.'
        // '/' <-> '*'
        private static readonly char[] _specialEncodingChars = new char[64]
        {
            '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
            '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',
            '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',  '/',  '-', '\0',  '+',  '=',  '*',
            '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0',  '.', '\0', '\0',
        };

        internal String EncodeSpecialViewState(String pageState)
        {
            char[] viewstate = pageState.ToCharArray();

            for (int i = 0; i < viewstate.Length; i++)
            {
                char currentChar = viewstate[i];

                // Only check character replacement if within the range
                if (currentChar < _specialEncodingChars.Length)
                {
                    char encodingChar = _specialEncodingChars[currentChar];
                    if (encodingChar != '\0')
                    {
                        viewstate[i] = encodingChar;
                    }
                }
            }
            return new String(viewstate);
        }

        private static readonly Encoding UTF8Encoding = Encoding.GetEncoding("UTF-8");

        private bool _requiresUTF8ContentEncoding = false;
        private bool _haveRequiresUTF8ContentEncoding = false;

        private bool RequiresUTF8ContentEncoding()
        {
            if (!_haveRequiresUTF8ContentEncoding)
            {
                String RequiresUTF8ContentEncodingString = Device["requiresUTF8ContentEncoding"];
                if (RequiresUTF8ContentEncodingString == null)
                {
                    if (IsKDDIPhone())
                    {
                        _requiresUTF8ContentEncoding = true;
                    }
                }
                else
                {
                    _requiresUTF8ContentEncoding = Convert.ToBoolean(RequiresUTF8ContentEncodingString);
                }
                _haveRequiresUTF8ContentEncoding = true;
            }
            return _requiresUTF8ContentEncoding;
        }

        private bool _requiresValueAttributeInInputTag = false;
        private bool _haveRequiresValueAttributeInInputTag = false;

        internal bool RequiresValueAttributeInInputTag()
        {
            if (!_haveRequiresValueAttributeInInputTag)
            {
                String RequiresValueAttributeInInputTagString = Device["requiresValueAttributeInInputTag"];
                if (RequiresValueAttributeInInputTagString == null)
                {
                    if (IsKDDIPhone())
                    {
                        _requiresValueAttributeInInputTag = true;
                    }
                }
                else
                {
                    _requiresValueAttributeInInputTag = Convert.ToBoolean(RequiresValueAttributeInInputTagString);
                }
                _haveRequiresValueAttributeInInputTag = true;
            }
            return _requiresValueAttributeInInputTag;
        }

        private bool _isKDDIPhone = false;
        private bool _haveIsKDDIPhone = false;

        internal bool IsKDDIPhone()
        {
            if (!_haveIsKDDIPhone)
            {
                if (Device.Browser == "Phone.com" &&
                    Device.MajorVersion == 3 &&
                    Device.MinorVersion < 0.3)
                {
                    String charset = Page.Request.Headers["x-up-devcap-charset"];

                    if (charset != null &&
                        String.Compare(charset, "Shift_JIS", true, CultureInfo.InvariantCulture) == 0)
                    {
                        _isKDDIPhone = true;
                    }
                }
                _haveIsKDDIPhone = true;
            }
            return _isKDDIPhone;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmlvalidationsummaryadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlValidationSummaryAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.MobileControls;
using System.Diagnostics;
using System.Collections;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlValidationSummaryAdapter provides the wml device functionality for
     * ValidationSummary control.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlValidationSummaryAdapter : WmlControlAdapter
    {
        private List _list;  // to paginate error messages
        private Link _link;  // to go back to the form validated by this control

        protected new ValidationSummary Control
        {
            get
            {
                return (ValidationSummary)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
            // Create child controls to help on rendering
            _list = new List();
            Control.Controls.Add(_list);
            _link = new Link();
            Control.Controls.Add(_link);
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            String[] errorMessages = null;

            if (Control.Visible)
            {
                errorMessages = Control.GetErrorMessages();
            }
    
            writer.EnterStyle(Style);
            if (errorMessages != null)
            {
                if (Control.HeaderText.Length > 0)
                {
                    writer.RenderText(Control.HeaderText, true);
                }

                ArrayList arr = new ArrayList();
                foreach (String errorMessage in errorMessages)
                {
                    Debug.Assert(errorMessage != null && errorMessage.Length > 0, "Bad Error Messages");
                    arr.Add(errorMessage);
                }

                _list.DataSource = arr;
                _list.DataBind();

                if (String.Compare(Control.FormToValidate, Control.Form.UniqueID, true) != 0)
                {
                    _link.NavigateUrl = Constants.FormIDPrefix + Control.FormToValidate;
                    _link.Text = Control.BackLabel == String.Empty? GetDefaultLabel(BackLabel) : Control.BackLabel;
                }
                else
                {
                    _link.Visible = false;
                }

                // Render the child controls to display error message list and a
                // link for going back to the Form that is having error
                RenderChildren(writer);
            }
            writer.ExitStyle(Style);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\adapters\wmltextboxadapter.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmlTextBoxAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.IO;
using System.Web;
using System.Web.UI;
using System.Web.UI.MobileControls;
using System.Security.Permissions;

#if COMPILING_FOR_SHIPPED_SOURCE
namespace System.Web.UI.MobileControls.ShippedAdapterSource
#else
namespace System.Web.UI.MobileControls.Adapters
#endif    

{

    /*
     * WmlTextBoxAdapter class.
     *
     * Copyright (c) 2000 Microsoft Corporation
     */
    [AspNetHostingPermission(SecurityAction.LinkDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    [AspNetHostingPermission(SecurityAction.InheritanceDemand, Level=AspNetHostingPermissionLevel.Minimal)]
    public class WmlTextBoxAdapter : WmlControlAdapter
    {
        private String _staticValue;

        protected new TextBox Control
        {
            get
            {
                return (TextBox)base.Control;
            }
        }

        public override void OnInit(EventArgs e)
        {
            _staticValue = Control.Text;
            base.OnInit(e);
        }

        public override void Render(WmlMobileTextWriter writer)
        {
            String value = Control.Text;
            bool requiresRandomID = RequiresRandomID();

            writer.EnterLayout(Style);
            if (Control.Password)
            {
                value = String.Empty;
            }

            if (!PageAdapter.RequiresValueAttributeInInputTag())
            {
                writer.AddFormVariable(Control.ClientID, value, requiresRandomID);
            }
            else
            {
                // This is to make sure an id is determined in the first
                // pass, and this is done in AddFormVariable as well.
                writer.MapClientIDToShortName(Control.ClientID, requiresRandomID);
            }

            String format = ((IAttributeAccessor)Control).GetAttribute("wmlFormat");
            if (format == null || format == String.Empty)
            {
                if (Control.Numeric)
                {
                    format = "*N";
                }
                else
                {
                    format = null;
                }
            }
            
            writer.RenderTextBox(Control.ClientID, 
                                 value,
                                 format, 
                                 Control.Title,
                                 Control.Password, 
                                 Control.Size, 
                                 Control.MaxLength, 
                                 requiresRandomID,
                                 Control.BreakAfter);
            writer.ExitLayout(Style);
        }

        private bool RequiresRandomID()
        {
            String randomID = ((IAttributeAccessor)Control).GetAttribute("useRandomID");
            if (randomID != null)
            {
                return String.Compare(randomID, "true", true, CultureInfo.InvariantCulture) == 0;
            }
            else
            {
                return Control.Password;
            }
        }

        protected override String GetPostBackValue()
        {
            // Optimization - if viewstate is enabled for this control, and the
            // postback returns to this page, we just let it do the trick.

            if (Control.Form.Action.Length > 0 || (!IsViewStateEnabled() && Control.Text != _staticValue))
            {
                return Control.Text;
            }
            else
            {
                return null;
            }
        }

        private bool IsViewStateEnabled()
        {
            Control ctl = Control;
            while (ctl != null)
            {
                if (!ctl.EnableViewState)
                {
                    return false;
                }
                ctl = ctl.Parent;
            }
            return true;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\calendardatabindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarDataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class CalendarDataBindingHandler : DataBindingHandler
    {
        public override void DataBindControl(IDesignerHost designerHost, Control control)
        {
            Debug.Assert(control is Calendar, "Expected a Calendar");
            Calendar calendar = (Calendar)control;

            DataBinding dateBinding = ((IDataBindingsAccessor)calendar).DataBindings["SelectedDate"];
            if (dateBinding != null) {
                calendar.SelectedDate = DateTime.Today;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\adrotatordesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdRotatorDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Web.UI.MobileControls;
    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides design-time support for the <see cref='System.Web.UI.MobileControls.AdRotator'/>
    ///       mobile control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.AdRotator'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class AdRotatorDesigner : MobileControlDesigner 
    {
        private System.Web.UI.MobileControls.AdRotator _adRotator;

        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.AdRotator,
                         "AdRotatorDesigner.Initialize - Invalid AdRotator Control");
            _adRotator = (System.Web.UI.MobileControls.AdRotator) component;
            base.Initialize(component);
        }

        protected override String GetDesignTimeNormalHtml()
        {
            DesignerTextWriter writer = new DesignerTextWriter();
            _adRotator.Adapter.Render(writer);

            return writer.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\basetemplatedmobilecomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseTemplatedMobileComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <summary>
    ///    <para>
    ///       Provides the
    ///       base component editor for Mobile Templated controls.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal abstract class BaseTemplatedMobileComponentEditor : WindowsFormsComponentEditor
    {
        private int _initialPage;

        /// <summary>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.MobileControls.BaseTemplatedMobileComponentEditor'/>.
        ///    </para>
        /// </summary>
        /// <param name='initialPage'>
        ///    The index of the initial page.
        /// </param>
        internal BaseTemplatedMobileComponentEditor(int initialPage)
        {
            this._initialPage = initialPage;
        }

        /// <summary>
        ///    <para>
        ///       Edits a component.
        ///    </para>
        /// </summary>
        /// <param name='parent'>
        ///    The <see cref='System.Windows.Forms.IWin32Window'/> parent.
        /// </param>
        /// <param name='context'>
        /// </param>
        /// <param name=' obj'>
        ///    The component to edit.
        /// </param>
        public override bool EditComponent(ITypeDescriptorContext context, Object obj, IWin32Window parent)
        {
            bool result = false;
            bool inTemplateMode = false;

            Debug.Assert(obj is IComponent, "Expected obj to be an IComponent");
            IComponent comp = (IComponent)obj;
            ISite compSite = comp.Site;

            if (compSite != null)
            {
                IDesignerHost designerHost = (IDesignerHost)compSite.GetService(typeof(IDesignerHost));

                IDesigner compDesigner = designerHost.GetDesigner(comp);
                Debug.Assert(compDesigner is TemplatedControlDesigner,
                             "Expected component to have a TemplatedControlDesigner");

                TemplatedControlDesigner tplDesigner = (TemplatedControlDesigner) compDesigner;
                inTemplateMode = tplDesigner.InTemplateMode;
            }
            
            if (inTemplateMode == false)
            {
                result = base.EditComponent(context, obj, parent);
            }
            else
            {
                MessageBox.Show(SR.GetString(SR.BaseTemplatedMobileComponentEditor_TemplateModeErrorMessage), 
                                SR.GetString(SR.BaseTemplatedMobileComponentEditor_TemplateModeErrorTitle),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            return result;
        }

        /// <summary>
        ///    <para>
        ///       Gets the index of the initial component editor page.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The index of the initial page.
        ///    </para>
        /// </returns>
        protected override int GetInitialComponentEditorPageIndex()
        {
            return _initialPage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\applieddevicefilterseditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="AppliedDeviceFiltersEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Windows.Forms.Design;

    using DialogResult = System.Windows.Forms.DialogResult;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class AppliedDeviceFiltersTypeEditor : UITypeEditor
    {
        private static readonly String _appliedDeviceFiltersDescription = "AppliedDeviceFilters";

        public override Object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, Object value) 
        {
            Debug.Assert(context.Instance is Control, "Expected control");
            Control ctrl = (Control) context.Instance;

            IServiceProvider serviceProvider;
            ISite site = ctrl.Site;
            if (site == null && ctrl.Page != null) 
            {
                site = ctrl.Page.Site;
            }
            if (site != null) 
            {
                serviceProvider = site;
            }
            else 
            {
                serviceProvider = provider;
            }
            Debug.Assert(serviceProvider != null,
                "Failed to get the serviceProvider");
            
            IComponentChangeService changeService =
                (IComponentChangeService) serviceProvider.GetService(typeof(IComponentChangeService));

            IDesignerHost designerHost = 
                (IDesignerHost) serviceProvider.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null,
                "Must always have access to IDesignerHost service");

            IDeviceSpecificDesigner dsDesigner = 
                designerHost.GetDesigner(ctrl) as IDeviceSpecificDesigner;
            Debug.Assert(dsDesigner != null,
                "Expected component designer to implement IDeviceSpecificDesigner");

            IMobileWebFormServices wfServices = 
                (IMobileWebFormServices)serviceProvider.GetService(typeof(IMobileWebFormServices));

            DialogResult result = DialogResult.Cancel;

            DesignerTransaction transaction = designerHost.CreateTransaction(_appliedDeviceFiltersDescription);
            try 
            {
                if (changeService != null) 
                {
                    try 
                    {
                        changeService.OnComponentChanging(ctrl, null);
                    }
                    catch (CheckoutException ce) 
                    {
                        if (ce == CheckoutException.Canceled) 
                        {
                            return value;
                        }
                        throw;
                    }
                }

                try 
                {
                    AppliedDeviceFiltersDialog dialog = 
                        new AppliedDeviceFiltersDialog(dsDesigner, MobileControlDesigner.MergingContextChoices);
                    IWindowsFormsEditorService edSvc = 
                        (IWindowsFormsEditorService) provider.GetService(typeof(IWindowsFormsEditorService));
                    result = edSvc.ShowDialog(dialog);
                }
                finally 
                {
                    if (changeService != null && result != DialogResult.Cancel) 
                    {
                        changeService.OnComponentChanged(ctrl, null, null, null);
                    }
                }
            }
            finally 
            {
                if (transaction != null) 
                {
                    if (result == DialogResult.OK) 
                    {
                        transaction.Commit();
                    }
                    else 
                    {
                        transaction.Cancel();
                    }
                }
            }

            return value;
        }

        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) 
        {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\calendardesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="CalendarDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.WebControls;

    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides a designer for the <see cref='System.Web.UI.MobileControls.Calendar'/>
    ///       control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.Calendar'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class CalendarDesigner : MobileControlDesigner 
    {
        private System.Web.UI.MobileControls.Calendar _calendar;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.Calendar,
                         "CalendarDesigner.Initialize - Invalid Calendar Control");
            _calendar = (System.Web.UI.MobileControls.Calendar) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.Calendar'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.Calendar'/>
        protected override String GetDesignTimeNormalHtml()
        {
            DesignerTextWriter tw = new DesignerTextWriter();
            _calendar.Adapter.Render(tw);

            return tw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\basevalidatordesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseValdiatorDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.WebControls;

    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       Provides
    ///       a designer for controls derived from ValidatorBase.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class BaseValidatorDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.BaseValidator _baseValidator;

        /// <summary>
        ///    <para>
        ///       Initializes the designer.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element being designed.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component being
        ///       designed.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.BaseValidator,
                         "BaseValidatorDesigner.Initialize - Invalid BaseValidator Control");
            _baseValidator = (System.Web.UI.MobileControls.BaseValidator) component;
            base.Initialize(component);

            // remove the contained asp validator within mobile validator so that it won't
            // be persisted.
            for (int i = _baseValidator.Controls.Count - 1; i >= 0; i--)
            {
                Control child = _baseValidator.Controls[i];
                if (child is System.Web.UI.WebControls.BaseValidator)
                {
                    _baseValidator.Controls.RemoveAt(i);
                }
            }
        }

        /// <summary>
        ///    <para>
        ///       Gets the design time HTML of ValidatorBase controls.
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The design time
        ///       HTML of the control.
        ///    </para>
        /// </returns>
        protected override String GetDesignTimeNormalHtml()
        {
            Debug.Assert(_baseValidator.Text != null);

            String originalText  = _baseValidator.ErrorMessage;
            ValidatorDisplay validatorDisplay = _baseValidator.Display;
            bool blankText = (validatorDisplay == ValidatorDisplay.None || 
                             (originalText.Trim().Length == 0 && _baseValidator.Text.Trim().Length == 0));
            if (blankText)
            {
                _baseValidator.ErrorMessage = "[" + _baseValidator.ID + "]";
            }

            DesignerTextWriter tw = new DesignerTextWriter();
            _baseValidator.Adapter.Render(tw);

            if (blankText)
            {
                _baseValidator.ErrorMessage = originalText;
            }

            return tw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\applieddevicefiltersdialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="AppliedDeviceFilterDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    
    using System.Web.UI.MobileControls;
    using System.Web.UI.Design.MobileControls.Util;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class AppliedDeviceFiltersDialog :
        System.Windows.Forms.Form, IRefreshableDeviceSpecificEditor
    {
        private bool _isDirty = true;
        private IDeviceSpecificDesigner _designer = null;
        private WebConfigManager _webConfig = null;
        private IDictionary _cachedDeviceSpecifics =
            new HybridDictionary(true /* make case-insensitive */ );
        private String _currentDeviceSpecificID = null;
        
        private System.Windows.Forms.Label _lblAvailableFilters;
        private System.Windows.Forms.Button _btnEditFilters;
        private System.Windows.Forms.ComboBox _cbAvailableFilters;
        private System.Windows.Forms.Button _btnApplyFilter;
        private System.Windows.Forms.Button _cmdCancel;
        private System.Windows.Forms.Button _cmdOK;
        private System.Windows.Forms.Button _cmdHelp;
        private System.Windows.Forms.Panel _pnlMain;
        private System.Windows.Forms.Label _lblArgument;
        private System.Windows.Forms.TextBox _tbArgument;
        private EditableTreeList _appliedFiltersList;
        
        internal AppliedDeviceFiltersDialog(
            IDeviceSpecificDesigner designer, 
            int mergingContext)
        {
            _designer = designer;
            _designer.SetDeviceSpecificEditor(this);

            // Required for Win Form Designer support
            InitializeComponent();

            _lblAvailableFilters.Text =
                SR.GetString(SR.AppliedDeviceFiltersDialog_AvailableDeviceFilters);
            _appliedFiltersList.LblTitle.Text =
                SR.GetString(SR.AppliedDeviceFiltersDialog_AppliedDeviceFilters);
            _btnEditFilters.Text = SR.GetString(SR.GenericDialog_Edit);
            _btnApplyFilter.Text =
                SR.GetString(SR.AppliedDeviceFiltersDialog_ApplyDeviceFilter);
            _lblArgument.Text =
                SR.GetString(SR.AppliedDeviceFiltersDialog_Argument);
            _cmdOK.Text = SR.GetString(SR.GenericDialog_OKBtnCaption);
            _cmdCancel.Text = SR.GetString(SR.GenericDialog_CancelBtnCaption);
            _cmdHelp.Text = SR.GetString(SR.GenericDialog_HelpBtnCaption);

            int tabOffset = GenericUI.InitDialog(
                this,
                _designer,
                mergingContext
            );
            
            this.Text = _designer.UnderlyingControl.ID
                + " - " + SR.GetString(SR.AppliedDeviceFiltersDialog_Title);
            SetTabIndexes(tabOffset);
            _webConfig = new WebConfigManager(_designer.UnderlyingControl.Site);
            LoadAvailableFilters();

            // Note that the following can cause an
            // IDeviceSpecificDesigner.Refresh() to occur as a side-effect.
            _designer.RefreshHeader(mergingContext);

            _currentDeviceSpecificID = _designer.CurrentDeviceSpecificID;
            if(_currentDeviceSpecificID != null)
            {
                DeviceSpecific ds;
                _designer.GetDeviceSpecific(_currentDeviceSpecificID, out ds);
                LoadChoices(ds);
            }

            // Register Event Handlers
            _cbAvailableFilters.SelectedIndexChanged += new EventHandler(
                OnAvailableFilterSelected
            );
            _cbAvailableFilters.TextChanged += new EventHandler(
                OnAvailableFilterSelected
            );
            _btnApplyFilter.Click += new EventHandler(OnApplyFilter);
            _btnEditFilters.Click += new EventHandler(OnEditFilters);
            _appliedFiltersList.TvList.AfterSelect += new TreeViewEventHandler(OnAppliedFilterSelected);
            _appliedFiltersList.TvList.AfterLabelEdit += new NodeLabelEditEventHandler(OnAfterLabelEdit);
            _appliedFiltersList.BtnUp.Click += new EventHandler(OnAppliedFiltersReordered);
            _appliedFiltersList.BtnDown.Click += new EventHandler(OnAppliedFiltersReordered);
            _appliedFiltersList.BtnRemove.Click -= _appliedFiltersList.RemoveHandler;
            _appliedFiltersList.BtnRemove.Click += new EventHandler(OnRemove);
            _tbArgument.TextChanged += new EventHandler(OnArgumentChanged);
            _cmdOK.Click += new EventHandler(OnOK);
            _cmdCancel.Click += new EventHandler(OnCancel);
            _cmdHelp.Click += new EventHandler(OnHelp);

            UpdateUI();
        }
        
        internal void SetTabIndexes(int tabOffset)
        {
            _pnlMain.TabIndex = ++tabOffset;
            _lblAvailableFilters.TabIndex = ++tabOffset;
            _cbAvailableFilters.TabIndex = ++tabOffset;
            _btnEditFilters.TabIndex = ++tabOffset;
            _btnApplyFilter.TabIndex = ++tabOffset;
            _appliedFiltersList.TabIndex = ++tabOffset;
            _lblArgument.TabIndex = ++tabOffset;
            _tbArgument.TabIndex = ++tabOffset;
            _cmdOK.TabIndex = ++tabOffset;
            _cmdCancel.TabIndex = ++tabOffset;
            _cmdHelp.TabIndex = ++tabOffset;
        }

        private void InitializeComponent()
        {
            this._appliedFiltersList =
                new System.Web.UI.Design.MobileControls.Util.EditableTreeList(
                false, true, 16
                );
            this._btnEditFilters = new System.Windows.Forms.Button();
            this._cmdHelp = new System.Windows.Forms.Button();
            this._cmdOK = new System.Windows.Forms.Button();
            this._pnlMain = new System.Windows.Forms.Panel();
            this._tbArgument = new System.Windows.Forms.TextBox();
            this._lblArgument = new System.Windows.Forms.Label();
            this._cmdCancel = new System.Windows.Forms.Button();
            this._lblAvailableFilters = new System.Windows.Forms.Label();
            this._cbAvailableFilters = new System.Windows.Forms.ComboBox();
            this._btnApplyFilter = new System.Windows.Forms.Button();
            this._pnlMain.SuspendLayout();
            this.SuspendLayout();
            // 
            // _appliedFiltersList
            // 
            this._appliedFiltersList.Location = new System.Drawing.Point(0, 74);
            this._appliedFiltersList.Name = "_appliedFiltersList";
            this._appliedFiltersList.Size = new System.Drawing.Size(275, 208);
            // 
            // _btnEditFilters
            // 
            this._btnEditFilters.Location = new System.Drawing.Point(201, 15);
            this._btnEditFilters.Size = new System.Drawing.Size(75, 23);
            this._btnEditFilters.Name = "_btnEditFilters";
            // 
            // _cmdHelp
            // 
            this._cmdHelp.Location = new System.Drawing.Point(201, 334);
            this._cmdHelp.Name = "_cmdHelp";
            // 
            // _cmdOK
            // 
            this._cmdOK.Location = new System.Drawing.Point(39, 334);
            this._cmdOK.Name = "_cmdOK";
            // 
            // _pnlMain
            // 
            this._pnlMain.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
            this._pnlMain.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                                   this._tbArgument,
                                                                                   this._lblArgument,
                                                                                   this._appliedFiltersList,
                                                                                   this._cmdHelp,
                                                                                   this._cmdCancel,
                                                                                   this._cmdOK,
                                                                                   this._lblAvailableFilters,
                                                                                   this._btnEditFilters,
                                                                                   this._cbAvailableFilters,
                                                                                   this._btnApplyFilter});
            this._pnlMain.Location = new System.Drawing.Point(6, 8);
            this._pnlMain.Name = "_pnlMain";
            this._pnlMain.Size = new System.Drawing.Size(276, 357);
            // 
            // _tbArgument
            // 
            this._tbArgument.Location = new System.Drawing.Point(0, 306);
            this._tbArgument.Name = "_tbArgument";
            this._tbArgument.Size = new System.Drawing.Size(275, 20);
            this._tbArgument.Text = "";
            // 
            // _lblArgument
            // 
            this._lblArgument.Location = new System.Drawing.Point(0, 290);
            this._lblArgument.Name = "_lblArgument";
            this._lblArgument.Size = new System.Drawing.Size(275, 16);
            // 
            // _cmdCancel
            // 
            this._cmdCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this._cmdCancel.Location = new System.Drawing.Point(120, 334);
            this._cmdCancel.Name = "_cmdCancel";
            // 
            // _lblAvailableFilters
            // 
            this._lblAvailableFilters.Name = "_lblAvailableFilters";
            this._lblAvailableFilters.Size = new System.Drawing.Size(198, 16);
            // 
            // _cbAvailableFilters
            // 
            this._cbAvailableFilters.DropDownWidth = 195;
            this._cbAvailableFilters.Location = new System.Drawing.Point(0, 16);
            this._cbAvailableFilters.Name = "_cbAvailableFilters";
            this._cbAvailableFilters.Size = new System.Drawing.Size(195, 21);
            this._cbAvailableFilters.Sorted = true;
            // 
            // _btnApplyFilter
            // 
            this._btnApplyFilter.Location = new System.Drawing.Point(0, 44);
            this._btnApplyFilter.Name = "_btnApplyFilter";
            this._btnApplyFilter.Size = new System.Drawing.Size(195, 23);
            // 
            // AppliedDeviceFiltersDialog
            // 
            this.AcceptButton = this._cmdOK;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this._cmdCancel;
            this.ClientSize = new System.Drawing.Size(285, 373);
            this.Controls.AddRange(new System.Windows.Forms.Control[] {
                                                                          this._pnlMain});
            this.Name = "AppliedDeviceFiltersDialog";
            this.HelpRequested += new System.Windows.Forms.HelpEventHandler(this.OnHelpRequested);
            this._pnlMain.ResumeLayout(false);
            this.ResumeLayout(false);
        }

        private void LoadAvailableFilters()
        {
            _cbAvailableFilters.Items.Clear();
            try
            {
                ArrayList filterList = _webConfig.ReadDeviceFilters();
                _cbAvailableFilters.Sorted = false;
                foreach(DeviceFilterNode node in filterList)
                {
                    _cbAvailableFilters.Items.Add(node);
                }
            }
            catch (Exception e)
            {
                Debug.Fail(e.ToString());
                // This is okay.  They may still apply a default or external
                // device filter.
            }
            _cbAvailableFilters.Sorted = true;
            EnsureDefaultFilterAvailableXorApplied();

            // If there is no filter selected, or there was a filter selected
            // but that filter no longer exists
            if( _cbAvailableFilters.Text.Length == 0
                || FindAvailableFilter(_cbAvailableFilters.Text) == null)
            {
                SelectFirstAvailableFilter();
            }
        }

        private void CacheState(String deviceSpecificID)
        {
            _cachedDeviceSpecifics[deviceSpecificID] = new AppliedFiltersCachedState(
                _appliedFiltersList.TvList
            );
        }

        private void CacheCurrentState()
        {
            CacheState(_currentDeviceSpecificID);
        }

        private bool RestoreState(String deviceSpecificID)
        {
            if (null != deviceSpecificID)
            {
                _currentDeviceSpecificID = deviceSpecificID;
                AppliedFiltersCachedState state =
                    (AppliedFiltersCachedState) _cachedDeviceSpecifics[
                        _currentDeviceSpecificID
                    ];
                if(state != null)
                {
                    state.Restore(_appliedFiltersList.TvList);
                    EnsureDefaultFilterAvailableXorApplied();
                    return true;
                }
            }
            else
            {
                _currentDeviceSpecificID = null;
            }
            return false;
        }

        private DeviceFilterNode CreateExternalFilter(String name)
        {
            DeviceFilterNode externalFilter;
            externalFilter = new DeviceFilterNode(_webConfig);
            externalFilter.Name = name;
            return externalFilter;
        }

        private void LoadChoice(DeviceSpecificChoice runtimeChoice)
        {
            DeviceFilterNode filterUsed =
                FindAvailableFilter(runtimeChoice.Filter);
            
            ChoiceTreeNode choice = new ChoiceTreeNode(
                filterUsed,
                runtimeChoice,
                _designer
            );
            _appliedFiltersList.TvList.Nodes.Add(choice);
        }

        private void LoadChoices(DeviceSpecific deviceSpecific)
        {
            _appliedFiltersList.TvList.Nodes.Clear();

            if(deviceSpecific != null)
            {
                foreach(DeviceSpecificChoice runtimeChoice in deviceSpecific.Choices)
                {
                    LoadChoice(runtimeChoice);
                }
            }
            EnsureDefaultFilterAvailableXorApplied();
        }
        
        private void SaveChoices()
        {
            if(_currentDeviceSpecificID != null)
            {
                CacheCurrentState();
            }
            foreach (DictionaryEntry entry in _cachedDeviceSpecifics)
            {
                AppliedFiltersCachedState state =
                    (AppliedFiltersCachedState) entry.Value;
                state.SaveChoicesFromTreeView(
                    _designer,
                    (String) entry.Key
                );
            }
        }

        private void SelectFirstAvailableFilter()
        {
            if (_cbAvailableFilters.Items.Count > 0)
            {
                DeviceFilterNode filter =
                    (DeviceFilterNode) _cbAvailableFilters.Items[0];
                _cbAvailableFilters.SelectedItem = filter;
            }
            else
            {
                _cbAvailableFilters.Text = "";
            }
        }

        private void SelectNextAvailableFilter(DeviceFilterNode currentFilter)
        {
            // if an externally defined filter is selected, let
            // SelectFirstAvailableFitler handle this.
            if(currentFilter == null)
            {
                SelectFirstAvailableFilter();
                return;
            }
            
            int index = _cbAvailableFilters.Items.IndexOf(currentFilter);
            if((index + 1) < _cbAvailableFilters.Items.Count)
            {
                _cbAvailableFilters.SelectedItem =
                    _cbAvailableFilters.Items[index + 1];
            }
            else if(index > 0)
            {
                _cbAvailableFilters.SelectedItem =
                    _cbAvailableFilters.Items[index - 1];
            }
            else
            {
                _cbAvailableFilters.SelectedItem = null;
                _cbAvailableFilters.Text = "";
            }
        }

        private DeviceFilterNode FindAvailableFilter(String name)
        {
            if(IsDefaultFilter(name))
            {
                name = "";
            }
            foreach(DeviceFilterNode filter in _cbAvailableFilters.Items)
            {
                if(filter.Name == name)
                {
                    return filter;
                }
            }
            return null;
        }

        private bool DefaultFilterIsApplied
        {
            get
            {
                return FindAppliedFilter("") != null;
            }
        }

        private bool DefaultFilterIsAvailable
        {
            get
            {
                return FindAvailableFilter("") != null;
            }
        }

        private ChoiceTreeNode FindAppliedFilter(String name)
        {
            if(IsDefaultFilter(name))
            {
                name = "";
            }
            foreach(ChoiceTreeNode choice in _appliedFiltersList.TvList.Nodes)
            {
                if(choice.Name == name)
                {
                    return choice;
                }
            }
            return null;            
        }

        private void EnsureDefaultFilterAvailableXorApplied()
        {
            if(DefaultFilterIsApplied)
            {
                DeviceFilterNode filter = FindAvailableFilter("");
                if(filter != null)
                {
                    RemoveAvailableFilter(filter);
                }
            }
            else if(!DefaultFilterIsAvailable)
            {
                _cbAvailableFilters.Items.Add(CreateExternalFilter(""));
            }
        }

        private bool IsDefaultFilter(String name)
        {
            return(
                name == null
                || name.Length == 0
                || name == SR.GetString(SR.DeviceFilter_DefaultChoice)
            );
        }
        
        private bool AvailableFilterIsSelected
        {
            get
            {
                return _cbAvailableFilters.Text != null && 
                    _cbAvailableFilters.Text.Length > 0;
            }
        }
        
        private bool AppliedFilterIsSelected
        {
            get
            {
                return SelectedAppliedFilter != null;
            }
        }

        private ChoiceTreeNode SelectedAppliedFilter
        {
            get
            {
                return (ChoiceTreeNode) _appliedFiltersList.TvList.SelectedNode;
            }
        }

        private void UpdateUI()
        {
            if(AppliedFilterIsSelected
                && !IsDefaultFilter(SelectedAppliedFilter.Name))
            {
                _tbArgument.Enabled = true;
                _tbArgument.Text = SelectedAppliedFilter.Argument;
            }
            else
            {
                _tbArgument.Enabled = false;
                _tbArgument.Text = "";
            }
            _btnApplyFilter.Enabled =
                AvailableFilterIsSelected && (_designer.UnderlyingObject != null);
            _cbAvailableFilters.Enabled = (_designer.UnderlyingObject != null);
            _appliedFiltersList.UpdateButtonsEnabling();
        }

        private bool ChoiceHasContent(DeviceSpecificChoice runtimeChoice)
        {
            return (runtimeChoice.Contents.Count > 0) || runtimeChoice.HasTemplates;
        }

        private void RemoveAvailableFilter(DeviceFilterNode filter)
        {
            SelectNextAvailableFilter(filter);
            _cbAvailableFilters.Items.Remove(filter);
            UpdateUI();
        }

        private void ShowHelpTopic()
        {
            ISite componentSite = _designer.UnderlyingControl.Site;
            Debug.Assert(componentSite != null, "Expected the stylesheet to be sited.");
 
            IHelpService helpService = (IHelpService)componentSite.GetService(typeof(IHelpService));
            if (helpService != null) 
            {
                helpService.ShowHelpFromKeyword("net.Mobile.AppliedDeviceFiltersDialog");
            }
        }

        private void SetDirty(bool dirty)
        {
            if (dirty)
            {
                if (false == _isDirty)
                {
                    _isDirty = true;
                    _cmdCancel.Text = SR.GetString(SR.GenericDialog_CancelBtnCaption);
                }
            }
            else
            {
                if (true == _isDirty)
                {
                    _isDirty = false;
                    _cmdCancel.Text = SR.GetString(SR.GenericDialog_CloseBtnCaption);
                }
            }
        }

        private bool ValidateAppliedFilters()
        {
            StringCollection duplicateChoices =
                DesignerUtility.GetDuplicateChoiceTreeNodes(
                    _appliedFiltersList.TvList.Nodes
                );
            if(duplicateChoices.Count > 0)
            {
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.AppliedDeviceFiltersDialog_Title),
                    SR.GetString(SR.AppliedDeviceFiltersDialog_DuplicateChoices,
                    GenericUI.BuildCommaDelimitedList(duplicateChoices))
                );
                return false;
            }
            return true;
        }

        ////////////////////////////////////////////////////////////////////////
        //  Begin Event Handling
        ////////////////////////////////////////////////////////////////////////

        private void OnArgumentChanged(Object sender, EventArgs e)
        {
            if(!AppliedFilterIsSelected)
            {
                // UpdateUI sets to empty string when no filter selected.
                Debug.Assert(_tbArgument.Text == "",
                    "Not a side effect of clearing the argument. "
                    + "Arugment changed with no applied filter selected. "
                    + "Missing a call to UpdateUI()?");
                return;
            }
            SelectedAppliedFilter.Argument = _tbArgument.Text;
            SetDirty(true);
        }

        private void OnAfterLabelEdit(Object sender, NodeLabelEditEventArgs e)
        {
            // null still returned if label unmodified (verified 2310)
            if(e.Label == null)
            {
                return;
            }

            String oldLabel = e.Node.Text;
            String newLabel = e.Label;

            bool labelIsLegal = true;

            if(!DeviceFilterEditorDialog.NewLabelIsLegal(
                _designer.UnderlyingControl.Site,
                _appliedFiltersList,
                oldLabel,
                newLabel,
                SR.GetString(SR.AppliedDeviceFiltersDialog_Title)
            )) {
                labelIsLegal = false;
            }
            else if(IsDefaultFilter(newLabel))
            {
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.AppliedDeviceFiltersDialog_Title),
                    SR.GetString(SR.DeviceFilterEditorDialog_IllegalDefaultName)
                );
                labelIsLegal = false;
            }
            
            if(!labelIsLegal)
            {
                e.CancelEdit = true;
                return;
            }

            ((ChoiceTreeNode)e.Node).Name = newLabel;
            EnsureDefaultFilterAvailableXorApplied();
            SetDirty(true);
            UpdateUI();
        }

        private void OnAvailableFilterSelected(Object sender, EventArgs e)
        {
            // NOTE: This event handler is registed for both ItemSelected and
            //       TextChanged events of _cbAvailableFilters.
            UpdateUI();
        }
        
        private void OnAppliedFilterSelected(Object sender, TreeViewEventArgs e)
        {
            UpdateUI();
        }
        
        private void OnEditFilters(Object sender, EventArgs e)
        {
            if(!ValidateAppliedFilters())
            {
                return;
            }
            DeviceFilterEditorDialog dialog = null;

            try
            {
                try
                {
                    dialog = new DeviceFilterEditorDialog(
                        _designer.UnderlyingControl.Site,
                        _webConfig
                        );
                }
                catch (TargetInvocationException ex)
                {
                    throw ex.InnerException;
                }
            }
            catch (CheckoutException ex)
            {
                if (ex == CheckoutException.Canceled)
                {
                    return;
                }
                throw;
            }
            catch (FileLoadException)
            {
                // This is how the constructor tells us it failed to read
                // web.config.
                return;
            }
            
            if(AvailableFilterIsSelected)
            {
                dialog.SelectFilterByName(_cbAvailableFilters.Text);
            }
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                Cursor oldCursor = null;
                try
                {
                    oldCursor = this.Cursor;
                    this.Cursor = Cursors.WaitCursor;

                    // Fix for # 4667
                    // if (_currentDeviceSpecificID != null)
                    //{
                    LoadAvailableFilters();
                    //}
                    SaveChoices();
                    SetDirty(false);
                }
                finally
                {
                    this.Cursor = oldCursor;
                }
            }
        }

        private void OnApplyFilter(Object sender, EventArgs e)
        {
            DeviceFilterNode filter = (DeviceFilterNode) _cbAvailableFilters.SelectedItem;
            if(filter == null)
            {
                String name = _cbAvailableFilters.Text;
                Debug.Assert(
                    ((name != null) && (name.Length > 0)),
                    "Should not be trying to apply a filter with none selected. "
                    + "Missed a call to UpdateUI()?"
                );

                // If the user typed the name of a filter which exists in their
                // web.config, we need to find the original rather than create
                // a new external filter.
                filter = FindAvailableFilter(name);
                if(filter == null)
                {
                    /* Removed for DCR 4240
                    if (!DesignerUtility.IsValidName(name))
                    {
                        GenericUI.ShowWarningMessage(
                            SR.GetString(SR.AppliedDeviceFiltersDialog_Title),
                            SR.GetString(
                                SR.AppliedDeviceFiltersDialog_InvalidFilterName,
                                _cbAvailableFilters.Text
                            )
                        );
                        return;
                    }
                    */

                    filter = CreateExternalFilter(_cbAvailableFilters.Text);
                }
            }
            ChoiceTreeNode choice = new ChoiceTreeNode(
                filter,
                _designer
            );
            if(IsDefaultFilter(filter.Name))
            {
                if(DefaultFilterIsApplied)
                {
                    // Do not allow user to apply default filter if already
                    // been applied.
                    GenericUI.ShowWarningMessage(
                        SR.GetString(SR.AppliedDeviceFiltersDialog_Title),
                        SR.GetString(SR.AppliedDeviceFiltersDialog_DefaultFilterAlreadyApplied)
                    );
                }
                else
                {
                    // Add the default filter to the end of the list and
                    // remove it from list of available filters.
                    _appliedFiltersList.TvList.Nodes.Add(choice);
                    RemoveAvailableFilter(filter);
                }
            }
            else
            {
                // All other filters are added to the beginning
                _appliedFiltersList.TvList.Nodes.Insert(0, choice);
            }
            SetDirty(true);
            UpdateUI();
        }

        private void OnAppliedFiltersReordered(Object sender, EventArgs e)
        {
            SetDirty(true);
        }

        private void OnRemove(Object sender, EventArgs e)
        {
            ChoiceTreeNode choice = (ChoiceTreeNode) _appliedFiltersList.TvList.SelectedNode;
            if(ChoiceHasContent(choice.RuntimeChoice))
            {
                if(!GenericUI.ConfirmYesNo(
                    SR.GetString(SR.AppliedDeviceFiltersDialog_Title),
                    SR.GetString(
                        SR.AppliedDeviceFiltersDialog_AssociatedItemsWillBeLost
                    )
                )) {
                    return;
                }
            }
            _appliedFiltersList.TvList.Nodes.Remove(_appliedFiltersList.TvList.SelectedNode);

            // If it was the default filter, and it a duplicate is not still
            // still applied (error in HTML view), return it to the list of
            // available filters.
            if(IsDefaultFilter(choice.Name))
            {
                EnsureDefaultFilterAvailableXorApplied();
            }
            _appliedFiltersList.UpdateButtonsEnabling();
            SetDirty(true);
            UpdateUI();
        }
                
        private void OnOK(Object sender, EventArgs e)
        {
            if(!ValidateAppliedFilters())
            {
                return;
            }
            SaveChoices();
            Close();
            DialogResult = DialogResult.OK;
        }
        
        private void OnCancel(Object sender, EventArgs e)
        {
            Close();
            DialogResult = DialogResult.Cancel;
        }
        
        private void OnHelp(Object sender, EventArgs e)
        {
            ShowHelpTopic();
        }
        
        private void OnHelpRequested(Object Control, HelpEventArgs hevent)
        {
            ShowHelpTopic();
            hevent.Handled = true;
        }


        ////////////////////////////////////////////////////////////////////////
        //  End Event Handling
        ////////////////////////////////////////////////////////////////////////
        
        ////////////////////////////////////////////////////////////////////////
        //  Begin IRefreshableDeviceSpecificEditor Implementation
        ////////////////////////////////////////////////////////////////////////
        
        bool IRefreshableDeviceSpecificEditor.RequestRefresh()
        {
            return ValidateAppliedFilters();
        }
        
        void IRefreshableDeviceSpecificEditor.Refresh(
            String deviceSpecificID,
            DeviceSpecific deviceSpecific
        ) {
            if (_currentDeviceSpecificID != null)
            {
                CacheCurrentState();
            }
            if(!RestoreState(deviceSpecificID))
            {
                // If we could not restore the state, we have not edited
                // this DeviceSpecific yet and need to load choices.
                LoadChoices(deviceSpecific);
            }
            UpdateUI();
        }

        void IRefreshableDeviceSpecificEditor.UnderlyingObjectsChanged()
        {
            SaveChoices();
            SetDirty(false);
        }

        private bool InExternalCacheEditMode
        {
            get
            {
                return _cacheBuffer != null;
            }
        }
        
        private IDictionary _cacheBuffer = null;
        
        void IRefreshableDeviceSpecificEditor.BeginExternalDeviceSpecificEdit()
        {
            Debug.Assert(!InExternalCacheEditMode,
                "Call to BeginExternalDeviceSpecificEdit() while already in external "
                + "cache edit mode.");
            if(_currentDeviceSpecificID != null)
            {
                CacheCurrentState();
                _currentDeviceSpecificID = null;
            }
            _cacheBuffer = new HybridDictionary(
                true /* make case-insensitive*/ );
            foreach(DictionaryEntry entry in _cachedDeviceSpecifics)
            {
                _cacheBuffer.Add(entry.Key, entry.Value);
            }
        }
        
        void IRefreshableDeviceSpecificEditor.EndExternalDeviceSpecificEdit(
            bool commitChanges)
        {
            Debug.Assert(InExternalCacheEditMode,
                "Call to EndExternalDeviceSpecificEdit() while not in external "
                + "cache edit mode.");
            if(commitChanges)
            {
                _cachedDeviceSpecifics = _cacheBuffer;
            }
            _cacheBuffer = null;
        }
        
        void IRefreshableDeviceSpecificEditor.DeviceSpecificRenamed(
            String oldDeviceSpecificID, String newDeviceSpecificID)
        {
            Debug.Assert(InExternalCacheEditMode,
                "Call to DeviceSpecificRenamed() while not in external "
                + "cache edit mode.");
            Object value = _cacheBuffer[oldDeviceSpecificID];
            if(value != null)
            {
                _cacheBuffer.Remove(oldDeviceSpecificID);
                _cacheBuffer.Add(newDeviceSpecificID, value);
            }
        }
        
        void IRefreshableDeviceSpecificEditor.DeviceSpecificDeleted(
            String deviceSpecificID)
        {
            Debug.Assert(InExternalCacheEditMode,
                "Call to DeviceSpecificDeleted() while not in external "
                + "cache edit mode.");
            _cacheBuffer.Remove(deviceSpecificID);
        }

        ////////////////////////////////////////////////////////////////////////
        //  End IRefeshableComponentEditorPage Implementation
        ////////////////////////////////////////////////////////////////////////
    }

    ////////////////////////////////////////////////////////////////////////////
    //  Begin Internal Class
    ////////////////////////////////////////////////////////////////////////////

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class AppliedFiltersCachedState : DeviceSpecificDialogCachedState
    {
        private TreeNode[] _cachedTreeView = null;
        
        internal AppliedFiltersCachedState(
            TreeView treeView
        ) {
            _cachedTreeView = new TreeNode[treeView.Nodes.Count];
            treeView.Nodes.CopyTo(_cachedTreeView, 0);
        }

        internal TreeNode[] AppliedFilters
        {
            get
            {
                return _cachedTreeView;
            }
        }
        
        internal void Restore(
            TreeView treeView
        ) {
            TreeNode selectedNode = treeView.SelectedNode;
            treeView.Nodes.Clear();
            treeView.Nodes.AddRange(_cachedTreeView);
            if(selectedNode != null)
            {
                int index = treeView.Nodes.IndexOf(selectedNode);
                if(index >= 0)
                {
                    treeView.SelectedNode = treeView.Nodes[index];
                }
            }
        }

        internal bool ChoiceExistsInTreeView(DeviceFilterNode filter)
        {
            foreach(ChoiceTreeNode appliedFilter in _cachedTreeView)
            {
                if(appliedFilter.Name == filter.Name)
                {
                    return true;
                }
            }
            return false;
        }
        
        internal void SaveChoicesFromTreeView(
            IDeviceSpecificDesigner designer,
            String deviceSpecificID
        ) {
            SaveChoices(designer, deviceSpecificID, _cachedTreeView);
        }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    //  End Internal Class
    ////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////
    //  Begin Internal Class
    ////////////////////////////////////////////////////////////////////////////

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class ChoiceTreeNode : TreeNode
    {
        private IDeviceSpecificDesigner _designer;
        private ChoicePropertyFilter _choicePropertyFilter = null;
        private DeviceSpecificChoice _runtimeChoice = null;
        private String _filterName;
        private String _argument;
        private bool _includeArgument = false;

        internal ChoiceTreeNode(
            DeviceFilterNode filter,
            IDeviceSpecificDesigner designer
        ) : base() 
        {
            Name = filter.Name;
            _designer = designer;
            _runtimeChoice = new DeviceSpecificChoice();
            _runtimeChoice.Filter = filter.Name;

            if(
                // This looks like circular reasoning, but the designer is a
                // IDeviceSpecificDesigner and we are interested in the
                // type of the designer's parent control.
                Adapters.DesignerAdapterUtil.ControlDesigner(designer.UnderlyingControl)
                is MobileTemplatedControlDesigner
            ) 
            {
                _runtimeChoice.Xmlns = SR.GetString(SR.MarkupSchema_HTML32);
            }
        }

        internal ChoiceTreeNode(
            DeviceFilterNode filter,
            DeviceSpecificChoice runtimeChoice,
            IDeviceSpecificDesigner designer
        ) : base()
        {
            _designer = designer;
            _runtimeChoice = runtimeChoice;
            Name = _runtimeChoice.Filter;
            Argument = _runtimeChoice.Argument;
        }
        
        internal bool IncludeArgument
        {
            get
            {
                return _includeArgument;
            }

            set
            {
                _includeArgument = value;
            }
        }
        
        [Obsolete]
        internal new String Text
        {
            get
            {
                return Name;
            }

            set
            {
                Name = value;
            }
        }
        
        internal String Name
        {
            get
            {
                return _filterName;
            }

            set
            {
                Debug.Assert(value != null);
                _filterName = value;
                base.Text = ToString();
            }
        }

        internal String Argument
        {
            get
            {
                return _argument;
            }

            set
            {
                _argument = value;
            }
        }

        internal ChoicePropertyFilter Choice
        {
            get
            {
                if(_choicePropertyFilter == null)
                {
                    _choicePropertyFilter = new ChoicePropertyFilter(
                        _runtimeChoice,
                        _designer,
                        _designer.UnderlyingControl.Site                        
                    );
                }
                return _choicePropertyFilter;
            }
        }

        internal void CommitChanges()
        {
            RuntimeChoice.Filter = _filterName;
            RuntimeChoice.Argument = _argument;
        }
        
        internal DeviceSpecificChoice RuntimeChoice
        {
            get
            {
                Debug.Assert(
                    (_choicePropertyFilter == null)
                    || (_runtimeChoice == _choicePropertyFilter.RuntimeChoice),
                    "Local runtime choice object out of sync."
                );
                return _runtimeChoice;
            }
        }

        // This done so that these TreeNodes will display correctly when
        // inserted in a ComboBox.
        public override String ToString()
        {
            StringBuilder name = new StringBuilder(_filterName);
            
            if(name == null || name.Length == 0)
            {
                name = new StringBuilder(
                    SR.GetString(SR.DeviceFilter_DefaultChoice)
                );
            }
            else if(_includeArgument)
            {
                name.Append( " (\"" + _runtimeChoice.Argument + "\")" );
            }
            return name.ToString();
        }
    }
    
    ////////////////////////////////////////////////////////////////////////////
    //  End Internal Class
    ////////////////////////////////////////////////////////////////////////////
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\commandcollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls 
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Web.UI.WebControls;
    using System.Runtime.Serialization.Formatters;

    using ObjectList = System.Web.UI.MobileControls.ObjectList;

    /// <summary>
    ///    <para>
    ///       The editor for column collections.
    ///    </para>
    /// </summary>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class CommandCollectionEditor : UITypeEditor 
    {
        /// <summary>
        ///    <para>
        ///       Edits the value specified.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the context of the value to edit.
        /// </param>
        /// <param name=' provider'>
        ///    An <see cref='System.IServiceProvider'/> .
        /// </param>
        /// <param name=' value'>
        ///    The object to edit.
        /// </param>
        /// <returns>
        ///    <para>
        ///       The updated value.
        ///    </para>
        /// </returns>
        public override Object EditValue(ITypeDescriptorContext context, IServiceProvider provider, Object value) 
        {
            IDesignerHost designerHost = (IDesignerHost)context.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Did not get DesignerHost service.");

            Debug.Assert(context.Instance is ObjectList, "Expected objectlist");
            ObjectList _objectList = (ObjectList)context.Instance;

            ObjectListDesigner _designer = (ObjectListDesigner)designerHost.GetDesigner(_objectList);
            Debug.Assert(_designer != null, "Did not get designer for component");

            _designer.InvokePropertyBuilder(ObjectListComponentEditor.IDX_COMMANDS);
            return value;
        }

        /// <summary>
        ///    <para>
        ///       Gets the edit style.
        ///    </para>
        /// </summary>
        /// <param name='context'>
        ///    An <see cref='System.ComponentModel.ITypeDescriptorContext'/> that specifies the associated context.
        /// </param>
        /// <returns>
        ///    <para>
        ///       A <see cref='System.Drawing.Design.UITypeEditorEditStyle'/> that represents the edit style.
        ///    </para>
        /// </returns>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) 
        {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\designercapabilities.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerCapabilities.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System.Collections;
    using System.Diagnostics;
    using System.Web.Mobile;
    using System.Web.UI;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DesignerCapabilities : MobileCapabilities
    {
        private static IDictionary _items = null;
        private readonly static DesignerCapabilities _staticInstance = new DesignerCapabilities();

        static DesignerCapabilities()
        {
            _items = new Hashtable();

            // HTTPBrowserCapabilities Properties
            _items["type"] = "IE5";
            _items["browser"] = "IE";
            _items["version"] = "5.5";
            _items["majorversion"] = "5";
            _items["minorversion"] = "5";
            _items["platform"] = "Win32";
            _items["tagwriter"] = "System.Web.UI.HtmlTextWriter";
            _items["beta"] = "false";
            _items["crawler"] = "false";
            _items["aol"] = "false";
            _items["win16"] = "false";
            _items["win32"] = "true";
            _items["frames"] = "true";
            _items["tables"] = "true";
            _items["cookies"] = "true";
            _items["vbscript"] = "false";
            _items["javascript"] = "true";
            _items["javaapplets"] = "false";
            _items["activeXControls"] = "false";
            _items["backgroundSounds"] = "false";
            _items["cdf"] = "false";

            // Designer Capabilities Properties
            _items["defaultCharacterWidth"] = "8";
            _items["defaultCharacterHeight"] = "12";
            _items["mobileDeviceManufacturer"] = "Unknown";
            _items["mobileDeviceModel"] = "Unknown";
            _items["gatewayVersion"] = "None";
            _items["gatewayMajorVersion"] = "0";
            _items["gatewayMinorVersion"] = "0";
            _items["preferredRenderingType"] = "html32";
            _items["preferredRenderingMime"] = "text/html";
            _items["preferredImageMime"] = "image/gif";
            _items["preferredLanguage"] = "";
            _items["screenCharactersWidth"] = "80";
            _items["screenCharactersHeight"] = "40";
            _items["screenPixelsWidth"] = "640";
            _items["screenPixelsHeight"] = "480";
            _items["screenBitDepth"] = "8";
            _items["isColor"] = "true";
            _items["inputType"] = "";
            _items["numberOfSoftkeys"] = "0";
            _items["maximumSoftkeyLabelLength"] = "8";
            _items["canInitiateVoiceCall"] = "false";
            _items["canSendMail"] = "true";
            _items["hasBackButton"] = "true";
            _items["rendersWmlDoAcceptsInline"] = "true";
            _items["rendersWmlSelectsAsMenuCards"] = "false";
            _items["rendersBreaksAfterWmlAnchor"] = "false";
            _items["rendersBreaksAfterWmlInput"] = "false";
            _items["rendersBreakBeforeWmlSelectAndInput"] = "false";
            _items["requiresPhoneNumbersAsPlainText"] = "false";
            _items["requiresUrlEncodedPostfieldValues"] = "false";
            _items["requiredMetaTagNameValue"] = "";
            _items["rendersBreaksAfterHtmlLists"] = "true";
            _items["requiresUniqueHtmlCheckboxNames"] = "false";
            _items["requiresUniqueHtmlInputNames"] = "false";
            _items["requiresAttributeColonSubstitution"] = "false";
            _items["requiresHtmlAdaptiveErrorReporting"] = "false";
            _items["requiresContentTypeMetaTag"] = "false";
            _items["requiresDBCSCharacter"] = "false";
            _items["supportsCss"] = "true";
            _items["hidesRightAlignedMultiselectScrollbars"]="false";
            _items["isMobileDevice"] = "false";
            _items["canRenderInputAndSelectElementsTogether"] = "true";
            _items["canRenderAfterInputOrSelectElement"] = "true";
            _items["canRenderOneventAndPrevElementsTogether"] = "true";
            _items["canRenderSetvarZeroWithMultiSelectionList"] = "true";
            _items["canRenderPostBackCards"] = "true";
            _items["canRenderMixedSelects"] = "true";
            _items["canCombineFormsInDeck"] = "true";
            _items["supportsImageSubmit"] = "true";
            _items["requiresUniqueFilePathSuffix"] = "false";
            _items["supportsSelectMultiple"] = "true";
            _items["supportsBold"] = "true";
            _items["supportsItalic"] = "true";
            _items["supportsFontSize"] = "true";
            _items["supportsFontName"] = "true";
            _items["supportsFontColor"] = "true";
            _items["supportsBodyColor"] = "true";
            _items["supportsDivAlign"] = "true";
            _items["supportsDivNoWrap"] = "true";
            _items["requiresOutputOptimization"] = "false";
            _items["supportsAccesskeyAttribute"] = "false";
            _items["supportsInputIStyle"] = "false";
            _items["supportsInputMode"] = "false";
            _items["supportsIModeSymbols"] = "false";
            _items["supportsJPhoneSymbols"] = "false";
            _items["supportsJPhoneMultiMediaAttributes"] = "false";
            _items["maximumRenderedPageSize"] = "2000";
            _items["requiresSpecialViewStateEncoding"] = "false";
            _items["requiresNoBreakInFormatting"] = "false";
            _items["supportsQueryStringInFormAction"] = "true";
            _items["supportsCacheControlMetaTag"] = "true";
            _items["supportsUncheck"] = "true";
            _items["canRenderEmptySelects"] = "true";
            _items["supportsRedirectWithCookie"] = "true";
            _items["supportsEmptyStringInCookieValue"] = "true";
            _items["requiresNoSoftkeyLabels"] = "false";
            _items["defaultSubmitButtonLimit"] = "1";
        }

        public override String this[String key]
        {
            get
            {
                Object obj = _items[key];
                Debug.Assert(obj != null, 
                    String.Format("property {0} not defined in DesignerCapabilities", key));
                Debug.Assert(obj is String,
                    String.Format("property {0} invalid type defined", key));

                return obj as String;
            }
        }

        internal static DesignerCapabilities Instance
        {
            get
            {
                return _staticInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\commanddesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="CommandDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.Web.UI.MobileControls.Adapters;
    using System.Web.UI.Design.MobileControls.Adapters;

    /// <summary>
    ///    <para>
    ///       The designer for the <see cref='System.Web.UI.MobileControls.Command'/>
    ///       mobile control.
    ///    </para>
    /// </summary>
    /// <seealso cref='System.Web.UI.MobileControls.Command'/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class CommandDesigner : MobileControlDesigner
    {
        private System.Web.UI.MobileControls.Command _command;

        /// <summary>
        ///    <para>
        ///       Initializes the designer with the component for design.
        ///    </para>
        /// </summary>
        /// <param name='component'>
        ///    The control element for design.
        /// </param>
        /// <remarks>
        ///    <para>
        ///       This is called by the designer host to establish the component for
        ///       design.
        ///    </para>
        /// </remarks>
        /// <seealso cref='System.ComponentModel.Design.IDesigner'/>
        public override void Initialize(IComponent component)
        {
            Debug.Assert(component is System.Web.UI.MobileControls.Command,
                         "CommandDesigner.Initialize - Invalid Command Control");
            _command = (System.Web.UI.MobileControls.Command) component;
            base.Initialize(component);
        }

        /// <summary>
        ///    <para>
        ///       Returns the design-time HTML of the <see cref='System.Web.UI.MobileControls.Call'/>
        ///       mobile control
        ///    </para>
        /// </summary>
        /// <returns>
        ///    <para>
        ///       The HTML of the control.
        ///    </para>
        /// </returns>
        /// <seealso cref='System.Web.UI.MobileControls.Call'/>
        protected override String GetDesignTimeNormalHtml()
        {
            Debug.Assert(null != _command.Text);

            DesignerTextWriter tw;
            Control[] children = null;

            String originalText = _command.Text;
            bool blankText = (originalText.Trim().Length == 0);
            bool hasControls = _command.HasControls();

            if (blankText)
            {
                if (hasControls) 
                {
                    children = new Control[_command.Controls.Count];
                    _command.Controls.CopyTo(children, 0);
                }
                _command.Text = "[" + _command.ID + "]";
            }
            try
            {
                tw = new DesignerTextWriter();
                _command.Adapter.Render(tw);
            }
            finally
            {
                if (blankText)
                {
                    _command.Text = originalText;
                    if (hasControls) 
                    {
                        foreach (Control c in children) 
                        {
                            _command.Controls.Add(c);
                        }
                    }
                }
            }

            return tw.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\containmentstatus.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContainmentStatus.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;

    internal enum ContainmentStatus
    {
        /// <summary>
        ///    Containment status is unknown. ie. other than any of the next 4 cases.
        /// </summary>
        Unknown = 0,

        /// <summary>
        ///    Parent control is a Form
        /// </summary>
        InForm = 1,

        /// <summary>
        ///    Parent control is a Panel
        /// </summary>
        InPanel = 2,

        /// <summary>
        ///    Parent control is templateable control in template mode.
        /// </summary>
        InTemplateFrame = 3,

        /// <summary>
        ///    Parent control is Page
        /// </summary>
        AtTopLevel = 4,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\constants.cs ===
//------------------------------------------------------------------------------
// <copyright file="Constants.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class Constants : System.Web.UI.MobileControls.Constants
    {
        // You don't want to instantiate this class.
        private Constants() 
        {
        }

        static Constants()
        {
            ControlSizeAtToplevelInNonErrorMode = ControlMaxsizeAtToplevel.ToString() + "px";
        }

        internal static readonly int ControlMaxsizeAtToplevel               = 297;
        internal static readonly String ControlSizeAtToplevelInNonErrorMode;
        internal static readonly String ControlSizeAtToplevelInErrormode    = "300px";
        internal static readonly String ControlSizeInContainer              = "100%";

        internal static readonly String ReflectPropertyDescriptorTypeFullName = 
            "System.ComponentModel.ReflectPropertyDescriptor";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\devicespecificdialogcachedstate.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceSpecificDialogCachedState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;

    using System.Web.UI.MobileControls;

    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal class DeviceSpecificDialogCachedState : ICloneable
    {
        protected void SaveChoices(
            IDeviceSpecificDesigner designer,
            String deviceSpecificID,
            ICollection choices
        ) {
            DeviceSpecific deviceSpecific;
            if (!designer.GetDeviceSpecific(deviceSpecificID, out deviceSpecific))
            {
                return;
            }

            if(choices.Count == 0)
            {
                designer.SetDeviceSpecific(deviceSpecificID, null);
                return;
            }
            
            if (deviceSpecific == null)
            {
                deviceSpecific = new DeviceSpecific();
            }
            else
            {
                deviceSpecific.Choices.Clear();
            }
            foreach (ChoiceTreeNode node in choices)
            {
                node.CommitChanges();
                DeviceSpecificChoice choice = node.Choice.RuntimeChoice;
                deviceSpecific.Choices.Add(choice);
            }
            designer.SetDeviceSpecific(deviceSpecificID, deviceSpecific);
        }

        /// <summary>
        ///     Perform shallow copy of state.  Cached contents will still
        ///     point to the same instances.
        /// </summary>
        public Object Clone()
        {
            return MemberwiseClone();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\mit\system\web\ui\mobilecontrols\design\devicefiltereditordialog.cs ===
//------------------------------------------------------------------------------
// <copyright file="DeviceFilterEditorDialog.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design.MobileControls
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.Design.Util;
    using System.Web.UI.MobileControls;
    using System.Windows.Forms;
    using System.Web.UI.Design.MobileControls.Util;

    using Control = System.Windows.Forms.Control;
    using Label = System.Windows.Forms.Label;
    using TextBox = System.Windows.Forms.TextBox;
    using DeviceFilterMode = Util.DeviceFilterNode.DeviceFilterMode;

    /// <summary>
    ///   The General page for the TextView control.
    /// </summary>
    /// <internalonly/>
    [
        System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand,
        Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
    ]
    internal sealed class DeviceFilterEditorDialog : System.Windows.Forms.Form
    {
        /// <summary>
        ///   Initializes the UI of the form.
        /// </summary>
        
        private EditableTreeList        _filterList = null;
        private DefaultDialogButtons    _dialogButtons = null;
        private WebConfigManager        _webConfig = null;
        private ISite                   _site = null;

        private static String _nameOfDefaultFilter =
            SR.GetString(SR.DeviceFilter_DefaultChoice);

        private System.Windows.Forms.Label _lblCompare;
        private System.Windows.Forms.ComboBox _cbCompare;
        private System.Windows.Forms.Label _lblArgument;
        private System.Windows.Forms.TextBox _txtArgument;
        private System.Windows.Forms.Panel _pnlCompare;
        private System.Windows.Forms.Label _lblType;
        private System.Windows.Forms.Label _lblMethod;
        private System.Windows.Forms.TextBox _txtMethod;
        private System.Windows.Forms.TextBox _txtType;
        private System.Windows.Forms.Panel _pnlDelegate;
        private System.Windows.Forms.RadioButton _rbDelegate;
        private System.Windows.Forms.RadioButton _rbCompare;
        private System.Windows.Forms.Panel _pnlRight;
        private System.Windows.Forms.Panel _pnlMain;
        private GroupLabel _glAttributes;
        private GroupLabel _glType;
        private HeaderPanel _pnlHeader;
        private HeaderLabel _lblHeader;

        internal DeviceFilterEditorDialog(ISite site)
            : this(site, new WebConfigManager(site))
        {
        }
        
        // NOTE: A FileLoadException is thrown if an error occurs while reading
        //       web.config.
        internal DeviceFilterEditorDialog(ISite site, WebConfigManager webConfig)
        {
            InitializeComponent();

            _lblArgument.Text = SR.GetString(SR.DeviceFilterEditorDialog_Argument);
            _glAttributes.Text = SR.GetString(SR.DeviceFilterEditorDialog_Attributes);
            _lblMethod.Text = SR.GetString(SR.DeviceFilterEditorDialog_Method);
            _glType.Text = SR.GetString(SR.DeviceFilterEditorDialog_TypeGl);
            _rbCompare.Text = SR.GetString(SR.DeviceFilterEditorDialog_Equality);
            _lblCompare.Text = SR.GetString(SR.DeviceFilterEditorDialog_Compare);
            _rbDelegate.Text = SR.GetString(SR.DeviceFilterEditorDialog_Evaluator);
            _lblType.Text = SR.GetString(SR.DeviceFilterEditorDialog_TypeTxt);
            _lblHeader.Text = SR.GetString(SR.DeviceFilterEditorDialog_Header);
            this.Text = SR.GetString(SR.DeviceFilterEditorDialog_Title);

            int tabOffset = 0;
            this._pnlMain.TabIndex = tabOffset++;
            this._filterList.TabIndex = tabOffset++;
            this._pnlRight.TabIndex = tabOffset++;
            this._glType.TabIndex = tabOffset++;
            this._rbCompare.TabIndex = tabOffset++;
            this._rbDelegate.TabIndex = tabOffset++;
            this._glAttributes.TabIndex = tabOffset++;
            this._pnlCompare.TabIndex = tabOffset++;
            this._pnlDelegate.TabIndex = tabOffset++;
            this._lblCompare.TabIndex = tabOffset++;
            this._cbCompare.TabIndex = tabOffset++;
            this._lblType.TabIndex = tabOffset++;
            this._txtType.TabIndex = tabOffset++;
            this._lblArgument.TabIndex = tabOffset++;
            this._txtArgument.TabIndex = tabOffset++;
            this._lblMethod.TabIndex = tabOffset++;
            this._txtMethod.TabIndex = tabOffset++;
            this._dialogButtons.TabIndex = tabOffset++;
            
            _webConfig = webConfig;
            this._site = site;
            GenericUI.InitDialog(this, site);

            _filterList.LblTitle.Text = SR.GetString(SR.DeviceFilterEditorDialog_DeviceFilters);
            _filterList.BtnAdd.Text = SR.GetString(SR.DeviceFilterEditorDialog_NewDeviceFilter);

            // Attempt to load Device Filters
            ArrayList filters = null;
            try 
            {
                filters = _webConfig.ReadDeviceFilters();
            }
            catch (FileNotFoundException e)
            {
                GenericUI.ShowWarningMessage(
                    SR.GetString(SR.DeviceFilterEditorDialog_Title),
                    SR.GetString(SR.DeviceFilterEditorDialog_WebConfigMissingOnOpen)
                );
                throw new FileLoadException(
                    SR.GetString(SR.WebConfig_FileLoadException, e)
                );
            }
            catch (Exception e)
            {
                if (e.Message.Equals(SR.GetString(SR.DeviceFilterEditorDialog_DuplicateNames)))
                {
                    GenericUI.ShowWarningMessage(
                        SR.GetString(SR.DeviceFilterEditorDialog_Title),
                        SR.GetString(SR.DeviceFilterEditorDialog_DuplicateNames)
                    );
                }
                else
                {
                    GenericUI.ShowWarningMessage(
                        SR.GetString(SR.DeviceFilterEditorDialog_Title),
                        SR.GetString(
                            SR.DeviceFilterEditorDialog_WebConfigParsingError,
                            e.Message
                        )
                    );
                }
                throw new FileLoadException(
                    SR.GetString(SR.WebConfig_FileLoadException, e)
                );
            }

            // Make sure web.config is checked out before we make changes.
            _webConfig.EnsureWebConfigCheckedOut();

            // Insert the Device Filters into the List UI
            foreach(DeviceFilterNode filter in filters)
            {
                DeviceFilterTreeNode node = new DeviceFilterTreeNode(filter);
                _filterList.TvList.Nodes.Add(node);
            }

            // Make sure all filters have a name...
            // NOTE: Do not combine with the above loop or GetUniqueLabel()
            //       will not necessarily be unique.  It could be done if
            //       we wrote another implementation of GetUniqueLabel()
            //       that compared against filters [ArrayList returned
            //       from ReadDeviceFilters()].
            foreach(DeviceFilterTreeNode node in _filterList.TvList.Nodes)
            {
                if(node.Text == null || node.Text == "")
                {
                    node.Text = _filterList.GetUniqueLabel(
                        SR.GetString(SR.DeviceFilterNode_DefaultFilterName)
                    );
                }
            }
                
            // Initialize the UI
            _rbCompare.Click += new EventHandler(OnClickCompareRadioButton);
            _rbDelegate.Click += new EventHandler(OnClickDelegateRadioButton);
            _cbCompare.TextChanged += new EventHandler(OnTextChanged);
            _cbCompare.SelectedIndexChanged += new EventHandler(OnTextChanged);
            _txtArgument.TextChanged += new EventHandler(OnTextChanged);
            _txtType.TextChanged += new EventHandler(OnTextChanged);
            _txtMethod.TextChanged += new EventHandler(OnTextChanged);
            _filterList.TvList.AfterLabelEdit += new NodeLabelEditEventHandler(OnAfterLabelEdit);
            _filterList.TvList.AfterSelect += new TreeViewEventHandler(OnFilterSelected);
            _filterList.BtnAdd.Click += new EventHandler(OnClickAddButton);
            _filterList.BtnRemove.Click += new EventHandler(OnClickRemoveButton);
            _filterList.TvList.SelectedNode = null;

            LoadAvailableCapabilities();
            UpdateButtonsEnabling();

            _dialogButtons.CmdOK.Click += new EventHandler(OnClickOK);
            _dialogButtons.CmdCancel.Click += new EventHandler(OnClickCancel);
            _dialogButtons.CmdHelp.Click += new EventHandler(OnClickHelp);
        }

        private void InitializeComponent()
        {
            this._pnlHeader = new HeaderPanel();
            this._lblHeader = new HeaderLabel();
            this._glAttributes = new GroupLabel();
            this._glType = new GroupLabel();
            this._txtType = new System.Windows.Forms.TextBox();
            this._pnlMain = new System.Windows.Forms.Panel();
            this._filterList = new EditableTreeList();
            this._rbCompare = new System.Windows.Forms.RadioButton();
            this._lblCompare = new System.Windows.Forms.Label();
            this._dialogButtons = new DefaultDialogButtons();
            this._lblType = new System.Windows.Forms.Label();
            this._txtMethod = new System.Windows.Forms.TextBox();
            this._txtArgument = new System.Windows.Forms.TextBox();
            this._pnlRight = new System.Windows.Forms.Panel();
            this._lblMethod = new System.Windows.Forms.Label();
            this._rbDelegate = new System.Windows.Forms.RadioButton();
            this._pnlCompare = new System.Windows.Forms.Panel();
            this._cbCompare = new System.Windows.Forms.ComboBox();
            this._lblArgument = new System.Windows.Forms.Label();
            this._pnlDelegate = new System.Windows.Forms.Panel();
            this._txtType.Location = new System.Drawing.Point(0, 20);
            this._txtType.Size = new System.Drawing.Size(211, 20);

            this._lblHeader.Location = new System.Drawing.Point(0, 0);
            this._lblHeader.Size = new System.Drawing.Size(434, 16);
            this._lblHeader.Anchor = (System.Windows.Forms.AnchorStyles.Top
                | System.Windows.Forms.AnchorStyles.Left);
            this._pnlHeader.Controls.AddRange(new System.Windows.Forms.Control[] {
                this._lblHeader
            });
            this._pnlHeader.Location = new System.Drawing.Point(6, 5);
            this._pnlHeader.Size = new System.Drawing.Size(434, 16);
            this._pnlHeader.Anchor = (System.Windows.Forms.AnchorStyles.Top
                | System.Windows.Forms.AnchorStyles.Left);
            this._pnlMain.Controls.AddRange(new System.Windows.Forms.Control[] {this._dialogButtons,
                                                                                  this._pnlRight,
                                                         