                               ;C03

   cmp   mt_deviceBPB.csect_track,0 ;patch 1/16/86 for 3.2 diskcopy
   je    far_ct_old                ;

   cmp   mt_deviceBPB.chead,0      ;cannot belive the info from dos
   je    far_ct_old                ;sanity check for divide by 0.

   jmp   SHORT Over_Ct_Jump                                               ;D01
                                                                          ;D01
FAR_CT_OLD:                                                               ;D01
   jmp   ct_old                    ;Do a far jump to 'ct_old'             ;D01
FAR_CT_FATAL:                                                             ;C11
   jmp   ct_fatal                  ;Do a far jump to 'ct_fatal'           ;C11
                                                                          ;D01
OVER_CT_JUMP:                                                             ;D01
;C08   MOV   AX, MS_deviceBPB.CTOTSECT ;
   MOV   AX, MT_deviceBPB.CTOTSECT ;                                      ;C08
   CWD                             ;CONVERT IT TO A DOUBLE WORD
   OR    AX,AX
   JNZ   NOT_ENHANCED2
;C08   MOV   AX, WORD PTR MS_deviceBPB.BIG_TOT_SECT
;C08   MOV   DX, WORD PTR MS_deviceBPB.BIG_TOT_SECT+2
   MOV   AX, WORD PTR MT_deviceBPB.BIG_TOT_SECT                           ;C08
   MOV   DX, WORD PTR MT_deviceBPB.BIG_TOT_SECT+2                         ;C08

NOT_ENHANCED2:
;C08   DIV   MS_deviceBPB.CSECT_TRACK  ;
;C08   MOV   BX,MS_deviceBPB.CHEAD ;(TOTAL SECTORS / # OF TRACKS) / # OF HEADS
   DIV   MT_deviceBPB.CSECT_TRACK  ;                                      ;C08
   MOV   BX,MT_deviceBPB.CHEAD ;(TOTAL SECTORS / # OF TRACKS) / # OF HEADS;C08
   DIV   BX                        ;ENSURE WORD DIVISION
   DEC   AX                        ;DECREASE BY 1 FOR THIS PROGRAM.
   CMP   LAST_TRACK, AX            ;COMPARE WITH THE LAST TRACK OF SOURCE
   JE    CT_SECTOR_TRACK           ;IF SAME, THEN CHECK SECTOR PER TRACK
                                   ;SINCE NOT THE SAME, CONTINUE...

   CMP   MT_deviceBPB.CSECT_TRACK,0FH ;AN012;IS TARGET 15 SEC / TRK?
   JNE   CT_FORMAT                 ;AN012;NO, SOMETHING ELSE...
                                   ;YES, 15 SEC/TRACK, CONTINUE...

   CMP   LAST_TRACK,27H            ;AN012;IS SOURCE ORIGINALLY 40 TRACK?
   JNE   CT_FORMAT                 ;AN012;NO, SOMETHING ELSE...
                                   ;YES, 40 TRACK, CONTINUE...
   JMP   SHORT FAR_CT_FATAL              ;AN012;ABORT THIS, DO NOT MESS UP THE 1.2M
                                   ; WITH NOBLE ATTEMPTS TO FORMAT
CT_SECTOR_TRACK:                   ;
   MOV   AX, MT_deviceBPB.CSECT_TRACK ;
   CMP   END_OF_TRACK, AL          ;
;C03   JNE   CT_FORMAT                 ;
   JE    CT_BYTE_SECTOR            ;Same # of sectors/track, continue      ;C03
   CMP   LAST_TRACK, 4Fh           ;Q: 80 tracks on target AND source?     ;C03
   JNE   CT_FORMAT                 ; N: then not a 1.44M drive, go format  ;C03
   CMP   AL, 12h                   ;Q: 1.44M target?                       ;C03
   JNE   CHECK_35_INCH_PROBLEMS    ; N: Go check if 720k target and 144 src;C03
   CMP   END_OF_TRACK, 0Fh         ;Q: 1.2M source?                        ;C07
   JNE   CHECK_720_SOURCE          ; N: Then go check for a 720K source    ;C07
   JMP   SHORT FAR_CT_FATAL              ; Y: Can't copy 1.2M to 1.44M media     ;C07
                                   ;                                       ;C07
CHECK_720_SOURCE:                  ;                                       ;C07
   CMP   END_OF_TRACK, 09H         ;Q: 720k source? (target is 1.44M)      ;C03
   JE    FAR_CT_FATAL              ; Y: Then don't try to format the 1.44M ;C11
   CMP   END_OF_TRACK, 24H         ;Q: 2.88M source? (target is 1.44M)     ;C11
   JNE   CT_BYTE_SECTOR            ; N: Then continue                      ;C03
   JMP   SHORT FAR_CT_FATAL              ; Y: Then don't make a noble attempt to ;C03
                                   ;    mess with the 1.44M format         ;C03
                                   ;                                       ;C03
CHECK_35_INCH_PROBLEMS:            ;    (target is not 1.44M)              ;C03
                                   ;                                       ;C03
   CMP   AL, 09H                   ;Q: 720k  target?                       ;C03
;C11 JNE   CT_FORMAT               ; N: Don't know anything, go format     ;C11
   JNE   CHECK_288_TARGET          ; N: go check if a 2.88M target         ;C11
   CMP   END_OF_TRACK, 12H         ;Q: 1.44M source? (target is 720k)      ;C03
   JE    FAR_CT_FATAL              ; Y: Then don't format the 720k wrong   ;C11
   CMP   END_OF_TRACK, 24H         ;Q: 2.88M source? (target is 720k)      ;C11
   JNE   CT_BYTE_SECTOR            ; N: ok, continue                       ;C03
   JMP   SHORT FAR_CT_FATAL                  ; Y: Then don't make a noble attempt to ;C03
                                   ;    mess with the 720k  format         ;C03
                                   ;                                       ;C11
CHECK_288_TARGET:                  ;    (target is not 1.44M or 720k)      ;C11
                                   ;                                       ;C11
   CMP   AL, 24H                   ;Q: 2.88M target?                       ;C11
   JNE   CT_FORMAT                 ; N: Don't know anything, go format     ;C11
   CMP   END_OF_TRACK, 12H         ;Q: 1.44M source? (target is 2.88M)     ;C11
   JE    FAR_CT_FATAL              ; Y: Then don't format the 2.88M wrong  ;C11
   CMP   END_OF_TRACK, 09H         ;Q:  720k source? (target is 2.88M)     ;C11
   JNE   CT_BYTE_SECTOR            ; N: ok, continue                       ;C11
   JMP   FAR_CT_FATAL              ; Y: Then don't make a noble attempt to ;C11
                                   ;    mess with the 720k  format         ;C11

CT_BYTE_SECTOR:                    ;
   MOV   AX, MT_deviceBPB.CBYTE_SECT ;
   CMP   AX, bSECTOR_SIZE          ;
   JNE   CT_FORMAT                 ;

CT_HEAD:                           ;
   MOV   AX, MT_deviceBPB.CHEAD    ;
   DEC   AX                        ;
   CMP   AL, NO_OF_SIDES           ;
   JB    CT_FORMAT                 ;IF TARGET SIDE < SOURCE SIDE
                                   ; THEN FORMAT IT.

   JMP   CT_SET_DRV                ;TARGET IS O.K. SET DRIVE PARM
                                   ; AND EXIT

CT_FORMAT:                         ;
   call  TargetMediaSense          ;Use media sensing to determine if target;D01
   jnc   MediaOK                   ;media is large enough, before formatting;D01
   mov   Copy_Status,FATAL                                                  ;D01
   jmp   CT_EXIT                                                            ;D01

MediaOK:                                                                    ;D01
   PRINT MSGNUM_FORMATTING         ;AC000;"Formatting while copying"

   MOV   FORMAT_FLAG, ON           ;
   CALL  FORMAT_ALL                ;FORMAT ALL TRACKS STARTING
                                   ; FROM TRACK_TO_WRITE
   JMP   CT_EXIT                   ;

CT_OLD:                            ;AC011;
   CMP   UKM_ERR,ON                ;AN011;IS THIS HARD ERROR "UNKNOWN MEDIA"?
   JE    CT_FORMAT                 ;AN011; IF SO, GO TRY FORMATTING
                                   ;SAME OLD... ;AGAIN, THIS DOES
                                   ; NOT RECOGNIZE 3.5 MEDIA
   MOV   READ_T_BPB_FAILURE, 1     ;SET THE FLAG
   XOR   BX, BX                    ;
   MOV   BL, TARGET_DRIVE          ;
   MOV   IOCTL_TRACK, 0            ;
   MOV   IOCTL_SECTOR, 8           ;
   MOV   IOCTL_HEAD, 0             ;TRY TO READ HEAD 0, TRACK 0, SECTOR 8
   CALL  READ_A_SECTOR             ;

   JC    CT_FORMAT                 ;ASSUME TARGET MEDIA NOT FORMATTED.

   MOV   IOCTL_SECTOR, 9           ;TRY TO READ SECTOR 9
   CALL  READ_A_SECTOR             ;

   JC    CT_8_SECTOR               ;TARGET IS 8 SECTOR MEDIA

   MOV   IOCTL_SECTOR, 15          ;
   CALL  READ_A_SECTOR             ;

   JC    CT_9_SECTOR               ;TARGET IS 9 SECTOR MEDIA

;CT_15_SECTOR:                          ;TARGET IS 15 SECTOR MEDIA
   CMP   END_OF_TRACK, 15          ;IS SOURCE ALSO 96 TPI?
   JNE   CT_FATAL                  ;NO, FATAL ERROR

;C00   JMP   CT_EXIT_OLD               ;OK
   JMP   SHORT CT_EXIT_OLD         ;OK                                  ;C00

CT_8_SECTOR:                       ;
   CMP   END_OF_TRACK, 15          ;
   JE    CT_FATAL                  ;IF SOURCE IS 96 TPI, THEN FATAL ERROR

   CMP   END_OF_TRACK, 9           ;
   JE    CT_FORMAT                 ;IF SOURCE IS 9 SECTOR, THEN
                                   ; SHOULD FORMAT TARGET

;C00   JMP   CT_EXIT_OLD               ;ELSE ASSUME SOURCE IS 8 SECTOR.
   JMP   SHORT CT_EXIT_OLD         ;ELSE ASSUME SOURCE IS 8 SECTOR.     ;C00

CT_9_SECTOR:                       ;
   CMP   END_OF_TRACK, 15          ;IS SOURCE 96 TPI ?
   JNE   CT_EXIT_OLD               ;NO. SOUCE IS 8 OR 9
                                   ; SECTORED 48 TPI DISKETTE

CT_FATAL:                          ;
   MOV   COPY_STATUS, FATAL        ;
                                   ;"Drive types or diskette types"
   PRINT MSGNUM_NOT_COMPATIBLE     ;AC000;"not compatible"
   CMP EXITFL,EXOK                 ;Q: Was there already an error          ;C12
   JNZ CT_EXIT                     ; Y: then save that error               ;C12
   MOV EXITFL,EX_INIT_ERROR        ; N: Force an initialization error      ;C12

   JMP   SHORT   CT_EXIT           ;

CT_EXIT_OLD:                       ;
   MOV   CX, MS_deviceBPB_leng     ;
   MOV   SI, OFFSET MS_deviceBPB   ;
   MOV   DI, OFFSET MT_deviceBPB   ;
   REP   MOVSB                     ;set MT_deviceBPB to MS_deviceBPB
CT_SET_DRV:                        ;
   MOV   T_DRV_SET_FLAG, 1         ;INDICATE THE TARGET DEFAULT
                                   ; DEVICE PARM HAS BEEN SET.
   mov   bx, last_track            ;patch for 3.2 diskcopy, 3/27/86 J.K.
   inc   bx                        ;
   mov   MT_numberOfCylinders, bx  ;make sure the # of cyl of the target
   MOV   BL, TARGET_DRIVE          ;
   MOV   DX, OFFSET MT_IOCTL_DRV_PARM ;
   MOV   MT_specialFunctions, SET_SP_FUNC_DEF ;
   CALL  SET_DRV_PARM_DEF          ;

CT_EXIT:                           ;
   RET                             ;

CHECK_TARGET ENDP                  ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHK_MULTI_MEDIA - CHECK IF DRIVE IS MULTI-MEDIA> ;AN000;
;*****************************************************************************
   PUBLIC CHK_MULTI_MEDIA          ;AN000;MAKE ENTRY IN LINK MAP
CHK_MULTI_MEDIA PROC NEAR          ;
;IF THE SOURCE IS 96 TPI DISKETTE, AND TARGET IS 48 TPI
;DISKETTE, OR VICE VERSA, THEN SET THE CARRY BIT.
;THIS ROUTINE BE CALLED WHEN BPB INFORMATIONS OF TARGET HAS BEEN SUCCESSFULLY
;READ.
;*** CURRENTLY, ONLY 96 TPI DRIVE IN PC_AT CAN HAVE MULTI_MEDIA.
;INPUT: AX - TARGET MEDIA CYLINDER NUMBER - 1
;       LAST_TRACK - SOURCE MEDIA CYLINDER NUMBER - 1
;*****************************************************************************
   CLC                             ;CLEAR CARRY
   CMP   LAST_TRACK, 39            ;SOURCE IS 48 TPI MEDIA?
;  $IF   E,AND                     ;
   JNE $$IF105
   CMP   AX, 79                    ;AND TARGET IS 96 TPI MEDIA?
;  $IF   E                         ;
   JNE $$IF105
       STC                         ;THEN SET CARRY
;  $ELSE                           ;
   JMP SHORT $$EN105
$$IF105:
       CMP   LAST_TRACK, 79        ;SOURCE IS 96 TPI MEDIA?
;      $IF   E,AND                 ;
       JNE $$IF107
       CMP   AX, 39                ;AND TARGET IS 48 TPI?
;      $IF   E                     ;
       JNE $$IF107
           STC                     ;
;      $ENDIF                      ;
$$IF107:
;  $ENDIF                          ;
$$EN105:
   RET                             ;
CHK_MULTI_MEDIA ENDP               ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <SET_DRV_PARM_DEF - SET DRIVE PARMS VIA IOCTL> ;AN000;
;*****************************************************************************
   PUBLIC SET_DRV_PARM_DEF         ;AN000;MAKE ENTRY IN LINK MAP
SET_DRV_PARM_DEF PROC NEAR         ;
;SET THE DRV PARMAMETERS
;INPUT: BL - DRIVE NUMBER
;       DX - POINTER TO THE DEFAULT PARAMETER TABLE
;       specialfunc should be set before calling this routine
;*****************************************************************************
   MOV   CL, SETDEVPARM            ;=40H
   CALL  GENERIC_IOCTL             ;

   RET                             ;
SET_DRV_PARM_DEF ENDP              ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <CHK_MEDIATYPE - DETERMINE MEDIATYPE OF TARGET FOR FORMAT> ;AN000;
;*****************************************************************************
   PUBLIC CHK_MEDIATYPE            ;AN000;MAKE ENTRY IN LINK MAP
CHK_MEDIATYPE PROC NEAR            ;
;SET THE mediaType OF IOCTL_DRV_PARM FOR TARGET DRIVE IN CASE OF FORMAT.
;IF TARGET IS A MULTI-MEDIA DEVICE, mediaType SHOULD BE SET CORRECTLY
;TO FORMAT THE TARGET MEDIA.
;IF EITHER OF LAST_TRACK OR END_OF_TRACK IS LESS THAN THAT OF TARGET
;DRIVE, THEN mediaType WILL BE SET TO 1. OTHERWISE, IT WILL BE 0 FOR
;THE DEFAULT VALUE.
;*****************************************************************************

   MOV   AX, T_DRV_TRACKS          ;TARGET DEVICE MAXIUM TRACKS
   DEC   AX                        ;
   CMP   LAST_TRACK, AX            ;COMPARE SOURCE MEDIA # OF TRACKS TO IT
;  $IF   B,OR                      ;
   JB $$LL110
   MOV   AL, T_DRV_SECT_TRACK      ;
   CMP   END_OF_TRACK, AL          ;SOURCE # OF SECT/TRACK < TARGET DEVICE?
;  $IF   B                         ;
   JNB $$IF110
$$LL110:
       MOV   MT_mediaType, 1       ;
;  $ENDIF                          ;
$$IF110:
   RET                             ;
CHK_MEDIATYPE ENDP                 ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <GENERIC_IOCTL - COMMUNICATE WITH THE DEVICE DRIVER> ;AN000;
;*****************************************************************************
   PUBLIC GENERIC_IOCTL            ;AN000;MAKE ENTRY IN LINK MAP
GENERIC_IOCTL PROC NEAR            ;
;INPUT: CL - MINOR CODE; 60 - GET DEVICE PARM, 40 - SET DEVICE PARM
;                        61 - READ TRACK, 41 - WRITE TRACK,
;                        42 - FORMAT AND VERIFY TRACK, 43 - SET MEDIA ID
;                        62 - VERIFY TRACK, 63 - GET MEDIA ID
;       BL - LOGICAL DRIVE LETTER
;       DS:DX - POINTER TO PARAMETERS
;*****************************************************************************
   MOV   IO_ERROR, NO_ERROR        ;reset io_error
   MOV   CH, MAJOR_CODE            ;MAJOR CODE, REMOVABLE = 08H
   DOSCALL IOCTL_FUNC,GENERIC_IOCTL_CODE ;AC000;(440DH) CALL THE DEVICE DRIVER

;  $IF   C                         ;
   JNC $$IF112
       CALL  EXTENDED_ERROR_HANDLER ;ERROR, SEE WHAT IT IS!

;  $ENDIF                          ;
$$IF112:
   RET                             ;
GENERIC_IOCTL ENDP                 ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <EXTENDED_ERROR_HANDLER - RESPOND TO DOS ERRORS> ;AN000;
;*****************************************************************************
   PUBLIC EXTENDED_ERROR_HANDLER   ;AN000;MAKE ENTRY IN LINK MAP
EXTENDED_ERROR_HANDLER PROC NEAR   ;
;INPUT: BL - LOGICAL DRIVE LETTER
;*****************************************************************************

   PUSHF                           ;
   PUSH  AX                        ;
   PUSH  BX                        ;
   PUSH  CX                        ;
   PUSH  DX                        ;
   PUSH  SI                        ;
   PUSH  DI                        ;
   PUSH  ES                        ;
   PUSH  DS                        ;
   PUSH  BX                        ;

   MOV   AH, EXTENDED_ERROR        ;59H
   MOV   BX, 0                     ;
   INT   21H                       ;

   POP   BX                        ;RESTORE BL FOR DRIVE LETTER
   POP   DS                        ;
   POP   ES                        ;

   CMP   AX, 21                    ;DRIVE NOT READY? (TIME_OUT ERROR?)
   JE    EEH_CHK_TIMEOUT           ;

   CMP   AX, 19                    ;ATTEMP TO WRITE ON WRITE_PROTECTED?
   JE    WARN_USER_2               ;

;C00   JMP   EEH_HARD_ERROR            ;OTHERWISE, HARD_ERROR
   JMP   SHORT EEH_HARD_ERROR      ;OTHERWISE, HARD_ERROR               ;C00

EEH_CHK_TIMEOUT:                   ;BECAUSE OF THE INACCURACY
                                   ; OF TIME OUT ERROR,
                                   ;IN READING AND WRITING OPERATION,
                                   ; CHECK OUT CAREFULLY WITH "FORMAT"
   CMP   FORMAT_FLAG, ON           ;AFTER OR DURING FORMAT OPERATION,
   JE    WARN_USER_1               ; TIME OUT ERROR IS
                                   ; ASSUMED TO BE CORRECT.

   CMP   TRY_FORMAT_FLAG, ON       ;HAPPENED AT "TRY_FORMAT" PROCEDURE?
   JE    EEH_TIMEOUT               ;

   CMP   TARGET_OP, ON             ;HAPPENED ON TARGET DRIVE?
   JNE   WARN_USER_1               ;IF NOT, THEN ASSUME TIME OUT ERROR

   MOV   TRY_FORMAT_FLAG, ON       ;
   CALL  TRY_FORMAT                ;JUST TRY TO FORMAT THE TRACK.

   MOV   TRY_FORMAT_FLAG, OFF      ;
   CMP   TIME_OUT_FLAG, ON         ;REAL TIME OUT?
   JE    WARN_USER_1               ;YES, A SOFT ERROR.

   CMP   IO_ERROR, SOFT_ERROR      ;IT HAPPENED AT TRY_FORMAT PROC AND
                                   ; PC_AT WHEN THE DRIVE DOOR OPENED ABRUPTLY.
   JE    EEH_EXIT                  ;IT WAS WRITE PROTECTED ERROR.

;C00   JMP   EEH_HARD_ERROR            ;NO, "ADDRESS MARK NOT OUT". A HARD ERROR.
   JMP   SHORT EEH_HARD_ERROR      ;NO, "ADDRESS MARK NOT OUT". A HARD ERROR.;C00

EEH_TIMEOUT:                       ;
   MOV   TIME_OUT_FLAG, ON         ;SET TIME_OUT_FLAG AND EXIT THIS ROUTINE
;C00   JMP   EEH_EXIT                  ;
   JMP   SHORT EEH_EXIT            ;                                    ;C00

WARN_USER_1:                       ;
   MOV   DRIVE_LETTER, 'A'         ;
   DEC   BL                        ;CHANGE LOGICAL TO PHYSICAL
   ADD   DRIVE_LETTER, BL          ;
   PRINT MSGNUM_GET_READY          ;AC000;"Drive not ready - %0"

   PRINT MSGNUM_CLOSE_DOOR         ;AN004;"Make sure a diskette is inserted into
                                   ;  the drive and the door is closed"
;C00   JMP   WAIT_FOR_USER             ;
   JMP   SHORT WAIT_FOR_USER       ;                                    ;C00

WARN_USER_2:                       ;
   PRINT MSGNUM_WRITE_PROTECT      ;AC000;"Attempt to write to write-protected diskette"

WAIT_FOR_USER:                     ;
                                   ;"Press any key when ready . . ."
;C12   CALL  PRESS_ANY_KEY             ;AC000; THEN WAIT FOR ANY RESPONSE
   PRINT MSGNUM_CORRECT            ;"Press any key when ready..."          ;C12

   MOV   IO_ERROR, SOFT_ERROR      ;INDICATE THE CALLER TO TRY AGAIN
   JMP   SHORT EEH_EXIT            ;

EEH_HARD_ERROR:                    ;
   MOV   IO_ERROR, HARD_ERROR      ;
   MOV   UKM_ERR,OFF               ;AN011;ASSUME NOT "UNKNOWN MEDIA" TYPE ERROR
   CMP   AX,26                     ;AN011;IS THE ERROR TYPE IS "UNKNOWN MEDIA"?
;  $IF   E                         ;AN011;IF "UNKNOWN MEDIA" TYPE ERROR
   JNE $$IF114
       MOV   UKM_ERR,ON            ;AN011;SET FLAG TO INDICATE "UNKNOWN MEDIA"
                                   ; TO CAUSE FORMATTING OF TARGET DISKETTE
;  $ENDIF                          ;AN011;
$$IF114:

EEH_EXIT:                          ;
   POP   DI                        ;
   POP   SI                        ;
   POP   DX                        ;
   POP   CX                        ;
   POP   BX                        ;
   POP   AX                        ;
   POPF                            ;
   RET                             ;
.XLIST                             ;
;EEH_JUST_EXIT:
;   JMP   EXIT_PROGRAM              ;UNCONDITIONAL EXIT (IN MAIN PROC)
.LIST                              ;
EXTENDED_ERROR_HANDLER ENDP        ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <TRY_FORMAT - ATTEMPT TRACK FORMAT, TRY FOR ERROR RECOVERY> ;AN000;
;*****************************************************************************
   PUBLIC TRY_FORMAT               ;AN000;MAKE ENTRY IN LINK MAP
TRY_FORMAT PROC NEAR               ;
;*** TRY TO FORMAT A TRACK.
;*** CALLED BY "EXTENDED_ERROR_HANDLER" TO CHECK THE TIME OUT ERROR IS A REAL
;*** ONE OR CAUSED BY "ADDR MARK NOT FOUND" ERROR.(THIS IS HARDWARE ERROR THAT
;*** DOES NOT GIVE CORRECT ERROR CODE).
;*** THIS ROUTINE WILL CALL "GENERIC_IOCTL" WHICH IN TURN WILL CALL "EXTENDED_
;*** ERROR_HANDLER" WHERE THE ERROR WILL BE REEXAMINED.
;*****************************************************************************
   PUSH  ES                        ;

   PUSH  DS                        ;
   POP   ES                        ;

   MOV   CX, MS_deviceBPB_leng     ;set length of BPB
   MOV   SI, OFFSET MS_deviceBPB   ;
   MOV   DI, OFFSET MT_deviceBPB   ;
   REP   MOVSB                     ;
   CALL  CHK_MEDIATYPE             ;set MT_mediaTYPE for FORMAT operation

   MOV   MT_specialFunctions, SET_SP_BF_FORM ;=00000101B
   MOV   CL, SETDEVPARM            ;=40h
   MOV   DX, OFFSET MT_IOCTL_DRV_PARM ;
   XOR   BX, BX                    ;
   MOV   BL, TARGET_DRIVE          ;
   CALL  GENERIC_IOCTL             ;

   XOR   AX, AX                    ;
   MOV   AL, SIDE                  ;SIDE TO FORMAT
   MOV   Fhead, AX                 ;
   MOV   AX, TRACK_TO_WRITE        ;TRACK TO FORMAT
   MOV   Fcylinder, AX             ;

   XOR   BX, BX                    ;
   MOV   BL, TARGET_DRIVE          ;
   MOV   CL, FORMAT_FUNC           ;=42h
   MOV   DX, OFFSET IOCTL_FORMAT   ;
   CALL  GENERIC_IOCTL             ;

   MOV   AL, IO_ERROR              ;SAVE IO_ERROR, IN CASE FOR PC_AT CASE.
   PUSH  AX                        ;

   XOR   BX, BX                    ;
   MOV   BL, TARGET_DRIVE          ;
   MOV   T_DRV_SET_FLAG, 1         ;INDICATE TARGET DRIVE PARM HAS BEEN SET
   MOV   DX, OFFSET MT_IOCTL_DRV_PARM ;
   MOV   MT_specialFunctions, SET_SP_FUNC_DEF ;
   CALL  SET_DRV_PARM_DEF          ;SET IT BACK FOR NORMAL
                                   ; OPERATION, EX. WRITING

   POP   AX                        ;
   MOV   IO_ERROR, AL              ;RESTORE IO_ERROR

   POP   ES                        ;

   RET                             ;

TRY_FORMAT ENDP                    ;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <ERROR_MESSAGE - SAY WHAT AND WHERE FAILURE> ;AN000;
;*****************************************************************************
;                                                                            *
ERROR_MESSAGE PROC NEAR            ;DISPLAY ERROR MESSAGE                    *
   PUBLIC ERROR_MESSAGE            ;AN000;MAKE ENTRY IN LINK MAP
;                                                                            *
;  FUNCTION: THIS SUBROUTINE DISPLAYS WHAT OPERATION FAILED (READ OR WRITE)  *
;            AND WHERE IT FAILED (TRACK NO. AND SIDE).                       *
;                                                                            *
;  INPUT: AH = IOCTL I/O COMMAND CODE  (3=READ, 4=WRITE)                     *
;                                                                            *
;*****************************************************************************
   CMP   AH,READ_FUNC              ;ERROR DURING READ ?
.XLIST                             ;
;       $IF     E
;           MOV     BX,OFFSET READ_ERROR
;           MOV     MSG_HARD_ERR_TYPE,BX ;ERROR DURING READ OP
;           MOV     BL,TRACK_TO_READ    ;SAVE BAD TRACK NUMBER FOR READ
;       $ELSE
;           MOV     BX,OFFSET WRITE_ERROR
;           MOV     MSG_HARD_ERR_TYPE,BX ;ERROR DURING WRITE OP
;           MOV     BL,TRACK_TO_WRITE   ;SAVE BAD TRACK NUMBER FOR WRITE
;       $ENDIF
.LIST                              ;
;  $IF   E                         ;AN000;YES, READ ERROR
   JNE $$IF116
       MOV   BX,TRACK_TO_READ      ;SAVE BAD TRACK NUMBER FOR READ
       MOV   DI,OFFSET MSGNUM_HARD_ERROR_READ ;AN000;
;  $ELSE                           ;AN000;NO, NOT READ, MUST BE WRITE ERROR
   JMP SHORT $$EN116
$$IF116:
       MOV   BX,TRACK_TO_WRITE     ;SAVE BAD TRACK NUMBER FOR WRITE
       MOV   DI,OFFSET MSGNUM_HARD_ERROR_WRITE ;AN000;
;  $ENDIF                          ;AN000;READ ERROR?
$$EN116:
   MOV   AL,SIDE                   ;
   MOV   DRIVE_LETTER,"A"          ;
   dec   dl                        ;change logical drive letter to physical one.
   ADD   DRIVE_LETTER,DL           ;SHOW DRIVE LETTER
.XLIST                             ;
;       MOV     BYTE PTR MSG_HARD_ERROR_PTR+8,AL ;SIDE NUMBER
;       MOV     BYTE PTR MSG_HARD_ERROR_PTR+10,BL ;TRACK NUMBER WHERE THE ERROR
.LIST                              ;
   MOV   BYTE PTR ERROR_SIDE_NUMBER,AL ;AC000;SIDE NUMBER
   MOV   ERROR_TRACK_NUMBER,BX         ;AC000;TRACK NUMBER WHERE THE ERROR
                                   ;CR,LF,"Unrecoverable read/write error on drive %1",CR,LF
   CALL  SENDMSG                   ;"Side %2, track %3",CR,LF                   ;ACN000;
   MOV EXITFL,EX_HARD_ERROR        ;Indicate unrecoverable errorlevel      ;C12

   RET                             ;
ERROR_MESSAGE ENDP                 ;
.XLIST                             ;
; HEADER <PROMPT - READ RESPONSE FROM KEYBOARD>
;KB_INPUT_FUNC EQU 0C01H                 ;DOS KEYBOARD INPUT
;*****************************************************************************
;                                                                            *
;PROMPT  PROC    NEAR                    ;DISPLAY MESSAGE                    *
;                                          AND GET A USER INPUT CHARACTER    *
;        PUBLIC  PROMPT                                                      *
;                                                                            *
;       INPUT:  DX = MESSAGE POINTER                                         *
;       OUTPUT: BYTE USER_INPUT                                              *
;                                                                            *
;*****************************************************************************
;        PUSH    AX
;        MOV     AX,KB_INPUT_FUNC        ;KEYBOARD INPUT
;        INT     21H
;        MOV     USER_INPUT,AL           ;SAVE USER'S RESPONSE
;        POP     AX
;        RET
;PROMPT  ENDP
;   HEADER <CALL_PRINTF - COMMON DRIVER TO PRINTF, DISPLAY MESSAGE>
;CALL_PRINTF PROC NEAR
;   PUBLIC CALL_PRINTF
;INPUT - DX HAS OFFSET INTO DS OF MESSAGE PARM LIST
;   PUSH  DX
;   PUSH  CS
;   CALL  PRINTF

;   RET
;CALL_PRINTF ENDP
;  =  =  =  =  =  =  =  =  =  =  =  =
.list                              ;
   HEADER <SENDMSG - PASS IN REGS DATA FROM MSG DESCRIPTOR TO DISP MSG> ;AN000;
SENDMSG PROC NEAR                  ;AN000;
   PUBLIC SENDMSG                  ;AN000;
; INPUT - DI=POINTER TO MSG_DESC STRUC FOR THIS MESSAGE
; OUTPUT - IF CARRY SET, EXTENDED ERROR MSG ATTEMPTED DISPLAYED
;          IF CARRY CLEAR, ALL OK
;          IN EITHER CASE, DI AND AX ALTERED, OTHERS OK
;  =  =  =  =  =  =  =  =  =  =  =  =

   PUSH  BX                        ;AN000;SAVE CALLER'S REGS
   PUSH  CX                        ;AN000;
   PUSH  DX                        ;AN000;
   PUSH  SI                        ;AN000;

;                PASS PARMS TO MESSAGE HANDLER IN
;                THE APPROPRIATE REGISTERS IT NEEDS.
   MOV   BX,[DI].MSG_NUM           ;AC006;MESSAGE NUMBER
   MOV   SI,[DI].MSG_SUBLIST       ;AN000;OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
   MOV   CX,[DI].MSG_COUNT         ;AN000;NUMBER OF %PARMS, 0 IF NONE
   MOV   DX,[DI].MSG_CLASS         ;AN000;CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
   MOV   AX,SELECT_MPX             ;AN006;REQUEST THE SELECT MULTIPLEXOR, IF PRESENT
   INT   MULTIPLEXOR               ;AN006;CALL THE MULTIPLEXOR FUNCTION

   CMP   AL,SELECT_PRESENT         ;AN006;CHECK MULTIPLEXOR RESPONSE CODE
;  $IF   NE                        ;AN006;IF SELECT HAS NOT HANDLED THE MESSAGE
   JE $$IF119
       MOV   AX,[DI].MSG_NUM       ;AN000;MESSAGE NUMBER
       MOV   BX,[DI].MSG_HANDLE    ;AN006;HANDLE TO DISPLAY TO
       CALL  SYSDISPMSG            ;AN000;DISPLAY THE MESSAGE

;      $IF   C                     ;AN000;IF THERE IS A PROBLEM
       JNC $$IF120
                                   ;AX=EXTENDED ERROR NUMBER                    ;AN000;
           LEA   DI,MSGNUM_EXTERR  ;AN000;GET REST OF ERROR DESCRIPTOR
           MOV   BX,[DI].MSG_HANDLE ;AN000;HANDLE TO DISPLAY TO
           MOV   SI,[DI].MSG_SUBLIST ;AN000;OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
           MOV   CX,[DI].MSG_COUNT ;AN000;NUMBER OF %PARMS, 0 IF NONE
           MOV   DX,[DI].MSG_CLASS ;AN000;CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
           CALL  SYSDISPMSG        ;AN000;TRY TO SAY WHAT HAPPENED
           MOV EXITFL,EX_INIT_ERROR;Force an initialization error          ;C12

           STC                     ;AN000;REPORT PROBLEM
;      $ENDIF                      ;AN000;PROBLEM WITH DISPLAY?
$$IF120:
;  $ELSE                           ;AN006;SINCE SELECT DID THE MESSAGE
   JMP SHORT $$EN119
$$IF119:
       MOV   SELECT_FLAG,TRUE      ;AN006;INDICATE SELECT IS DOING THE MESSAGES
       CLC                         ;AN006;GENERATE A "NO PROBLEM" RESPONSE
;  $ENDIF                          ;AN006;DID SELECT HANDLE THE MESSAGE?
$$EN119:

   POP   SI                        ;AN000;RESTORE CALLER'S REGISTERS
   POP   DX                        ;AN000;
   POP   CX                        ;AN000;
   POP   BX                        ;AN000;

   RET                             ;AN000;
SENDMSG ENDP                       ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
   HEADER <YESNO - DETERMINE IF A RESPONSE IS YES OR NO> ;AN000;
YESNO PROC NEAR                    ;AN000;
   PUBLIC YESNO                    ;AN000;MAKE ENTRY IN LINK MAP
;INPUT: DL=CHAR WITH Y OR N EQUIVALENT CHAR TO BE TESTED
;       SELECT_FLAG - IF SELECT IS DOING MESSAGES, ALWAYS ASSUME "NO"
;OUTPUT: AX=0=NO; AX=1=YES ; AX=2=INVALID RESPONSE, NEITHER Y NOR N
;       IF CARRY SET, PROBLEM WITH THE FUNCTION, CALLER SHOULD ASSUME "NO"
;  =  =  =  =  =  =  =  =  =  =  =  =

   CMP   SELECT_FLAG,TRUE          ;AN006;IS SELECT DOING THE MESSAGES?
;  $IF   NE                        ;AN006;IF SELECT HAS NOT HANDLED THE MESSAGE
   JE $$IF124
                                   ;AL=SUBFUNCTION, AS:
                                   ;  20H=CAPITALIZE SINGLE CHAR
                                   ;  21H=CAPITALIZE STRING
                                   ;  22H=CAPITALIZE ASCIIZ STRING
                                   ;  23H=YES/NO CHECK
                                   ;  80H BIT 0=USE NORMAL UPPER CASE TABLE
                                   ;  80H BIT 1=USE FILE UPPER CASE TABLE
                                   ;DL=CHAR TO CAP (FUNCTION 23H)               ;AN000;
       MOV   AX,(GET_EXT_CNTRY_INFO SHL 8) + YESNO_CHECK ;AN000;(6523H) GET EXTENDED
                                   ; COUNTRY INFORMATION, (Y/N)
       INT   21H                   ;AN000;SEE IF Y OR N

;  $ELSE                           ;AN006;SINCE SELECT IS NOT PRESET
   JMP SHORT $$EN124
$$IF124:
       MOV   AX,NO                 ;AN006;ASSUME RESPONSE WAS 'NO'
;  $ENDIF                          ;AN006;
$$EN124:
   RET                             ;AN000;RETURN TO CALLER
YESNO ENDP                         ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =
;(deleted ;AN013;)   HEADER <READ_VOLSER - OBTAIN OLD VOLUME SERIAL NUMBER FROM SOURCE> ;AN000;
;(deleted ;AN013;) READ_VOLSER PROC NEAR              ;                         ;AN000;
;(deleted ;AN013;)    PUBLIC READ_VOLSER              ;                         ;AN000;
;(deleted ;AN013;) ;IF THE SOURCE DISKETTE SUPPORTED A VOL SERIAL NUMBER, THEN MAKE A NEW ONE
;(deleted ;AN013;) ; AND SEND IT TO THE TARGET DISKETTE.  FOR OLD STYLE DISKETTES THAT DID NOT
;(deleted ;AN013;) ; HAVE ANY VOL SERIAL NUMBER, MAKE NO CHANGE AFTER THE TRADITIONAL FULL COPY.
;(deleted ;AN013;) ;INPUT: SOURCE AND TARGET DRIVE ID
;(deleted ;AN013;) ;       THE TARGET DISKETTE IS A COMPLETE COPY OF THE SOURCE.
;(deleted ;AN013;) ;REFERENCED: A_MEDIA_ID_INFO STRUC (DEFINED IN DISKCOPY.EQU)
;(deleted ;AN013;) ; = = = = = = = = = = = = = = = = = =
;(deleted ;AN013;) ;              ISSUE GET MEDIA ID FROM SOURCE
;(deleted ;AN013;)    MOV BH,ZERO                ;BH=0, RES                ;AN000;
;(deleted ;AN013;)    MOV BL,SOURCE_DRIVE        ;BL=DRIVE NUM (1=A:, 2=B:, ETC);AN000;
;(deleted ;AN013;)    MOV DX,OFFSET MEDIA_ID_BUF ;DS:DX=BUFFER (see A_MEDIA_ID_INFO STRUC);AN000;
;(deleted ;AN013;)    DOSCALL GSET_MEDIA_ID,GET_ID ;(6900H) GET MEDIA ID        ;AC009;
;(deleted ;AN013;)                               ;CARRY SET ON ERROR (OLD STYLE BOOT RECORD)
;(deleted ;AN013;)
;(deleted ;AN013;)    $IF NC                     ;IF THERE IS NO PROBLEM        ;AN000;
;(deleted ;AN013;) ;         GET CURRENT DATE
;(deleted ;AN013;)        DOSCALL GET_DATE       ;READ SYSTEM DATE              ;AN000;
;(deleted ;AN013;)                               ;OUTPUT: DL = DAY (1-31)
;(deleted ;AN013;)                               ;  AL = DAY OF WEEK (0=SUN,6=SAT)
;(deleted ;AN013;)                               ;  CX = YEAR (1980-2099)
;(deleted ;AN013;)                               ;  DH = MONTH (1-12)
;(deleted ;AN013;)        PUSH  CX               ;SAVE THESE FOR                ;AN000;
;(deleted ;AN013;)        PUSH  DX               ; INPUT INTO HASH ALGORITHM    ;AN000;
;(deleted ;AN013;) ;          GET CURRENT TIME
;(deleted ;AN013;)        DOSCALL GET_TIME       ;READ SYSTEM TIME CLOCK        ;AN000;
;(deleted ;AN013;)                               ;OUTPUT: CH = HOUR (0-23)
;(deleted ;AN013;)                               ;  CL = MINUTES (0-59)
;(deleted ;AN013;)                               ;  DH = SECONDS (0-59)
;(deleted ;AN013;)                               ;  DL = HUNDREDTHS (0-99)
;(deleted ;AN013;)
;(deleted ;AN013;) ; HASH THESE INTO A UNIQUE 4 BYTE NEW VOLUME SERIAL NUMBER:
;(deleted ;AN013;) ;          MI_SERIAL+0 = DX FROM DATE + DX FROM TIME
;(deleted ;AN013;) ;          MI_SERIAL+2 = CX FROM DATE + CX FROM TIME
;(deleted ;AN013;)
;(deleted ;AN013;)        POP   AX               ;GET THE DX FROM DATE          ;AN000;
;(deleted ;AN013;)        ADD   AX,DX            ;ADD IN THE DX FROM TIME       ;AN000;
;(deleted ;AN013;)        MOV   WORD PTR MEDIA_ID_BUF.MI_SERIAL,AX ;SAVE FIRST RESULT OF HASH;AN000;
;(deleted ;AN013;)
;(deleted ;AN013;)        POP   AX               ;GET THE CX FROM DATE          ;AN000;
;(deleted ;AN013;)        ADD   AX,CX            ;ADD IN THE CX FROM TIME       ;AN000;
;(deleted ;AN013;)        MOV   WORD PTR MEDIA_ID_BUF.MI_SERIAL+WORD,AX ;SAVE SECOND RESULT OF HASH;AN000;
;(deleted ;AN013;)
;(deleted ;AN013;)        MOV   VOLSER_FLAG,TRUE ;REQUEST THE NEW VOL SERIAL NUMBER BE WRITTEN;AN000;
;(deleted ;AN013;)    $ENDIF                     ;                              ;AN000;
;(deleted ;AN013;)    RET                        ;RETURN TO CALLER              ;AN000;
;(deleted ;AN013;) READ_VOLSER ENDP              ;                              ;AN000;
; = = = = = = = = = = = = = = = = = = =
   HEADER <WRITE_VOLSER - PUT NEW VOL SER NUMBER TO TARGET> ;AN000;
WRITE_VOLSER PROC NEAR             ;AN000;
   PUBLIC WRITE_VOLSER             ;AN000;MAKE ENTRY IN LINK MAP
   CMP   VOLSER_FLAG,TRUE          ;AN000;IF NEW NUMBER READY TO BE WRITTEN
;  $IF   E                         ;AN000;THEN WRITE IT
   JNE $$IF127

;NOTE FOR ;AN013;
;THERE IS NO NEED TO DO A SET MEDIA ID TO WRITE OUT THE MODIFIED SERIAL NUMBER
;BECAUSE THAT NUMBER WAS CHANGED IN THE IMAGE OF THE BOOT RECORD WHEN THE
;ORIGINAL BOOT RECORD WAS READ IN, SO WHEN THAT TRACK IMAGE WAS WRITTEN,
;IT CONTAINED THE NEW SERIAL NUMBER ALREADY.

;(deleted ;AN013;) ;     ISSUE SET MEDIA ID TO TARGET
;(deleted ;AN013;)  MOV   BH,ZERO               ;BH=0, RES                      ;AN000;
;(deleted ;AN013;)  MOV   BL,TARGET_DRIVE       ;BL=DRIVE NUM                   ;AN000;
;(deleted ;AN013;)  MOV   DX,OFFSET MEDIA_ID_BUF ;DS:DX=BUFFER (see STRUC above);AN000;
;(deleted ;AN013;)  DOSCALL GSET_MEDIA_ID,SET_ID ;(6901H) SET MEDIA ID          ;AC009;

; NOTE: IN THE FOLLOWING TWO SUBLISTS, WE ARE GOING TO DISPLAY, IN HEX,
; A CONSECUTIVE SET OF 4 BYTES, THE VOLUME SERIAL NUMBER.  THE ORDER OF
; THESE TWO WORDS OF HEX IS, LEAST SIGNIFICANT WORD FIRST, THEN THE
; MOST SIGNIFICANT WORD.  WHEN DISPLAYED, THE MOST SIGNIFICANT IS TO BE
; DISPLAYED FIRST, SO THE VALUE AT SERIAL+2 GOES TO THE 26A SUBLIST,
; AND THE LEAST SIGNIFICANT VALUE AT SERIAL+0 GOES TO THE SECOND POSITION,
; REPRESENTED BY THE 26B SUBLIST.

       LEA   AX,SERIAL             ;AC013;GET POINTER TO DATA TO BE PRINTED
       MOV   SUBLIST_26B.SUB_VALUE,AX ;AN001; INTO THE SUBLIST

       LEA   AX,SERIAL+WORD        ;AC013;GET POINTER TO DATA TO BE PRINTED
       MOV   SUBLIST_26A.SUB_VALUE,AX ;AN001; INTO THE SUBLIST

       PRINT MSGNUM_CR_LF          ;AN000;SKIP A SPACE

                                   ;"Volume Serial Number is %1-%2"
       PRINT MSGNUM_SERNO          ;AN001;DISPLAY THE NEW SERIAL NUMBER

;  $ENDIF                          ;AN000;
$$IF127:
   RET                             ;AN000;RETURN TO CALLER
WRITE_VOLSER ENDP                  ;AN000;
; = = = = = = = = = = = = = = = = = = =
   HEADER <PRESS_ANY_KEY - PUTS A BLANK LINE BEFORE PROMPT> ;AN000;
PRESS_ANY_KEY PROC NEAR            ;
;THE CANNED MESSAGE "PRESS ANY KEY..." DOES NOT START WITH CR,LF.
;THIS PUTS OUT THE CR LF TO CAUSE SEPARATION OF THIS PROMP FROM
;PRECEEDING MESSAGES.
;  =  =  =  =  =  =  =  =  =  =  =  =
   PRINT MSGNUM_CR_LF              ;AN000;SKIP A SPACE

   PRINT MSGNUM_STRIKE             ;AN000;"Press any key when ready..."

   RET                             ;AN000;RETURN TO CALLER
PRESS_ANY_KEY ENDP                 ;AN000;
;  =  =  =  =  =  =  =  =  =  =  =  =

;<Start of 5.00 media sense additions>                                    ;D01
;************************************************************************
;
; TargetMediaSense :    This procedure prints out a warning message in
;                       case the TARGET media is too small (capacity-wise).
;                       The user is also asked whether or not to continue.
;
;************************************************************************

TargetMediaSense        proc    NEAR

        push    AX                      ;Save registers
        push    BX
        push    CX
        push    DX

        call    TargetBigEnough
        jnc     ExitTargetMediaSense    ;No carry ==> Target is big enough

GiveMessage:                            ;CR,LF,"TARGET media has lower capacity
                                        ;than SOURCE",CR,LF,"Continue anyway (Y/N)?"
        MOV EXITFL,EX_INIT_ERROR        ;Force an initialization error     ;C12
        PRINT   MSGNUM_TARGETTOOSMALL   ;See if user wants to continue, and
                                        ;read response to AL
        mov     DX,AX                   ;Copy response to DL for YesNo call
        call    YesNo                   ;Check for (Y/N)
                                        ;AX=0,NO; AX=1,YES; AX=2,INVALID
        jc      ExitTargetMediaSense    ;If carry set, problem, pretend "NO"
        cmp     AX,BAD_YESNO            ;Was the response invalid?
        jnb     GiveMessage             ;Repeat message (answer given AX!=(0 or 1))
        cmp     AL,YES                  ;Was "YES" specified?
        jne     GotNo
GotYes:
        MOV EXITFL,EXOK                 ;Reset errorlevel, going to try!   ;C12
        clc                             ;Clear carry to indicate CONTINUE with
        jmp     SHORT ExitTargetMediaSense;current disk

GotNo:
        stc                             ;Set carry to indicate ABORT current disk

ExitTargetMediaSense:

        pop     AX                      ;Restore registers
        pop     BX
        pop     CX
        pop     DX

        ret
TargetMediaSense        endp

;***************************************************************************
;
; TargetBigEnough :     This procedure utilizes media sensing (if available)
;                       to determine whether or not the TARGET media is of
;                       sufficient capacity to be formatted to the same
;                       layout as the SORUCE disk.
;
; Returns :     NC --> Target capacity sufficient, or media sensing not avlbl
;               CY --> Target media too small
;
; Input :       MediaTable
;               MS_DeviceBPB.CTOTSECT
;
;***************************************************************************

TargetBigEnough proc    NEAR

        xor     BX,BX                                   ;Setup for media sensing call
        mov     BL,Target_Drive                         ;Load 1-based no.
        mov     CX,(MAJOR_CODE shl 8) or SENSE_MEDIA_TYPE       ;CX = 0868h
        lea     DX,MediaSensePacket

                                                        ;Do preliminary call
                                                        ;to check if function
                                                        ;is supported
        mov     AX,(IOCTL_FUNC shl 8) or IOCTL_QUERY_BLOCK      ;AX = 4411h
        int     21h
        jnc     MediaSenseSupported
        clc                                             ;Not supported, signal
        jmp     SHORT ExitTargetBigEnough               ;continue with current disk

MediaSenseSupported:
                                                        ;Now perform actual call
        mov     AX,(IOCTL_FUNC shl 8) or GENERIC_IOCTL_CODE     ;AX = 440Dh
        int     21h
        jnc     GotMediaSense
        clc                                             ;Not successful, signal
        jmp     SHORT ExitTargetBigEnough               ;continue with current disk

GotMediaSense:
        mov     AL,MediaSensePacket.MS_DEVMEDIATYPE     ;AL = media type
        xor     AH,AH                                   ;(2=720K,7=1.44M,9=2.88M);4417
        shl     AX,1                                    ;Use for word offset
        mov     BX,OFFSET MediaTable
        add     BX,AX                                   ;Index into table

        cmp     BX,OFFSET EndMediaTable                 ;Make sure we're still
        jl      StillInTable                            ;in table

OutOfTable:
        clc                                             ;Clear carry to continue
        jmp     SHORT ExitTargetBigEnough               ;with current disk

StillInTable:
        mov     AX,[BX]                                 ;now AX has #sectors on target media
        cmp     AX,WORD PTR MS_DeviceBPB.CTOTSECT       ;See if target is large enough
        jl      TargetTooSmall
        clc                                             ;Clear carry for ok target
        jmp     SHORT ExitTargetBigEnough

TargetTooSmall:
        stc                                             ;Set carry for small target

ExitTargetBigEnough:
        ret
TargetBigEnough endp
;**********************************************************************************
;<End of 5.00 media sense additions>                                    ;D01
   PUBLIC DISKCOPY_END             ;
DISKCOPY_END LABEL NEAR            ;

   PATHLABL DISKCOPY               ;AN015;
CSEG ENDS                          ;
   END   DISKCOPY                  ;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\doskey\display.asm ===
page	,132
;******************************************************************************
TITLE DISPLAY.ASM - Screen Display for DOSKEY
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989
;
;
	include	gendef.inc
	include dbcs.sw

video_int	equ	10h
;

;******************************************************************************
;			I N S T A N C E    D A T A
; (This data is all collectively defined in Win386.Asm in the instance block)
;******************************************************************************
	

; Purely Local

	extrn	num_cols:word
	extrn	active_page:byte
	extrn	cur_col:byte
	extrn	over_cursor:word
	extrn	mark_row:byte
	extrn	mark_col:byte
	extrn	rows_advanced:byte

	extrn	macro_base:word
	extrn	macro_last:word
	extrn	macro_end:word
	extrn	buf_base:word
	extrn	buf_end:word
	extrn	buf_front:word
	extrn	buf_back:word
	extrn	buf_current:word
	extrn	text_ptr:word
	extrn	macro_ptr:word
	extrn	end_dsp:word

	extrn	more_prompt:byte
	extrn	rows:word
	extrn	getkey:near

ifdef DBCS
	extrn	IsDBCSLeadByte:near
endif

text 	segment	byte public	'CODE'
	assume	cs:text, ds:nothing, es:nothing, ss:nothing


	public	number_of_display_columns
	public	get_video_mode
	public	get_cursor_pos
	public	set_cursor_type
	public	set_cursor_pos
	public	number_of_display_columns
	public	backspace
	public	display_char
	public	beep

	public	dumphist
	if	debug_version
	public	dumpdebug
	endif
	public	dstring
	public	newline
	public	word10

;******************************************************************************
;
;   get_video_mode
;
;   description:  Use BIOS Int16 function 0fh to setup
;		     num_cols and active_page
;		    and function 03h to setup over_cursor
;
;==============================================================================
get_video_mode		proc	near
	assume	ds:text,es:nothing


	mov	ah,0fh			; get video mode
	int	video_int
	mov	al,ah
	xor	ah,ah
	mov	[num_cols],ax
	mov	[active_page],bh

	mov	ah,3
	int	video_int
	mov	[over_cursor],cx	; save "overstrike" cursor
	mov	[cur_col],dl		; save the actual column
	ret

get_video_mode	endp
	

;******************************************************************************
;
;   get_cursor_pos	Gets the current cursor position and stores it into
;			cur_col, mark_col & mark_row.  Also sets rows_advanced
;			to zero.
;
;==============================================================================
get_cursor_pos	proc	near
	assume	ds:text,es:nothing

	mov	ah,3			; get cursor position
	mov	bh,[active_page]
	int	video_int
	mov	[cur_col], dl
	mov	[mark_row],dh
	mov	[mark_col],dl
	mov	[rows_advanced],0		; number of rows advanced

	ret
get_cursor_pos	endp

;******************************************************************************
;
;   set_cursor_pos	Sets the cursor position to the marked position
;			Note:  if (rows_advanced != 0) then set mark_row =
;				(get_cursor_pos_row) - rows_advanced
;
;==============================================================================

set_cursor_pos	proc	near
	assume	ds:text,es:nothing


	cmp	[rows_advanced],0
	je	rcp_1

	mov	ah,3			; get cursor position
	mov	bh,[active_page]
	int	video_int
	sub	dh,[rows_advanced]	; find the original 
	mov	[mark_row],dh

rcp_1:
	mov	ah,2			; set cursor position
	mov	bh,[active_page]
	mov	dh,[mark_row]
	mov	dl,[mark_col]
	mov	[cur_col],dl
	int	video_int

	ret

set_cursor_pos	endp


;******************************************************************************
;
;   set_cursor_type	Sets cursor type via ROM BIOS to type in CX
;
;==============================================================================

set_cursor_type	proc	near
	assume	ds:text,es:nothing

	mov	ah,1			; set cursor type
	int	video_int
	ret

set_cursor_type	endp

;******************************************************************************
;
;   number_of_display_columns
;
;   description: Returns the number of character positions required
;		 to display the character in al.  Note: if al=tab, we'll
;		 use cur_col in our calculations.
;
;   entry:     al contains character
;   exit:      cx number of chars corresponding to display
;	       al still contains the character
;
;==============================================================================

number_of_display_columns	proc	near
	assume	ds:text,es:nothing

	cmp	al,TAB		; is it a tab character?
	je	nodc_tab	;  brif so

	mov	cx,1		; assume it is just 1 char
	cmp	al,' '		; is it a control character?
	jae	nodc_ret
	cmp	al,CTRL_T	; these are just
	je	nodc_ret
	cmp	al,CTRL_U	; 1 character.
	je	nodc_ret
	inc	cl		; two characters then
nodc_ret:
	ret

nodc_tab:
	mov	cx,708h		; ch=mask, cl=8
	and	ch,[cur_col]
	sub	cl,ch		
	xor	ch,ch
	ret
number_of_display_columns	endp

;******************************************************************************
;
;   backspace		backspace cursor over character
;   entry:		cx number of characters to backspace
;   uses:		mark_row, mark_col
;
;==============================================================================

backspace	proc	near
	assume	ds:text,es:nothing

	push	cx
	call	get_cursor_pos	; get current position.
	pop	cx
	mov	al,[mark_col]	; ax = current column
	xor	ah,ah

	sub	ax,cx		; back up column by count
	jnb	bs_2		; brif no wrap to previous line(s)

bs_1:
	dec	[mark_row]
	add	ax,[num_cols]
	jnc	bs_1		; loop until we go positive again
bs_2:
	mov	[mark_col],al
	call	set_cursor_pos ; and position the cursor there

	ret
backspace	endp


;******************************************************************************
;
;   display_char	Processes character and displays on screen
;   entry:		al char to display
;   exit:		ax = number of display positions
;   Preserves:		si, di, bx, cx
;
;==============================================================================
display_char	proc	near
	assume	ds:text,es:nothing

	push	si
	push	cx
	call	number_of_display_columns
	push	cx
	cmp	al,TAB
	je	dc_tab

	cmp	al,' '			; is it a ^ control char display?
	jae	dc_3			; jump if not

	cmp	al,cr
	je	dc_3
	cmp	al,LF
	je	dc_3
	cmp	al,CTRL_T		; control t is not processed
	je	dc_3
	cmp	al,CTRL_U		; control u is also not processed.
	je	dc_3

; ctrl character display

	mov	cl,al
	mov	al,'^'
	call	display
	mov	al,cl
	add	al,40h		; make control character displayable

; normal character display

dc_3:
	call	display
dc_4:
	pop	ax			; number of columns into ax
	pop	cx			; restore cx
	pop	si			; restore si
	ret

dc_tab:
	mov	al,' '
dc_tab_1:
	call	display
	loop	dc_tab_1
	jmp	short dc_4
display_char	endp
	


;******************************************************************************
;
;   beep		sound a beep via int10 (ttyoutput)
;
;==============================================================================

beep		proc	near
	mov	ax,(0eh shl 8) + bell		; tty output
	int	video_int
	ret
beep	endp

;******************************************************************************
;
;	dumphist	dump the history buffer to console output
;			al = non-zero if we want line numbers and <more>
;			  (rows must be set to the size of the screen if so)
;
;==============================================================================


dumphist	proc	near

;	*note:  We use the high bit of bx to indicate the need to
;		display a newline and a line number on the next character
;		displayed.  The reason for delaying the newline/line number
;		is that we don't want an extra line number on the end.

	mov	bx,8000h		; start line numbering at 1
;					;  bit7 means next char forces newline
	mov	si,buf_front
	cmp	si,buf_back		; is it a split buffer?
	jbe	dumphist_01		; skip if not

	mov	cx,buf_end
	sub	cx,si			; get length to end of buffer
	call	dumphist_doblock	; do a simple dump for now
	mov	si,buf_base
dumphist_01:
	mov	cx,buf_back
	sub	cx,si

dumphist_doblock:
	jcxz	xret_dumphist
dumphist_doblock_1:
	push	ax			; save <more> flag

	test	bh,80h			; time to do a line number?
	jz	dumphist_doblock_1ax	; brif not
	and	bh,7fh

	or	al,al			; suppress line numbering?
	jz	dumphist_doblock_cronly

	or	bx,bx
	jz	no_more_check

	mov	ax,bx
	xor	dx,dx
	div	rows			; time to do (more)?
	or	dx,dx			;  only if remainder == 0
	jnz	no_more_check

;	now display "press any key for more" and wait for key

	push	cx
	push	si
	mov	si,offset more_prompt
	call	dstring
	pop	si
	call	getkey
	pop	cx

no_more_check:
	inc	bx			; increment number
	call	newline
	mov	ax,bx
	call	decout_ax
	mov	al,':'
	call	display_char
	mov	al,' '
	cmp	si,buf_current		; are we at the current line?
	jnz	not_at_current_line
	mov	al,'>'			; display '>' pointing to it if so
not_at_current_line:
	call	display_char
	jmp	short dumphist_doblock_1ax

dumphist_doblock_cronly:
	or	bx,bx			; don't do newline on first line
	jz	dumphist_doblock_1ay
	call	newline
dumphist_doblock_1ay:
	inc	bx			; keep count of lines
dumphist_doblock_1ax:

	lodsb
	or	al,al
	jnz	dumphist_doblock_2

	or	bh,80h		; set flag for newline on next char.
	jmp	short dumphist_doblock_3

dumphist_doblock_2:
	call	display_char
dumphist_doblock_3:
	pop	ax			; restore <more> flag
	loop	dumphist_doblock_1

xret_dumphist:
	ret

dumphist	endp


	if	debug_version

;******************************************************************************
;
;   dumpdebug: debug hotkey displays buffer pointers
;
;==============================================================================

dk_cs	dw	0

dumpdebug	proc	near
	mov	dk_cs,cs
	mov	si,offset debug_info
dumpdebug_t1:
	call	newline
	call	dstring		; display a string
	lodsw
	mov	bx,ax
	mov	ax,[bx]
	call	hex16
	cmp	byte ptr [si],0
	jnz	dumpdebug_t1
;
	ret

debug_info:
	db	'segment = ',0
	dw	dk_cs
	db	'text_ptr = ',0
	dw	text_ptr
	db	'end_dsp = ',0
	dw	end_dsp
	db	'macro_ptr = ',0
	dw	macro_ptr
	db	'macro_base = ',0
	dw	macro_base
	db	'macro_last = ',0
	dw	macro_last
	db	'macro_end = ',0
	dw	macro_end
	db	'buf_base = ',0
	dw	buf_base
	db	'buf_end = ',0
	dw	buf_end
	db	'buf_front = ',0
	dw	buf_front
	db	'buf_back = ',0
	dw	buf_back
	db	'buf_current = ',0
	dw	buf_current
	db	0
;
dumpdebug	endp

	endif


;**************************************************************
;	display a crlf
;**************************************************************

newline	proc	near
	mov	al,cr
	call	display_char
	mov	al,lf
	jmp	display_char
newline	endp

;*********************************************************
;
;	display ax in decimal, leading zero suppressed
;	  trash ax,dx
;
;	Note: algorithm taken from code published by our esteemed leader
;	  years ago in his programming column in the MITS newsletter
;
;	may use up to 20 bytes of stack
;
;*********************************************************
word10	dw	10

decout_ax	proc	near
	xor	dx,dx
	assume	ds:nothing
	div	word10
	assume	ds:text
	or	ax,ax		; any remaining digits to display?
	push	dx		; save the units digit
	jz	decout_ax_1	; done if no more digits
	call	decout_ax	; do the rest recursively
decout_ax_1:
	pop	ax		; recover digit from stack
	add	al,'0'		; make it ascii
	jmp	display_char
decout_ax	endp


;**************************************
;       display zero terminated string at si. trash al,cx.
;         return si->after null
;**************************************
 
dstring_1:
        call    display_char
dstring:
        lodsb
        or      al,al
        jnz     dstring_1
dstring_ret:
        ret

	if	debug_version

hex16:
	push	ax
	mov	al,ah
	call	hex8
	pop	ax
hex8:
	push	ax
	shr	al,1
	shr	al,1
	shr	al,1
	shr	al,1
	call	hexnib
	pop	ax
hexnib:
	and	al,0fh
	add	al,90h
	daa
	adc	al,3ah
	daa
	jmp	display_char

	endif

;******************************************************************************
;			L O C A L    R O U T I N E S
;******************************************************************************
;******************************************************************************
;
;   display	display the processed character on the screen
;	          through dos_int function char_output
;   entry:	 al char
;
;	Note:  this code keeps cur_col and rows_advanced up to date.
;		It assumes that all characters displayed through here
;		take one column to display, except <cr>.
;
;==============================================================================

ifdef DBCS
	public	display
disp_flag	db	0		; 0=single, 1=lead byte, 2=tail byte
endif

display	proc	near
	assume	ds:text,es:nothing


ifdef DBCS				; if DBCS ----------------------------
	cmp	disp_flag,1
	jz	set_dbcs		; if it was lead byte
	cmp	disp_flag,2
	jnz	@f			; if it was not tail byte
	mov	disp_flag,0		; reset
@@:
	call	IsDBCSLeadByte
	jnz	@f			; if this is not lead byte
set_dbcs:
	inc	disp_flag
@@:
	cmp	disp_flag,1
	jnz	@f			; if this is not lead byte
	mov	dl,[cur_col]
	inc	dl
	cmp	dl,byte ptr [num_cols]
	jb	@f			; if this is not last column
	push	ax
	mov	ah,char_output
	mov	dl,0			; mark it and go to next row
	int	dos_int
	pop	ax
	mov	[cur_col],0
	inc	[rows_advanced]
@@:
endif					; end if DBCS ------------------------

	mov	ah,char_output
	mov	dl,al
	int	dos_int

	xor	ah,ah		; reset column to zero if 'cr'
	cmp	al,cr
	je	prt_2

	mov	ah,[cur_col]
	inc	ah
	cmp	ah,byte ptr [num_cols]
	jb	prt_2

;	Note:  We come here if the display should have wrapped.  Unfortunately,
;	  there are times when ANSI.SYS (or another display driver) has wrap
;	  disabled.  Therefore, we must inquire the column number and force
;	  a CRLF if it is == [num_cols].

	push	bx
	push	cx
	mov	ah,3			; get cursor position
	mov	bh,[active_page]
	int	video_int
	pop	cx
	pop	bx
	inc	dl
	cmp	dl,byte ptr [num_cols]	; are we still at the end of line?
	jnz	prt_00a			; brif no need to force wrap

	mov	dl,0dh
	mov	ah,char_output
	int	dos_int
	mov	dl,0ah
	mov	ah,char_output
	int	dos_int

prt_00a:
	xor	ah,ah
	inc	[rows_advanced]
prt_2:
	mov	[cur_col],ah
	ret

display	endp

ifdef DBCS				; if DBCS ----------------------------
	public	read_character
;
;	Read Character at cursor
;
;	input:	dh = cursor row
;		dl = cursor column
;	output:	al = character
;
read_character		proc	near
	push	dx
	mov	cx,dx			; save original cursor position
	push	cx
	mov	ah,3			; get cursor position
	mov	bh,[active_page]
	int	video_int
	pop	cx
	xchg	dx,cx			; cursor position to read
	mov	ah,2			; set cursor
	int	video_int
	mov	ah,8			; read character
	int	video_int
	mov	dx,cx			; original cursor position
	mov	ah,2			; set cursor
	int	video_int
	pop	dx
	ret
read_character		endp
endif					; end if DBCS


text	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\doskey\template.asm ===
page	,132
;******************************************************************************
title TEMPLATE.ASM - DOSKey's keystroke handling
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;
include	gendef.inc
include dbcs.sw
include rombios.inc

; extended key / not extended key?

ext_key		equ	0
not_ext_key	equ	not ext_key

ifdef	DBCS
ifdef	KOREA
kbd_int         equ     16h
endif	; KOREA
endif	; DBCS

; Normal Keys, DOS compatible dispalay!  Keys from 20h (" ") to ffh are
; just passed to the display device as printable characters and receive
; no special consideration. The only exception to this is <ctrl_BACKSPACE>
; 7fh which is translated to a backspace.

; some not extended keys

ctrl_f	=	6
bell	=	7
bs	=	8
tab	=	9
cr	=	13
lf	=	10
ctrl_z	=	26
escape	=	27


; some extended keys

f_1	=	59
f_2	=	60
f_3	=	61
f_4	=	62
f_5	=	63
f_6	=	64
f_7	=	65
f_8	=	66
f_9	=	67
alt_f7	=	110
alt_f8	=	111
alt_f10	=	113

home_key =	47h
up	=	48h
pgup	=	49h
left	=	4bh
right	=	4dh
end_key	=	4fh
down	=	50h
pgdn	=	51h
ins	=	52h
del	=	53h

; extended control characters

ctrl_home =	77h
ctrl_end =	75h
ctrl_left =	73h
ctrl_right =	74h

lines_per_page = 24			; default screen height


text 	segment	byte public	'CODE'
	assume	cs:text,ds:text,es:text,ss:nothing

	extrn	dumphist:near
	if	debug_version
	extrn	dumpdebug:near
	endif
	extrn	dstring:near
	extrn	word10:word

	extrn	ansi_buf:byte
	extrn	rows:word
	extrn	d_mode:byte

	public	getkey

	extrn	number_of_display_columns:near
	extrn	get_video_mode:near
	extrn	get_cursor_pos:near
	extrn	set_cursor_type:near
	extrn	set_cursor_pos:near
	extrn	beep:near
	extrn	backspace:near
	extrn	display_char:near
	extrn	get_cur_line:near
	extrn	buffer_compare:near
	extrn	prev_line:near
	extrn	next_line:near

	extrn	buf_current:word
	extrn	buf_base:word
	extrn	buf_end:word
	extrn	buf_front:word
	extrn	buf_back:word
	extrn	macro_base:word
	extrn	macro_last:word

	extrn	default_insert:byte
	extrn	command_template:dword	; pointer to int 21(10) caller's buffer
	extrn	end_template:word	; length of template from command.com
	extrn	template:byte		 ; array of locations
	extrn	output:byte		 ; array of locations
	extrn	f9_buf:byte,f9_buf_end:byte

	extrn	end_dsp:word		 ; end of current template displayed
	extrn	cur_ptr:word		 ; current position in template

	extrn	oper_flags:byte		 ; insert mode
					 ; edited?
	extrn	num_prompt:byte
	extrn	more_prompt:byte
	extrn	cur_col:byte
	extrn	over_cursor:word
	extrn	mark_row:byte
	extrn	mark_col:byte

ifdef DBCS
	extrn	DBCSLeadByteTable:dword
	extrn	read_character:near
	extrn	num_cols:word
	extrn	rows_advanced:byte
	extrn	display:near
endif

;	the operating environment of all of these routines is
;	  ds and es -> text (resident data).

;******************************************************************************
;
;   fresh_template	perform any desired editing functions on the
;			template.  There may be some invisible stuff there,
;			but we'll start with the DISPLAYABLE end == 0
;
;==============================================================================

	public	fresh_template
fresh_template	proc	near
	call	copyin_template		; get template from command.com
	mov	[end_dsp],0
	mov	[cur_ptr],0		; start at beginning
	and	[oper_flags],(not ins_mode) and (not edited)
	push	ds
	xor	ax,ax
	mov	ds,ax
	and	byte ptr ds:417h,7fh	; reset INSERT mode in ROM BIOS DATA
	pop	ds
	call	get_video_mode		; video mode for display

	cmp	[default_insert],0
	jz	fresh_01
	call	ins_t			; toggle insert mode ON
fresh_01:

edtemp_1:
	call	getkey
	call	process_key		; process_key will skip one level
					;  of return address when the user
					;  presses a <cr> or when another
					;  special termination case exists
	jmp	edtemp_1		; loop as long as process_key returns

fresh_template	endp

;******************************************************************************
;
;   copyin_template	copy the template passed by command.com into template[]
;
;==============================================================================

copyin_template	proc	near
	lds	si,[command_template]	; fetch up the old command
	assume	ds:nothing
	mov	di,offset template
	inc	si			; throw away first byte
	lodsb				; get the count byte
	mov	cl,al
	xor	ch,ch
	cmp	cx,LINE_LEN-1		; in case that field was undefined
	jbe	copyin_01
	mov	cx,LINE_LEN-1		;  limit length to LINE_LEN
copyin_01:
	mov	[end_template],cx	; save it
	jcxz	copyin_03		; done if zero length line
copyin_02:
	lodsb				; get the byte
	cmp	al,cr			;  done if <cr>  (sometimes we seem
;					;  to get single <cr> in the buffer
;					;  with a non-zero count.  This
;					;  causes a bug when COMMAND.COM's
;					;  template gets trashed by the
;					;  previous transient program
	jz	copyin_02a		; special exit if <cr>
	stosb
	loop	copyin_02
copyin_02a:
	sub	[end_template],cx	; adjust for <cr> & anything following
copyin_03:
	push	cs			; reset ds: -> text segment
	pop	ds
	assume	ds:text
	ret
copyin_template	endp

;******************************************************************************
;			L O C A L    R O U T I N E S
;******************************************************************************

;	note:  the value tables are stored in reverse order from the
;	   associated dispatch tables.  this allows us to use the
;	   value of cx after the scasb instruction as our index into
;	   the branch tables.

norm_key_table	label	byte
	db	cr
	db	lf
	db	escape
	db	bs
	db	ctrl_f
	db	ctrl_f			; will never match second duplicate
					; so if we end up with cx=0, do default
norm_key_table_siz =	$ - norm_key_table

norm_key_dispatch	label	word
	dw	char_t			; default case!
	dw	dummy_t
	dw	bs_t
	dw	esc_t
	dw	dummy_t
	dw	ret_t

;	dispatch table for extended keys

alt_key_table	label	byte
	if	debug_version
	db	alt_f8
	endif
	db	alt_f10
	db	alt_f7
	db	f_9
	db	f_8
	db	f_7
	db	ctrl_right
	db	ctrl_left
	db	ctrl_home
	db	ctrl_end
	db	f_6
	db	f_5
	db	f_4
	db	f_3
	db	f_2
	db	f_1
	db	del
	db	ins
	db	end_key
	db	home_key
	db	down
	db	up
	db	left
	db	right
	db	pgup
	db	pgdn
	db	pgdn			; duplicate for default case
alt_key_table_siz	= $ - alt_key_table

alt_key_dispatch	label	word
	dw	dummy_t			; default means ignore
	dw	pgup_or_dn_t
	dw	pgup_or_dn_t
	dw	right_t
	dw	left_t
	dw	up_t
	dw	down_t
	dw	home_t
	dw	end_t
	dw	ins_t
	dw	del_t
	dw	right_t
	dw	f2_t
	dw	f3_t
	dw	f4_t
	dw	f5_t
	dw	f6_t
	dw	ctrl_end_t
	dw	ctrl_home_t
	dw	ctrl_left_t
	dw	ctrl_right_t

	dw	f7_t
	dw	f8_t
	dw	f9_t
	dw	af7_t
	dw	af10_t
	if	debug_version
	dw	af8_t
	endif
	

;******************************************************************************
;
;   process_key		perform whatever action is needed for key in ax
;			RETURNS ONE LEVEL UP WHEN TERMINATION CONDITION EXISTS
;
;   trashes:  just about everything except segment registers
;
;==============================================================================

process_key	proc	near

	mov	di,offset norm_key_table ; set up for normal key dispatch
	mov	cx,norm_key_table_siz
	mov	bx,offset norm_key_dispatch

	cmp	ah,ext_key
	jnz	prockey_2

	mov	di,offset alt_key_table	; dispatch alternate keys then
	mov	cx,alt_key_table_siz
	mov	bx,offset alt_key_dispatch

prockey_2:
	repne	scasb			; the cx == 0 case means no match
	shl	cx,1			; convert count to word index
	add	bx,cx			; index into branch table

;	note:  some functions may assume that al still contains the character

	jmp	word ptr [bx]		; perform action

process_key	endp

;	the processing routines are generally free to trash any registers
;	  they like.  Some of them are called from the others.  A few
;	  have special register behavior for this reason.

;******************************************************************************
;
;   ret_t	- user typed a <cr>  Display it and return one level back
;
;  entry - al still has <cr>
;
;==============================================================================

ret_t	proc	near

	push	ax
	call	end_t			; be sure that cursor is at last row
	pop	ax

	call	display_char
return_from_mainloop:
	mov	cx,[over_cursor]
	call	set_cursor_type		; restore original cursor type
	pop	ax		; get rid of normal return from process_key
;	ret			; fall into dummy_t for return
ret_t	endp

;******************************************************************************
;  dummy_t .. just a return (to be used when some key is to be ignored
;******************************************************************************

dummy_t	  	proc	near
	ret
dummy_t		endp

;******************************************************************************
;
;   pgup_or_dn_t	skip directly to newest/oldest line in history
;
;	entry:  uses al==pgup to distinguish up case from down case
;
;==============================================================================

pgup_or_dn_t	proc	near
	cmp	[buf_current],0
	jz	dummy_t		; do nothing if empty workspace
	push	ax		; save pgup or pgdn character
	call	esc_t		; cancel any current line
	mov	ax,[buf_front]
	mov	[buf_current],ax
	pop	ax
	cmp	al,pgup
	jz	pgup_or_dn_t_nobackup
	mov	ax,[buf_back]	; point to end
	mov	[buf_current],ax
	call	prev_line	; back up one line if it was a pgdn
pgup_or_dn_t_nobackup:
	jmp	get_current_line
pgup_or_dn_t	endp


;******************************************************************************
;
;   left_t	shifts back one char in the template
;
;	note:  frequently called internally.  Returns zero flag true
;	       if we couldn't backup cuz [cur_ptr] was already zero.
;
;==============================================================================

ifdef	DBCS
ifdef   KOREA
; We need another left operation when we get left arrow key after during
; we write interim.
InterimOneLeft:
        mov     WasInterimFlag, 0
endif	; KOREA
endif	; DBCS

left_t	proc	near

	cmp	[cur_ptr],0		; if cur_ptr == 0, exit
	je	leftt_1

	dec	[cur_ptr]
	mov	si,[cur_ptr]
	mov	cl,output[si]
	xor	ch,ch

ifdef DBCS				; if DBCS ----------------------------
	call	CheckDBCSTailByte
	jnz	@f			; if not at tail byte
	cmp	si,0
	jz	@f			; if cur_ptr at top
	dec	[cur_ptr]		; pass DBCS tail byte
	add	cl,output[si-1]		; backspace for lead byte
@@:
	push	cx
	call	get_cursor_pos
	pop	cx
	mov	bl,[mark_col]		; save current column
	push	bx
	call	backspace		; backspace
	pop	bx

	cmp	bl,0
	jnz	@f			; if it was not at top of row
	mov	dl,byte ptr [num_cols]
	dec	dl			; last column
	mov	dh,[mark_row]
	call	read_character
	cmp	al,0
	jnz	@f			; if not ajusted
	mov	cx,1
	call	backspace
@@:
ifdef   KOREA                           ;
        cmp     WasInterimFlag, 1       ; Previous char are final, then
        je      InterimOneLeft          ; We
        mov     WasInterimFlag, 0
endif   ; KOREA
else					; if Not DBCS ------------------------

	call	backspace		; backspace so many times

endif					; end if Not DBCS --------------------

	or	al,1			; reset zero flag cuz we did backup
leftt_1:
	ret
left_t	endp


;******************************************************************************
;
;   right_t (or f1)	move right one character, set zero flag if at end
;
;==============================================================================

right_t	proc	near

	mov	si,[cur_ptr]		; get cursor
	cmp	si,[end_dsp]		; at end of displayed stuff?
	jb	rightt_01		; go ahead if not

;	well, they MUST be equal if we get here, cuz the cursor should
;	   never be past the displayed part of the line

	cmp	si,[end_template]	; is there invisible stuff at end?
	jz	rightt_09		;  return with zero true of not
	inc	[end_dsp]		; accept one more character

rightt_01:

	mov	al,template[si]		; display it, keep track of columns
	call	display_char
 	mov	output[si],al
	inc	[cur_ptr]		; will always reset zero flag

ifdef DBCS				; if DBCS ----------------------------
	mov	al,template[si]
	call	IsDBCSLeadByte
	jnz	@f			; if it was not lead byte
	inc	si
	cmp	si,[end_dsp]
	jb	rightt_tail_byte	; if not at end of displayed stuff
	cmp	si,[end_template]
	jz	@f			; if at end
	inc	[end_dsp]
rightt_tail_byte:
	mov	al,template[si]		; get the tail byte
	call	display_char
	mov	output[si],al
	inc	[cur_ptr]		; pass tail byte
@@:
	mov	al,[cur_col]
	inc	al
	cmp	al,byte ptr [num_cols]
	jnz	@f			; if this is not last column
	mov	si,[cur_ptr]
	cmp	si,[end_dsp]
	jz	@f			; if at end of displayed stuff
	mov	al,template[si]
	call	IsDbcsLeadByte
	jnz	@f			; if next character not lead byte
	mov	al,0
	call	display			; display dummy character
@@:
	or	al,1			; reset ZF
endif					; end if DBCS ------------------------

rightt_09:
	ret
right_t	endp


;******************************************************************************
;
;   home_t	move cursor to beginning of line
;
;==============================================================================

home_t	proc	near
	call	left_t
	jnz	home_t		; keep going as long as it could back up
	ret
home_t	endp

;******************************************************************************
;
;   end_t		advances cursor to end of displayed template
;
;==============================================================================

end_t	proc	near
	mov	si,[cur_ptr]		; are we at end of displayed line?
	cmp	si,[end_dsp]
	jz	xret_endt		; done if so
	call	right_t
	jmp	end_t			; keep on loopin'
xret_endt:
	ret
end_t	endp

;******************************************************************************
;
;   f3			advances cursor to end of hidden template
;
;==============================================================================

f3_t	proc	near
	call	right_t
	jnz	f3_t			; keep looping until end of line
xret_f3:
	ret
f3_t	endp

;******************************************************************************
;
;   del_t	deletes one character at cursor
;
;==============================================================================

del_t	proc	near
ifdef	DBCS
ifdef   KOREA                           ; If we get DEL key after final char
        cmp     WasInterimFlag, 1       ; then we must delete current final char
        jne     normal_del_t            ; We must delete a char at CCP
        call    TwoBackSpace
normal_del_t:
        mov     WasInterimFlag, 0
endif	; KOREA
endif	; DBCS

	mov	cx,1		; delete one character

ifdef DBCS
	mov	si,[cur_ptr]
	mov	al,template[si]		; get character at cursor
	call	IsDBCSLeadByte
	jnz	@f			; if not lead byte
	inc	cx			; erase tail byte also
@@:
endif

del_t	endp			; fall into delete_cx_chars

;******************************************************************************
;
;  delete_cx_chars	deletes cx characters at cursor
;
;==============================================================================

delete_cx_chars	proc	near
	push	cx			; save deletion count
	or	[oper_flags],edited
	call	count_columns_to_end	; how many columns does rest of line
					;  currently occupy?
	pop	bx			; restore deletion count

	mov	di,[cur_ptr]
	sub	[end_dsp],bx		; backup [end_dsp]
	jb	delcx_0			;  don't let it wrap past zero
	cmp	di,[end_dsp]		;  or even get below [cur_ptr]
	jbe	delcx_0a
delcx_0:
	mov	[end_dsp],di		; force [end_dsp] = [cur_ptr]
delcx_0a:

	lea	si,[di+bx]		; point to new under-cursor character
delcx_1:
	cmp	si,[end_template]	; are we past template?
	jae	delcx_2			; brif so
	mov	al,template[si]
	mov	template[di],al		; copy one character down
	inc	si
	inc	di
	jmp	delcx_1			;  and loop

delcx_2:
	mov	[end_template],di	; store new [end_template]

;	now all we have to do is:  save cursor, display rest of line,
;	  and display some number of spaces at the end

	push	cx			; save number of columns of old line
	call	get_cursor_pos		; get cursor position
	call	display_to_eol
	call	count_columns_to_end	; see how many it takes now
	pop	ax			; get old column count
	sub	ax,cx
	mov	cx,ax			; column count into cx

ifdef DBCS				; if DBCS ----------------------------
	inc	cx
	call	display_cx_spaces	; display blanks, reset cursor
	call	get_cursor_pos		; get cursor position
	mov	dl,[mark_col]
	inc	dl
	cmp	dl,byte ptr [num_cols]
	jnz	@f			; if this is not last column
	dec	dl
	mov	dh,[mark_row]
	call	read_character
	cmp	al,0
	jnz	@f			; if not adjusted
	inc	[mark_row]
	mov	[mark_col],0		; go to top of next row
	call	set_cursor_pos
@@:
	ret

else					; if Not DBCS ------------------------

	jmp	display_cx_spaces	; display blanks, reset cursor

endif					; end if Not DBCS --------------------

delete_cx_chars	endp

;******************************************************************************
;
;   bs_t  	Deletes the previous character
;
;==============================================================================

bs_t	proc	near
	cmp	[cur_ptr],0		; inhibit bs in column zero
	jz	bs_t_ret
	call	left_t

;	Now we want to delete the character and squeeze everything else
;	  down, UNLESS we're at the end of the line, in which case we'll
;	  let the character stay in the buffer but just erase it from
;	  the screen.


ifdef DBCS				; if DBCS ----------------------------
	mov	si,[cur_ptr]
	mov	cl,output[si]
	xor	ch,ch
	mov	al,template[si]		; get current character
	call	IsDBCSLeadByte
	jnz	@f			; if not lead byte
	inc	si			; for tail byte
	add	cl,output[si]
@@:
	inc	si
	cmp	si,[end_dsp]
	jz	@f
	jmp	del_t			; if it is not last character
@@:
	mov	si,[cur_ptr]
	mov	[end_dsp],si

else					; if Not DBCS ------------------------

	mov	si,[end_dsp]	; chop last char if we're at end of display
	dec	si
	cmp	si,[cur_ptr]
	jnz	del_t			; delete character if not at end

	mov	[end_dsp],si	; back up the display
	mov	cl,output[si]	; get number of columns it took

endif					; end if Not DBCS ---------------------

	jmp	gc_and_disp_cx	; blank out the character

bs_t_ret:
	ret
bs_t	endp

;******************************************************************************
;
;   ctrl_home_t	deletes to beginning of line
;
;==============================================================================

ctrl_home_t	proc	near
	push	[cur_ptr]	; get cursor pointer
	call	home_t		; move cursor to home
	pop	cx		; get count to delete
	jmp	delete_cx_chars	; delete up to cursor
ctrl_home_t	endp

;******************************************************************************
;
;   ctrl_end_t	deletes to end of line
;
;==============================================================================

ctrl_end_t	proc	near

	call	count_columns_to_end	; how many columns is rest of line?
	mov	si,[cur_ptr]
	mov	[end_template],si 	; delete rest of template
	mov	[end_dsp],si

ifdef DBCS
	inc	cx
endif

	jmp	gc_and_disp_cx		; erase rest of line, reset cursor
ctrl_end_t	endp

;******************************************************************************
;
;   ctrl_left_t	go to start of previous word
;
;==============================================================================

ctrl_left_t	proc	near

c_leftt_1:
	call	left_t		; first take care of adjacent whitespace
	mov	si,[cur_ptr]
	or	si,si
	jz	xret_crightt  	; if we are at beg. of line we are done

	mov	al,template[si]
	call	is_whitespace
	jz	c_leftt_1	; if whitespace we need to retreat left.

c_leftt_2:
	mov	si,[cur_ptr]	; while (there's a column to our left) &&
	or	si,si		;  (it's contents are non-white)
	jz	xret_crightt	; return if at left border
	dec	si
	mov	al,template[si]
	call	is_whitespace
	je	xret_crightt	; return if on whitespace
	call	left_t		;  keep retreating cursor to the left
	jmp	c_leftt_2

ctrl_left_t	endp
	
;******************************************************************************
;
;   ctrl_right_t	move to beginning of next word
;
;==============================================================================

ctrl_right_t	proc	near

cright_01:
	mov	si,[cur_ptr]
	cmp	si,[end_template]	; are we at end of buffer?
	jz	xret_crightt		; done if so

	mov	al,template[si]		; are we on whitespace?
	call	is_whitespace
	je	c_rightt_2		; advance until so (or hit end)
	call	right_t
	jmp	short cright_01

c_rightt_2:
	call	right_t			; now advance until end or
	jz	xret_crightt

	mov	si,[cur_ptr]
	mov	al,template[si]		; find non-whitespace
	call	is_whitespace
	je	c_rightt_2

xret_crightt:
	ret
ctrl_right_t	endp


;******************************************************************************
;
;   f2_t	search for character in template
;
;==============================================================================

f2_t	proc	near

	call	getkey		; get the next char specified
	cmp	ah,ext_key	; extended key?
	je	xret_f2		; yes .. exit

;	search for the key in template.  if found advance number of chars
	
	mov	si,[cur_ptr]
	cmp	si,[end_template]	; have we hit end with no match?
	je	xret_f2			; done if so
f2t_1:
	inc	si			; skip one character
	cmp	si,[end_template]	; at end?
	je	xret_f2

ifdef DBCS
	push	ax
	mov	al,template[si-1]
	call	IsDBCSLeadByte
	pop	ax
	jnz	@f			; if not DBCS lead byte
	inc	si			; pass tail byte
	cmp	si,[end_template]
	jz	xret_f2			; if it is end
@@:
endif

	cmp	template[si],al		; compare the characters
	jne	f2t_1			; loop if new character doesn't match

;	if we've gotten here, we know that we've advanced si at least
;	  once.  Therefore, there's no need to pre-test for si=[cur_ptr]

f2t_2:
	push	si
	call	right_t			; advance one position
	pop	si
	cmp	si,[cur_ptr]
	ja	f2t_2			; loop until we reach match

xret_f2:
	ret
f2_t	endp


;******************************************************************************
;
;   f4t		Delete chars till char specified
;
;==============================================================================
f4_t	proc	near
	call	getkey		; get the next char specified
	cmp	ah,ext_key	; extended key?
	je	xret_f2		; yes .. exit

;	search for the key in template.  if found delete till character
	
	mov	si,[cur_ptr]
	cmp	si,[end_template]
	je	xret_f2		; brif hit end with no match

f4t_1:
	inc	si		; pre-increment
	cmp	si,[end_template]
	je	xret_f2		; done if at end, no match

ifdef DBCS
	push	ax
	mov	al,template[si-1]
	call	IsDBCSLeadByte
	pop	ax
	jnz	@f			; if not DBCS lead byte
	inc	si			; pass tail byte
	cmp	si,[end_template]
	jz	xret_f2			; if end
@@:
endif

	cmp	template[si],al	; compare the characters
	jne	f4t_1		; loop if no match

	sub	si,[cur_ptr]	; how many shall we delete?
	mov	cx,si		; we incremented si at least once, cx != 0
	jmp	delete_cx_chars

f4_t	endp


;******************************************************************************
;
;   f6_t		(puts ctrl_Z in template)
;
;==============================================================================

f6_t	proc	near
	mov	al,ctrl_Z
	jmp	char_t
f6_t	endp

;******************************************************************************
;
;   af7_t	erase the history queue
;
;==============================================================================

af7_t	proc	near
	mov	ax,buf_base
	mov	buf_front,ax
	mov	buf_back,ax
	mov	buf_current,0
	ret
af7_t	endp

;******************************************************************************
;
;   f7_t	lists the entire command queue
;
;==============================================================================

f7_t	proc	near

;	first find out how many lines are on the screen for accurate paging


	mov	ax,440ch		; ANSI_GET
	mov	bx,2			; STDERR
	mov	cx,37fh			; get subfunction
	mov	dx,offset ansi_buf	; point to result buffer
	int	21h			

	jc	ansi_error		; branch if error from ANSI

	cmp	d_mode,1
	jz	rows_all_set		; done if in text mode

ansi_error:

;	Get screen height from ROM BIOS data area in ANSI's absence

ifndef JAPAN				; if Not JAPAN

	push	ds
	mov	ax,ROMBIOS_DATA 	;Get ROM Data segment
	mov	ds,ax
	Assume	DS:ROMBIOS_DATA

	mov	al,CRT_Rows		;Get max rows
	pop	ds
	Assume	DS:text

	or	al,al			;If zero specified
	jnz	@F

endif					; end if Not DBCS

	mov	al,lines_per_page	;assume 24 rows

@@:
	xor	ah,ah
	mov	rows,ax 		; set default

rows_all_set:
	dec	rows			; leave last line for (more)
	call	esc_t			; delete any input
	mov	al,1			; force <more> prompts
	call	dumphist
	jmp	return_from_mainloop	;  return a blank line so we get
;					;  re-prompted
f7_t	endp

;******************************************************************************
;
;   f8_t	scan back through history buffer looking for match
;		of characters up to cur_ptr
;
;==============================================================================

f8_t	proc	near
	mov	si,buf_current		; get original current pointer
					;  for termination test
f8_t1:
	push	si

	mov	si,buf_current
	cmp	si,buf_front		; in this case only, we'll wrap to back
	jnz	f8_t2
	mov	si,buf_back
	mov	buf_current,si
	pop	si
	cmp	si,buf_current		; does the wrap bring us back home?
	jz	f8_t3
	push	si			; re-save original pointer
f8_t2:

	call	prev_line
	mov	di,offset template
	mov	bx,[cur_ptr]		; compare this far
	call	buffer_compare		; see if we match that much
	jz	f8_matched
	pop	si
f8_t3:
	cmp	si,buf_current
	jnz	f8_t1			; loop until we go all the way 'round
	ret				; done.  No match, no change.

f8_matched:
	pop	si
	push	[cur_ptr]
	call	esc_t			; erase previous input
	call	get_current_line
	pop	ax			; get match length pointer
	mov	cx,[cur_ptr]		; get end of new line
	sub	cx,ax			; back up this much

;	we know cx can't be less than zero because we matched orig.cur_ptr
;	  bytes out of the current string

	jcxz	f8_ret
f8_backup:
	push	cx
	call	left_t		; backup cursor to match point
	pop	cx
	loop	f8_backup
f8_ret:
	ret
f8_t	endp

;******************************************************************************
;
;   f9_t	prompt for a decimal line number and skip there
;
;==============================================================================
	public	f9_t

f9_t	proc	near
	cmp	[buf_current],0	; if workspace is empty, we can't function
	jnz	f9_t001
	ret			; do nothing



f9_bs:
	cmp	si,offset f9_buf
	jbe	f9_t1		; can't bs past front of buffer
	dec	si
	mov	cl,[mark_row]
	mov	ch,[mark_col]	; save mark_row/mark_col for restore
	push	cx
	mov	cx,1
	call	backspace
	mov	al,' '		; destructive bs
	call	display_char
	mov	cx,1
	call	backspace
	pop	cx
	mov	[mark_row],cl
	mov	[mark_col],ch
	jmp	short f9_t1

f9_t001:
	call	esc_t		; delete any input
	call	get_cursor_pos
	mov	si,offset num_prompt
	call	dstring
	mov	si,offset f9_buf
f9_t1:
	call	getkey
	sub	ah,not_ext_key	; force ah=0 if non-extended
	jnz	f9_t1		; ignore extended keys
	cmp	al,escape
	jz	f9_esc
	cmp	al,cr
	jz	f9_cr		; done if cr
	cmp	al,bs
	jz	f9_bs
	cmp	al,'0'
	jb	f9_t1		; ignore non-decimal
	cmp	al,'9'
	ja	f9_t1
	cmp	si,offset f9_buf_end
	jae	f9_t1		; don't accept chars past end of buffer
	mov	[si],al
	inc	si
	call	display_char	; echo it
	jmp	f9_t1

f9_cr:
	mov	cx,si
	mov	si,offset f9_buf
	sub	cx,si		; see how many characters we've got in buffer
	xor	ax,ax		; accumulator
	jcxz	f9_esc

f9_cra:
	mul	word10
	mov	bx,ax
	lodsb
	sub	al,'0'
	xor	ah,ah
	add	ax,bx
	loop	f9_cra

	mov	bx,ax

	mov	ax,[buf_front]		; point after last line
	mov	[buf_current],ax
	mov	cx,bx		; line count
	sub	cx,1		; make 0 = 1, advance in neither case
	jbe	f9_t4
f9_t3:
	push	cx
	call	next_line
	pop	cx
	mov	ax,buf_current
	cmp	ax,buf_back	; are we at end?
	jz	f9_t3x		; exit loop if at end
	loop	f9_t3
	jmp	short f9_t4

f9_t3x:
	call	prev_line	; stick on last line

f9_t4:
	xor	al,al		; not escape flag
f9_esc:
	push	ax		; save zero or escape
	push	word ptr [cur_col] ; save current cursor column
	call	set_cursor_pos
	pop	ax		; restore end of text column
	sub	al,[cur_col]
	xor	ah,ah
	mov	cx,ax
	call	display_cx_spaces ; erase stuff with spaces
	pop	ax
	cmp	al,escape
	jnz	get_current_line ; call up the selected line
	ret
f9_t	endp

;******************************************************************************
;
;   af10_t	erase the entire macro table
;		   (without reallocating memory to history)
;
;==============================================================================

af10_t	proc	near
	mov	ax,macro_base
	mov	macro_last,ax
	ret
af10_t	endp


	if	debug_version

;******************************************************************************
;
;   af8_t
;   description: debug hotkey displays buffer pointers
;
;==============================================================================

af8_t	proc	near
	call	esc_t		; delete any input
	call	dumpdebug	; display debug info
	jmp	return_from_mainloop	;  return a blank line so we get
;					;  re-prompted
af8_t	endp

	endif

;******************************************************************************
;
;   esc_t	Invalidates the current editing on the template
;		 and starts fresh with the current template
;
;==============================================================================

esc_t	proc	near
	call	home_t		; move cursor to home
	call	ctrl_end_t	; delete to end of line
	and	[oper_flags],not edited
	jmp	copyin_template	; get a new copy of template
esc_t	endp

;******************************************************************************
;
;   f5_t	Clear the line on the screen, continue using current
;		 template.
;
;==============================================================================

f5_t	proc	near
	push	[end_template]	; save length of current template
	call	home_t		; move cursor to home
	call	ctrl_end_t	; delete to end of line
	pop	[end_template]	; leave template that same size
	and	[oper_flags],not edited
	ret

f5_t	endp


;******************************************************************************
;
;   get_current_line  Retrieves current line from buffers and displays it
;
;==============================================================================

get_current_line	proc	near

ifdef DBCS
	call	get_cursor_pos
endif

	mov	di,offset template
	call	get_cur_line
	mov	[end_dsp],cx		; set end of line pointers
	mov	[end_template],cx
	mov	[cur_ptr],0
;
;	display the template
;
	push	cx		; save line length count
	call	display_to_eol
	pop	[cur_ptr]	; cursor is at end of line
 	ret

get_current_line	endp

;******************************************************************************
;
;   up_t	gets previous command and displays it for editing. if there
;		 is no present command, the current command in buffers 
;		 is gotten
;
;==============================================================================

up_t	proc	near
	call	prev_line
	call	esc_t			; common processing
upt_01:
	jmp	get_current_line
up_t	endp

;******************************************************************************
;
;   down_t 	Makes next command the current and displays it for 
;		editing.  if there is not current command then the
;		current one in buffers is fetched
;
;==============================================================================

down_t	proc	near
	cmp	[end_dsp],0
	je	downt_01
	call	esc_t
	call	next_line		; bump pointer to next line
downt_01:
	jmp	get_current_line
down_t	endp

;******************************************************************************
;
;   ins		toggles the ins_mode bit in the flags
;
;==============================================================================

ins_t	proc	near
	xor	[oper_flags],ins_mode
;M001	push	ds
;M001	xor	ax,ax
;M001	mov	ds,ax
;M001	xor	byte ptr ds:417h,80h	; toggle INSERT bit in ROM BIOS DATA
;M001	pop	ds
	mov	al,[default_insert]
	xor	al,[oper_flags]		; are we in "alternate" mode?
	test	al,ins_mode
	push	cx
	mov	cx,[over_cursor]
	jz	ins_t1			; brif not insert mode
	sub	ch,2			; back off
	ja	ins_t1			; but not past 0
	xor	ch,ch
ins_t1:
	call	set_cursor_type
	pop	cx

;	M001 -- begin additions

	push	ds
	xor	ax,ax
	mov	ds,ax
	assume	ds:nothing
	and	byte ptr ds:417h,7fh	; force ROM BIOS insert flag off
	test	cs:[oper_flags],ins_mode
	jz	not_rep_mode
	or	byte ptr ds:417h,80h	; turn it on if in insert mode
not_rep_mode:
	pop	ds
	assume	ds:text

;	M001 -- end additions

xret_ins:
	ret
ins_t	endp

;******************************************************************************
;
;   char_t	al = character to put in template
;
;==============================================================================

char_t	proc	near

ifdef DBCS				; if DBCS ----------------------------

	jmp	dbcs_char_t

else					; if Not DBCS ------------------------

	or	[oper_flags],edited
	test	[oper_flags],ins_mode
	jne	chart_1			; brif insert mode

	mov	si,[cur_ptr]
	cmp	si,LINE_LEN-1
	jae	near_beep		; just beep if at end of buffer

	mov	si,[cur_ptr]

	mov	template[si],al		; stick character into array
	call	display_char		; display the new character
	mov	si,[cur_ptr]
	xchg	al,output[si]		; save # columns it took
	sub	al,output[si]		; how many fewer columns new char took

	inc	si
	mov	[cur_ptr],si
	cmp	si,[end_dsp]		; incr [end_dsp] & [end_template]?
	jbe	char_t_opt_01
	inc	[end_dsp]
	cmp	si,[end_template]
	jbe	char_t_opt_01
	inc	[end_template]
char_t_opt_01:

	or	al,al			; did new & old take same # columns?
	jz	xret_ins		; all finished if so

	push	ax			; save # of columns we're different by
	call	get_cursor_pos		; this is where cursor will end up
	pop	ax

	mov	si,[cur_ptr]		; display until eol or columns match
char_t_opt_02:
	cmp	si,[end_dsp]
	jz	char_t_opt_03		; done if at end of line

	push	ax
	mov	al,template[si]		; get next character
	call	display_char		;  and display it
	mov	cl,al			; get number of columns it took into cl
	pop	ax
	add	al,output[si]		; keep track of old vs. new columns
	mov	output[si],cl		; save # columns
	inc	si
	sub	al,cl			; keep running track
	jnz	char_t_opt_02		; loop only until/unless columns match

char_t_opt_03:
	cbw				; get # spaces needed at end
	mov	cx,ax			; into cx
	jmp	display_cx_spaces	; do spaces, reset cursor

;	okay.  Now we're going to insert a character into the template

chart_1:
	mov	si,[end_dsp]
	cmp	si,LINE_LEN-1
	jb	chart_2			; brif room to insert
near_beep:
	jmp	beep			; can't do it if it's full

chart_2:

	mov	si,[end_template]
	cmp	si,LINE_LEN-1		; was line already full?
	jz	chart_2a		; skip if so
	inc	si
	mov	[end_template],si
chart_2a:
	cmp	si,[cur_ptr]
	je	chart_3
	dec	si
	mov	cl,template[si]
	mov	template[si][1],cl
	jmp	chart_2a

chart_3:
	mov	template[si],al
	inc	[end_dsp]
	call	display_char
	mov	output[si],al	; save the size of the inserted char
	inc	[cur_ptr]	; and bump cursor

	call	get_cursor_pos

	call	display_to_eol	; display the rest of the line

	jmp	set_cursor_pos

endif					; end if Not DBCS --------------------

char_t	endp


;******************************************************************************
;
;   count_columns_to_end	returns cx= number of columns between
;				[cur_ptr] and [end_dsp]
;
;==============================================================================

count_columns_to_end	proc	near
	mov	cx,0		; initialize count
	mov	si,[cur_ptr]
ccte_1:
	cmp	si,[end_dsp]	; are we at the end of the display?
	jae	xret_iswhite	; return if so
	mov	al,output[si]
	inc	si
	cbw
	add	cx,ax		; accumulate number of columns
	jmp	ccte_1
count_columns_to_end	endp

;******************************************************************************
;
;   display_to_eol	Displays the current template from cur_ptr to end_dsp
;
;==============================================================================

display_to_eol	proc	near

ifdef DBCS
	call	clear_to_eol
endif

	mov	si,[cur_ptr]
dteol_1:
	cmp	si,[end_dsp]
	jae	xret_iswhite		; return if at end
	mov	al,template[si]
	call	display_char
	mov	output[si],al
	inc	si
	jmp	dteol_1
display_to_eol	endp

;******************************************************************************
;
;   is_whitespace	sets zero flag if al is a space or a tab
;
;==============================================================================

is_whitespace	proc	near
	cmp	al,' '
	je	xret_iswhite
	cmp	al,tab
xret_iswhite:
      	ret
is_whitespace	endp

;******************************************************************************
;
;   getkey		Waits for key to be entered and returns it
;   exit:   		al= keystroke, ah= ext_key / not_ext_key
;
;	note that we won't execute a blocking call.  We'll go into a
;	polling loop and issue win386 idle signals while we wait.
;
;==============================================================================

getkeyx	proc	near

getkey_1:
	int	IDLE_INT	; signal an idle interrupt

	mov	ax,1680h
	int	I2f_INT		; and call in win386 to release current
				; vm's time slice
getkey:

ifdef   KOREA
; In KOREA, we can not use the DOS system call to get char from KBD because
; of some hangeul/hanja char has special scan code in AH. We must seperate it.
;       AH = 0f0h       : Interim Char
;            0f1h       : Final Char
;            0f2h       : Hanja Char which were conversioned at Current Cursor
;                         Position(CCP)
;

        mov     ah, CHECK_INPUT_INTERIM
        int     kbd_int
        jz      getkey_1                ; if no character, do idling stuff

;	character present in keyboard buffer, get it and if it is an
;       extended key then store AH value to AL
;	
        mov     ah, CHAR_INPUT_INTERIM
        int     kbd_int
        or      al, al                  ; ah = extended key value if exist
        jnz     getkey_3
;
;	extended key input
;
        mov     al, ah                  ; Store extended key
        mov     ah, ext_key             ; Mark it
        ret
getkey_3:
        mov     InterimFlag, 1
        cmp     ah, CHAR_INTERIM        ; Is it interim char?
        jz      getkey_4                ; Jump if yes
        mov     InterimFlag, 0          ; Default is final
        cmp     ah, HANJA_AT_CCP        ; Hanja at CCP
        jnz     getkey_4                ; Jump if not
        mov     InterimStart, 1         ; Must overwrite at CCP
getkey_4:
        mov     ah, not_ext_key         ; It isn't extended key
	ret

else

	mov	ah,CHECK_INPUT_STATUS
	int	DOS_INT
	or	al,al
	jz	getkey_1		; if no character, do idling stuff

;	character present in keyboard buffer, get it and if it is an
;	extended key then go to get the second character in the buffer.
;	
	mov	ah,char_inp_no_echo
	int	DOS_INT

	mov	ah,not_ext_key		; assume not extended key
	or	al,al
	jne	getkey_3

;
;	extended key input
;
	mov	ah,char_inp_no_echo
	int	DOS_INT
	mov	ah,ext_key
getkey_3:
	ret
endif   ; KOREA

getkeyx	endp


;**************************************************************
;	here are some useful display utility subroutines
;**************************************************************

;**************************************************************
;  gc_and_disp_cx	save cursor position and fall into display_cx_spaces
;**************************************************************
gc_and_disp_cx	proc	near
	push	cx
	call	get_cursor_pos		; mark cursor position for restoration
	pop	cx
gc_and_disp_cx	endp

;**************************************************************
;  display_cx_spaces	displays cx spaces and then jump to
;			set_cursor_pos, does no spaces if cx is <= 0
;**************************************************************

display_cx_spaces	proc	near
	cmp	cx,0
	jle	dcxs_done	; done if cx <= 0
dcxs_loop:
	mov	al,' '
	call	display_char
	loop	dcxs_loop
dcxs_done:
	jmp	set_cursor_pos
display_cx_spaces	endp

ifdef DBCS				; if DBCS ----------------------------
;
;	Clear till end of line
;
clear_to_eol		proc	near
	push	ax
	push	si
	push	word ptr [mark_row]
	mov	bh,[rows_advanced]
	mov	bl,[cur_col]
	push	bx
	call	count_columns_to_end	; how many columns is rest of line?
	xor	bh,bh
	add	bx,cx
	cmp	bx,[num_cols]
	jb	@f			; if only one row
	inc	cx
@@:
	call	gc_and_disp_cx
	pop	bx
	mov	[rows_advanced],bh
	mov	[cur_col],bl
	pop	word ptr [mark_row]
	pop	si
	pop	ax
	ret
clear_to_eol		endp
endif					; end if DBCS ------------------------

ifdef DBCS				; if DBCS ----------------------------
;
;	DBCS routine of char_t
;
;	input:	AL = character
;

dbcs_flag	db	0		; 0=sbcs, 1=lead byte, 2=tail byte
dbcs_char	db	0
refresh_flag	db	0
ifdef   KOREA
        public  InterimFlag
InterimFlag             db      0
WasInterimFlag          db      0
InterimStart            db      0
endif   ; KOREA

dbcs_char_t	proc	near
	cmp	dbcs_flag,1
	jz	chart_dbcs		; if this is tail byte
	cmp	dbcs_flag,2
	jnz	@f			; if previous was not tail byte
	mov	dbcs_flag,0		; reset flag
@@:
	call	IsDBCSLeadByte
	jnz	@f			; if this is not lead byte
chart_dbcs:
	inc	dbcs_flag		; 0=sbcs, 1=lead byte, 2=tail byte
@@:

	or	[oper_flags],edited
	test	[oper_flags],ins_mode
	je	@f

ifdef	KOREA
        cmp     InterimStart, 1
        je      @f
endif   ; KOREA

	jmp	chart_1
@@:
	mov	si,[cur_ptr]

	cmp	dbcs_flag,1
	jnz	chart_o_notlead		; if this is not lead byte
	cmp	si,LINE_LEN-2
	jnb	chart_o_full		; if no space for double byte
	push	ax
	mov	al,template[si]		; get current character
	call	IsDBCSLeadByte
	pop	ax
	jz	@f			; if overwrite DBCS to DBCS
	mov	si,[end_dsp]
	cmp	si,LINE_LEN-1
	jnb	chart_o_full		; if there is no space for tail byte
	call	ins_space		; save space for tail byte
	mov	refresh_flag,1
@@:
	mov	dbcs_char,al
	jmp	chart_ret
chart_o_full:
	call	getkey			; throw tail byte
	mov	dbcs_flag,0		; reset
chart_o_beep:
	jmp	beep
chart_o_notlead:

	cmp	dbcs_flag,2
	jz	chart_o_tail		; if this is tail byte
	cmp	si,LINE_LEN-1
	jae	chart_o_beep		; just beep if at end of buffer
	call	check_cur		; adjust cursor for wrap
	jnc	@f
	mov	refresh_flag,1
@@:
	push	ax
	mov	al,template[si]		; get current character
	call	IsDBCSLeadByte
	pop	ax
	jnz	@f			; if overwrite single to single
	call	clear_to_eol
	call	del_char
	mov	refresh_flag,1
	jmp	short @f
chart_o_tail:

ifdef   KOREA
        cmp     InterimFlag, 0
        mov     cl, [InterimStart]      ;
        mov     WasInterimFlag, cl      ; We wrote Final char previously
        mov     InterimStart, 0         ; Yes, we will write interim char
        je      YesFinal1
        mov     refresh_flag, 1
        mov     WasInterimFlag, 0       ; We wrote writing Interim
        mov     InterimStart, 1         ; Yes, we will write interim char
YesFinal1:
endif   ; KOREA

	xchg	al,dbcs_char		; get lead byte
@@:

	mov	template[si],al		; stick character into array
	call	display_char		; display the new character
	mov	si,[cur_ptr]
	mov	ch,al			; set new char length
	xchg	al,output[si]		; save # columns it took
	mov	cl,al			; set old char length
	inc	si
	mov	[cur_ptr],si

	cmp	dbcs_flag,2
	jnz	@f			; if this is not dbcs

	mov	al,dbcs_char		; get tail byte
	mov	template[si],al		; stick character into array
	call	display_char		; display the new character
	mov	si,[cur_ptr]
	add	ch,al			; add new char length
	xchg	al,output[si]		; save # columns it took
	add	cl,al			; add old char length
	inc	si
	mov	[cur_ptr],si
@@:
	sub	cl,ch
	mov	al,cl

	cmp	si,[end_dsp]		; incr [end_dsp] & [end_template]?
	jbe	char_t_opt_01
	mov	[end_dsp],si
	cmp	si,[end_template]
	jbe	char_t_opt_01
	mov	[end_template],si
char_t_opt_01:

	cmp	refresh_flag,0
	jz	@f
	mov	refresh_flag,0
	call	get_cursor_pos
	call	display_to_eol

ifdef	KOREA
        cmp     InterimFlag, 0          ; Is it final char?
        je      YesFinal
        call    set_cursor_pos
        call    TwoBackSpace
        ret
YesFinal:
        jmp     set_cursor_pos
else
        jmp     set_cursor_pos
endif   ; KOREA

@@:

	or	al,al			; did new & old take same # columns?
	jnz	@f
	jmp	chart_ret		; all finished if so
@@:

	push	ax			; save # of columns we're different by
	call	get_cursor_pos		; this is where cursor will end up
	pop	ax

	mov	si,[cur_ptr]		; display until eol or columns match
char_t_opt_02:
	cmp	si,[end_dsp]
	jz	char_t_opt_03		; done if at end of line

	push	ax
	mov	al,template[si]		; get next character
	call	display_char		;  and display it
	mov	cl,al			; get number of columns it took into cl
	pop	ax
	add	al,output[si]		; keep track of old vs. new columns
	mov	output[si],cl		; save # columns
	inc	si
	sub	al,cl			; keep running track

	jnz	char_t_opt_02		; loop only until/unless columns match

char_t_opt_03:
	cbw				; get # spaces needed at end
	mov	cx,ax			; into cx
	jmp	display_cx_spaces	; do spaces, reset cursor

;	okay.  Now we're going to insert a character into the template

chart_1:
	mov	si,[end_dsp]

	cmp	dbcs_flag,1
	jnz	chart_i_notlead		; if this is not lead byte
	cmp	si,LINE_LEN-2
	jnb	@f			; if there no space for tail byte
	mov	dbcs_char,al
	jmp	short chart_ret
@@:
	call	getkey			; throw tail byte
	mov	dbcs_flag,0		; reset
chart_i_beep:
	jmp	beep
chart_i_notlead:

	cmp	dbcs_flag,2
	jz	chart_i_tail

	cmp	si,LINE_LEN-1
	jnb	chart_i_beep		; no room to insert
	call	check_cur		; adjust cursor for wrap
	jmp	short @f
chart_i_tail:
	xchg	al,dbcs_char
@@:

	call	ins_space
	mov	si,[cur_ptr]
	mov	template[si],al
	call	display_char
	mov	output[si],al		; save the size of the inserted char
	inc	[cur_ptr]		; and bump cursor

	cmp	dbcs_flag,2
	jnz	@f			; if this is not dbcs
	mov	al,dbcs_char
	call	ins_space
	mov	si,[cur_ptr]
	mov	template[si],al
	call	display_char
	mov	output[si],al		; save the size of the inserted char
	inc	[cur_ptr]		; and bump cursor
@@:

	call	get_cursor_pos
	call	display_to_eol		; display the rest of the line

ifdef   KOREA
        cmp     InterimFlag, 0
        je      YesFinal2
        mov     InterimStart, 1
        call    set_cursor_pos
        call    TwoBackSpace
        ret
YesFinal2:
        jmp     set_cursor_pos
else
	jmp	set_cursor_pos
endif   ; KOREA

chart_ret:
	ret
dbcs_char_t	endp

;
;	Insert one space
;
ins_space	proc	near
	push	ax
	push	si
	mov	si,[end_template]
	cmp	si,LINE_LEN-1		; was line already full?
	jz	inss_loop		; skip if so
	inc	si
	mov	[end_template],si
inss_loop:
	cmp	si,[cur_ptr]
	je	@f			; if this is end
	dec	si
	mov	al,template[si]
	mov	template[si+1],al	; move template
	mov	al,output[si]
	mov	output[si+1],al		; move output
	jmp	inss_loop

@@:
	mov	template[si],' '
	mov	output[si],1
	inc	[end_dsp]

	mov	si,[end_template]
	call	CheckDBCSTailByte
	jz	@f			; if end char is tail byte
	mov	al,template[si]
	call	IsDBCSLeadByte
	jnz	@f			; if end char is not lead byte
	mov	template[si],' '
@@:

	pop	si
	pop	ax
	ret
ins_space	endp

;
;	Delete one character
;
del_char	proc	near
	push	ax
	push	si
	mov	si,[cur_ptr]
	cmp	si,[end_template]
	jnb	delc_end		; if this is at end
delc_loop:
	inc	si
	mov	al,template[si]
	mov	template[si-1],al	; move template
	mov	al,output[si]
	mov	output[si-1],al		; move output
	cmp	si,[end_template]
	jnz	delc_loop		; if this is end
delc_end:
	mov	template[si],' '
	mov	output[si],1
	dec	[end_template]
	mov	si,[cur_ptr]
	cmp	si,[end_dsp]
	jz	@f			; if at end
	dec	[end_dsp]
@@:
	pop	si
	pop	ax
	ret
del_char	endp

;
;	Check ajust mark at the cursor
;
check_cur	proc	near
	push	ax
	push	dx
	call	get_cursor_pos
	cmp	[mark_col],0
	jnz	cc_ok			; if not at top of row
	cmp	[cur_ptr],0
	jz	cc_ok			; if top of buffer
	mov	dh,[mark_row]
	cmp	dh,0
	jz	cc_ok			; if at top
	dec	dh			; previus row
	mov	dl,byte ptr [num_cols]
	dec	dl			; last column
	call	read_character
	cmp	al,0
	jnz	cc_ok			; if not adjusted
	mov	[mark_row],dh
	mov	[mark_col],dl
	call	set_cursor_pos
	stc
	jmp	short cc_ret
cc_ok:
	clc
cc_ret:
	pop	dx
	pop	ax
	ret
check_cur	endp

ifdef   KOREA
TwoBackSpace    proc
        mov     cx, 2
        call    backspace
        mov     si, [cur_ptr]
        sub     si, 2
        mov     [cur_ptr], si
        ret
TwoBackSpace     endp
endif   ; KOREA

endif					; end if DBCS ------------------------


ifdef DBCS
;****************************************************************************
;
;		Common Subroutines for DBCS version
;
;****************************************************************************

	public	IsDBCSLeadByte
;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;
IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	mov	ah,al			; save character to check
	lds	si,DBCSLeadByteTable	; get table address
test_lead_byte:
	lodsb				; get lower value
	or	al,al
	jz	not_lead_byte		; if at end of table
	cmp	ah,al
	jb	not_lead_byte		; if out of range
	lodsb				; get higher value
	cmp	ah,al
	ja	test_lead_byte		; if out of range do next
	and	al,0			; set ZF
	jmp	short test_lead_byte_end
not_lead_byte:
	or	al,1			; reset ZF
test_lead_byte_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp



	public	CheckDBCSTailByte
;
;	Check if the character position is at Tail Byte of DBCS
;
;	input:	template = start address of the string
;		si = character position to check
;	output:	ZF = 1 if at Tail Byte
;
CheckDBCSTailByte	proc	near
	push	ax
	push	bx
	push	si
	lea	bx,template[si]		; get current character address
	lea	si,template		; get start address
check_tail_byte:
	cmp	si,bx
	jz	not_tail_byte		; if at DBCS lead byte or single byte
	ja	tail_byte		; if at DBCS tail byte
	lodsb				; get character
	call	IsDBCSLeadByte
	jnz	check_tail_byte		; if not DBCS lead byte
	inc	si			; pass tail byte
	jmp	short check_tail_byte
not_tail_byte:
	or	al,1			; reset ZF
	jmp	short check_tail_byte_end
tail_byte:
	and	al,0			; set ZF
check_tail_byte_end:
	pop	si
	pop	bx
	pop	ax
	ret
CheckDBCSTailByte	endp

endif					; end of DBCS

text	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\doskey\buffer.asm ===
page	,132
;******************************************************************************
title BUFFER.ASM - buffer handler for doskey
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989
;
;	this is a new ultra-simple version which has minimal overhead
;	  the lines in the buffer are zero terminated.
;                    
;	the buffer is organized as follows:
;
;	the most common layout is the "split" configuration, where
;	  the free space is in the middle somewhere.
;
;	<n><e><3> 0  .  .  . <l><i><n><e><1> 0 <l><i><n><e><2><l><i>
;	 ^           ^        ^                 ^                    ^
;	 |           |        |                 |                    + buf_end
;	 |           |        |                 + buf_current
;	 |           |        + buf_front
;	 |          + buf_back
;	 + buf_base
;
;	at other times, the free space will be at the ends, thus:
;
;	 .  . <l><i><n><e><1> 0 <l><i><n><e><2> 0 <l><i><n><e><3> 0  .
;	 ^     ^                 ^                                   ^  ^
;	 |     |                 |                          buf_back +  |
;	 |     + buf_front       +buf_current                   buf_end +
;	 + buf_base
;
;	notes:
;		There will always be one unusuable byte in the buffer.
;		  This avoids the problem of not being able to distinguish
;		  an empty buffer from a full one.
;
;		By definition, the buf_current pointer will be a null when
;		  the buffer is completely empty.  At all other times, there
;		  will be at least one string, thus there will be at least
;		  one zero terminator.  This fact allows us to avoid
;		  doing lots of messy checks to prevent endless loops.

	include	gendef.inc		; get LINE_LEN

;******************************************************************************
;			I N S T A N C E    D A T A
; (This data is all collectively defined in win386.asm in the instance block)
;******************************************************************************
	extrn	buf_base:word		; base of buffer array
	extrn	buf_end:word		; end of buffer array
	extrn	buf_front:word		; first string in buffer
	extrn	buf_back:word		; after last string in buffer
	extrn	buf_current:word	; current line pointer
					
text 	segment	byte	public	'code'
	assume	cs:text, ds:nothing, es:nothing, ss:nothing

	public	buffer_compare
	public	next_line
	public	prev_line
	public	get_cur_line
	public	ins_new_line
	
;******************************************************************************
;
;   next_line		Advance a line further in the command history
;   uses 		al,cx,si
;
;==============================================================================

next_line	proc	near
	assume	ds:text,es:text
	mov	si,[buf_current]	; get current pointer
	or	si,si			;  current=null?
	jz	nl_return		; exit, nothing needs to be done
	
nl_0:
	cmp	si,[buf_back]		; are we at end of history already?
	jz	nl_4			; don't advance if so

	call	get_buflen		; get length left in buffer segment
	jcxz	nl_1

	xchg	si,di
	xor	al,al			; setup al=terminator for scanning
	repnz	scasb			; look for a null terminator
	xchg	si,di
	jz	nl_3			; found null.  Done.

	cmp	si,[buf_back]
	jz	nl_4			; stop at end of history
nl_1:
	mov	si,[buf_base]		; wrap around to physical buffer base
	jmp	nl_0

nl_3:
	cmp	si,[buf_back]		; don't let nxt_buf screw up when
	jz	nl_4			;  buf_back == buf_end
	call	nxtbuf_x		; prohibit certain end conditions
nl_4:
	mov	[buf_current],si	; save current pointer
nl_return:
	ret

next_line	endp

;******************************************************************************
;
;   prev_line		Retreat a line back in the command history
;   uses   		si,cx,al
;
;==============================================================================


prev_line	proc	near
	assume	ds:text,es:text

	std				; we'll be scanning backwards
	mov	si,buf_current
	or	si,si			; current=null?
	jz	pl_return		; exit, nothing needs to be done
	
pl_0:
	call	decr_pointer		; point back to the null
	jc	pl_4			; done if hit buf_front

pl_01:
	call	decr_pointer		; scan back for previous null
	jc	pl_4			; done if hit buf_front
	mov	al,[si]			; is this the previous null?
	or	al,al
	jnz	pl_01			; loop if not

	inc	si			; point past previous terminator
	call	nxtbuf_x		; make sure we're not at buf_end

pl_4:
	mov	[buf_current],si	; save current pointer
pl_return:
	cld
	ret

prev_line	endp

;	decr_pointer decrements si within the buffer.  It wraps from
;	  buf_base back to buf_end.  If it hits buf_front, it returns
;	  with carry set.

decr_pointer	proc	near
	cmp	si,buf_front
	stc
	jz	decr_pointer_9	; return with carry set if at buf_front

	cmp	si,buf_base
	jnz	decr_pointer_1
	mov	si,buf_end

decr_pointer_1:
	dec	si
	clc				; return with no carry

decr_pointer_9:
	ret

decr_pointer	endp


;******************************************************************************
;
;   get_cur_line  	Copies the current line into the buffer passed
;   entry:   		es:di: Buffer where the line is to be copied
;   exit:	   	cx: Size of line copied
;   uses		ax
;
;==============================================================================

get_cur_line  		proc	near
	assume	ds:text,es:nothing

	push	si
	xor	cx,cx
	mov	si,[buf_current]
	or	si,si		; is there a current line?
	jz	getcurlin_1
	cmp	si,[buf_back]	; or are we at end of buffer?
	jz	getcurlin_1

	push	di
	push	bx		; preserve caller's bx

	xor	bx,bx		; keep our count here
gcl_1:
	call	get_buflen
	jcxz	gcl_3		; skip if at end of buffer
gcl_2:
	lodsb			; load one byte
	or	al,al		; is this the end?
	jz	gcl_4		; skip if so
	stosb			; copy it
	inc	bx		; count it
	loop	gcl_2

;	we come here if we've scanned to end of source buffer segment
;	  without finding a null terminator.  this implies that
;	  we were at the end of the physical buffer in a split buffer
;	  configuration, otherwise we would've been guaranteed to find
;	  the null just before buf_back.

gcl_3:
	mov	si,[buf_base]	; continue scanning other buffer segment
	jmp	gcl_1

gcl_4:
	mov	cx,bx		; return the length
	pop	bx
	pop	di
getcurlin_1:
	pop	si
	ret

get_cur_line	endp	



;******************************************************************************
;
;   ins_new_line	Inserts a line at the end of the history
;   entry:		ds:si line, cx=length
;   trash:		ax, bx
;
;==============================================================================

ins_new_line	proc	near
	assume	ds:text,es:text

	push	di		; preserve caller's registers
	push	si
	push	cx

	inc	cx		; move one extra dummy byte for null

;	the procedure here is to start at buf_back and start copying
;	  the new data in.  By definition, we'll never insert a line
;	  bigger than the buffer.  Therefore, we won't check for it.

;	The tricky part here is to know when we've deleted data.
;	  Accumulate a flag byte in bl as follows:
;	   bits 7-3 same as bit 2
;	   bit 2 - buffer was initially in split configuration
;	   bit 1 - we wrapped around the end of physical buffer with insertion
;	   bit 0 - the final buf_back is >= buf_front (reached or passed it)
;
;	The logical formula for knowing when we've deleted data is as follows:
;	  if (initially split) then if wrapped or reached -> delscan
;	  else if wrapped and passed -> delscan
;
;	Which means bl == 3, 253, 254 and 255 indicate a deletion occurred.
;	  When this is the case, we have to scan forward from the new buf_back
;	  to find the next null, then advance one more place for
;	  the new buf_front

	mov	di,buf_back		; get end of buffer pointer
	cmp	di,buf_front		;  split buffer configuration?
	sbb	bl,bl			; fill bl with initially_split flag

	mov	ax,buf_end		; how much room to end of buffer?
	sub	ax,di
	cmp	ax,cx			; will we wrap 'round end?
	rcl	bl,1			; save the flag in flag byte
	test	bl,1
	jz	ins_nowrap		; skip if no wrap

	xchg	ax,cx
	sub	ax,cx			; this amount will go at front
	rep	movsb			; move the part to the end
	mov	di,buf_base		; and the rest will go here
	mov	cx,ax			; length remaining

ins_nowrap:
	rep	movsb			; move the rest
	cmp	di,buf_front		; did we reach or pass?
	cmc				; put flag into correct state
	rcl	bl,1			; get the reached flag

;	now if bl=3, 253, 254 or 255, we need to delete some data

	cmp	bl,3
	jz	inl_delscan
	cmp	bl,253
	jb	inl_exit1		; done if no deletion needed
inl_delscan:

	push	di			; save new buf_back pointer

;	******* Now scan di forward to the next null and set
;	*******  buf_front just after it

	xor	al,al
	mov	cx,buf_end
	sub	cx,di
	repnz	scasb
	jz	inl_delscan_1		; brif we found it

	mov	di,buf_base
	mov	cx,buf_end
	sub	cx,di
	repnz	scasb			; find null in front part of buffer
inl_delscan_1:
	mov	buf_front,di
	pop	di			; restore buf_back

;	come here to store the new buf_back pointer and place the null

inl_exit1:
	mov	byte ptr [di-1],0	; store null at end
	mov	buf_back,di		; we're done!
	mov	buf_current,di
	pop	cx
	pop	si
	pop	di
	ret

ins_new_line	endp


;******************************************************************************
;
;   buffer_compare	returns zero flag true if the string
;			matches the current line, not case sensitive
;   entry:		di = string in our es:, bx = length
;   exit:		zero true if matched
;   trashes:		ax, bx, cx, di, si
;
;==============================================================================

buffer_compare	proc	near
	mov	si,[buf_current]
bufcom0:
	call	get_buflen	; see how many bytes in that part of buffer
bufcom1:
	or	bx,bx		; have we matched the whole thing?
	jz	bufcom9		; yes!  success!  zero flag true!
	jcxz	bufcom2		; brif need to swap to other buffer half
	lodsb			; get the character
	dec	bx
	dec	cx
	scasb			; does it match?
	jz	bufcom1		; loop if so
	and	al,5fh		; see if it's alpha
	cmp	al,'A'
	jb	bufcom_fail
	cmp	al,'Z'
	ja	bufcom_fail
	xor	al,[di][-1]
	and	al,5fh		; totally non-case sensitive compare
	jz	bufcom1		; still okay if both alpha and match
bufcom_fail:
	or	al,1		; reset zero flag
bufcom9:
	ret
bufcom2:
	mov	si,[buf_base]	; wrap to front of buffer
	jmp	bufcom0
buffer_compare	endp

;******************************************************************************
;			L O C A L    R O U T I N E S
;******************************************************************************


;******************************************************************************
;
;   get_buflen		sets up count in cx of bytes left in buffer
;			segment at si
;   entry:		si->buffer pointer
;   exit:		cx= count remaining in that part of buffer
;
;==============================================================================

get_buflen	proc	near
	mov	cx,buf_back
	sub	cx,si			; get length if not 2nd half of split
	jae	get_buflen_9

	mov	cx,buf_end
	sub	cx,si			; get length in second half of split

get_buflen_9:
	ret

get_buflen	endp

;******************************************************************************
;
;   nxtbuf_x		if buffer pointer in [si] is at the end of the
;			physical buffer (at buf_end), wrap back to front
;			(buf_base)
;   entry:		si = buffer pointer
;   exit:		si = corrected buffer pointer
;
;==============================================================================

;	if (si == buf_end) then si = buf_base;

nxtbuf_x	proc	near

	cmp	si,buf_end
	jnz	nb_02
	mov	si,buf_base
nb_02:
	ret

nxtbuf_x	endp

text	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\doskey\doskey.asm ===
page ,132
;******************************************************************************
Title DOSKEY.ASM - First module/init code
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;   (C) Copyright Microsoft Corp., 1989
;
;	Revision history:
;
;	06/09/89	1.01	Original version
;	09/10/89	1.02	Restructuring source modules
;	04/17/90	1.03	Added /? option (c-PaulB)

hipper_install	=	0	; true for hipper final install sequence
	include	gendef.inc
	include dbcs.sw

text 	segment	byte public 'CODE'
	assume	cs:text,ds:nothing,es:nothing,ss:nothing


	org	100h
start:
	extrn	init_main:near
	if	hipper_install
	call	init_main		; only returns if new- or re-install
	rep	movsb			; move buffers down over install code
	int	TSR_INT			; terminate stay resident
	else
	jmp	init_main
	endif


;******************************************************************************
;			I N S T A N C E    D A T A
;******************************************************************************

begin_inst_data:

	public	command_template
command_template dd	0
 
; buffer.asm data..

	public	macro_base
	public	macro_last
	public	macro_end
	public	buf_base
	public	buf_back
	public	buf_front
	public	buf_end
	public	buf_current

macro_base	dw	0
macro_last	dw	0
macro_end	dw	0

buf_base	dw	0		; base of command buffer
buf_back	dw	0		; end of data in command buffer
buf_front	dw	0		; start of data in command buffer
buf_end		dw	0		; end of command buffer
buf_current	dw	0		; current command pointer

	public	default_insert

default_insert	db	0

	public	text_ptr
	public	macro_ptr
text_ptr	dw	0		; pointers for output to user
macro_ptr	dw	0

; display.asm data..

	public	num_cols
	public	active_page
	public	cur_col
	public	mark_row
	public	mark_col
	public	rows_advanced
	public	over_cursor
			
num_cols	dw	0
active_page	db	0
cur_col		db	0
mark_row	db	0
mark_col	db	0
rows_advanced	db	0
over_cursor	dw	0

; template.asm data..

	public	template
	public	end_template
	public	output
	public	end_dsp
	public	cur_ptr
	public	oper_flags

end_template	dw	0		; template size passed from command.com
template	db	LINE_LEN	dup (0)
		db	0		; always allow room for a <cr>
output		db	LINE_LEN	dup (0)
end_dsp		dw	0
cur_ptr		dw	0
oper_flags	db	0		; flags for operation

	public	f9_buf,f9_buf_end

f9_buf	db	5 dup (?)
f9_buf_end:

ifdef DBCS
	public	DBCSLeadByteTable
DBCSLeadByteTable	dd	?
endif

	
;	Here's the buffer we use for learning the display size on f7

	public	ansi_buf,d_mode,rows

ansi_buf dw	0
	dw	14		; data length
	dw	?
d_mode	db	?
	db	?
	dw	?
	dw	?
	dw	?
	dw	?
rows	dw	?

end_inst_data:

; Message texts from DOSKEY.  These are messages needed at run time.
; Those needed only for initialization are in INITMSG.INC

	public	more_prompt
	public	num_prompt
include doskey.cl1			; message text for resident

;	We'll hook into the Multiplex Interrupt (2f) in order to give
;	  access between our .COM file and the resident part, and also
;	  so that we can report instance data to win386.

next2f_int	label	dword
	public	old2f
old2f		dw	2 dup (?)

; the table used to report the instance data is given below.  structure
; is understood by win 3.0 and later versions will support it too.
;
	public	w386_instptr
	public	w386_instseg1
	public	w386_instoff2
	public	w386_instseg2
	public	w386_instsize2

w386loadinfo:
w386_ver	db	3,0			
w386_nextdev	dw	2 dup (?)		 
w386_fileptr	dw	2 dup (0)
w386_refdata	dw	2 dup (?)
w386_instptr	dw	offset w386_insttable,?

w386_insttable:
w386_instoff1	dw	offset begin_inst_data
w386_instseg1	dw	?
w386_instsize1	dw	end_inst_data - begin_inst_data
w386_instoff2	dw	?
w386_instseg2	dw	?
w386_instsize2	dw	?

		dw	0
		dw	0


;******************************************************************************
;
;   ourint2f 	 this is our int2f handler.
;   entry: 	 ax = INT2F Multiplex # and Sub-Function.
;   exit:	 If ax = 1605h then es:bx = instance table str. ptr
;		 If ax = 4b05h then es:bx = instance table (for dos switcher)
;		 if ax = 4800h then ax=our_version, es:-> our data area
;		 if ax = 4810h, then do a read command line function
;
;==============================================================================

	public	ourint2f
ourint2f	proc	near

	assume	ds:nothing,es:nothing,ss:nothing

	cmp	ax,1605h   		; check to see if 
	je	w386install		; win386 int 2f.
	cmp	ax,4b05h		; check to see if dos switcher
	je	w386install		;  and treat it the same as windows
	cmp	ah,48h			; DOSKEY private function?
	je	doskey_int2f		; go handle our subfunctions
int2f_notus:
	jmp	next2f_int


;	note that the int2f(4b05h) and int2f(1605h) are not precisely
;	  the same.  the registers for the task switcher callback are
;	  different.  but the registers we care about (es:bx) are the same.

w386install:
	pushf
	call	next2f_int		; this is a cooperative
					; chain.  the buffer returned
	mov	cs:w386_nextdev,bx	; by the next guy is stored
	mov	cs:w386_nextdev[2],es	; in our data.

	push	cs			; return pointer to our 
	pop	es			; buffer
	assume	es:text
	mov	bx,offset w386loadinfo
	iret

doskey_int2f:
	cmp	al,10h			; read console line?
	jnz	not_readconsole		; brif not

;	M002 -- The following code didn't actually work, so it's deleted

;M002	;	we just disable ourselves if STDIN is not the CON device.
;M002	;	  that is because we don't know how to work with external
;M002	;	  terminals on CTTY.
;M002	
;M002		push	ax
;M002		push	bx
;M002		push	dx
;M002		mov	ax,4400h
;M002		mov	bx,1			; IOCTL for STDIN
;M002		int	21h
;M002		test	dl,1			; console input device?
;M002		pop	dx
;M002		pop	bx
;M002		pop	ax
;M002		jz	int2f_notus		; fail the call if not CON dev

;	handle most common case of int2f(48xx) first.

	xchg	bx,dx			; see if length of buffer == 128
	cmp	byte ptr [bx],128
	xchg	bx,dx
	jnz	int2f_notus		; don't handle other buffer lengths

	sti
	call	line_input		; implement line input
	xor	ax,ax			; signal that we handled it
	iret


not_readconsole:
	or	al,al			; is it doskey installation check?
	jnz	int2f_notus		;  back down chain if not
	push	cs
	pop	es
	mov	ax,our_version
	iret

ourint2f	endp


	extrn	fresh_template:near
	extrn	ins_new_line:near
	extrn	display_char:near

line_input	proc	near
	assume	ds:nothing,es:nothing

	push	ax			; save all the registers
	push	bx
	push	cx
	push	dx
	push	si
	push	di

;	we don't use bp, but we supposedly need to preserve it because
;	  some ROM BIOSs trash it on int 10h calls

	push	bp
	push	ds
	push	es
	cld

;	save the template address
 
	mov	word ptr cs:[command_template],dx
	mov	word ptr cs:[command_template.2],ds

	push	cs			; point ds, es -> text segment
	pop	ds
	push	cs
	pop	es
	assume	ds:text,es:text

;	check the command flag and do appropriate thing

	test	[oper_flags],OLDINP	; is there old input to scan?
	jnz	short continue_with_old_input

  	call	fresh_template
;
; transfer data from template to history buffer if it has been edited
;
	mov	si,offset template
	mov	cx,[end_dsp]

;	cas note:  commented out following two lines to implement
;	  OPTION 2 from discussions
;
;	test	[oper_flags],EDITED
;	je	linein_1		; if not edited we don't reset
;					; current line nor do we insert
;					; new one.

	or	cx,cx			; don't insert zero length lines
	jz	linein_1
	call	ins_new_line
linein_1:

;	Okay.  Here we go.  We've got a new line of input from the
;	  user.  If A) the line starts with a macro invocation or
;	  B) the line contains multiple lines with separators, then
;	  we'll resort to a special mode where 1) we just return from
;	  this call with no input so that we get re-prompted, 2) when
;	  we get re-entered, we start spitting out the macro expansion
;	  text and individual lines as executed.

;	see if the stuff in template matches any defined macros

	mov	si,[end_dsp]
	mov	template[si],cr		; store <cr> at end of string
	mov	[text_ptr],offset template ; save scan ptr just in case

	call	check_for_macro_expand	; see if we need to expand a macro
	jc	return_with_empty_command ; brif it set up a macro expansion

	mov	di,[text_ptr]
	mov	cx,[end_dsp]
	mov	al,ctrl_t
	jcxz	no_macro_match_01	; don't scan empty lines
	repnz	scasb			; does the new line have separators?
	jz	return_with_empty_command ; found separator, do special mode

no_macro_match_01:
	les	di,command_template
	assume	es:nothing
	mov	si,offset template
	mov	cx,[end_dsp]
	inc	di
	mov	es:byte ptr [di],cl
	inc	di
	rep	movsb
	mov	al,cr
	stosb
	jmp	line_input_return	; return the line

	assume	es:text
return_with_empty_command:
	or	[oper_flags],OLDINP	; force invocation of saved command
;					;  strings next time we're entered
	les	di,command_template
	assume	es:nothing
	mov	es:word ptr 1[di],0d00h	; zero length, <cr> terminator
	jmp	line_input_return

continue_with_old_input:
	les	di,command_template
	assume	es:nothing
	inc	di			; point to actual data field
	inc	di
	mov	cx,LINE_LEN
	dec	cx			; allow room for separator

	test	[oper_flags],MAC_EXPAND
	jnz	time_to_expand_macro
	jmp	no_macro_to_expand
time_to_expand_macro:

	mov	si,[macro_ptr]		; is there an macro to send?

;	now copy characters out of the macro string

expand_macro:
	lodsb				; next char from macro
	or	al,al			; terminator?
	jz	macro_exp_done
	cmp	al,ctrl_t		; macro string command separator?
	jz	got_macro_sep

	cmp	al,'$'			; macro parameter character?
	jnz	scanning_mac_01		; brif not

	lodsb				; get the next character
	or	al,al			; terminator?
	jz	macro_exp_done		; done if so
	cmp	al,ctrl_t		; string command separator?
	jz	got_macro_sep

	cmp	al,'*'			; $* means use entire command tail
	jz	expand_parm0
	cmp	al,'1'
	jb	scanning_mac_01		; done if below digit-land
	cmp	al,'9'
	jbe	expand_parameter	; go insert macro expansion
scanning_mac_01:
	stosb				; copy one character
	call	display_char		; and echo to screen
	loop	expand_macro

;	we're out of buffer.  Truncate rest of command.

mac_exp_outofdstbuf:
	lodsb				; next char from macro?
	or	al,al			; end?
	jz	macro_exp_done		; brif so
	cmp	al,ctrl_t		; command separator?
	jnz	mac_exp_outofdstbuf	; loop until one or the other
got_macro_sep:
	mov	[macro_ptr],si		; save the macro_scan pointer
	jmp	return_the_buffer_to_caller

macro_exp_done:
	and	[oper_flags],not (MAC_EXPAND or OLDINP)	; macro expander off

;	now see if there was a command separator in the original command tail

	mov	si,[text_ptr]
	mov	cx,[end_dsp]
	jcxz	mac_exp_done_02		; brif no more command tail
mac_exp_done_01:
	lodsb				; can't do scasb cuz es:di is busy
	cmp	al,ctrl_t
	loopnz	mac_exp_done_01		; loop until end or we find one
	jnz	mac_exp_done_02		; brif no command separator

	or	[oper_flags],OLDINP	; turn regular scanning back on
	mov	[text_ptr],si		; save pointers
	mov	[end_dsp],cx

	push	es			; save destination buffer
	push	di
	push	cs
	pop	es			; set es: -> text for macro search
	call	check_for_macro_expand	; does NEXT line have ANOTHER macro?
	pop	di
	pop	es
mac_exp_done_02:
	jmp	return_the_buffer_to_caller

expand_parm0:
	push	si			; save pointer to macro text
	mov	si,[text_ptr]		; get pointer to command tail
	mov	bx,[end_dsp]		; get length of command tail
exp_parm0_01:
	or	bx,bx			; nothing left in command tail?
	jz	expand_parm_done	; brif so
	dec	bx
	lodsb				; scan any blanks at front of tail
	cmp	al,' '
	jz	exp_parm0_01
	cmp	al,tab
	jz	exp_parm0_01

	dec	si			; point back to first non-whitespace
	inc	bx			; adjust count
exp_parm0_01a:
	or	bx,bx			; command tail finished?
	jz	expand_parm_done	; done if so
	dec	bx
	lodsb
	cmp	al,ctrl_t		; command separator?
	jz	expand_parm_done	; don't go any further if so
	stosb				; copy it
	call	display_char		; display it
	loop	exp_parm0_01a		; loop as long as we've got dest buffer
expand_parm_outobuf:
	pop	si			; restore macro text pointer
	jmp	mac_exp_outofdstbuf

expand_parm_done:
	pop	si
	jmp	expand_macro

expand_parameter:
	push	si			; save pointer to macro text
	mov	si,[text_ptr]		; get pointer to command tail
	mov	bx,[end_dsp]		; get length of command tail
	sub	al,'0'			; subtract ascii offset from parm #
	mov	ah,al
expand_parm_01:
	or	bx,bx			; nothing left in command tail?
	jz	expand_parm_done	; done if so
	dec	bx
	lodsb				; get character
	cmp	al,ctrl_t		; command separator?
	jz	expand_parm_done	; done if so
	cmp	al,' '			; scan past if whitespace
	jz	expand_parm_01
	cmp	al,tab
	jz	expand_parm_01

;	now we've got non-whitespace.  check parameter number request.

	dec	ah			; have we found the one we wanted?
	jz	expand_parm_found	; brif so

;	oh well.  Now scan until we find whitespace and loop.

expand_parm_02:
	or	bx,bx			; nothing left in command tail?
	jz	expand_parm_done	; done if so
	dec	bx
	lodsb				; get character
	cmp	al,' '
	jz	expand_parm_01		;  back to outer loop if whitespace
	cmp	al,tab
	jz	expand_parm_01
	cmp	al,ctrl_t
	jz	expand_parm_done	; done if command separator
	jmp	expand_parm_02

expand_parm_found:
	inc	bx			; count back for first character
	dec	si			; we overscanned first character
exp_parm_found_01:
	or	bx,bx			; nothing left in command tail?
	jz	expand_parm_done	; brif so
	dec	bx
	lodsb				; get character from command tail
	cmp	al,' '			; consider whitespace a delimiter
	jz	expand_parm_done
	cmp	al,tab
	jz	expand_parm_done
	cmp	al,ctrl_t		; or command separator
	jz	expand_parm_done
	stosb				; copy it
	call	display_char		; display it
	loop	exp_parm_found_01	; loop as long as we've got dest buffer
	jmp	short expand_parm_outobuf



no_macro_to_expand:
	mov	si,[text_ptr]
	mov	bx,[end_dsp]		; get count remaining
scanning_text:
	or	bx,bx			; have we exhausted count?
	jz	text_exp_done
	dec	bx
	lodsb				; next character from text
	cmp	al,ctrl_t		; command separator?
	jz	got_text_sep		; skip if so
	stosb				; copy it
	call	display_char		; echo to screen
	loop	scanning_text		; loop until we run out of buffer

;	if we run out of buffer, force a fake separator

got_text_sep:
	mov	[text_ptr],si
	mov	[end_dsp],bx		; save the scan pointers
	or	bx,bx
	jnz	 return_the_buffer_to_caller

text_exp_done:
	and	[oper_flags],NOT OLDINP	; force new input next time
return_the_buffer_to_caller:
	mov	al,cr			; store delimiter into buffer
	stosb
	mov	cx,di
	mov	di,word ptr command_template
	sub	cx,di			; get length we actually copied
	sub	cx,3			; less the two count bytes and the <cr>
	mov	es:byte ptr [di][1],cl

;
; restore all the registers
;
line_input_return:
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	assume	ds:nothing
	ret

line_input	endp
	
;	this subroutine is called when we're about to expand a
;	  command line.  It checks to see if the first thing on
;	  the line is a macro.  If so, it sets up the appropriate
;	  pointers and stuff and sets the MAC_EXPAND and OLDINP bits.
;	  sets carry when macro will be expanded.

check_for_macro_expand	proc	near
	assume	ds:text

	mov	si,[text_ptr]
	call	count_name		; how far to macro delimiter?
	jcxz	no_macro_match		; if line started with delim, no macro

	mov	si,[text_ptr]		; now look that up in macro table
	push	cx			; save macro length
	call	search_macro
	pop	cx
	jc	no_macro_match		; brif search failed

	add	di,cx			; point to end of macro name in table
	inc	di			; point past delimiter
	add	[text_ptr],cx		; advance pointer past macro name
	sub	[end_dsp],cx		; reduce length of string by macro size
	mov	[macro_ptr],di		; save the command tail
	or	[oper_flags],MAC_EXPAND or OLDINP ; set macro-expansion flags
	stc				; set flag indicating macro expansion
	ret
no_macro_match:
	clc				; no macro expansion
	ret
check_for_macro_expand	endp

;	return al=force_upper(al)

	public	ucase
ucase	proc	near
	cmp	al,'a'
	jb	ucas1		; skip if below lower case
	cmp	al,'z'
	ja	ucas1		; skip if above lower case
	and	al,5fh		; force to upper case
ucas1:
	ret
ucase	endp


;	Return the length of macro name at ds:si in cx, return si->delimiter
;	   trash ax

	public	count_name
count_name	proc	near
	xor	cx,cx			; start counting
count_name_size:
	lodsb
	cmp	al,cr			; check for all possible delimiters
	jz	count_name_gotdel
	cmp	al,' '
	jz	count_name_gotdel
	cmp	al,tab
	jz	count_name_gotdel
	cmp	al,'='
	jz	count_name_gotdel
	cmp	al,ctrl_t
	jz	count_name_gotdel
	inc	cx			; count it
	jmp	count_name_size

count_name_gotdel:
	dec	si			; point back to the delimiter
	ret
count_name	endp

;	search macro table for macro named at ds:si, length = cx
;	  assume es:-> resident data.  Return es:di -> match entry
;	  or carry true if fail.  Note:  Alias table always stored
;	  as CAPS, other string non-case-sensitive.
;
;	returns si-> after the matched string if matched

	public	search_macro
search_macro	proc	near
	assume	ds:nothing,es:text
	lodsb				; get first character to match
	call	ucase			; force upper
	mov	ah,al			; save first character in ah, too
	dec	cx			; eat the first character

	mov	di,[macro_base]
sa_01:
	cmp	di,[macro_last]
	jae	sa_08			; fail if we hit end of table

	push	di			; save pointer to string
	scasb				; match first character?
	jnz	sa_02			;  don't do string compare if not

	jcxz	sa_017			; skip if it was a one byte string
	push	si
	push	cx			; save target string and length
sa_015:
	lodsb				; get source string
	call	ucase			; force upper
	scasb				; compare
	loopz	sa_015
	pop	cx
	pop	si			; restore compare string
	jnz	sa_02			; brif no match
sa_017:
	cmp	es:byte ptr [di],0	;  was the length the same?
sa_02:
	pop	di
	jz	sa_09			; success! (carry clear)

sa_03:
	push	cx
	mov	cx,[macro_last]
	sub	cx,di
	xor	al,al
	repnz	scasb			; find two delimiters
	repnz	scasb
	pop	cx
	mov	al,ah			; restore first character to match
	jmp	sa_01			; next entry

sa_08:
	stc
	ret
sa_09:
	add	si,cx			; point si past comparison string
					; guaranteed to leave carry reset
	ret
search_macro	endp

text	ends

	end	start

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\doskey\trans.asm ===
page ,132
;******************************************************************************
Title TRANS.ASM - Transient parts of DOSKey
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;   (C) Copyright Microsoft Corp., 1989
;
hipper_install	=	0

	include	gendef.inc
	include	versiona.inc
	include dbcs.sw

cgroup	group	text,initseg
text	segment	byte public 'code'
	extrn	macro_base:word
	extrn	macro_end:word
	extrn	macro_last:word

	extrn	buf_base:word
	extrn	buf_front:word
	extrn	buf_back:word
	extrn	buf_end:word
	extrn	buf_current:word

	extrn	default_insert:byte

	extrn	w386_instptr:word
	extrn	w386_instseg1:word
	extrn	w386_instseg2:word
	extrn	w386_instoff2:word
	extrn	w386_instsize2:word

	extrn	old2f:word
	extrn	ourint2f:near

	extrn	dumphist:near
	extrn	newline:near
	extrn	dstring:near
	extrn	display_char:near
	extrn	ucase:near
	extrn	count_name:near
	extrn	search_macro:near

ifdef DBCS
	extrn	DBCSLeadByteTable:dword
endif

text	ends
initseg	segment	byte public 'code'
	assume	cs:cgroup		; allow cs: access to text & initseg

start_of_init_code:
	if	not hipper_install
base_of_buffers:
	endif

zero	dw	0		; segment of interrupt vectors

reinstall_string db	'/REINSTALL',0
bufsize_string	db	'/BUFSIZE',0
dhist_string	db	'/HISTORY',0
dh1_string	db	'/H',0
dmacs_string	db	'/MACROS',0
dm1_string	db	'/M',0
options_string	db	'/?',0
insert_string	db	'/INSERT',0
overstrike_string db	'/OVERSTRIKE',0

REINSTALL	equ	01h
NEW_BUFSIZE	equ	02h
NEW_INSTALL	equ	04h
DHIST		equ	08h
DMACS		equ	10h
INSERT_FLAG	equ	20h
OVERSTRIKE_FLAG	equ	40h

bufsizer	dw	512	       ; DEFAULT BUFFER SIZE

	if	hipper_install
;	init_main will only return in the case that it does
;	  a new installation.  In that case, it returns with
;	  everything all setup for the movsb which moves the
;	  buffer space down over the init code.  Also, it has
;	  dx set up for a TSR_INT
	endif

	public	init_main
init_main	proc	near
	assume	cs:initseg		; tell assembler not to assume
					;  it can get to data through cs:
	push	cs			; point ds:si to our command tail
	pop	ds
	assume	ds:cgroup,es:nothing
	push	cs
	pop	es			; point es into our command strings

	mov	ah,30h			; check DOS version
	int	21h
	cmp	ax,expected_version	; must match version EXACTLY!
	jz	dvers_ok

	mov	dx,offset cgroup:IncorrectDOS
	jmp	error_abort		; abort if wrong DOS

dvers_ok:
	mov	si,81h			; look at command tail

scan_options:
	call	get_nonwhite

	mov	di,offset cgroup:options_string		; /?
	call	noncase_compare
	jz	options_command

	mov	di,offset cgroup:insert_string		; /insert
	call	noncase_compare
	jz	insert_command

	mov	di,offset cgroup:overstrike_string	; /overstrike
	call	noncase_compare
	jz	overstrike_command


	mov	di,offset cgroup:reinstall_string	; /REINSTALL
	call	noncase_compare
	jz	reinstall_command

	mov	di,offset cgroup:dhist_string		; /HIST
	call	noncase_compare
	jz	dhist_command
	mov	di,offset cgroup:dh1_string		; '/H'
	call	noncase_compare
	jz	dhist_command

	mov	di,offset cgroup:dmacs_string		; /MACS
	call	noncase_compare
	jz	dmacs_command
	mov	di,offset cgroup:dm1_string		; '/M'
	call	noncase_compare
	jz	dmacs_command

	mov	di,offset cgroup:bufsize_string		; /BUFSIZE
	call	noncase_compare
	jnz	done_scanning_options	; brif what's there ain't an option

;	scan the /bufsize= option

	call	get_nonwhite		; get past any blanks
	cmp	al,'='
	jz	scanning_bufsize_01
	jmp	bad_syntax		; syntax error if not '='
scanning_bufsize_01:

	call	get_nonwhite_1
	call	scan_decimal_string
	mov	[bufsizer],bx
	assume	cs:cgroup
	or	cs:byte ptr [install_flags],NEW_BUFSIZE
	assume	cs:initseg
	jmp	scan_options

reinstall_command:
	assume	cs:cgroup
	or	cs:byte ptr [install_flags],REINSTALL
	assume	cs:initseg
	jmp	scan_options

insert_command:
	assume	cs:cgroup
	or	cs:byte ptr [install_flags],INSERT_FLAG
	assume	cs:initseg
	jmp	scan_options

overstrike_command:
	assume	cs:cgroup
	or	cs:byte ptr [install_flags],OVERSTRIKE_FLAG
	assume	cs:initseg
	jmp	scan_options


options_command:

;	can't use normal message output here cuz message contains "$"

	mov	bx,offset cgroup:help_info
opt_com:
	mov	al,[bx]
	inc	bx
	or	al,al
	jz	opt_com_done		; null at end

	push	bx
	mov	dl,al
	mov	ah,2
	int	21h			; console out
	pop	bx
	jmp	opt_com

opt_com_done:
	mov	al, 0			; return code
	jmp	normal_return

dhist_command:
	assume	cs:cgroup
	or	cs:byte ptr [install_flags],DHIST
	assume	cs:initseg
	jmp	scan_options

dmacs_command:
	assume	cs:cgroup
	or	cs:byte ptr [install_flags],DMACS
	assume	cs:initseg
	jmp	scan_options

;	okay.  Now we've scanned our options.  Install us if needed,
;	  then fall into a possible macro definition.

done_scanning_options:
	assume	cs:cgroup
	test	cs:byte ptr [install_flags],REINSTALL
	assume	cs:initseg
	jnz	force_reinstall		; do the install, damnit!

	mov	ax,4800h		; Installation check
	int	I2F_INT			; get es:-> resident data if installed
	cmp	ax,4800h		; is ANY DOSKey installed?
	jz	force_reinstall
	jmp	already_installed	;  yep.  go see if it's the same one

;	come here to install us as resident part

force_reinstall:
	push	si			; save command line pointer
	mov	ax,[bufsizer]
	cmp	ax,1+2*LINE_LEN		; minimum size
	jae	got_bufsize_1
	mov	ax,1+2*LINE_LEN		; set size to minimum
got_bufsize_1:

	mov	cx,0ffffh		; figure out max buffer size
	sub	cx,offset cgroup:base_of_buffers
	cmp	ax,cx			; are we over max?
	jbe	got_bufsize_2		; brif okay
	mov	ax,cx
got_bufsize_2:
	push	ax			; save buffer size

;	free the environment

	mov	es,word ptr ds:[02ch]
	mov	ah,49h
	int	21h

;	initialize buffers module.

	mov	ax,offset cgroup:base_of_buffers
	mov	[macro_base],ax
	mov	[macro_last],ax
	mov	[macro_end],ax

	mov	[buf_base],ax
	mov	[buf_front],ax
	mov	[buf_back],ax
	pop	bx
	add	ax,bx
	mov	[buf_end],ax


;	initialize win386 module.

;
; first set vital values in instance table
;
	mov	ax,cs
	mov	[w386_instptr.2],ax	; segment of instance table ptr
	mov	[w386_instseg1],ax	; segment of instance data block
					; in win386.asm
	mov	[w386_instseg2],ax	; segment of buffer data area.

	mov	ax,[macro_base]
	mov	[w386_instoff2],ax 	; offset of buffer data area
	mov	ax,[buf_end]
	sub	ax,[macro_base]
	mov	[w386_instsize2],ax	; size of buffer data area

ifdef DBCS

;	set DBCS Lead Byte Table

	push	ds
	mov	ax,6300h		; get address of DBCS Lead Byte Table
	int	21h
	mov	bx,ds
	pop	ds
	mov	word ptr DBCSLeadByteTable,si
	mov	word ptr DBCSLeadByteTable+2,bx
endif

;	hook us into int2f


	mov	ax,offset ourint2f
	mov	bx,cs
	mov	es,zero
	cli
	xchg	ax,es:word ptr [I2F_INT*4]
	xchg	bx,es:word ptr [I2F_INT*4][2]
	mov	[old2f],ax
	mov	[old2f][2],bx

	sti

	mov	dx,offset cgroup:installed
	call	dsp_msg_crlf

	assume	cs:cgroup
	or	cs:byte ptr [install_flags],NEW_INSTALL
	assume	cs:initseg
	pop	si			; restore command tail pointer
	push	cs			; point es: to text segment
	pop	es
	jmp	short continue_after_install

;	put install_flags down here so they don't get wiped out by
;	  a macro definition on an installation run

install_flags	db	0

already_installed:
	cmp	ax,our_version		; proper version installed?
	mov	dx,offset cgroup:vers_mismatch
	jnz	err_abrt_01
	test	[install_flags],NEW_BUFSIZE
	jz	continue_after_install
	mov	dx,offset cgroup:cant_change_bufsize
err_abrt_01:
	jmp	short error_abort

;	okay.  Now we know we have a resident portion to talk to.
;	  we'll tell the assembler to use es (returned by int 2f) to
;	  access our resident data variables, and invalidate ds

	assume	ds:nothing,es:cgroup

continue_after_install:

	assume	cs:cgroup
	test	cs:[install_flags],INSERT_FLAG
	assume	cs:initseg
	jz	not_in_forced_insert
	mov	[default_insert],-1
not_in_forced_insert:

	assume	cs:cgroup
	test	cs:[install_flags],OVERSTRIKE_FLAG
	assume	cs:initseg
	jz	not_in_forced_overstrike
	mov	[default_insert],0
not_in_forced_overstrike:


	call	get_nonwhite		; scan past any blanks

;	okay.  Now.  si is the start of the macro name.  Find the
;	  length of the name, the start of the definition, and the
;	  length of the definition so we can take the needed space
;	  away from the history buffer.

	mov	di,si			; save start of name string
	call	count_name
	jcxz	no_macro_to_define	;  done if name is zero length
	call	get_nonwhite		; scan whitespace
	cmp	al,'='			; got the required equals?
	jnz	bad_syntax		;  error if not equals
	call	get_nonwhite_1		; scan up to actual definition string

	mov	bx,cx			; get length of name string into bx

;	now convert the definition string for storage and get its length

	call	pack_macro		; pack the macro & count its length

;	now di->name, bx=name length, si->definition, cx=def length

	if	not hipper_install
mustbe_greater_than_128	=	$ - start_of_init_code

;	see that label above us?  there's probably some way of
;	  convincing the assembler to generate an error if an
;	  expression is less than 128, but I'm probably not
;	  going to figure it out at 6:40 a.m.  The reason why
;	  it's a concern is that the macro is going to start
;	  overlaying our initialization code.  the biggest
;	  possible macro is limited by the length of the
;	  invocation line.  128 is a good number to use.
	endif

	call	insert_macro		; create the macro string
	assume	ds:cgroup,es:nothing
	mov	dx,offset cgroup:out_o_macro_msg
	jc	error_abort

no_macro_to_define:
	assume	cs:cgroup
	test	cs:byte ptr [install_flags],DHIST
	assume	cs:initseg
	push	ds
	push	es
	pop	ds			; get ds -> resident data
	jz	no_dhist
	xor	al,al			; no line numbers
	call	dumphist
	call	newline			; put a newline after
no_dhist:
	assume	cs:cgroup
	test	cs:byte ptr [install_flags],DMACS
	assume	cs:initseg
	jz	no_dmacs
	xor	al,al		; no newline the first time
	call	dumpmacs
	call	newline		; put a newline after
no_dmacs:
	pop	ds			; restore our data segment
	mov	al,0			; return code okay
	jmp	short normal_return


bad_syntax:
	mov	dx,offset cgroup:syntax_error
error_abort:
	call	dsp_msg_crlf
	mov	al,1			; abnormal return
normal_return:
	test	[install_flags],NEW_INSTALL
	jnz	must_do_tsr
	mov	ah,4ch			; terminate
	int	21h

must_do_tsr:

	if	hipper_install

;	now we're going to move the buffers down on top of the init
;	  code.  we'll have to adjust a bunch of pointers first.

	mov	ax,offset cgroup:end_of_init_code
	sub	ax,offset cgroup:start_of_init_code

	mov	si,[macro_base]
	sub	[macro_base],ax
	mov	di,[macro_base]
	sub	[macro_last],ax
	sub	[macro_end],ax
	sub	[buf_base],ax
	sub	[buf_front],ax
	sub	[buf_back],ax
	sub	[buf_end],ax

;	we know ds: and es: point to cs: for the movsb
;	  which follows the call to init_main

	mov	cx,[macro_last]
	sub	cx,di			; get length of macro block
	mov	dx,[buf_end]		; end of last buffer
	add	dx,16			; augment by a paragraph
	ret				; return back to low memory
	else
	mov	dx,[buf_end]		; end of last buffer
	add	dx,16			; augmented by a paragraph
	int	TSR_INT
	endif

init_main	endp

;	delete old macro definition (if any) and insert new def (if any)
;	  di->name, bx=name length, si->definition, cx=def length
;	  trash: all, return carry if couldn't get enough room for macro
;	  name must already be checked for zero length
;	Note:  es: must be pointing to our RESIDENT data area.  ds: will
;	  be pointing to all of our names and stuff

insert_macro	proc	near
	assume	es:text,ds:nothing

	push	di			; save name and length
	push	bx

insert_al_01:
	mov	al,ds:byte ptr [di]	; fetch name character
	call	ucase			;  force to upper case
	mov	ds:byte ptr [di],al	;   and store it back
	inc	di
	dec	bx
	jnz	insert_al_01		; loop through entire name

	pop	bx
	pop	di

	push	si
	push	cx
	push	di
	push	bx

	call	delete_macro		; delete the any old definitions

	pop	bx
	pop	di
	pop	cx
	pop	si
	jcxz	insert_macro_okay	; if zero length, we're done

;	do the insertion here

	mov	ax,bx			; get the amount of room we need
	add	ax,cx			; for name and definition
	add	ax,2			; plus two nulls
	mov	dx,[macro_end]		; how much room exists now?
	sub	dx,[macro_last]		; this is the amount of space we have
	sub	ax,dx			; do we need any additional?
	jbe	insert_al_spaceok	; skip if not

	push	ax
	call	shrink_history		; try to get the space from history
	pop	ax
	jc	insert_macro_done	;  exit with carry set if problem
	add	[macro_end],ax		; update macro_end

insert_al_spaceok:
	push	si			; save definition string
	push	cx			; save definition string length
	mov	si,di			; get name string
	mov	cx,bx			; get name string length
	mov	di,[macro_last]
	rep	movsb			; zip it in there.  We already know
					;  we've got enough space.
	xor	al,al			; get a null to store at end
	stosb				;  store null
	pop	cx			; get definition string length
	pop	si			; get definition string
					;  we've already disposed of the case
					;   where cx == 0
	rep	movsb			; copy already-crunched string
	xor	al,al
	stosb				; store null at end
	mov	[macro_last],di		; update end-of-macroes pointer
insert_macro_okay:
	clc				; clear carry - no error
insert_macro_done:
	ret
insert_macro	endp

;	si -> macro definition string.  We must pack it in place.  This
;	  is safe because the packed form NEVER takes more room than the
;	  user-entered form.  We'll return cx == count of string in bytes.
;	  the original string was <cr> terminated.
;
;	bx, si, di & es must be preserved!


pack_macro	proc	near
	push	es			; save resident data segment
	push	di			; preserve macro name pointer
	push	si			; preserve macro def pointer

	push	ds
	pop	es
	mov	di,si			; point es:di to ds:si

pack_macro_0:
	lodsb				; get the character
	cmp	al,cr			; is that the end?
	jz	pack_macro_9		; done if so!

	cmp	al,'$'			; is it a '$'?
	jnz	pack_macro_5		; just copy this character if not '$'

	lodsb				;  get following character
	cmp	al,cr			; handle '$'<cr> case
	jz	pack_macro_9

;	see if it's a $$, $* or $1 - $9.  If so, allow it into the macro.

	cmp	al,'$'
	jz	pack_macro_2
	cmp	al,'*'
	jz	pack_macro_2

	cmp	al,'1'
	jb	pack_macro_3		; brif sub zero
	cmp	al,'9'
	ja	pack_macro_3		; brif super nine

pack_macro_2:
	mov	byte ptr es:[di],'$'	; copy $ + trail character
	inc	di
	jmp	short pack_macro_5	; copy trail character & loop

;	character after '$' wasn't "$*123456789".  It's either
;	  illegal, or a $b, $t, etc...

pack_macro_3:
	call	ucase			; force upper

	mov	ah,'|'
	cmp	al,'B'			; vertical bar?
	jz	pack_macro_4

	mov	ah,'<'
	cmp	al,'L'			; less than?
	jz	pack_macro_4

	mov	ah,'>'
	cmp	al,'G'			; greater than?
	jz	pack_macro_4

	mov	ah,ctrl_t
	cmp	al,'T'			; control t?

;	$<illegal> just gets thrown out.

	jnz	pack_macro_0		; just ignore illegal '$x'

pack_macro_4:
	mov	al,ah
pack_macro_5:
	stosb
	jmp	pack_macro_0

pack_macro_9:
	mov	cx,di			; get pointer to end of new string
	pop	si			; restore macro def pointer
	pop	di			; restore macro name pointer
	pop	es			; restore resident data pointer
	sub	cx,si			; get length of definition string
	ret
pack_macro	endp

;	delete any existing macro matching name at ds:di length bx
;	   trashes si, di, ax, bx, cx
;
;	note:  the recovered space WILL NOT be returned to the history
;	   pool.  It could be with a fairly minimal amount of work.

delete_macro	proc	near
	mov	si,di			; get string pointer in ds:si
	mov	cx,bx
	call	search_macro		; find the macro
	jc	delete_macro_done	; done if no match

	push	di			; save the pointer to macro table
	mov	cx,[macro_last]
	sub	cx,di
	xor	al,al			; scan to end
	repnz	scasb
	repnz	scasb
	mov	si,di
	pop	di			; restore pointer to macro match
	db	26h			; do the es: override
	rep	movsb
;  rep	movs	es:byte ptr [si],byte ptr [di]	; es: seg override
	mov	[macro_last],di
delete_macro_done:
	ret
delete_macro	endp

;******************************************************************************
;
;   shrink_history	Reduce the history buffer size by ax bytes,
;			truncating commands if necessary.
;   entry:		ax = number of bytes to shrink by
;   exit:		Carry set if couldn't shrink that much
;   trashes:		ax
;			sets buf_current to end of history
;   guaranteed preserves:  bx, cx, si, di
;
;==============================================================================

shrink_history	proc	near
	assume	ds:nothing,es:text
	push	cx			; we won't save bx cuz we won't use it
	push	si
	push	di
	push	ds		; save original ds:
	push	es		; copy es: -> ds: (text)
	pop	ds
	assume	ds:text

	mov	di,buf_end
	sub	di,buf_base		; how big is total buffer?
	sub	di,ax			; requested reduction size
	jc	shrink_exit3		; exit with carry if going past zero
	cmp	di,2+(2*LINE_LEN)	; allow for at least two full lines
	jb	shrink_exit3		; exit with carry if hit minimum size

	mov	cx,buf_back
	cmp	cx,buf_front		; split buffer configuration?
	jae	shrink_nosplit

;	We're in a split buffer configuration.  di has our new buffer size.
;	   first of all, look to see if we'll be discarding the entire
;	   2nd half of the buffer.

	sub	cx,buf_base		; get size of bottom segment
	sub	di,cx			; need to look at any of top segment?
	jbe	shrink_split_02		;  brif not, plenty of data in bottom

;	now let's start scanning through data to find the limits of
;	  what we're actually going to keep

	mov	si,buf_end
	sub	si,di			; subtract the amount of room left
;					;  to find the earliest possible
;					;  history we might be able to keep
	cmp	si,buf_front		; can we keep it all?
	jbe	shrink_split_01		;  yep.  all of it!  Just compactify.

;	welp, let's scan for a null to see how much we need to delete.

	mov	cx,di			; get length remaining in top buffer
	mov	di,si
	dec	di			; delete no more if previous was null
	inc	cx
	push	ax
	xor	al,al
	repnz	scasb			; try to find a null
	pop	ax
	jnz	shrink_split_02		;  no data left to keep in top part
	mov	buf_front,di		; do the truncation

;	any data needing deletion has been.  Just squeeze out the gap.

shrink_split_01:
	mov	si,buf_back
	add	buf_back,ax
	mov	di,buf_back
	mov	cx,si
	sub	cx,buf_base
	add	buf_base,ax
	dec	si
	dec	di
	std
	rep	movsb			; move bottom half up into gap
	cld
shrink_exitok:
	mov	ax,[buf_end]
	cmp	ax,[buf_front]
	jnz	shrink_exit1		; done if [buf_front] not at [buf_end]
	mov	si,[buf_base]
	mov	[buf_front],si		; [buf_front] = [buf_base]
	cmp	ax,[buf_back]		; is buffer completely empty?
	jnz	shrink_exit1		; done if not
	mov	[buf_back],si		; set [buf_back] = [buf_base] too
shrink_exit1:
	mov	ax,buf_back
	cmp	ax,buf_front		; is buffer empty?
	jnz	shrink_exit2		; set buf_current to buf_back if not
	xor	ax,ax			; else set it to zero
shrink_exit2:
	mov	buf_current,ax
	clc				; return with carry clear

shrink_exit3:
	pop	ds			; restore caller's ds
	pop	di
	pop	si
	pop	cx
	ret

;	there's no keeper data in the second half.  Change buffer to
;	  non-split configuration and let the normal non-split code
;	  do the job.

shrink_split_02:
	mov	si,buf_base
	mov	buf_front,si		; undo the split

shrink_nosplit:
	add	buf_base,ax		; don't care about old buf_base value

;	non-split configuration.  If the gap at the front is big
;	  enough, we're already done.

	mov	ax,buf_base
	cmp	ax,buf_front
	jbe	shrink_exitok		; done!

;	the next step is to move the data up to the top of the workspace,
;	  then check again for buf_base <= buf_front

	mov	di,buf_end
	mov	si,di
	xchg	si,buf_back		; new buf_back = buf_end
	mov	cx,buf_front
	sub	cx,si			; get size of move
	neg	cx
	dec	di
	dec	si
	std
	rep	movsb			; move the data up
	inc	di
	inc	si
	cld
	mov	buf_front,di		; update buf_front

	mov	si,buf_base
	cmp	si,buf_front
	jbe	shrink_exitok

;	now we've got to scan forward to delete some data to find the new
;	  buf_front

	mov	di,si			; get pointer to keeper data
	dec	di			;  we need not delete any more if
;					;  PREVIOUS byte was a null
;					;  And we KNOW data is there cuz
;					;  the old buf_front is less than
;					;  the new buf_base (si)
	mov	cx,buf_back
	sub	cx,di			; get length to scan
	xor	al,al			; scan for null
	repnz	scasb			; guaranteed to succeed
	mov	buf_front,di
	jmp	shrink_exitok

shrink_history	endp

	assume	ds:nothing

;	use int21(9) to display message at ds:dx

dsp_msg_crlf	proc	near
	mov	ah,9
	int	21h
	mov	dx,offset cgroup:crlf_msg
	mov	ah,9
	int	21h
	ret
dsp_msg_crlf	endp

;	advance si and then scan past any whitespace by falling
;	  into get_nonwhite

get_nonwhite_1	proc	near
	inc	si
get_nonwhite_1	endp

;	scan past any blanks at ds:si
;	  return first non-blank in al, si still points to it

get_nonwhite	proc	near
	lodsb
	cmp	al,tab
	jz	get_nonwhite
	cmp	al,' '
	jz	get_nonwhite
	dec	si
	ret
get_nonwhite	endp

;	compare string at ds:si to string at es:di.  If any mismatch,
;	  return zero flag false and si unchanged.  If match, return
;	  zero true and si pointing past the matched string.
;	  Note:  string at es:di is all alpha caps, zero terminated.
;	  comparison is non-case-sensitive to string at si.
;	  Also note that the string at ds:si need not have a delimiter

noncase_compare	proc	near
	push	si		; save original string start
nc_comp_01:
	cmp	es:byte ptr [di],0
	jz	nc_comp_09	; brif terminator on constant string, done!
	lodsb			; get character
	call	ucase		; force to upper case
	scasb			; compare to target string
	jz	nc_comp_01	; branch while continue to match
	pop	si		; restore original string
	ret			; return with zero false

nc_comp_09:
	pop	ax		; unjunk stack by trashing ax
	ret			; return with zero true
noncase_compare	endp

;	scan up a decimal string at ds:si.  Return the value in bx.
;	  trash ax,cx

scan_decimal_string proc near
	xor	bx,bx		; zero accumulator
scan_decimal_1:
	lodsb
	sub	al,'0'
	cmp	al,10
	jae	scan_decimal_9
	mov	cx,bx
	add	bx,bx
	add	bx,bx
	add	bx,cx
	add	bx,bx		; bx=bx*10
	cbw
	add	bx,ax
	jmp	scan_decimal_1
scan_decimal_9:
	dec	si		; point back to the delimiter
scandec_ret:
	ret
scan_decimal_string endp

;******************************************************************************
;
;       dumpmacs        dump the macro list to console output
;                       suppress first newline
;                       convert "><|^t" back to "$?" equivalent
;
;==============================================================================
 
dumpmacs        proc    near
	assume	ds:text,es:text
	xor	al,al		; set first time through flag
        mov     si,[macro_base]
        cmp     si,[macro_last]
        jz      scandec_ret
 
dmacs_t1:
        call    dstring         ; display a string
        mov     al,'='
        call    display_char
        call    dstringz        ; display the value
	cmp	si,[macro_last]	; done?
	jz	scandec_ret	; skip if so
	call	newline		; force newline between lines
	jmp	dmacs_t1	; and loop until done
 
dumpmacs        endp

;**********************************
;       dstringz: - display zero termianted string at si.  trash al,cx.
;         return si->after null
;	  translate special characters back into "$?" representation
;**********************************
 
dstringz proc   near
 
 
dstringz_1:
        lodsb                   ; get the character
        or      al,al
        jz      scandec_ret
 
        mov     ah,'b'          ; vertical bar
        cmp     al,'|'
        jz      dstringz_subs   ; make the $v substitution
        mov     ah,'g'          ; greater than
        cmp     al,'>'
        jz      dstringz_subs
        mov     ah,'l'
        cmp     al,'<'
        jz      dstringz_subs
        mov     ah,'t'
        cmp     al,ctrl_t
        jz      dstringz_subs
        cmp     al,'$'          ; is it '$'?
        jnz     dstringz_nosub  ; done if not

	lodsb			; and the character after it, which is
	mov	ah,al		;  known to be present after a '$'
dstringz_subs:
        push    ax
        mov     al,'$'
        call    display_char
        pop     ax
        mov     al,ah
dstringz_nosub:
        call    display_char
        jmp     dstringz_1              ; back to loop
 
dstringz endp
 
include doskey.cl2		; text for initialization time

end_of_init_code:
	if	hipper_install
base_of_buffers:
	endif

initseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlcmd1.asm ===
PAGE 60,132;
	TITLE EDLCMD1.ASM
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLCMD1.SAL
;
; DESCRIPTIVE NAME: EDLIN ROUTINES
;
; FUNCTION: THIS MODULE PROVIDES ROUTINES NEEDED FOR EDLIN'S EXECUTION.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; EXIT NORMAL: NA
;
; EXIT ERROR : NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD2 - ROUTINES MAY BE CALLED FROM EDLCMD2
;		 EDLMES  - ROUTINES MAY BE CALLED FROM EDLMES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;					- IMPLEMENT SYSPARSE
;					- IMPLEMENT MESSAGE RETRIEVER
;					- IMPLEMENT DBCS ENABLING
;					- ENHANCED VIDEO SUPPORT
;					- EXTENDED OPENS
;					- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================

include syscall.inc
include edlequ.asm

SUBTTL	Contants and Data areas
PAGE


CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD
	EXTRN	DSKFUL:abs,READ_ERR_PTR:word
	EXTRN	NOSUCH:abs,TOOLNG:abs,EOF:abs
	extrn	txt1:byte,txt2:byte
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
	extrn	ParamCt:WORD
	extrn	current:word,pointer:word,start:word,endtxt:word
	extrn	wrt_handle:word,editbuf:byte,path_name:byte,fname_len:word
	extrn	arg_buf:byte,arg_buf_ptr:word
	extrn	olddat:byte,oldlen:word,newlen:word,param1:word,param2:word
	extrn	srchflg:byte,srchmod:byte,comline:word,lstfnd:word,numpos:word
	extrn	lstnum:word,srchcnt:word,amnt_req:word,delflg:byte,lastlin:word
	extrn	three4th:word,one4th:word,last_mem:word,rd_handle:word,ending:byte
	extrn	haveof:byte
	extrn	Disp_Len:Byte

DATA	ENDS

CODE SEGMENT PUBLIC
ASSUME	CS:DG,DS:DG,SS:CStack,ES:DG

	extrn	findlin:near,shownum:near,loadbuf:near
	extrn	delbak:near,unquote:near,lf:near
	extrn	dispone:near,display:near,query:near
	extrn	quit:near,scanln:near,scaneof:near
	extrn	fndfirst:near,fndnext:near,replace:near,memerr:near
	extrn	std_printf:near,chkrange:near,comerr:near
	extrn	display_message:near

	public	zerror
	public	xerror,bad_read,append,nocom,pager,list
	public	delete,replac_from_curr,search_from_curr,ewrite,wrt

NOMOREJ:JMP	NOMORE

APPEND:
	CMP	ParamCt,1
	JZ	AppendOK
	JMP	ComErr
AppendOK:
	TEST	BYTE PTR [HAVEOF],-1
	JNZ	NOMOREJ
	MOV	DX,[ENDTXT]
	CMP	[PARAM1],0	;See if parameter is missing
	JNZ	PARMAPP
	CMP	DX,[THREE4TH]	;See if already 3/4ths full
	jb	parmapp
	return			;If so, then done already
PARMAPP:
	MOV	DI,DX
	MOV	CX,[LAST_MEM]
	SUB	CX,DX		;Amount of memory available
	jnz	sj53
	jmp	memerr
sj53:
	MOV	DX,[ENDTXT]
	MOV	BX,[RD_HANDLE]
	mov	[amnt_req],cx	;Save number of chars requested
	MOV	AH,READ
	INT	21H		;Fill memory with file data
	CMP	CX,AX		;Did we read less than we asked for?
	JZ	SJ55
; Make sure this is an end-of-file by trying to read more
	PUSH	AX		;Save old byte count
	ADD	DX,AX		;Point to next open space in buffer
	MOV	CX,1		;Just one character past EOF
	MOV	AH,READ
	INT	21H
	CMP	AX,0		      ;Is it EOF?
	POP	AX
	JNZ	SJ54		      ;No -- we have one more character
	MOV	BYTE PTR [HAVEOF],1   ;Yes - set old style system call flag
	JMP	SHORT SJ55
SJ54:
	INC	AX		      ;Include one more char in byte count
sj55:
	MOV	CX,AX		      ;Want byte count in CX
	PUSH	CX		      ;Save actual byte count
	CALL	SCANEOF
	JNZ	NOTEND
	MOV	BYTE PTR [HAVEOF],1	;Set flag if 1AH found in file
NOTEND:
	XOR	DX,DX
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	COUNTLN
	MOV	AX,DI
	ADD	AX,CX		;First byte after loaded text
	CMP	AX,[THREE4TH]	;See if we made 3/4 full
	JBE	COUNTLN
	MOV	DI,[THREE4TH]
	MOV	CX,AX
	SUB	CX,DI		;Length remaining over 3/4
	MOV	BX,1		;Look for one more line
COUNTLN:
	CALL	SCANLN		;Look for BX lines
	CMP	[DI-1],AL	;Check for full line
	JZ	FULLN
	CMP	HavEof,1
	JNZ	DoBackScan
;
; We have an incomplete line in the buffer at end of file.  Fix it up to be
; pretty.
;
	MOV	BYTE PTR [DI],13	; CR
	MOV	BYTE PTR [DI+1],10	; LF
	ADD	DI,2			; length is 2 greater
	POP	CX
	ADD	CX,2
	PUSH	CX
	JMP	SHORT FULLN

DoBackScan:
	DEC	DI
	MOV	CX,[LAST_MEM]
	STD
	REPNE	SCASB			;Scan backwards for last line
	CLD
	INC	DI
	INC	DI
	DEC	DX
FULLN:
	POP	CX				    ;Actual amount read
	MOV	WORD PTR [DI],1AH		    ;Place EOF after last line
	SUB	CX,DI
	XCHG	DI,[ENDTXT]
	ADD	DI,CX				    ;Amount of file read but not used
; Must seek for old partial line
	OR	DI,DI
	JZ	FULLN1
	PUSH	DX
	PUSH	BX
	MOV	BX,[RD_HANDLE]
	MOV	DX,DI
	NEG	DX
	MOV	CX,-1
	MOV	AL,1
	MOV	AH,LSEEK
	INT	21H
	POP	BX
	POP	DX
	JC	BAD_READ
FULLN1:
	CMP	BX,DX
	JNZ	EOFCHK
	MOV	BYTE PTR [HAVEOF],0
	return
NOMORE:
	mov	ax,EOF
	call	display_message
ret3:	return

BAD_READ:
	MOV	DX,OFFSET DG:READ_ERR_ptr
	MOV	DI,offset dg:path_name
	ADD	DI,[FNAME_LEN]
	MOV	AL,0
	STOSB
	JMP	XERROR

EOFCHK:
	TEST	BYTE PTR [HAVEOF],-1
	JNZ	NOMORE
	TEST	BYTE PTR [ENDING],-1
	retnz			;Suppress memory error during End
	JMP	MEMERR

EWRITE:
	CMP	ParamCt,1
	JBE	EWriteOK
	JMP	ComErr
EWriteOK:
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	WRT
	MOV	CX,[ONE4TH]
	MOV	DI,[ENDTXT]
	SUB	DI,CX		;Write everything in front of here
	JBE	RET3
	CMP	DI,OFFSET DG:START	;See if there's anything to write
	JBE	RET3
	XOR	DX,DX
	MOV	BX,1		;Look for one more line
	CALL	SCANLN
	JMP	SHORT WRTADD
WRT:
	INC	BX
	CALL	FINDLIN
WRTADD:
	CMP	BYTE PTR [DELFLG],0
	JNZ	WRTADD1
	PUSH	DI
	CALL	DELBAK			;Want to delete the .BAK file
					;as soon as the first write occurs
	POP	DI
WRTADD1:
	MOV	CX,DI
	MOV	DX,OFFSET DG:START
	SUB	CX,DX			;Amount to write
	retz
	MOV	BX,[WRT_HANDLE]
	MOV	AH,WRITE
	INT	21H
	JC	WRTERR
	CMP	AX,CX			; MZ correct full disk detection
	JNZ	WRTERR			; MZ correct full disk detection
	MOV	SI,DI
	MOV	DI,OFFSET DG:START
	MOV	[POINTER],DI
	MOV	CX,[ENDTXT]
	SUB	CX,SI
	INC	CX			;Amount of text remaining
	CLD
	REP	MOVSB
	DEC	DI			;Point to EOF
	MOV	[ENDTXT],DI
	MOV	[CURRENT],1
	return

WRTERR:
	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	mov	ax,DSKFUL
zerror:
	push	cs
	pop	ds
	call	display_message
xerror1111:
	mov	al,0ffh
	mov	ah,exit
	int	21h

xERROR:
	push	cs
	pop	ds
	call	std_printf
	jmp	xerror1111

NOTFNDJ:JMP	NOTFND

replac_from_curr:
	CMP	ParamCt,2
	JBE	Replace1
	JMP	ComErr
Replace1:
	mov	byte ptr [srchmod],1   ;search from curr+1 line
	jmp	short sj6

REPLAC:
	mov	byte ptr [srchmod],0   ;search from beg of buffer
sj6:
	MOV	BYTE PTR [SRCHFLG],0
	CALL	FNDFIRST
	JNZ	NOTFNDJ
REPLP:
	MOV	SI,[NUMPOS]
	CALL	LOADBUF 	;Count length of line
	SUB	DX,[OLDLEN]
	MOV	CX,[NEWLEN]
	ADD	DX,CX		;Length of new line
	CMP	DX,254
;	jbe	len_ok
;	Jmp	TOOLONG
	ja	toolong
len_ok:
	MOV	BX,[LSTNUM]
	PUSH	DX
	CALL	SHOWNUM
	POP	DX
	MOV	CX,[LSTFND]
	MOV	SI,[NUMPOS]
	SUB	CX,SI		;Get no. of char on line before change
	DEC	CX
	mov	di,offset dg:arg_buf	;Initialize the output string buffer
	CALL	OUTCNT		;Output first part of line
	PUSH	SI
	MOV	SI,1+ OFFSET DG:TXT2
	MOV	CX,[NEWLEN]
	CALL	OUTCNT		;Output change
	POP	SI
	ADD	SI,[OLDLEN]	;Skip over old stuff in line
	MOV	CX,DX		;DX=no. of char left in line
	ADD	CX,2		;Include CR/LF
	CALL	OUTCNT		;Output last part of line
	xor	al,al
	stosb
	mov	dx,offset dg:arg_buf_ptr
	call	std_printf
	CALL	QUERY		;Check if change OK
	JNZ	REPNXT
	CALL	PUTCURS
	MOV	DI,[LSTFND]
	DEC	DI
	MOV	SI,1+ OFFSET DG:TXT2
	MOV	DX,[OLDLEN]
	MOV	CX,[NEWLEN]
	DEC	CX
	ADD	[LSTFND],CX	;Bump pointer beyond new text
	INC	CX
	DEC	DX
	SUB	[SRCHCNT],DX	;Old text will not be searched
	JAE	SOMELEFT
	MOV	[SRCHCNT],0
SOMELEFT:
	INC	DX
	CALL	REPLACE
REPNXT:
	CALL	FNDNEXT
	retnz
	JMP	REPLP

OUTCNT:
	JCXZ	RET8
OUTLP:
	LODSB
	stosb
	DEC	DX
	LOOP	OUTLP
RET8:	return

TOOLONG:
	mov	ax,TOOLNG
	JMP	SHORT PERR

search_from_curr:
	CMP	ParamCt,2
	JBE	Search1
	JMP	ComErr
Search1:
	mov	byte ptr [srchmod],1   ;search from curr+1 line
	jmp	short sj7

SEARCH:
	mov	byte ptr [srchmod],0   ;search from beg of buffer
sj7:
	MOV	BYTE PTR [SRCHFLG],1
	CALL	FNDFIRST
	JNZ	NOTFND
SRCH:
	MOV	BX,[LSTNUM]
	MOV	SI,[NUMPOS]
	CALL	DISPONE
	MOV	DI,[LSTFND]
	MOV	CX,[SRCHCNT]
	MOV	AL,10
	CLD
	REPNE	SCASB
	JNZ	NOTFND
	MOV	[LSTFND],DI
	MOV	[NUMPOS],DI
	MOV	[SRCHCNT],CX
	INC	[LSTNUM]
	CALL	QUERY
	JZ	PUTCURS1
	CALL	FNDNEXT
	JZ	SRCH
NOTFND:
	mov	ax,NOSUCH
PERR:
	jmp	display_message

;
; Replace enters here with LSTNUM pointing to the correct line.
;
PUTCURS:
	MOV	BX,[LSTNUM]
	jmp	short putcursor
;
; Search enters here with LSTNUM pointing AFTER the correct line
;
putcurs1:
	MOV	BX,[LSTNUM]
	DEC	BX			;Current <= Last matched line

putcursor:
	CALL	FINDLIN
	MOV	[CURRENT],DX
	MOV	[POINTER],DI
	return

;
; n,mD	    deletes a range of lines.  Allowable values for n are:
;   1 ... LAST_MEM.  Allowable values for m are:
;   1 ... LAST_MEM.
; nD	    deletes a single line
; D	    deletes the current line
;
DELETE:
	CMP	ParamCt,2		; at most two parameters specified.
	JA	ComErrJ
	MOV	BX,Param1
	OR	BX,BX			; default first arg?
	JNZ	DelParm2
	MOV	BX,Current		; use current as default
	MOV	Param1,BX
DelParm2:
	MOV	BX,Param2		; did we default second arg?
	OR	BX,BX
	JNZ	DelCheck		; no, use it.
	MOV	BX,Param1		; use param1 as default
	MOV	Param2,BX
DelCheck:
	MOV	BX,Param1
	CALL	ChkRange		; returns by itself if bad range
;
; BX is first line of range to be deleted. Param2 is last line in range to
; be deleted.  Get pointer to beginning of block.  Save location
;
	CALL	FINDLIN 		; Grab line
	retnz				; If not found => return
	PUSH	BX
	PUSH	DI
;
; Get pointer past end of block (Param2+1).
;
	MOV	BX,Param2
	INC	BX
	CALL	FINDLIN
;
; Set up pointers.  Compute number of chars to move.
;
	MOV	SI,DI			; move from second line+1
	POP	DI			; restore destination (first line)
	POP	Current 		; Current line is first param
	MOV	Pointer,DI		; internal current line
	MOV	CX,EndTxt		; compute count
	SUB	CX,SI
	JB	ComErrJ 		; should never occur: ChkRange
	INC	CX			; remember ^Z at end
	CLD
	REP	MOVSB			; move data
	DEC	DI
	MOV	EndTxt,DI		; reset end pointer
	return

COMERRJ:
	JMP	COMERR

PAGER:
	CMP	ParamCt,2
	JA	ComErrJ
	xor	bx,bx		;get last line in the buffer
	call	findlin
	mov	[lastlin],dx

	mov	bx,[param1]
	or	bx,bx		;was it specified?
	jnz	frstok		;yes, use it
	mov	bx,[current]
	cmp	bx,1		;if current line =1 start from there
	je	frstok
	inc	bx		;start from current+1 line
frstok:
	cmp	bx,[lastlin]	;check that we are in the buffer
	jbe	frstok1
	return			;if not just quit
frstok1:
	mov	dx,[param2]
	or	dx,dx		;was param2 specified?
	jnz	scndok		;yes,....
	mov	dx,bx		;no, take the end line to be the
				;    start line + length of active display

;=========================================================================
; This modification is to provide support for screens larger than
; 24 lines.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax		;an000;save affected registers

	mov	ah,00h		;an000;zero out high byte
	mov	al,dg:disp_len	;an000;set ax to active display length
	sub	ax,2		;an000;adjust for length of screen & current
				;      line
	add	dx,ax		;an000;this gives us the last line to be
				;      printed
	pop	ax		;an000;restore affected registers

;=========================================================================

scndok:
	inc	dx
	cmp	dx,[lastlin]	;check that we are in the buffer
	jbe	infile
	mov	dx,[lastlin]	;we are not, take the last line as end
infile:
	cmp	dx,bx		;is param1 < param2 ?
	retz
	ja	sj33
	jmp	comerr		;yes, no backwards listing, print error
sj33:
	push	dx		;save the end line
	push	bx		;save start line
	mov	bx,dx		;set the current line
	dec	bx
	call	findlin
	mov	[pointer],di
	mov	[current],dx
	pop	bx		;restore start line
	call	findlin 	;get pointer to start line
	mov	si,di		;save pointer
	pop	di		;get end line
	sub	di,bx		;number of lines
	jmp	short display_lines


LIST:
	CMP	ParamCt,2
	JBE	ListOK
	JMP	ComERR
ListOK:
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	CHKP2
	MOV	BX,[CURRENT]
	SUB	BX,11
	JA	CHKP2
	MOV	BX,1
CHKP2:
	CALL	FINDLIN
	retnz
	MOV	SI,DI
	MOV	DI,[PARAM2]
	INC	DI
	SUB	DI,BX
	JA	DISPLAY_lines

;=========================================================================
; This modification is to provide support for screens larger than
; 24 lines.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax			;an000;save affected registers

	mov	ah,00h			;an000;zero out high byte
	mov	al,dg:disp_len		;an000;set ax to active display length	       dec     ax		       ;an000;allow room at bottom for
					;      messages
	mov	di,ax			;an000;number of lines to print an
					;      entire screen less 1.
	pop	ax			;an000;restore affected registers

;=========================================================================

display_lines:
	call	DISPLAY
	return

Break <NOCOM - edit a single line>

;
; NOCOM is called when there is a single line being edited.  This occurs when
; the command letter is CR or is ;.
;
NOCOM:
	CMP	ParamCt,2
	JB	NoComOK
	JMP	ComErr
NoComOK:
	DEC	[COMLINE]
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	HAVLIN
	MOV	BX,[CURRENT]
	INC	BX	;Default is current line plus one
	CALL	CHKRANGE
HAVLIN:
	CALL	FINDLIN
	MOV	SI,DI
	MOV	[CURRENT],DX
	MOV	[POINTER],SI
	jz	sj12
ret12:	return
sj12:
	CMP	SI,[ENDTXT]
	retz
	CALL	LOADBUF
	MOV	[OLDLEN],DX
	MOV	SI,[POINTER]
	CALL	DISPONE
	CALL	SHOWNUM
	MOV	AH,STD_CON_STRING_INPUT 	  ;Get input buffer
	MOV	DX,OFFSET DG:EDITBUF
	INT	21H
	CALL	lf
	MOV	CL,[EDITBUF+1]
	MOV	CH,0
	JCXZ	RET12
	MOV	DX,[OLDLEN]
	MOV	SI,2 + OFFSET DG:EDITBUF
;-----------------------------------------------------------------------
	call	unquote 		;scan for quote chars if any
;-----------------------------------------------------------------------
	mov	cl,[EditBuf+1]		;an000; dms;get new line length
	mov	ch,0			;an000; dms;clear high byte
	MOV	DI,[POINTER]
	JMP	Replace 		; MZ 11/30

CODE	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\doskey\gendef.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
debug_version	=	00000h		; enables alt-f8

LINE_LEN	=	128

;	command flags

INS_MODE	=	00000001B
EDITED		=	00000010B
OLDINP		=	00000100B	; there's still old input to scan
MAC_EXPAND	=	00001000B	; valid when OLDINP is, expanding macro

;	some common ascii values

bell		=	7
tab		=	9
lf		=	10
cr		=	13
ctrl_t		=	'T' and 1fh
ctrl_u		=	'U' and 1fh


; DOS INTERRUPTS

DOS_INT		=	21h
I2F_INT		=	2fh
IDLE_INT	=	28h
TSR_INT		=	27h

; DOS INT21H SUBFUNCTIONS

; Cpmio functions

CHAR_OUTPUT		=	02h
CHAR_INP_NO_ECHO	=	08h
BUFFERED_INPUT		=	0Ah
CHECK_INPUT_STATUS	=	0BH

ifdef	DBCS
ifdef   KOREA
; We can not use this functions because of lack of function
; ECS call related functions
;ECS_CALL                =       63h
;SET_GET_interim         =       01h             ; Subfunction of ECS call
;SET_interim             =       01h
CHECK_INPUT_INTERIM     =       0f1h
CHAR_INPUT_INTERIM      =       0f0h
CHAR_INTERIM            =       0f0h
CHAR_FINAL              =       0f1h
HANJA_AT_CCP            =       0f2h
endif	; KOREA
endif	; DBCS


;	note:  the our_version value is reported by our resident portion's
;	  int2f(4800h) along with its resident data segment.  This allows
;	  the transient part to verify that it's working with a compatible
;	  resident portion.  The version number needs to change only when the
;	  data variables which describe the workspace change.  The only
;	  thing that really matters right now about choosing a version
;	  number is that it is NOT 4800h, because a return code of 4800h
;	  is the indication that nobody hooked that interrupt.


our_version	=	0aa02h	; version stamp


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlcmd2.asm ===
PAGE 60,132
TITLE Edlcmd2 - PART2 procedures called from EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLCMD2.SAL
;
; DESCRIPTIVE NAME: EDLIN ROUTINES
;
; FUNCTION: THIS MODULE PROVIDES ROUTINES NEEDED FOR EDLIN'S EXECUTION.
;
; ENTRY POINT: ANY CALLED ROUTINE
;
; EXIT NORMAL: NA
;
; EXIT ERROR : NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD1 - ROUTINES MAY BE CALLED FROM EDLCMD1
;		 EDLMES  - ROUTINES MAY BE CALLED FROM EDLMES
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				    - IMPLEMENT SYSPARSE
;				    - IMPLEMENT MESSAGE RETRIEVER
;				    - IMPLEMENT DBCS ENABLING
;				    - ENHANCED VIDEO SUPPORT
;				    - EXTENDED OPENS
;				    - SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================

include edlequ.asm
include syscall.inc

CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS


DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD
	extrn	msg_crlf:abs,msg_lf:abs,qmes_ptr:byte,ask_ptr:byte
	extrn	bak:byte,$$$file:byte,delflg:byte,loadmod:byte,txt1:byte
	extrn	txt2:byte,memful_ptr:word

	extrn	Del_Bak_Ptr:byte		;an000;dms;
	extrn	cont_ptr:byte			;an000;dms:6/10/87

CONST	ENDS

DATA	SEGMENT PUBLIC WORD
	extrn	ParamCt:WORD
	extrn	current:word,pointer:word,start:word,endtxt:word
	extrn	wrt_handle:word,editbuf:byte,ext_ptr:word,qflg:byte
	extrn	temp_path:byte,line_num:word,line_flag:byte
	extrn	line_num_buf_ptr:byte,arg_buf:byte,arg_buf_ptr:word
	extrn	olddat:byte,oldlen:word,newlen:word,param1:word,param2:word
	extrn	srchflg:byte,srchmod:byte,comline:word,lstfnd:word,numpos:word
	extrn	lstnum:word,last_mem:word,srchcnt:word,amnt_req:word

	extrn	lc_adj:byte			;an000;dms:6/10/87
	extrn	continue:byte			;an000;dms:6/10/87
	extrn	pg_count:byte			;an000;dms:6/10/87
	extrn	Disp_Len:byte			;an000;dms;
	extrn	Disp_Width:byte 		;an000;dms;
	extrn	lc_flag:byte			;an000;dms:6/10/87

	ifdef	DBCS
	extrn	lbtbl:dword
	endif

DATA	ENDS

CODE SEGMENT PUBLIC

ASSUME	CS:DG,DS:DG,SS:CStack,ES:DG

	public	findlin,shownum,loadbuf,crlf,lf,abortcom,unquote
	public	kill_bl,make_caps,display,dispone,make_cntrl
	public	query,quit,scanln,delbak,scaneof,memerr
	public	fndfirst,fndnext,replace
	ifdef	DBCS
	public	testkanj
	endif
	extrn	std_printf:near,command:near,chkrange:near,ComErr:NEAR
	extrn	Xerror:near
	extrn	display_message:near


FINDLIN:

; Inputs
;	BX = Line number to be located in buffer (0 means last line+1)
; Outputs:
;	DX = Actual line found
;	DI = Pointer to start of line DX
;	Zero set if BX = DX (if specified line found)
; AL,CX destroyed. No other registers affected.

	MOV	DX,[CURRENT]
	MOV	DI,[POINTER]
	CMP	BX,DX			; fast find.  Current = requested
	retz
	JA	FINDIT			; start scanning at current?
	OR	BX,BX			; special case of EOF?
	JZ	FINDIT			; yes
	MOV	DX,1			; set up for scan at beginning
	MOV	DI,OFFSET DG:START
	CMP	BX,DX			; at beginning?
	retz
FINDIT:
	MOV	CX,[ENDTXT]		; count of bytes in buffer
	SUB	CX,DI			; for scan
SCANLN:
	MOV	AL,10			; LF is what we look for.
	OR	AL,AL			; Clear zero flag for JCXZ
FINLIN:
	JCXZ	RET4			; at end? Yes, no skip.
	REPNE	SCASB			; find EOL
	INC	DX			; increment count
	CMP	BX,DX			; find correct line?
	JNZ	FINLIN			; no, try again.
RET4:	return

; Inputs:
;	BX = Line number to be displayed
; Function:
;	Displays line number on terminal in 8-character
;	format, suppressing leading zeros.
; AX, CX, DX destroyed. No other registers affected.

SHOWNUM:
	mov	dx,offset dg:line_num_buf_ptr
	mov	line_num,bx
	MOV	line_flag,"*"
	CMP	BX,[CURRENT]
	JZ	STARLIN
	MOV	line_flag," "
STARLIN:
	call	std_printf
ret5:	return


DISPONE:
	MOV	DI,1

DISPLAY:

; Inputs:
;	BX = Line number
;	SI = Pointer to text buffer
;	DI = No. of lines
; Function:
;	Ouputs specified no. of line to terminal, each
;	with leading line number.
; Outputs:
;	BX = Last line output.
; All registers destroyed.

	MOV	CX,[ENDTXT]
	SUB	CX,SI
	retz				; no lines to display
;=========================================================================
; Initialize screen size and line counts for use by display.
;
;	Date	   : 6/10/87
;=========================================================================

	push	ax				;an000;save affected regs

	mov	al,dg:disp_len			;an000;length of video display
	mov	pg_count,al			;an000;init. screen size ctr.

	pop	ax				;an000;restore affected regs

;=========================================================================

	mov	dx,di				;number of lines to print
;
; CX is the number of bytes in the buffer
; dx is the number of lines to be output
;
DISPLN:
	SaveReg <CX,DX>
	CALL	SHOWNUM
	RestoreReg  <DX,CX>
	mov	di,offset dg:arg_buf
;
; Copy chars until CR/LF or end of line hit
;
OUTLN:
	LODSB
	CMP	DI,254+offset dg:arg_buf ; are we at end of buffer?
	JAE	StoreDone		; Yes, do NOT store
	CMP	AL," "
	JAE	SEND
	CMP	AL,10
	JZ	SEND
	CMP	AL,13
	JZ	SEND
	CMP	AL,9
	JZ	SEND
	MOV	AH,"^"
	OR	AL,40h
	XCHG	AL,AH
	STOSW
	JMP	short StoreDone
SEND:
	stosb
StoreDone:
	CMP	AL,10			; perform copy until LF is seen
	LOOPNZ	OUTLN
;
; Make sure buffer ends with CRLF
;
	cmp	byte ptr [di-1],10
	jz	Terminate
;
; No LF seen.  See if CR
;
	cmp	byte ptr [di-1],CR
	jz	StoreLF
	mov	al,CR
	stosb
StoreLF:
	mov	al,10
	stosb
Terminate:
	mov	byte ptr [di],0

	call	EDLIN_DISP_COUNT		;an000;determine lines printed
						;      DMS:6/10/87
	push	dx
	mov	dx,offset dg:arg_buf_ptr
	call	std_printf
	pop	dx
	JCXZ	ret7
	INC	BX

	call	EDLIN_PG_COUNT			;an000;adjust screen line count
						;      DMS:6/10/87
	cmp	lc_flag,false			;an000;continue DISPLAY?
						;      DMS:6/10/87
	JNZ	DISPLN
	DEC	BX
ret7:	return

FNDFIRST:
	MOV	DI,1+OFFSET DG:TXT1
	mov	byte ptr[olddat],1     ;replace with old value if none new
	CALL	GETTEXT
	OR	AL,AL		;Reset zero flag in case CX is zero
	JCXZ	RET7
	cmp	al,1ah		;terminated with a ^Z ?
	jne	sj8
	mov	byte ptr[olddat],0     ;do not replace with old value
sj8:
	MOV	[OLDLEN],CX
	XOR	CX,CX
	CMP	AL,0DH
	JZ	SETBUF
	CMP	BYTE PTR [SRCHFLG],0
	JZ	NXTBUF
SETBUF:
	DEC	SI
NXTBUF:
	MOV	[COMLINE],SI
	MOV	DI,1+OFFSET DG:TXT2
	CALL	GETTEXT
	CMP	BYTE PTR [SRCHFLG],0
	JNZ	NOTREPL
	CMP	AL,0DH
	JNZ	HAVCHR
	DEC	SI
HAVCHR:
	MOV	[COMLINE],SI
NOTREPL:
	MOV	[NEWLEN],CX
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	CALLER
	cmp	byte ptr[srchmod],0
	jne	sj9
	mov	bx,1	 ;start from line number 1
	jmp	short sj9a
sj9:
	MOV	BX,[CURRENT]
	INC	BX	;Default search and replace to current+1
sj9a:
	CALL	CHKRANGE
CALLER:
	CALL	FINDLIN
	MOV	[LSTFND],DI
	MOV	[NUMPOS],DI
	MOV	[LSTNUM],DX
	MOV	BX,[PARAM2]
	CMP	BX,1
	SBB	BX,-1	;Decrement everything except zero
	CALL	FINDLIN
	MOV	CX,DI
	SUB	CX,[LSTFND]
	OR	AL,-1
	JCXZ	aret
	CMP	CX,[OLDLEN]
	jae	sj10
aret:	return
sj10:
	MOV	[SRCHCNT],CX

FNDNEXT:

; Inputs:
;	[TXT1+1] has string to search for
;	[OLDLEN] has length of the string
;	[LSTFND] has starting position of search in text buffer
;	[LSTNUM] has line number which has [LSTFND]
;	[SRCHCNT] has length to be searched
;	[NUMPOS] has beginning of line which has [LSTFND]
; Outputs:
;	Zero flag set if match found
;	[LSTFND],[LSTNUM],[SRCHCNT] updated for continuing the search
;	[NUMPOS] has beginning of line in which match was made

	MOV	AL,[TXT1+1]
	MOV	CX,[SRCHCNT]
	MOV	DI,[LSTFND]
SCAN:
	OR	DI,DI		;Clear zero flag in case CX=0
	REPNE	SCASB		;look for first byte of string

	retnz			;return if you don't find
ifdef	DBCS
	call	kanji_check	;see if the found byte is on a character boundary
	jnz	scan
endif
	MOV	DX,CX
	MOV	BX,DI		;Save search position
	MOV	CX,[OLDLEN]
	DEC	CX
	MOV	SI,2 + OFFSET DG:TXT1
	CMP	AL,AL		;Set zero flag in case CX=0
	REPE	CMPSB
	MOV	CX,DX
	MOV	DI,BX
	JNZ	SCAN
	MOV	[SRCHCNT],CX
	MOV	CX,DI
	MOV	[LSTFND],DI
	MOV	DI,[NUMPOS]
	SUB	CX,DI
	MOV	AL,10
	MOV	DX,[LSTNUM]
;Determine line number of match
GETLIN:
	INC	DX
	MOV	BX,DI
	REPNE	SCASB
	JZ	GETLIN
	DEC	DX
	MOV	[LSTNUM],DX
	MOV	[NUMPOS],BX
	XOR	AL,AL
	return

ifdef	DBCS

;Kanji_check		idea is to scan backwards to the first
;			character which can't be a kanji or part of one
;			(.lt. DB_SP_LO) then scan forward to see if the
;			current byte is on character boundary
;
;Output 	ZR <==> we're on a character boundary
;		NZ <==> we're not on character boundary i.e. No Match
kanji_check:
	push	ax			;save search character
	push	di
	dec	di			;point to the character we found
	mov	si,di			;start searching bakwards from there
	std
srch_loop:
	lodsb
	cmp	al,DB_SP_LO
	jae	srch_loop
	inc	si			;point to first non-kanji
	cld				;forward search
kan_loop:
	cmp	si,di			;are we at current byte?
	jae	passed_char		;if we are, or are passed it, exit
	call	next_char		;otherwise advance si to next char
	jmp	short kan_loop		;and loop
passed_char:
	pop	di
	pop	ax
	ret

;Next_char		si points to a character boundary
;			advance si to point to the beginning of the next char
;
;
next_char:
	push	ax
	lodsb
	call	testkanj
	jz	not_kanj
	inc	si
not_kanj:
	pop	ax
	ret

;--------------------------------------------------------------------;
; TESTKANJ ~ FIND OUT IS THE BYTE IS A KANJI PREFIX		     ;
;								     ;
; entry:  AL	byte to test					     ;
;								     ;
; exit:   NZ if lead byte ortherwise  ZR			     ;
;								     ;
; modifies:	AX						     ;
;								     ;
;--------------------------------------------------------------------;

testkanj:
	push	ax
	xchg	ah,al		    ;put byte in ah
	push	ds
	push	si
	lds	si,cs:[lbtbl]	       ;get pointer to lead byte table
ktlop:
	lodsb			    ;direction flag should be OK
	or	al,al		    ;are we at the end of table?
	jz	notlead 	    ;brif so
	cmp	al,ah		    ;is START RANGE > CHARACTER?
	ja	notlead 	    ;brif so, not a lead character (carry clear)
	lodsb			    ;get second range byte
	cmp	ah,al		    ;is CHARACTER > END RANGE
	ja	ktlop		    ;brif so, not a lead character (check next range)
	or	al,al		    ;make NZ
notl_exit:
	pop	si
	pop	ds
	pop	ax
	ret
notlead:
	cmp	al,al
	jmp	notl_exit

endif

GETTEXT:

; Inputs:
;	SI points into command line buffer
;	DI points to result buffer
; Function:
;	Moves [SI] to [DI] until ctrl-Z (1AH) or
;	RETURN (0DH) is found. Termination char not moved.
; Outputs:
;	AL = Termination character
;	CX = No of characters moved.
;	SI points one past termination character
;	DI points to next free location

	XOR	CX,CX

GETIT:
	LODSB
;-----------------------------------------------------------------------
	cmp	al,quote_char	;a quote character?
	jne	sj101		;no, skip....
	lodsb			;yes, get quoted character
	call	make_cntrl
	jmp	short sj102
;-----------------------------------------------------------------------
sj101:
	CMP	AL,1AH
	JZ	DEFCHK
sj102:
	CMP	AL,0DH
	JZ	DEFCHK
	STOSB
	INC	CX
	JMP	SHORT GETIT

DEFCHK:
	OR	CX,CX
	JZ	OLDTXT
	PUSH	DI
	SUB	DI,CX
	MOV	BYTE PTR [DI-1],cl
	POP	DI
	return

OLDTXT:
	cmp	byte ptr[olddat],1	;replace with old text?
	je	sj11			;yes...
	mov	byte ptr[di-1],cl	;zero text buffer char count
	return

sj11:
	MOV	CL,BYTE PTR [DI-1]
	ADD	DI,CX
	return

REPLACE:

; Inputs:
;	CX = Length of new text
;	DX = Length of original text
;	SI = Pointer to new text
;	DI = Pointer to old text in buffer
; Function:
;	New text replaces old text in buffer and buffer
;	size is adjusted. CX or DX may be zero.
; CX, SI, DI all destroyed. No other registers affected.

	CMP	CX,DX
	JZ	COPYIN
	PUSH	SI
	PUSH	DI
	PUSH	CX
	MOV	SI,DI
	ADD	SI,DX
	ADD	DI,CX
	MOV	AX,[ENDTXT]
	SUB	AX,DX
	ADD	AX,CX
	CMP	AX,[LAST_MEM]
	JAE	MEMERR
	XCHG	AX,[ENDTXT]
	MOV	CX,AX
	SUB	CX,SI
	CMP	SI,DI
	JA	DOMOV
	ADD	SI,CX
	ADD	DI,CX
	STD
DOMOV:
	INC	CX

	REP	MOVSB
	CLD
	POP	CX
	POP	DI
	POP	SI
COPYIN:
	REP	MOVSB
	return

MEMERR:
	MOV	DX,OFFSET DG:MEMFUL_ptr
	call	std_printf
	JMP	COMMAND


LOADBUF:
	MOV	DI,2 + OFFSET DG:EDITBUF
	MOV	CX,255
	MOV	DX,-1
LOADLP:
	LODSB
	STOSB
	INC	DX
	CMP	AL,13
	LOOPNZ	LOADLP
	MOV	[EDITBUF+1],DL
	retz
TRUNCLP:
	LODSB
	INC	DX
	CMP	AL,13
	JNZ	TRUNCLP
	DEC	DI
	STOSB
	return

SCANEOF:
	cmp	[loadmod],0
	je	sj52

;----- Load till physical end of file

	cmp	cx,word ptr[amnt_req]
	jb	sj51
	xor	al,al
	inc	al		;reset zero flag
	return
sj51:
	jcxz	sj51b
	push	di		;get rid of any ^Z at the end of the file
	add	di,cx
	dec	di		;points to last char
	cmp	byte ptr [di],1ah
	pop	di
	jne	sj51b
	dec	cx
sj51b:
	xor	al,al		;set zero flag
	call	check_end	;check that we have a CRLF pair at the end
	return

;----- Load till first ^Z is found

sj52:
	PUSH	DI
	PUSH	CX
	MOV	AL,1AH
	or	cx,cx
	jz	not_found	;skip with zero flag set
	REPNE	SCASB		;Scan for end of file mark
	jnz	not_found
	LAHF				;Save flags momentarily
	inc	cx			;include the ^Z
	SAHF				;Restore flags
not_found:
	mov	di,cx			;not found at the end
	POP	CX
	LAHF				;Save flags momentarily
	SUB	CX,DI			;Reduce byte count if EOF found
	SAHF				;Restore flags
	POP	DI
	call	check_end		;check that we have a CRLF pair at the end

	return


;-----------------------------------------------------------------------
;	If the end of file was found, then check that the last character
; in the file is a LF. If not put a CRLF pair in.

check_end:
	jnz	not_end 		;end was not reached
	pushf				;save return flag
	push	di			;save pointer to buffer
	add	di,cx			;points to one past end on text
	dec	di			;points to last character
	cmp	di,offset dg:start
	je	check_no
	cmp	byte ptr[di],0ah	;is a LF the last character?
	je	check_done		;yes, exit
check_no:
	mov	byte ptr[di+1],0dh	;no, put a CR
	inc	cx			;one more char in text
	mov	byte ptr[di+2],0ah	;put a LF
	inc	cx			;another character at the end
check_done:
	pop	di
	popf
not_end:
	return

CRLF:
	push	dx
	mov	ax,msg_crlf
	call	display_message
	pop	dx
	return
LF:
	mov	ax,msg_lf
	jmp	display_message

ABORTCOM:
	MOV	AX,CS
	MOV	DS,AX
	MOV	ES,AX
	MOV	AX,cstack
	MOV	SS,AX
	MOV	SP,STACK
	STI
	CALL	CRLF
	JMP	COMMAND

DELBAK:
	;Delete old backup file (.BAK)

	MOV	BYTE PTR [DELFLG],1
	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:BAK
	MOVSW
	MOVSW
	MOVSB
	MOV	AH,UNLINK
	MOV	DX,OFFSET DG:TEMP_PATH
	INT	21H
;	$if	c					;error ?		;an000; dms;
	JNC $$IF1
		cmp	ax,Access_Denied		;file read only?	;an000; dms;
;		$if	e				;yes			;an000; dms;
		JNE $$IF2
			mov	bx,[Wrt_Handle] 	;close .$$$ file	;an000; dms;
			mov	ah,Close		;close function 	;an000; dms;
			int	21h			;close it		;an000; dms;

			mov	di,[Ext_Ptr]		;point to extension	;an000; dms;
			mov	si,offset dg:$$$File	;point to .$$$ extension;an000; dms;
			movsw				;get .$$$ extension	;an000; dms;
			movsw				;			;an000; dms;
			movsb				;			;an000; dms;
			mov	dx,offset dg:Temp_Path	;point to .$$$ file	;an000; dms;
			mov	ah,Unlink		;delete it		;an000; dms;
			int	21h			;			;an000; dms;

			mov	di,[Ext_Ptr]		;point to extension	;an000; dms;
			mov	si,offset dg:BAK	;point to .BAK extension;an000; dms;
			movsw				;get .BAK extension	;an000; dms;
			movsw				;			;an000; dms;
			movsb				;			;an000; dms;
			mov	dx,offset dg:Del_Bak_Ptr;point to error message ;an000; dms;
			jmp	Xerror			;display message & exit ;an000; dms;
;		$endif
$$IF2:
;	$endif
$$IF1:

	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:$$$FILE
	MOVSW
	MOVSW
	MOVSB
	return


;-----------------------------------------------------------------------;
; Will scan buffer given pointed to by SI and get rid of quote
;characters, compressing the line and adjusting the length at the
;begining of the line.
; Preserves al registers except flags and AX .

unquote:
	push	cx
	push	di
	push	si
	mov	di,si
	mov	cl,[si-1]	;length of buffer
	xor	ch,ch
	mov	al,quote_char
	cld
unq_loop:
	jcxz	unq_done	;no more chars in the buffer, exit
	repnz	scasb		;search for quote character
	jnz	unq_done	;none found, exit
	push	cx		;save chars left in buffer
	push	di		;save pointer to quoted character
	push	ax		;save quote character
	mov	al,byte ptr[di] ;get quoted character
	call	make_cntrl
	mov	byte ptr[di],al
	pop	ax		;restore quote character
	mov	si,di
	dec	di		;points to the quote character
	inc	cx		;include the carriage return also
	rep	movsb		;compact line
	pop	di		;now points to after quoted character
	pop	cx
	jcxz	sj13		;if quote char was last of line do not adjust
	dec	cx		;one less char left in the buffer
sj13:	pop	si
	dec	byte ptr[si-1]	;one less character in total buffer count also
	push	si
	jmp	short unq_loop

unq_done:
	pop	si
	pop	di
	pop	cx
	return


;-----------------------------------------------------------------------;
;	Convert the character in AL to the corresponding control
; character. AL has to be between @ and _ to be converted. That is,
; it has to be a capital letter. All other letters are left unchanged.

make_cntrl:
	push	ax
	and	ax,11100000b
	cmp	ax,01000000b
	pop	ax
	jne	sj14
	and	ax,00011111b
sj14:
	return


;---- Kill spaces in buffer --------------------------------------------;
;=========================================================================
; kill_bl : Parses over spaces in a buffer.
;
;	Date	   : 6/10/86
;=========================================================================
kill_bl:

	push	bx			;an000;save affected reg.
kill_bl_cont:

	lodsb				;get rid of blanks
	    cmp al,9
	    je	kill_bl_cont		;an000;it is a tab

	    cmp al,10
	    je	kill_bl_cont		;an000;if LF

	    cmp al,' '
	    je	kill_bl_cont		;an000;we have a space

	ifdef DBCS			;an000;is this a kanji assembly
	     call testkanj		;an000;do we have a dbcs lead byte
;	     $if  nz			;an000;yes, we have a lead byte
	     JZ $$IF5
		  cmp  al,DB_SP_HI	;an000;is it DB_SP_HI
;		  $if  z		;an000;it is DB_SP_HI
		  JNZ $$IF6
		       mov  bl,ds:[si]	;an000;set up for compare
		       cmp  bl,DB_SP_LO ;an000;is it DB_SP_LO
;		       $if  z		;an000;we have an asian blank
		       JNZ $$IF7
			    lodsb	;an000;skip byte containing 81h
			    jmp kill_bl_cont
;		       $endif		;an000;
$$IF7:
;		  $endif		;an000;fall through no delim
$$IF6:
					;      found
;	     $endif			;an000;end test for dbcs lead byte
$$IF5:
	endif				;an000;end conditional assembly

	pop	bx			;an000;restore affected reg.
	return

;----- Capitalize the character in AL ----------------------------------;
;									;
;   Input:								;
;									;
;	    AL	    contains a character to capitalize			;
;									;
;   Output:								;
;									;
;	    AL	    contains a capitalized character			;
;									;
;-----------------------------------------------------------------------;

MAKE_CAPS:
	CMP	AL,"a"
	JB	CAPS1
	CMP	AL,"z"
ifdef DBCS
	JA	CAPS1		; M003 MSKK TAR 476, kana chars
else
	JG	CAPS1
endif
	AND	AL,0DFH
CAPS1:
	return

QUIT:
	CMP	ParamCt,1
	JZ	Quit1
CERR:	JMP	ComErr
Quit1:	CMP	Param1,0
	JNZ	CERR
	MOV	DX,OFFSET DG:QMES_ptr
	call	std_printf

IFDEF	DBCS
	CALL	TESTKANJ
	JZ	ASCII
	MOV	AX, (STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21H		; Eat the trailing byte.
	JMP	CRLF
ASCII:
ENDIF
;=========================================================================
; We are invoking the VAL_YN proc here.  This will replace the
; method of Y/N validation used prior to DOS 4.00.
;
;	Date	   : 6/10/87
;=========================================================================

	call	val_yn		;an000;pass Y/N byte in AL to macro
	cmp	ax,yes		;an000;did we return a Y
	jz	NoCRLF		;an000; dms; close the file
	cmp	ax,no		;an000; dms; return N?
;	$if	ne		;an000; dms; neither N or Y - reprompt
	JE $$IF11
		call	crlf			; spit out crlf
		jmp	Quit1			;an000; dms; reprompt
;	$endif			;an000; dms;
$$IF11:
	call	crlf			; spit out CRLF
	return				;an000; dms;

;=========================================================================
; End of Y/N validation check for qmes_ptr
;=========================================================================

NOCRLF:
	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	MOV	DX,OFFSET DG:TEMP_PATH
	MOV	AH,UNLINK
	INT	21H
	mov	ah,exit
	xor	al,al
	INT	21H

QUERY:
	TEST	BYTE PTR [QFLG],-1
	retz
	MOV	DX,OFFSET DG:ASK_ptr
	call	std_printf
	PUSH	AX
	CALL	CRLF
	POP	AX
IFDEF	DBCS
	CALL	TESTKANJ
	JZ	ASCII1
	PUSH	AX
	MOV	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0
	INT	21H		;Eat the trailing byte
	XOR	AX,AX
	INC	AX		; non zero flag
	POP	AX
	return
ASCII1:
ENDIF
	CMP	AL,13		;Carriage return means yes
	retz
;=========================================================================
; We are invoking the VAL_YN proc here.  This will replace the
; method of Y/N validation used prior to DOS 4.00.
; This invocation of val_yn will return ZR if Y is found, otherwise
; it will return NZ.
;
;	Date	   : 6/10/87
;=========================================================================

	call	val_yn		;an000;pass Y/N byte in AL to macro
	cmp	ax,yes		;an000;did we return a Y
	je	Query_Exit	;an000; dms; exit Y/N validation
	cmp	ax,no		;an000; dms; N response?
	jne	Query		;an000; dms; no - reprompt user
	cmp	ax,yes		;an000; dms; must have N response - force
				;	     NZ flag
Query_Exit:


;=========================================================================
; End of Y/N validation check for ask_ptr
;=========================================================================

	return

;=========================================================================
; EDLIN_DISP_COUNT: This routine will determine the number of lines
;		    actually displayed to the screen.  Lines displayed to
;		    the screen for one EDLIN line printed will be calculated
;		    by the following formula:
;
;		LINES_PRINTED = (LINE_LEN + 10) / SCREEN_WIDTH
;
;		LINES_PRINTED - Actual number of lines printed on screen
;				for one EDLIN line.  If LINES_PRINTED has
;				a remainder, it will be rounded up.
;
;		LINE_LEN      - The length, in bytes, of the EDLIN line
;				printed.
;
;		SCREEN_WIDTH  - The width in bytes of the current display.
;
;	Inputs : DI - offset into buffer containing line printed
;		 DISP_WIDTH  - width of current video output
;
;	Outputs: LC_ADJ - factor to adjust line counter by
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_DISP_COUNT	proc	near		;an000;lines printed

	push	dx				;an000;save affected regs
	push	di				;an000;
	push	ax				;an000;
	push	bx				;an000;
	push	cx				;an000;

	mov	bx,offset dg:arg_buf		;an000;arg_buf holds line
						;      printed
	mov	ax,di				;an000;where print line ends
	sub	ax,bx				;an000;diff = line's length
	add	ax,10				;an000;adjust for leading blks
	mov	cl,dg:disp_width		;an000;set up for division
	div	cl				;an000;divide AX by the
						;      width of the console
	cmp	ah,0				;an000;see if a remainder
;	$if	nz				;an000;if a remainder
	JZ $$IF13
		add al,1			;an000;increment AL 1
						;      to round upward
;	$endif					;an000;
$$IF13:

	mov	lc_adj,al			;an000;number of lines printed
						;      on console
	pop	cx				;an000;restore affected regs
	pop	bx				;an000;
	pop	ax				;an000;
	pop	di				;an000;
	pop	dx				;an000;

	ret					;an000;return to caller

EDLIN_DISP_COUNT	endp			;an000;end proc

;=========================================================================
; EDLIN_PG_COUNT : This routine determines whether or not we will continue
;		   displaying text lines based on the count of lines that
;		   can be output to the current video screen.
;
;	Inputs : LC_ADJ    - adjustment factor for number of lines printed
;		 PG_COUNT  - number of lines remaining on current video
;			     display
;		 DX	   - holds the total number of lines to print
;		 CONTINUE  - signals if the user wants to continue
;			     printing lines.
;
;	Outputs: LC_FLAG   - used to signal completion of print
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_PG_COUNT		proc	near		;an000;track remaining lines

	push	ax				;an000;save affected regs

	mov	lc_flag,true			;an000;init. flag to signal
						;      continue printing

	mov	al,pg_count			;an000;set up for page adj.
	cmp	al,lc_adj			;an000;see if we are at end
;	$if	be				;an000
	JNBE $$IF15
		mov	pg_count,0		;an000;set pg_count to 0
;	$else
	JMP SHORT $$EN15
$$IF15:
		sub	al,lc_adj		;an000;adjust number of lines
		mov	pg_count,al		;an000;save remaining line ct.
;	$endif					;an000;
$$EN15:

	dec	dx				;an000;decrease total number
						;      of lines to print by 1
;	$if	nz				;an000;more lines to print
	JZ $$IF18
	    cmp    pg_count,0			;an000;have we printed screen
;	    $if    be				;an000;we have printed screen
	    JNBE $$IF19
		   call    EDLIN_PG_PROMPT	;an000;prompt the user to
						;      "Continue(Y/N)?"
		   cmp	  continue,true 	;an000;did user say continue
;		   $if	  z			;an000;continue
		   JNZ $$IF20
			  mov	al,dg:disp_len	;an000;begin init of screen
;			  dec	al		;an000;    length
			  mov	pg_count,al	;an000;
;		   $else			;an000;do not continue
		   JMP SHORT $$EN20
$$IF20:
			  mov	lc_flag,false	;an000;signal no more to print
;		   $endif			;an000;
$$EN20:
;	    $endif				;an000;
$$IF19:
;	$else					;an000;total lines printed
	JMP SHORT $$EN18
$$IF18:
	    mov    lc_flag,false		;an000;signal no more to print
;	$endif					;an000;
$$EN18:

	pop	ax				;an000;restore affected regs

	ret					;an000;return to caller

EDLIN_PG_COUNT		endp			;an000;end procedure

;=========================================================================
; EDLIN_PG_PROMPT : This routine prompts the user as to whether or not to
;		    continue printing lines to the video display, if lines
;		    are still present for printing.
;
;	Inputs : none
;
;	Outputs: CONTINUE - flag that signals other routines whether or
;			    not to continue printing.
;
;	Date	   : 6/10/87
;=========================================================================

EDLIN_PG_PROMPT 	proc	near		;an000;ask user to continue?

	push	dx				;an000;save affected regs.
	push	ax				;an000;

EPP_Reprompt:

	mov	dx,offset dg:cont_ptr		;an000;point to Continue msg.
	call	std_printf			;an000;invoke message ret.

	push	ax				;an000;save affected regs.
	call	crlf				;an000;send crlf
	pop	ax				;an000;restore affected regs.

	call	val_yn				;an000;Y/N validation

	cmp	ax,yes				;an000;did we have a Y
	jz	EPP_True_Exit			;an000;we had a Y
	cmp	ax,no				;an000;did we have a N
	jz	EPP_False_Exit			;an000;yes
	jmp	EPP_Reprompt			;an000;neither Y or N - reprompt

EPP_True_Exit:

	mov	Continue,True			;an000;flag Y found
	jmp	short EPP_Exit			;an000;exit routine

EPP_False_Exit:

	mov	Continue,False			;an000;flag N found

EPP_Exit:

	pop	ax				;an000;restore affected regs.
	pop	dx				;an000;

	ret					;an000;return to caller

EDLIN_PG_PROMPT 	endp			;an000;end procedure

;=========================================================================
; val_yn: This proc validates a Y/N response entered by the user.  The
;	  routine uses the new functionality of "GET EXTENDED COUNTRY
;	  INFORMATION" being implemented in DOS 4.00.
;
; Inputs : AL - character to be validated for Y/N response
;
; Outputs: AX - 00h = "N"o
;	      - 01h = "Y"es
;=========================================================================

val_yn	proc	near		;an000;validate Y/N response

	push	dx		;an000;save affected registers
	push	cx		;an000;
	push	bx		;an000;

	mov	dl,al		;an000;character to be checked for Y/N
	mov	ah,GetExtCntry	;an000;get extended country information
	mov	al,yn_chk	;an000;perform Y/N checking
	mov	cx,max_len	;an000;max. len. of Y/N char.
	int	21h		;an000;invoke function

	pop	bx		;an000;restore affected registers
	pop	cx		;an000;
	pop	dx		;an000;

	ret			;an000;return to caller

val_yn	endp			;an000;end proc



code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlstdsw.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)stdsw.asm	1.1 85/04/10
; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system


;include EDLVERS.INC			;IBM/MSVER/JAPVER switches


WANG	EQU	FALSE
Rainbow EQU	FALSE


; Set this switch to cause DOS to move itself to the end of memory
HIGHMEM EQU	FALSE

	IF	IBM
ESCCH	EQU	0			; character to begin escape seq.
CANCEL	EQU	27			;Cancel with ESCAPE
TOGLPRN EQU	TRUE			;One key toggles printer echo
ZEROEXT EQU	TRUE
	ELSE
	IF	WANG			;Are we assembling for WANG?
ESCCH	EQU	1FH			;Yes. Use 1FH for escape character
	ELSE
ESCCH	EQU	1BH
	ENDIF
CANCEL	EQU	"X"-"@"                 ;Cancel with Ctrl-X
TOGLPRN EQU	FALSE			;Separate keys for printer echo on
					;and off
ZEROEXT EQU	TRUE
	ENDIF


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlequ.asm ===
page	60,132			;
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

	.xlist
	include version.inc
	include DOSSYM.INC
	include EDLSTDSW.INC
	.list

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLEQU.SAL
;
; DESCRIPTIVE NAME: EQUATES FOR EDLIN
;
; FUNCTION: PROVIDES EQUATES FOR EDLIN.  IT ALSO PROVIDES THE MACRO
;	    VAL_YN.
;
; ENTRY POINT: NA
;
; INPUT: NA
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
;	ROUTINE: VAL_YN - VALIDATES Y/N RESPONSES FROM THE KEYBOARD
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: NA
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT SYSPARSE
;				- IMPLEMENT MESSAGE RETRIEVER
;				- IMPLEMENT DBCS ENABLING
;				- ENHANCED VIDEO SUPPORT
;				- EXTENDED OPENS
;				- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;
;======================= END OF SPECIFICATIONS ===========================






COMAND_LINE_LENGTH EQU 128
QUOTE_CHAR EQU	16H			;Quote character = ^V
CR	EQU	13
STKSIZ	EQU	200h
STACK	equ	stksiz

asian_blk      equ DB_SP_LO		;an000;asian blank 2nd. byte
dbcs_lead_byte equ DB_SP_HI		;an000;asian blank lead byte
nul	equ	00h			;an000;nul character
Access_Denied equ 0005h 		;an000;extended error code for access denied

;======== Y/N validation equates =========================================

yn_chk	equ	23h			;an000;check for Y/N response
max_len equ	01h			;an000;max. len. for Y/N char.
yes	equ	01h			;an000;boolean yes value
no	equ	00h			;an000;boolean no value

;======== text display values for initialization =========================

video_get equ	0fh			;an000;int 10 get video attributes
video_set equ	00h			;an000;int 10 set video attributes
video_text equ	03h			;an000;80 X 25 color monitor

;======== code page values for functions =================================

get_set_cp equ	66h			;an000;get or set code page
get_cp	equ	01h			;an000;get active code page
set_cp	equ	02h			;an000;set active code page

;======== screen length & width defaults =================================

std_out equ	01h			;an000;console output
display_attr equ 03h			;an000;display for IOCTL
Get_Display equ 7fh			;an000;Get display for IOCTL
ifndef JAPAN
Def_Disp_Len equ 25			;an000;default display length
else					; if JAPAN
Def_Disp_Len equ 24
endif
Def_Disp_Width equ 80			;an000;default display width

;======== extended open equates ==========================================

rw	equ	0082h			;an000;read/write
					;      compatibility
					;      noinherit
					;      int 24h handler
					;      no commit

ext_read equ	0080h			;an000;read
					;      compatibility
					;      noinherit
					;      int 24h handler
					;      no commit

rw_flag equ	0101h			;an000;fail if file not exist
					;      open if file exists
					;      don't validate code page

creat_flag equ	0110h			;an000;create if file does not exist
					;      fail if file exists
					;      don't validate code page

open_flag equ	0101h			;an000;fail if file not exist
					;      open if file exists
					;      don't validate code page

creat_open_flag equ 0112h		;an000;create if file does not exist
					;      open/replace if file exists
					;      don't validate code page

attr	equ	00h			;an000;attributes set to 0

;======== parse value equates ============================================

nrm_parse_exit equ 0ffffh		;an000;normal exit from sysparse
too_many equ	01h			;an000;too many parms entered
op_missing equ	02h			;an000;required operand missing
sw_missing equ	03h			;an000;not a valid switch


;======== Strucs =========================================================

Display_Buffer_Struc Struc		;an000;dms;

	Display_Info_Level db	   ?	;an000;dms;
	Display_Reserved db	 ?	;an000;dms;
	Display_Buffer_Size dw	    ?	;an000;dms;
	Display_Flags dw      ? 	;an000;dms;
	Display_Mode db      ?		;an000;dms;
					;  TEXT=01
					;  APA =02
	Display_Mode_Reserved db      ? ;an000;dms;
	Display_Colors dw      ?	;an000;dms;# of colors
	Display_Width_Pixels dw      ?	;an000;dms;# of pixels in width
	Display_Length_Pixels dw      ? ;an000;dms;# of pixels in len.
	Display_Width_Char dw	   ?	;an000;dms;# of chars in width
	Display_Length_Char dw	    ?	;an000;dms;# of chars in length

Display_Buffer_Struc ends		;an000;dms;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlmes.asm ===
PAGE	60,132;
	title	EDLIN Messages
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLMES.SAL
;
; DESCRIPTIVE NAME: MESSAGE RETRIEVER INTERFACE MODULE
;
; FUNCTION: THIS MODULE PROVIDES AN INTERFACE FOR THE MODULES THAT ARE
;	    NEEDED TO INVOKE THE MESSAGE RETRIEVER.
;
; ENTRY POINT: PRINTF
;
; INPUT: OFFSET CARRIED IN DX TO APPLICABLE MESSAGE TABLE
;
; EXIT NORMAL: NO CARRY
;
; EXIT ERROR : CARRY
;
; INTERNAL REFERENCES:
;
;	ROUTINE: PRINTF - PROVIDES THE ORIGINAL INTERFACE FOR THE ORIGINAL
;			  PRINTF USED PRIOR TO VERSION 4.00.  PRINTS MESSAGES.
;
;		 DISP_MESSAGE - BUILDS THE REGISTERS NECESSARY FOR INVOCATION
;			  OF THE MESSAGE RETRIEVER, BASED ON THE TABLE
;			  POINTED TO BY DX.
;
;		 DISP_FATAL - INVOKED IF AN ERROR OCCURS (CARRY) IN THE
;			  MESSAGE RETRIEVER.  IT DISPLAYS THE APPROPRIATE
;			  MESSAGE.
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: SYSLOADMSG - LOAD MESSAGES FOR THE MESSAGE RETRIEVER
;		 SYSDISPMSG - DISPLAYS THE REQUESTED MESSAGE
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION DOS 4.00 - IMPLEMENTATION OF MESSAGE RETRIEVER
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft  "
;
; MICROSOFT REVISION HISTORY
;
;	 MODIFIED BY: AARON R
;		      M.A. U
;		      N. P
;======================= END OF SPECIFICATIONS ===========================

.xlist

include sysmsg.inc				;an000;message retriever

msg_utilname <EDLIN>				;an000;EDLIN messages
.list
;-----------------------------------------------------------------------;
;									;
;	Done for Vers 2.00 (rev 9) by Aaron R				;
;	Update for rev. 11 by M.A. U					;
;	Printf for 2.5 by Nancy P					;
;									;
;-----------------------------------------------------------------------;

;=========================================================================
; revised edlmes.asm
;=========================================================================

fatal_error	equ	30			;an000;fatal message handler
unlim_width	equ	00h			;an000;unlimited output width
pad_blank	equ	20h			;an000;blank pad
pre_load	equ	00h			;an000;normal pre-load




message_table	struc				;an000;struc for message table

	entry1	dw	0			;an000;message number
	entry2	db	0			;an000;message type
	entry3	dw	0			;an000;display handle
	entry4	dw	0			;an000;pointer to sublist
	entry5	dw	0			;an000;substitution count
	entry6	db	0			;an000;use keyb input?
	entry7	dw	0			;an000;keyb buffer to use

message_table	ends				;an000;end struc

;=========================================================================
; macro disp_message: this macro takes a pointer to a message table
;		      and displays the applicable message based on
;		      the table's contents.
;		      this is to provide an interface into the module
;		      of the message retriever, SYSDISPMSG.
;
;	Date	  : 6/11/87
;=========================================================================

disp_message	macro	tbl			;an000;display message macro

	push	bx				;an000;
	push	cx				;an000;
	push	dx				;an000;
	push	di				;an000;
	push	si				;an000;

	push	tbl				;an000;exchange tbl with si
	pop	si				;an000;exchanged

	mov	ax,[si].entry1			;an000;move message number
	mov	bx,[si].entry3			;an000;display handle
	mov	cx,[si].entry5			;an000;number of subs
	mov	dl,[si].entry6			;an000;function type
	mov	di,[si].entry7			;an000;input buffer if appl.
	mov	dh,[si].entry2			;an000;message type
	mov	si,[si].entry4			;an000;sublist

	call	sysdispmsg			;an000;display the message

	pop	si				;an000;restore affected regs
	pop	di				;an000;
	pop	dx				;an000;
	pop	cx				;an000;
	pop	bx				;an000;

endm						;an000;end macro disp_message

;=========================================================================
; macro disp_message: end macro
;=========================================================================

CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC BYTE

	extrn	path_name:byte

DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

code	segment public	byte			;an000;code segment
	assume cs:dg,ds:dg,es:dg,ss:CStack	;an000;

	public	printf				;an000;share printf
	public	disp_fatal			;an000;fatal error display
	public	pre_load_message		;an000;message loader

.xlist
msg_services <MSGDATA>				;an000;
.list

;======================= sysmsg.inc invocation ===========================
;
;	include sysmsg.inc - message retriever services
;
;
; options selected:
;		    NEARmsg
;		    DISPLAYmsg
;		    LOADmsg
;		    CHARmsg
;		    NUMmsg
;		    CLSAmsg
;		    CLSBmsg
;		    CLSCmsg
;
;=========================================================================

.xlist

 msg_services <LOADmsg> 			;an000;no version check
 msg_services <DISPLAYmsg,CHARmsg,NUMmsg,INPUTmsg>  ;an000;display messages
 msg_services <EDLIN.CLA,EDLIN.CLB,EDLIN.CLC>	;an000;message types
 msg_services <EDLIN.CL1,EDLIN.CL2>		;an000;message types
 msg_services <EDLIN.CTL>			;an000;

.list

;=========================================================================
; printf: printf is a replacement of the printf procedure used in DOS
;	  releases prior to 4.00.  printf invokes the macro disp_message
;	  to display a message through the new message handler.  the
;	  interface into printf will continue to be a pointer to a message
;	  passed in DX.  the pointer is pointing to more than a message
;	  now.	it is pointing to a table for that message containing
;	  all relevant information for printing the message.  the macro
;	  disp_message operates on these tables.
;
;	Date	  : 6/11/87
;=========================================================================

printf	proc	near				;an000;printf procedure

	disp_message	dx			;an000;display a message
;	$if	c				;an000;if an error occurred
	JNC $$IF1
		call	disp_fatal		;an000;display the fatal error
;	$endif					;an000;
$$IF1:

	ret					;an000;return to caller

printf	endp					;an000;end printf proc


;=========================================================================
; disp_fatal: this routine displays a fatal error message in the event
;	      an error occurred in disp_message.
;
;	Date	  : 6/11/87
;=========================================================================

disp_fatal proc near				;an000;fatal error message

	mov	ax,fatal_error			;an000;fatal_error number
	mov	bx,stdout			;an000;print to console
	mov	cx,0				;an000;no parameters
	mov	dl,no_input			;an000;no keyboard input
	mov	dh,UTILITY_MSG_CLASS		   ;an000;utility messages

	call	sysdispmsg			;an000;display fatal error

	ret					;an000;return to caller

disp_fatal endp 				;an000;end disp_fatal proc

;=========================================================================
; PRE_LOAD_MESSAGE : This routine provides access to the messages required
;		     by EDLIN.	This routine will report if the load was
;		     successful.  An unsuccessful load will cause EDLIN
;		     to terminate with an appropriate error message.
;
;	Date	  : 6/11/87
;=========================================================================

PRE_LOAD_MESSAGE	proc	near		;an000;pre-load messages


	call	SYSLOADMSG			;an000;invoke loader

;	$if	c				;an000;if an error
	JNC $$IF3
		pushf				;an000;save flags
		call	SYSDISPMSG		;an000;let him say why
		popf				;an000;restore flags
;	$endif					;an000;
$$IF3:

	ret					;an000;return to caller

PRE_LOAD_MESSAGE	endp			;an000;end proc

include msgdcl.inc

code	ends					;an000;end code segment




CONST	SEGMENT PUBLIC BYTE

	extrn	arg_buf:byte			;an000;
	extrn	line_num:byte			;an000;
	extrn	line_flag:byte			;an000;
	extrn	Temp_Path:byte			;an000;

	public	baddrv,opt_err_ptr,nobak
	public	simple_msg
	public	msg_too_many,dskful,memful_ptr,badcom
	public	nodir,filenm_ptr,newfil,read_err_ptr
	public	nosuch,toolng,eof,dest
	public	mrgerr,ro_err,bcreat,ndname
	public	dsp_options,dsp_help,num_help_msgs
	public	ask_ptr,qmes_ptr,msg_crlf,msg_lf
	public	prompt
	public	line_num_buf_ptr		;an000;DMS:6/15/87
	public	arg_buf_ptr			;an000;DMS:6/15/87
	public	cont_ptr			;an000;DMS:6/18/87
	public	cp_err				;an000;DMS:6/22/87
	public	Del_Bak_Ptr			;an000;dms;

;============== REPLACEABLE PARAMETER SUBLIST STRUCTURE ==================
;
;	byte 1	-	substitution list size, always 11
;	byte 2	-	reserved for use by message handler
;	byte 3	-	pointer to parameter to be used as a substitution
;	byte 7	-	which parameter is this to replace, %1, %2, etc.
;	byte 8	-	determines how the parameter is to be output
;	byte 9	-	determines the maximum width of the parameter string
;	byte 10 -	determines the minimum width of the parameter string
;	byte 11 -	define what is to be used as a pad character
;
;=========================================================================

;=========================================================================
;	     replaceable parameter sublists
;=========================================================================

ed_read_sub	label	dword			;an000;a read error occurred

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:path_name			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blanks

arg_sub 	label	dword			;an000;line output buffer

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:arg_buf			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank

num_sub 	label	dword			;an000;line number

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:line_num			   ;an000;pointer to parameter
	db	01				;an000;parm 1
	db	Right_Align+Unsgn_Bin_Word	;an000;right align/decimal
	db	08				;an000;maximum width
	db	08				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank

	db	11				;an000;optional flag
	db	00				;an000;reserved
	dd	dg:line_flag			   ;an000;pointer to parameter
	db	02				;an000;parm 2
	db	Char_Field_Char 		;an000;character
	db	01				;an000;minimum width of 1
	db	01				;an000;maximum width of 1
	db	pad_blank			;an000;pad with blank

BAK_Sub 	label	dword			;an000;line output buffer

	db	11				;an000;sublist size
	db	00				;an000;reserved
	dd	dg:Temp_Path			;an000;pointer to parameter
	db	00				;an000;parm 0
	db	Char_Field_ASCIIZ		;an000;left align/asciiz/char.
	db	unlim_width			;an000;unlimited width
	db	00				;an000;minimum width of 0
	db	pad_blank			;an000;pad with blank


;=========================================================================
;	     end replaceable parameter sublists
;=========================================================================

;======================= TABLE STRUCTURE =================================
;
;	bute 1-2  :	message number of message to be displayed
;	byte 3	  :	message type to be used, i.e.;class 1, utility, etc.
;	byte 4-5  :	display handle, i.e.; console, printer, etc.
;	byte 6-7  :	pointer to substitution list, if any.
;	byte 8-9  :	number of replaceable parameters, if any.
;	byte 10   :	type of input from keyboard, if any.
;	byte 11-12:	pointer to buffer for keyboard input, if any.
;
;=========================================================================

;	a bunch of common messages (class=UTILITY_MSG_CLASS, dest=stdout,
;				    no inputs or sublists) are passed
;				    through absolute message numbers rather
;				    than duplicating the data structure for
;				    each one.

prompt		=	0006	; "*"
baddrv		=	0007	; "Invalid drive or file name"
ndname		=	0008	;"File name must be
				;specified",0d,0a,0
ro_err		=	0010	;"File is READ-ONLY",0d,0a,0
bcreat		=	0011	;"File Creation Error",0d,0a,0
msg_too_many	=	0012	;"Too many files open",0d,0a,0
nobak		=	0014	;"Cannot edit .BAK file
				;--rename file",0d,0a,0
nodir		=	0015	;"No room in directory
				;for file",0d,0d,0
dskful		=	0016	;"Disk full. Edits lost.",0d,0a,0
badcom		=	0018	;"Entry error",0d,0a,0
newfil		=	0019	;"New file",0d,0a,0
nosuch		=	0020	;"Not found",0d,0a,0
toolng		=	0022	;"Line too long",0d,0a,0
eof	 	=	0023	;"End of input file",0d,0a,0
dest		=	0025	;"Must specify destination
				;line number",0d,0a,0
mrgerr		=	0026	;"Not enough room to
				;merge the entire file",0d,0a,0
msg_crlf	=	0027	;0d,0a,0
msg_lf		=	0028	;0a,0
cp_err		=	0033	;"Cannot merge - Code page
				;	mismatch",0d,0a
dsp_options	=	0300	; display options
dsp_help	=	0301	; display help
num_help_msgs	=	7

simple_msg	label	word
		dw	0000  		; message number (supplied as used)
		db	UTILITY_MSG_CLASS  ; utility message
		dw	stdout		; display handle
		dw	00		; no sublist
		dw	00		; no sub
		db	no_input	; no keyboard input
		dw	00		; no keyboard buffer


opt_err_ptr	label	word		;an000;"Invalid parameter",0d,0a,0
		dw	0010		;an000;message number
		db	Parse_Err_Class ;an000;utility message
		dw	StdErr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

read_err_ptr	label	word		;an000;"Read error in:",
					;an000;0d,0a,"%1",0d,0a,0
		dw	0013		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:ed_read_sub	;an000;point to sublist
		dw	0001		;an000;1 sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

memful_ptr	label	word		;an000;"Insufficient memory",0d,0a,0
		dw	0008		;an000;message number
		db	Ext_Err_Class	;an000;extended error
		dw	stderr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

filenm_ptr	label	word		;an000;"File not found",0d,0a
		dw	0002		;an000;message number
		db	Ext_Err_Class	;an000;utility message
		dw	stderr		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

ask_ptr 	label	word		;an000;"O.K.? ",0
		dw	0021		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sub
		dw	00		; no sublist
		db	DOS_KEYB_INP	;an000;keyboard input - AX
		dw	00		;an000;no keyboard buffer

qmes_ptr	label	word		;an000;"Abort edit (Y/N)? ",0
		dw	0024		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	DOS_KEYB_INP	;an000;keyboard input - AX
		dw	00		;an000;no keyboard buffer

cont_ptr	label	word		;an000;"Continue (Y/N)?"
		dw	0029		;an000;message number
		db	UTILITY_MSG_CLASS  ;an000;utility message
		dw	stdout		;an000;display handle
		dw	00		;an000;no sublist
		dw	00		;an000;no sub
		db	DOS_KEYB_INP	;an000;keyboard input
		dw	00		;an000;no keyboard buffer

arg_buf_ptr	label	word		;an000;argument buffer for
					;      line output
		dw	0031		;an000;message number
		db	UTILITY_MSG_CLASS     ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:arg_sub	;an000;argument sublist
		dw	01		;an000;1 sub
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

line_num_buf_ptr label	word		;an000;holds line numbers
		dw	0032		;an000;message number
		db	UTILITY_MSG_CLASS     ;an000;utility message
		dw	stdout		;an000;display handle
		dw	dg:num_sub	;an000;argument sublist
		dw	02		;an000;2 subs
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

del_bak_ptr	label	word		;an000;"Access Denied - xxxxxxxx.BAK"
		dw	0005		;an000;message number
		db	Ext_Err_Class	;an000;utility message
		dw	stderr		;an000;display handle
		dw	dg:BAK_Sub	;an000;no sublist
		dw	01		;an000;no subs
		db	no_input	;an000;no keyboard input
		dw	00		;an000;no keyboard buffer

CONST	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlparse.asm ===
page	60,132;
	title	EDLPARSE for EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


;******************* START OF SPECIFICATIONS *****************************
;
; MODULE NAME: EDLPARSE.SAL
;
; DESCRIPTIVE NAME: PARSES THE EXTERNAL COMMAND LINE FOR EDLIN
;
; FUNCTION: THIS ROUTINE PROVIDES PARSING CAPABILITIES FOR THE
;	    EXTERNAL COMMAND LINE OF EDLIN.  IT PARSES FOR THE PRESENCE
;	    OF A REQUIRED FILESPEC AND AN OPTIONAL SWITCH (/B).
;
; ENTRY POINT: PARSER_COMMAND
;
; INPUT: DOS COMMAND LINE
;
; EXIT NORMAL: AX = 0FFH    - VALID SWITCH AND FILESPEC SPECIFIED
;
; EXIT ERROR:  AX NOT= 0FFH - INVALID SWITCH OR NO FILESPEC SPECIFIED
;
; INTERNAL REFERENCES
;
;	ROUTINE: PARSER_COMMAND - THIS ROUTINE PARSES FOR THE PRESENCE
;				  OF THE /B SWITCH AND A FILESPEC.  THE
;				  FILEPSEC IS REQUIRED, WHILE THE SWITCH
;				  IS OPTIONAL.
;
; EXTERNAL REFERENCES:
;
;     ROUTINE: PARSE.ASM - THIS IS THE PARSER CODE.
;
; NOTES: THIS MODULE IS TO BE PREPPED BY SALUT WITH THE "PR" OPTIONS.
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - IMPLEMENTS THE SYSTEM PARSER (SYSPARSE)
;
; COPYRIGHT: "THE IBM PERSONAL COMPUTER EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft"
;
;
;******************** END OF SPECIFICATIONS ******************************


;======================= equates for edlparse ============================

parse_ok	equ	0			;an000;good parse return
parse_command	equ	081h			;an000;offset of command line
nul		equ	0			;an000;nul
fs_flag 	equ	05h			;an000;filespec found
sw_flag 	equ	03h			;an000;switch found
true		equ	0ffffh			;an000;true
false		equ	00h			;an000;false
too_many	equ	01h			;an000;too many parms

;======================= end equates =====================================


CODE	SEGMENT PUBLIC BYTE
CODE	ENDS

CONST	SEGMENT PUBLIC BYTE
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC BYTE

	extrn	path_name:byte
	extrn	org_ds:word			;an000; dms;

	public	parse_switch_b			;an000;parse switch result
	public	parse_switch_?			;      parse switch result
	public	filespec			;an000;actual filespec

;======================= input parameters control blocks =================
; these control blocks are used by sysparse and must be pointed to by
; es:di on invocation.

		public	parms			;an000;share parms
parms		label	byte			;an000;parms control block
		dw	dg:parmsx		;an000;point to parms structure
		db	00h			;an000;no additional delims.

parmsx		label	byte			;an000;parameter types
		db	1,1			;an000;must have filespec
		dw	dg:fs_pos		;an000;filespec control block
		db	2			;an000;max. number of switches
		dw	dg:sw_b 		;an000;/b switch control block
		dw	dg:sw_? 		;an000;/? switch control block
		db	00h			;an000;no keywords

;======================= filespec positional tables ======================

fs_pos		label	byte			;an000;filespec positional
		dw	0200h			;an000;filespec/not optional
		dw	0001h			;an000;cap
		dw	dg:filespec_res 	;an000;filespec result table
		dw	dg:noval		;an000;value list/none
		db	0			;an000;no keyword/switch syns.

filespec_res	label	byte			;an000;filespec result table
parse_fs_res	db	?			;an000;must be filespec (05)
parse_fs_tag	db	?			;an000;item tag
parse_fs_syn	dw	?			;an000;synonym pointer
parse_fs_off	dw	?			;an000;offset to filespec
parse_fs_seg	dw	?			;an000;segment of filespec

;======================= switch tables /b ================================

sw_b		label	byte			;an000;/b switch
		dw	0000h			;an000;no match flags
		dw	0000h			;an000;no cap
		dw	dg:switch_res		;an000;result buffer
		dw	dg:noval		;an000;value list/none
		db	1			;an000;1 switch
sw_b_switch	db	"/B",0			;an000;/B means ignore CTL-Z

sw_?		label	byte			;an000;/b switch
		dw	0000h			;an000;no match flags
		dw	0000h			;an000;no cap
		dw	dg:switch_res		;an000;result buffer
		dw	dg:noval		;an000;value list/none
		db	1			;an000;1 switch
sw_?_switch	db	"/?",0			;an000;/B means ignore CTL-Z
	PUBLIC sw_?_switch
switch_res	label	byte			;an000;switch result table
parse_sw_res	db	?			;an000;must be string (03)
parse_sw_tag	db	?			;an000;item tag
parse_sw_syn	dw	?			;an000;synonym pointer
parse_sw_ptr	dd	?			;an000;pointer to result

noval		label	byte			;an000;value table
		db	0			;an000;no values


;======================= end input parameter control blocks ==============

filespec	db	128 dup (0)		;an000;holds filespec
parse_switch_b	db	false			;an000;hold boolean result
						;      of /b parse
parse_switch_?	db	false			; true if /? found
parse_sw_b	db	"/B"			;an000;comparison switch

DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

code	segment public	byte			;an000;code segment
	assume cs:dg,ds:dg,es:dg,ss:CStack	;an000;

	public	parser_command			;an000;share this routine



;======================= begin main routine ==============================
.xlist

include version.inc  ; parse.asm include psdata.inc which needs defs from here
include parse.asm				;an000;parser

.list

parser_command	proc	near			;an000;parse routine

	push	es				;an000;save registers
	push	ds				;an000;
	push	di				;an000;
	push	si				;an000;

	mov	dg:parse_switch_b,false 	;an000;init. to false
	xor	cx,cx				;an000;set cx to 0
	xor	dx,dx				;an000;set dx to 0
	mov	di,offset dg:parms		;an000;point to parms
	mov	si,parse_command		;an000;point to ds:81h
	mov	ds,dg:org_ds			;an000;get ds at entry
	assume	ds:nothing			;an000;

parse_continue: 				;an000;loop return point

	call	sysparse			;an000;invoke parser
	cmp	ax,parse_ok			;an000;is it a good parse
	jne	parse_end			;an000;continue on good parse
	push	si
	mov	si,dx
	cmp	byte ptr es:[si],fs_flag	;an000;do we have a filespec
;	$if	e				;an000;yes we do
	JNE $$IF1
		call build_fs			;an000;save filespec
;	$else					;an000;
	JMP SHORT $$EN1
$$IF1:
	; A switch was found.
	; See which one it was.

	  call	val_sw				;an000;see which switch

;	$endif					;an000;
$$EN1:

	pop	si
	jmp	parse_continue			;an000;continue parsing

parse_end:					;an000;end parse routine

	pop	si				;an000;restore registers
	pop	di				;an000; for return to caller
	pop	ds				;an000;
	assume	ds:dg				;an000;
	pop	es				;an000;

	ret					;an000;return to caller

parser_command	endp				;an000;end parser_command


;======================= subroutine area =================================


;=========================================================================
; build_fs: This routine saves the filespec for use by the calling program.
;=========================================================================

build_fs	proc	near			;an000;save filespec

	push	ax				;an000;save affected regs.
	push	di				;an000;
	push	si				;an000;
	push	ds				;an000;
	push	es				;an000;

	mov	di,offset dg:filespec		;an000;point to filespec buffer
	lds	si,dword ptr es:parse_fs_off	;an000;get offset

build_cont:					;an000;continue routine

	lodsb					;an000;mov ds:si to al
	cmp	al,nul				;an000;is it end of filespec
;	$if	nz				;an000;if not
	JZ $$IF7
		stosb				;an000;move byte to filespec
		jmp build_cont			;an000;continue buffer fill
;	$endif					;an000;
$$IF7:
	stosb					;an000;save nul

	pop	es				;an000;restore regs
	pop	ds				;an000;
	pop	si				;an000;
	pop	di				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

build_fs	endp				;an000;end proc

;=========================================================================
; val_sw : determines which switch we have.
;=========================================================================

val_sw		proc	near			;an000;switch determination

	; Check for /B

	cmp	es:[parse_sw_syn], offset es:sw_b_switch
	jne	ValSwitchBDone
	cmp	es:[parse_switch_b], true	; see if already given
	jne	ValSwitchBOkay			; jump if not
	mov	ax, too_many			; set error level
	jmp	parse_end			;  and exit parser
ValSwitchBOkay:
	mov	es:[parse_switch_b], true	; set the flag on
	jmp	short ValSwitchExit		;  and done
ValSwitchBDone:

	; Check for /?

	cmp	es:[parse_sw_syn], offset es:sw_?_switch
	jne	ValSwitch?Done
	mov	es:[parse_switch_?], true	; set the flag on
	jmp	short ValSwitchExit		;  and done
ValSwitch?Done:

ValSwitchExit:

	ret					;an000;return to caller

val_sw		endp				;an000;end proc


code	ends					;an000;end segment
	end					;an000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\display.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */


CODE    SEGMENT PARA PUBLIC 'CODE'
CODE    ENDS
DATA    SEGMENT PARA PUBLIC 'DATA'
DATA    ENDS
STACK   SEGMENT PARA STACK  'STACK'
STACK   ENDS
ZLOAD   SEGMENT PARA PUBLIC 'ZLOAD'
ZLOAD   ENDS

CODE    SEGMENT PARA PUBLIC 'CODE'
        assume  cs:code,ds:data
;
;*****************************************************************************
; External Declarations
;*****************************************************************************
;

        extrn   SysDispMsg:near

;
;***************************************************************************
; Message Structures
;***************************************************************************
;


Message_Table struc                             ;                               ;AN000;
                                                ;
Entry1  dw      0                               ;                               ;AN000;
Entry2  dw      0                               ;                               ;AN000;
Entry3  dw      0                               ;                               ;AN000;
Entry4  dw      0                               ;                               ;AN000;
Entry5  db      0                               ;                               ;AN000;
Entry6  db      0                               ;                               ;AN000;
Entry7  dw      0                               ;                               ;AN000;
                                                ;
Message_Table ends                              ;                               ;AN000;



;*****************************************************************************
;Routine name&gml Display_Interface
;*****************************************************************************
;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg
;             routine. This information is contained in a message description
;             table pointed to by the DX register. Call SysDispMsg, then
;             restore registers. This routine assumes that the only time an
;             error will be returned is if an extended error message was
;             requested, so it will ignore error returns
;
;Called Procedures: Message (macro)
;
;Change History&gml Created        4/22/87         MT
;
;Input&gml ES&gmlDX = pointer to message description
;
;Output&gml None
;
;Psuedocode
;----------
;
;       Save all registers
;       Setup registers for SysDispMsg from Message Description Tables
;       CALL SysDispMsg
;       Restore registers
;       ret
;*****************************************************************************

Public  Display_Interface
Display_Interface   proc                        ;                               ;AN000;

        push    ds                              ;                               ;AN000;
        push    es                              ;                               ;AN000;
        push    ax                              ;Save registers                 ;AN000;
        push    bx                              ; "  "    "  "                  ;AN000;
        push    cx                              ; "  "    "  "                  ;AN000;
        push    dx                              ; "  "    "  "                  ;AN000;
        push    si                              ; "  "    "  "                  ;AN000;
        push    di                              ; "  "    "  "                  ;AN000;
        mov     di,dx                           ;Change pointer to table        ;AN000;
        mov     dx,SEG data                     ;Point to data segment
        mov     ds,dx                           ;
        mov     es,dx
        mov     ax,[di].Entry1                  ;Message number                 ;AN000;
        mov     bx,[di].Entry2                  ;Handle                         ;AN000;
        mov     si,[di].Entry3                  ;Sublist                        ;AN000;
        mov     cx,[di].Entry4                  ;Count                          ;AN000;
        mov     dh,[di].Entry5                  ;Class                          ;AN000;
        mov     dl,[di].Entry6                  ;Function                       ;AN000;
        mov     di,[di].Entry7                  ;Input                          ;AN000;
        call    SysDispMsg                      ;Display the message            ;AN000;
        pop     di                              ;Restore registers              ;AN000;
        pop     si                              ; "  "    "  "                  ;AN000;
        pop     dx                              ; "  "    "  "                  ;AN000;
        pop     cx                              ; "  "    "  "                  ;AN000;
        pop     bx                              ; "  "    "  "                  ;AN000;
        pop     ax                              ; "  "    "  "                  ;AN000;
        pop     es                              ;                               ;AN000;
        pop     ds                              ;                               ;AN000;
        ret                                     ;All done                       ;AN000;

Display_Interface      endp                     ;                               ;AN000;
code    ends


        end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\e2bchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
;
;
;*****************************************************************************
;*                                                                           *
;* Change list to EXE2BIN modules                                            *
;*                                                                           *
;* Lines are tagged ANxxx for new, ACxxx for changed                         *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test          *
;*         Date: 12/31/87  Developer: Dennis M	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 PTM P3964 Pass invalid parameter to message retriever for *
;*         replacement in error message.                                     *
;*         Date: 03/24/88  Developer: Dennis M	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*****************************************************************************
;* Note: This is file E2BCHNG.INC for updating purposes                      *
;*****************************************************************************
.list


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\edlin\edlin.asm ===
PAGE	60,132;
	TITLE	EDLIN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;======================= START OF SPECIFICATIONS =========================
;
; MODULE NAME: EDLIN.SAL
;
; DESCRIPTIVE NAME: LINE TEXT EDITOR
;
; FUNCTION: EDLIN IS A SIMPLE, LINE ORIENTED TEXT EDITOR.  IT PROVIDES
;	    USERS OF DOS THE ABILITY TO CREATE AND EDIT TEXT FILES.
;
; ENTRY POINT: EDLIN
;
; INPUT: DOS COMMAND LINE
;	 EDLIN COMMANDS
;	 TEXT
;
; EXIT NORMAL: NA
;
; EXIT ERROR: NA
;
; INTERNAL REFERENCES:
;
; EXTERNAL REFERENCES:
;
;	ROUTINE: EDLCMD1 - CONTAINS ROUTINES CALLED BY EDLIN
;		 EDLCMD1 - CONTAINS ROUTINES CALLED BY EDLIN
;		 EDLMES  - CONTAINS ROUTINES CALLED BY EDLIN
;
;	 LINK EDLIN+EDLCMD1+EDLCMD2+EDLMES+EDLPARSE
;
; REVISION HISTORY:
;
;	AN000	VERSION 4.00 - REVISIONS MADE RELATE TO THE FOLLOWING:
;
;				- IMPLEMENT SYSPARSE
;				- IMPLEMENT MESSAGE RETRIEVER
;				- IMPLEMENT DBCS ENABLING
;				- ENHANCED VIDEO SUPPORT
;				- EXTENDED OPENS
;				- SCROLLING ERROR
;
; COPYRIGHT: "MS DOS EDLIN UTILITY"
;	     "VERSION 4.00 (C) COPYRIGHT 1988 Microsoft"
;	     "LICENSED MATERIAL - PROPERTY OF Microsoft"
;
;
;	MICROSOFT REVISION HISTORY:
;									;
;	V1.02										;
;									;
;	V2.00	9/13/82  M.A.U						;
;									;
;		2/23/82  Rev. 13	N. P					;
;		    Changed to 2.0 system calls.				;
;		    Added an error message for READ-ONLY files		;
;									;
;		11/7/83  Rev. 14	N. P					;
;		    Changed to .EXE format and added Printf		;
;									;
;	V2.50	11/15/83 Rev. 1 	M.A. U					;
;		    Official dos 2.50 version. Some random bug		;
;		fixes and message changes.					;
;									;
;		11/30/83 Rev. 2 	MZ						;
;		    Close input file before rename.				;
;		    Jmp to replace after line edit				;
;									;
;		02/01/84 Rev. 3 	M.A. U			;
;		    Now it is called 3.00 dos. Repaired problem 	;
;		with using printf and having %'s as data.                       ;
;									;
;		02/15/84 MZ make out of space a fatal error with output;
;									;
;		03/28/84 MZ fixes bogus (totally) code in MOVE/COPY	;
;									;
;		04/02/84 MZ fixes DELETE and changes MOVE/COPY/EDIT	;
;									;
;	V3.20 08/29/86 Rev. 1 S.M. G					;
;									;
;		08/29/86 M001 MSKK TAR 593, TAB MOVEMENT		;
;									;
;		08/29/86 M002 MSKK TAR 157, BLKMOVE 1,1,1m, 1,3,1m	;
;									;
;		08/29/86 M003 MSKK TAR 476, EDLCMD2,MAKECAPS,kana char	;
;									;
;		08/29/86 M004 MSKK TAR 191, Append load size		;
;									;
;		08/29/86 M005 IBMJ TAR Transfer Load command		;
;									;
;	04/17/90 c-PaulB						;
;		Added /? switch to display options			;
;		Files changed: edlin.asm, edlparse.asm, edlmes.asm,	;
;		edlin.skl.						;
;									;
;======================= END OF SPECIFICATIONS ===========================									;

include version.inc
include intnat.inc
include syscall.inc
include edlequ.asm


SUBTTL	Contants and Data areas
PAGE
	extrn	parser_command:near		;an000;SYSPARSE

CODE	SEGMENT PUBLIC
CODE	ENDS

CONST	SEGMENT PUBLIC WORD
CONST	ENDS

cstack	segment stack
cstack	ends

DATA	SEGMENT PUBLIC WORD
DATA	ENDS

DG	GROUP	CODE,CONST,cstack,DATA

CONST	SEGMENT PUBLIC WORD

	public	bak,$$$file,delflg,loadmod,txt1,txt2

	EXTRN	BADDRV:abs,NDNAME:abs
	EXTRN	opt_err_ptr:word,NOBAK:abs,BADCOM:abs
	EXTRN	NEWFIL:abs,DEST:abs,MRGERR:abs
	EXTRN	NODIR:abs,FILENM_ptr:word,ro_err:abs
	EXTRN	bcreat:abs,msg_too_many:abs,msg_lf:abs
	EXTRN	prompt:abs,MemFul_Ptr:word,simple_msg:word
	extrn	dsp_options:abs
	extrn	dsp_help:abs,num_help_msgs:abs

BAK	DB	".BAK",0

$$$FILE DB	".$$$",0

fourth	db	0			;fourth parameter flag

loadmod db	0			;Load mode flag, 0 = ^Z marks the
					; end of a file, 1 = viceversa.
optchar db	"-"

TXT1	DB	0,80H DUP (?)
TXT2	DB	0,80H DUP (?)
DELFLG	DB	0
fNew	DB	0			; old file
HAVEOF	DB	0

CONST	ENDS

cstack	segment stack
	db  stksiz dup (?)
cstack	ends

DATA	SEGMENT PUBLIC WORD

	extrn	arg_buf_ptr:word		;an000;
	extrn	line_num_buf_ptr:word		;an000;

	public	path_name,ext_ptr,start,line_num,line_flag
	public	arg_buf,wrt_handle,temp_path
	public	current,pointer,qflg,editbuf,amnt_req,fname_len,delflg,lastlin
	public	olddat,oldlen,newlen,srchflg,srchmod
	public	comline,lstfnd,numpos,lstnum,last_mem,srchcnt
	public	rd_handle,haveof,ending,three4th,one4th

	public	lc_adj				;an000;page length adj. factor
	public	lc_flag 			;an000;display cont. flag
	public	pg_count			;an000;lines left on screen
	public	Disp_Len			;an000;display length
	public	Disp_Width			;an000;display width
	public	continue			;an000;boolean T/F
	public	temp_path			;an000;pointer to filespec buf

Video_Buffer	label	word			;an000;buffer for video attr
	db	0				;an000;dms;
	db	0				;an000;dms;
	dw	14				;an000;dms;
	dw	0				;an000;dms;
	db	?				;an000;dms;
	db	0				;an000;dms;
	dw	?				;an000;dms;# of colors
	dw	?				;an000;dms;# of pixels in width
	dw	?				;an000;dms;# of pixels in len.
	dw	?				;an000;dms;# of chars in width
	dw	?				;an000;dms;# of chars in length


video_org	db	?			;an000;original video mode on
						;      entry to EDLIN.
lc_adj		db	?			;an000;page length adj. factor
lc_flag 	db	?			;an000;display cont. flag
pg_count	db	?			;an000;lines left on screen
Disp_Len	db	?			;an000;display length
Disp_Width	db	?			;an000;display width
continue	db	?			;an000;boolean T/F


;-----------------------------------------------------------------------;
; This is a table that is sequentially filled via GetNum.  Any additions to it
; must be placed in the correct position.  Currently Param4 is known to be a
; count and thus is treated specially.

	public	param1,param2,Param3,param4,ParamCt
PARAM1	DW	?
PARAM2	DW	?
PARAM3	DW	?
PARAM4	DW	?
ParamCt DW	?			; count of passed parameters
	ifdef	DBCS			; Used in TESTKANJ:
LBTbl	dd	?			;  long pointer to lead byte table
	endif				;  in the dos (from syscall 63H)

;-----------------------------------------------------------------------;

PUBLIC PTR_1, PTR_2, PTR_3, OLDLEN, NEWLEN, LSTFND, LSTNUM, NUMPOS, SRCHCNT
PUBLIC CURRENT, POINTER, ONE4TH, THREE4TH, LAST_MEM, ENDTXT, COPYSIZ
PUBLIC COMLINE, LASTLIN, COMBUF, EDITBUF, EOL, QFLG, ENDING, SRCHFLG
PUBLIC PATH_NAME, FNAME_LEN, RD_HANDLE, TEMP_PATH, WRT_HANDLE, EXT_PTR
PUBLIC MRG_PATH_NAME, MRG_HANDLE, amnt_req, olddat, srchmod, MOVFLG, org_ds
ifdef	DBCS
public	lbtbl
endif

;
; These comprise the known state of the internal buffer.  All editing
; functions must preserve these values.
;
CURRENT     DW	    ?			; the 1-based index of the current line
POINTER     DW	    ?			; pointer to the current line
ENDTXT	    DW	    ?			; pointer to end of buffer. (at ^Z)
LAST_MEM    DW	    ?			; offset of last byte of memory
;
; The label Start is the beginning of the in-core buffer.
;

;
; Internal temporary pointers
;
PTR_1		DW	    ?
PTR_2		DW	    ?
PTR_3		DW	    ?

QFLG		DB	    ?			; TRUE => query for replacement
OLDLEN	DW	    ?
NEWLEN	DW	    ?
LSTFND	DW	    ?
LSTNUM	DW	    ?
NUMPOS	DW	    ?
SRCHCNT     DW	    ?
ONE4TH	DW	    ?
THREE4TH    DW	    ?
COPYSIZ     DW	    ?			; total length to copy
COPYLEN     DW	    ?			; single copy length
COMLINE     DW	    ?
LASTLIN     DW	    ?
COMBUF	DB	    82H DUP (?)
EDITBUF     DB	    258 DUP (?)
EOL		DB	    ?
ENDING	DB	    ?
SRCHFLG     DB	    ?
PATH_NAME   DB	    128 DUP(0)
FNAME_LEN   DW	    ?
RD_HANDLE   DW	    ?
TEMP_PATH   DB	    128 DUP(?)
WRT_HANDLE  DW	    ?
EXT_PTR     DW	    ?
MRG_PATH_NAME DB    128 DUP(?)
MRG_HANDLE  DW	    ?
amnt_req    dw	    ?			; amount of bytes requested to read
olddat	db	    ?			; Used in replace and search, replace
					; by old data flag (1=yes)
srchmod     db	    ?			; Search mode:	1=from current+1 to
					; end of buffer, 0=from beg.  of
					; buffer to the end (old way).
MOVFLG	    DB	    ?
org_ds	    dw	    ?			;Orginal ds points to header block

arg_buf db	258 dup (?)

EA_Flag 	db	False		;an000; dms;set to false

EA_Buffer_Size	dw	?		;an000; dms;EA buffer's size

EA_Parm_List	label	word		;an000; dms;EA parms
		dd	dg:Start	;an000; dms;ptr to EA's
		dw	0001h		;an000; dms;additional parms
		db	06h		;an000; dms;
		dw	0002h		;an000; dms;iomode


line_num    dw	?

line_flag   db	?,0
	EVEN			;align on word boundaries
;
; Byte before start of data buffer must be < 40H  !!!!!!
;
	    dw	0		;we scan backwards looking for
				;a character which can't be part
				;of a two-byte seqence.  This
				;double byte sequence will cause the back
				;scan to stop here.
START	LABEL	WORD

DATA	ENDS


CODE SEGMENT PUBLIC

ASSUME	CS:DG,DS:NOTHING,ES:NOTHING,SS:CStack



	extrn	pre_load_message:near		;an000;message loader
	extrn	disp_fatal:near 		;an000;fatal message
	extrn	printf:near			;an000;new PRINTF routine

	extrn	findlin:near,shownum:near,loadbuf:near,crlf:near,lf:near
	extrn	abortcom:near,delbak:near,unquote:near,kill_bl:near
	extrn	make_caps:near,dispone:near,display:near,query:near
	extrn	quit:near,make_cntrl:near,scanln:near,scaneof:near
	extrn	fndfirst:near,fndnext:near,replace:near,memerr:near
	extrn	xerror:near
	extrn	zerror:near
	extrn	bad_read:near,append:near
	extrn	nocom:near,pager:near,list:near,search_from_curr:near
	extrn	replac_from_curr:near,ewrite:near,wrt:near,delete:near


	extrn	filespec:byte			;an000;parser's filespec
	extrn	parse_switch_b:byte		;an000;result of switch scan
	extrn	parse_switch_?:byte		;      result of switch scan

	public	std_printf,command,chkrange,comerr
	public	display_message
						;      exit from EDLIN

	IFDEF	DBCS
	extrn	testkanj:near
	ENDIF

EDLIN:
	JMP	SHORT SIMPED

std_printf	proc	near			;ac000;convert to proc

	push	dx
	call	printf
	pop	dx				;an000;balance the push
	ret

std_printf	endp				;ac000;end proc

Break	<Dispatch Table>

;-----------------------------------------------------------------------;
;   Careful changing the order of the next two tables.	They are linked and
;   changes should be be to both.

COMTAB	DB	13,";ACDEILMPQRSTW"
NUMCOM	EQU	$-COMTAB

TABLE	DW	BLANKLINE		; Blank line
	DW	NOCOM			; ;
	DW	APPEND			; A(ppend)
	DW	COPY			; C(opy)
	DW	DELETE			; D(elete)
	DW	ENDED			; E(xit)
	DW	INSERT			; I(nsert)
	DW	LIST			; L(ist)
	DW	MOVE			; M(ove)
	DW	PAGER			; P(age)
	DW	QUIT			; Q(uit)
	dw	replac_from_curr	; R(eplace)
	dw	search_from_curr	; S(earch)
	DW	MERGE			; T(merge)
	DW	EWRITE			; W(rite)

Break	<Initialization Code>

NONAME:
	mov	ax,NDNAME
	jmp	zerror

SIMPED:
	mov	org_ds,DS
	push	ax			;ac000;save for drive compare

	push	cs			;an000;exchange cs/es
	pop	es			;an000;

	push	cs			;an000;exchange cs/ds
	pop	ds			;an000;
	assume	ds:dg,es:dg		;an000;establish addressibility

	MOV	dg:ENDING,0
	mov	sp,stack
	call	EDLIN_DISP_GET			;an000;get current video
						;      mode & set it to
						;      text

;=========================================================================
; invoke PRE_LOAD_MESSAGE here.  If the messages were not loaded we will
; exit with an appropriate error message.
;
;	Date	   : 6/14/87
;=========================================================================

	call	PRE_LOAD_MESSAGE	;an000;invoke SYSLOADMSG
;	$if	c			;an000;if the load was unsuccessful
	JNC $$IF1
		mov ah,exit		;an000;exit EDLIN. PRE_LOAD_MESSAGE
					;      has said why we are exiting
		mov al,00h		;an000
		int 21h 		;an000;exit
;	$endif				;an000;
$$IF1:



VERS_OK:
;----- Check for valid drive specifier --------------------------------;

	pop	ax
	OR	AL,AL
	JZ	get_switch_char
	mov	ax,BADDRV
	jmp	zerror
get_switch_char:
	MOV	AX,(CHAR_OPER SHL 8)	;GET SWITCH CHARACTER
	INT	21H
	CMP	DL,"/"
	JNZ	CMD_LINE		;IF NOT / , THEN NOT PC
	MOV	OPTCHAR,"/"		;IN PC, OPTION CHAR = /

	IFDEF	DBCS
	push	ds			; SAVE! all regs destroyed on this
	push	es
	push	si			; call !!
	mov	ax,(ECS_call shl 8) or 00h  ; get kanji lead tbl
	int	21h
assume	ds:nothing
assume	es:nothing
	mov	word ptr [LBTbl],si
	mov	word ptr [LBTbl+2],ds
	pop	si
	pop	es
	pop	ds
assume	ds:dg
assume	es:dg
	ENDIF


CMD_LINE:
	push	cs
	pop	es
	ASSUME	ES:DG

;----- Process any options ------------------------------------------;

;=========================================================================
;  The system parser, called through PARSER_COMMAND, parses external
;  command lines.  In the case of EDLIN we are looking for two parameters
;  on the command line.
;
;  Parameter 1 - Filespec (REQUIRED)
;  Parameter 2 - \B switch (OPTIONAL)
;
;  PARSER_COMMAND  -  exit_normal : ffffh
;		      exit_error  : not = ffffh
;=========================================================================


	call	PARSER_COMMAND		;an000;invoke sysparse
					;      DMS:6/11/87

	; Check for /? switch.
	; If so, display the options
	; and exit.
	;
	; This is done first so that if the user typed
	; /? along with unknown commands, they can get
	; a coherent message without being over-errored.
	;
	; 4/17/90 c-PaulB

	cmp	[parse_switch_?], true	; is the /? switch on?
	jne	CheckOptionsDone	;  skip the rest of this if not

	mov	ax,dsp_options
	call	display_message

	mov	al, 0			; get an okay exit code
	mov	ah, exit		;  and
	int	21h			;   bail out.

CheckOptionsDone:

	cmp	ax,nrm_parse_exit	;an000;was it a good parse
;	$if	z			;an000;it was a good parse
	JNZ $$IF3
		call EDLIN_COMMAND	;an000;interface results
					;      into EDLIN
;	$else				;an000;
	JMP SHORT $$EN3
$$IF3:
		cmp ax,too_many 	;an000;too many operands
;		$if z			;an000;we have too many
		JNZ $$IF5
		    jmp short badopt	;an000;say why and exit
;		$endif
$$IF5:

		cmp ax,op_missing	;an000;required parm missing
;		$if z			;an000;missing parm
		JNZ $$IF7
ifdef DBCS
		    jmp noname		;an000;say why and exit
else
		    jmp short noname	;an000;say why and exit
endif
;		$endif			;an000;
$$IF7:

		cmp ax,sw_missing	;an000;is it an invalid switch
;		$if z			;an000;invalid switch
		JNZ $$IF9
		    jmp short badopt	;an000;say why and exit
;		$endif			;an000;
$$IF9:

;	$endif				;an000;
$$EN3:

;=========================================================================
;======================= begin .BAK check ================================
; Check for .BAK extension on the filename

	push	ds			;an000;save reg.
	push	cs			;an000;set up addressibility
	pop	ds			;an000;
	assume	ds:dg			;an000;

	push	ax			;an000;save reg.
	mov	ax,offset dg:path_name	;an000;point to path_name
	add	ax,[fname_len]		;an000;calculate end of path_name
	mov	si,ax			;an000;point to end of path_name
	pop	ax			;an000;restore reg.

	MOV	CX,4			;compare 4 bytes
	SUB	SI,4			;Point 4th to last char
	MOV	DI,OFFSET DG:BAK	;Point to string ".BAK"
	REPE	CMPSB			;Compare the two strings
	pop	ds
	ASSUME	DS:NOTHING
	JNZ	NOTBAK
	JMP	HAVBAK

;======================= end .BAK check ==================================

;======================= begin NOTBAK ====================================
; we have a file without a .BAK extension, try to open it

NOTBAK:
	push	ds
	push	cs
	pop	ds
	ASSUME	DS:DG

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	push	es			;an000;save reg.
	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,RW_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;nul parm list

	call	EXT_OPEN1		;an000;open for R/W;DMS:6/10/87
	pop	es			;an000;restore reg.

;=========================================================================
	pop	ds
	ASSUME	DS:NOTHING
	JC	CHK_OPEN_ERR		;an open error occurred
	MOV	RD_HANDLE,AX		;Save the handle

	Jmp	HavFil			;work with the opened file

;======================= end NOTBAK ======================================

Badopt:
	MOV	DX,OFFSET DG:OPT_ERR_ptr;Bad option specified
	JMP	XERROR

;=========================================================================
;
; The open of the file failed.	We need to figure out why and report the
; correct message. The circumstances we can handle are:
;
;   open returns pathnotfound => bad drive or file name
;   open returns toomanyopenfiles => too many open files
;   open returns access denied =>
;	chmod indicates read-only => cannot edit read only file
;	else => file creation error
;   open returns filenotfound =>
;	creat ok => close, delete, new file
;	creat fails => file creation error
;   else => file cre
;

CHK_OPEN_ERR:
	cmp	ax,error_path_not_found
	jz	BadDriveError
	cmp	ax,error_too_many_open_files
	jz	TooManyError
	cmp	ax,error_access_denied
	jnz	CheckFNF
	push	ds
	push	cs
	pop	ds
	assume	ds:dg
	mov	ax,(chmod shl 8)
	MOV	DX,OFFSET DG:PATH_NAME
	int	21h
	jc	FileCreationError
	test	cx,attr_read_only
	jz	FileCreationError
	jmp	short ReadOnlyError

CheckFNF:
	cmp	ax,error_file_not_found
	jnz	FileCreationError
;
; Try to create the file to see if it is OK.
;
	push	ds
	push	cs
	pop	ds
	assume ds:dg
;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,CREAT_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;null parm list
	call	EXT_OPEN1		;an000;create file;DMS:6/10/87

;=========================================================================

	pop	ds
	assume	ds:nothing
	jc	CreateCheck
	mov	bx,ax
	mov	ah,close
	int	21h
	push	ds
	push	cs
	pop	ds
	assume	ds:dg
	mov	ah,unlink
	MOV	DX,OFFSET DG:PATH_NAME
	int	21h
	pop	ds
	assume	ds:nothing
	jc	FileCreationError	; This should NEVER be taken!!!
	MOV	HAVEOF,0FFH		; Flag from a system 1.xx call
	MOV	fNew,-1
	JMP	short HAVFIL

CreateCheck:
	cmp	ax,error_access_denied
	jnz	BadDriveError
DiskFull:
	mov	ax,NODIR
	jmp	zerror

FileCreationError:
	mov	ax,bcreat
	jmp	zerror

ReadOnlyError:
	mov	ax,RO_ERR
	jmp	zerror

BadDriveError:
	mov	ax,BADDRV
	jmp	zerror

TooManyError:
	mov	ax,msg_too_many
	jmp	zerror


CREAT_ERR:
	CMP	DELFLG,0
	JNZ	DiskFull
	push	cs
	pop	ds
	CALL	DELBAK
	JMP	short MAKFIL

HAVBAK:
	mov	ax,NOBAK
	jmp	zerror

HAVFIL:
	push	cs
	pop	ds
	ASSUME	DS:DG
	CMP	fNew,0
	JZ	MakeBak
	mov	ax,newfil
	call	display_message
MakeBak:
	MOV	SI,OFFSET DG:PATH_NAME
	MOV	CX,[FNAME_LEN]
	PUSH	CX
	MOV	DI,OFFSET DG:TEMP_PATH
	REP	MOVSB
	DEC	DI
	MOV	DX,DI
	POP	CX
	MOV	AL,"."
	STD
	REPNE	SCASB
	JZ	FOUND_EXT
	MOV	DI,DX			;Point to last char in filename
FOUND_EXT:
	CLD
	INC	DI
	MOV	[EXT_PTR],DI
	MOV	SI,OFFSET DG:$$$FILE
	MOV	CX,5
	REP	MOVSB

;Create .$$$ file to make sure directory has room
MAKFIL:

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	mov	bx,RW			;an000;open for read/write
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,Creat_Open_Flag	;an000;action to take on open
	cmp	EA_Flag,True		;an000;EA_Buffer used?
;	$if	e			;an000;yes
	JNE $$IF12
		mov	di,offset dg:EA_Parm_List ;an000; point to buffer
;	$else				;an000;
	JMP SHORT $$EN12
$$IF12:
		mov	di,0ffffh	;an000;nul parm list
;	$endif				;an000;
$$EN12:
	call	EXT_OPEN2		;an000;create file;DMS:6/10/87

;=========================================================================

	JC	CREAT_ERR
	MOV	[WRT_HANDLE],AX
;
; We determine the size of the available memory.  Use the word in the PDB at
; [2] to determine the number of paragraphs.  Then truncate this to 64K at
; most.
;
	push	ds				;save ds for size calc
	mov	ds,[org_ds]
	MOV	CX,DS:[2]
	MOV	DI,CS
	SUB	CX,DI
	CMP	CX,1000h
	JBE	GotSize
	MOV	CX,0FFFh
GotSize:
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	SHL	CX,1
	pop	ds				;restore ds after size calc
	DEC	CX
	MOV	[LAST_MEM],CX
	MOV	DI,OFFSET DG:START
	TEST	fNew,-1
	JNZ	SAVEND
	SUB	CX,OFFSET DG:START	;Available memory
	SHR	CX,1			;1/2 of available memory
	MOV	AX,CX
	SHR	CX,1			;1/4 of available memory
	MOV	[ONE4TH],CX		;Save amount of 1/4 full
	ADD	CX,AX			;3/4 of available memory
	MOV	DX,CX
	ADD	DX,OFFSET DG:START
	MOV	[THREE4TH],DX		;Save pointer to 3/4 full
	MOV	DX,OFFSET DG:START
SAVEND:
	CLD
	MOV	BYTE PTR [DI],1AH
	MOV	[ENDTXT],DI
	MOV	BYTE PTR [COMBUF],128
	MOV	BYTE PTR [EDITBUF],255
	MOV	BYTE PTR [EOL],10
	MOV	[POINTER],OFFSET DG:START
	MOV	[CURRENT],1
	MOV	ParamCt,1
	MOV	[PARAM1],0		;M004 Leave room in memory, was -1
	TEST	fNew,-1
	JNZ	COMMAND
;
; The above setting of PARAM1 to -1 causes this call to APPEND to try to read
;  in as many lines that will fit, BUT.... What we are doing is simulating
;  the user issuing an APPEND command, and if the user asks for more lines
;  than we get then an "Insufficient memory" error occurs. In this case we
;  DO NOT want this error, we just want as many lines as possible read in.
;  The twiddle of ENDING suppresses the memory error
;
	MOV	BYTE PTR [ENDING],1	;Suppress memory errors
	CALL	APPEND
	MOV	ENDING,0		; restore correct initial value

Break	<Main command loop>

;
; Main read/parse/execute loop.  We reset the stack all the time as there
; are routines that JMP back here.  Don't blame me; Tim Paterson write this.
;
COMMAND:
	push	cs				;an000;set up addressibility
	pop	ds				;an000;
	push	cs				;an000;
	pop	es				;an000;
	assume	ds:dg,es:dg			;an000;

	MOV	SP, STACK
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTCOM
	INT	21H
	mov	ax,prompt
	call	display_message

	MOV	DX,OFFSET DG:COMBUF
	MOV	AH,STD_CON_STRING_INPUT
	INT	21H
	MOV	[COMLINE],OFFSET DG:COMBUF + 2

	mov	ax,msg_lf
	call	display_message

PARSE:
	MOV	[PARAM2],0
	MOV	[PARAM3],0
	MOV	[PARAM4],0
	mov	[fourth],0		;reset the fourth parameter flag
	MOV	QFLG,0
	MOV	SI,[COMLINE]
	MOV	BP,OFFSET DG:PARAM1
	XOR	DI,DI
CHKLP:
	CALL	GETNUM
;
; AL has first char after arg
;
	MOV	ds:[BP+DI],DX
	ADD	DI,2

	MOV	ParamCt,DI		; set up count of parameters
	SHR	ParamCt,1		; convert to index (1-based)

	CALL	SKIP1			; skip to next parameter
	CMP	AL,","			; is there a comma?
	jnz	NOT_COMMA		; if not, then done with arguments

	cmp	di,8			; **** maximum size of PARAM array!
	jb	CHKLP			;  continue scanning if <4 PARAMS
	jmp	short COMERR

NOT_COMMA:
	DEC	SI			; point at char next
	CALL	Kill_BL 		; skip all blanks
	CMP	AL,"?"			; is there a ?
	JNZ	DISPATCH		; no, got command letter
	MOV	QFLG,-1 		; signal query
	CALL	Kill_BL
DISPATCH:
	CMP	AL,5FH
	JBE	UPCASE
	cmp	al,"z"
	ja	upcase
	AND	AL,5FH
UPCASE:
	MOV	DI,OFFSET DG:COMTAB
	mov	cx,NUMCOM
	REPNE	SCASB
	JNZ	COMERR

	SUB	DI,1+OFFSET DG:COMTAB	; convert to index
	MOV	BX,DI
	MOV	AX,[PARAM2]
	OR	AX,AX
	JZ	PARMOK
	CMP	AX,[PARAM1]
	JB	COMERR			; Param. 2 must be >= param 1
PARMOK:
	MOV	[COMLINE],SI
	SHL	BX,1
	CALL	[BX+TABLE]
COMOVER:
	MOV	SI,[COMLINE]
	CALL	Kill_BL
	CMP	AL,0DH
	JZ	COMMANDJ
	CMP	AL,1AH
	JZ	DELIM
	CMP	AL,";"
	JNZ	NODELIM
DELIM:
	INC	SI
NODELIM:
	DEC	SI
	MOV	[COMLINE],SI
	JMP	PARSE

COMMANDJ:
	JMP	COMMAND

SKIP1:
	DEC	SI
	CALL	Kill_BL
ret1:	return

Break	<Range Checking and argument parsing>

;
; People call here.  we need to reset the stack.
;   Inputs: BX has param1
;   Outputs: Returns if BX <= Param2
;

CHKRANGE:
	CMP	[PARAM2],0
	retz
	CMP	BX,[PARAM2]
	JBE	RET1
	POP	DX			; clean up return address
COMERR:
	mov	ax,BADCOM
zcomerr1:
	call	display_message
	jmp	command

COMERR1:
	call	std_printf
	JMP	COMMAND

;
; GetNum parses off 1 argument from the command line.  Argument forms are:
;   nnn     a number < 65536
;   +nnn    current line + number
;   -nnn    current line - number
;   .	    current line
;   #	    lastline + 1
;
;

GETNUM:
	CALL	Kill_BL
	cmp	di,6			;Is this the fourth parameter?
	jne	sk1
	mov	[fourth],1		;yes, set the flag
sk1:
	CMP	AL,"."
	JZ	CURLIN
	CMP	AL,"#"
	JZ	MAXLIN
	CMP	AL,"+"
	JZ	FORLIN
	CMP	AL,"-"
	JZ	BACKLIN
	MOV	DX,0
	MOV	CL,0			;Flag no parameter seen yet
NUMLP:
	CMP	AL,"0"
	JB	NUMCHK
	CMP	AL,"9"
	JA	NUMCHK
	CMP	DX,6553 		;Max line/10
	JAE	COMERR			;Ten times this is too big
	MOV	CL,1			;Parameter digit has been found
	SUB	AL,"0"
	MOV	BX,DX
	SHL	DX,1
	SHL	DX,1
	ADD	DX,BX
	SHL	DX,1
	CBW
	ADD	DX,AX
	LODSB
	JMP	SHORT NUMLP
NUMCHK:
	CMP	CL,0
	retz
	OR	DX,DX
	JZ	COMERR			;Don't allow zero as a parameter
	return

CURLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	MOV	DX,[CURRENT]
	LODSB
	return
MAXLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	MOV	DX,1
	MOV	AL,0Ah
	PUSH	DI
	MOV	DI,OFFSET DG:START
	MOV	CX,EndTxt
	SUB	CX,DI
MLoop:
	JCXZ	MDone
	REPNZ	SCASB
	JNZ	MDone
	INC	DX
	JMP	MLoop
MDone:
	POP	DI
	LODSB
	return
FORLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	CALL	GETNUM
	ADD	DX,[CURRENT]
	return
BACKLIN:
	cmp	[fourth],1		;the fourth parameter?
	je	comerra 		;yes, an error
	CALL	GETNUM
	MOV	BX,[CURRENT]
	SUB	BX,DX
	JA	OkLin			; if negative or zero
	MOV	BX,1			; use first line
OkLin:
	MOV	DX,BX
	return

comerra:
	jmp	comerr


ERRORJ:
	JMP	COMERR
ERROR1J:
	JMP	zcomerr1

BLANKLINE:
	cmp	QFLG,0
	jnz	SHOWHELP		; if ? at front of blank line, do HELP
	jmp	NOCOM			; ignore blank line otherwise

SHOWHELP:
	dec	[COMLINE]		; point back to <cr>
	mov	cx,num_help_msgs-1
	mov	ax,dsp_help
SHOWHELP1:
	call	display_message
	inc	ax
	loop	SHOWHELP1

;	fall into display_message for last message and return

;=========================================================================
; display_message	: Displays a simple common message through the
;			;  message retriever, using a common parameter
;			;  block.

;	Inputs	: ax = message number to display
;
;=========================================================================

display_message	proc	near

	mov	dg:[simple_msg],ax
	mov	dx,offset dg:simple_msg
	jmp	printf			; display it

display_message	endp



Break	<Move and Copy commands>

PUBLIC MOVE
MOVE:
	CMP	ParamCt,3
	JNZ	ERRORJ
	MOV	BYTE PTR [MOVFLG],1
	JMP	SHORT BLKMOVE

PUBLIC COPY
COPY:
	CMP	ParamCt,3
	JB	ERRORJ
	MOV	BYTE PTR [MOVFLG],0
;
; We are to move/copy a number of lines from one range to another.
;
; Memory looks like this:
;
;   START:	line 1
;		...
;   pointer->	line n		Current has n in it
;		...
;		line m
;   endtxt->	^Z
;
; The algoritm is:
;
;   Bounds check on args.
;   set ptr1 and ptr2 to range before move
;   set copysiz to number to move
;   open up copysize * count for destination
;   if destination is before ptr1 then
;	add copysize * count to both ptrs
;   while count > 0 do
;	move from ptr1 to destination for copysize bytes
;	count --
;   if moving then
;	move from ptr2 through end to ptr1
;   set endtxt to last byte moved.
;   set current, pointer to original destination
;

BLKMOVE:
;
; Make sure that all correct arguments are specified.
;
	MOV	BX,[PARAM3]		; get destination of move/copy
	OR	BX,BX			; must be specified (non-0)
	mov	ax,DEST
	JZ	ERROR1J 		; is 0 => error
;
; get arg 1 (defaulting if necessary) and range check it.
;
	MOV	BX,[PARAM1]		; get first argument
	OR	BX,BX			; do we default it?
	JNZ	NXTARG			; no, assume it is OK.
	MOV	BX,[CURRENT]		; Defaults to the current line
	CALL	CHKRANGE		; Make sure it is good.
	MOV	[PARAM1],BX		; set it
NXTARG:
	CALL	FINDLIN 		; find first argument line
	JNZ	ErrorJ			; line not found
	MOV	[PTR_1],DI
;
; get arg 2 (defaulting if necessary) and range check it.
;
	MOV	BX,[PARAM2]		; Get the second parameter
	OR	BX,BX			; do we default it too?
	JNZ	HAVARGS 		; Nope.
	MOV	BX,[CURRENT]		; Defaults to the current line
	MOV	[PARAM2],BX		; Stash it away
HAVARGS:
	CALL	FindLin
	JNZ	ErrorJ			; line not found
	MOV	BX,Param2
	INC	BX			;Get pointer to line Param2+1
	CALL	FINDLIN
	MOV	[PTR_2],DI		;Save it
;
; We now have true line number arguments and pointers to the relevant places.
; ptr_1 points to beginning of region and ptr_2 points to first byte beyond
; that region.
;
; Check args for correct ordering of first two arguments
;
	mov	dx,[param1]
	cmp	dx,[param2]
	jbe	havargs1		; first must be <= second
	jmp	comerr
havargs1:
;
; make sure that the third argument is not contained in the first range
;
	MOV	DX,[PARAM3]
	CMP	DX,[PARAM1]		; third must be <= first or
	JBE	NOERROR
	CMP	DX,[PARAM2]
	JA	NoError 		; third must be > last
	JMP	ComErr
NOERROR:
;
; Determine number to move
;
	MOV	CX,Ptr_2
	SUB	CX,Ptr_1		; Calculate number of bytes to copy
	MOV	CopySiz,CX
	MOV	CopyLen,CX		; Save for individual move.
	MOV	AX,[PARAM4]		; Was count defaulted?
	OR	AX,AX
	JZ	SizeOk			; yes, CX has correct value
	MUL	[COPYSIZ]		; convert to true size
	MOV	CX,AX			; move to count register
	OR	DX,DX			; overflow?
	JZ	SizeOK			; no
	JMP	MEMERR			; yes, bomb.
SizeOK:
	MOV	[COPYSIZ],CX
;
; Check to see that we have room to grow by copysiz
;
	MOV	AX,[ENDTXT]		; get pointer to last byte
	MOV	DI,[LAST_MEM]		; get offset of last location in memory
	SUB	DI,AX			; remainder of space
	CMP	DI,CX			; is there at least copysiz room?
	JAE	HAV_ROOM		; yes
	JMP	MEMERR
HAV_ROOM:
;
; Find destination of move/copy
;
	MOV	BX,[PARAM3]
	CALL	FINDLIN
	MOV	[PTR_3],DI
;
; open up copysiz bytes of space at destination
;
;	move (p3, p3+copysiz, endtxt-p3);
;
	MOV	SI,EndTxt		; get source pointer to end
	MOV	CX,SI
	SUB	CX,DI			; number of bytes from here to end
	INC	CX			; remember ^Z at end
	MOV	DI,SI			; destination starts at end
	ADD	DI,[COPYSIZ]		; plus size we are opening
	MOV	[ENDTXT],DI		; new end point
	STD				; go backwards
	REP	MOVSB			; and store everything
	CLD				; go forward
;
; relocate ptr_1 and ptr_2 if we moved them
;
	MOV	BX,Ptr_3
	CMP	BX,Ptr_1		; was dest before source?
	JA	NoReloc 		; no, above. no relocation
	MOV	BX,CopySiz
	ADD	Ptr_1,BX
	ADD	Ptr_2,BX		; relocate pointers
NoReloc:
;
; Now we copy for count times copylen bytes from ptr_1 to ptr_3
;
;	move (ptr_1, ptr_3, copylen);
;
	MOV	BX,Param4		; count (0 and 1 are both 1)
	MOV	DI,Ptr_3		; destination
CopyText:
	MOV	CX,CopyLen		; number to move
	MOV	SI,Ptr_1		; start point
	REP	MOVSB			; move the bytes
	SUB	BX,1			; exhaust count?
	JG	CopyText		; no, go for more
;
; If we are moving
;
	CMP	BYTE PTR MovFlg,0
	JZ	CopyDone
;
; Delete the source text between ptr_1 and ptr_2
;
;	move (ptr_2, ptr_1, endtxt-ptr_2);
;
	MOV	DI,Ptr_1		; destination
	MOV	SI,Ptr_2		; source
	MOV	CX,EndTxt		; pointer to end
	SUB	CX,SI			; number of bytes to move
	CLD				; forwards
	REP	MOVSB
	MOV	BYTE PTR ES:[DI],1Ah	; remember ^Z terminate
	MOV	EndTxt,DI		; new end of file
;
; May need to relocate current line (parameter 3).
;
	MOV	BX,Param3		; get new current line
	CMP	BX,Param1		; do we need to relocate
	JBE	CopyDone		; no, current line is before removed M002
	ADD	BX,Param1		; add in first
	SUB	BX,Param2		; current += first-last - 1;
	DEC	BX
	MOV	Param3,BX
CopyDone:
;
; we are done.	Make current line the destination
;
	MOV	BX,Param3		; set parameter 3 to be current
	CALL	FINDLIN
	MOV	[POINTER],DI
	MOV	[CURRENT],BX
	return

Break	<MoveFile - open up a hole in the internal file>

;
;   MoveFile moves the text in the buffer to create a hole
;
;   Inputs:	DX is spot in buffer for destination
;		DI is spot in buffer for source
MOVEFILE:
	MOV	CX,[ENDTXT]		;Get End-of-text marker
	MOV	SI,CX
	SUB	CX,DI			;Calculate number of bytes to copy
	INC	CX			; remember ^Z
	MOV	DI,DX
	STD
	REP	MOVSB			;Copy CX bytes
	XCHG	SI,DI
	CLD
	INC	DI
	MOV	BP,SI
SETPTS:
	MOV	[POINTER],DI		;Current line is first free loc
	MOV	[CURRENT],BX		;   in the file
	MOV	[ENDTXT],BP		;End-of-text is last free loc before
	return

NAMERR:
	cmp	ax,error_file_not_found
	jne	otherMergeErr
	MOV	DX,OFFSET DG:FILENM_ptr
	JMP	COMERR1

otherMergeErr:
	mov	ax,BADDRV
	jmp	zcomerr1

PUBLIC MERGE
MERGE:
	CMP	ParamCt,1
	JZ	MergeOK
	JMP	Comerr
MergeOK:
	CALL	KILL_BL
	DEC	SI
	MOV	DI,OFFSET DG:MRG_PATH_NAME
	XOR	CX,CX
	CLD
MRG1:
	LODSB
	CMP	AL," "
	JE	MRG2
	CMP	AL,9
	JE	MRG2
	CMP	AL,CR
	JE	MRG2
	CMP	AL,";"
	JE	MRG2
	STOSB
	JMP	SHORT MRG1
MRG2:
	MOV	BYTE PTR[DI],0
	DEC	SI
	MOV	[COMLINE],SI

;=========================================================================
; implement EXTENDED OPEN
;=========================================================================

	push	es			;an000;save reg.
	mov	bx,ext_read		;an000;open for read
	mov	cx,ATTR 		;an000;file attributes
	mov	dx,OPEN_FLAG		;an000;action to take on open
	mov	di,0ffffh		;an000;null parm list
	call	EXT_OPEN3		;an000;create file;DMS:6/10/87
	pop	es			;an000;restore reg.

;=========================================================================

	JC	NAMERR

	MOV	[MRG_HANDLE],AX
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTMERGE
	INT	21H
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	MRG
	MOV	BX,[CURRENT]
	CALL	CHKRANGE
MRG:
	CALL	FINDLIN
	MOV	BX,DX
	MOV	DX,[LAST_MEM]
	CALL	MOVEFILE
	MOV	DX,[POINTER]
	MOV	CX,[ENDTXT]
	SUB	CX,[POINTER]
	PUSH	CX
	MOV	BX,[MRG_HANDLE]
	MOV	AH,READ
	INT	21H
	POP	DX
	MOV	CX,AX
	CMP	DX,CX
	JA	FILEMRG 			; M005
	mov	ax,mrgerr
	call	display_message
	MOV	CX,[POINTER]
	JMP	SHORT RESTORE_Z
FILEMRG:
	ADD	CX,[POINTER]
	MOV	SI,CX
	dec	si
	LODSB
	CMP	AL,1AH
	JNZ	RESTORE_Z
	dec	cx
RESTORE_Z:
	MOV	DI,CX
	MOV	SI,[ENDTXT]
	INC	SI
	MOV	CX,[LAST_MEM]
	SUB	CX,SI
	inc	cx			; remember ^Z
	REP	MOVSB
	dec	di			; unremember ^Z
	MOV	[ENDTXT],DI
	MOV	BX,[MRG_HANDLE]
	MOV	AH,CLOSE
	INT	21H
	return

PUBLIC INSERT
INSERT:
	CMP	ParamCt,1
	JBE	OKIns
	JMP	ComErr
OKIns:
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H	;Set vector 23H
	MOV	DX,OFFSET DG:ABORTINS
	INT	21H
	MOV	BX,[PARAM1]
	OR	BX,BX
	JNZ	INS
	MOV	BX,[CURRENT]
	CALL	CHKRANGE
INS:
	CALL	FINDLIN
	MOV	BX,DX
	MOV	DX,[LAST_MEM]
	CALL	MOVEFILE
INLP:
	CALL	SETPTS			;Update the pointers into file
	CALL	SHOWNUM
	MOV	DX,OFFSET DG:EDITBUF
	MOV	AH,STD_CON_STRING_INPUT
	INT	21H
	CALL	LF
	MOV	SI,2 + OFFSET DG:EDITBUF
	CMP	BYTE PTR [SI],1AH
	JZ	ENDINS
;-----------------------------------------------------------------------
	call	unquote 		;scan for quote chars if any
;-----------------------------------------------------------------------
	MOV	CL,[SI-1]
	MOV	CH,0
	MOV	DX,DI
	INC	CX
	ADD	DX,CX
	JC	MEMERRJ1
	JZ	MEMERRJ1
	CMP	DX,BP
	JB	MEMOK
MEMERRJ1:
	CALL	END_INS
	JMP	MEMERR
MEMOK:
	REP	MOVSB
	MOV	AL,10
	STOSB
	INC	BX
	JMP	SHORT INLP

ABORTMERGE:
	MOV	DX,OFFSET DG:START
	MOV	AH,SET_DMA
	INT	21H

ABORTINS:
	MOV	AX,CS			;Restore segment registers
	MOV	DS,AX
	MOV	ES,AX
	MOV	AX,CSTACK
	MOV	SS,AX
	MOV	SP,STACK
	STI
	CALL	CRLF
	CALL	ENDINS
	JMP	COMOVER

ENDINS:
	CALL	END_INS
	return

END_INS:
	MOV	BP,[ENDTXT]
	MOV	DI,[POINTER]
	MOV	SI,BP
	INC	SI
	MOV	CX,[LAST_MEM]
	SUB	CX,BP
	REP	MOVSB
	DEC	DI
	MOV	[ENDTXT],DI
	MOV	AX,(SET_INTERRUPT_VECTOR SHL 8) OR 23H
	MOV	DX,OFFSET DG:ABORTCOM
	INT	21H
	return


FILLBUF:
	MOV	[PARAM1],-1		;Read in max. no of lines
	MOV	ParamCt,1
	CALL	APPEND
	MOV	Param1,0
PUBLIC ENDED
ENDED:

;Write text out to .$$$ file

	CMP	ParamCt,1
	JZ	ENDED1
CERR:	JMP	ComErr
Ended1:
	CMP	Param1,0
	JNZ	Cerr
	MOV	BYTE PTR [ENDING],1	;Suppress memory errors
	MOV	BX,-1			;Write max. no of lines
	CALL	WRT
	TEST	BYTE PTR [HAVEOF],-1
	JZ	FILLBUF
	MOV	DX,[ENDTXT]
	MOV	CX,1
	MOV	BX,[WRT_HANDLE]
	MOV	AH,WRITE
	INT	21H			;Write end-of-file byte

;Close input file			; MZ 11/30
					; MZ 11/30
	MOV	BX,[RD_HANDLE]		; MZ 11/30
	MOV	AH,CLOSE		; MZ 11/30
	INT	21H			; MZ 11/30

;Close .$$$ file

	MOV	BX,[WRT_HANDLE]
	MOV	AH,CLOSE
	INT	21H

;Rename original file .BAK

	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:BAK
	MOVSW
	MOVSW
	MOVSB
	MOV	DX,OFFSET DG:PATH_NAME
	MOV	DI,OFFSET DG:TEMP_PATH
	MOV	AH,RENAME
	INT	21H
	MOV	DI,[EXT_PTR]
	MOV	SI,OFFSET DG:$$$FILE
	MOVSW
	MOVSW
	MOVSB

;Rename .$$$ file to original name

	MOV	DX,OFFSET DG:TEMP_PATH
	MOV	DI,OFFSET DG:PATH_NAME
	MOV	AH,RENAME
	INT	21H
						;      mode
	mov	ah,exit
	xor	al,al
	int	21h

;=========================================================================
; EDLIN_DISP_GET: This routine will give us the attributes of the
;		  current display, which are to be used to restore the screen
;		  back to its original state on exit from EDLIN.  We also
;		  set the screen to a text mode here with an 80 X 25 color
;		  format.
;
;	Inputs	: VIDEO_GET - 0fH (get current video mode)
;		  VIDEO_SET - 00h (set video mode)
;		  VIDEO_TEXT- 03h (80 X 25 color mode)
;
;	Outputs : VIDEO_ORG - Original video attributes on entry to EDLIN
;
;=========================================================================

EDLIN_DISP_GET	proc	near			;an000;video attributes

	push	ax				;an000;save affected regs.
	push	bx				;an000;
	push	cx				;an000;
	push	dx				;an000;
	push	si				;an000;
	push	ds				;an000;

	push	cs				;an000;exchange cs/ds
	pop	ds				;an000;

	mov	ax,440Ch			;an000;generic ioctl
	mov	bx,Std_Out			;an000;Console
	mov	cx,(Display_Attr shl 8) or Get_Display ;an000;get display
	mov	dx,offset dg:Video_Buffer	;an000;buffer for video attr.
	int	21h				;an000;
;	$if	nc				;an000;function returned a
	JC $$IF15
						;      buffer
		mov	si,dx			;an000;get pointer
		mov	ax,word ptr dg:[si].Display_Length_Char  ;an000;get video len.
		dec	ax			;an000;allow room for message
		mov	dg:Disp_Len,al		;an000;put it into var.
		mov	ax,word ptr dg:[si].Display_Width_Char ;an000;get video width
		mov	dg:Disp_Width,al	;an000;put it into var.
;	$else					;an000;function failed use
	JMP SHORT $$EN15
$$IF15:
						;      default values
		mov	al,Def_Disp_Len 	;an000;get default length
		dec	al			;an000;leave room for messages
		mov	dg:Disp_Len,al		;an000;use default length
		mov	dg:Disp_Width,Def_Disp_Width;an000;use default width
;	$endif					;an000;
$$EN15:

	pop	ds				;an000;restore affected regs.
	pop	si				;an000;
	pop	dx				;an000;
	pop	cx				;an000;
	pop	bx				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

EDLIN_DISP_GET	endp				;an000;end proc.


;=========================================================================
; EXT_OPEN1 : This routine opens a file for read/write access.	If the file
;	      if not present for opening the open will fail and return with a
;	      carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN1	proc	near			;an000;open for R/W

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:path_name		;an000;point to PATH_NAME

	int	21h				;an000;invoke function
	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN1	endp				;an000;end proc.

;=========================================================================
; EXT_OPEN2  : This routine will attempt to create a file for read/write
;	       access.	If the files exists the create will fail and return
;	       with the carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN2	proc	near			;an000;create a file

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:temp_path		;an000;point to TEMP_PATH

	int	21h				;an000;invoke function

	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN2	endp				;an000;end proc.

;=========================================================================
; EXT_OPEN3  : This routine will attempt to create a file for read
;	       access.	If the files exists the create will fail and return
;	       with the carry set.
;
;	Inputs : BX - Open mode
;		 CX - File attributes
;		 DX - Open action
;
;	Outputs: CY - If error
;
;	Date	   : 6/10/87
;=========================================================================

EXT_OPEN3	proc	near			;an000;create a file

	assume	ds:dg
	push	ds				;an000;save regs
	push	si				;an000;

	mov	ah,ExtOpen			;an000;extended open
	mov	al,0				;an000;reserved by system
	mov	si,offset dg:mrg_path_name	;an000;point to mrg_path_name

	int	21h				;an000;invoke function

	pop	si				;an000;restore regs
	pop	ds				;an000;

	ret					;an000;return to caller

EXT_OPEN3	endp				;an000;end proc.


;=========================================================================
; EDLIN_COMMAND : This routine provides an interface between the new
;		  parser and the existing logic of EDLIN.  We will be
;		  interfacing the parser with three existing variables.
;
;	Inputs : FILESPEC - Filespec entered by the user and passed by
;			    the parser.
;
;		 PARSE_SWITCH_B - Contains the result of the parse for the
;				/B switch.  This is passed by the parser.
;
;	Outputs: PATH_NAME - Filespec
;		 LOADMOD   - Flag for /B switch
;		 FNAME_LEN - Length of filespec
;
;	Date	   : 6/11/87
;=========================================================================

EDLIN_COMMAND		proc	near		;an000;interface parser

	push	ax				;an000;save regs.
	push	cx				;an000;
	push	di				;an000
	push	si				;an000;

	mov	si,offset dg:filespec		;an000;get its offset
	mov	di,offset dg:path_name		;an000;get its offset

	mov	cx,00h				;an000;cx will count filespec
						;      length
	cmp	parse_switch_b,true		;an000;do we have /B switch
;	$if	z				;an000;we have the switch
	JNZ $$IF18
		mov	[LOADMOD],01h		;an000;signal switch found
;	$endif					;an000
$$IF18:

;	$do					;an000;while we have filespec
$$DO20:
		lodsb				;an000;move byte to al
		cmp	al,nul			;an000;see if we are at
						;      the end of the
						;      filespec
;		$leave	e			;an000;exit while loop
		JE $$EN20
		stosb				;an000;move byte to path_name
		inc	cx			;an000;increment the length
						;      of the filespec
;	$enddo					;an000;end do while
	JMP SHORT $$DO20
$$EN20:

	mov	[FNAME_LEN],cx			;an000;save filespec's length

	pop	si				;an000; restore regs
	pop	di				;an000;
	pop	cx				;an000;
	pop	ax				;an000;

	ret					;an000;return to caller

EDLIN_COMMAND		endp			;an000;end proc


;=========================================================================
; Calc_Memory_Avail	: This routine will calculate the memory
;			  available for use by EDLIN.
;
;	Inputs	: ORG_DS - DS of PSP
;
;	Outputs : DX	 - paras available
;=========================================================================

Calc_Memory_Avail	proc	near		;an000; dms;

	push	ds				;save ds for size calc
	push	cx				;an000; dms;
	push	di				;an000; dms;

	mov	ds,cs:[org_ds]
	MOV	CX,DS:[2]
	MOV	DI,CS
	SUB	CX,DI
	mov	dx,cx				;an000; dms;put paras in DX

	pop	di				;an000; dms;
	pop	cx				;an000; dms;
	pop	ds				;an000; dms;

	ret					;an000; dms;

Calc_Memory_Avail	endp			;an000; dms;

;=========================================================================
; EA_Fail_Exit		: This routine tells the user that there was
;			  Insufficient memory and exits EDLIN.
;
;	Inputs	: MemFul_Ptr - "Insufficient memory"
;
;	Outputs : message
;=========================================================================

EA_Fail_Exit		proc	near		;an000; dms;

	mov	dx,offset dg:MemFul_Ptr 	;an000; dms;"Insufficient

	push	cs				;an000; dms;xchange ds/cs
	pop	ds				;an000; dms;
						;	     memory"
	call	Std_Printf			;an000; dms;print message
	mov	ah,exit 			;an000; dms;exit
	xor	al,al				;an000; dms;clear al
	int	21h				;an000; dms;
	ret					;an000; dms;

EA_Fail_Exit		endp			;an000; dms;

CODE	ENDS
	END	EDLIN


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\e2bequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
                                                ;                               ;     ;

NO      equ     0
YES     equ     not NO


DOS_Found equ   0

INIT    equ     0


Net_Check equ   1200h
Assign_Check equ 8000h

Found_Yes equ   1
Found_No equ    0

Asciiz_End equ  0
;DBCS_Blank_hi    equ     81h
DBCS_Blank equ	DB_SP_LO
DBCS_Vector_Size equ 2
End_Of_Vector equ 0


Blank   equ     " "

Label_Length equ 11
CR      equ     13

DBCS_VECTOR equ NO

;-------------------------------------------------------------------------------





DRNUM   EQU     5CH



; Exit status defines
ExitOK  equ     0


;-------------------------------------------------------------------------------
; These are the data structures which we will need



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\e2bmacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

MESSAGE macro   Message_Name                    ;                               ;AN000;
                                                ;
        mov     dx,offset Message_Name          ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
                                                ;
        endm                                    ;                               ;AN000;


;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure       macro   Proc_Name

Public  Proc_Name
Proc_Name    proc

        endm
;-----------------------------------------------------------------------------

DOS_Call        macro   Function

        mov     ah,Function
        int     21h

        endm
;-----------------------------------------------------------------------------

Parse_Message macro                                                             ;AN000;


        push    ds                                                              ;AN000;
        mov     dx,SEG parse_ptr                                                ;AN000;
        mov     ds,dx                                                           ;AN000;
        ASSUME  DS:DATA                                                         ;AN000;
        ASSUME  ES:DATA                                                         ;AN000;
        mov     word ptr Parse_Error_Msg,ax                                     ;AN000;
        mov     dx,offset Parse_Error_Msg       ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Extend_Message macro                            ;                               ;AN001;

                                                ;
        push    ds                                                              ;AN001;
        mov     dx,SEG parse_ptr                                                ;AN001;
        mov     ds,dx                                                           ;AN001;
        ASSUME  DS:DATA                                                         ;AN001;
        ASSUME  ES:DATA                                                         ;AN001;
        mov     word ptr Extend_Error_Msg,ax     ;                              ;AN001;
        mov     dx,offset Extend_Error_Msg       ;                              ;AN001;
        call    Display_Interface               ;                               ;AN001;
        pop     ds                                                              ;AN001;
        endm                                    ;                               ;AN001;

;-----------------------------------------------------------------------------

; macros to declare messages

addr macro sym,name
    public name
    ifidn <name>,<>
	dw offset sym
    else
    public name
name    dw  offset sym
    endif
endm


defmsg	macro	sym, name, str1, str2, str3, str4, str5
	sym	db	str1
	ifnb	<str2>
		db	str2
	endif
	ifnb	<str3>
		db	str3
	endif
	ifnb	<str4>
		db	str4
	endif
	ifnb	<str5>
		db	str5
	endif
	ifnb	<name>
	addr	sym, name
	endif
endm

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\e2btable.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
data    segment

;
;*****************************************************************************
; Macro's
;*****************************************************************************
;


Define_Msg macro Message_Name                   ;                               ;AN000;
                                                ;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
                                                ;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;               ;AN000;

Parm1   label   word                            ;                               ;AN000;
        dw      Parm2                           ;                               ;AN000;
        dw      Parm3                           ;                               ;AN000;
        dw      Parm4                           ;                               ;AN000;
        dw      Parm5                           ;                               ;AN000;
        db      Parm6                           ;                               ;AN000;
        db      Parm7                           ;                               ;AN000;
        dw      Parm8                           ;                               ;AN000;
        endm                                    ;                               ;AN000;


;---------------------------                    ;                               ;AN001;
Sublist_msg_parserr     label   dword           ;                               ;AN001;
                                                                                ;AN001;
        db              Sublist_Length          ;11                             ;AN001;
        db              Reserved                ;0                              ;AN001;
parsoff dw              ?                       ;off                            ;AN001;
parseg  dw              ?                       ;                               ;AN001;
        db              0                       ;USE PERCENT ZERO               ;AN001;
        db              Left_Align+Char_Field_ASCIIZ ;type of data              ;AN001;
        db              128                     ;max width                      ;AN001;
        db              1                       ;min width                      ;AN001;
        db              Blank                   ;pad char                       ;AN001;
;---------------------------                    ;                               ;AN001;

Sublist_msg_exterror label word                                                 ;AN001;

        db              Sublist_Length                                          ;AN001;
        db              Reserved                                                ;AN001;
FileNamePointer         label dword                                             ;AN001;
FileNameOffset  dw      ?                                                       ;AN001;
FileNameSegment dw      ?                                                       ;AN001;
        db              0                              ; SPECIAL %0 - Extended Errors only ;AN001;
        db              Left_Align+Char_Field_ASCIIZ                            ;AN001;
        db              132                                                     ;AN001;
        db              0                                                       ;AN001;
        db              Blank                                                   ;AN001;
;-----------------------------------------------------------------------------
;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************
;

Format_Msg              equ     'C'

N_A                     equ     0

Blank                   equ     " "
No_Function             equ     0

No_Input                equ     0


;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

MSG_OPTIONS_FIRST	equ	300
MSG_OPTIONS_LAST        equ     303

;----------------------                         ;
Message_Number  = 1                             ;                               ;AN000;
Handle          = No_Handle                     ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgBadDOSVersion        ;                               ;AN000;
;----------------------                         ;
Message_Number  = 2                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgOutOfMemory          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 3                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgLoadFailure          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 4                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoAccess             ;                               ;AN000;
;----------------------                         ;
Message_Number  = 5                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoConvert            ;                               ;AN000;
;----------------------                         ;
Message_Number  = 6                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoFile               ;                               ;AN000;
;----------------------                         ;
Message_Number  = 7                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgFileCreateError      ;                               ;AN000;
;----------------------                         ;
Message_Number  = 8                             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = DOS_BUF_KEYB_INP              ;                               ;AN000;
Input           = INBUF                         ;                               ;AN000;
        Define_Msg      msgFixUp                ;                               ;AN000;
;----------------------                         ;
Message_Number  = 0                             ;                               ;AN001;
Handle          = STDERR                        ;                               ;AN001;
Sublist         = ds:sublist_msg_parserr        ;                               ;AN001;
Count           = 1                             ;                               ;AN001;
Class           = Parse_Err_Class               ;                               ;AN001;
Function        = No_Input                      ;                               ;AN001;
Input           = N_A                           ;                               ;AN001;
        Define_Msg      parse_error_msg         ;                               ;AN001;
;----------------------                         ;
Message_Number  = 0                             ;                               ;AN001;
Handle          = STDERR                        ;                               ;AN001;
Sublist         = ds:sublist_msg_exterror       ;                               ;AN001;
Count           = 1                             ;                               ;AN001;
Class           = ext_Err_Class                 ;                               ;AN001;
Function        = No_Input                      ;                               ;AN001;
Input           = N_A                           ;                               ;AN001;
        Define_Msg      extend_error_msg        ;                               ;AN001;
;----------------------                         ;
Message_Number  = 10                            ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoDiskSpace          ;                               ;AN000;
;----------------------                         ;
Message_Number  = 12                            ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgNoFileName           ;                               ;AN000;
;----------------------                         ;
Message_Number  = MSG_OPTIONS_FIRST             ;                               ;AN000;
Handle          = STDOUT                        ;                               ;AN000;
Sublist         = No_Replace                    ;                               ;AN000;
Count           = N_A                           ;                               ;AN000;
Class           = Utility_Msg_Class             ;                               ;AN000;
Function        = No_Input                      ;                               ;AN000;
Input           = N_A                           ;                               ;AN000;
        Define_Msg      msgOptions              ;                               ;AN000;
;----------------------                         ;

data ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\dosdir.asm ===
;****************************************************************************
;
; dosdir.asm - IsDir() and support functions for compress.c,
;              stolen from dos.asm
;
;              Copyright (c) Microsoft Corporation 1989-1991
;              Microsoft Confidential
;              All Rights Reserved.
;
;****************************************************************************

; cmacros.inc options:
memS equ 1                 ; small model
?PLM = 0                   ; C calling convention, not Pascal
?WIN = 0                   ; no Windows prolog\epilog code

include cmacros.inc

COLON         equ ':'
PATH_SEP      equ '\'
NOT_SUPPORTED equ 2h       ; Return code from IsDeviceRemote function.
REMOTE        equ 3h       ; Return code for remote drive found.
TRUE          equ 1h       ; TRUE Definition
FALSE         equ 0h       ; False Definition.

FARPOINTER struc
         off   dw ?
         sel   dw ?
FARPOINTER ends

;=============================================================================

sBegin DATA

include ioctl.inc

sEnd   DATA

;=============================================================================

sBegin CODE
assumes CS, CODE
assumes DS, DATA

;----------------------------------------------------------------------------
;
; GetCurDrive() - returns current drive in AX
;                 (0 --> A, 25 --> Z)
;
;----------------------------------------------------------------------------

cProc GetCurDrive, <FAR, PUBLIC>

cBegin
         mov   ah, 19h              ; Get Current Drive
         int   21h
         xor   ah, ah               ; Zero out AH
cEnd


;----------------------------------------------------------------------------
;
; GetCurDir() - puts current directory in space pointed to by lpszDest
;
;----------------------------------------------------------------------------

cProc GetCurDir, <FAR, PUBLIC>, <DS, SI, DI>

ParmD lpszBuf

cBegin
         cCall GetCurDrive
         mov   si, ax               ; SI = Current drive

         les   di, lpszBuf          ; ES:DI = lpDest
         push  es
         pop   ds                   ; DS:DI = lpDest
         cld
         mov   ax, si               ; AX = Current drive
         inc   al                   ; Convert to logical drive number
         mov   dl, al               ; DL = Logical Drive Number
         add   al, '@'              ; Convert to ASCII drive letter
         stosb
         mov   al, ':'
         stosb
         mov   al, '\'              ; Start string with a backslash
         stosb
         mov   byte ptr es:[di], 0  ; Null terminate in case of error
         mov   si, di               ; DS:SI = lpDest[1]
         mov   ah, 47h              ; Get Current Directory
         int   21h
         jc    GetCurDirExit        ; Skip if error
         xor   ax, ax               ; Return FALSE if no error

GetCurDirExit:
cEnd


;----------------------------------------------------------------------------
;
; SetDrive() - returns the number of drives in AX
;
;----------------------------------------------------------------------------

cProc SetDrive, <FAR, PUBLIC>

ParmW wDrive   ; A --> 0, Z --> 25

cBegin
         mov   dx, wDrive
         mov   ah, 0Eh            ; Set Current Drive
         int   21h
         sub   ah, ah             ; Zero out AH
cEnd


;----------------------------------------------------------------------------
;
; SetDir() - changes the current directory to that specified by lpszDirName,
;            returns 0 in AX if successful, non-0 if not successful
;
;----------------------------------------------------------------------------

cProc SetDir, <FAR, PUBLIC>, <DS, DI>

ParmD lpszDirName

LocalV pszCwd, 128

cBegin
			lds	dx, lpszDirName	 ; DS:DX -> lpszDirName

         mov   bx, dx
         mov   ax, ds:[bx]
         cmp   ah, ':'
         jnz   NoDrive

         ; Convert drive letter to drive index.
         or    al, 20h
         sub   al, 'a'
         xor   ah, ah

         push  dx
         cCall SetDrive, <ax>
         pop   dx

         ; Check for drive-only specification.
         mov   di, dx
         cmp   BYTE PTR [di + 2], 0
         jne   ChDir

         ; Only drive specified.  Get current directory on that drive.
         lea   di, pszCwd         ; ds:di = pszCwd
         cCall GetCurDir, <di, ds>
         lea   dx, pszCwd

NoDrive:
ChDir:
         mov   ah, 3Bh            ; Change Current Directory
         int   21h
         jc    SetDirExit         ; Skip on error
         xor   ax, ax             ; Return 0 if successful

SetDirExit:
cEnd


;----------------------------------------------------------------------------
;
; IsDir() - returns 1 if the directory specified by lpszDir is valid,
;				0 if not
;
; History: M001 - Change to lpszDir's Drive before saving current directory.
;
;----------------------------------------------------------------------------

cProc IsDir, <FAR, PUBLIC>, <DS,ES,SI,DI>		;M001.

ParmD lpszDir FARPOINTER

LocalV pszCwd, 128

cBegin
											; M001 begin.
			cCall GetCurDrive
			mov	di, ax				; DI = Current drive

			les	bx, lpszDir			; ES:BX ->	lpszDir
			push	bx
			mov	ax, es:[bx]
			cmp	ah, ':'				; 1st character of lpszDir = drive letter?
			jnz	id20					; No, jump.

         ; Convert drive letter to drive index.
			or 	al, 20h				; Convert to lowercase.
         sub   al, 'a'
         xor   ah, ah

			cCall SetDrive, <ax> 	; Change to lpszDir's drive.

id20: 	lea	si, pszCwd
			cCall GetCurDir, <si, ds> ; DS:SI -> current dir. on this drive.
			pop	bx 					; ES:BX -> lpszDir.
			cCall SetDir, <bx, es>	; M001 end: Attempt change to lpszDir.
         or    ax, ax
			pushf 						; Save result.
			cCall SetDir, <si, ds>	; M001: Return to original dir. on this drive.

			cCall SetDrive, <di> 	; M001: Restore original drive.

         ; return TRUE (1) if SetDir returns 0, FALSE (0) otherwise

         xor   ax, ax
         popf
         jnz   IsDirExit
         inc   ax

IsDirExit:

cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;* BOOL DosIsRemote(int);                                                   *
;*                                                                          *
;* ENTRY:  Word, iPDrive: must be of the form ( logical volume A = 0 )      *
;*               Physical Drive Spec.                          B = 1        *
;*                                                             C = 2        *
;*                                                             ect.         *
;* EXIT: BOOL  returned in AX Remote = Remote                               *
;*                            False  = Local                                *
;*                            not_supported                                 *
;*                                                                          *
;* DESTROYS: AX. (preserves all registers except AX for return value)       *
;*                                                                          *
;* AUTHOR: MC                                                               *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc   DosIsRemote, <FAR, PUBLIC>, <BX,CX,DX,SI,DI,ES,DS>

ParmW   iPDrive                   ; Int Physical drive spec 0 - 25
localV  local_name,     16d       ; Buffer to hold redirected local name.
localV  net_name,      128d       ; Buffer to hold remote device name.
localV  remote_list,    42d       ; Buffer, will be filled with list of
                                  ; redirected local device names.
cBegin

        ; First, we need to make a list of remote devices (logical Volumes)
        ; I have to use DOS call int 21h/5f02h because DOS call int 21h/4409h
        ; is not reliable under DOS versions 4.00 and 4.01. (IBM fuck-up).

        xor     cx,cx
        xor     dx,dx

next_entry:
        mov     bx,cx                 ; CX = redirection list index.
        mov     ax,ss                 ; Load segs for stack vars.
        mov     es,ax
        mov     ds,ax
        mov     ax,5f02h              ; func 5f/02 Get redirection list.
        lea     si,local_name         ; ds:si = local_name
        lea     di,net_name           ; es:di = net_name
        push    cx                    ; save CX
        push    dx                    ; save DX
        int     21h
        pop     dx                    ; restore DX
        pop     cx                    ; restore CX
        jc      check_support         ; error, not supported or end of list.
        cmp     bl,04h                ; Is redirected device a drive ?
        jne     not_a_drive           ; If not, we don't care !

        mov     al,byte ptr ds:[si]   ; Grab volume name.
        sub     al,41h                ; Convert to volume number A=0 ect.
        lea     di,remote_list        ; get a pointer to our remote list.
        add     di,dx                 ; DX is index into list of devices.
        mov     byte ptr es:[di],al   ; save remote device into out list.
        inc     dx                    ; Increment list index pointer.

not_a_drive:
        inc     cx                    ; CX = redirection list index.
        jmp     short next_entry

check_support:
        cmp     ax,12h                ; AX = 12h means end of redir list !
        jne     Game_Over_Man         ; If not then soooo long.
        lea     di,remote_list
        add     di,dx                 ; DX is index into list of devices.
        mov     byte ptr es:[di],0ffh ; Terminate list.

        ;
        ; Is the drive remote ?
        ; See if it matches any entries in list of redirected devices.
        ;

        lea     di,remote_list        ; pointer to list of redirected drives.
        mov     bx,iPDrive            ; Grab the parameter.

next_in_list:
        cmp     byte ptr es:[di],0ffh ; Are we at the end of the redir list ?
        jne     keep_checking
        mov     ax,FALSE              ; Indicate Volume not remote !
        jmp     IsRemoteDone

keep_checking:
        xor     cx,cx
        mov     cl,byte ptr es:[di]
        cmp     bx,cx
        je      Found_Remote
        inc     di
        jmp     short next_in_list

Game_Over_Man:
        mov     ax,NOT_SUPPORTED      ; Indicate no support in return value.
        jmp     short IsRemoteDone

Found_Remote:
        mov     ax,REMOTE             ; Indicate Volume is remote !

IsRemoteDone:

cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;* BOOL DosRemoveable(char);                                                *
;*                                                                          *
;* ENTRY: Word iLDrive - Logical drive spec. A - Z. (case does not matter)  *
;*                                                                          *
;* EXIT:  BOOL Returns TRUE if media is removable. False if Remote or fixed *
;*                                                                          *
;* DESTROYS: AX. (preserves all registers except AX for return value)       *
;*                                                                          *
;* AUTHOR: MC                                                               *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc DosRemoveable, <FAR, PUBLIC>, <BX>

ParmW   iLDrive                     ; Logical Drive spec A - Z.

cBegin

        mov     bx,iLDrive          ; Grab the parameter.
        or      bx,20h              ; case insensitive.
        sub     bx,'a'              ; map to A=0
		  cCall	 DosIsRemote, <bx>	; M001: Find out if logical volume is remote
        cmp     ax,NOT_SUPPORTED    ; Not supported usually means no net, so
        je      ok_for_4408         ; drive should be local.
        or      ax,ax               ; check IsRemote return ?
        jnz     Remote_Or_Removable ; False ( 0 ) means local.

        ; Now we have found the volume is local, we can check to
        ; see if it's removable or not.

ok_for_4408:
        mov     ax,4408h            ; IOCTL is removeable
        inc     bx                  ; Map from A=0 to A=1 ...
        int     21h
        jc      Remote_Or_Removable ; error, skip
        or      al,al
        jnz     Remote_Or_Removable ; NOT removeable
        inc     ax
        jnz     ir_exit

Remote_Or_Removable:
        xor     ax,ax               ; Return FALSE for remote or removable.

ir_exit:                            ; Finished.

cEnd

sEnd CODE

END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\e2bparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
data    segment public 'DATA'



;
;***************************************************************************
; Equates
;***************************************************************************
;

;Match Flags

Numeric_Value           equ     8000h           ;                               ;AN000;
Signed_Numeric_Value    equ     4000h           ;                               ;AN000;
Simple_String           equ     2000h           ;                               ;AN000;
Date_String             equ     1000h           ;                               ;AN000;
Time_String             equ     0800h           ;                               ;AN000;
Complex_List            equ     0400h           ;                               ;AN000;
Filespec                equ     0200h           ;                               ;AN000;
Drive_Only              equ     0100h           ;                               ;AN000;
Quoted_String           equ     0080h           ;                               ;AN000;
Ignore_Colon            equ     0010h           ;                               ;AN000;
Repeats_Allowed         equ     0002h           ;                               ;AN000;
Optional                equ     0001h           ;                               ;AN000;

;Function_Flags

File_Table_Capitalize   equ     1               ;                               ;AN000;

;Result buffer type returned
rb_Number               equ     1
rb_List_Index           equ     2
rb_String               equ     3
rb_Complex              equ     4
rb_Filespec             equ     5
rb_Drive                equ     6
rb_Date                 equ     7
rb_Time                 equ     8
rb_Quoted_String        equ     9


;Extra delimeters and EOL

Delimiters_Only         equ     1               ;                               ;AN000;
EOL_Or_Delimiters       equ     2               ;                               ;AN000;

Semi_Colon              equ     ";"             ;                               ;AN000;
Tab                     equ     09h             ;                               ;AN000;
Colon1                  equ     ":"             ;                               ;AN000;
NUL                     equ     "0"

;Parse Errors

No_Error                equ     0               ;                               ;AN000;
Too_Many_Operands       equ     1               ;                               ;AN000;
Operand_Missing         equ     2               ;                               ;AN000;
Not_In_Switch_List      equ     3               ;                               ;AN000;
Not_In_Keyword_List     equ     4               ;                               ;AN000;
Out_Of_Range            equ     6               ;                               ;AN000;
Not_In_Value_List       equ     7               ;                               ;AN000;
Not_In_String_List      equ     8               ;                               ;AN000;
Syntax_Error            equ     9               ;                               ;AN000;
End_Of_Parse            equ     -1              ;                               ;AN000;

;Other

None                    equ     0               ;                               ;AN000;
No_Error                equ     0               ;                               ;AN000;
Switch_Found            equ     0FFFFh          ;                               ;AN000;
Range_Ok                equ     1               ;                               ;AN000;
Command_Line_Parms      equ     81h             ;                               ;AN000;

;
;*****************************************************************************
; Parse Structures
;*****************************************************************************
;

Control          struc

Match_Flags     dw      ?
Function_Flags  dw      ?
Result          dw      ?
Values          dw      ?
Num_Keywords    db      ?
Keyword         db      ?

Control         ends

File_Name_Return        struc                   ;                               ;AN000;

Drive_Type      db      0                       ;                               ;AN000;
Drive_Item_Tag  db      0                       ;                               ;AN000;
Synonym         dw      0                       ;                               ;AN000;
String_Value_ptr db     0                       ;File Name                      ;AN000;

File_Name_Return     ends                       ;                               ;AN000;


;
;**************************************************************************
; Parse tables
;**************************************************************************
;

Command_Line_Table label byte                      ;                               ;AN000;

        dw      Command_Control                 ;Point to next level            ;AN000;
        db      Delimiters_Only                 ;                               ;AN000;
        db      1                               ;                               ;AN000;
        db      Semi_Colon                      ;                               ;AN000;


;
;**************************************************************************
; Define Positionals, Switches and Keywords
;**************************************************************************
;

Command_Control label byte                      ;                               ;AN000;

        db      1,2                             ;File names Positional (1 required) ;AN000;
        dw      Positional_Control1             ;Pointer to control table       ;AN000;
        dw      Positional_Control2             ;Pointer to control table       ;AN000;
        db      1                               ; 1 switch
	dw	Switch_Control1			; Pointer to control table
        db      None                            ;No Keywords (maxk)             ;AN000;

;
;**************************************************************************
;Control Tables
;**************************************************************************
;

Positional_Control1 label byte                  ;                               ;AN000;

        dw      Filespec                        ;Match_Flag                     ;AN000;
        dw      File_Table_Capitalize           ;No function flags              ;AN000;
        dw      File_Name_Buffer1               ;Where it will be returned      ;AN000;
        dw      No_Value                        ;No value ranges defined        ;AN000;
        db      None                            ;No defined switches/keywords   ;AN000;

Positional_Control2 label byte                  ;                               ;AN000;

        dw      Filespec+Optional               ;Match_Flag                     ;AN000;

        dw      File_Table_Capitalize           ;No function flags              ;AN000;
        dw      File_Name_Buffer2               ;Where it will be returned      ;AN000;
        dw      No_Value                        ;No value ranges defined        ;AN000;
        db      None                            ;No defined switches/keywords   ;AN000;

Switch_Control1	label byte			; used by /?

	dw	0				; Match Mask
	dw	0				; Func Mask
	dw	Switch_Buffer1			; ptr to Results
	dw	No_Value			; ptr to Value
	db	1				; # of synonyms
sw1_s1	db	"/?",0				; 1st synonym

No_Value        label   byte                    ;                               ;AN000;
        db      0                               ;                               ;AN000;

;
;************************************************************************
; PARSE Return Buffers
;************************************************************************
;
File_name_Buffer1   label  byte                 ;                               ;AN000;

rb_type1       db      0                        ;type returned                  ;AN000;
rb_item_tag1   db      0                        ;matched item tag               ;AN000;
rb_synonym1    dw      0                        ;found synonyms                 ;AN000;
rb_string1_off dw      0                        ;Offset of string               ;AN000;
rb_string1_seg dw      0                        ;Offset of string               ;AN000;

File_name_Buffer2   label  byte                 ;                               ;AN000;

rb_type2       db      0                        ;type returned                  ;AN000;
rb_item_tag2   db      0                        ;matched item tag               ;AN000;
rb_synonym2    dw      0                        ;found synonyms                 ;AN000;
rb_string2_off dw      0                        ;Offset of string               ;AN000;
rb_string2_seg dw      0                        ;Offset of string               ;AN000;

Switch_Buffer1	label byte			; used by /?

sw_type1	db	0			; type returned
sw_tag1		db	0			; matched item tag
sw_synonym1	dw	0			; found synonym
sw_padding1	dd	0			; pad it out

data    ends


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\exe2bin\e2binit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

Title	E2BINIT(EXE2BIN)

;*****************************************************************************
;   Loader for EXE files under 86-DOS
;   VER 1.5
;	05/21/82   Added rev number
;   VER 1.6
;	07/01/82   A little less choosy about size matches
;   VER 2.0  M.A.U
;	10/08/82   Modified to use new 2.0 system calls for file i/o
;   Ver 2.1  M.A.U
;	10/27/82   Added the DOS version check
;   Ver 2.2  MZ
;	8/30/83     Fixed command line parsing
;   Ver 2.3  EE
;	10-12-83    More fixes to command line parsing
;   Ver 2.4  NP
;	10/17/83    Use Printf for messages
;   Ver 2.5  MZ     Fix LOCATE sss D: problem
;	04/09/87    Add PARSER and MESSAGE RETRIEVER
;   Ver 4.00  DRM
;
;       M001    MD      12/27/90        Removed special checks for ambiguous
;                                       file names
;*****************************************************************************


INCLUDE SYSMSG.INC
MSG_UTILNAME <EXE2BIN>							;AN000;

	subttl	Main Code Area						;AN000;
	page


; The following switch allows use with the "old linker", which put a version
; number where the new linker puts the number of bytes used in the last page.
; If enabled, this will cause a test for 0004 at this location (the old linker
; version number), and if equal, change it to 200H so all of the last page
; will be used.

OLDLINK EQU	0			;1 to enable, 0 to disable

CODE	SEGMENT PARA PUBLIC 'CODE'					;AN000;
CODE	ENDS								;AN000;
DATA	SEGMENT PARA PUBLIC 'DATA'					;AN000;
DATA	ENDS								;AN000;
STACK	SEGMENT PARA PUBLIC 'STACK'					;AN000;
STACK	ENDS								;AN000;
ZLOAD	SEGMENT PARA PUBLIC 'ZLOAD'					;AN000;
ZLOAD	ENDS								;AN000;

DATA	SEGMENT PARA PUBLIC 'DATA'					;AN000;

MSG_SERVICES <MSGDATA>							;AN000;

Command_Line_Buffer db 128 dup(0)					;AN000;
Command_Line_Length equ $ - Command_Line_Buffer 			;AN000;

Fatal_Error db	0							;AN000;

Command_Line db NO



rev	db	"2.4"


file1_ext db	".EXE",00h
file2_ext db	".BIN",00h

per11	db	0							;AN000;
per2	db	0
per22	db	0							;AN000;

update	equ	0							;AN000;
noupdate equ	-1							;AN000;

file1	db	(64+13) dup(?)
fnptr	dw	offset file1		; Ptr to filename in file1
handle1 dw	1 dup(?)

file2	db	(64+13) dup(?)
f2cspot dw	offset file2		; Ptr to spot in file2, file1 maybe added

name2_given	db	1		;1-> atleast the file2 name is present
ext2_given	db	0		;1-> full file2 spec given
file2_given	db	0		; is TRUE if user specified atleast a 
					; drive, or path (or full name)
handle2 dw	1 dup(?)

dma_buf db	80h dup(0)		; DMA transfer buffer

INBUF	DB	5,0
	DB	5 DUP(?)

;The following locations must be defined for storing the header:

RUNVAR	LABEL	BYTE			;Start of RUN variables
RELPT	DW	?
LASTP	LABEL	WORD
RELSEG	DW	?
SIZ	LABEL	WORD			;Share these locations
PAGES	DW	?
RELCNT	DW	?
HEADSIZ DW	?
	DW	?
LOADLOW DW	?
INITSS	DW	?
INITSP	DW	?
	DW	?
INITIP	DW	?
INITCS	DW	?
RELTAB	DW	?
RUNVARSIZ EQU	$-RUNVAR

DBCS_Vector_Off dw 0							;AN000;
DBCS_Vector_Seg dw 0							;AN000;

parse_ptr DW	?

DATA	ENDS


STACK	SEGMENT PARA PUBLIC 'STACK'
	DB	(362 - 80h) + 80H DUP (?) ; (362 - 80h) is IBMs ROM requirement
					; (New - Old) == size of growth
STACK	ENDS
;



ZLOAD	SEGMENT PARA PUBLIC 'ZLOAD'
	db	?
ZLOAD	ENDS
LOAD	EQU	ZLOAD
;



;
;*****************************************************************************
; Include files
;*****************************************************************************
;

.xlist
INCLUDE DOSSYM.INC			; also versiona.inc		;AN000;
INCLUDE SYSCALL.INC							;AN000;
INCLUDE E2BMACRO.INC							;AN000;
INCLUDE E2BEQU.INC							;AN000;
INCLUDE E2BTABLE.INC							;AN000;
INCLUDE E2BPARSE.INC							;AN000;
include version.inc
.list



CODE	SEGMENT PARA PUBLIC 'CODE'
	assume	cs:CODE,ds:DATA,es:NOTHING,SS:STACK			;AN000;

psp_ptr dw	1 dup(?)						;AN000;
;
;*****************************************************************************
; SysDisplayMsg Declarations
;*****************************************************************************
;
.xlist
MSG_SERVICES <LOADmsg>							;AN000;
MSG_SERVICES <DISPLAYmsg,CHARmsg>					;AN000;
MSG_SERVICES <EXE2BIN.CLA,EXE2BIN.CLB>					;AN000;
MSG_SERVICES <EXE2BIN.CL1,EXE2BIN.CL2>					;AN000;
MSG_SERVICES <EXE2BIN.CTL>						;AN000;


.list

;
;*****************************************************************************
; External Routine Declarations
;*****************************************************************************
;

	public	SysDispMsg						;AN000;
	public	SysLoadMsg						;AN000;


;*****************************************************************************
;Routine name:	Main_Init
;*****************************************************************************
;
;Description: Main control routine for init section
;
;Called Procedures: Message (macro)
;		    Check_DOS_Version
;		    Init_Input_Output
;		    Validate_Target_Drive
;		    Hook_CNTRL_C
;
;Input: None
;
;Output: None
;
;Change History: Created	6/22/87 	DM
;
;*****************************************************************************

procedure Main_Init near		;				;AN000;

	ASSUME	DS:NOTHING		; THIS IS WHAT dos GIVES YOU	;AN000;
	ASSUME	ES:NOTHING						;AN000;

	PUSH	DS							;AN000;
	mov	psp_ptr,ds						;AN000;
	XOR	AX,AX							;AN000;
	PUSH	AX			;Push return address to DS:0	;AN000;

	MOV	AX,SEG DATA		;SET UP ADDRESSABILITY TO	;AN000;
	MOV	DS,AX			; THE DATA SEGMENT		;AN000;
	ASSUME	DS:DATA 		;TELL ASSEMBLER WHAT I JUST DID ;AN000;

	mov	Fatal_Error,No		;Init the error flag		;AN000;
	call	Init_Input_Output	;Setup messages and parse	;AN000;
	cmp	Fatal_Error,Yes 	;Error occur?			;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF1
	    call    LOCATE		;Go do the real program 	;AN000;
;	$ENDIF								;AN000;
$$IF1:
	xor	al,al							;AN000;
	Dos_call Exit							;AN000;
	int	20h			;If other exit fails		;AN000;

Main_Init endp								;AN000;

;*****************************************************************************
;Routine name: Init_Input_Output
;*****************************************************************************
;
;Description: Initialize messages, Parse command line, allocate memory as
;	      needed. If there is a /FS switch, go handle it first as
;	      syntax of IFS format may be different from FAT format.
;
;Called Procedures: Preload_Messages
;		    Parse_For_FS_Switch
;		    Parse_Command_Line
;		    Interpret_Parse
;
;Change History: Created	6/22/87 	DM
;
;Input: PSP command line at 81h and length at 80h
;	Fatal_Error  = No
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************

procedure Init_Input_Output near					;AN000;

	call	Preload_Messages	;Load up message retriever	;AN000;
	cmp	Fatal_Error,YES 	;Quit?				;AN000;
;	$IF	NE			;Nope, keep going		;AN000;
	JE $$IF3
	    call    Parse_Command_Line	;Parse in command line input	;AN000;
;	$ENDIF								;AN000;
$$IF3:
	ret								;AN000;

Init_Input_Output endp							;AN000;

;*****************************************************************************
;Routine name: Preload_Messages
;*****************************************************************************
;
;Description: Preload messages using common message retriever routines.
;
;Called Procedures: SysLoadMsg
;
;
;Change History: Created	6/22/87 	DM
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************

procedure Preload_Messages near 					;AN000;

	call	SYSLOADMSG		;Preload the messages		;AN000;
;	$IF	C			;Error? 			;AN000;
	JNC $$IF5
	    call    SYSDISPMSG						;AN000;
	    mov     fatal_error, YES					;AN000;
;	$ENDIF								;AN000;
$$IF5:
	ret								;AN000;
Preload_Messages endp							;AN000;


;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description: Parses command line.
;
;Called Procedures: Message (macro)
;		    Sysparse
;
;Change History: Created	6/22/87 	DM
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;*****************************************************************************


Procedure Parse_Command_Line						;AN000;

	push	ds							;AN000;
	mov	ds,psp_ptr						;AN000;
	ASSUME	DS:NOTHING						;AN000;
	mov	si,Command_Line_Parms					;AN000;
	mov	ax,seg command_line_table				;AN000;
	push	es							;AN000;
	mov	es,ax							;AN000;
	ASSUME	ES:NOTHING						;AN000;
	mov	di,offset Command_Line_Table				;AN000;
	xor	cx,cx							;AN000;

	PUBLIC	MainParseLoop
MainParseLoop:

;	$DO								;AN000;
$$DO7:
	    xor     dx,dx						;AN000;
	    mov     es:parse_ptr,si
	    call    Sysparse						;AN000;
	    cmp     ax,No_Error 					;AN000;

;	    $IF     E							;AN000;
	    JNE $$IF8

	        ; Check if /? switch entered.
		; If so, display the options help message
		; and set for exit.
		;
		; This gives the user the info they want,
		; without all the other possible error messages.
		;
		; 4/18/90 c-PaulB

		cmp	es:[sw_synonym1], offset sw1_s1	; /?
		jne	CheckSW1Done			;  skip this if not
		call	DisplayOptions			; else display msg
		mov	es:[Fatal_Error], YES		; set flag to stop
		jmp	ParseCLExit			;  and bail out now
CheckSW1Done:

		push	ax						;AN000;
		push	bx						;AN000;
		push	ds						;AN000;
		push	es						;AN000;
		push	si						;AN000;
		push	di						;AN000;

		cmp	cx,1						;AN000;

;		$IF	E						;AN000;
		JNE $$IF9

		    mov     ax,seg rb_string1_off			;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,offset rb_string1_off			;AN000;
		    mov     ax,ds:[si]					;AN000;
		    mov     bx,ax					;AN000;


		    mov     ax,ds:[si+2]				;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,bx					;AN000;

		    mov     ax,seg file1				;AN000;
		    mov     es,ax					;AN000;
		    ASSUME  ES:NOTHING					;AN000;
		    mov     di,offset file1				;AN000;
		    call    copyfs					;AN000;

;		$ELSE							;AN000;
		JMP SHORT $$EN9
$$IF9:

		    mov     ax,seg rb_string2_off			;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,offset rb_string2_off			;AN000;
		    mov     ax,ds:[si]					;AN000;
		    mov     bx,ax					;AN000;


		    mov     ax,ds:[si+2]				;AN000;
		    mov     ds,ax					;AN000;
		    ASSUME  DS:NOTHING					;AN000;
		    mov     si,bx					;AN000;

		    mov     ax,seg file2				;AN000;
		    mov     es,ax					;AN000;
		    ASSUME  ES:NOTHING					;AN000;
		    mov     di,offset file2				;AN000;
		    call    copyfs					;AN000;

;		$ENDIF							;AN000;
$$EN9:

		pop	di						;AN000;
		pop	si						;AN000;
		pop	es						;AN000;
		ASSUME	ES:NOTHING					;AN000;
		pop	ds						;AN000;
		ASSUME	DS:NOTHING					;AN000;
		pop	bx						;AN000;
		pop	ax						;AN000;

;	    $ENDIF							;AN000;
$$IF8:

	    cmp     ax,No_Error 					;AN000;

;	$ENDDO	NE							;AN000;
	JE $$DO7

	cmp	ax,End_of_Parse 	;Check for parse error		;AN000;
;	$IF	NE							;AN000;
	JE $$IF14
		push	ax						;AN001;
		mov	ax,es:parse_ptr 				;AN001;
		mov	es:parsoff,ax					;AN001;
		mov	es:parseg,ds					;AN001;
		mov	byte ptr ds:[si],0				;AN001;
		pop	ax						;AN001;
		parse_message		       ;Must enter file name	;AN000;
		mov	es:Fatal_Error,YES     ;Indicate death! 	;AN000;
;	$ENDIF								;AN000;
$$IF14:
ParseCLExit:
	pop	es							;AN000;
	ASSUME	ES:NOTHING						;AN000;
	pop	ds							;AN000;
	ASSUME	DS:DATA 						;AN000;

	ret								;AN000;

Parse_Command_Line endp 						;AN000;

;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description:       Displays options help message lines.
;
;Called Procedures: Display_Interface
;
;Change History:    Created 5/2/90 c-PaulB
;
;Input:             No value passed.
;
;Output:            No value returned.
;
;*****************************************************************************


Procedure DisplayOptions

	mov     dx, offset msgOptions		; get options msg
DO_Loop:
	call    Display_Interface		;  and show it
	cmp	word ptr es:[msgOptions], MSG_OPTIONS_LAST	; last msg?
	je	DO_Done				; done if so
	inc	word ptr es:[msgOptions]		; else get next msg
	jmp	short DO_Loop			;  and go do it
DO_Done:
	ret

DisplayOptions	endp

;*****************************************************************************

INCLUDE PARSE.ASM

;*****************************************************************************


procedure LOCATE near

	push	ds							;AN000;
	ASSUME	ES:NOTHING		; THIS IS THE WAY IT GETS HERE! ;AN000;
	mov	ax,es			; ES -> PSP			;AN000;
	mov	ds,ax			; DS -> PSP			;AN000;
	ASSUME	DS:NOTHING						;AN000;

	MOV	SI,offset file1
	MOV	BX,SEG DATA
	MOV	ES,BX
	assume	es:data 						;AN000;

	MOV	BX,WORD PTR DS:[2]	;Get size of memory


;-----------------------------------------------------------------------;

;
; The rules for the arguments are:
;   File 1:
;	If no extention is present, .EXE is used.
;   File 2:
;	If no drive is present in file2, use the one from file1
;	If no path is specified, then use current dir
;	If no filename is specified, use the filename from file1
;	If no extention is present in file2, .BIN is used
;


;----- Get the first file name
	push	ds							;AN000;
	push	es							;AN000;
	ASSUME	ES:DATA 						;AN000;
	pop	ds							;AN000;
	ASSUME	DS:DATA 						;AN000;

sj01:
	mov	si,offset file1 	;   d = file1;
	mov	per11,0 		;   assume no extension on file1;AC000;

;******************************************************************************

sj0:
	lodsb				;   while (!IsBlank(c=*p++)) {
	cmp	al,0
	JE	SJ2
	call	dbcs_check		; see if a dbcs character	;AN000;
	jc	dbcs_1			; dbcs character, go load another char ;AN000;
	cmp	al,'\'			;	if (c == '\\' || c == ':') {
	jnz	sj05
	mov	per11,update						;AC000;
	mov	fnptr,si		;	    fnptr = ptr to slash
sj05:
	cmp	al,':'			;	if (c == '\\' || c == ':') {
	jnz	checkper1
	mov	per11,update						;AC000;
	mov	fnptr,si		;	    fnptr = ptr to slash
checkper1:
	cmp	al,'.'			;	if (c == '.')
	jne	sj0                     ;                               ;M001
	mov	per11,noupdate		;   set file1 to have extension ;AN000;
        jmp     short sj0               ;                               ;M001
                                        ;M001 - code removed
dbcs_1: 				;				;AN000;
	lodsb				; load another character and got to ;AN000;
	jmp	short sj0		; the start again.		;AN000;

;******************************************************************************

sj2:
get_second:
;----- Get the second file name
; Initially we assume that user has not given any file2 spec. Then if we find
; that user has entered something, then file2_given is made to TRUE;
; Once file2_given is TRUE, then we assume that user has given atleast a name
; i.e. name2_given = 1 but ext2_given = 0;
; if we find that user has given just a drive: then name2_given is made to FALSE
; The logic then simplifies to :
;	if (!file2_given) 
;		copy file1 and add .BIN ext and try to open
; 	else { /* file2 given */
;		if (!name2_given) 
;			copy name from file1 and .BIN as extn ; try to open
;		else { /* name2 also given */
;			do find_first		
;			if (file_not_found) 
;				add extn .BIN if needed and try to open
;			else if (it is subdir)  {
;				add '\' to it;
;				add the file1 name and .BIN 
;				go for file open
;			}	
;		} /* else name2 given*/
;	} /* else file2 given */

	MOV	SI,offset file1
	mov	di,offset file2 	;   d = file2

;******************************************************************************

sj3:
	cmp	word ptr [di],00	;   check to see if first character of
	je	sj32			;   file2 is a null.		;AN000;
	mov	file2_given,1		;   user has given atleast a partial
					;    spec for file2
	mov	si,offset file2 	;   set pointer to file2

;******************************************************************************

sj31:
	lodsb				;   If file2 first character is not a
	mov	f2cspot,si
	cmp	al,0			;   null, this loop will check to see
	JZ	maycopy 		;   the file has an extension assigned;AN000;
	call	dbcs_check		; to it.  If not it will set per2 to  ;AN000;
	jc	dbcs_2			; go load another byte		      ;AN000;
	cmp	al,'\'			
	jnz	checkper6	
	cmp	byte ptr [si],0		;   end of file2 spec ?
	jne	sj31			;  no, go get next char
	mov	name2_given,0		; copy from file1
checkper6:
	cmp	al,':'			;	if (c == '\\' || c == ':') {
	jnz	checkper4
	cmp	byte ptr [si],0		; end of file2 spec ?
	jne	sj31			; no, go get next char
	mov	name2_given,0		; no name; copy from file1
checkper4:				;   there is an extension already.
	cmp	al,'.'			;
	jne	sj31			;       M001
	mov	ext2_given,1		;       M001 - code removed
	jmp	short sj31		;       M001
                                        ;       M001 - code removed
dbcs_2:                                 ;
	lodsb				;load another character and got to    ;AN000;
	jmp	short sj31		;the start again.		      ;AN000;

;******************************************************************************

; we get here only if user specified something - a drive, just a name or
; even the full spec
; check if we have to copy the name 

maycopy:				
	cmp	name2_given,1		; did the user give a name
	je	sj5			; yes, go check for the existence 
	
	dec	f2cspot 						      
	mov	di,f2cspot						     

sj32:
					;   There is no second filename so
	mov	si,fnptr						      ;AN000;

;******************************************************************************

copy1to2:								      ;AN000;
	lodsb				; This loop is executed when there is ;AN000;
	cmp	al,0			; no file2 specified on the command   ;AN000;
	JZ	SJ5			; line.  It will copy the file1 name  ;AN000;
	call	dbcs_check		; check for dbcs character	      ;AN000;
	jc	dbcs_3			; got a dbcs character, go copy.      ;AN000;
	cmp	al,'.'			; extension.  The defult extension    ;AN000;
	je	sj5			; of .BIN will be added in check_ext. ;AN000;
	stosb								      ;AN000;
	jmp	short copy1to2						      ;AN000;
dbcs_3:
	stosb				; Got a dbcs character. Copy	      ;AN000;
	lodsb				; two characters and then go to       ;AN000;
	stosb				; next character in filename.	      ;AN000;
	jmp	short copy1to2						      ;AN000;	     ;AN000;

;******************************************************************************

sj5:
;	mov	byte ptr es:[di],00h	;   *d = 0;
	cmp	file2_given,1		; if the user specified some path
	jne	check_ext		; we need to check it; else 
	cmp	name2_given,1		; add .BIN and try to open file2
	jne	check_ext		; (at this point we have the name)
	mov	ah,Set_DMA		; Use find_first to see if file2 is
	mov	dx,offset dma_buf	; a directory.	If it isn't, go to
	int	21h			; set f2cspot to point to the spot
	mov	ah,Find_First		; right after the backslash, and
	mov	dx,offset file2 	; fall through to no_second so that
	mov	cx,-1			; file1's name will be added to file2.
	int	21h
	jc	check_ext
	test	dma_buf+21,00010000b
	jNZ	DoDirectory
	jmp	short Check_Ext
DoDirectory:
	mov	AL,'\'
	mov	di,f2cspot
	dec	di
	stosb
	inc	f2cspot
	mov	name2_given,0		; so that we will copy file1.ext to
	mov	ext2_given,0		; file2; we also have to copy ext
	jmp	maycopy			; 


;----- Check that files have an extension, otherwise set default
check_ext:
	cmp	per11,noupdate		;   if (ext2_given == NULL) { 	;AC000;
	jz	file1_ok
	mov	di,offset file1 	;	d = file1;
	mov	si,offset file1_ext	;	s = ".EXE";
	call	strcat			;	strcat (d, s);
file1_ok:				;	}
	cmp	ext2_given,1		;   if (ext2_given == NULL) { 	;AC000;
	je	file2_ok
	mov	di,offset file2 	;	d = file2;
	mov	si,offset file2_ext	;	s = ".BIN";
	call	strcat			;	strcat (d, s);
	jmp	short file2_ok		;	}

;-----------------------------------------------------------------------;
file2_ok:
	mov	dx,offset file1
	mov	ax,(open SHL 8) + 0	;for reading only
	INT	21H			;Open input file
	jc	bad_file
	mov	[handle1],ax
	jmp	short exeload

bad_file:
	jmp	DosError

BADEXE:
	pop	ds
	ASSUME	DS:nothing						;AN000;
	MESSAGE msgNoConvert						;AC000;
	jmp	getout							;AN000;

ReadError:
	jmp	DosError

EXELOAD:
	ASSUME	DS:DATA 						;AN000;
	MOV	DX,OFFSET RUNVAR	;Read header in here
	MOV	CX,RUNVARSIZ		;Amount of header info we need
	push	bx
	mov	bx,[handle1]
	MOV	AH,read
	INT	21H			;Read in header
	pop	bx
	jc	ReadError
	CMP	[RELPT],5A4DH		;Check signature word
	JNZ	BADEXE
	MOV	AX,[HEADSIZ]		;size of header in paragraphs
	ADD	AX,31			;Round up first
	CMP	AX,1000H		;Must not be >=64K
	JAE	TOOBIG
	AND	AX,NOT 31
	MOV	CL,4
	SHL	AX,CL			;Header size in bytes

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,ax
	xor	cx,cx
	mov	al,0
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	XCHG	AL,AH
	SHR	AX,1			;Convert to pages
	MOV	DX,[PAGES]		;Total size of file in 512-byte pages
	SUB	DX,AX			;Size of program in pages
	CMP	DX,80H			;Fit in 64K? (128 * 512 = 64k)
	JAE	TOOBIG
	XCHG	DH,DL
	SHL	DX,1			;Convert pages to bytes
	MOV	AX,[LASTP]		;Get count of bytes in last page
	OR	AX,AX			;If zero, use all of last page
	JZ	WHOLEP

	IF	OLDLINK
	    CMP     AX,4		;Produced by old linker?
	    JZ	    WHOLEP		;If so, use all of last page too
	ENDIF

	SUB	DX,200H 		;Subtract last page
	ADD	DX,AX			;Add in byte count for last page
WHOLEP:
	MOV	[SIZ],DX
	ADD	DX,15
	SHR	DX,CL			;Convert bytes to paragraphs
	MOV	BP,SEG LOAD
	ADD	DX,BP			;Size + start = minimum memory (paragr.)
	CMP	DX,BX			;Enough memory?
	JA	TOOBIG
	MOV	AX,[INITSS]
	OR	AX,[INITSP]
	OR	AX,[INITCS]
	JMP	short ERRORNZ

TOOBIG:
	pop	ds
	ASSUME	DS:NOTHING						;AN000;
	MESSAGE msgOutOfMemory						;AN000;
	jmp	getout							;AN000;

LseekError:
	jmp	DosError


ERRORNZ:
	ASSUME	DS:DATA 						;AN000;
	jz	xj
	JMP	BADEXE			;AC000; For ptm P475;
xj:	MOV	AX,[INITIP]
	OR	AX,AX			;If IP=0, do binary fix
	JZ	BINFIX
	CMP	AX,100H 		;COM file must be set up for CS:100
	JNZ	ERRORNZ

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,100h 		;chop off first 100h
	xor	cx,cx
	mov	al,1			;seek from current position
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	SUB	[SIZ],AX		;And count decreased size
	CMP	[RELCNT],0		;Must have no fixups
	JNZ	ERRORNZ
BINFIX:
	XOR	BX,BX			;Initialize fixup segment
;See if segment fixups needed
	CMP	[RELCNT],0
	JZ	LOADEXE
GETSEG:
	pop	ds
	ASSUME	DS:NOTHING						;AN000;
	MESSAGE msgFixUp						;AN000;
	PUSH	DS
	PUSH	ES
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	MOV	AH,STD_CON_STRING_INPUT
	MOV	DX,OFFSET INBUF
	INT	21H			;Get user response
	MOV	SI,OFFSET INBUF+2
;;dcl;; MOV	BYTE PTR [SI-1],0	;Any digits?
	cmp	BYTE PTR [SI-1],0	;Any digits?			;AC000;
	JZ	GETSEG
DIGLP:
	LODSB
	SUB	AL,"0"
	JC	DIGERR
	CMP	AL,10
	JB	HAVDIG
	AND	AL,5FH			;Convert to upper case
	SUB	AL,7
	CMP	AL,10
	JB	DIGERR
	CMP	AL,10H
	JAE	DIGERR
HAVDIG:
	SHL	BX,1
	SHL	BX,1
	SHL	BX,1
	SHL	BX,1
	OR	BL,AL
	JMP	DIGLP

DIGERR:
	CMP	BYTE PTR [SI-1],0DH	;Is last char. a CR?
	JNZ	GETSEG
LOADEXE:
	XCHG	BX,BP			;BX has LOAD, BP has fixup

	MOV	CX,[SIZ]
	MOV	AH,read
	push	di
	mov	di,[handle1]
	PUSH	DS
	MOV	DS,BX
	ASSUME	DS:NOTHING						;AN000;
	XOR	DX,DX
	push	bx
	mov	bx,di
	INT	21H			;Read in up to 64K
	pop	bx
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	pop	di
	Jnc	HAVEXE			;Did we get it all?

	jmp	DosError

LseekError2:
	jmp	DosError

HAVEXE:
	ASSUME	DS:DATA 						;AN000;
	CMP	[RELCNT],0		;Any fixups to do?
	JZ	STORE
	MOV	AX,[RELTAB]		;Get position of table

	push	dx
	push	cx
	push	ax
	push	bx
	mov	dx,ax
	xor	cx,cx
	mov	al,0
	mov	bx,[handle1]
	mov	ah,lseek
	int	21h
	jc	LseekError2
	pop	bx
	pop	ax
	pop	cx
	pop	dx

	MOV	DX,OFFSET RELPT 	;4-byte buffer for relocation address
RELOC:
	MOV	DX,OFFSET RELPT 	;4-byte buffer for relocation address
	MOV	CX,4
	MOV	AH,read
	push	bx
	mov	bx,[handle1]
	INT	21H			;Read in one relocation pointer
	pop	bx
	Jnc	RDCMP
	jmp	short DosError
RDCMP:
	MOV	DI,[RELPT]		;Get offset of relocation pointer
	MOV	AX,[RELSEG]		;Get segment
	ADD	AX,BX			;Bias segment with actual load segment
	MOV	ES,AX
	ASSUME	ES:NOTHING						;AN000;
	ADD	ES:[DI],BP		;Relocate
	DEC	[RELCNT]		;Count off
	JNZ	RELOC
STORE:
	MOV	AH,CREAT
	MOV	DX,OFFSET file2
	xor	cx,cx
	INT	21H
	Jc	MKERR
	mov	[handle2],ax
	MOV	CX,[SIZ]
	MOV	AH,write
	push	di
	mov	di,[handle2]
	PUSH	DS
	MOV	DS,BX
	ASSUME	DS:NOTHING						;AN000;
	XOR	DX,DX			;Address 0 in segment
	push	bx
	mov	bx,di
	INT	21H
	pop	bx
	POP	DS
	ASSUME	DS:DATA 						;AN000;
	pop	di
	Jc	WRTERR			;Must be zero if more to come
	cmp	AX,CX
	jnz	NOROOM
	MOV	AH,CLOSE
	push	bx
	mov	bx,[handle2]
	INT	21H
	jc	CloseError
	pop	bx
	pop	ds
	pop	ds
	ASSUME	DS:NOTHING						;AN000;

	RET

;*******************************************************************************

NOROOM: 				;				     ;AN000;
	ASSUME	DS:DATA 						;AN000;
	MOV	AH,CLOSE		; Close the file here		     ;AN000;
	push	bx			;				     ;AN000;
	mov	bx,[handle2]		;				     ;AN000;
	INT	21H			;				     ;AN000;
	jc	CloseError		; If error let extend messages get it;AN000;
	pop	bx			;				     ;AN000;
	mov	ah,UNLINK		; Delete the file because it did     ;AN000;
	MOV	DX,OFFSET file2 	; not get written correctly.	     ;AN000;
	INT	21H			;				     ;AN000;
	jc	CloseError		; If error let extend messages get it;AN000;
	pop	ds			;				     ;AN000;
	ASSUME	DS:NOTHING		;				     ;AN000;
	message msgNoDiskSpace		; Put out insufficient disk space    ;AN000;
	jmp	short getout		; message			     ;AN000;
	RET				; return to main_init		     ;AN000;

;*******************************************************************************

WRTERR: 								;AN000;
MKERR:									;AN000;
CloseError:								;AN000;

	public	DosError						;AN000;
DosError:								;AN000;
	mov	es:FileNameSegment,ds	   ; save for opens, creates,	;AN000;
	mov	es:FileNameOffset,dx					;AN000;

	mov	bx,0			; get the extended error code	;AN000;
	mov	ah,059h 						;AN000;
	int	21h							;AN000;

	mov	si,offset ds:Sublist_msg_exterror			;AC001;
	extend_message							;AN001;
	pop	ds							;AN001;

getout: 								;AN000;
	pop	ds							;AN000;
	ASSUME	DS:NOTHING						;AN000;

	ret								;AN000;


LOCATE	ENDP

;----- concatenate two strings
strcat	proc	near			;   while (*d)
	cmp	byte ptr [di],0
	jz	atend
	inc	di			;	d++;
	jmp	strcat
atend:					;   while (*d++ = *s++)
	lodsb
	stosb
	or	al,al			;	;
	jnz	atend
	ret
strcat	endp

;----- Find the first non-ignorable char, return carry if CR found
kill_bl proc	near
	cld
sj10:					;   while ( *p != 13 &&
	lodsb
	CMP	AL,13			;	    IsBlank (*p++))
	JZ	BreakOut
	CALL	IsBlank
	JZ	SJ10			;	;
BreakOut:
	dec	si			;   p--;
	cmp	al,0dh			;   return *p == 13;
	clc
	jne	sj11
	stc
sj11:
	ret
kill_bl endp

IsBlank proc	near
	cmp	al,00							;AN000;
	retz								;AN000;
	cmp	al,13
	retz
	cmp	al,' '			; space
	retz
	cmp	al,9			; tab
	retz
	cmp	al,','			; comma
	retz
	cmp	al,';'			; semicolon
	retz
	cmp	al,'+'			; plus
	retz
	cmp	al,10			; line feed
	retz
	cmp	al,'='			; equal sign
	return
IsBlank Endp


procedure copyfs near

	push	ax							;AN000;

;	$do				; while we have filespec	;AN000;
$$DO16:
	    lodsb			; move byte to al		;AN000;
	    cmp     al,0		; see if we are at		;AN000;
					; the end of the
					; filespec
;	$leave	e			; exit while loop		;AN000;
	JE $$EN16
	    stosb			; move byte to path_name	;AN000;
;	$enddo				; end do while			;AN000;
	JMP SHORT $$DO16
$$EN16:
	stosb								;AN000;
	pop	ax							;AN000;

	ret								;AN000;
copyfs	endp								;AN000;


procedure dbcs_check near

	push	ds				;Save registers 	;AC000;
	push	si				; "  "	  "  "		;AC000;
	push	ax				; "  "	  "  "		;AC000;
	push	ds				; "  "	  "  "		;AC000;
	pop	es				;Establish addressability;AC000;
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?	;AC000;
	push	ax				;Save input character	;AC000;
;	$IF	NE				;Nope			;AN000;
	JE $$IF19
	   mov	   al,0 			;Get DBCS environment vectors;AC000;
	   DOS_Call Hongeul			;  "  "    "  " 	;AC000;
	   mov	   byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector;AC000;
	   mov	   es:DBCS_Vector_Off,si	;Save the vector	;AC000;
	   mov	   ax,ds			;			;AC000;
	   mov	   es:DBCS_Vector_Seg,ax	;			;AC000;
;	$ENDIF					; for next time in	;AC000;
$$IF19:
	pop	ax				;Restore input character;AC000;
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer;AC000;
	mov	ds,si				;			;AC000;
	mov	si,es:DBCS_Vector_Off		;			;AC000;
;	$SEARCH 				;Check all the vectors	;AC000;
$$DO21:
	   cmp	   word ptr ds:[si],End_Of_Vector ;End of vector table? ;AC000;
;	$LEAVE	E				;Yes, done		;AC000;
	JE $$EN21
	   cmp	   al,ds:[si]			;See if char is in vector;AC000;
;	$EXITIF AE,AND				;If >= to lower, and	;AC000;
	JNAE $$IF21
	   cmp	   al,ds:[si+1] 		; =< than higher range	;AC000;
;	$EXITIF BE				; then DBCS character	;AC000;
	JNBE $$IF21
	   stc					;Set CY to indicate DBCS;AC000;
;	$ORELSE 				;Not in range, check next;AC000;
	JMP SHORT $$SR21
$$IF21:
	   add	   si,DBCS_Vector_Size		;Get next DBCS vector	;AC000;
;	$ENDLOOP				;We didn't find DBCS chaR;AC000;
	JMP SHORT $$DO21
$$EN21:
	   clc					;Clear CY for exit	;AC000;
;	$ENDSRCH				;			;AC000;
$$SR21:
	pop	ax				;Restore registers	;AC000;
	pop	si				; "  "	  "  "		;AC000;
	pop	ds				;Restore data segment	;AC000;
	ret					;			;AC000;

	ret								;AN000;
dbcs_check  endp							;AN000;



CODE	ends


	end	main_init						;AC000;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\doslzexp.c ===
/*
**          DOS Lempel-Ziv Data Decompression Module
**          written by Steve Zeck and David Dickman
**
**          (C) Copyright 1989-1991 by Microsoft Corp.
**          Microsoft Confidential
**          All Rights Reserved.
**
** This module contains functions and variables common to the LZ command-line
** module (compress.c), the DOS library module (lzcopy.c), and the Windows
** DLL (lzexpand.dll).
*/


// Headers
///////////

#include <string.h>
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>

#include "doslzexp.h"


// Globals
//////////
UCHAR FAR *rguchInBuf;     // input buffer for reads
UCHAR FAR *puchInBufEnd;   // pointer past end of rguchInBuf[]
UCHAR FAR *puchInBuf;      // pointer to next byte to read from rguchInBuf[]

UCHAR FAR *rguchOutBuf;    // output buffer for writes
UCHAR FAR *puchOutBufEnd;  // pointer past end of rguchOutBuf[]
UCHAR FAR *puchOutBuf;     // pointer to last byte to write from rguchOutBuf[]

UCHAR FAR *rguchRingBuf;   // ring buffer

// flag indicating whether or not rguchInBuf[0], which holds the last byte
// from the previous input buffer, should be read as the next input byte
// (only used so that at least one unReadUChar() can be done at all input
// buffer positions)
BOOL bLastUsed;

unsigned ucbIOBufLen;      // length of input and output buffers
// (actually, rguchInBuf[] has length ucbIOBufLen + 1 since rguchInBuf[0] is
// used when bLastUsed is TRUE)




// copyCreateDate()
//
// Copies create date of file with DOS handle doshfrom to file with DOS
// handle doshTo.  Returns LZERROR_BADINHANDLE or LZERROR_BADOUTHANDLE as
// error codes.
//
// n.b., stream-style I/O routines like fopen() and fclose() may counter the
// intended effect of this function.  fclose() writes the current date to any
// file it's called with which was opened in write "w" or append "a" mode.
// One klugey way to get around this in order to modify the date of a file
// opened for writing or appending by fopen() is to fclose() the file and
// fopen() it again in read "r" mode.  Then pass it to copyCreateDate().
//
int CopyCreateDate(int doshFrom,       // date and time stamp origin handle
                   int doshTo)         // target handle
{
   // _dos function prototypes
   extern unsigned _dos_getftime(int, unsigned *, unsigned *);
   extern unsigned _dos_setftime(int, unsigned, unsigned);
   unsigned uFrom_date, uFrom_time;

   if (_dos_getftime(doshFrom, &uFrom_date, &uFrom_time) != 0u)
      return((int)LZERROR_BADINHANDLE);

   if (_dos_setftime(doshTo, uFrom_date, uFrom_time) != 0u)
      return((int)LZERROR_BADOUTHANDLE);

   return(COPYCREATEDATE_OK);
}  // copyCreateDate()



// ReadInBuf()
//
// Reads input buffer from input file.  Returns c cast as an int if the read
// is successful.  If the read is unsuccessful, returns LZERROR_BADINHANDLE or
// END_OF_INPUT.
//
int ReadInBuf(UCHAR LZPTR *puch, // first character to be read from the new
                                 // input buffer after reading from disk
              int doshSource)    // DOS input file handle
{
   unsigned ucbRead;             // number of bytes actually read

   rguchInBuf[0] = *(puchInBufEnd - 1);

   if ((ucbRead = FREAD(doshSource, &rguchInBuf[1], ucbIOBufLen))
       != ucbIOBufLen)
      if (_error != 0U)
         // given incorrect input file handle
         return((int)LZERROR_BADINHANDLE);
      else if (ucbRead > 0U)
         // read last ucbRead bytes of input file, change input buffer end to
         // account for shorter read
         puchInBufEnd = &rguchInBuf[1] + ucbRead;
      else  // (ucbRead == 0U)
         // couldn't read any bytes from input file (EOF)
         return(END_OF_INPUT);

   // reset read pointer to beginning of input buffer
   puchInBuf = &rguchInBuf[1];

   if (bLastUsed)
   {
      // return the last character from the previous input buffer
      bLastUsed = FALSE;
      return((int)(*puch = rguchInBuf[0]));
   }
   else
      // return the first character from the new input buffer
      return((int)(*puch = *puchInBuf++));
}  // ReadInBuf()



// GetHdr()
//
// Puts compressed file header information from file with DOS handle
// doshSource into the file info structure pointed to by pFH.  Returns TRUE
// if input file size was long enough to have contained valid header
// information.  Returns FALSE if file was too short to have contained header
// information, or if a read error occurred when trying to get the header.
//
BOOL GetHdr(FH LZPTR *pFH,       // pointer to destination info structure
            int doshSource)      // DOS input file handle
{
   UCHAR rguchBuf[cbHdrSize];    // storage for compressed file header
   long cblInSize;               // length of input file
   int i, j;

   // get file length to compare to size of compressed file header
   if ((cblInSize = FSEEK(doshSource, 0L, SEEK_END)) == -1L)
      return(FALSE);

   // make sure file length >= size of compressed file header
   if (cblInSize < (long)cbHdrSize)
      return(FALSE);

   // move to beginning of input file
   if (FSEEK(doshSource, 0L, SEEK_SET) != 0L)
      return(FALSE);

   // put entire compressed file header into rguchBuf[]
   if (FREAD(doshSource, (UCHAR FAR *)rguchBuf, cbHdrSize) != cbHdrSize)
      return(FALSE);

   // put compressed file signature into rguchMagic[] of struct
   for (i = 0; i < cbCompSigLength; i++)
      pFH->rguchMagic[i] = rguchBuf[i];

   // get algorithm label and version id
   pFH->uchAlgorithm = rguchBuf[i++];
   pFH->uchVersion = rguchBuf[i++];

   // extract uncompressed file size, LSB --> MSB (4 bytes in long)
   pFH->cbulUncompSize = 0UL;
   for (j = 0; j < 4; j++)
      pFH->cbulUncompSize |= ((ULONG)(rguchBuf[i + j])) << (8 * j);

   // add compressed file size
   pFH->cbulCompSize = (ULONG)cblInSize;

   return(TRUE);              // file header read ok
}  // GetHdr()



// ChkHdr()
//
// Examines the compressed file signature in the given header info structure
// to see if it matches the real signature.  Returns non-0 if the bytes
// match (compressed file with signature).  Returns 0 if the bytes don't
// match (uncompressed file).
//
int ChkHdr(FH FHIn)           // header info structure to check
{
   int i;
   // storage for FHIn's compressed file signature (used to make it an sz)
   char rgchBuf[cbCompSigLength + 1];

   // copy file info structure's compressed file signature into rgchBuf[] to
   // make it an sz
   for (i = 0; i < cbCompSigLength; i++)
      rgchBuf[i] = FHIn.rguchMagic[i];

   rgchBuf[i] = '\0';

   return(strcmp(rgchBuf, szCompSig) == 0);
}  // ChkHdr()



// InitBuffers()
//
// Allocates far heap space (DOS) or fixed global heap space (Windows) for
// the input, output, and ring buffers.  Initializes working far pointers
// used to manipulate these buffers.  Returns TRUE if there was sufficient
// heap space to allocate the buffers, FALSE if not.  The ring buffer must be
// allocated at the fixed size used during encoding for decoding to proceed
// properly.  However, the input and output buffers hog as much heap space as
// they can get, up to ucbIOBufMax.  ucbIOBufLen is set when the input and
// output buffers are successfully allocated.  n.b., InitBuffers() will try
// to allocate buffer space down to (ucbIOBufMax % ucbIOBufStep).
//
BOOL InitBuffers(void)
{
      // set up ring buffer, n.b., extra cbStrMax - 1 bytes used to
      // facilitate string comparisons near end of ring buffer
      if ((rguchRingBuf = (UCHAR FAR *)FALLOC(cbRingBufMax + cbStrMax - 1))
          == NULL)
         return(FALSE);

      for (ucbIOBufLen = ucbIOBufMax; ucbIOBufLen > 0U;
                                      ucbIOBufLen -= ucbIOBufStep)
      {
         // try to set up input buffer, n.b., extra byte because
         // rguchInBuf[0] holds last byte from previous input buffer
         if ((rguchInBuf = (UCHAR FAR *)FALLOC(ucbIOBufLen + 1U)) == NULL)
            continue;

         // try to set up output buffer
         if ((rguchOutBuf = (UCHAR FAR *)FALLOC(ucbIOBufLen)) == NULL)
         {
            FFREE(rguchInBuf);
            continue;
         }

         // buffers allocated OK, so set up working pointers
         InitBufferPtrs();

         return(TRUE);
      }

      return(FALSE);
}  // InitBuffers()





// LZDecode()
//
// Decompresses input file into output file using LZ algorithm.  Returns
// LZDECODE_OK if everything went alright.  If any errors occurred, returns
// LZERROR_BADINHANDLE, LZERROR_BADOUTHANDLE, LZERROR_READ, or LZERROR_WRITE.
// n.b., LZDecode() starts decoding from the current position of the input
// file pointer.
//
int LZDecode(int doshSource,  // compressed input file to decode
             int doshDest)    // decompressed output file
{
   int i,
       cb,                    // number of bytes to unpack
       f;                     // holds ReadUchar() return values
   int oStart,                // buffer offset for unpacking
       iCurBuf;               // ring buffer offset

   UCHAR uch1, uch2;          // input byte holders
   unsigned ufFlags = 0U;     // holds high order description byte

   bLastUsed = FALSE;

   for (i = 0; i < cbRingBufMax - cbStrMax; i++)
      rguchRingBuf[i] = uchBUF_CLEAR;

   iCurBuf = cbRingBufMax - cbStrMax;

   f = ReadUchar(uch1);
   if (f != (int)uch1)
      return((int)LZERROR_BADINHANDLE);


   FOREVER
   {
      if (f == END_OF_INPUT)        // EOF reached
         break;

      // high order byte counts the number of bits used in the low order byte
      if (((ufFlags >>= 1) & 0x100) == 0)
      {
         // set bit mask describing the next 8 bytes
         ufFlags = ((unsigned)uch1) | 0xff00;
         f = ReadUchar(uch1);
         if (f != (int)uch1)
            return((int)LZERROR_READ);
      }

      if (ufFlags & 1)
      {
         // just store the literal character in the buffer
         if ((f = writeUChar(uch1)) != (int)uch1)
            return(f);

         rguchRingBuf[iCurBuf++] = uch1;
         iCurBuf &= cbRingBufMax - 1;
      }
      else
      {
         // extract the buffer offset and count to unpack
         f = ReadUchar(uch2);
         if (f != (int)uch2)
            return((int)LZERROR_READ);

         cb = (int)uch2;
         oStart = (cb & 0xf0) << 4 | (int)uch1;
         cb = (cb & 0x0f) + cbIndex;

         for (i = 0; i <= cb; i++)
         {
            uch1 = rguchRingBuf[(oStart + i) & (cbRingBufMax - 1)];

            if ((f = writeUChar(uch1)) != (int)uch1)
               return(f);

            rguchRingBuf[iCurBuf++] = uch1;
            iCurBuf &= cbRingBufMax - 1;
         }
      }

      f = ReadUchar(uch1);
   }

   // flush buffer to output file
   // (uchFLUSH isn't actually written to the output file)
   if ((f = WriteOutBuf(uchFLUSH, doshDest)) != (int)uchFLUSH)
      return(f);

   return(LZDECODE_OK);
}  // LZDecode()

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\expand.h ===
/*
** expand.h -	 housekeeping for DOS Lempel-Ziv command-line decompression
**              modules
**
**              Copyright (c) 1989-1991 Microsoft Corporation
**              Microsoft Confidential
**              All Rights Reserved.
*/


#include "doslzexp.h"


// Constants
/////////////
#define EXIT_SUCCESS    0              // main() return codes
#define EXIT_FAILURE    1

#define WRITEHDR_OK     503            // WriteHdr() successful return value
#define LZENCODE_OK     504            // LZEncode() successful return value

#define CHAR_MASK       0xffL          // used to cast long's to char's in
                                       // file I/O

#define chPATH_SEP      '\\'

#define NO_DOSH         (-20)          // output DOS file handle used as flag
                                       // to prevent writing output to disk

#define NIL             cbRingBufMax   // index for root of binary search
                                       // trees

#define FILE_SIZE_BREAK 100000L        // boundary between 'small' files and
                                       // 'big' files for status display

// % steps between "% done" status displays
#define BIG_FILE_STEP   1           // uncompressed size >  FILE_SIZE_BREAK
#define SMALL_FILE_STEP 5           // uncompressed size <= FILE_SIZE_BREAK

#define pszTEMP_FILE_PREFIX   "DD"

/* Begin M001 */
#define	NO_ERROR 0
#define	OK  0
#define	EOL  '\0'
#define	CHAR_PERIOD '.'
#define	CHAR_UNDERSCORE '_'
#define  CHAR_EOF 0x1A
#define  CHAR_ESC 0x1B
#define  CHAR_ABORT CHAR_ESC
#define	ABORT -1
#define	MAX_ROW_LEN 80

/* File Information structure from \INC\FIND.INC.	This should be
 * the same as structure find_t, except that here we show the structure
 * of the reserved members.
 */
struct FIND_BUF
{
	char		FIND_BUF_DRIVE;			/* drive of search */
	char		FIND_BUF_NAME[11];		/* formatted name */
	char		FIND_BUF_SATTR;			/* attribute of search */
	unsigned	FIND_BUF_LASTENT;			/* LastEnt */
	unsigned FIND_BUF_DIRSTART;		/* DirStart */
	char		FIND_BUF_NETID[4];		/* Reserved for NET */
	char		FIND_BUF_ATTR;				/* attribute found */
	unsigned	FIND_BUF_TIME;				/* time */
	unsigned	FIND_BUF_DATE;				/* date */
	unsigned FIND_BUF_SIZE_L;			/* low(size) */
	unsigned FIND_BUF_SIZE_H;			/* high(size) */
	char		FIND_BUF_PNAME[13];		/* packed name */
};
/* End M001 */

// command-line directives:
// The directives should be single characters.  They appear in the
// instructions as defined here, but may be entered in upper or lower case on
// the command line.
#define chENCODE_TO_DIFFERENT_FILE    'e'
#define chDECODE_TO_DIFFERENT_FILE    'd'
#define chENCODE_IN_PLACE             'c'
#define chDECODE_IN_PLACE             'b'
#define chCOPY_STAMP                  's'
#define chQUERY_SAVINGS               'q'


// Macros
//////////
//  IPG - Made PrintInstructions() into two Macros because INTL strings too long
#define PrintInstructions1()           printf(pszHELP_TEXT1);\
                                       printf(pszHELP_TEXT2)
#define PrintInstructions2()           printf(pszHELP_TEXT3);\
                                       printf(pszHELP_TEXT4)

#define PrintBanner()                  printf(pszBANNER_TEXT)


#include "expand.pro"
#include "dosdir.pro"

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\ioctl.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1988-1991
;   Microsoft Confidential
;   All Rights Reserved.
;
;   Title:	smartdrv.inc - smartdrv equates & structures
;
;   Version:	1.00
;
;   Date:	15-Sep-1989
;
;   Author:	ARR
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   15-Sep-1989 ARR Original
;   30-Oct-1989 MC  Borrowed from AAR for use in win.com. Pared down to only
;                   SD_IOCTL_Read because thats all I need. I need only look
;                   at the size of SD. I do not have to shrink it.
;   11-Dec-1989 MC  Add needed struc's and support for talking to LIM drivers
;
;==============================================================================
;
;
; Device name of SMARTDRV
;
SD_DEV_NAME	equ	"SMARTAAR",0    ; Name for SD driver IOCTL opens.
EMM_DEV_NAME    equ     "EMMXXXX0",0    ; Name for EMM driver IOCTL opens.
;
;
; Structure of the data returned on the SMARTDRV IOCTL read call
;

SD_IOCTL_Read	struc

    SD_IR_Write_Through   db	?   ; Write-through flag, currently always 1
    SD_IR_Write_Buff	  db	?   ; Buffer write flag, currently always 0
    SD_IR_Enable_Int13	  db	?   ; Cache enable flag, 1 = enabled
    SD_IR_Driver_Type     db	?   ; Type 1 (XMS cache) or 2 (EMS cache)
    SD_IR_Tick_Setting	  dw	?   ; Ticks between flushes, currently unused
    SD_IR_Lock_Cache	  db	?   ; Non-zero if cache is locked
    SD_IR_Reboot_Flush	  db	?   ; Non-zero if cache should be flushed on reboot
    SD_IR_Cache_All	  db	?   ; Zero if full track writes are not cached
    SD_IR_Double_Buffer   db	?   ; Dbl buff state 0=Off, 1=On, 2=Dynamic
    SD_IR_Original_INT13  dd	?   ; INT 13 address SMARTDRV hooked
    SD_IR_Minor_Ver	  db	?   ; Minor version number
    SD_IR_Major_Ver	  db	?   ; Major version number
			  dw	?   ; Unused
                    ; Next three values are used for computing
                    ; cache statistics.  They may be scaled rather
                    ; than absolute values
    SD_IR_Total_Sec_Read  dw	?   ; Count of sectors read
    SD_IR_Cache_Sec_Read  dw	?   ; Count of sectors read from cache
    SD_IR_Track_Sec_Read  dw	?   ; Count of sectors read from track buffer
                    ; Cache statistics
    SD_IR_Cache_Hit_Ratio db	?   ; = Cache_Sec_Read * 100 / Total_Sec_Read
    SD_IR_Track_Hit_Ratio db	?   ; = Track_Sec_Read * 100 / Total_Sec_Read

    SD_IR_Total_Tracks	  dw	?   ; Number of tracks in the cache
    SD_IR_Total_Used	  dw	?   ; Tracks currently in use
    SD_IR_Total_Locked	  dw	?   ; Tracks currently locked
    SD_IR_Total_Dirty	  dw	?   ; Tracks currently dirty
                    ; Information for resizing cache
                    ; All values are in terms of 16Kb pages.
    SD_IR_Current_Size	  dw	?   ; Current size of the cache, in 16Kb pages
    SD_IR_Dev_Size	  dw	?   ; Original size requested by user
    SD_IR_Min_Cache_Size  dw	?   ; Minimum allowable size

SD_IOCTL_Read	ends

SMRTDRVInfo	SD_IOCTL_Read  <>

;
; Structure of the data returned on the IOCTL call to the EMM driver
;
EMM_Import_IOCTL_Data	struc

    EMM_Import_Data_Phys_Ptr	dd	?   ; PHYSICAL 32 bit address of the
					    ;	EMM_Import_Data structure
    EMM_Import_API_Version_Maj	db	?   ; API version #
    EMM_Import_API_Version_Min	db	?

EMM_Import_IOCTL_Data	ends

;
; For the IOCTL to get the data and version number of importable EMM info
;   the IOCTL read subfunction is encoded in the first byte of the IOCTL
;   read buffer.
;
EMM_IMPRT_IOCTL_FUNC	equ	1

EMM_OK	                equ	0
;
; Current version number restriction of WIN386 on EMM_Import_API_Version
;
EMM_IMPORT_MIN_VER	equ	0100h
EMM_IMPORT_MAX_VER	equ	0100h

EMMIoctlBuf	db	EMM_IMPRT_IOCTL_FUNC
		db	(SIZE EMM_Import_IOCTL_Data) dup (0)

SMRTDRVName	db SD_DEV_NAME     ; Name for smartdrv IOCTL opens.
EMM_Name        db EMM_DEV_NAME    ; Name for EMM IOCTL opens.


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\expand.c ===
/*          Data Decompression Program
            written by Steve Zeck and David Dickman

            Copyright (c) 1989-1991 by Microsoft Corporation
            Microsoft Confidential
            All Rights Reserved.

   This program will decompress files using the Lempel-Zev compress algorithm.
   A header is prepended to the file being compressed which contains a
   signature block and other information, like the size of the uncompressed
   file.  Other compression algorithms may be added fairly easily.  The
   compressed file header contains tags for the algorithm used in compression
   and the version of the program which compressed the file.  The last file
   modification date is preserved through compression and decompression.

   Fragmented Compression:
   ----------------------

   Compression of files which, even when compressed, occupy more than one
   floppy disk is handled in a primitive way.  Once compress runs out of disk
   space during a write, it asks for a new disk, and continues compression
   into a file of the same output name on the new disk.  Decompressing a
   fragmented output file takes more work.  The compressed output files must
   be appended together in their output order before decompressing the
   resulting unfragmented compressed file.  Of course, this requires a hard
   disk or some medium with sufficient space to hold the unfragmented
   compressed file.

   For example, suppose a large program called "bogusxl.exe" still occupies
   900Kb even when compressed.  It is to be shipped on 360Kb floppy disks.
   Working from a directory containing the original version of bogusxl.exe on
   drive c, bogusxl.exe might be compressed into bogusxl.out with the
   following command line:

   C:>compress e bogusxl.exe bogusxl.out

   compress will try to fit as much of the compressed data on each diskette
   as possible.  Assuming compress is handed empty 360Kb formatted floppy
   disks, bogusxl.out will be split into three fragments: 360Kb on disk 1,
   360Kb on disk 2, and 180Kb on disk 3 (in order).  The compressed data file
   on each disk is named bogusxl.out.  You might want to rename the files on
   the floppy disks.  e.g., bogusxl.1 on disk 1, bogusxl.2 on disk 2, and
   bogusxl.3 on disk 3.  Now we need to create an unfragmented version (e.g.,
   on hard drive c: on the purchaser's pc).

   <working from the target directory on c:>
   <insert disk 1 in drive a:>
   C:>copy a:bogusxl.1 c:

   <insert disk 2 in drive a:>
   C:>copy a:bogusxl.2 c:

   <insert disk 3 in drive a:>
   C:>copy a:bogusxl.3 c:

   Now to stitch together the three fragments in order.

   C:>copy bogusxl.1 /b + bogusxl.2 /b + bogusxl.3 /b bogusxl.out

   However, the date and time stamp of bogusxl.out no longer matches that of
   the original version of bogusxl.exe.  To fix this, use the 's' (set time
   and date) option of compress to copy bogusxl.1's stamp to bogusxl.out:

   C:>compress s bogusxl.1 bogusxl.out

   Now bogusxl.out is an unfragmented compressed version of bogusxl.exe, so
   it just needs to be decompressed.

   C:>compress d bogusxl.out bogusxl.exe

   And we can get rid of the compressed files...

   C:>del bogusxl.1
   C:>del bogusxl.2
   C:>del bogusxl.3
   C:>del bogusxl.out

   So now an uncompressed copy of bogusxl.exe with matching date and time
   stamp is on the user's hard drive.

   (A future version of compress may try to mitigate this multi-file
   rigamarole.)

****************************************************************************/
/*
   Notes:
   -----

   Fragmented compression needs to be tidied up.  e.g., a fragment number
   (UCHAR) could be added to the compressed file header to help automate
   fragmented decompression.  The 's' command line option is an especially
   klugey example of the messy fragmented compression handling.
*/

/* History:
 *
 * 08/07/91	M001	Added the following functionality:
 *						1) Do not allow source file to overwrite itself.
 *						2) If source file cannot be found, try file name with 3rd
 *							character of extension set = '_'.
 *						3) Display status messages as each file is expanded (like
 *							COPY, but display status even if just expanding 1 file):
 *								A:\EGA.SY_ -> C:\DOS\EGA.SYS
 *							Each message will appear on a new line, so if multiple
 *							files are expanded, the screen will scroll.
 *						4) Number of input parameters:
 *							a) = 0: Prompt for source file and destination file/path
 *							b) = 1: Prompt for destination file/path
 *							c) = 2:	Source must be file name
 *										Destination can be file name or existing
 *										 directory name (path)
 *							d) > 2:	First parameters (sources) must be file names
 *										Last parameter (destination) must be existing
 *										directory name (path)
 *						5) Destination file name:
 *							a) Can be explicitly specified when only 1 file is
 *								being expanded.
 *							b) When no destination file name is specified, the
 *								source file name is used as specified on command-line
 *								(i.e. if "EXPAND A:\EGA.SYS  C:\DOS" finds A:\EGA.SY_,
 *								it will display the status message
 *								"A:\EGA.SY_ -> C:\DOS\EGA.SYS"
 *								and create the file C:\DOS\EGA.SYS).
 *
 * 11/09/89	CC		Copied from compress.c and isolated
 *						expand features.	Retained former features since we
 *						may want them later (see #ifdef OLD's).
 */



// Headers
///////////
#include <stdio.h>
#include <stdlib.h>				/* M001 */
#include <string.h>
#include <ctype.h>
#include <conio.h>
#include <io.h>
#include <dos.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>

#include "expand.h"
#include "expmsgs.h"

#include <decomp.h>

// M001: Local Prototypes
//////////////////////////

static unsigned fnFileCopy(int fhDst,int fhSrc);
static BOOL PromptUser(int, char **);
static int Quit(int);
static int ProcessInput(int, char **);
static int GetString(char *, int);
static int GetSourceHandle(char *);
static BOOL IsSourceDest(char *, char *);

// Globals
///////////
static long cblInSize,                 // size in bytes of original file
            cblOutSize = 0L;           // size in bytes of output file

static int iCurMatch,                  // index and length of longest match
           cbCurMatch;                 // (set by LZInsertNode())

static int leftChild[cbRingBufMax + 1],    // left, right children and parents
           rightChild[cbRingBufMax + 257], // (these arrays make up the binary
           parent[cbRingBufMax + 1];       // search trees)

static char *pszInFile,                  // names of input and output files
            *pszOutFile;

static UCHAR uchAlgorithm,                // algorithm label
             uchVersion;                  // version id

static int doshIn,                     // input and output DOS file handles
           doshOut;

static int wOriginalDrive;

static int iFiles;					/* M001: # of files successfully expanded */


// DOS file handles are used for file references in this module since using
// FILE *'s for file references poses a problem.  fclose()'ing a file which
// was fopen()'ed in write "w" or append "a" mode stamps the file with the
// current date.  This undoes the effect of copyCreateDate().  Could also get
// around this fclose() problem by first fclose()'ing the file, and
// fopen()'ing it again in read "r" mode.
//
// Using file handles also allows us to bypass stream buffering, so read's
// and write's may be done with whatever buffer size is desired.  Also, the
// lower-level DOS file handle functions are faster than their stream
// counterparts.


#ifdef DBCS
/*
	Test if the character is DBCS lead byte

	input:	c = character to test
	output:	TRUE if leadbyte
*/

int	IsDBCSLeadByte(c)
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;

	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;

	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;		/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return FALSE;
}

/*
	Check if the character point is at tail byte

	input:	*str = strart pointer of the string
		*point = character pointer to check
	output:	TRUE if at the tail byte
*/

int	CheckDBCSTailByte(str,point)
unsigned char *str,*point;
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif


BOOL HelpSwitchPresent(int argc, char *argv[])
{
   int i;

	for (i = 1; i < argc; i++)
      if (strcmp(argv[i], pszHELP_SWITCH) == 0)
         return(TRUE);

   return(FALSE);
} // HelpSwitchPresent()



void CatPathAndFileName(char *pszPath, char *pszFileName)
{
   if (*pszFileName != '\0')
   {
#ifdef DBCS
      if ((! SLASH(pszPath[strlen(pszPath) - 1]) &&
          (pszPath[strlen(pszPath) - 1]) != ':') ||
          CheckDBCSTailByte(pszPath,&pszPath[strlen(pszPath) - 1]))
#else
      if (! SLASH(pszPath[strlen(pszPath) - 1]) &&
          (pszPath[strlen(pszPath) - 1]) != ':')
#endif
         strcat(pszPath, CHSEPSTR);

      strcat(pszPath, pszFileName);
   }
} // CatPathAndFileName()



char *ExtractFileName(char *pszPath)
{
   char *psz;

   for (psz = pszPath; *psz != '\0'; psz++)
      ;

#ifdef DBCS
   for ( ; psz >= pszPath && ((! SLASH(*psz) && *psz != ':') ||
   		CheckDBCSTailByte(pszPath,psz)) ; psz--)
#else
   for ( ; psz >= pszPath && ! SLASH(*psz) && *psz != ':'; psz--)
#endif
      ;

   return(++psz);
} // ExtractFileName()


char ExtractDrive(char *pszFileName)
{
   return(pszFileName[1] == ':' ?
          pszFileName[0] :
          (char)('a' + wOriginalDrive));
}



// WriteOutBuf()
//
// Dumps output buffer to output (compressed) file.  Prompts for new floppy
// disk if old one if full.  Continues dumping to output file of same name on
// new floppy disk.  The only error codes it may return are
// LZERROR_BADINHANDLE and LZERROR_BADOUTHANDLE (from copyCreateDate()).
//
int WriteOutBuf(UCHAR uch,    // first character to be added to the empty
                              // buffer after the full buffer is written
                int doshDest) // output file handle
{
   unsigned ucbToWrite,       // number of bytes to write from buffer
            ucbWritten,       // number of bytes actually written
            ucbTotWritten;    // total number of bytes written to output
   char chDrive;
   int f;                     // holds copyCreateDate() return value

   // how much of the buffer should be written to the output file?
   ucbTotWritten = ucbToWrite = (unsigned)(puchOutBuf - rguchOutBuf);
   // reset pointer to beginning of buffer
   puchOutBuf = rguchOutBuf;

   // do not write to an output file if given the 'q' command line option
   if (doshDest == NO_DOSH)
   {
      cblOutSize += (long)ucbTotWritten;
      return((int)uch);
   }

   while ((ucbWritten = FWRITE(doshDest, puchOutBuf, ucbToWrite)) != ucbToWrite)
   {
      // ran out of disk space
      if (DosRemoveable(chDrive = ExtractDrive(pszOutFile)))
         do
         {
            // shut down the old output file
            if ((f = CopyCreateDate(doshIn, doshDest)) != COPYCREATEDATE_OK)
               return(f);
            FCLOSE(doshDest);
            printf(pszINSERT_NEW_DISK, chDrive);
            getchar();
         // open a new output file of the same name
         } while ((doshDest = FCREATE(pszOutFile)) == -1);
      else
      {
         // shut down the old output file
         FCLOSE(doshIn);
         FCLOSE(doshDest);
         if (remove(pszOutFile))
            printf(pszNO_DELETE_OLD, pszOutFile);
         printf(pszNOT_ENOUGH_DISK, chDrive);
         return(LZERROR_WRITE);
      }

      // check to see if some buffer data remains to be written
      if (ucbWritten > 0
          && _error == 0U)
      {
         // account for partial writes
         ucbToWrite -= ucbWritten;
         puchOutBuf += ucbWritten;
      }
   }

   cblOutSize += (long)ucbTotWritten;

   // add the next character to the buffer
   return((int)(*puchOutBuf++ = uch));
}  // WriteOutBuf()



// WriteHdr()
//
// Writes compressed file header to output file.  Could add fragment number
// to write in header as argument to WriteHdr().  The only error codes that
// may be returned are LZERROR_BADINHANDLE and LZERROR_BADOUTHANDLE.
//
// header format:
//                8 bytes  -->   compressed file signature
//                1 byte   -->   algorithm label
//                1 byte   -->   version id
//                4 bytes  -->   uncompressed file size (LSB to MSB)
//
//       total = 14 bytes
//
int WriteHdr(int doshDest)    // output file handle
{
   int i,
       f;            // writeUChar return value
   UCHAR uch;        // temporary storage for next header byte to write

   // move to beginning of output file
   if (doshDest != NO_DOSH && FSEEK(doshDest, 0L, SEEK_SET) != 0L)
      return((int)LZERROR_BADOUTHANDLE);

   // write the compressed file signature
   for (i = 0; i < cbCompSigLength; i++)
   {
      uch = (UCHAR)(*(szCompSig + i));
      if ((f = writeUChar(uch)) != (int)(uch))
         return(f);
   }

   // write out algorithm label and version number
   if ((f = writeUChar(uchAlgorithm)) != (int)uchAlgorithm)
      return(f);
   if ((f = writeUChar(uchVersion)) != (int)uchVersion)
      return(f);

   // write out input file size (long ==> 4 bytes)
   // LSB first, MSB last
   uch = (UCHAR)(cblInSize & CHAR_MASK);              // LSB
   if ((f = writeUChar(uch)) != (int)uch)
      return(f);
   uch = (UCHAR)((cblInSize >> 8) & CHAR_MASK);
   if ((f = writeUChar(uch)) != (int)uch)
      return(f);
   uch = (UCHAR)((cblInSize >> 16) & CHAR_MASK);
   if ((f = writeUChar(uch)) != (int)uch)
      return(f);
   uch = (UCHAR)((cblInSize >> 24) & CHAR_MASK);      // MSB
   if ((f = writeUChar(uch)) != (int)uch)
      return(f);

   return(WRITEHDR_OK);
}  // WriteHdr()



// LZInitTree
//
// Initializes trees for LZ compression.
//
void LZInitTree(void)
{
   int i;

/* For i = 0 to cbRingBufMax - 1, rightChild[i] and leftChild[i] will be the
   right and left children of node i.  These nodes need not be initialized.
   Also, parent[i] is the parent of node i.  These are initialized to
   NIL (= N), which stands for 'not used.'
   For i = 0 to 255, rightChild[cbRingBufMax + i + 1] is the root of the tree
   for strings that begin with character i.  These are initialized to NIL.
   n.b., there are 256 trees.
*/

   for (i = cbRingBufMax + 1; i <= cbRingBufMax + 256; i++)
      rightChild[i] = NIL;

   for (i = 0; i < cbRingBufMax; i++)
      parent[i] = NIL;

   return;
}  // LZInitTree()



// LZInsertNode()
//
// Inserts string of length cbStrMax, rguchRingBuf[r..r + cbStrMax - 1], into one of
// the trees (rguchRingBuf[r]'th tree) and returns the longest-match position
// and length via the global variables iCurMatch and cbCurMatch.  If
// cbCurMatch == cbStrMax, removes the old node in favor of the new one,
// since the old one will be deleted sooner.  n.b., r plays a double role, as
// both tree node and position in buffer.
//
void LZInsertNode(int r)      // node to insert
{
   int  i, p, cmp;
   UCHAR FAR *key;

   cmp = 1;
   key = &rguchRingBuf[r];
   p = cbRingBufMax + 1 + key[0];

   rightChild[r] = leftChild[r] = NIL;
   cbCurMatch = 0;

   FOREVER
   {
      if (cmp >= 0)
      {
         if (rightChild[p] != NIL)
            p = rightChild[p];
         else
         {
            rightChild[p] = r;
            parent[r] = p;
            return;
         }
      }
      else
      {
         if (leftChild[p] != NIL)
            p = leftChild[p];
         else
         {
            leftChild[p] = r;
            parent[r] = p;
            return;
         }
      }

      for (i = 1; i < cbStrMax; i++)
         if ((cmp = key[i] - rguchRingBuf[p + i]) != 0)
            break;

      if (i > cbCurMatch)
      {
         iCurMatch = p;
         if ((cbCurMatch = i) >= cbStrMax)
            break;
      }
   }

   parent[r] = parent[p];
   leftChild[r] = leftChild[p];
   rightChild[r] = rightChild[p];

   parent[leftChild[p]] = r;
   parent[rightChild[p]] = r;

   if (rightChild[parent[p]] == p)
      rightChild[parent[p]] = r;
   else
      leftChild[parent[p]] = r;

   parent[p] = NIL;        // remove p
   return;
}  // LZInsertNode()



// LZDeleteNode()
//
// Deletes node p from tree.
//
void LZDeleteNode(int p)      // node to delete
{
   int  q;

   if (parent[p] == NIL)
      // node p is not in the tree
      return;

   if (rightChild[p] == NIL)
      q = leftChild[p];
   else if (leftChild[p] == NIL)
      q = rightChild[p];
   else
   {
      q = leftChild[p];
      if (rightChild[q] != NIL)
      {
         do
         {
            q = rightChild[q];
         } while (rightChild[q] != NIL);

         rightChild[parent[q]] = leftChild[q];
         parent[leftChild[q]] = parent[q];
         leftChild[q] = leftChild[p];
         parent[leftChild[p]] = q;
      }
      rightChild[q] = rightChild[p];
      parent[rightChild[p]] = q;
   }
   parent[q] = parent[p];

   if (rightChild[parent[p]] == p)
      rightChild[parent[p]] = q;
   else
      leftChild[parent[p]] = q;

   parent[p] = NIL;        // remove p
   return;
}  // LZDeleteNode()


/* int GetSourceHandle(char *pszSource)
 *
 * Get Source file handle.
 *
 * ENTRY:	pszSource -> Source filename
 *
 * EXIT: 	returns file handle; file handle = -1 if source file not found.
 *
 * NOTES:	If the pszSource filename can't be found, we try an alternate
 *				filename by substituting the '_' for the 3rd character of the
 *				pszSource filename extension.
 *
 * HISTORY: M001	Created.
 *
 */

int GetSourceHandle(char *pszSource)
{
	int  i;
	int  doshSrc;								/* Source file handle */
	char szAltSource[MAXFILESPECLEN];	/* Alternate source file name */

	if ( (doshSrc = FOPEN(pszSource)) != -1 )
		return(doshSrc);
	else
	{
		if( (i = strlen(pszSource)) > (MAXFILESPECLEN - 1) ||
			 i < 5 ||
			 pszSource[i-4] != CHAR_PERIOD )
		{
			return(doshSrc);
		}
		else
			strcpy(szAltSource, pszSource);

		/* Change 3rd character of extension to '_' */

		szAltSource[i-1] = CHAR_UNDERSCORE;

		if( (doshSrc = FOPEN(szAltSource)) == -1 )
			return(doshSrc);
		else
		{
			/* Alternate filename found, so reflect change in pszSource. */

			pszSource[i-1] = CHAR_UNDERSCORE;
			return(doshSrc);
		}
	}
}



BOOL GetIOHandles(char *pszSource,char *pszDest,int *pdoshSource,int *pdoshDest)
{
	if (pszSource != NULL)
	{
		/* M001: Find and open source file */
		if ((*pdoshSource = GetSourceHandle(pszSource)) == -1)
		{
			printf(pszNO_OPEN_INPUT, pszSource);
			return(FALSE);
		}

      // Move to the end of the input file to find its length,
      // then return to the beginning.
      if ((cblInSize = FSEEK(*pdoshSource, 0L, SEEK_END)) < 0L ||
          FSEEK(*pdoshSource, 0L, SEEK_SET) != 0L)
      {
         FCLOSE(*pdoshSource);
         printf(pszNO_READ_INPUT, pszSource);
         return(FALSE);
      }
   }
   else
      *pdoshSource = -1;

   // Set up output DOS file handle.
   if (pszDest != NULL)
	{

		/* M001: Verify that source and destination files are not the same file.
		 * Must do this BEFORE creating destination file, since if source
		 * == dest., the dest. create operation will truncate source file to
		 * zero length.
		 */
		if( IsSourceDest(pszSource, pszDest) )
		{
			printf(pszSOURCE_IS_DEST, pszSource);
			return(FALSE);
		}

      if ((*pdoshDest = FCREATE(pszDest)) == -1)
      {
         FCLOSE(*pdoshSource);
         printf(pszNO_OPEN_OUTPUT, pszDest);
         return(FALSE);
      }
   }
   else
      *pdoshDest = -1;

   return(TRUE);
} // GetIOHandles()


/* BOOL Decompress( char *pszSource, char *pszDest );
 *
 * Decompress source to destination.
 *
 * ENTRY: pszSource -> Source pathname
 * 		 pszDest   -> Destination pathname
 *
 * EXIT: TRUE if successful; FALSE otherwise.
 *
 * HISTORY: M001	Added progress messages.
 *
 */

BOOL Decompress(char *pszSource,
                char *pszDest)
{
   int doshSource,      // input file handle
		 doshDest,			// output file handle
		 fAppsComp, 		// 'apps' compression
		 f;
   FH FHIn;             // structure holding header information from
                        // compressed input file (used for decoding)
	long lWritten;

   // Set up source and dest file handles.

   if (! GetIOHandles(pszSource, pszDest, &doshSource, &doshDest))
      return(FALSE);

	// Determine if file was compressed using one of the special applications
	// division methods.

	fAppsComp = WReadHeaderInfo(doshSource) > 0;

   // make sure source file is in compressed format
   // make sure file shows Lempel-Ziv algorithm indicator

	if (! fAppsComp &&
		(! GetHdr(&FHIn, doshSource) || ! ChkHdr(FHIn) ||
		 (FHIn.uchAlgorithm != uchALG_LEMPEL_ZIV)))
   {
      BOOL rc = FALSE;

		printf(pszINPUT_NOT_COMPRESSED_FMT, pszSource); 		/* M001 */

		/* seek to beginning of file because of header read */
		if ( FSEEK(doshSource, 0L, SEEK_SET) == 0L )
		{
			/* M001: Display progress message. */
			printf( pszPROGRESS, strupr(pszSource), strupr(pszDest) );

			/* Copy file */
			rc = (BOOL) fnFileCopy(doshDest,doshSource);
		}
      FCLOSE(doshDest);
      FCLOSE(doshSource);

		if( rc == TRUE )
			iFiles++;		/* M001: Update file count */

      return(rc);
   }

   // set up globals for reading and writing
   pszInFile = pszSource;
   pszOutFile = pszDest;
   doshIn = doshSource;
   doshOut = doshDest;

	// compressed header found, so decompress file

	/* M001: Display progress message. */
	printf( pszPROGRESS, strupr(pszSource), strupr(pszDest) );

	if (fAppsComp)
	{
		f = LZDECODE_OK;
		lWritten = LcbDecompressToFile( doshSource, doshDest, LCBNIL, 0L, TRUE );
		if (lWritten < 0L)
			if (lWritten == rcWriteError)
				f = LZERROR_BADOUTHANDLE;
			else if (lWritten == rcReadError)
				f = LZERROR_BADINHANDLE;
			else
				f = LZERROR_READ;
	}

	if (!fAppsComp)
		f = LZDecode(doshSource, doshDest);

	if (f != LZDECODE_OK)
   {
      if (f == LZERROR_BADINHANDLE)
         printf(pszNO_READ_INPUT, pszSource);
      else if (f == LZERROR_BADOUTHANDLE)
         printf(pszNO_WRITE_OUTPUT, pszDest);
      else if (f == LZERROR_READ)
         printf(pszFORMAT_ERROR, pszSource);
      else  // (f == LZERROR_WRITE), actually this case will never occur
            // since the multi-disk version of writeOutBuf() can only
            // return LZERROR_BADINHANDLE or LZERROR_BADOUTHANDLE as error
            // conditions
         printf(pszOUT_OF_SPACE, pszDest);

      FCLOSE(doshSource);
      FCLOSE(doshDest);
      return(EXIT_FAILURE);
	}

	/* M001: At this point, source file has been expanded to destination, so
	 * update file count.
	 */
	iFiles++;

   f = CopyCreateDate(doshSource, doshDest);

   if (doshDest != NO_DOSH && f != COPYCREATEDATE_OK)
   {
      printf(pszNO_COPY_TIME);
      if (f == LZERROR_BADINHANDLE)
         printf(pszFROM_INPUT, pszSource);
      else  // (f == LZERROR_BADOUTHANDLE)
         printf(pszTO_OUTPUT, pszDest);

      FCLOSE(doshSource);
      FCLOSE(doshDest);
      return(FALSE);
   }

   FCLOSE(doshSource);
   FCLOSE(doshDest);
   return(TRUE);
} // Decompress()


/* unsigned fnFileCopy(int doshDest, int doshSource);
 *
 * Function copies files given a source and destination file handle.
 * will preserve source file date and time.
 *
 * ENTRY: doshDest   - destination file handle.
 *
 *        doshSource - Source file handle.
 *
 * EXIT: unsigned as to success or failure of file copy function.
 *
 *       Zero == Success.    Non Zero == Failure.
 *
 */
unsigned fnFileCopy(fhDst,fhSrc)
int    fhDst;
int    fhSrc;
{
   LPSTR       lpBuf = NULL;             /* copy buffer pointer */
   unsigned    size;
   unsigned    date;
   unsigned    time;
   int         f = 0;

   _dos_getftime(fhSrc,&date,&time);
   lpBuf = FALLOC(4096*sizeof(char));  // 4kb on far heap for a copy buffer.
   if (! lpBuf )
      return(FALSE);

   while (size = FREAD(fhSrc,lpBuf,4096)) {
      if (FWRITE(fhDst,lpBuf,size) != size) {
         /* write error? */
         f = FERROR();
	      if (f == ERROR_OK)
            f = ERROR_WRITE;
         break;
      }
   }
   FFREE(lpBuf);
   if (! f )
   {
      _dos_setftime(fhDst,date,time);
      f = TRUE;
   }
   return f;
}


/* BOOL IsSourceDest( char *pszSource, char *pszDest );
 *
 * Checks if source and destination files are the same file.
 *
 * ENTRY:	pszSource -> source filename
 * 			pszDest	 -> destination filename
 *
 * EXIT: 	TRUE if files are the same; FALSE otherwise.
 *
 * NOTES:	If DOS version >= 3.1, we use the DOS Truename function.	Else,
 * 			we do a DosFindFirst() and compare the reserved fields in the
 * 			returned FIND_BUF structure.	(Versions of DOS prior to 3.1 did
 * 			not support networks, so we can be fairly certain that the
 * 			reserved fields will be consistent.)
 *
 * 			If we experience an error during this function, we skip the
 * 			verification test and exit FALSE, as if the files were different.
 *
 * HISTORY: M001	Created.
 *
 */

BOOL IsSourceDest( char *pszSource, char *pszDest )
{
	int i;
	union REGS inregs, outregs;
	struct SREGS segregs;
	char szSrcAbs[MAXFILESPECLEN];		/* Absolute source pathname */
	char szDestAbs[MAXFILESPECLEN];		/* Absolute dest. pathname */
	struct find_t SrcFileInfo; 			/* Source file information buffer */
	struct find_t DestFileInfo;			/* Dest. file information buffer */
#ifdef DEBUG
	struct FIND_BUF * s;
#endif

	/* For DOS versions >= 3.1, use DOS Truename function */

	if( _osmajor > 3 || (_osmajor == 3 && _osminor >= 1) )
	{
		/* Get segment register values, and ensure they are the same (for safety:
		 * they should be the same since this is SMALL model).
		 */
		segread( &segregs );
		if( segregs.ds != segregs.es || segregs.ds != segregs.ss )
			return(FALSE);		/* Skip test */

		/* Get absolute source pathname */
		inregs.h.ah = 0x60;								/* DOS Truename function */
		inregs.x.si = (unsigned) pszSource;			/* Relative source path */
		inregs.x.di = (unsigned) szSrcAbs;			/* Buffer */
		intdosx( &inregs, &outregs, &segregs );
		if( outregs.x.cflag != 0 )
			return(FALSE); 	/* Skip test */

		/* Get absolute destination pathname */
		inregs.h.ah = 0x60;								/* DOS Truename function */
		inregs.x.si = (unsigned) pszDest;			/* Relative dest path */
		inregs.x.di = (unsigned) szDestAbs;			/* Buffer */
		intdosx( &inregs, &outregs, &segregs );
		if( outregs.x.cflag != 0 )
			return(FALSE); 	/* Skip test */

#ifdef DEBUG
		printf("Source = %s, Dest = %s\n", szSrcAbs, szDestAbs);
#endif

		if( strcmpi(szSrcAbs, szDestAbs) == 0 )
			return(TRUE);		/* Source == Destination */
	}
	else			/* DOS version >= 2.1 */
	if( (_osmajor == 3 && _osminor == 0) || (_osmajor == 2 && _osminor >= 1) )
	{
		/* Use _dos_findfirst(); compare file information structures. */

		/* Clear File Information Buffers */

		memset(&SrcFileInfo,  0, sizeof(struct find_t));
		memset(&DestFileInfo, 0, sizeof(struct find_t));

		/* Source file */
		if( _dos_findfirst(pszSource, _A_NORMAL, &SrcFileInfo) != 0 )
			return(FALSE); 	/* Skip test */

		/* Dest. file */
		if( _dos_findfirst(pszDest, _A_NORMAL, &DestFileInfo) != 0 )
			return(FALSE); 	/* Skip test */

#ifdef DEBUG
		s = (struct FIND_BUF *) &SrcFileInfo;
		printf(	"Source:  Drive=0x%hx  Name=%.11s  SAttr=0x%hx\n" \
					"LastEnt=0x%hx  DirStart=0x%hx  NetId=%.4s  Attr=0x%hx\n" \
					"Time=0x%hx  Date=0x%hx  Size=0x%lx  Name=%s\n\n",
					s->FIND_BUF_DRIVE,			/* drive of search */
					s->FIND_BUF_NAME,				/* formatted name */
					s->FIND_BUF_SATTR,			/* attribute of search */
					s->FIND_BUF_LASTENT,			/* LastEnt */
					s->FIND_BUF_DIRSTART,		/* DirStart */
					s->FIND_BUF_NETID,			/* Reserved for NET */
					SrcFileInfo.attrib,			/* attribute found */
					SrcFileInfo.wr_time,			/* time */
					SrcFileInfo.wr_date,			/* date */
					SrcFileInfo.size, 			/* size */
					SrcFileInfo.name );			/* packed name */
		s = (struct FIND_BUF *) &DestFileInfo;
		printf(	"Dest:    Drive=0x%hx  Name=%.11s  SAttr=0x%hx\n" \
					"LastEnt=0x%hx  DirStart=0x%hx  NetId=%.4s  Attr=0x%hx\n" \
					"Time=0x%hx  Date=0x%hx  Size=0x%lx  Name=%s\n\n",
					s->FIND_BUF_DRIVE,			/* drive of search */
					s->FIND_BUF_NAME,				/* formatted name */
					s->FIND_BUF_SATTR,			/* attribute of search */
					s->FIND_BUF_LASTENT,			/* LastEnt */
					s->FIND_BUF_DIRSTART,		/* DirStart */
					s->FIND_BUF_NETID,			/* Reserved for NET */
					DestFileInfo.attrib,			/* attribute found */
					DestFileInfo.wr_time,		/* time */
					DestFileInfo.wr_date,		/* date */
					DestFileInfo.size,			/* size */
					DestFileInfo.name );			/* packed name */
#endif

		/* Zero-out NET_ID members, in case they contain garbage. */
		for(i=0; i<4; i++)
		{
			((struct FIND_BUF *) &SrcFileInfo)->FIND_BUF_NETID[i] = '\0';
			((struct FIND_BUF *) &DestFileInfo)->FIND_BUF_NETID[i] = '\0';
		}

		if( memcmp(&SrcFileInfo, &DestFileInfo, sizeof(struct find_t)) == 0 )
			return(TRUE);		/* Source == Destination */
	}

	return(FALSE); 			/* Source != Destination */
}


/* BOOL PromptUser( int argc, char *$argv[] );
 *
 * Prompt the user for the source and destination files.
 *
 * ENTRY: $argv[] 	array of pointers to input parameters.
 *
 * EXIT: TRUE if user entered valid parameters; FALSE otherwise.
 * 		If TRUE, then $argv[1] -> source parameter
 * 					and  $argv[2] -> destination parameter
 *
 * HISTORY: M001	Created.
 *
 */

BOOL PromptUser( int argc, char *$argv[] )
{
	int i;

	/* Prompt for Source file, if needed. */

	if( argc == 1 )
	{
		printf(pszSRC_PROMPT1);
		while(TRUE)
		{
			printf(pszSRC_PROMPT2);

			i = GetString( $argv[1], MAX_ROW_LEN - sizeof(pszSRC_PROMPT2) );

			if( i == ABORT )
				return(FALSE);
			else
			if( i > 0 )
				break;
		}
	}

	/* Prompt for Destination file */

	printf(pszDEST_PROMPT1);
	while(TRUE)
	{
		printf(pszDEST_PROMPT2);

		i = GetString( $argv[2], MAX_ROW_LEN - sizeof(pszDEST_PROMPT2) );

		if( i == ABORT )
			return(FALSE);
		else
		if( i > 0 )
			break;
	}

	return(TRUE);
}


/* int Quit(int);
 *
 * Cleanup and exit program.
 *
 * ENTRY: Exit code.
 *
 * EXIT: None
 *
 * NOTES: NULL memory pointers are ignored by the free() and _ffree()
 * 		 functions, so we always exit through Quit(), even if the
 * 		 memory pointers haven't been initialized yet. (All the global
 * 		 memory pointers are static or external, so they are initialized
 *			 to NULL by default.)
 *
 * HISTORY: M001	Created.
 *
 */
int Quit(int rc)
{
	FreeBuffers();
	return(rc);
}


/* int GetString(char *chBuf, int iBufSiz)
 *
 * Read a line from STDIN into a buffer (chBuf).  The line is
 * terminated when the buffer is full (buffer size is specified by
 *	iBufSiz and includes a terminating NULL character) or when a newline
 * is encountered ('\n').	The line is terminated by a NULL character ('\0');
 * the newline ('\n') is not retained.	The function returns the number of
 * characters in the buffer chBuf, not including the NULL ('\0'), or ABORT
 * if the CHAR_ABORT character is encountered.
 *
 * ENTRY:	chBuf -> destination buffer
 * 			iBufSize = Maximum buffer size (including terminating NULL char.)
 *
 * EXIT: 	returns number of characters in the buffer chBuf, not including
 * 			the terminating NULL char., or ABORT if the CHAR_ABORT is
 * 			encountered.
 *
 * NOTES:	This function does not handle the case of strings which wrap.
 * 			So, in order for the BACKSPACE key to erase all the input
 * 			characters, the value of iBufSiz should limit input to 1
 * 			screen row.
 *
 * HISTORY: M001	Created.
 *
 */

int GetString(char *chBuf, int iBufSiz)
{
	int i;
	char chIn;
	int iBufEnd = iBufSiz - 1;

	/* Save characters in chBuf[] until buffer is full.	Don't
	 * exit loop until Carriage return or EOF or ABORT received.
	 */

	for( i=0;
		  ((chIn = (char) getch()) != CHAR_EOF) &&
		  (chIn != '\r') &&
		  (chIn != CHAR_ABORT); )
	{
		if( isprint(chIn) )
		{
			if( i < iBufEnd )
			{
				putch(chIn);
				chBuf[i++] = chIn;
			}
			else
				putch('\a');
		}
		else
		if( chIn == '\b' )
		{
			if( i > 0 )
			{
				putch('\b');
				putch(' ');
				putch('\b');
				chBuf[i--] = NULL;
				continue;
			}
		}
		else
			putch('\a');
	}
	chBuf[i] = EOL;		/* Zero-terminate string */

	if( chIn == CHAR_ABORT )
		i = ABORT;

	printf("\n");

#ifdef DEBUG0
	printf("i=%d, input=%s\n", i, chBuf);
#endif

	fflush(stdin);			/* Flush input buffer */

	return(i);
}


/* ProcessInput( int $argc, char *$argv[] )
 *
 * Decompress source file(s) to destination.
 *
 * ENTRY:	$argc		Number of input parameters
 * 			$argv[]	Array of ptrs to input parameters
 *
 * EXIT: 	EXIT_SUCCESS or EXIT_FAILURE.
 *
 * NOTES:
 *
 * HISTORY: M001	Created.
 *
 */

int ProcessInput( int $argc, char *$argv[] )
{
	int i;
	int rc = EXIT_SUCCESS;
	char rgchDestFileName[MAXFILESPECLEN];	/* destination file name */
	BOOL bIsDir;									/* IsDir() return value */
   long cblTotIn = 0L,
        cblTotOut = 0L;

   // initialize globals
   uchAlgorithm = uchALG_LEMPEL_ZIV;
   uchVersion = uchVER_1;

   // keep track of original drive
   wOriginalDrive = GetCurDrive();

	// Is the last parameter a directory?
	bIsDir = IsDir((LPSTR)$argv[$argc - 1]);

	if ($argc != 3 && ! bIsDir)
   {
		printf(pszNO_DEST_DIR, $argv[$argc - 1]);
		return(EXIT_FAILURE);
   }

   // Set up input, output, and ring buffers, and associated work
   // pointers.
   if (! InitBuffers())
   {
      printf(pszNOT_ENOUGH_MEM);
		return(EXIT_FAILURE);
   }

	if ($argc == 3 && ! bIsDir)
   {
		// CASE 1: expand a file to a different file

		if ( !Decompress($argv[1], $argv[2]) )
			rc = EXIT_FAILURE;
   }
	else
	{
		// CASE 2: expand a file or files to a file or files with the same name
		// in a different directory specified in $argv[$argc - 1].

		for (i = 1; i < $argc - 1; i++)
		{
			InitBufferPtrs();
			cblOutSize = 0L;
			strcpy(rgchDestFileName, $argv[$argc - 1]);
			CatPathAndFileName(rgchDestFileName, ExtractFileName($argv[i]));

			if ( !Decompress($argv[i], rgchDestFileName) )
			{
				rc = EXIT_FAILURE;
				break;
			}

			cblTotIn += cblInSize;
			cblTotOut += cblOutSize;
		}

#ifdef DEBUG0
		printf("\n       %ld bytes expanded to %ld bytes, savings: %d%%\n",
				  cblTotIn, cblTotOut, (int)(100 - 100 * cblTotOut / cblTotIn));
#endif
	}

	if( iFiles == 1 )
		printf( pszONE_FILE, iFiles);
	else
	if( iFiles > 1 )
		printf( pszTOTAL_FILES, iFiles);

	return(rc);
}


/* main(int argc, char *argv[] )
 *
 * Decompress source file(s) to destination.
 *
 * ENTRY:	argc		Number of input parameters
 * 			argv[]	Array of ptrs to input parameters
 *
 * EXIT: 	EXIT_SUCCESS or EXIT_FAILURE.
 *
 * NOTES:	This function primarily parses the command-line. The function
 * 			ProcessInput() does most of the real work.
 *
 * HISTORY: M001	main() now does command-line parsing; ProcessInput() does
 * 					most everything else.
 *
 */

int main(int argc, char *argv[])
{
	int  i;
	char *$argv[3];						/* Dummy argv[] for user prompted input. */
	char szSource[MAXFILESPECLEN];	/* Prompted source input. */
	char szDest[MAXFILESPECLEN];		/* Prompted destination input. */


	/* Parse command-line */

	if( HelpSwitchPresent(argc, argv) ) 	/* EXPAND /?: display help	*/
   {
      PrintInstructions1(); // IPG - These two lines used to be one macro
      PrintInstructions2(); // IPG - called PrintInstructions()
      		Quit(EXIT_FAILURE);
	}
	else
	if( argc == 1 || argc == 2	)	/* Missing parameters: prompt user */
	{
		/* Init. dummy argv[] so user input can be treated
		 * as command-line input parameters.
		 */

		$argv[0] = argv[0];		/* program name */

		if( argc == 2 )			/* Use cmd-line source input, if available */
			$argv[1] = argv[1];
		else
			$argv[1] = szSource; /* source input buffer */

		$argv[2] = szDest;		/* destination input buffer */

		/* Prompt user for source, $argv[1], and destination, $argv[2]. */
		if ( !PromptUser(argc, $argv) )
			Quit(EXIT_FAILURE);

		Quit( ProcessInput( 3, $argv ) );
	}
	else
	if( argc > 2 )
	{
		Quit( ProcessInput( argc, argv ) );
	}
	else
	{
		printf(pszINVALID);
		Quit(EXIT_FAILURE);
	}

	return(EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\sulib.h ===
/*
 * SULIB.H - Windows/DOS Setup common code
 *
 *           Copyright (c) 1988-1991 Microsoft Corporation
 *           Microsoft Confidential
 *           All Rights Reserved.
 *
 *  Modification History:
 *
 *  3/23/89  Toddla  combined common.h and prototypes into this file
 *               
 */

    #define FAR       far
    #define NEAR      near
    #define LONG      long
    #define VOID      void
    #define PASCAL    pascal
    typedef unsigned char   BYTE;
    typedef unsigned short  WORD;
    typedef unsigned long   DWORD;
    typedef int             BOOL;
    typedef char           *PSTR;
    typedef char NEAR      *NPSTR;
    typedef char FAR       *LPSTR;
    typedef int  FAR       *LPINT;
    int         _ret;
    unsigned    _error;
   #ifndef NULL
      #if (_MSC_VER >= 600)
         #define NULL   ((void *)0)
      #elif (defined(M_I86SM) || defined(M_I86MM))
         #define NULL   0
      #else
         #define NULL   0L
      #endif
   #endif

/* These macros are for near heap only */

    #define FOPEN(sz)                ((_ret=-1),(_error=_dos_open(sz,O_RDONLY,&_ret)),_ret)
    #define FCREATE(sz)              ((_ret=-1),(_error=_dos_creat(sz,_A_NORMAL,&_ret)),_ret)
    #define FCLOSE(fh)               ((_error=_dos_close(fh)))
    #define FREAD(fh,buf,len)        ((_error=_dos_read(fh,buf,len,&_ret)),_ret)
    #define FWRITE(fh,buf,len)       ((_error=_dos_write(fh,buf,len,&_ret)),_ret)
    #define FERROR()                 _error
    #define FSEEK(fh,off,i)          lseek(fh,(long)(off),i)

    #define ALLOC(n)                 malloc(n)
    #define FREE(p)                  free(p)
    #define SIZE(p)                  _msize(p)
    #define REALLOC(p,n)             realloc(p,n)

/* here are some macros for allocating and freeing far heap space */

    #define FALLOC(n)                _fmalloc(n)
    #define FFREE(n)                 _ffree(n)

/* flags for _lseek */

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0


/* M001: This path length constant has been made large enough to account for
 * drive letter, directory name, file name, terminating null, plus some pad
 * on both FAT and Installable File Systems (IFS), which may implement
 * long file names.
 */
#define MAXFILESPECLEN 260

#define ISEOF(c)     ((c) == '\0' || (c) == CNT_Z)
#define ISSEP(c)     ((c) == '='  || (c) == ',')
#define ISWHITE(c)   ((c) == ' '  || (c) == '\t' || (c) == '\n' || (c) == '\r')
#define ISFILL(c)    ((c) == ' '  || (c) == '\t')
#define ISEOL(c)     ((c) == '\n' || (c) == '\r' || (c) == '\0' || (c) == CNT_Z)
#define ISCRLF(c)    ((c) == '\n' || (c) == '\r')
#define ISNOISE(c)   ((c) == '"')
#define ISDIGIT(c)   ((c) >= '0' && (c) <= '9')
#define ISHEX(c)     (ISDIGIT(c) || ISCHAR(c))
#define ISCHAR(c)    (((c) >= 'A' && (c) <= 'Z') || ((c) >= 'a' && (c) <= 'z'))
#define SLASH(c)     ((c) == '/' || (c) == '\\')
#define DEVICESEP(c) ((c) == '/' || (c) == '\\' || (c) == '=' || (c) == ' ' || (c) == '\t')
#define UPCASE(c)    ((c) >= 'a' && (c) <= 'z' ? (c) & 0xdf : (c))
#define HEXVAL(c)    (ISDIGIT(c) ? (c) - '0' : UPCASE(c) - 'A' + 10)

#define CHSEPSTR                "\\"
#define EQUAL                   '='
#define SPACE                   ' '
#define LF                      0x0A
#define CR                      0x0D

/* DOS ERROR CODES */

#define ERROR_OK            0x00
#define ERROR_FILENOTFOUND  0x02    /* File not found */
#define ERROR_PATHNOTFOUND  0x03    /* Path not found */
#define ERROR_NOFILEHANDLES 0x04    /* Too many open files */
#define ERROR_ACCESSDENIED  0x05    /* Access denied */
#define ERROR_INVALIDHANDLE 0x06    /* Handle invalid */
#define ERROR_FCBNUKED      0x07    /* Memory control blocks destroyed */
#define ERROR_NOMEMORY      0x08    /* Insufficient memory */
#define ERROR_FCBINVALID    0x09    /* Memory block address invalid */
#define ERROR_ENVINVALID    0x0A    /* Environment invalid */
#define ERROR_FORMATBAD     0x0B    /* Format invalid */
#define ERROR_ACCESSCODEBAD 0x0C    /* Access code invalid */
#define ERROR_DATAINVALID   0x0D    /* Data invalid */
#define ERROR_UNKNOWNUNIT   0x0E    /* Unknown unit */
#define ERROR_DISKINVALID   0x0F    /* Disk drive invalid */
#define ERROR_RMCHDIR       0x10    /* Attempted to remove current directory */
#define ERROR_NOSAMEDEV     0x11    /* Not same device */
#define ERROR_NOFILES       0x12    /* No more files */
#define ERROR_13            0x13    /* Write-protected disk */
#define ERROR_14            0x14    /* Unknown unit */
#define ERROR_15            0x15    /* Drive not ready */
#define ERROR_16            0x16    /* Unknown command */
#define ERROR_17            0x17    /* Data error (CRC) */
#define ERROR_18            0x18    /* Bad request-structure length */
#define ERROR_19            0x19    /* Seek error */
#define ERROR_1A            0x1A    /* Unknown media type */
#define ERROR_1B            0x1B    /* Sector not found */
#define ERROR_WRITE         0x1D    /* Write fault */
#define ERROR_1C            0x1C    /* Printer out of paper */
#define ERROR_READ          0x1E    /* Read fault */
#define ERROR_1F            0x1F    /* General failure */
#define ERROR_SHARE         0x20    /* Sharing violation */
#define ERROR_21            0x21    /* File-lock violation */
#define ERROR_22            0x22    /* Disk change invalid */
#define ERROR_23            0x23    /* FCB unavailable */
#define ERROR_24            0x24    /* Sharing buffer exceeded */
#define ERROR_32            0x32    /* Unsupported network request */
#define ERROR_33            0x33    /* Remote machine not listening */
#define ERROR_34            0x34    /* Duplicate name on network */
#define ERROR_35            0x35    /* Network name not found */
#define ERROR_36            0x36    /* Network busy */
#define ERROR_37            0x37    /* Device no longer exists on network */
#define ERROR_38            0x38    /* NetBIOS command limit exceeded */
#define ERROR_39            0x39    /* Error in network adapter hardware */
#define ERROR_3A            0x3A    /* Incorrect response from network */
#define ERROR_3B            0x3B    /* Unexpected network error */
#define ERROR_3C            0x3C    /* Remote adapter incompatible */
#define ERROR_3D            0x3D    /* Print queue full */
#define ERROR_3E            0x3E    /* Not enough room for print file */
#define ERROR_3F            0x3F    /* Print file was deleted */
#define ERROR_40            0x40    /* Network name deleted */
#define ERROR_41            0x41    /* Network access denied */
#define ERROR_42            0x42    /* Incorrect network device type */
#define ERROR_43            0x43    /* Network name not found */
#define ERROR_44            0x44    /* Network name limit exceeded */
#define ERROR_45            0x45    /* NetBIOS session limit exceeded */
#define ERROR_46            0x46    /* Temporary pause */
#define ERROR_47            0x47    /* Network request not accepted */
#define ERROR_48            0x48    /* Print or disk redirection paused */
#define ERROR_50            0x50    /* File already exists */
#define ERROR_51            0x51    /* Reserved */
#define ERROR_52            0x52    /* Cannot make directory */
#define ERROR_53            0x53    /* Fail on Int 24H (critical error) */
#define ERROR_54            0x54    /* Too many redirections */
#define ERROR_55            0x55    /* Duplicate redirection */
#define ERROR_56            0x56    /* Invalid password */
#define ERROR_57            0x57    /* Invalid parameter */
#define ERROR_58            0x58    /* Net write fault */


/* LZCopy() return error codes.  These must be negative. */

#define LZERROR_BADINHANDLE   -1  /* Invalid input handle */
#define LZERROR_BADOUTHANDLE  -2  /* Invalid output handle */
#define LZERROR_READ          -3  /* Bad compressed file format */
#define LZERROR_WRITE         -4  /* Out of space for output file */
#define LZERROR_GLOBALLOC     -5  /* Insufficient memory for buffers */
#define LZERROR_GLOBLOCK      -6  /* Bad global handle */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\doslzexp.h ===
/*
** doslzexp.h - housekeeping for DOS Lempel-Ziv decompression command-line
**              and library modules
**
**              Copyright (c) Microsoft Corporation 1989-1991
**              Microsoft Confidential
**              All Rights Reserved.
*/

#define LZPTR NEAR

#include "sulib.h"


// Constants
/////////////
#define FALSE           0              // booleans
#define TRUE            1

#define END_OF_INPUT       500         // readInBuf() EOF flag for input file

#define LZDECODE_OK        501         // LZDecode() successful return value
#define COPYCREATEDATE_OK  502         // copyCreateDate() successful return
                                       // value

#define cbRingBufMax    4096           // size of ring buffer
#define cbIndex         2              // encode string into position and
                                       // length
#define cbStrMax        16             // upper limit for match length

#define ucbIOBufMax     32768U         // max size of rguchInBuf[] used for
                                       // reads and rguchOutBuf[] used for
                                       // writes
#define ucbIOBufStep    512U           // step down value used in attempting
                                       // to allocate rguchInBuf[] and
                                       // rguchOutBuf[]

#define uchBUF_CLEAR ((UCHAR) ' ')  // rguchRingBuf[] initializer

#define szCompSig       "SZDD\x88\xf0\x27\x33"  // compressed file signature:
                                                // "SZDD'3"
#define cbCompSigLength 8              // length of signature (bytes)
                                       // (no '\0' terminator)

#define uchFLUSH     ((UCHAR) 'F')  // dummy character used to flush
                                       // outBuf[] to output file

#define uchALG_LEMPEL_ZIV  ((UCHAR) 'A')  // Lempel-Ziv algorithm label
#define uchVER_1           ((UCHAR) '\0') // start with version 1

// length of entire compressed file header (used as offset to start of
// compressed data)
#define cbHdrSize       14

// (14 == cbCompSigLength * sizeof(char) + 2 * sizeof(UCHAR) + sizeof(long))
//     == cbCompSigLength + algorithm + version + uncompressed length



// Macros
//////////
#define FOREVER         for(;;)

// read a character (buffered) from input file - returns character read cast
// as int if successful, or one of readInBuf()'s error codes if unsuccessful
#define ReadUchar(uch)        ((puchInBuf < puchInBufEnd) ?\
                               (int)(uch = *puchInBuf++) :\
                               ReadInBuf((UCHAR LZPTR *)&uch, doshSource))

// put at most one character back into the buffered input,
// n.b., can be used at most (puchInBuf - &rguchInBuf[1]) times (i.e., at
// beginning of buffer, can only be used once)
#define UnreadUchar()         ((puchInBuf == &rguchInBuf[1]) ?\
                               (bLastUsed = TRUE) :\
                               (int)(UCHAR LZPTR *)(--puchInBuf))

// write a character (buffered) to output file - returns given character
// argument cast as int if successful, or one of WriteOutBuf()'s error codes
// if unsuccessful
#define writeUChar(uch)       ((puchOutBuf < puchOutBufEnd) ?\
                               (int)(*puchOutBuf++ = uch) :\
                               WriteOutBuf(uch, doshDest))

#define InitBufferPtrs()      {  puchInBufEnd = &rguchInBuf[1] + ucbIOBufLen;\
                                 puchInBuf = &rguchInBuf[1] + ucbIOBufLen;\
                                 puchOutBufEnd = rguchOutBuf + ucbIOBufLen;\
                                 puchOutBuf = rguchOutBuf;\
                              }
                           

// free the far/global heap space used by the buffers
#define FreeBuffers()         {  FFREE(rguchInBuf);\
                                 FFREE(rguchOutBuf);\
                                 FFREE(rguchRingBuf);\
                              }


// Types
/////////
typedef unsigned char UCHAR;
typedef unsigned long ULONG;

// n.b., the compressed file header does not contain the file size of the
// compressed file since this is readily obtainable through filelength() or
// lseek().  The file info structure, however, does contain the compressed
// file size.
typedef struct tagFH          // file info structure (compressed file header
                              // + some additional information)
{
    UCHAR rguchMagic[cbCompSigLength]; // magic array of compressed file
                                       // signature bytes

    UCHAR uchAlgorithm;       // algorithm label
    UCHAR uchVersion;         // version id

    ULONG cbulUncompSize;     // uncompressed file size
    ULONG cbulCompSize;       // compressed file size (not stored in header)
} FH;



// Globals available to outside modules
////////////////////////////////////////
extern UCHAR FAR *rguchInBuf;       // input buffer for reads
extern UCHAR FAR *puchInBufEnd;     // pointer past end of rguchInBuf[]
extern UCHAR FAR *puchInBuf;        // pointer to next byte to read from
                                    // rguchInBuf[]

extern UCHAR FAR *rguchOutBuf;      // output buffer for writes
extern UCHAR FAR *puchOutBufEnd;    // pointer past end of rguchOutBuf[]
extern UCHAR FAR *puchOutBuf;       // pointer to last byte to write from
                                    // rguchOutBuf[]

extern UCHAR FAR *rguchRingBuf;     // ring buffer

// flag indicating whether or not rguchInBuf[0], which holds the last byte
// from the previous input buffer, should be read as the next input byte
// (only used so that at least one unReadUChar() can be called at all input
// buffer positions)
extern BOOL bLastUsed;

extern unsigned ucbIOBufLen;        // length of input and output buffers
// (actually, rguchInBuf[] has length ucbIOBufLen + 1 since rguchInBuf[0] is
// used when bLastUsed is TRUE)



#include "doslzexp.pro"

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fastopen\fastinit.asm ===
Page 84,132 ;

TITLE	FASTINIT - initialization code for FASTOPEN  (May 13, 1988)
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

; IBM changes incoporated during 11/89 code merge:
;	      AN002 - Jan 10, 1989  EMS Dynamic allocation support  P.A.L
;	      AN003 - Apr 15, 1989  Fastopen Rename directory fix

;
;	Revision History
;	================
;
; Microsoft changes for DOS 5.0
;
;	      RMFS - Dec 15, 1989	Remove FAST_SEEK code - jh
;		     5/11/90		Used proper EMS installed check - MD
;
;	M000	SR	08/24/90	Remove code to reserve 64K above
;				itself for running other programs.
;				Not needed any more
;
;	M001	SR	08/31/90	Initialized sp to a proper value
;				instead of 0.
;
;       M002    MD      09/17/90        Properly initialize name cache size
;                                       if only extent size given
;
;	M003	MD	09/19/90	Make default name cache size consistent
;
;	M007	SR	1/22/91	Bug #5263. In Adjust_segids, also
;				update segment for FOPEN_Rename.
;

;ͻ
; The entire Fastopen component is divided into 4 modules.  They are:
; Fastopen initialization routine-1, Fastopen initialization routine-2,
; Fastopen which manages the directory/file cache buffers,
; and the cache buffer which holds directory information.
;
; These modules resides in different segments for the reason that they can
; be overlayed conditionally, depending on the user request.  For example
; initially all segments are loaded into the memory.
; Segmentation is also usefull when Fastopen
; need to copy into Expanded memory.	Following figure shows
; memory map of the FastOpen.
;
;		   Modules	      Segment
;
;	      -------------------
;	            MAIN	     CSEG_MAIN
;	      -------------------
;	         FASTINIT1	     CSEG_MAIN
;	      -------------------
;	       		  
;	          FASTOPEN	     CSEG_OPEN
;	       		  
;	      -------------------
;	         FASTINIT2	     CSEG_INIT
;	      -------------------
;	       		  
;	         NAME		  
;	         CACHE BUFFERS      CSEG_INIT
;	       		  
;	      -------------------
;
; MAIN:       This module provides DOS entry point into FASTOPEN. It also
;	      dispatch various Fastopen and Fastseek functions.  This module is
;	      in the file FASTOPEN.asm
;
; FASTINIT-1: This module is called INIT_TREE which is also a part of the
;	      Cseg_Main segment.  This basically initializes both
;	      Name and Extent drive headers, and sets up name and extent
;	      cache buffers.  This module can be found in the file
;	      FASTINIT.asm
;
; FASTINIT-1: This module is called INIT which is part of the  Cseg_Init
;	      segment.	This module parses the user commad, check memory
;	      requirements, overlay Fastopen and Fastseek code and finally
;	      installs the Fastopen to be stay resident.  This module is
;	      eventually overlayed by the cache buffers created during the
;	      buffer initialization by FASTINIT-1 ( See INIT_TREE)
;	      This module can be found in FASTINIT.asm
;
; FASTOPEN:   This module is a collection of four Fastopen functions which
;	      manage the File/Directory cache buffers. These functions are
;	      in the file FASTOPEN.asm
;
;
; Fastopen Code and Cache buffer Relocation
; -----------------------------------------
;    If user specifies both  n and m in the user command  and /x, then
; Cseg_Open, Cseg_Seek and Cseg_Init will be copied into a 16K page of the
; Expanded Memory.  If only n is specified, then Cseg_Open and Cseg_Init will
; be copied.  If only m is specified, then Cseg_Seek and Cseg_init will be
; copied.  After this the total size of the segments transferred will be
; deblocked from the low memory to save available user space.
;
; WARNING: After every move you have to recalculate the Seg ID of moved
;	   modules depending on how far it has been displaced and then
;	   replace the Seg ID in the jump vectors used for accessing
;	   functions in the moved modules.  A wrong Seg ID can cause
;	   instant System CRASH ...@%+(@!$#@@*&...
;
; Future Enhancements:
;
;   1.	Modify Fastopen so that it can be run on removable media (Diskette).
;	At present only fixed disk is supported.
;
;   2.	Allocate all Extent buffers during initialization. Now they are
;	done in run time.  This may avoid using flags (-2) for discontinuous
;	buffers. Using (-2) requires buffers be filled with '0's during PURGE.
;
;
;   4;	Currently Fastopen code and cache is kept in one 16K page of the
;	Extended Memory.  This puts a restriction on the size of the cache
;	buffer available in EMS usually about 8K.  This can be avoided by
;	keeping code and cache buffers in two seperated pages, so that maximum
;	of 16K is available for cache buffers.
;ͼ
;
IF1
    ;%OUT ASSEMBLING: FASTINIT - FASTOPEN initialization
ENDIF
NAME	FASTINIT

.XCREF
.XLIST


TRUE	   EQU	  0FFFFh
FALSE	   EQU	  0

;DBCS	    =	  FALSE
Installed   =	  TRUE

IFNDEF	DEBUG
    DEBUG	= FALSE
ENDIF

INCLUDE    dosmac.inc
INCLUDE    vector.inc
INCLUDE    filemode.inc
INCLUDE    mult.inc
include	   version.inc

.LIST
.CREF

INCLUDE    fastsegs.inc
INCLUDE    fastopen.inc
INCLUDE    SYSCALL.INC ;

BUFFERFLAG	EQU	TRUE


;-----------------------------------------------------------------------
;		       EQUATES
;-----------------------------------------------------------------------
Top_mem 	       EQU    02h	      ;Top of memory index in PSP
Min_entry_num	       EQU    10	      ;minimum name cache entries
Max_entry_num	       EQU    999	      ;maximum name cache entries
Default_names	       EQU    48	      ;default name cache entries M003
Debug		       EQU    0 	      ;for callinstall
Len_source_xname       EQU    4 	      ;used for xname translate
No_siblings	       EQU    -1	      ;indicate no siblings
No_child	       EQU    -1	      ;indicate no children
No_backward	       EQU    -1	      ;no backward pt yet
Max_drives	       EQU    24	      ;maximum number of drives allowed

STACKSIZE		EQU    200h
IF	NOT BUFFERFLAG
Static_Alloc	       EQU    1
Dyna_Alloc	       EQU    2
ENDIF

; ----------------- MESSAGE EQUATES -------------------------------------

Not_enough_mem	       EQU	2
Invalid_switch	       EQU	3
Install1	       EQU	4
Already_install        EQU	5
Incorrect_param        EQU	6
Too_many_entries       EQU	7
Dup_drive	       EQU	8


Invalid_name	       EQU	12
Ems_failed	       EQU	13
Ems_not_install        EQU	14
Invalid_drive	       EQU	15
No_page_space	       EQU	16
Bad_Use_Message        EQU	17


Many_Name_Entries      EQU	19

Under_DosShell	       EQU	20

MSG_OPTIONS_FIRST      EQU	300		; Options help messages
MSG_OPTIONS_LAST       EQU	305

;------------ E M S SUPPORT EQUATES -------------------------------

EMS_GET_STATUS	       EQU	40H
EMS_GET_NUM_PAGES      EQU	42H
EMS_ALLOC_PAGES        EQU	43H
EMS_MAP_HANDLE	       EQU	44H
EMS_GET_VERSION        EQU	46H
EMS_SAVE_STATE	       EQU	4FH
EMS_RESTORE_STATE      EQU	48H
EMS_PAGE_SIZE	       EQU	4FH
EMS_2F_HANDLER	       EQU	1BH
EMS_GET_COUNT	       EQU	5801H
EMS_GET_FRAME_ADDR     EQU	5800H
EMS_HANDLE_NAME        EQU	53H
EMS_INT 	       EQU	67H
SINGLE_SEGMENT	       EQU	 1


;-------------------- STRUCTURES ---------------------------------

PAGE_FRAME_STRUC    STRUC	    ; EMS page frame structure

  PAGE_SEG	DW	?	    ;EMS page segment
  PAGE_NUM	DW	?	    ;EMS page number (only one page is used)

PAGE_FRAME_STRUC    ENDS

BUFFER_ENTRY_SIZE      EQU    TYPE  PAGE_FRAME_STRUC


SUB_LIST      STRUC			; Message handler sublist structure
	DB	11			;
	DB	0			;
DATA_OFF DW	0			; offset of data to be inserted
DATA_SEG DW	0			; offset of data to be inserted
MSG_ID	DB	0			; n of %n
FLAGS	DB	0			; Flags
MAX_WIDTH DB	0			; Maximum field width
MIN_WIDTH DB	0			; Minimum field width
PAD_CHAR DB	0			; character for pad field
SUB_LIST      ENDS


;-------------------------------------------------------------------------------
; Following two segments are used to define external variable that
; are defined in two other segments.
;-------------------------------------------------------------------------------

CSEG_OPEN   SEGMENT   PARA   PUBLIC 'CODE'       ; Cseg_Open segment
  EXTRN   Open_name_cache_seg:word
  EXTRN   Open_Name_Drive_Buff:word
  EXTRN   End_Open:byte
  EXTRN   Chk_Flag:word
  EXTRN   VECTOR_LOOKUP:dword	  ; jump vector inside Cseg_Main to make
				; a FAR call to Fopen LookUp function within
				; the segment
ifdef DBCS
  EXTRN   DBCSLeadByteTable:dword
endif

CSEG_OPEN	ENDS



;
CSEG_MAIN   SEGMENT   PARA   PUBLIC 'CODE'       ;  MAIN segment

; This segment is a continuation of the Cseg_Main segment in Fastopen.asm
; and contains code to initializes name and extent drive buffers
;
ASSUME	 CS:cseg_main,DS:nothing,SS:stack,ES:nothing

EXTRN	MAIN:FAR


EXTRN			EMS_PAGE_MAP	:WORD
EXTRN			EMS_PAGE_ARRAY	:DWORD

extrn	restore_page_state:near		; HKN 8/25/88

extrn	ems_save_handle1:word		; HKN
extrn	ems_page_number:word		; HKN


EXTRN	Main_Total_Name_Count:word
EXTRN	Main_Name_Drive_Buff:word
EXTRN	Main_Name_Cache_Buff:word
EXTRN	Main_Name_Cache_Seg:word
EXTRN	Main_Parambuff:byte


EXTRN	Main_Num_Of_drives:word


	if bufferflag
EXTRN	Main_EMS_FLAG:word
	else
EXTRN	MAIN_EMS_MEM:word		;AN002; 0= No EMS  2=/X, 1=/XS, 2=/XD
					;AN002; /X default dynamic  /XS - Static, /XD=dynamic
	endif

EXTRN	Main_Res_Segs:word
EXTRN	Main_EMS_PAGE_SEG:word
EXTRN	Main_EMS_PAGE_SIZE:word

EXTRN	FOPEN_Insert:dword
EXTRN	FOPEN_Update:dword
EXTRN	FOPEN_Delete:dword
EXTRN	FOPEN_Lookup:dword
EXTRN	FOPEN_Purge:dword
EXTRN	FOPEN_Rename:dword	       ;AN003



;*************************************************************************
;
;SUBROUTINE: INIT_TREE	  (FASTINIT-1)
;
;FUNCTION:  This routine builds 'N' name directory buffers under each drive
;	    header. The second half of this routine makes the Fastopen code
;	    resident.
;
;INPUT:     Drive_cache_header, End_Caches
;
;OUTPUT:    Name_cache and Extent Cache entries installed for every
;	    drive requested.
;
;*************************************************************************
	IF  ($-Cseg_Main) MOD 16
	   ORG ($-Cseg_Main)+16-(($-Cseg_Main) MOD 16)
	ENDIF
End_Main1  label   word


INIT_TREE:
	mov	ax,cseg_Main		       ;get addressiblity to
	mov	ds,ax			       ;DS --> Cseg_Main
	ASSUME	ds:cseg_Main


;-----------------------------------------------------------------------------
; Following code adds 'n' directory entry buffers to each Name Drive headers,
; depending on the value of 'n' specified with each drive ID
;-----------------------------------------------------------------------------
	mov	si,Main_Name_Drive_Buff        ;SI-->first Name drive cache buff
	mov	bx,Main_Name_Cache_Buff        ;BX-->Name cache buffer
	xor	dx,dx
	xor	ax,ax

	mov	ax,Main_Name_Cache_Seg	       ;get addresability to CSeg_Init
	mov	ds,ax			       ;DS=addressablity to Cseg_Init
	ASSUME	ds:cseg_Init

Set_Up_Cache:
	mov	[si].DCH_LRU_ROOT,bx		;set to point to first name
	mov	[si].DCH_NAME_BUFF,bx		;set to point to first name
	mov	cx,[si].DCH_num_entries 	;get number of name records

;-----------------------------------------------------------------------------
;  set up MRU and LRU pointers
;  AX points to last name record
;  BX points to current name record
;  DX points to next name record
;-----------------------------------------------------------------------------
	mov	[bx].nMRU_ptr,-1		;make first MRU -1
	jmp	short set_start

Set_Up_Names:
	mov	[bx].nMRU_ptr,ax		;set up MRU
	add	ax,size name_record

Set_Start:
	mov	[bx].nChild_ptr,no_child	;no children or siblings
	mov	[bx].nsibling_ptr,no_siblings	;  right now
	mov	[bx].nBackward_ptr,no_backward
	push	es
	push	di
	push	ax

	push	ds
	pop	es				;ES-->name cache buffer
	ASSUME	es:Cseg_Init

	mov	ax, '  '
	mov	di, bx
	add	di, nCmpct_Dir_Info		;blank out the Dir name area
	stosb					;the directory buffer
	stosw
	stosw					; Same as rep stosb * 11
	stosw
	stosw
	stosw

	pop	ax
	pop	di
	pop	es

	mov	dx,bx				;get name offset
	add	dx,size name_record		;get start of next name
	dec	cx				;decrement num_entries
	jcxz	get_next_drive			;if zero - get next drive
	mov	[bx].nLRU_ptr,dx		;LRU pointer - next name
	add	bx,size name_record		;
	jmp	set_up_names

Get_Next_Drive:
	mov	[bx].nLRU_ptr,-1		;LRU pointer - next name

	mov	[si].DCH_MRU_ROOT,bx		;set to point to last name
	mov	bx,dx				;get pointer to next name
	cmp	[si].dch_sibling_ptr,no_siblings  ;is there any more to set up??
	jz	Init_exit			; RMFS
	add	ax,size name_record		; yes - get next name directory buffer
	add	si,size drive_cache_header	;point to next drive header
	jmp	set_up_cache

;----------------------------------------------------------------------------
; Close handles 0 - 4
;----------------------------------------------------------------------------

INIT_EXIT:
	mov	bx,0
Handle_Loop:
	mov	ah,03EH
	INT	21H
	inc	bx
	cmp	bx,5
	jne	Handle_Loop


;----------------------------------------------------------------------------
; Get PSP segment and find the program environment segment and deallocate
; the environment space.
;----------------------------------------------------------------------------

	 push  ds
	 mov   si,0081H
	 mov   ah,62H
	 INT   21H		   ; get program PSP segment

	 mov   ds,bx		   ; DS = PSP segment
	 mov   si,02CH		   ; SI-->address of enviroment segment
	 mov   ax,[si]		   ; AX = environment seg id
	 cmp   ax,0		   ; environment present ??
	 je    dont_dealloc	   ; no - dont deallocate
	 mov   es,ax
	 mov   ah,49H
	 INT   21H		   ; deallocate environment
Dont_Dealloc:
	 pop   ds		   ; restore DS

;----------------------------------------------------------------------------
; Keep resident the Fastopen code and cache buffers.  The size of the resident
; area is in (Main_Res_Segs). Size may vary depending on whether Fastopen or
; Fastseek or both or extent memory is specified.
;----------------------------------------------------------------------------

	  if	 not bufferflag
	  CMP	 MAIN_EMS_Mem,Dyna_Alloc      ;AN002;Dynamic allocation ??
	  JNE	 SKIP_RESTORE1		      ;AN002; if not dont restore
	  endif

	  call	 restore_page_state	      ; HKN 8/25/88

Skip_Restore1:				      ;AN002;
	  mov	 ah,KEEP_PROCESS	      ;remain resident
	  mov	 al,0			      ;return code
	  mov	 dx,Main_Res_Segs	      ;size of area in paragraph
	  INT	 21h			      ;keep resident and then return
					      ;control to DOS

;----------------------------------------------------------------------------
; Calculate the size of the MAIN module in bytes.  First potion of this
; segment can be found in the Fastopen.asm
;----------------------------------------------------------------------------
	IF  ($-Cseg_Main) MOD 16
	   ORG ($-Cseg_Main)+16-(($-Cseg_Main) MOD 16)
	ENDIF
End_Main   label   word


CSEG_MAIN	ENDS		     ; End of Cseg_Main segment
page


;

CSEG_INIT	SEGMENT PUBLIC PARA 'CODE'

;
	 ASSUME    cs:cseg_init,ds:cseg_init,ss:stack,es:cseg_init

	 EXTRN	  SYSPARSE:NEAR
	 EXTRN	  SYSLOADMSG:NEAR
	 EXTRN	  SYSDISPMSG:NEAR

; Changed to eliminate having to do a far call to same_ems_page_state
; from within the resident code. Added a duplicate function to the
; init code.
;
;	extrn	save_ems_page_state:far		; HKN 8/25/88




;----------------------------------------------------------------------------
; The cache buffers start from the first location of Cseg_Init.
; First portion is the NAME DRIVE HEADERS, which is followed by
; NAME CACHE BUFFER, which is followed by EXTENT DRIVE HEADER. Under each
; extent drive header its cache buffer. 24 Name drive buffers are allocated
; during assembly time.  Remaining drive and cache buffers are allocated
; during run time.  Eventhough 24 name cache buffers are allocated during
; assembly time, this number may be reduced to the specified number of drive
; numbers during run time by overlaying other drive buffers over the unused ones.
; The initialization code will be overlayed by name and extent cache buffs
; during second half of the initialization which is in the MAIN module (see INit_Tree).
;-----------------------------------------------------------------------------

Drive_header_start	label	byte	    ;Name cache drive buffer
Drive_Cache		Drive_Cache_Header    max_drives DUP (<>)  ; header for 24 drives are reserved

;-----------------------------------------------------------------------------
; Anything below this point will be overlayed by the Cache Buffers
; MSG retriever is placed after Cache buffer, so that the area can be
;-----------------------------------------------------------------------------
;=============================================================================
;		   Non_Resident Data Area
;=============================================================================
INIT_VECTOR		DD     INIT_TREE	;jump vector to INIT_TREE
MAIN_VECTOR		DD     MAIN		;entry point to MAIN routine
source_xname		DB	" :\",0         ;used for xname translate
target_xname		DB	65 DUP (0)	;used for xname translate
user_drive		db	0		;current user drive
psp_seg 		dw	0		;segment of psp
stack_seg_start 	dw	0		;segment of temporary stack
stack_seg_end		dw	0
num_of_drives		dw	0		;number of user specified drives
Ext_Mem 		dw	0		;=1 if exteded memory is enabled
						;or, if not bufferflag (ie, IBM):
						;  0=No EMS, 2=/X, 1=/XS, 2=/XD
drive_id		db     " :",0
Parambuff		db	50  dup (0)
Parmbuff_Ptr		dw	0
FRAME_COUNT		dw	0		;EMS frame count
FRAME_BUFFER		DB	100h DUP(0)	; EMS frame buffer
FST_PAGE		DW	0,0		; holds the second highest page above 640k

Cmdline_buff		db	135  dup (0)	;command line buffer
name_cache_seg		dw	Cseg_Init	;default to Init1 seg


name_cache_Buff 	dw	0		;pointer to Name cache buffer
EMS_FLAG		dw	0		;EMI flag  1= if EMI is enabled
CHECK_QUEUE		dw	0		; = 1 if analyser is activated
RES_SEGS		dw	010H	;PSP SIZE ; M001 :add stacksize later
EMS_PAGE_SEG		DW	0		;EMS code page segment ID
EMS_PAGE_NUM		DW	0		;EMS physical page number
EMS_NAME		db	"EMMXXXX0"	;Name of EMS driver

Total_Name_Count	DW	0		;Total Name entry count

;; JUNK ;; Total_Cache_Size	DW	0		;Total cache buffer size (name+extent) buffer

Name_Cache_Size 	DW	0		;Total name cache size (header + entry buffs)
Name_Count		DW	0		;name entry count
Name_Drive_Buff 	DW	0		;name driver buffer address


Open_SegID		DW	0		;SegId of Cseg_Open after relocation


Init_SegID		DW	0		;SegId of Cseg_Init  "       "
MAIN_Size		DW	0		;size of Cseg_Main in Paragraph
OPEN_Size		DW	0		;size of Cseg_Open in paragraph


;-----------------------------------------------------------------------;
;	EMS Support							;
;-----------------------------------------------------------------------;
EXT_HANDLE     DW   ?		     ; EMS handle for reference
EMS_PAGESIZE   DW   ?		     ; EMS handle for reference
EMS_FRAME_ADDR DW   ?		     ; EMS handle for reference
CURR_EMS_PAGE  DB   ?		     ; Current EMS page number
HANDLE_NAME    DB   'FASTOPEN',0     ; EMS handle name

;;; johnhe 12/31/89; SAVE_MAP_ADDR	DD	?	; HKN 8/25/88


;; md debug publics
public drive_cache, parambuff, parmbuff_ptr, current_parm, Next_parm
public ordinal, ordinal1, prev_type, par_min, par_max, par_sw, pos1type
public pos2type, valuelo

;---------------------------------------------------------------------------
;	PARSER Support
;---------------------------------------------------------------------------
CURRENT_PARM   DW   81H 	     ;POINTER INTO COMMAND OF CUREENT OPERANT
NEXT_PARM      DW   0		     ;POINTER INTO COMMAND OF NEXT OPERAND
ORDINAL        DW   0		     ;ORDINAL NUMBER OF MAIN PARSER LOOP
ORDINAL1       DW   0		     ;ORDINAL NUMBER OF COMPLEX ITEM LOOP
PREV_TYPE      DB   0		     ;PREVIOUS POSITIONAL PARAMETER TYPE

;---------------------------------------------------------------------------
; PRINT_STDOUT input parameter save area
;----------------------------------------------------------------------------
SUBST_COUNT DW	  0		   ;message substitution count
MSG_CLASS   DB	  0		   ;message class
INPUT_FLAG  DB	  0		   ;Type of INT 21 used for KBD
MSG_NUM     DW	  0		   ;message number


;----------------------------------------------------------------------------
; Following three sublists are used by the  Message Retriever
;----------------------------------------------------------------------------
SUBLIST1 LABEL	DWORD		   ;SUBSTITUTE LIST 1
	DB	11		   ;sublist size
	DB	0		   ;reserved
	DD	0		   ;substition data Offset
	DB	1		   ;n of %n
	DB	0		   ;data type
	DB	0		   ;maximum field width
	DB	0		   ;minimum field width
	DB	0		   ;characters for Pad field


SUBLIST2 LABEL	DWORD		   ;SUBSTITUTE LIST 2
	DB	11		   ;sublist size
	DB	0		   ;reserved
	DD	0		   ;substition data Offset
	DB	2		   ;n of %n
	DB	0		   ;data type
	DB	0		   ;maximum field width
	DB	0		   ;minimum field width
	DB	0		   ;characters for Pad field



;--------------------------------------------------------------------------
;   PARSER  Control Blocks and Buffers
;--------------------------------------------------------------------------

NUM_SWITCHES	equ	2	  ; number of command switches supported

PARMS	   label   word
	    DW	    parmsx
	    DB	    1		  ; number of delemeters
	    DB	    1		  ; extra delimeters length
	    DB	    "=" 	  ; extra delimeter expected
	    DB	    0		  ; extra end of line length
	    DB	    0


PARMSX	   label   byte
par_min     DB	    1		  ; min, max positional operands allowed
par_max     DB	    2		  ; min, max positional operands allowed
	    DW	    Pos1	  ; offset into positonal-1 control block
	    DW	    Pos2	  ; offset into positonal-1 control block
par_sw	    DB	    NUM_SWITCHES  ; two switches
	    DW	    Switch_X	  ; offset of Switch_X control bloc
	    DW	    Switch_?	  ; offset of Switch_? control bloc
	    DB	    0		  ; no keywords
	    DB	    0		  ; 0



;------------------ POS2 CONTROL BLOCK --------------------------------------

POS1	  label  word	  ; positional-1 control definition
Pos1Type    DW	   0100H	; control type flag (drive only)
	    DW	   0		; function flags
	    DW	   Result	; offset into result buffer
	    DW	   value_pos1	; offset value list buffer
	    DB	   0		; number of keyword/switch synonyms


Value_Pos1    label   byte	; postional parameter value expected
	    DB	    0		; no values expected



;---------------- POS1 CONTROL BLOCK ----------------------------------------

POS2	 label	word	       ; positional-2 control definition
Pos2Type   DW	  08502H       ; Control type (complex/integer/drive/
			       ; repeat)
	   DW	  0	       ; function flags
	   DW	  Result       ; offset into result buffer
	   DW	  value_pos2   ; offset value list buffer
	   DB	  0	       ; number of keyword/switch synonyms

Value_Pos2    label   byte
	   DB	   0	       ; either (n) or (m) will be returned



;--------------- RESULT BUFFER ---------------------------------------------

RESULT	 label	byte	 ; postional2 parameter result buffer
PosType    DB	  ?	       ; type of operand returned
Postag	   DB	  ?	       ; type of item tage returned
synonym    DW	  ?	       ; offset into synonyms returned
valuelo    DW	  ?	       ; space for drive number/integer/strin
valuehi    DW	  ?


;---------------- SWITCH CONTROL BLOCK S -------------------------------------

Switch_X   label  word	       ; switch control definition
	   DW	  0	       ; no match flag
	   DW	  0	       ; no function flags
	   DW	  Result       ; offset into result buffer
	   DW	  Value_Nul    ; offset value list buffer
	   DB	  1	       ; number of keyword/switch synonyms
E_Switch   DB	  "/X"	       ; /X option for extended memory access
	   DB	  0

Switch_?   label  word	       ; switch control definition
	   DW	  0	       ; no match flag
	   DW	  0	       ; no function flags
	   DW	  Result       ; offset into result buffer
	   DW	  Value_Nul    ; offset value list buffer
	   DB	  1	       ; number of keyword/switch synonyms
Sw_?_Syn   DB	  "/?"	       ; /? option for display options
	   DB	  0


Value_Nul  label   byte        ; switch parameter value expected
	   DB	   0	       ; no values expected







;-----------------------------------------------------------------------------
;  INIT     (FASTINIT-2)
;-----------------------------------------------------------------------------
;
;SUBROUTINE: INIT
;
;FUNCTION:  Performs FASTOPEN initialization function
;
;
;NOTE: This routine is the starting routine of FASTOPEN
;
;-----------------------------------------------------------------------------

START:
					; on entry DS and ES -->PSP
	mov	AX,CS			; DS-->Cseg_Init
	mov	DS,AX
	ASSUME	ds:cseg_init
	mov	psp_seg,es		; save PSP segment for later use
	mov	ES,AX			; ES-->Cseg_Init
	ASSUME	es:cseg_init

	CALL	SYSLOADMSG		; Preload messages
	jnc	Parse_cmd_line		; If no error, parse command line

	mov	ax,1
	CALL	SYSDISPMSG		; display error

	mov	ah,04ch 		; Terminate
	mov	al,0			; Errorlevel 0 (Compatible)
	INT	021h			; exit to DOS

Parse_Cmd_Line:
	CALL	PARSE			;Parse command line
	lea	si,parambuff		;drive ID buff address

;  RMFS ;;;;;	mov	ax,Total_name_Count	;
;  RMFS ;;;;;	mov	ax,num_of_drives
;  RMFS ;;;;;	mov	ax,ext_mem

	jc	error_exit		;yes - exit

Check_Installed:
	CALL	CHECK_INSTALL		; Fastopen installed ??
	jc	error_exit

;-----------------------------------------------------------------------------
; Set seg IDs of three segments.
;-----------------------------------------------------------------------------
Save_SegIds:
	mov	Open_SegID, Cseg_Open
	mov	Init_SegID, Cseg_Init

;-----------------------------------------------------------------------------
; Compute the size of segments and cache buffers.  Setup a temporary stack
; to be used by the second half of initilization.
;-----------------------------------------------------------------------------
	CALL	CHECK_MEM		;See if we have enough memory
	jc	error_exit		;no  - display not enough mem msg			   ;RMFS;

;-----------------------------------------------------------------------------
; Check if Extended Memeory is specified. If true, check if Extended memory is
; available.  Get segid of one extended memory page.
;-----------------------------------------------------------------------------
Chk_Extended_Mem:
	cmp	Ext_Mem,0		; enable EMS ??
	je	Set_Data_Areas		; no, set data areas

	CALL	SET_EMS 		; set expanded memory
	jc	error_exit

;------------------------------------------------------------------------------
; Copy Data and segid of Init segments to Main, Open and Seek segments.
; If code is relocated, segids have to be adjusted later. (See Adjust_SegID)
;------------------------------------------------------------------------------
Set_Data_Areas:
	CALL	COPY_DATA		; copy data to other segments


ifdef DBCS
	call	SET_DBCS_TABLE		; set DBCS lead byte table address
endif

;-----------------------------------------------------------------------------
; Relocate code to extended memory if extended memory is specified or
; relocate in lower memory itself.
;-----------------------------------------------------------------------------
Relocate_Code:
	CALL	RELOCATE_SEGMENT	; Relocate the code cnd buffers

;-----------------------------------------------------------------------------
; Adjust the segids and jump vectors in other segments after code relocation
;-----------------------------------------------------------------------------
	CALL	ADJUST_SEGIDS		; adjust segment ids after relocation

;-----------------------------------------------------------------------------
; Display FASTOPEN INSTALLED message. This must be done prior to the actual
; installation.
;-----------------------------------------------------------------------------
Disp_Install_Msg:			; display FASTOPEN installed message
	MOV	AX,INSTALL1		; message number
	MOV	MSG_NUM,AX		; set message number
	MOV	SUBST_COUNT,0		; no message
	MOV	MSG_CLASS,-1		; message class
	MOV	INPUT_FLAG,0		; no input
	CALL	PRINT_STDOUT		; show message

;-----------------------------------------------------------------------------
; Install Fastopen
;-----------------------------------------------------------------------------
	CALL	INSTALL_FASTOPEN	; Install Fastopen
	jc	error_exit

;----------------------------------------------------------------------------
; Set Stack Values. This stack is used by the cache buffer initilization
; portion of the code. This stack area will be eventually overlayed and
; wont be used by either Fastopen or Fastseek functions in MAIN module.
;----------------------------------------------------------------------------
SETUP_STACK:
;  RMFS ;;;;;	nop
	CLI				;no interrupts allowed during stach change
	mov	SS,Stack_Seg_Start	;set up new stack
	mov	SP,STACKSIZE			;
	STI				;interrupts ok now
	jmp	INIT_VECTOR		;Jump to Cseg_Main to do second
					;phase of the initialization
ERROR_EXIT:
	mov	al,1			;set up return code
	mov	ah,exit 		;set function code
	INT	INT_COMMAND		;exit to DOS



;----------------------------------------------------------------------------
;  CHECK_INSTALL
;----------------------------------------------------------------------------
; Input:  None
;
; Output:
;      IF Carry = 0   -  Fastopen is not already installed
;
;      IF Carry = 1   -  Fastopen is already installed
;
;----------------------------------------------------------------------------
;  Use CALLINSTALL macro to see if FASTOPEN is already installed.
;  If carry flag set then FASTOPEN is installed. In this case display
;  Already Installed message.
; Also check for the presence of DOSSHELL switcher being enabled. FASTOPEN 
; should not be installed if the switcher is present.
;----------------------------------------------------------------------------

CHECK_INSTALL	PROC	 NEAR

	push	ax				;save every registers that may
	push	bx				;be destroyed by DOS
	push	cx
	push	dx
	push	si
	push	di
	push	bp

	push	ds
	mov	bx, 1				;Fastopen function code
	mov	si, -1				;special check install code
	CALLINSTALL fastopencom,multdos,42	;see if fastopen installed
	pop	ds

	jnc	Chk_DosShell			; AN_RMFS



Install_Msg:					;installed previously display message
	MOV	AX,ALREADY_INSTALL		;message number
Chk_disp_Msg:	
	MOV	MSG_NUM,AX			;set message number
	MOV	SUBST_COUNT,0			;no message substitution
	MOV	MSG_CLASS,-1			;message class
	MOV	INPUT_FLAG,0			;no input
	CALL	PRINT_STDOUT			;show message "Already Installed"
	stc

Chk_Install_Exit:
	pop	bp				;restore registers
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret					;return

; M0006 BEGIN
; Check for the presence of DOSSHELL Switcher; if present display a message and
; quit
Chk_DosShell:
	mov	ax,4b02h			; see if switcher enabled
	xor	bx,bx
	push	es
	mov	es,bx
	mov 	di,bx				; es:di <- 0 on entry
	int	2fh				
	mov	ax,es
	pop	es
	cmc
	jnc	Chk_Install_Exit		; assume no Switcher
	or	ax,di				; es:di == 0 =>no switcher
	jz	Chk_Install_Exit
	mov	ax,UNDER_DOSSHELL		; display appropriate err msg
	jmp	short Chk_disp_Msg

; M0006 END

CHECK_INSTALL	  ENDP





;----------------------------------------------------------------------------
;  INSTALL_FASTOPEN
;----------------------------------------------------------------------------
; Input:     Addrss of entry point to Fastopen resident code
;
; Output:
;      IF Carry = 0
;	     Entry point to FASTOPEN resident code set
;
;      IF Carry = 1  Error
;
; Calls:     none
;----------------------------------------------------------------------------
;  Use CALLINSTALL macro to see if FASTOPEN is already installed.
;  If FASTOPEN is not installed, install it.
;  If carry flag set then FASTOPEN is installed. In this case display
;  already installed message.
;----------------------------------------------------------------------------

INSTALL_FASTOPEN    PROC    NEAR

	push	ax				;Save every registers,point reg since
	push	bx				;DOS may destroy it.
	push	cx
	push	dx
	push	si
	push	di
	push	bp


	push	ds				;yes - install fastopen
	mov	bx, 1				;tell DOS that this is the
	lds	si,Main_Vector
	CALLINSTALL fastopencom,multdos,42	;see if fastopen installed
	pop	ds
	jnc	Install_Exit			;No error detected


Installx_Msg:					;installed previously display message
	MOV	AX,ALREADY_INSTALL		;message number
	MOV	MSG_NUM,AX			;set message number
	MOV	SUBST_COUNT,0			;no message substitution
	MOV	MSG_CLASS,-1			;message class
	MOV	INPUT_FLAG,0			;no input
	CALL	PRINT_STDOUT			;show message "Already Installed"
	stc

Install_Exit:
	pop	bp		    ;restore registers
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret			    ;return

INSTALL_FASTOPEN    ENDP






;----------------------------------------------------------------------------
;  CHECK_MEM
;----------------------------------------------------------------------------
;  Function:  Compute the total size of memory required by the Fasteopen.
;	      This includes both code and the cache buffers.
;
;  Input:     Name_Count, extent_count, Drive_cache,  num_of_drives
;
;  Output:    Memory is validated, Resident segment size is calculated
;	      Temporary stack segment is set
;----------------------------------------------------------------------------
CHECK_MEM	PROC	NEAR		     ; DS-->Cseg_init

;** Compute the total resident segment size and then add the cache buffer
;** size.  The Resident segment size should be adjusted again after relocation.

;; JUNK ;;	mov	Total_Cache_Size,0	     ;reset total cache size (Name +Ext)
	mov	Name_Cache_Size,0	     ;reset Name cache buffer size
	mov	ax, offset End_Main	     ;size of Main_Seg in bytes
	add	ax,15
	mov	cl,4			     ;convert size to paragraph
	shr	ax,cl			     ;by dividng by 16
	mov	MAIN_Size, ax		     ;save MAIN segment size in para
	add	Res_Segs,ax		     ;update resident seg count

	mov	ax, offset End_Open	     ;size of Open_Seg in bytes
	add	ax,15
	mov	cl,4			     ;convert it to paragraph
	shr	ax,cl
	mov	OPEN_Size, ax		     ;save OPEN segment size in para
	add	RES_SEGS,ax		     ;update resident seg count


;----------------------------------------------------------------------------
; Calculate the size of the NAME DRIVE HEADER BUFFERS
;----------------------------------------------------------------------------
	xor	ax,ax			    ;reset the cache size register


	mov	bx,offset DRIVE_CACHE	    ;get beginning of cache buff
	xor	ax,ax
	mov	al,size drive_cache_header  ;get size of one name entry
	mul	Num_Of_drives		    ;get total needed for drive cache
	add	ax,bx			    ;set up correct offset
	add	ax,15			    ;round up to paragraph boundary
	mov	cl,4
	shr	ax,cl			    ;convert to paragraphs
	add	RES_SEGS,ax		    ;update resident seg count
;; JUNK ;;	mov	Total_Cache_Size, ax	    ;update total cache buff size
	mov	Name_Cache_Size, ax	    ;size in paragraph

; Calculate the offset of the Name cache buffers
	shl	ax,cl			    ;AX = offset to Name cache buff
	mov	NAME_CACHE_BUFF,ax	    ;save Name cache address

;-----------------------------------------------------------------------------
; Compute the size of the NAME CACHE  buffer
;-----------------------------------------------------------------------------
	mov	ax,size Name_Record
	mul	Total_Name_Count
	add	ax,15			    ;round up to paragraph boundary
	mov	cl,4
	shr	ax,cl			    ;convert to paragraphs ( divide 16)
	add	RES_SEGS,ax		    ;AX = End of Name cache buffers
;; JUNK ;;	add	Total_Cache_Size,ax	    ;update total cache buff size
	add	Name_Cache_Size, ax	    ;



;----------------------------------------------------------------------------
; Setup stack segment followed by the extent cache buffers.  This is a
; temporary stack used by the  drive buffer initilization code in the
; Cseg_Main segment.  This stack will be overlayed by the cache buffers.
;----------------------------------------------------------------------------
Set_Stack:
	mov	ax,RES_SEGS		    ;AX=size of code and buffs in para
	add	ax,PSP_Seg		    ;AX=segID of stack
	mov	Stack_Seg_Start,ax	    ;start of the new STACK
	add	ax,STACKSIZE / 16			    ;add the size of the stack
	mov	Stack_Seg_End,ax	    ;get end of what we need
	add	Res_Segs,STACKSIZE / 16		;add stacksize paras ;M001

	push	ds			    ;
	mov	ds,PSP_Seg		    ;access PSP for memory size
	mov	si,Top_mem
	LODSW				    ;get total memory size
	pop	ds
	sub	ax,Stack_Seg_End		    ;see if there is enough for us
	jnc	Check_Reloc_Size		    ;yes, continue ;M000

;M000;	sub	ax,1000h		    ;will there still be 64K ??
;M000;	jnc	Check_Reloc_Size	    ;and return

Not_Enough_Memory:
	MOV	AX,NOT_ENOUGH_MEM	    ;message number
	MOV	MSG_NUM,AX		    ;set message number
	MOV	SUBST_COUNT,0		    ;no message substitution
	MOV	MSG_CLASS,-1		    ;message class
	MOV	INPUT_FLAG,0		    ;no input
	CALL	PRINT_STDOUT		    ;show message "Insufficient Memory"
	stc				    ;set error flag
	jmp	short Set_Mem_Ret	    ;return

;------------------------------------------------------------------------------
; If relocation is needed, then recalculate the size of resident segment
; If extended memory relocation, OPEN, SEEK and INIT segments will be
; eliminated from the current resident seg.
;-----------------------------------------------------------------------------
Check_Reloc_Size:
	cmp	Ext_Mem,0		; extended memory relocation ??
	je	Set_Mem_Exit		; no - exit

;-----------------------------------------------------------------------------
; Check to see that the both code and the cache buffers fit in the
; exteneded memory one 16K page. Since the entire code segment and the
; cache buffers are going to be moved to XMA, that amount should be
; reduced from the size that should reside in the low memory.
;-----------------------------------------------------------------------------

;; RMJUNK ;;	xor	ax,ax
;; RMJUNK ;;	xor	bx,bx

	mov	ax, OPEN_SIZE		;size of Open seg in para
	add	ax, Name_Cache_Size	;size of Init_Seg in para
	cmp	ax, 0400H		;Less than 16K ??
	jge	Not_Enough_Space	;no - display message
;; JUNK ;;	mov	ax, OPEN_SIZE		;size of Open seg in para
;; JUNK ;;	add	ax, Total_Cache_Size	;reduce resident seg size
	sub	RES_SEGS,ax		;update resident seg count

;-----------------------------------------------------------------------------
; If the code is to be moved to extended memory.  There is no reason to
; keep Init_Tree in main memory.  Remove that also to save space in base memory
;-----------------------------------------------------------------------------
	mov	ax, offset End_Main1	;size of Main_Seg until Init_Tree (bytes)
	add	ax,15
	mov	cl,4			;convert size to paragraph
	shr	ax,cl			;by dividng by 16
	mov	bx,Main_Size		;bx=total size of Main seg including Init_Tree
	sub	bx,ax			;bx=size after reducing Init_Tree
	sub	RES_SEGS,bx		;update base memory resident seg count
	jmp	short Set_Mem_Exit
					;
Not_Enough_Space:
	MOV	AX,NO_PAGE_SPACE	; not enough space in EMS page
	MOV	MSG_NUM,AX		; set message number
	MOV	SUBST_COUNT,0		; no message
	MOV	MSG_CLASS,-1		; message class
	MOV	INPUT_FLAG,0		; no input
	CALL	PRINT_STDOUT		; display message
	mov	Ext_Mem, 0		; RESET XMA FLAG
	stc
	jmp	SHORT set_mem_ret

Set_Mem_Exit:
	clc

Set_Mem_Ret:
	ret

CHECK_MEM	endp





;----------------------------------------------------------------------------
;  RELOCATE
;----------------------------------------------------------------------------
;  Function:  Relocate Fastopen code and buffer in base memory or in
;	      Extended Memory.	If base memory relocation, then
;	      relocate Cseg_Seek over Cseg_Open segment if the user
;	      didn't specify Fastopen (n).  Relocate Cseg_Init over Cseg_Seek
;	      if user didn't specify Fastseek feature(m). If extended memory
;	      relocation, copy Cseg_Open, Cseg_Seek and Cseg_Init to
;	      a single page in extented memory if both Fastopen and Fastseek
;	      (n and m) are specified.	Copy Cseg_open and Cseg_Init only if Fastseek
;	      feature (m) is not specified.  Copy Cseg_Seek and Cseg_Init if
;	      FastOpen feature (n) is not specified
;
;----------------------------------------------------------------------------

RELOCATE_SEGMENT    PROC    NEAR

	cmp	Ext_Mem,0			; Extended memory enabled ??

	je	Reloc_Low_Mem			; If not relocate to low memory

;; JUNK ;;	jne	Set_Seg_Ids		; yes - do extented memory relocation
;; JUNK ;;	jmp	SHORT Reloc_Low_Mem	; no - do low memory relocation

;----------------------------------------------------------------------------
; Move Fastopen, FastSeek or both to the Extended memory
;----------------------------------------------------------------------------
Set_Seg_Ids:
	cld				; clear direction flag (increment si and di)

;-----------------------------------------------------------------------------
;	 ----  Extended Memory Relocation -----
;  Setup Cseg_Open segment in Extended Memory
;------------------------------------------------------------------------------
Set_Open_Seg:
	mov	ax,Cseg_Init		;
	mov	ds,ax			; DS-->Cseg_Init
	ASSUME	ds:Cseg_Init
	mov	ax,EMS_Page_Seg 	; AX = seg id of Cseg_Open in ext mem
	mov	Open_SegID,ax		; save it

Copy_Open_Seg:
	mov	ax, offset End_Open	; size of Open seg in bytes
	mov	cl,1
	shr	ax,cl			; convert to words
	mov	cx,ax			; CX = number of WORDS to transfer
	xor	si,si			; offset of the source in low memory
	xor	di,di			; offset of the destination in XMA
	mov	ax,Cseg_Open		; set source segID
	mov	ds,ax			; DS-->Cseg_Open
	ASSUME	ds:Cseg_Open
	mov	ax,Open_SegID		; set destination XMA  seg id
	mov	es,ax			; ES-->Extended memory page
	ASSUME	es:nothing
	REP	MOVSW			; copy Open segment to extended memory
					; SI-->Cseg_Seek segment
	mov	ax,Cseg_Init		; no - only Fastseek specified
	mov	ds,ax			; DS-->Cseg_Init
	ASSUME	ds:Cseg_Init

;-----------------------------------------------------------------------------
;  Setup Cseg_Init segment in Extended Memory
;------------------------------------------------------------------------------
Set_Init_seg:

	sub	ax,Cseg_Open		; AX = size of Open_Cseg+Seek_Cseg
	add	ax,EMS_Page_Seg 	; new Cseg_Init id in XMA if both
	mov	Init_SegID,ax		; Fastopen and Fastseek are enabled

Copy_Init_Seg:				; comes here if no Cseg_Seek is required
	xor	si,si			; offset of the source in low memory
	xor	di,di			; offset of the destination in XMA
	mov	ax, Name_Cache_Size	; size of Init seg area to be copied
	mov	cl,4			; in paragraph
	shl	ax,cl			; convert to number of bytes
	mov	cl,1			;
	shr	ax,cl			; convert to number ofwords
	mov	cx,ax			; CX = number of WORDS to transfer
	mov	ax,Cseg_Init		; set source segID
	mov	ds,ax
	ASSUME	ds:Cseg_Init
	mov	ax,Init_SegID		; set destination XMA  seg id
	mov	es,ax
	ASSUME	es:nothing
	REP	MOVSW			; copy Init segment to extended memory
	jmp	SHORT reloc_exit	; then return


;NOTE:	No need to adjust the resident segment size (Res_Segs) since it is
;	done in the routine (Check_Mem).


;-----------------------------------------------------------------------
;	 ---- LOW MEMORY RELOCATION ----
; Reloctae FastOpen in the low memory and adjust the
; resident size of the code.
;-----------------------------------------------------------------------
Reloc_LOW_Mem:


Reloc_Exit:
; copy the latest RES_SEGS size to Cseg_Main
	mov	ax,Cseg_Init		;
	mov	ds,ax			; DS-->Cseg_Init
	ASSUME	ds:Cseg_Init
	mov	ax,Cseg_Main		; set destination seg id
	mov	es,ax			; ES--> Cseg_Main
	ASSUME	es:Cseg_Main
	mov	ax,Res_Segs
	mov	es:Main_Res_Segs,ax	; save it

	RET

RELOCATE_SEGMENT      ENDP






;-----------------------------------------------------------------------
; Procedure:   COPY_DATA
;-----------------------------------------------------------------------
; Copy data values from Cseg_Init to other segments.  I the code is relocated,
; seg IDs should be updated after relocation.  This is done in "Update_SegID"
;
; Input:     Variables inside Cseg_Open, CsegSeek and Cseg_Main segments
;
; Output:    Data values copied to the above segments
;
;
;-----------------------------------------------------------------------
	public	copy_data
COPY_DATA	PROC	NEAR

	mov	ax,cseg_init
	mov	ds,ax			      ;DS--> Cseg_Init
	ASSUME	ds:Cseg_init
	mov	ax,cseg_Main
	mov	es,ax			      ;ES--> CSEG_MAIN
	ASSUME	es:Cseg_Main

	mov	es:Main_Name_Cache_Seg, Cseg_Init
	mov	ax,Num_Of_Drives
	mov	es:Main_Num_Of_Drives,ax


	mov	ax,Name_Cache_Buff
	mov	es:Main_Name_Cache_Buff,ax
	mov	ax,Name_Drive_Buff
	mov	es:Main_Name_Drive_Buff,ax
	mov	ax,Ems_Flag
	mov	es:Main_EMS_FLAG,ax
	mov	ax,EMS_PAGE_Seg
	mov	es:Main_EMS_PAGE_Seg,ax

IF	BUFFERFLAG
	mov	ax, EMS_PAGE_NUM
	mov	es:ems_page_number, ax	       ;HKN
ELSE
	CMP	EMS_Mem,Static_Alloc	       ; Dynamic allocation ??
	JE	Skip_Save_Num		       ; no - dont save page num
	mov	ax, EMS_PAGE_NUM	       ; save page num for
	mov	es:ems_page_number, ax	       ; Dyna mode page map
Skip_Save_Num:				       ;
ENDIF

	mov	ax,EMS_PAGE_SIZE
	mov	es:Main_EMS_PAGE_SIZE,ax


	mov	ax,Total_Name_Count
	mov	es:Main_Total_Name_Count,ax

; Copy drive buffer to MAIN segment
	 lea   si,ParamBuff
	 lea   di,es:Main_ParamBuff
	 mov   cx,50

Paramloop:
	 mov   al,[si]
	 mov   es:[di],al
	 inc   si
	 inc   di
	 LOOP  paramloop

;-----------------------------------------------------------------------
; Copy data values to OPEN segment (Cseg_Open)
;-----------------------------------------------------------------------
	mov	ax,cseg_Open
	mov	es,ax			      ;ES--> CSEG_Open
	ASSUME	es:Cseg_Open
	mov	si,offset drive_cache
	mov	es:Open_Name_Drive_Buff,si
	mov	es:Open_Name_Cache_Seg,Cseg_Init
	mov	ax,check_Queue
	mov	es:chk_Flag,ax


	mov	ax,cseg_Init
	mov	es,ax			      ;ES addressability to CSEG_Init
	ASSUME	es:Cseg_Init

	ret

COPY_DATA	ENDP




;-----------------------------------------------------------------------
; Procedure:   ADJUST_SEGIDS
;-----------------------------------------------------------------------
; Function:  Adjust segment Ids of various segments after relocation
;
; Input:   SegID Vectors
;
; Output:  SegIDs vectors are adjusted
;
; Note: The following segid and vectors are set previously either during
;	link time or during initialization time.  These SegIDS needs to
;	be changed after the code and buffers are relocated.
;-----------------------------------------------------------------------

ADJUST_SEGIDS	PROC	NEAR

	mov	ax,Cseg_Init
	mov	ds,ax			      ;DS addressability to Cseg_Init
	ASSUME	ds:Cseg_init
	mov	ax,cseg_Main
	mov	es,ax			      ;ES addressability to CSEG_MAIN
	ASSUME	es:Cseg_Main

	mov	bx, Init_segID		      ; copy seg ID of Init_Seg to
	mov	es:Main_Name_Cache_Seg, bx    ; Main seg


	mov	ax,Open_SegID
	mov	es,ax			      ; ES addressability to CSEG_Open
	ASSUME	es:Cseg_Open		      ; copy segid of init_seg to
	mov	es:Open_Name_Cache_Seg, bx    ; Open segment



; Adjust seg ids of jump vectors to Fastopen and Fastseek functions
Adjust_Vectors:
	mov	ax,cseg_Main
	mov	es,ax			      ;ES addressability to CSEG_MAIN
	ASSUME	es:Cseg_Main
					      ;DS addressability to Cseg_Init
	mov	ax, Open_SegID
	mov	word ptr es:FOPEN_Insert + word, ax
	mov	word ptr es:FOPEN_Update + word, ax
	mov	word ptr es:FOPEN_Delete + word, ax
	mov	word ptr es:FOPEN_Lookup + word, ax
	mov	word ptr es:FOPEN_Purge + word, ax						   ;TEL 9/29
;M007
; Update the segment of the Rename routine also
;
	mov	word ptr es:FOPEN_Rename + word, ax ;M007


; Change the segID of single Jump Vector inside Cseg_Main
	mov	ax,cseg_Main
	mov	es,ax			      ;ES addressability to CSEG_MAIN
	ASSUME	es:Cseg_Main
	mov	ax,Open_SegID
	mov	word ptr es:Vector_LookUp + word, ax						  ;AN000;



Adjust_Exit:
	ret
					      ;return
ADJUST_SEGIDS	ENDP








;******************************************************************************
; *
; *	 MODULE: PARSE
; *
; *	 FUNCTION: Parse  command line
; *
; *	 INPUT: FASTOPEN  d: {=n | (n,m) } ... /x  
; *		   where  activates queue analyser for debugging
; *
; *	 OUTPUT:   Command line is parsed
; *		   For IBM:
; *		   [Ext_MEM] = 0  if no EMS enabled
; *			     = 1  if EMS enabled with /XS static allocation
; *			     = 2  if EMS enabled with /X  default dynamic allocation
; *			     = 2  if EMS enabled with /XD dynamic allocation
; *
; *	 RETURN SEQUENCE:
; *
; *		   If CY = 0	No error
; *
; *		   If CY = 1	Error
; *
; *	 EXTERNAL REFERENCES:	SYSPARSE
; *
; *************************************************************************

EOL	       EQU   -1 	   ; Indicator for End-Of-Line
NOERROR        EQU    0 	   ; Return Indicator for No Errors

	 public   PARSE
PARSE	 PROC	  NEAR

	 mov   num_of_drives,0	   ; initialize drive count
	 mov   name_count,0


	 mov   Total_name_count,0


	 mov   Prev_Type,0

	 mov	Ext_Mem,0

	 mov   Check_Queue,0
	 lea   si,parambuff	    ; drive ID buff address
	 mov   parmbuff_Ptr,si	    ; save it

;----------------------------------------------------------------------------
; Get command string address from PSP
;----------------------------------------------------------------------------
	 mov   si,0081H
	 mov   ah,62H
	 INT   21H		   ; get program PSP segment
	 mov   PSP_Seg,bx	   ; save PSP segment

	 mov   ds,bx		   ; DS = PSP segment
	 mov   si,0081h 	   ; SI-->beginning of parameter string in PSP
	 lea   di,cmdline_buff	   ; DI-->command param buffer
	 mov   cx,127		   ; copy 127 bytes from PSP
	 rep movsb

	 push  cs
	 pop   ds

;----------------------------------------------------------------------------
; set parametrs for SysParse call
;----------------------------------------------------------------------------
	 xor   cx,cx		   ; no params processed so far
	 MOV  ORDINAL,CX	   ; SAVE initial ordinal value
	 lea   si,cmdline_buff	   ; ES:SI-->command line
	 lea   di,parms 	   ; ES:DI-->parameter
	 MOV  CURRENT_PARM,SI	   ; pointer to next positional

	 mov   ax,0100h 	   ; Drive only
	 mov   pos1type,ax	   ; set positional control block 1
	 mov   ax,08502h	   ; Numeric/Complex/Drive/Repeat
	 mov   pos2type,ax	   ; set positional control block 2
	 mov   al,1		   ; minimum 1 positional
	 mov   Par_Min,al	   ;
	 mov   al,2
	 mov   Par_Max,al	   ; maximum 1 positional
	 jmp   short set_param

;----------------------------------------------------------------------------
;   MAIN PARSE LOOP
;----------------------------------------------------------------------------
PARSE_LOOP:			   ; MAIN PARSE LOOP
	 mov   ax,08502h	   ; number/drive ID/comlex/repeat
	 mov   pos1type,ax	   ; set positional control block
	 mov   ax,08502h	   ;
	 mov   pos2type,ax	   ;
	 mov   al,1		   ; minimum 1 positional
	 mov   Par_Min,al	   ; set min
	 mov   al,2		   ; maximum 2 positionals
	 mov   Par_Max,al	   ; set max
	 mov   par_sw,NUM_SWITCHES ; set number of switches to check

Set_Param:
	 xor   dx,dx
	 push  cs
	 pop   es		   ; ES=DS=CS
	 LEA  DI,PARMS		   ; ES:DI = PARSE CONTROL DEFINITON
	 MOV  SI,CURRENT_PARM	   ; DS:SI = next positional
	 XOR  DX,DX		   ; RESERVED, INIT TO ZERO
	 MOV  CX,ORDINAL	   ; OPERAND ORDINAL, INITIALLY

	 CALL  SYSPARSE 	   ; Parse current positional

	 mov   Next_Parm,si	   ; save pointer to next positional
	 mov   ORDINAL,CX	   ; save current ordinal
	 cmp   ax,EOL		   ; END-OF-COMMAND string ??
	 jne   Parse_chk_Error	   ; no -  check error


;----------------------------------------------------------------------------
; If previous positional is a drive ID without Name or Extent count then assign
; default counts .
;----------------------------------------------------------------------------
	 cmp   Prev_Type,6	   ; previous param = drive ID
	 jne   Take_Exit	   ; no - exit

	 CALL  PROC_DEFAULT	   ; yes - setup default counts for previous drive
	 jnc   Take_Exit	   ; exit
	 jmp   parse_Error	   ; error exit

Take_Exit:
	 CALL  Verify_Counts	   ; verify the Total counts
	 jnc   Counts_OK	   ; exit if count ok
	 jmp   parse_error	   ; else error exit

Counts_Ok:
	 jmp   parse_exit	   ; normal - exit


;----------------------------------------------------------------------------
;	CHECK ERROR CONDITIONS
;----------------------------------------------------------------------------

	PUBLIC	Parse_Chk_Error
Parse_Chk_Error:		   ; check for error conditions
	 cmp   ax,NOERROR	   ; any parse error ??
	 jne   verify_missing_oper ; yes - check missing operand
	 jmp   Chk_Result	   ; no - check result buffer

Verify_Missing_Oper:
	 cmp   ax,2		   ; yes - missing operand error??
	 jne   disp_error	   ; no - jump

	 cmp   Prev_Type,0	   ; yes - any previous parameters ??
	 jne   Chk_Prev_Drive	   ; yes, previous drive id
	 mov	 MSG_CLASS,2
	 MOV	 MSG_NUM,AX	   ; set message number
	 MOV	 SUBST_COUNT,0	   ; no message substitution
	 MOV	 INPUT_FLAG,0	   ; no input
	 CALL	 PRINT_STDOUT	   ; show message
	 stc			   ; set error flag
	 jmp   Parse_Exit	   ; exit

;----------------------------------------------------------------------------
; If previous positional is drive ID without counts then assign default counts
;----------------------------------------------------------------------------
Chk_prev_drive:
	 cmp   Prev_Type,6	   ; previous param = drive ID ??
	 jne   Take_Exit1	   ; no - exit

	 CALL  PROC_DEFAULT	   ; yes - assign default ID
	 jnc   Take_Exit1	   ; no error, verify counts
	 jmp   parse_Error	   ; error exit

Take_Exit1:
	 CALL  Verify_Counts	   ; verify the Total counts
	 jnc   Counts_right	   ; count ok - check special case
	 jmp   parse_error	   ; error - exit

Counts_right:
	 cmp   Prev_Type,0	   ; no previous param ?  (Special case)
	 je    invalid_operand	   ; no, exit ( FASTOPEN >TEMP ) case
	 clc
	 jmp   parse_exit	   ; exit

Invalid_Operand:		   ; else error
	 jmp   SHORT bad_param

Disp_Error:
	 cmp   ax, 3		   ; invalid switch type ??
	 jne   bad_param	   ; no -
	 jmp   Bad_Switch

;----------------------------------------------------------------------------
; If user entered  to activate the analyser, than verify the previous
; drive case. If true, assign default name extent entries, set activation
; flag and take normal exit.
;----------------------------------------------------------------------------
Bad_Param:
	mov   si,Current_Parm	   ; SI-->current parameter (analyser hook)
	mov   al,0e0h		   ;  (hidden character to activate analyser)
	cmp   [si],al		   ; activate analyser ??
	jne   set_disp_param	   ; no - normal error
	mov   Check_Queue,1	   ; yes - set flag to activate analyser
	clc
	jmp   Chk_Prev_Drive	   ; exit

Set_Disp_Param:
	mov   di,Next_Parm	  ; ending address of bad param  (1/6/88)
	mov   al,0
	mov   ds:[di],al	   ; set termination character
	LEA   SI,SUBLIST1	  ; DS:SI-->Substitution list
	MOV   AX,CURRENT_PARM	  ; starting address of bad parameter
	MOV   [SI].DATA_OFF,AX	  ; SI-->File name
	MOV   [SI].DATA_SEG,DS	  ; DS-->Segment
	MOV   [SI].MSG_ID,0	  ; message ID
	MOV   [SI].FLAGS,010H	  ; ASCIIZ string, left align
	MOV   [SI].MAX_WIDTH,0	  ; MAXIMUM FIELD WITH
	MOV   [SI].MIN_WIDTH,0	  ; MINIMUM FIELD WITH
	mov   ax,incorrect_param  ; Error Code
	MOV   MSG_NUM,AX	  ; set message number
	MOV   SUBST_COUNT,1	  ; substitution count
	MOV   MSG_CLASS,-1	  ; message class
	MOV   INPUT_FLAG,0	  ; no input
	CALL  PRINT_STDOUT	  ; display message
	stc			  ; error flag
	jmp   Parse_Exit	  ; exit		      (1/6/88 P2670)


;----------------------------------------------------------------------------
;	CHECK POSITIONAL PARAMETER TYPE
;----------------------------------------------------------------------------
Chk_Result:
	 push  es		   ; get DS back to Program data segment
	 pop   ds
	 cmp   postype,1	   ; number  ??
	 jne   chk_switch
	 jmp   short Proc_Name	   ; yes, process name entry

chk_switch:
	 cmp   postype,3	   ; switch  ??
	 je    Proc_sw		   ; yes, process switch
	 cmp   postype,6	   ; drive id ??
	 je    Proc_driveid	   ; yes, Process Drive ID
	 cmp   postype,4	   ; complex item ??
	 jne   disp_msg
	 jmp   Proc_complex	   ; yes, process Complex item

disp_msg:
	 mov   ax,incorrect_param  ; no, check reult buffer
	 jmp   bad_param	   ; else error

Proc_Sw: jmp   Proc_Switch	   ; process switch



;----------------------------------------------------------------------------
;	    PROCESS  DRIVE ID
;----------------------------------------------------------------------------
PROC_DRIVEID:			   ; PROCESS DRIVE ID
	 cmp   Prev_Type,6	   ; previous param = drive ID
	 jne   check_drive_id	   ; no, jump

; if not set default name and extent entry count for previous drive
	 CALL  PROC_DEFAULT	  ;  setup default counts
	 jnc   Check_Drive_id	  ;
	 jmp   parse_Error

Check_Drive_Id: 		   ; process current drive ID
	 mov   ax,ValueLo	   ; get drive letter number from result buff
				   ; C:=3 D:=4 etc, Parser drive id convention
	 add   al,040H		   ; convert to drive letter

	 CALL  CHECK_DRIVE	   ; validate drive ID ??
	 jnc   set_drive_id	   ; yes, jump
	 jmp   Parse_Exit	   ; no, invalid drive id , exit

Set_Drive_Id:
	 inc   num_of_drives	   ; update the drive count
	 xor   ax,ax
	 mov   ax,valuelo	   ; get drive number
	 xor   ah,ah		   ; only low byte is valid
	 mov   di,ParmBuff_Ptr	   ; DS:DI-->driveID buffer
	 dec   ax		   ; C:=2  D:=3 E:=4 etc Fastopen drive id
	 mov   [di],ax		   ; save drive in Drive ID table
	 add   parmbuff_ptr,2	   ; points to next extent count area
	 mov   al,PosTYpe	   ; set previous type before look for next
	 mov   Prev_Type,al	   ; positional parameter
	 mov   si,Next_Parm	   ; get pointer to next param (switch)
	 mov   Current_Parm,si	   ;
	 jmp   Parse_Loop	   ; look for next posistional parameter


;----------------------------------------------------------------------------
;	PROCESS INTEGER ( C:=n )  followed by drive ID
;----------------------------------------------------------------------------
PROC_NAME:
	 cmp   Prev_Type, 6	   ; previous type = drive ID
	 je    Get_Name_Value	   ; yes - jump
	 mov   ax,incorrect_param  ; error code
	 jmp   bad_param

Get_Name_Value:
	 xor   ax,ax
	 mov   ax,valuelo	   ; get name value
	 cmp   ax,10		   ; check validity of the count
	 jl    Bad_Name_Count
	 cmp   ax,999
	 jle   save_name_count	   ; count OK, save it

Bad_Name_Count: 		   ; bad name count
	 mov   ax,Invalid_Name	   ; error code
	 jmp   parse_error	   ; error - exit

Save_Name_Count:
	 mov   name_count,ax	   ; save it (name count)
	 add   Total_Name_Count,ax ; update total name count
	 mov   di,ParmBuff_Ptr	   ; DS:DI-->driveID buffer
	 mov   ax,-1
	 mov   [di],ax		   ; MARK this drive has no extent entry
	 add   parmbuff_ptr,2	   ; points to extent count area

Set_Drive_Hdr:
	 mov   ax,Name_Count	   ; get name count entry
	 CALL  SET_DRIVE_CACHE_HEADER	; Set Name cache header
	 jnc   set_min_max	   ; no error set min and max
	 jmp   parse_Error	   ; display error

Set_Min_Max:
	 mov   al,1
	 mov   Par_Min,al	   ; change min-max
	 mov   al,2
	 mov   Par_Max,al
	 mov   al,PosTYpe	   ; set previous type before look for next
	 mov   Prev_Type,al
	 mov   si,Next_Parm	   ; get pointer to next param (switch)
	 mov   Current_Parm,si	   ;
	 mov   ordinal,0
	 Jmp   Parse_Loop	   ; parse nexy positional


;----------------------------------------------------------------------------
;	 PROCESS COMPLEX (n,m)	followed by a drive id
;----------------------------------------------------------------------------
	public	proc_complex	; for debugging
PROC_COMPLEX:
	 cmp   Prev_Type, 6	  ; previous type = drive ID ??
	 je    Get_Cmplx_Item	  ; yes - ok
	 mov   ax,incorrect_param ; no - error, previous must be drive id
	 jmp   bad_param	  ; display error

Get_Cmplx_Item:
	 mov   al, PosType	  ;
	 mov   Prev_Type,al	  ; save current type as previous
	 lea   di,valuelo	  ; DI-->result buffer
	 mov   si,[di]		  ; get next positional param address
	 mov   current_parm,si	  ; SI-->first complex item
	 mov   ax,08001h	  ; Control ( Numeric/Optional )
	 mov   Pos1Type,ax	  ; change pos-param control block flag
	 mov   Pos2Type,ax
	 mov   Par_Min,al	  ; set minimum = 1
	 inc   al
	 mov   Par_Max,al	  ; set maximum = 2
	 mov   ordinal1,0	  ; initialize ordinal for complex item loop
	 mov   par_sw,0 	  ; reset switch flag in PARMSX

COMPLX_LOOP:
	 LEA  DI,PARMS		   ;ES:DI = PARSE CONTROL DEFINITON
	 MOV  SI,CURRENT_PARM	   ;SI = COMMAND STRING, NEXT PARM
	 XOR  DX,DX		   ;RESERVED, INIT TO ZERO
	 MOV  CX,ORDINAL1	   ;OPERAND ORDINAL, INITIALLY ZERO

	 CALL  SYSPARSE 	   ; parse positional param in complex item

	 cmp   ax,NOERROR	   ; parse error ??
	 je    Chk_Complex_Result  ; no, check result buffer
	 cmp   ax,EOL		   ; END-OF-COMMAND string ??
	 jne   Complex_Error	   ; no, check error
	 mov   si,Next_Parm	   ; Set pointer to next param	       (4/3/88)
	 mov   Current_Parm,si	   ; set next param address before parsing
	 jmp   Parse_Loop	   ; go to main parse loop

Complex_Error:
	 mov   ax,Incorrect_Param  ; no, check reult buffer
	 jmp   bad_param	   ; display error

;-------------------------------------------------------------------------------
;    Ckeck The Result Buffer
;-------------------------------------------------------------------------------
Chk_Complex_Result:
	 mov   ordinal1,cx	   ; save current ordinal
	 cmp   postype,1	   ; positional type = number  ??
	 je    Proc_Complex_Name   ; yes, process name entry
	 cmp   postype,3	   ; positional type = String ??
	 je    Miss_param	   ; yes, process missing parameter
	 mov   ax,incorrect_param  ; no, check reult buffer
	 jmp   bad_param

Miss_Param:
	 mov   ax,Default_Names    ; default name cache size ;M002  M003
	 mov   current_parm,si	   ; save current chara pointer  ;M002
	 jmp   short Store_Name_Count	   ; get extent count    ;M002


;-------------------------------------------------------------------------------
;   PROCESS NAME  ENTRY  (n)
;-------------------------------------------------------------------------------
Proc_Complex_Name:		   ; PROCESS COMPLEX ITEM
	 mov   current_parm,si	   ; save current chara pointer
	 cmp   cx,1		   ; ignore past first parameter
	 ja    complx_loop
	 xor   ax,ax		   ; eles process Name Count
	 mov   ax,valuelo	   ; get name value from result buffer
	 cmp   ax,10		   ; validate the name value for higher
	 jl    Name_Error	   ; and lower boundries
	 cmp   ax,Max_Entry_Num    ; name entry count ok ??
	 jg    Name_Error	   ; no - error
	 jmp   short Store_Name_Count	 ; yes - store it

Name_Error:			   ; invalid name count
	 mov   ax,invalid_name	   ; error code
	 jmp   parse_error	   ; display error

Store_Name_Count:
	 mov   Name_Count,ax	   ; save it (name count)
	 add   Total_name_count,ax ; update total name count

	 mov   di,ParmBuff_Ptr	   ; advance pointer into parameter buffer
	 mov   word ptr [di],-1    ; indicate no extent cache
	 add   ParmBuff_Ptr,2

	 CALL  SET_DRIVE_CACHE_HEADER	; Set Name cache header
	 jc    Cant_Set_Header	   ; jump if error
	 jmp   Complx_loop	   ; look for extent count

Cant_Set_Header:
	 jmp   Parse_Error	   ; error exit


;----------------------------------------------------------------------------
;	    PROCESS SWITCHES (/ OPTIONS)
;----------------------------------------------------------------------------

	PUBLIC	Proc_Switch
Proc_Switch:

; Check for other (non /X) switches first.
; The bulk of the remaining code (below
; ProcSwitchX) seems to be for just /X.

	cmp	[synonym], offset Sw_?_Syn	; /? found?
	jne	ProcSwitch?Done			;  skip this if not
	call	DISPLAY_OPTIONS			; else print msg
	stc					; set error flag
	jmp	Parse_Exit			; EXIT
ProcSwitch?Done:

; Check for the /X (Expanded Memory) switch.

ProcSwitchX:
	 cmp   Prev_Type,0	   ; any previous type ??
	 je    Switch_Error	   ; no  - error
	 cmp   Ext_Mem,0	   ; switch previously specified ??
	 je    set_sw_flag	   ; no, set flag

Switch_Error:
	 mov   ax,incorrect_param  ; error code
	 jmp   bad_param	   ; error - /x could be specified only once

Set_Sw_flag:
	 cmp   Prev_Type,6	   ; previous param = drive ID	12/15 P2939
	 jne   sw_save_Ptr	   ; no - continue		12/15 p2939

	 CALL  PROC_DEFAULT	   ; yes setup default counts for previous drive
	 jnc   sw_save_ptr	   ; no error - continue	12/15 p2939
	 jmp   short parse_Error   ; error - exit		12/15 P2939

Sw_save_ptr:
	 mov   current_parm,si	   ; save current chara pointer
	 mov   bx,synonym	   ; get synonym (/x)
	 cmp   bx,offset e_switch  ; /X ??
	 je    set_extflag	   ; yes - check result buffer
	 jmp   SHORT Bad_Switch	   ; error exit

Set_ExtFlag:			   ; no, check reult buffer
	 mov   Ext_Mem,1	   ; yes, set Hi Memory flag
	 mov   si,Current_parm	   ; -->next parameter
	 mov   al,PosTYpe	   ; set prevvious type before look for next
	 mov   Prev_Type,al
	 jmp   parse_loop

Bad_Switch:
	mov   di,Next_Parm	  ; ending address of bad param  1/6/88
	mov   al,0
	mov   ds:[di],al	   ; set termination character
	LEA   SI,SUBLIST1	  ; DS:SI-->Substitution list
	MOV   AX,CURRENT_PARM	  ; starting address of bad parameter
	MOV   [SI].DATA_OFF,AX	  ; SI-->File name
	MOV   [SI].DATA_SEG,DS	  ; DS-->Segment
	MOV   [SI].MSG_ID,0	  ; message ID
	MOV   [SI].FLAGS,010H	  ; ASCIIZ string, left align
	MOV   [SI].MAX_WIDTH,0	  ; MAXIMUM FIELD WITH
	MOV   [SI].MIN_WIDTH,0	  ; MINIMUM FIELD WITH
	MOV   BX,Invalid_Switch   ; get message number
	MOV   MSG_NUM,BX	  ; set message number
	MOV   SUBST_COUNT,1	  ; substitution count
	MOV   MSG_CLASS,-1	  ; message class
	MOV   INPUT_FLAG,0	  ; no input
	CALL  PRINT_STDOUT	  ; display message
	stc			  ; error flag
	jmp   SHORT Parse_Exit	  ; exit		      (1/6/88 P2670)



;----------------------------------------------------------------------------
;	      PROCESS PARSE ERROR
;----------------------------------------------------------------------------
PARSE_ERROR:			   ; AX = meassage number
	MOV	MSG_CLASS,-1	   ; message class
	MOV	MSG_NUM,AX	   ; set message number
	MOV	SUBST_COUNT,0	   ; no message substitution
	MOV	INPUT_FLAG,0	   ; no input
	CALL	PRINT_STDOUT	   ; show message
	stc			   ; set error flag

Parse_Exit:			   ; EXIT
	push	cs
	pop	ds		   ; DS - Program data area seg
	ret
PARSE	ENDP			   ; end of parser


;----------------------------------------------------------------------------
;
; Procedure:  DISPLAY_OPTIONS
;
; Function:   Display the options help message lines on standard output.
;
;----------------------------------------------------------------------------

DISPLAY_OPTIONS	PROC NEAR

	mov	[MSG_NUM], MSG_OPTIONS_FIRST	; set first message number
	mov	[MSG_CLASS], -1	   		; message class
	mov	[SUBST_COUNT], 0	   	; no message substitution
	mov	[INPUT_FLAG], 0	   		; no input
DO_LOOP:
	call	PRINT_STDOUT	   		; show message
	cmp	[MSG_NUM], MSG_OPTIONS_LAST	; last message?
	je	DO_DONE				; done if so
	inc	[MSG_NUM]			; else bump msg number
	jmp	short DO_LOOP			;  and go do it
DO_DONE:
	ret					; return

DISPLAY_OPTIONS ENDP


;----------------------------------------------------------------------------
;
; Procedure:  PROC_DEFAULT
;
; Function:   Process default parameters if name and extend counts
;	      are not specified with the drive id.
;
;----------------------------------------------------------------------------

PROC_DEFAULT	PROC		   ; PROCESS DEFAULT
	 push  si		   ; makesure to save next chara pointer
	 mov   ax,Default_names    ; get default name count M003
	 mov   name_count,ax	   ; save it
	 add   Total_name_count,ax ; update total name count


	 mov   di,ParmBuff_Ptr	   ; DS:DI-->parameter buffer
	 mov   [di],ax		   ; save in buffer
	 add   Parmbuff_ptr,2	   ; points to next drive id position
	 mov   ax,Name_Count
	 CALL  Set_drive_Cache_Header	; Set Name cache header

Default_Exit:
	 pop   si
	 ret			   ; return

PROC_DEFAULT   ENDP


;----------------------------------------------------------------------------
; Procedure:   VERIFY_COUNTS
;
; Function:    Verify the validity of the name and extent counts

;----------------------------------------------------------------------------
VERIFY_COUNTS	PROC   NEAR

; Check the validity of NAME and EXTENT count entries


Chk_Name_Count:

	cmp	Total_name_count, Max_Entry_Num
	jg	invalid_name_entry
	clc				 ; Name count is OK
	jmp	short verify_exit	 ; exit


Invalid_name_entry:
	mov	ax,many_name_entries	 ; AX = error code
	stc

Verify_Exit:		     ;

	RET

VERIFY_COUNTS	ENDP











;=========================================================================
; CHECK_DRIVE
;-----------------------------------------------------------------------
;
;  INPUT:  AL - Drive letter
;
;  OUTPUT:
;	   If Carry = 0
;	     user_drive       set to current entered drive letter
;	     num_Of_drives  incremented
;	   If Carry = 1       error
;-----------------------------------------------------------------------
; 1) see if drive is valid and removable using int 21h IOCTL
;
; 2) use int 21h name translate to make sure that the drive is not
;    redirected, substed, on another machine, or in any other way shape
;    or form hosed.
;=========================================================================

CHECK_DRIVE    PROC    NEAR

	CALL	Convert_To_Caps 	; make sure it is a capital letter
	mov	byte ptr user_drive,al	; save it in user drive
	mov	byte ptr source_xname,al ; put in source string for call

	mov	bl,al			;put drive letter in bl
	sub	bl,"A"-1                ;convert to 1 based number

	mov	ah,ioctl		;set up for removable call
	mov	al,8			;function code
	INT	int_command

	cmp	ax,1			;is drive fixed?
	jz	okay_drive		;yes - see if it's subst
	cmp	ax,0fh			;is drive valid?
	jnz	hosed_drive		;yes - but hosed

	mov	ax,invalid_drive	; set bad drive message
	jmp	short drive_Error	; display error message

Okay_Drive:
        mov     ah,ioctl                ;set up for network call          ;*EGH
        mov     al,9                    ;function code                    ;*EGH
        INT     int_command             ;                                 ;*EGH
        test    dx,1000H                ;Q: is drive local?               ;*EGH
        jnz     hosed_drive             ; N: drive is hosed               ;*EGH
                                                                          ;*EGH
        lea     si,source_xname         ; set up for name translate
	lea	di,target_xname
	mov	ax,xNameTrans SHL 8
	INT	int_command		;do the translation

	lea	si,source_xname 	;compare source and target drive
	lea	di,target_xname

	mov	cx,Len_source_xname	;get count of invalid chars
	repz	cmpsb			;compare until mismatch found
	jz	check_drive_end 	;no mismatch - exit

Hosed_Drive:
	MOV   AX,BAD_USE_MESSAGE	 ; message number

Drive_Error:
	push  ax		  ; save message number
	mov   ax,Valuelo	  ; get drive letter number from result buff
				  ; C:=3 D:=4 etc, Parser drive id convention
	add   al,040H		  ; convert to drive letter
	lea   si,Drive_Id	  ; DS:SI-->drive letter save area
	mov   [si],al		  ; save drive letter in buffer

	LEA   SI,SUBLIST1	  ; DS:SI-->Substitution list
	MOV   AX,OFFSET DRIVE_ID
	MOV   [SI].DATA_OFF,AX	  ; SI-->File name
	MOV   [SI].DATA_SEG,DS	  ; DS-->Segment
	MOV   [SI].MSG_ID,1	  ; message ID
	MOV   [SI].FLAGS,010H	  ; ASCIIZ string, left align
	MOV   [SI].MAX_WIDTH,0	  ; MAXIMUM FIELD WITH
	MOV   [SI].MIN_WIDTH,0	  ; MINIMUM FIELD WITH
	POP   AX		  ; restore message number
	MOV   MSG_NUM,AX	  ; set message number
	MOV   SUBST_COUNT,1	  ; substitution count
	MOV   MSG_CLASS,-1	  ; message class
	MOV   INPUT_FLAG,0	  ; no input
	CALL  PRINT_STDOUT	  ; display message
	stc			  ; error flag

Check_Drive_End:
	ret			  ; return

CHECK_DRIVE  endp





;=========================================================================
;  Procedure:  SET_DRIVE_CACHE_HEADER
;
;  Function: Set name cache drive header
;
;  Input:  ax		    contains number of entries for num_entries
;	   user_drive	    contains user drive for drive_letter
;	   num_Of_drives  contains number of caches set up so far
;	   drive_cache	    offset of drive cache headers start
;  Output:
;	   If successful:
;	     drive cache header set up
;	     user_drive 	reset to blank
;	     num_Of_drives    incremented
;	   else
;	     bx 	      set to error flag
;	     dx 	      points to error message
;-----------------------------------------------------------------------
; 1) see if drive too many drives have been entered.
; 2) Walk through drive cache headers to make sure that the drive
;    letter was not previously entered.
; 3) Set up drive cache header
;=========================================================================

	public	set_drive_cache_header
SET_DRIVE_CACHE_HEADER	 PROC	 NEAR

	mov	cx,num_of_drives	  ;get current count of drives
	mov	bx,offset drive_cache	  ;get start of name drive cache
	mov	dl,user_drive		  ;get user entered drive
	dec	cx			  ;is this the 1st drive entered ?
	jcxz	set_it_up		  ;yes - don't check

	cmp	num_Of_drives,max_drives  ;no - check for maximum num of drives
	jng	we_have_room		  ;yes - go check for dup drives
	mov	ax,too_many_entries	  ;set up for error message
	stc				  ;set up error flag
	jmp	short set_dheader_exit	  ;and exit

;-----------------------------------------------------------------------
; Search through the drive headers to see the duplicate drive exist.
; If a new drive header at the bottom of the chain for the new drive.
; If no drives exist, then create the new header as the first drive header.
;-----------------------------------------------------------------------
We_Have_Room:				  ;BX-->current drive header
	cmp	dl,[bx].dch_drive_letter  ;drive header exist for this drive??
	jnz	not_dup_drive		  ;no - continue
	mov	ax,dup_drive		  ;yes - set up for error message
	stc
	jmp	short set_dheader_exit	  ;exit

Not_Dup_Drive:
	cmp	[bx].dch_sibling_ptr,no_siblings  ;any more header to search ??
	jz	set_drive_sibling		  ;no - go create the new drive header
	add	bx,size drive_cache_header	  ;yes - get pointer to next drive header
	jmp short we_have_room			  ;check it

Set_drive_sibling:
	mov	cx,bx				  ;save current header address
	add	cx,size drive_cache_header	  ;pointer to next header
	mov	[bx].dch_sibling_ptr,cx 	  ;set pointer to new header from current hdr
	mov	bx,cx				  ;BX-->new header

Set_it_up:
	mov	[bx].dch_drive_letter,dl	  ;save drive letter in new header
	mov	[bx].dch_sibling_ptr,no_siblings  ;mark new header as last header in chain
	mov	[bx].dch_num_entries,ax 	  ;save name count in new header

Set_dheader_Exit:				  ; Exit
	ret

SET_DRIVE_CACHE_HEADER	 ENDP





subttl	Convert to caps
page
;=========================================================================
; Procedure: Convert_to_caps
;
; CONVERT LOWER CASE CHARACTERS TO UPPER CASE
; Convert character in al to a capital letter.

;=========================================================================

CONVERT_TO_CAPS    PROC     NEAR

	cmp	al,"a"
	JNAE	no_convert
	cmp	al,"z"
	JNBE	no_convert
	sub	al,32

No_Convert:
	ret					;and return

CONVERT_TO_CAPS    ENDP







;=========================================================================
; SET_EMS		: THIS MODULE SETS EMS FOR FASTOPEN CODE AND DATA
;			  PAGE 0 IN HIGH MEMORY IS MAPPED FOR CODE USING
;			  THE PHYSICAL PAGE FRAME  AND PAGE 1 IS
;			  MAPPED FOR DATA USING PHYSICAL PAGE FRAME NUMBER
;			  TWO PHYSICAL PAGE FRAME SEG IDs ARE SAVED AND
;			  THEY WILL BE USED BY THE (MAIN) ROUTINE.
;
;			For IBM:
;			  Dynamic Page allocation buffers are running in the
;			  dynamic page allocation mode.
;
;			  Dynamic Page mode is also selected if buffers are
;			  running in the base memory.
;
;			  Static meode is selected if Buffers are running in
;			  the static mode.
;
;
;	INPUTS		: NONE
;
;	OUTPUTS 	: CY  - ERROR
;
;			  NC  - EMS_PAGE_SEG - SEG ID OF SINGLE PAGE FRAME
;=========================================================================

SET_EMS  PROC  NEAR
	CALL	EMS_CHECK1		;SEE IF EMS INSTALLED
	JNC	EMS_GET_PAGE		; yes, get page

	MOV	EMS_FLAG,0		;  Flag EMS not installed
	JMP	EMS_EXIT	  ;  Leave check routine

EMS_GET_PAGE:
	PUSH	ES			; save ES,DI they may destroy by 2F
	PUSH	DI

IF	NOT BUFFERFLAG

	MOV	AH,EMS_2F_HANDLER
	XOR	AL,AL
	INT	2FH			; see 2F is there
	CMP	AL,0FFH
	JNE	EMS_SET_DYNAMIC 	; INT 2F handler no there, run in Dynamic mode

	MOV	EXT_MEM, STATIC_ALLOC	;AN002; Set static allocation mode
	MOV	EMS_FLAG, STATIC_ALLOC
	MOV	AH,EMS_2F_HANDLER
	MOV	AL,0FFH
	MOV	DI,0FEH
	INT	2FH		       ; get EMS page
	OR	AH,AH
	JNZ	EMS_PAGE_ERR
	MOV	EMS_PAGE_SEG,ES        ; SAVE PAGE SEG ID
	MOV	EMS_PAGE_NUM,DI        ; SAVE PHYSICAL PAGE NUMBER
	JMP	SKIP_DYNA_PAGE		; CONTINUE

EMS_SET_DYNAMIC:
	MOV	EXT_MEM, DYNA_ALLOC    ;AN002; Set dynamic mode
	MOV	EMS_FLAG, DYNA_ALLOC

ENDIF

;---------------------------------------------------------------HKN 8/25/88
;	Fastopen must get an EMS page like a well behaved program and
;	should not grab a reserved page from the BIOS.
;
	mov	cx, FRAME_COUNT
	xor	ax, ax
	mov	bx, ax
	mov	dx, ax

get_page:
	cmp	es:[di], 0a000h		; is the page in ax above 640K
	jb	next_page		; if no get next_page

	mov	bx, di			; we have a valid page

	inc	dx			; count the # of pages above 640K

	cmp	dx, 1
	je	next_page
	sub	di, 4
	mov	ax, es:[di]
	mov	[FST_PAGE], ax
	mov	ax, es:[di+2]
	mov	[FST_PAGE+2], ax
	mov	di, bx			; restore di

next_page:
	add	di, 4
	loop	get_page
	jne	found_page
	jmp	SHORT ems_page_err

found_page:
;	int	3
	cmp	dx, 1
	jne	second_last_page
	mov	di, bx
	mov	ax, es:[di]
	mov	ems_page_seg, ax
	mov	ax, es:[di+2]
	mov	ems_page_num, ax
	jmp	SHORT save_state

second_last_page:
	mov	ax, [FST_PAGE]
	mov	ems_page_seg, ax
	mov	ax, [FST_PAGE+2]
	mov	ems_page_num, ax

save_state:
	push	es
	mov	ax, Cseg_Main
	mov	es, ax
	assume 	es:Cseg_Main

;;; johnhe 12/31/89;	mov	word ptr save_map_addr, offset es:save_ems_page_state
;;; johnhe 12/31/89;	mov	word ptr save_map_addr + 2, ax

	mov	ax, ems_page_seg
	mov	es:Main_EMS_PAGE_SEG, ax
	pop	es
	assume	es:Cseg_Init

;;; johnhe 12/31/89;	call	[save_map_addr]
	call	SaveEmsState				; johnhe 12/31/89

	jc	ems_page_err

;--------------------------------------------------------------------------
IF	NOT BUFFERFLAG
SKIP_DYNA_PAGE:
ENDIF

	POP	DI
	POP	ES
	JMP	SHORT EMS_ALLOCATE_PAGE

EMS_PAGE_ERR:
	POP	DI
	POP	ES
	STC				;yes, page not found
	JMP	SHORT EMS_ERROR 	;error exit

;-----------------------------------------------------------------------
; Allocate one page
;-----------------------------------------------------------------------
EMS_ALLOCATE_PAGE:
	MOV	BX,1		     ;one page
	MOV	AH,EMS_ALLOC_PAGES   ;set op code
	INT	EMS_INT 	     ;allocate page
	OR	AH,AH		     ;Was there an error allocating?
	JNZ	EMS_ERROR	     ;yes - display error
	MOV	EXT_HANDLE,DX	     ;no -Save EMS handle


;------------------------------------------------------HKN 8/25/88
;	Must save ems handle in Cseg_Main also.

IF	NOT BUFFERFLAG
; If dynamic allocation, save handle in CSEG_MAIN
	CMP	EMS_Mem,Dyna_Alloc   ;AN002; Dynamic Allocation ??
	JNE	Skip_Save_Handle	;AN002; no - skip saving handle
ENDIF

	push	es
	push	ax
	mov	ax, Cseg_Main
	mov	es, ax
	assume	es:Cseg_Main
	mov	es:ems_save_handle1, dx
	pop	ax
	pop	es
	assume	es:Cseg_Init

IF	NOT BUFFERFLAG
SKIP_SAVE_HANDLE:
ENDIF

;-----------------------------------------------------------------------
; SET HANDLE NAME TO THE PAGE HANDLE
;-----------------------------------------------------------------------
	PUSH	DS
	POP	ES
	ASSUME	ES:CSEG_INIT
	LEA	SI,HANDLE_NAME	     ; DS:SI-->Handle name string
	MOV	DX,EXT_HANDLE	     ; handle number
	MOV	AH,EMS_HANDLE_NAME
	MOV	AL,1		     ; set op code code
	INT	67H		     ; set handle
	OR	AH,AH
	JNZ	EMS_ERROR	     ; jump if error

;-----------------------------------------------------------------------
; Map logical page 0 in physical page frame FE (P254)
;-----------------------------------------------------------------------
	CALL	MAP_FRAME	    ;map two pages
	JNC	EMS_GET_SIZE	    ;no error, normal exit

;-----------------------------------------------------------------------
; Get partial page map size
;-----------------------------------------------------------------------
EMS_GET_SIZE:
	MOV	AH,EMS_PAGE_SIZE    ;Allocate requested pages
	MOV	AL,2
	INT	EMS_INT 	    ;
	OR	AH,AH
	JNZ	EMS_ERROR
	XOR	AH,AH
	MOV	EMS_PAGESIZE,AX     ;save EMS page size
	CLC
	JMP	SHORT EMS_EXIT

EMS_ERROR:
	MOV	AX,EMS_FAILED	    ;error message
	MOV	MSG_NUM,AX	    ;save message number
	MOV	SUBST_COUNT,0	    ;no message substitution
	MOV	MSG_CLASS,-1	    ;message class
	MOV	INPUT_FLAG,0	    ;no input
	CALL	PRINT_STDOUT	    ;show message "Incorrect Parameter"
	STC			    ; set error flag

EMS_EXIT:
	RET			    ;	 Return

SET_EMS   ENDP






;=========================================================================
; EMS_CHECK1		: THIS MODULE DETERMINES WHETHER OR NOT EMS IS
;			  INSTALLED FOR THIS SESSION.
;
;	INPUTS		: NONE
;
;	OUTPUTS 	: ES:BX - FRAME ARRAY
;			  CY	- EMS NOT AVAILABLE
;			  NC	- EMS AVAILABLE
;=========================================================================

	public	EMS_CHECK1
EMS_CHECK1 PROC NEAR			;EMS INSTALL CHECK

	mov	ax,3567h		; Get interrupt vector
	int	21h
	mov	di,0Ah			; fixed offset of EMS name in dev header
	mov	si, offset EMS_NAME	; standard EMS device name string
	mov	cx, length EMS_NAME
	cld
	repe cmpsb			; do they match?
	JNE	 EMS_NOT_INST1		 ;no, EMS not installed

	MOV	AH,EMS_GET_STATUS	;YES, GET STATUS
	INT	EMS_INT 		;INT 67H
	CMP	AH,0			;EMS MANAGER PRESENT ??
	JNE	EMS_NOT_INST1		;NO, EMS NOT INSTALLED

	MOV	AH,EMS_GET_VERSION	;YES, GET STATUS
	INT	EMS_INT 		;INT 67H
	CMP	AH,0			;EMS MANAGER PRESENT ??
	JNE	EMS_NOT_INST1		;NO, EMS NOT INSTALLED

	CMP	AL,40H			;VERSION 4.0 ??
	JNE	EMS_NOT_INST1		;NO, EMS NOT INSTALLED

	MOV	AX,EMS_GET_COUNT
	INT	EMS_INT 		;GET ARRAY COUNT
	CMP	AH,0
	JNE	EMS_NOT_INST1

	MOV	FRAME_COUNT,CX

	MOV	AX, BUFFER_ENTRY_SIZE
	MUL	CX			; CALCULATE THE ARRAY SIZE BE RESERVED
	CMP	AX, 100h
	JG	EMS_NOT_INST1

	MOV	AX,EMS_GET_FRAME_ADDR	;YES, GET FRAME ADDRESS
	PUSH	DS			;SWAP DS & ES
	POP	ES			;
	LEA	DI,FRAME_BUFFER 	;ES:DI--> RESULT BUFFER
	INT	EMS_INT 		;GET FRAME ADDRESSES
	CMP	AH,0			;IS EMS INSTALLED
	JNE	EMS_NOT_INST1		;NO,exit
	CMP	CX,FRAME_COUNT		;
	JNE	SHORT EMS_NOT_INST1

	CLC
	MOV	EMS_FLAG,1		; EMS IS ACTIVE, SET FLAG
	JMP	SHORT EMS_CHECK1_EXIT

EMS_NOT_INST1:				;EMS NOT INSTALLED
	MOV	AX,EMS_NOT_INSTALL	;error message
	MOV	MSG_NUM,AX		;set message number
	MOV	SUBST_COUNT,0		;no message substitution
	MOV	MSG_CLASS,-1		;message class
	MOV	INPUT_FLAG,0		;no input
	CALL	PRINT_STDOUT		;show message
	STC				;FLAG EMS NOT INSTALLED

EMS_CHECK1_EXIT:			;EXIT ROUTINE
	RET				;RETURN TO CALLER

EMS_CHECK1 ENDP




;=========================================================================
; MAP_FRAME		: THIS MODULE MAPS TWO LOGICAL PAGES IN THE HIGH
;			  MEMORY TO TWO PHYSICAL PAGE FEAMES IN THE LOW
;			  MEMORY.
;
;	INPUTS		: EXT_HANDLE  - HANDLE
;
;	OUTPUTD 	  CY	- ERROR
;			  NC	- PAGE IS MAPPED
;=========================================================================

MAP_FRAME    PROC  NEAR 		; MAP physical page frames
	PUSH	BX			; DMS;
	XOR	BX,BX			; Logical page 0
	MOV	AX,EMS_PAGE_NUM 	; AL=Physical Page frame number
	MOV	AH,EMS_MAP_HANDLE	; AH=EMS function to map page
	MOV	DX,EXT_HANDLE		; EMS handle
	INT	EMS_INT
	OR	AH,AH			; Was there an error allocating?
	JNZ	MAP_ERROR		; yes - set flag
	CLC
	JMP	SHORT MAP_EXIT		; no - exit

MAP_ERROR:
	STC				; set error flag

MAP_EXIT:
	POP	BX
	RET				; return


MAP_FRAME ENDP






;************************************************************
;*
;*   SUBROUTINE NAME:	   PRINT_STDOUT
;*
;*   SUBROUTINE FUNCTION:
;*	   Display the requested message to the specified handle
;*
;*   INPUT:
;*	     Paramters in parater storage area
;*	     DS:SI-->Substitution List
;*	     ES:DI-->PTR to input buffer if buffered keyboard
;*		     input is specified (DL = 0A)
;*   OUTPUT:
;*	     AX =   Single character entered if DL=01
;*		OR
;*	     ES:DI-->input buffer where string is returned if DL=0A
;*
;*	The message corresponding to the requested msg number will
;*	be written to Standard Out. Message substitution will
;*	be performed if specified
;*
;*   NORMAL EXIT:
;*	Message will be successfully written to requested handle.
;*
;*   ERROR EXIT:
;*	None.  Note that theoretically an error can be returned from
;*	SYSDISPMSG, but there is nothing that the application can do.
;*
;*   INTERNAL REFERENCES:    SysDispMsg
;*
;*   EXTERNAL REFERENCES:
;*	None
;*
;************************************************************
PRINT_STDOUT PROC NEAR
	PUSH	BX
	PUSH	CX
	PUSH	DX

	MOV	AX,MSG_NUM		; Message ID
	MOV	BX,STDOUT		; standard input message handle
	MOV	CX,SUBST_COUNT		; message substitution count
	MOV	DH,MSG_CLASS		; message class
	MOV	DL,INPUT_FLAG		; Type of INT 10 for KBD input

	CALL	SYSDISPMSG		;  AX=Extended key value if wait
					;for key
	JNC	DISP_DONE		; If CARRY SET then registers
					;will contain extended error info
					;	AX - Extended error Number
					;	BH - Error Class
					;	BL - Suggested action
DISP_DONE:				;	CH - Locus
	POP	DX
	POP	CX
	POP	BX

	RET
PRINT_STDOUT ENDP


;---------------------------------------------------------------------------
;	Procedure name	:	SaveEmsState
;
;	Description:
;		Saves the state of the page whose physical segment value is
;	specified in Main_EMS_PAGE_SEG.
;
;	johnhe 12/31/89 - Added to eliminate having to declare the same
;			  function in the resident code as FAR
;---------------------------------------------------------------------------

SaveEmsState	PROC	NEAR
	assume	DS:cseg_main

	PUSH	AX			  ; save registers
	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI

	mov	AX,SEG EMS_PAGE_ARRAY
	mov	DS,AX
	mov	ES,AX

	mov	DI,offset EMS_PAGE_ARRAY ; ES:DI-->Page ARRAY
	mov	SI,offset EMS_PAGE_MAP	 ; DS:SI-->page map struc

	MOV	AH,EMS_SAVE_STATE	  ;
	MOV	AL,0			  ; subfunction code
	INT	EMS_INT 		  ; save page state

	add	AH,0ffh 		  ; Set carry if AH != 0

	POP	DI
	POP	SI
	POP	ES
	POP	DS
	POP	AX
	RET

SaveEmsState ENDP


ifdef DBCS
;
;	Set DBCS lead byte table address
;

	assume	es:cseg_open

SET_DBCS_TABLE	proc	near
	push	ax
	push	si
	push	ds
	push	es
	mov	ax,cseg_open
	mov	es,ax
	mov	ax,6300h
	int	21h			; get DBCS lead byte table
	mov	word ptr es:DBCSLeadByteTable,si
	mov	word ptr es:DBCSLeadByteTable+2,ds
	pop	es
	pop	ds
	pop	si
	pop	ax
	ret
SET_DBCS_TABLE	endp
endif


CSEG_INIT	ENDS


;===========================================================================
;;;	    STACK    SEGMENT	   SIZE = 20 PARAGRAPHS
;===========================================================================

STACK		SEGMENT PARA STACK 'STACK'
		DB	64 dup("STACK   ")     ; 512  WORD STACK AREA
STACK		ENDS


END		START

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\expand\cmacros.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<PL/M calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
	sub	sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fastopen\fastsegs.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */



.seq
stack       segment  Stack  'STACK' ; represents STACK                            ;AN000;
stack       ends                                                             ;AN000;

cseg_main   segment   Public 'CODE'; represents MAIN
cseg_main   ends

cseg_open   segment   Public 'CODE'; represents  FASTOPEN                          ;AN000;
cseg_open   ends                                                             ;AN000;

cseg_seek   segment   Public 'CODE'; represents FASTSEEK                           ;AN000;
cseg_seek   ends                                                             ;AN000;

cseg_init   segment  Public 'CODE' ; represents INIT
cseg_init   ends


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fastopen\fastp.asm ===
PAGE	90,132			;A2

	TITLE	fastp.asm - fastopen SYSTEM COMMAND LINE PARSER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: fastp.asm
;
; DESCRIPTIVE NAME: Include the DOS system PARSER in the SEGMENT
;		    configuration expected by the modules of fastopen.
;
;FUNCTION: The common code of the DOS command line PARSER is optimized by
;	   the setting of certain switches that cause the conditional
;	   assembly of only the required portions of the common PARSER.
;
; ENTRY POINT: SYSPARSE, near
;
; INPUT:
;	ES - has seg id of the SEGMENT
;	     that contains the input control blocks,
;	     defined below.
;
;	DI - offset into ES of the PARMS INPUT BLOCK
;
;	DS - has seg id of the SEGMENT
;	     that contains the DOS input COMMAND
;	     string, which is originally presented at 81h
;	     in the PSP.
;
;	SI - offset into DS of the text of the DOS input COMMAND string
;	     as originally presented at 81H in the PSP.
;
;	DX - zero
;
;	CX - ordinal value, intially zero, updated on each subsequent call
;	     to the value returned in CX on the previous call.
;
;	CS - points to the segment containing the
;	     INCLUDE PARSE.ASM statement
;
;	DS - also points to the segment containing the INCLUDE
;	     PARSE.ASM statement.
;
; EXIT-NORMAL:	Output registers:
;	 AX - return code:
;	    RC_No_Error     equ     0	 ; No error
;	    RC_EOL	    equ     -1	 ; End of command line
;
;	 DX - Offset into ES of the selected RESULT BLOCK.
;	 BL - terminated delimiter code
;	 CX - new operand ordinal
;	 SI - set past scanned operand
;
; EXIT-ERROR: Output registers:
;	 AX - return code:
;	    RC_Too_Many     equ     1	 ; Too many operands
;	    RC_Op_Missing   equ     2	 ; Required operand missing
;	    RC_Not_In_SW    equ     3	 ; Not in switch list provided
;	    RC_Not_In_Key   equ     4	 ; Not in keyword list provided
;	    RC_Out_Of_Range equ     6	 ; Out of range specified
;	    RC_Not_In_Val   equ     7	 ; Not in value list provided
;	    RC_Not_In_Str   equ     8	 ; Not in string list provided
;	    RC_Syntax	    equ     9	 ; Syntax error
;
; INTERNAL REFERENCES:
;    ROUTINES: SYSPARSE:near (INCLUDEd in PARSE.ASM)
;
;    DATA AREAS: none
;
; EXTERNAL REFERENCES:
;    ROUTINES: none
;
;    DATA AREAS: control blocks pointed to by input registers.
;
; NOTES:
;
;	 For LINK instructions, refer to the PROLOG of the main module,
;	 fastopen.asm.
;
; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;
; COPYRIGHT: "MS DOS FASTOPEN Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft  "
;	     "Licensed Material - Property of Microsoft  "
;
;PROGRAM AUTHOR: DOS 4.00 P L
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;					;AN000;
        ;    %OUT    COMPONENT=fastopen, MODULE=fastp.asm...
	ENDIF				;					;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<MACRO DEFINITION>	;					;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT			;;					;AN000;
.XLIST
	SUBTTL	TEXT
.LIST
	PAGE				;;					;AN000;
	ENDM				;;					;AN000;

; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<SYSPARSE - SYSTEM COMMAND LINE PARSER> ;			;AN000;
CSEG_INIT    SEGMENT PARA PUBLIC 'CODE'      ;
	ASSUME	CS:CSEG_INIT,DS:CSEG_INIT,ES:CSEG_INIT

	PUBLIC	SYSPARSE		;SUBROUTINE ENTRY POINT 		;AN000;


INCSW	EQU	1			;INCLUDE PSDATA.INC			;AN000;
FARSW	EQU	0			;CALL THE PARSER BY NEAR CALL
DATESW	EQU	0			;SUPPRESS DATE CHECKING 		;AN000;
TIMESW	EQU	0			;SUPPRESS TIME CHECKING 		;AN000;
FILESW	EQU	0			;SUPPRESS CHECKING FILE SPECIFICATION	;AN000;
CAPSW	EQU	0			;SUPPRESS FILE TABLE CAPS		;AN000;
CMPXSW	EQU	1			;SUPPRESS CHECKING COMPLEX LIST
DRVSW	EQU	1			;SUPPRESS SUPPORT OF DRIVE ONLY FORMAT
QUSSW	EQU	0			;SUPPRESS SUPPORT OF QUOTED STRING FORMAT ;AN000;
NUMSW	EQU	1			;SUPPRESS CHECKING NUMERIC VALUE
KEYSW	EQU	0			;SUPPRESS KEYWORD SUPPORT		;AN000;
SWSW	EQU	1			;DO SUPPORT SWITCHES			;AN000;
VAL1SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 1 ;AN000;
VAL2SW	EQU	0			;SUPPRESS SUPPORT OF VALUE DEFINITION 2 ;AN000;
VAL3SW	EQU	0			;DO SUPPORT VALUE DEFINITION 3


	IF1				;					;AN000;
        ;    %OUT    COMPONENT=fastopen, SUBCOMPONENT=PARSE, MODULE=PARSE.ASM...
        ;    %OUT    COMPONENT=fastopen, SUBCOMPONENT=PARSE, MODULE=PSDATA.INC...
	ENDIF				;					;AN000;

INCLUDE	VERSION.INC	
INCLUDE PARSE.ASM		;					;AN000;

CSEG_INIT  ENDS 			   ;
	END				;					;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\error.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; *	   IPG-changes by Terry Farrel on October 1991
; */

/* error.c - return text of error corresponding to the most recent DOS error */

// #include "tools.h" - no longer needed   TF

extern int errno;
extern system_nerr;             // IPG- was sys_nerr
extern char *sys_errorlist[];   // IPG- changed from sys_errlist, found in C libs.

#define UNKNOWN 37              /* TF -> points to sys_errorlist         */

char *error ()
{
    if (errno < 0 || errno >= system_nerr)
        return sys_errorlist[UNKNOWN];
    else
        return sys_errorlist[errno];
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\fc.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/****************************************************************************
    File Compare

    Fcom compares two files in either a line-by-line mode or in a strict
    byte-by-byte mode.

    The byte-by-byte mode is simple; merely read both files and print the
    offsets where they differ and the contents.

    The line compare mode attempts to isolate differences in ranges of lines.
    Two buffers of lines are read and compared.  No hashing of lines needs
    to be done; hashing only speedily tells you when things are different,
    not the same.  Most files run through this are expected to be largely
    the same.  Thus, hashing buys nothing.


***********************************************************************
The algorithm that immediately follows does not work.  There is an error
somewhere in the range of lines 11 on. An alternative explanation follows.
                                                            KGS
************************************************************************

    [0]     Fill buffers
    [1]     If both buffers are empty then
    [1.1]       Done
    [2]     Adjust buffers so 1st differing lines are at top.
    [3]     If buffers are empty then
    [3.1]       Goto [0]

    This is the difficult part.  We assume that there is a sequence of inserts,
    deletes and replacements that will bring the buffers back into alignment.

    [4]     xd = yd = FALSE
    [5]     xc = yc = 1
    [6]     xp = yp = 1
    [7]     If buffer1[xc] and buffer2[yp] begin a "sync" range then
    [7.1]       Output lines 1 through xc-1 in buffer 1
    [7.2]       Output lines 1 through yp-1 in buffer 2
    [7.3]       Adjust buffer 1 so line xc is at beginning
    [7.4]       Adjust buffer 2 so line yp is at beginning
    [7.5]       Goto [0]
    [8]     If buffer1[xp] and buffer2[yc] begin a "sync" range then
    [8.1]       Output lines 1 through xp-1 in buffer 1
    [8.2]       Output lines 1 through yc-1 in buffer 2
    [8.3]       Adjust buffer 1 so line xp is at beginning
    [8.4]       Adjust buffer 2 so line yc is at beginning
    [8.5]       Goto [0]
    [9]     xp = xp + 1
    [10]    if xp > xc then
    [10.1]      xp = 1
    [10.2]      xc = xc + 1
    [10.3]      if xc > number of lines in buffer 1 then
    [10.4]          xc = number of lines
    [10.5]          xd = TRUE
    [11]    if yp > yc then
    [11.1]      yp = 1
    [11.2]      yc = yc + 1
    [11.3]      if yc > number of lines in buffer 2 then
    [11.4]          yc = number of lines
    [11.5]          yd = TRUE
    [12]    if not xd or not yd then
    [12.1]      goto [6]

    At this point there is no possible match between the buffers.  For
    simplicity, we punt.

    [13]    Display error message.

EXPLANATION 2

    This is a variation of the Largest Common Subsequence problem.  A
    detailed explanation of this can be found on p 189 of Data Structures
    and Algorithms by Aho Hopcroft and Ulman.

    FC maintains two buffers within which it tries to find the Largest Common
    Subsequence (The largest common subsequence is simply the pattern in
    buffer1 that yields the most matches with the pattern in buffer2, or the
    pattern in buffer2 that yields the most matches with the pattern in buffer1)

    FC makes a simplifying assumption that the contents of one buffer can be
    converted to the contents of the other buffer by deleting the lines that are
    different between the two buffers.

    Two indices into each buffer are maintained:

            xc, yc == point to the last line that has been scanned up to now

            xp, yp == point to the first line that has not been exhaustively
                      compared to lines 0 - #c in the other buffer.

    FC now makes a second simplifying assumption:
        It is unnecessary to do any calculations on lines that are equal.

    Hence FC scans File1 and File two line by line until a difference is
    encountered.

    When a difference is encountered the two buffers are filled such that
    the line containing the first difference heads the buffer. The following
    exhaustive search algorithm is applied to find the first "sync" occurance.
    (The below is simplified to use == for comparison.  In practice more than
    one line needs to match for a "sync" to be established).

            FOR xc,yc = 1; xc,yx <= sizeof( BUFFERS ); xc++, yc++

                FOR xp,yp = 1; xp,yp <= xc,yc; xp++, yp++

                    IF ( BUFFER1[xp] == BUFFER2[yc] )

                        Then the range of lines BUFFER1[ 1 ... xp ] and
                        BUFFER2[ 1 ... yc ] need to be deleted for the
                        two files to be equal.  Therefore DISPLAY these
                        ranges, and begin scanning both files starting at
                        the matching lines.
                    FI

                    IF ( BUFFER1[yp] == BUFFER2[xc] )

                        Then the range of lines BUFFER2[ 1 ... yp ] and
                        BUFFER1[ 1 ... xc ] need to be deleted for the
                        two files to be equal.  Therefore DISPLAY these
                        ranges, and begin scanning both files starting at
                        the matching lines.
                    FI
                FOREND
            FOREND

    If a match is not found within the buffers, the message "RESYNC FAILED"
    is issued and further comparison is aborted since there is no valid way
    to find further matching lines.

END EXPLANATION 2

    Certain flags may be set to modify the behavior of the comparison:

    -a      abbreviated output.  Rather than displaying all of the modified
            ranges, just display the beginning, ... and the ending difference
    -b      compare the files in binary (or byte-by-byte) mode.  This mode is
            default on .EXE, .OBJ, .LIB, .COM, .BIN, and .SYS files
    -c      ignore case on compare (cmp = strcmpi instead of strcmp)
    -l      compare files in line-by-line mode
    -lb n   set the size of the internal line buffer to n lines from default
            of 100
    -w      ignore blank lines and white space (ignore len 0, use strcmps)
    -t      do not untabify (use fgets instead of fgetl)
    -n      output the line number also
    -NNNN   set the number of lines to resynchronize to n which defaults
            to 2.  Failure to have this value set correctly can result in
            odd output:
              file1:        file2:
                    abcdefg       abcdefg
                    aaaaaaa       aaaaaab
                    aaaaaaa       aaaaaaa
                    aaaaaaa       aaaaaaa
                    abcdefg       abcdefg

            with default sync of 2 yields:          with sync => 3 yields:

                    *****f1                             *****f1
                    abcdefg                             abcdefg
                    aaaaaaa                             aaaaaaa
                    *****f2                             aaaaaaa
                    abcdefg                             *****f2
                    aaaaaab                             abcdefg
                    aaaaaaa                             aaaaaab
                                                        aaaaaaa
                    *****f1
                    aaaaaaa
                    aaaaaaa
                    abcdefg
                    *****f2
                    aaaaaaa
                    abcdefg

WARNING:
        This program makes use of GOTO's and hence is not as straightforward
        as it could be!  CAVEAT PROGRAMMER.
****************************************************************************/


#include "tools.h"
#include "messages.h"
#include "fc.h"
#include <versionc.h>
#include <malloc.h>
#include <process.h>
#include <dos.h>
#include <version.h>


/**************************************************************************/
/* main                                                                   */
/**************************************************************************/

int main (int c, byte *v[])
{
  int i;
  int j;
  int fileargs;
  char *strpbrk(), *slash;
  char n[2][MAXFNAME];


  /* Issue error message if DOS version is not within valid range. */
  if ((EXPECTED_VERSION_MAJOR != _osmajor) ||      
      (EXPECTED_VERSION_MINOR != _osminor))       
  {    
    usage (Bad_ver, NULL);   
    return (1);
  }   

  funcRead = (int (*) ())FNADDR(fgetl);

  fileargs = 0;
  for (i=1; i < c; i++)
  {
    /*
     *  If argument doesn't begin with a /, parse a filename off of it
     *  then examine the argument for following switches.
     *
     */
    if (*v[i] != '/')
    {
      if (fileargs == 2)
      {
        usage(msg_tbl[TOO_MANY_FNAMES], NULL);
        return (1);
      }
    
      slash = strchr( v[i],'/');
      if ( slash )
      {
        *slash='\0'  ;
        strcpy(n[fileargs++],v[i]);
        *slash = '/';
      }
      else
        strcpy(n[fileargs++],v[i]);
    }
    
    for (j=0; j < strlen( v[i] ); j++)
    {
      if (*(v[i]+j) == '/')
      {
        switch ( toupper( *(v[i]+j+1)) )
        {
          case '?' :
              usage(NULL, HELPTEXT);
    	      return (0);
    	      break;
          case 'A' :
              fAbbrev = TRUE;
              break;
          case 'B' :
              fBinary = TRUE;
              break;
          case 'C' :
              fCase = FALSE;
              break;
#ifdef  DEBUG
          case 'D' :
              fDebug = TRUE;
              break;
#endif
          case 'W' :
              fIgnore = TRUE;
              break;
          case 'L' :
              if (toupper(*(v[i]+j+2)) == 'B')
              {
                cLine = ntoi ((v[i]+j+3),10);
                break;
              }
              else
                fLine = TRUE;
              break;
          case 'N' :
              fNumb = TRUE;
              break;
          case 'T' :
              funcRead =(int (*) ())FNADDR(fgets);
              break;
          default:
              if (*strbskip((v[i]+j+1),"0123456789") == 0)
                ctSync = ntoi ((v[i]+j+1), 10);
              else
                usage (msg_tbl[INVALID_SWITCH], NULL);
        }
      }
    }  
  }
  if (fileargs != 2)
  {
    usage (msg_tbl[NOT_ENUF_FILES], NULL);
    return (1);
  }
  if (ctSync != -1)
    fLine = TRUE;
  else
    ctSync = 2;

  if (cLine == -1)
    cLine = 100;

  if (!fBinary && !fLine)
  {
    extention (n[0], line);

    for (i=0; extBin[i]; i++)
    {
      if (!strcmpi (extBin[i], line))
        fBinary = TRUE;
    }
    if (!fBinary)
      fLine = TRUE;
  }

  if (fBinary && (fLine || fNumb))
  {
    usage (BadSw, NULL);
    return (1);
  }

  if (fIgnore)
  {
    if (fCase)
      fCmp = FNADDR(strcmps);
    else
      fCmp = FNADDR(strcmpis);
  }
  else
  {
    if (fCase)
      fCmp = FNADDR(strcmp);
    else
      fCmp = FNADDR(strcmpi);
  }

  /* Parse the two filenames and compare the two files */
  ParseFileNames(n[0], n[1]);

  return (0);
}


/***************************************************************************/
/* Usage has changed to take a third arg, pcode (print code), in order     */
/* to be able to specify printing more than one message at a call - before */
/* usage would check p, and if it was a null pointer, would print UseMes1, */
/* (now hlp_tbl[1]), otherwise it would print whatever p pointed to, which */
/* works if you only want one msg at a time.  pcode is an extensible means */
/* of being able to add all sorts of print capabilities. (leaf, april 90)  */
/***************************************************************************/

void usage (unsigned char *p, unsigned int pcode)
{
  int i;

  if (pcode == HELPTEXT)
  {
    for (i = 0; i < HELP_TEXT_LEN; i++)
      printf(hlp_tbl[i]);
  }
  else
  {
    if (p)
      printf ("FC: %s\n", p);
    else  
      printf (hlp_tbl[1]);
  }
}


/**************************************************************************/
/* BinaryCompare                                                          */
/**************************************************************************/

int BinaryCompare (unsigned char *f1, unsigned char *f2)
{
  register int c1, c2;
  long pos;
  FILE *fh1, *fh2;
  flagType fSame;

  fSame = TRUE;
  if ((fh1 = fopen (f1, "rb")) == NULL)
  {
    sprintf (line, BadOpn, f1, error ());
    usage (line, NULL);
    return (1);
  }

  if ((fh2 = fopen (f2, "rb")) == NULL)
  {
    sprintf (line, BadOpn, f2, error ());
    usage (line, NULL);
    fclose(fh1);
    return (1);
  }
  pos = 0L;

  while (TRUE)
  {
    if ((c1 = getc (fh1)) != EOF)
    {
      if ((c2 = getc (fh2)) != EOF)
      {
        if (c1 != c2)
        {
          fSame = FALSE;
          printf ("%08lX: %02X %02X\n", pos, c1, c2);
        }
      }
      else
      {
        sprintf (line, LngFil, f1, f2);
        usage (line, NULL);
	fclose(fh1);
	fclose(fh2);
	return (1);
      }
    }
    else
    {
      if ((c2 = getc (fh2)) == EOF)
      {
        if (fSame)
            usage (NoDif, NULL);
        fclose(fh1);
	fclose(fh2);
        return (0);
      }
      else
      {
        sprintf (line, LngFil, f2, f1);
        usage (line, NULL);
	fclose(fh1);
	fclose(fh2);
	return (1);
      }
    }
    pos++;
  }
  fclose(fh1);
  fclose(fh2);
  return (0);
}


/**************************************************************************/
/* Compare a range of lines.                                              */
/**************************************************************************/

flagType compare (int l1, register int s1, int l2, register int s2, int ct)
{
#ifdef  DEBUG
  if (fDebug)
    printf ("compare (%d, %d, %d, %d, %d)\n", l1, s1, l2, s2, ct);
#endif

  if (ct == 0 || s1+ct > l1 || s2+ct > l2)
    return (FALSE);

  while (ct--)
  {

#ifdef  DEBUG
    if (fDebug)
      printf ("'%s' == '%s'? ", buffer1[s1].text, buffer2[s2].text);
#endif

    if ((*fCmp)(buffer1[s1++].text, buffer2[s2++].text))
    {

#ifdef  DEBUG
      if (fDebug)
        printf ("No\n");
#endif
      return (FALSE);
    }
  }

#ifdef  DEBUG
  if (fDebug)
    printf ("Yes\n");
#endif

  return (TRUE);
}


/**************************************************************************/
/* LineCompare                                                            */
/**************************************************************************/

void LineCompare (unsigned char *f1, unsigned char *f2)
{
  FILE *fh1, *fh2;
  int l1, l2, i, xp, yp, xc, yc;
  flagType xd, yd, fSame;
  int line1, line2;

  fSame = TRUE;
  if ((fh1 = fopen (f1, "rb")) == NULL)
  {
    sprintf (line, BadOpn, f1, error ());
    usage (line, NULL);
    return;
  }

  if ((fh2 = fopen (f2, "rb")) == NULL)
  {
    sprintf (line, BadOpn, f2, error ());
    usage (line, NULL);
    fclose(fh2);
    return;
  }

  if ((buffer1 = (struct lineType *)malloc (cLine * (sizeof *buffer1))) == NULL ||
      (buffer2 = (struct lineType *)malloc (cLine * (sizeof *buffer1))) == NULL)
  {
    usage (NoMem, NULL);
    fclose(fh1);
    fclose(fh2);
    return;
  }

  l1 = l2 = 0;
  line1 = line2 = 0;

l0:

#ifdef  DEBUG
  if (fDebug)
    printf ("At scan beginning\n");
#endif

  l1 += xfill (buffer1+l1, fh1, cLine-l1, &line1);
  l2 += xfill (buffer2+l2, fh2, cLine-l2, &line2);

  if (l1 == 0 && l2 == 0)
  {
    if (fSame)
      usage (NoDif, NULL);
    free((void *)buffer1);
    free((void *)buffer2);
    fclose(fh1);
    fclose(fh2);
    return;
  }
  xc = min (l1, l2);

  for (i=0; i < xc; i++)
  {
    if (!compare (l1, i, l2, i, 1))
      break;
  }

  if (i != xc)
    i = max (i-1, 0);

  l1 = adjust (buffer1, l1, i);
  l2 = adjust (buffer2, l2, i);

  /* KLUDGE ALERT!! GOTO USED */
  if (l1 == 0 && l2 == 0)
    goto l0;

  l1 += xfill (buffer1+l1, fh1, cLine-l1, &line1);
  l2 += xfill (buffer2+l2, fh2, cLine-l2, &line2);

#ifdef  DEBUG
  if (fDebug)
    printf ("buffers are adjusted, %d, %d remain\n", l1, l2);
#endif

  xd = yd = FALSE;
  xc = yc = 1;
  xp = yp = 1;

l6:

#ifdef  DEBUG
  if (fDebug)
    printf ("Trying resync %d,%d  %d,%d\n", xc, xp, yc, yp);
#endif

  i = min (l1-xc,l2-yp);
  i = min (i, ctSync);

  if (compare (l1, xc, l2, yp, i))
  {
    fSame = FALSE;
    printf ("***** %s\n", f1);
    dump (buffer1, 0, xc);
    printf ("***** %s\n", f2);
    dump (buffer2, 0, yp);
    printf ("*****\n\n");

    l1 = adjust (buffer1, l1, xc);
    l2 = adjust (buffer2, l2, yp);

    /* KLUDGE ALERT!! GOTO USED */
    goto l0;
  }
  i = min (l1-xp, l2-yc);
  i = min (i, ctSync);

  if (compare (l1, xp, l2, yc, i))
  {
    fSame = FALSE;
    printf ("***** %s\n", f1);
    dump (buffer1, 0, xp);
    printf ("***** %s\n", f2);
    dump (buffer2, 0, yc);
    printf ("*****\n\n");

    l1 = adjust (buffer1, l1, xp);
    l2 = adjust (buffer2, l2, yc);

    /* KLUDGE ALERT!! GOTO USED */
    goto l0;
  }
  if (++xp > xc)
  {
    xp = 1;
    if (++xc >= l1)
    {
      xc = l1;
      xd = TRUE;
    }
  }
  if (++yp > yc)
  {
    yp = 1;
    if (++yc >= l2)
    {
      yc = l1;
      yd = TRUE;
    }
  }
  if (!xd || !yd)
    goto l6;
  fSame = FALSE;

  if (l1 >= cLine || l2 >= cLine)
    printf ("%s\n", ReSyncMes);

  printf ("***** %s\n", f1);
  dump (buffer1, 0, l1-1);
  printf ("***** %s\n", f2);
  dump (buffer2, 0, l2-1);
  printf ("*****\n\n");
  free((void *)buffer1);
  free((void *)buffer2);
  fclose(fh1);
  fclose(fh2);
  return;
}


/**************************************************************************/
/* Return number of lines read in.                                        */
/**************************************************************************/

xfill (struct lineType *pl, FILE *fh, int ct, int *plnum)
{
  int i;

#ifdef  DEBUG
  if (fDebug)
    printf ("xfill (%04x, %04x)\n", pl, fh);
#endif

  i = 0;
  while (ct-- && (*funcRead) (pl->text, MAXARG, fh) != NULL)
  {
    if (funcRead == (int (*) ())FNADDR(fgets))
      pl->text[strlen(pl->text)-1] = 0;
    if (fIgnore && !strcmps (pl->text, ""))
    {
      pl->text[0] = 0;
      ++*plnum;
    }
    if (strlen (pl->text) != 0 || !fIgnore)
    {
      pl->line = ++*plnum;
      pl++;
      i++;
    }
  }

#ifdef  DEBUG
  if (fDebug)
    printf ("xfill returns %d\n", i);
#endif

  return (i);
}


/**************************************************************************/
/* Adjust returns number of lines in buffer.                              */
/**************************************************************************/

adjust (struct lineType *pl, int ml, int lt)
{
#ifdef  DEBUG
  if (fDebug)
    printf ("adjust (%04x, %d, %d) = ", pl, ml, lt);
  if (fDebug)
    printf ("%d\n", ml-lt);
#endif

  if (ml <= lt)
    return (0);

#ifdef  DEBUG
  if (fDebug)
    printf ("move (%04x, %04x, %04x)\n", &pl[lt], &pl[0], sizeof (*pl)*(ml-lt));
#endif

  Move((unsigned char far *)&pl[lt], (char far *)&pl[0], sizeof (*pl)*(ml-lt));
  return ml-lt;
}


/**************************************************************************/
/* dump                                                                   */
/*      dump outputs a range of lines.                                    */
/*                                                                        */
/*  INPUTS                                                                */
/*          pl      pointer to current lineType structure                 */
/*          start   starting line number                                  */
/*          end     ending line number                                    */
/*                                                                        */
/*  CALLS                                                                 */
/*          pline, printf                                                 */
/**************************************************************************/

void dump (struct lineType *pl, int start, int end)
{
  if (fAbbrev && end-start > 2)
  {
    pline (pl+start);
    printf ("...\n");
    pline (pl+end);
  }
  else
  {
    while (start <= end)
      pline (pl+start++);
  }
}


/**************************************************************************/
/* PrintLINE                                                              */
/*      pline prints a single line of output.  If the /n flag             */
/*  has been specified, the line number of the printed text is added.     */
/*                                                                        */
/*  Inputs                                                                */
/*          pl      pointer to current lineType structure                 */
/*          fNumb   TRUE if /n specified                                  */
/**************************************************************************/

void pline (struct lineType *pl)
{
  if (fNumb)
    printf ("%5d:  ", pl->line);
  printf ("%s\n", pl->text);
}


/**************************************************************************/
/*        strcmpi will compare two string lexically and return one of     */
/*  the following:                                                        */
/*    - 0    if the strings are equal                                     */
/*    - 1    if first > the second                                        */
/*    - (-1) if first < the second                                        */
/*                                                                        */
/*	This was written to replace the run time library version of       */
/*  strcmpi which does not correctly compare the european character set.  */
/*  This version relies on a version of toupper which uses IToupper.      */
/**************************************************************************/

int strcmpi(unsigned char *str1, unsigned char *str2)
{
  unsigned char c1, c2;

#ifdef DBCS
  while (TRUE)
  {
    c1 = *str1++;
    c2 = *str2++;
    if (c1 == '\0' || c2 == '\0')
      break;
    if (IsDBCSLeadByte(c1) && IsDBCSLeadByte(c2))
    {
      if (c1 == c2)
      {
        c1 = *str1++;
        c2 = *str2++;
        if (c1 != c2)
          break;
      }
      else
        break;
    }
    else if (IsDBCSLeadByte(c1) || IsDBCSLeadByte(c2))
      return (IsDBCSLeadByte(c1) ? 1 : -1);
    else
      if ((c1 = toupper(c1)) != (c2 = toupper(c2)))
        break;
  }
  return (c1 == c2 ? 0 : (c1 > c2 ? 1 : -1));
#else
  while ((c1 = toupper(*str1++)) == (c2 = toupper(*str2++)))
  {
    if (c1 == '\0')
      return (0);
  }

  if (c1 > c2)
    return (1);
  else
    return (-1);
#endif
}


/**************************************************************************/
/* Skip white space.  Return pointer to first non-white character.        */
/**************************************************************************/
unsigned char *skipwhite(unsigned char *p)
{
#ifdef DBCS
  while (*p)
  {
    if (ISSPACE(*p))
      p++;
    else if (*p == DB_SP_HI && *(p+1) == DB_SP_LO)
    {
      *p++ = ' ';
      *p++ = ' ';
    }
    else
      break;
  }
#else
  while (ISSPACE(*p))
    p++;
#endif
  return(p);
}


/**************************************************************************/
/* Compare two strings, ignoring white space, case is significant, return */
/* 0 if identical, <>0 otherwise.  Leading and trailing white space is    */
/* ignored, internal white space is treated as single characters.         */
/**************************************************************************/
strcmps (unsigned char *p1, unsigned char *p2)
{
  unsigned char *q;

  p1 = skipwhite(p1); 		     /* skip any leading white space */
  p2 = skipwhite(p2);

  while (TRUE)
  {
    if (*p1 == *p2)
    {
      if (*p1++ == 0)             /* quit if at the end */
        return (0);
      else
        p2++;

#ifdef DBCS
      if (checkspace(p1))
#else
      if (ISSPACE(*p1))           /* compress multiple spaces */
#endif
      {
        q = skipwhite(p1);
	p1 = (*q == 0) ? q : q - 1;
      }

#ifdef DBCS
      if (checkspace(p2))
#else
      if (ISSPACE(*p2))
#endif
      {
        q = skipwhite(p2);
	p2 = (*q == 0) ? q : q - 1;
      }
    }
    else
      return *p1-*p2;
  }
}


/**************************************************************************/
/* Compare two strings, ignoring white space, case is not significant,    */
/* return 0 if identical, <>0 otherwise.  Leading and trailing white      */
/* space is ignored, internal white space is treated as single characters.*/
/**************************************************************************/
strcmpis (unsigned char *p1, unsigned char *p2)
{
  unsigned char *q;
#ifdef DBCS
  unsigned char c1,c2;
#endif

  p1 = skipwhite(p1);                  /* skip any leading white space */
  p2 = skipwhite(p2);

  while (TRUE)
  {
#ifdef DBCS
    c1 = *p1;
    c2 = *p2;

    if (IsDBCSLeadByte(c1) && IsDBCSLeadByte(c2) && c1 == c2)
    {
      c1 = *++p1;
      c2 = *++p2;
    }
    else if (IsDBCSLeadByte(c1) || IsDBCSLeadByte(c2))
      return (c1 - c2);
    else
    {
      c1 = toupper(c1);
      c2 = toupper(c2);
    }
    if (c1 == c2)
#else
      if (toupper(*p1) == toupper(*p2))
#endif
      {
        if (*p1++ == 0)                /* quit if at the end */
	  return (0);
	else
	  p2++;
#ifdef DBCS
	if (checkspace(p1))
#else
	if (ISSPACE(*p1))              /* compress multiple spaces */
#endif
	{
	  q = skipwhite(p1);
	  p1 = (*q == 0) ? q : q - 1;
	}
#ifdef DBCS
	if (checkspace(p2))
#else
	if (ISSPACE(*p2))
#endif
	{
	  q = skipwhite(p2);
	  p2 = (*q == 0) ? q : q - 1;
	}
      }
      else
        return *p1-*p2;
  }
}


/**************************************************************************/
/* Routine:  has_extension                                                */
/* Arguments: an arbitrary string                                         */
/* Function: check for extensions in the string.                          */
/**************************************************************************/

Boolean has_extension(char *s)
{
  int i;
  char *p1, *p2;

  p1 = s + strlen(s) - 1;
  for (i = 1; i <= 4; i++)
  {
    if (*p1 == '.')
      break;
    p1--;
  }
  p2 = strrchr(s, '\\');
  if (!p2) 
    p2 = strrchr(s,'/');
  if ((*p1 == '.') && !(p2 && (p2 > p1)))
    return (TRUE);
  else
    return (FALSE);
}


/*********************************************************************/ 
/* Routine:   ParseFileNames                                         */
/*                                                                   */
/* Function:  Parses the two given filenames and then compares the   */
/*            appropriate filenames.  This routine handles wildcard  */
/*            characters in both filenames.                          */
/*********************************************************************/

void ParseFileNames(char *file1, char *file2)
{
  struct find_t struct1;                    /* for findfirst/findnext */
  char final1[MAXFNAME], final2[MAXFNAME];  /* final path and filename */
  char inter2[MAXFNAME];                    /* intermediate filename for file2 */
  char *fname1, *fname2;                    /* filename begins here */
  int Wildcard2;                            /* if file2 contains a wildcard */


  /* Convert filenames to uppercase. */
  strupr(file1);
  strupr(file2);

  /* Copy current pathnames to final destination holders */
  strcpy(final1, file1);
  strcpy(final2, file2);

  /* Find position of filename for both pathnames */
  fname1 = FindFileName(final1);
  fname2 = FindFileName(final2);

  /*
   *  If a "*" is found by itself, make it "*.*".  The reason for this is
   *  that dos_findfirst treats "*" as "*." instead of "*.*".
   */
  CheckWildcard(final1, fname1);
  CheckWildcard(final2, fname2);

  /*
   *  Copy final2 filename to intermediate holder (contains wildcards).
   *  This is needed because final2 will be overwritten for each
   *  iteration through the loop.
   */
  strcpy(inter2, final2);

  /* Get name of first file1 to compare (handles wildcards). */
  if (_dos_findfirst(final1, _A_RDONLY, &struct1))
  {
    /* dos_findfirst failed, so print message */
    printf("%s%s\n", msg_tbl[FILES_NOT_FOUND_MSG], file1);
    return;
  }

  /* Set flag for whether or not file2 has a wildcard */
  Wildcard2 = HasWildcard(inter2);

  do
  {
    /*
     *  Create full pathname for file 1 with original path and new file name.
     *  This assumes that dos_findfirst returns an uppercase filename.
     */
    strcpy(fname1, struct1.name);

    if ( Wildcard2 )
    {
      /* Expand wildcards in file2 and compare the two files. */
      if (ExpandFile2(fname1, fname2))           /* M001 */
      {                                /* expansion of file2 failed */
        printf("%s     %s\n%s\n\n\n", final1, file2, msg_tbl[COULD_NOT_EXP_MSG]);
      }
      else
        comp(final1, final2);          /* compare the two files */
      
      strcpy(final2, inter2);          /* recopy original with wildcards */
    }                                            /* M001 */
    else
    {
      /* no wildcards in file2, so just compare final1 and final2 */
      comp(final1, final2);
    }
  } while (!_dos_findnext(&struct1));
}


/*********************************************************************/ 
/* Routine:   FindFileName                                           */
/*                                                                   */
/* Function:  Returns the pointer to the start of the filename in    */
/*            the given pathname.                                    */
/*********************************************************************/

char *FindFileName(char *pathname)
{
  int len1;
  char *ptr;

  
  len1 = strlen(pathname);
  ptr = pathname + len1 - 1;           /* position ptr at end of string */

#ifdef DBCS
  while ( ((len1-- && (*ptr != '\\')) && (*ptr != ':') && (*ptr != '/')) ||
          (len1 > 0 && CheckDBCSTailByte(pathname, ptr)) )
#else
  while ( (len1-- && (*ptr != '\\')) && (*ptr != ':') && (*ptr != '/') )
#endif
    ptr--;

    return (ptr + 1);
}


/*********************************************************************/ 
/* Routine:   HasWildcard                                            */
/*                                                                   */
/* Function:  Returns TRUE if string has a wildcard character.       */
/*            Otherwise, it returns FALSE.                           */
/*********************************************************************/

Boolean HasWildcard(char *file)
{
  if ( strchr(file, '?') || strchr(file, '*') )
    return (TRUE);
  return (FALSE);
}


/*********************************************************************/ 
/* Routine:   CheckWildcard                                          */
/*                                                                   */
/* Function:  If a "*" is found by itself in the filename, then it   */
/*            is changed to "*.*".  The reason for this is that      */
/*            dos_findfirst treats "*" as "*." instead of "*.*".     */
/*********************************************************************/

void CheckWildcard(char *path, char *file)
{
  char *ptr;                  /* ptr to wildcard in filename */
  
  if ( (!strchr(file, '.')) && (ptr = strchr(file, '*')) )
  {
    if (strlen(path) <= (MAXFNAME - 3))
    {
      /* change the '*' to '*.*' */
      *(ptr+1) = '.';
      *(ptr+2) = '*';
      *(ptr+3) = 0;                    /* end of string marker */
    }
  }
}


/*********************************************************************/ 
/* Routine:   ExpandFile2                                            */
/*                                                                   */
/* Function:  Expands the wildcards found in File2 to match File1.   */
/*            This routine is ONLY called if wildcards exist in      */
/*            File2.                                                 */
/* M001                                                              */
/*********************************************************************/

int ExpandFile2(char *File1, char *File2)
{
  char *Ptr1, *Ptr2;                   /* temp ptrs to filenames */
  char *Dot1, *Dot2;                   /* ptrs to dots in filenames */
  char *End1, *End2;                   /* ptrs to ends of filenames */
  char Storage[5];                     /* temp storage for file extension */
  char *TempFile2;                     /* temp pointer to File2 */

  /*
   *  Initialize pointers to filename sections.
   *  If a filename does not contain an extension, then Dot = End.
   */
  End1 = File1 + strlen(File1);
  End2 = File2 + strlen(File2);
  if (!(Dot1 = strrchr(File1, '.')))
    Dot1 = End1;
  if (!(Dot2 = strrchr(File2, '.')))
    Dot2 = End2;

  /*
   *  Expand '*' wildcard inside File2 by copying characters from
   *  File1 to File2.
   */
  if (Ptr2 = strchr(File2, '*'))
  {
    if (Ptr2 < Dot2)                   /* in first 8 of 8.3 for File2 */
    {
      strcpy(Storage, Dot2);           /* save extension of File2 */
      Ptr1 = File1 + (Ptr2 - File2);
      for (; Ptr1 < Dot1; Ptr1++, Ptr2++)
        *Ptr2 = *Ptr1;
      *Ptr2 = 0;
      End2 = End2 + (Ptr2 - Dot2);     /* reset End2 to new location */
      Dot2 = Ptr2;                     /* reset Dot2 to new location */
      strcat(File2, Storage);          /* recopy saved extension to File2 */
    }
    if (Ptr2 = strchr(File2, '*'))     /* in extension of 8.3 for File2 */
    {
      Ptr1 = Dot1 + (Ptr2 - Dot2);
      for (; Ptr1 < End1; Ptr1++, Ptr2++)
        *Ptr2 = *Ptr1;
      *Ptr2 = 0;                       /* null terminate string */
      End2 = Ptr2;                     /* reset End2 to new location */
    }
  }

  /*
   *  Expand '?' wildcard inside File2 by copying a character from
   *  File1 to File2.
   */
  TempFile2 = File2;
  while (Ptr2 = strchr(TempFile2, '?'))
  {
    if (Ptr2 < Dot2)                   /* in first 8 of 8.3 for File2 */
    {
      Ptr1 = File1 + (Ptr2 - File2);
      if (Ptr1 < Dot1)
        *Ptr2 = *Ptr1;
      else                             /* nothing in File1 matches '?' in File2 */
        return (FAILURE);              /*   return error */
    }
    else                               /* in extension of 8.3 for File2 */
    {
      Ptr1 = Dot1 + (Ptr2 - Dot2);
      if (Ptr1 < End1)
        *Ptr2 = *Ptr1;
      else                             /* nothing in File1 matches '?' in File2 */
        return (FAILURE);              /*   return error */
    }
    TempFile2 = Ptr2 + 1;              /* TempFile2 is now 1 after current '?' */
  }

  /* If the dot is the last character in the string, remove it. */
  if ((Ptr2 = strrchr(File2, '.')) == (End2 - 1))
    *Ptr2 = 0;

  return (SUCCESS);
}


/*********************************************************************/ 
/* Routine:   comp                                                   */
/*                                                                   */
/* Function:  Compares the two files.                                */
/*********************************************************************/

void comp(char *file1, char *file2)
{
  printf("%s%s%s%s\n",msg_tbl[COMPARING], file1, msg_tbl[AND], file2);
  if (fBinary)
    BinaryCompare (file1, file2);
  else
    LineCompare (file1, file2);

  printf("\n");
}	



#ifdef DBCS

/**************************************************************************/
/* Routine:  checkspace                                                   */
/* Arguments: an arbitrary string                                         */
/* Function: Determine whether there is a space in the string.            */
/* Side effects: none                                                     */
/**************************************************************************/

int checkspace(unsigned char *s)
{
  if (ISSPACE(*s) || (*s == DB_SP_HI && *(s+1) == DB_SP_LO))
    return (TRUE);
  else
    return (FALSE);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fastopen\fastsm.asm ===
PAGE	90,132			;A2

	TITLE	fastsm.SAL - fastopen SYSTEM MESSAGES
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: fastsm.SAL

; DESCRIPTIVE NAME: Include the DOS system MESSAGE HANDLER in the SEGMENT
;		    configuration expected by the modules of fastopen.

;FUNCTION: The common code of the DOS SYSTEM MESSAGE HANDLER is made a
;	   part of the fastopen module by using INCLUDE to bring in the
;	   common portion, in SYSMSG.INC.  This included code contains
;	   the routines to initialize for message services, to find
;	   where a particular message is, and to display a message.

; ENTRY POINT: SYSDISPMSG:near
;	       SYSGETMSG:near
;	       SYSLOADMSG:near

; INPUT:
;    AX = MESSAGE NUMBER
;    BX = HANDLE TO DISPLAY TO (-1 means use DOS functions 1-12)
;    SI = OFFSET IN ES: OF SUBLIST, OR 0 IF NONE
;    CX = NUMBER OF %PARMS, 0 IF NONE
;    DX = CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW
;   CALL SYSDISPMSG		;DISPLAY THE MESSAGE

;    If carry set, extended error already called:
;    AX = EXTENDED MESSAGE NUMBER
;    BH = ERROR CLASS
;    BL = SUGGESTED ACTION
;    CH = LOCUS
; _ _ _ _ _ _ _ _ _ _ _ _

;    AX = MESSAGE NUMBER
;    DH = MESSAGE CLASS (1=DOS EXTENDED ERROR, 2=PARSE ERROR, -1=UTILITY MSG)
;   CALL SYSGETMSG		 ;FIND WHERE A MSG IS

;    If carry set, error
;     CX = 0, MESSAGE NOT FOUND
;    If carry not set, ok, and resulting regs are:
;     CX = MESSAGE SIZE
;     DS:SI = MESSAGE TEXT
; _ _ _ _ _ _ _ _ _ _ _ _

;   CALL SYSLOADMSG		 ;SET ADDRESSABILITY TO MSGS, CHECK DOS VERSION
;    If carry not set:
;    CX = SIZE OF MSGS LOADED

;    If carry is set, regs preset up for SYSDISPMSG, as:
;    AX = ERROR CODE IF CARRY SET
;	  AX = 1, INCORRECT DOS VERSION
;	  DH =-1, (Utility msg)
;	OR,
;	  AX = 1, Error loading messages
;	  DH = 0, (Message manager error)
;    BX = STDERR
;    CX = NO_REPLACE
;    DL = NO_INPUT

; EXIT-NORMAL: CARRY is not set

; EXIT-ERROR:  CARRY is set
;	       Call Get Extended Error for reason code, for SYSDISPMSG and
;	       SYSGETMSG.

; INTERNAL REFERENCES:
;    ROUTINES: (Generated by the MSG_SERVICES macro)
;	SYSLOADMSG
;	SYSDISPMSG
;	SYSGETMSG

;    DATA AREAS:

;	INCLUDE SYSMSG.INC   ;Permit System Message handler definition
;
; EXTERNAL REFERENCES:
;    ROUTINES: none

;    DATA AREAS: control blocks pointed to by input registers.

; NOTES:

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 fastopen.asm.

; REVISION HISTORY: A000 Version 4.00: add PARSER, System Message Handler,
;
; COPYRIGHT: "MS DOS FASTOPEN Utility"
;	     "Version 4.00 (C)Copyright 1988 Microsoft "
;	     "Licensed Material - Property of Microsoft "
;
;****************** END OF SPECIFICATIONS *****************************
	IF1				;					;AN000;
        ;    %OUT    COMPONENT=fastopen, MODULE=fastsm.asm...
	ENDIF				;					;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =

HEADER	MACRO	TEXT			;;					;AN000;
.XLIST					;;
	SUBTTL	TEXT
.LIST					;;
	PAGE				;;					;AN000;
	ENDM				;;					;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AN000;
	MSG_UTILNAME <fastopen> 	;IDENTIFY THE COMPONENT 		;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	HEADER	<DEFINITION OF MESSAGES> ;					;AN000;
CSEG_INIT    SEGMENT PARA PUBLIC 'CODE' ;
	   ASSUME CS:CSEG_INIT		;ESTABLISHED BY CALLER
	   ASSUME DS:CSEG_INIT		;ESTABLISHED BY CALLER
	   ASSUME ES:CSEG_INIT		;ESTABLISHED BY CALLER

	   PUBLIC COPYRIGHT	   ;						;AN000;
COPYRIGHT  DB	 "MS DOS FASTOPEN Utility " ;                 ;AN000;
	   INCLUDE COPYRIGH.INC    ;						;AN000;
	   HEADER <MESSAGE DATA AREAS> ;					;AN000;
	   MSG_SERVICES <MSGDATA>  ;WORKAREAS FOR SYSTEM MESSAGE HANDLER	;AN000;
; =  =	=  =  =  =  =  =  =  =	=  =
	   HEADER <SYSTEM MESSAGE HANDLER> ;					;AN000;
	   PUBLIC SYSLOADMSG	   ;						;AN000;
	   PUBLIC SYSDISPMSG	   ;						;AN000;


	MSG_SERVICES <FASTOPEN.CLA,FASTOPEN.CL1,FASTOPEN.CL2> ;

				   ;DEFAULT=CHECK DOS VERSION
				   ;DEFAULT=NEARmsg
				   ;DEFAULT=INPUTmsg
				   ;DEFAULT=NUMmsg
				   ;DEFAULT=NO TIMEmsg
				   ;DEFAULT=NO DATEmsg

.xlist
.xcref
	MSG_SERVICES <LOADmsg,GETmsg,DISPLAYmsg,INPUTmsg,CHARmsg,NUMmsg> ;AN000;
	include msgdcl.inc
.cref
.list
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
CSEG_INIT	ENDS			;
	   END			   ;						;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fastopen\fastopen.asm ===
Page 84,132 ;


Title	FASTOPEN
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;Date: Jan 15,1989
;==============================================================================
;		 EQUATES
;==============================================================================
Is_drive_head	   EQU	   00000001b								   ;AN000;
Is_delete	   EQU	   00000010b								   ;AN000;
Is_insert	   EQU	   00000100b								   ;AN000;
Not_drive_head	   EQU	   11111110b								   ;AN000;
Not_delete	   EQU	   11111101b								   ;AN000;
Not_insert	   EQU	   11111011b

DYNA_ALLOC         EQU     2               ; EMS dynamic allocation (for IBM)

EMS_SAVE_STATE	   EQU	   4FH									   ;AN000;
EMS_RESTORE_STATE  EQU	   4FH									   ;AN000;
EMS_INT 	   EQU	   67H									   ;AN000;
DOS_PAGE1	   EQU	   0FEH 								   ;AN000;


;==============================================================================
;		   INCLUDE  FILES
;==============================================================================
.xcref
.xlist
debug=0 		   ; an equate only for DOSMAC.inc				     ;AN000;
INCLUDE  DOSMAC.inc										    ;AN000;
.list
.cref
INCLUDE  dirent.inc										    ;AN000;
INCLUDE  fastsegs.inc	   ; this cannot include in Fastopen.inc
INCLUDE  fastopen.inc	   ; this include file also contains DOS equates			    ;AN000;
include  version.inc

BUFFERFLAG	EQU	TRUE            ;M005


;==============================================================================




; IBM Revision History:
;	     AN002  -  Jan 10,1989  EMS Dynamic page allocation

;============================================================================

CSEG_MAIN   SEGMENT   PARA   PUBLIC 'code'
	ASSUME	cs:cseg_main, ds:nothing,es:nothing,ss:nothing
;============================================================================

PUBLIC	MAIN											   ;AN000;

;;;; johnhe 12/31/89 ;;; PUBLIC	SAVE_EMS_PAGE_STATE

PUBLIC	EMS_PAGE_NUMBER
PUBLIC	EMS_PAGE_MAP
PUBLIC	EMS_PAGE_ARRAY

PUBLIC	RESTORE_PAGE_STATE
PUBLIC	EMS_SAVE_HANDLE1

PUBLIC	Main_name_cache_seg									   ;AN000;
PUBLIC	Main_Num_Of_drives									   ;AN000;


PUBLIC	Main_name_cache_Buff									   ;AN000;
PUBLIC	Main_EMS_FLAG			; for IBM, 2= /X, 1=/XS, 2=/XD, 0=EMS not enabled             ;AN000;
PUBLIC	Main_Res_Segs										   ;AN000;
PUBLIC	Main_EMS_PAGE_SIZE									   ;AN000;
PUBLIC	Main_EMS_PAGE_SEG									   ;AN000;


PUBLIC	Main_Total_Name_Count									   ;AN000;
PUBLIC	Main_Name_Drive_Buff									   ;AN000;
PUBLIC	Main_ParamBuff										   ;AN000;

PUBLIC	FOPEN_Insert										   ;AN000;
PUBLIC	FOPEN_Update										   ;AN000;
PUBLIC	FOPEN_Delete										   ;AN000;
PUBLIC	FOPEN_Lookup										   ;AN000;
PUBLIC  FOPEN_Rename                    ;BN00X                                                      ;AN000;
PUBLIC	FOPEN_PURGE										  ;AN000;


PUBLIC	 VECTOR_LookUp										  ;AN000;



; Following data variables are accessed by all other segments
call_cnt	       DW    0									;AN000;
Purge_Flag	       DW    0		   ; =1 if last call is PURGE function
Prev_drv_id	       DB    -1 	   ; previous request drive id
Main_name_cache_seg    DW    Cseg_Init	   ; default to Init1 seg				;AN000;
Main_Num_Of_drives     DW    0		   ; number of drives					;AN000;


Main_name_cache_Buff   DW    0		   ; address of Name cache buffer			;AN000;


Main_EMS_FLAG	       DW    0		   ; EMI flag  1= if EMI is enabled			;AN000;
				           ; IBM: EMS flag 1=/X  2=/XS 3=/XD  0=No EMS              ;AN000;
Main_Res_Segs	       DW    0		   ; number of segs to be stay resident 		;AN000;


Main_Total_Name_Count  DW    0		   ; Total name count entries				;AN000;
Main_Name_Drive_Buff   DW    0		   ; EMS data page segment ID				;AN000;
Main_ParamBuff	       DW    50  dup (0)   ; Drive ID/extent count buffer			;AN000;

; The following structure is for saving and restoring EMS page state

EMS_PAGE_MAP	     LABEL    WORD
Main_EMS_SEG_COUNT     DW    1		   ; EMS segment count
Main_EMS_PAGE_SEG      DW    0		   ; EMS page segment ID				;AN000;


Main_EMS_PAGE_SIZE     DW    0		   ; EMS page size					;AN000;
EMS_PAGE_ARRAY	       DW  30	dup  (0)   ; EMS state save array

; The following data values are used by MAIN segment
EMS_SAVE_LOG_PAGE1     DW    ?		   ;HOLDS PREVIOUS PAGE1				    ;AN000;
EMS_SAVE_HANDLE1       DW    ?		   ;HOLDS PREVIOUS handle1				    ;AN000;

EMS_PAGE_NUMBER		DW	?			; holds the ems 
							; physical page no.
;
;-----------------------------------------------------------------------------
;	  Fastopen/Fastseek function jump vectors
; Inititally the jump vectors have default offset and segment values.
; If the modules are relocated, the offset and the segID in the jump vectors
; may be changed to the new segID of the new location.
;-----------------------------------------------------------------------------
FOPEN_Insert	 DD   Insert									 ;AN000;
FOPEN_Update	 DD   Update									 ;AN000;
FOPEN_Delete	 DD   delete									 ;AN000;
FOPEN_Lookup	 DD   lookup									 ;AN000;
FOPEN_Rename     DD   Rename           ;BN00X                                                           ;AN000;
FOPEN_Purge	 DD   FP_purge									 ;AN000;


VECTOR_LookUp	 DD   LookUp	      ; jump vector to LookUp used by Insert call



;==============================================================================

MAIN	PROC	FAR			  ; FAR procedure for FAR call from DOS
	push	cx			  ; save DOS registers				     ;AN000;
	push	dx			  ; makesure to restore the necessary			   ;AN000;
	push	ds			  ; ones on return					  ;AN000;
	push	es										   ;AN000;
	push	bp										   ;AN000;
	push	di										   ;AN000;
	push	bx										   ;AN000;

;-----------------------------------------------------------------------------
; The cache buffers are maintained in a seperate segement whose segment ID is
; in Name_Cache_Seg.  The ES will be used as the seg register during the access
; of data in the cache buffers, while DS will be used to access the Fastopen
; resident and non-resident data area.
;-----------------------------------------------------------------------------
	cmp	cs:Main_EMS_flag,0	  ; EMS enabled ??					     ;AN000;
	je	dispatch_funcs		  ; no - dispatch functions			   ;AN000;
					  ; yes - save EMS page state

	; NOTE:
	;	If BUFFERFLAG == TRUE it means that we're not using
	;	IBMs method of leaving the EMS pages always mapped in
	;	and instead are using the Microsoft method of mapping
	;	the pages in only when they are needed.
	;

IF	NOT BUFFERFLAG

	CMP	Main_EMS_Flag,DYNA_ALLOC   ;AN002; dynamic allocation
	JE	DYNA_SAVE_STATE 	  ;AN002; yes - do save for dynamic
;-----------------------------------------------------------------------------
; SAVE EMS PAGE STATE
;-----------------------------------------------------------------------------

;;;; johnhe 12/31/89;	CALL	FAR PTR SAVE_EMS_PAGE_STATE  ; save EMS page context
	call	Save_Ems_Page_State	  ; johnhe 12/31/89

	JNC	DISPATCH_FUNCS		  ; if no error, dispatch Fastopen functions
	JMP	ERROR_RET		  ; else error

DYNA_SAVE_STATE:

ENDIF

;------------------------------------------------------------HKN 8/26/88--
;	Before dispatching off the fastopen functions we must do the 
;	following:
;		1. save the map for this page
;		2. map this page to log. page 0 with the fastopen handle in
;		   ems_save_handle1.
;		3. dispatch
;

;;;; johnhe 12/31/89;	call	far ptr	save_ems_page_state
	call	Save_Ems_Page_State	  ; johnhe 12/31/89

	jc	ems_failed

	call	map_page
	jnc	DISPATCH_FUNCS

EMS_FAILED:
	JMP	ERROR_RET		 ; error return

;-----------------------------------------------------------------------------
; FASTOPEN/FASTSEEK DISPATCHER
;-----------------------------------------------------------------------------

DISPATCH_FUNCS:
	cmp	al,5		      ; buffer purge ??
	je	Check_Drive_id	      ; yes - check drive id
	jmp	SHORT Dispatch_fopen  ; yes - dispatch Fastopen functions			  ;AN000;

;-----------------------------------------------------------------------------
; Check to see the Drive ID in DL is the valid. If not error and return DI=1
; if Fastseek LookUp function. Makesure to preserve AL, DS, SI and DI
;-----------------------------------------------------------------------------
CHECK_DRIVE_ID:
	cmp	cs:Prev_drv_id, dl	    ; current id same as previous valid
	je	DISPATCH_FUNCTION	    ; yes - dont check drive ID

	push	si										   ;AN000;
	push	bx			    ;DS=addressability to Cseg_Main			   ;AN000;
	push	cx										   ;AN000;
	lea	si,cs:Main_ParamBuff	    ; DS:SI-->drive ID buffer				   ;AN000;
	mov	cx,cs:Main_Num_Of_Drives    ; number of drives					   ;AN000;

Get_Drive_Id:											   ;AN000;
	mov	bx,cs:[si]									   ;AN000;
	cmp	bl,dl			    ; drive ID match ?? 				   ;AN000;
	je	drive_found		    ; yes, drive ID found				   ;AN000;
	add	si,4			    ; (2/11) no, move pointer to next ID		   ;AN000;
	LOOP	get_drive_id		    ; check next drive id				   ;AN000;

Drive_Not_Found:			    ; drive id not found
	pop	cx			    ; restore registers 				   ;AN000;
	pop	bx										   ;AN000;
	pop	si										   ;AN000;
	jmp	Error_Exit		    ; return

Drive_Found:				    ; drive ID found
	mov	cs:Prev_drv_id,dl	    ; save drive id as prev drive id
	pop	cx			    ; restore registers 				   ;AN000;
	pop	bx			    ; and do the specified function			   ;AN000;
	pop	si										   ;AN000;

;-----------------------------------------------------------------------------

DISPATCH_FUNCTION:			  ; RMFS

	cmp	al,010H
	jle	Fsk_Cont
	inc	cs:call_cnt									   ;AN000;

Fsk_Cont:
	push	cs			   ; set addressability
	pop	ds			   ; CS = DS = Cseg_Main segment
	ASSUME	ds:Cseg_Main
	cmp	al,FONC_Purge		   ; PURGE call ??					       ;AN000;
	je	chk_05			   ; yes - continue						;AN000;

	mov	cs:Purge_Flag, 0	   ; reset purge flag


Chk_05:
	cmp	cs:Purge_Flag, 1	   ; previous call is purge ??				    ;AN000;
	jne	Purge_buffs		   ; no - purge the buffers
	clc				   ; yes - exit
	jmp	short exit										      ;AN000;

Purge_Buffs:
	mov	cs:Purge_Flag,1 	   ; set purge flag


Reset_Fopen:
	cmp	CS:Main_Total_Name_Count,0	    ; reset fopen buffs??
	je	Reset_Exit		   ; no - reset f
	CALL	CS:FOPEN_PURGE		      ; reset extent cache			       ;AN000;

Reset_Exit:
	clc
	jmp	short exit										 ;AN000;


; NOTE: Carry Flag state from Function calls must be correctly returned
;	to the DOS, especially from Fastseek Lookup function


;-----------------------------------------------------------------------------
;	FASTOPEN FUNCTION DISPATCHER
;-----------------------------------------------------------------------------
DISPATCH_FOPEN: 		      ; dispatch FOPEN functions
	cld											   ;AN000;
	mov	cs:Purge_Flag, 0      ; reset purge flag
	cmp	al, FONC_update 								   ;AN000;
	jne	Chk_02										   ;AN000;
	CALL	CS:Fopen_Update       ; UPDATE							   ;AN000;
	jmp	short exit										 ;AN000;

Chk_02:
	cmp	al, FONC_insert 								   ;AN000;
	jne	Chk_01										   ;AN000;
	CALL	CS:Fopen_Insert       ; INSERT							   ;AN000;
	jmp	short exit										 ;AN000;
Chk_01:
	cmp	al, FONC_look_up								   ;AN000;
	jne	chk_06
	CALL	CS:Fopen_lookup       ; LOOKUP							   ;AN000;
	jmp	short exit										 ;AN000;
Chk_06: 			      ;BN00X
	cmp	al, FONC_Rename       ;BN00X							   ;AN000;
	jne	chk_03		      ;BN00X							   ;AN000;
	CALL	CS:Fopen_Rename       ;BN00X  RENAME							 ;AN000;
	jmp	short exit	      ;BN00X								 ;AN000;
Chk_03:
	cmp	al, FONC_delete 								   ;AN000;
	jne	Error_Exit									   ;AN000;
	CALL	CS:Fopen_delete       ; DELETE							   ;AN000;
	jmp	short exit										 ;AN000;



;-----------------------------------------------------------------------------
;  EXIT TO DOS FROM FUNCTIONS
;-----------------------------------------------------------------------------

ERROR_EXIT:	     ; EXIT from invalid drive id search loop
	CALL	RESTORE_PAGE_STATE     ; restore frame buff status				   ;AN000;
				       ; on return AX should have function code
	pop	bx		       ; restore first two regs of DOS
	pop	di										   ;AN000;


	clc											   ;AN000;
	jmp	short Exit_1									   ;AN000;


; Normal Exit from Fastopen Functions except Fastseek Lookup function
EXIT:
	CALL	RESTORE_PAGE_STATE     ; restore EMS page state 				   ;AN000;;AN000;
	pop	bx		       ; restore BX						   ;AN000;
	pop	di		       ; restore DI						   ;AN000;


; Exit from FastSeek Lookup function. Dont restore BX and DI
EXIT_1:
	pop	bp		       ; restore remaining DOS registers
	pop	es		       ; except BX and DI since they contain								;AN000;
	pop	ds		       ; return values. 					    ;AN000;
	pop	dx										   ;AN000;
	pop	cx										   ;AN000;

ERROR_RET:
	ret											   ;AN000;

MAIN	ENDP


;---------------------------------------------------------------------------
;	Procedure name	:	save_ems_page_state
;	
;	Description:
;		Saves the state of the page whose physical segment value is
;	specified in Main_EMS_PAGE_SEG. 
;---------------------------------------------------------------------------

SAVE_EMS_PAGE_STATE	PROC	NEAR

	PUSH	AX			  ; save registers
	PUSH	DS										   ;AN000;
	PUSH	ES										   ;AN000;
	PUSH	SI										   ;AN000;
	PUSH	DI										   ;AN000;

	MOV	AX, SEG EMS_PAGE_MAP	  ; get segid
	MOV	DS,AX
	LEA	SI,EMS_PAGE_MAP 	  ; DS:SI-->page map struc
	MOV	AX, SEG EMS_PAGE_ARRAY	  ; get segid
	MOV	ES,AX
	LEA	DI,EMS_PAGE_ARRAY	  ; ES:DI-->Page ARRAY
	MOV	AH,EMS_SAVE_STATE	  ;
	MOV	AL,0			  ; subfunction code
	INT	EMS_INT 		  ; save page state							    ;AN000;

	add	AH,0ffh 		  ; Set carry if AH != 0

	POP	DI										   ;AN000;
	POP	SI										   ;AN000;
	POP	ES										   ;AN000;
	POP	DS										   ;AN000;
	POP	AX
	RET

SAVE_EMS_PAGE_STATE	ENDP



;-----------------------------------------------------------------------------
; PROCERDURE:  RESTORE_PAGE_STATE
;
; Function:    Restore state of EMS page
;
; Input:       None
; Output:      Page is restored
;
;-----------------------------------------------------------------------------

RESTORE_PAGE_STATE    PROC  NEAR	;RESTORE EMS PAGE STATE

	PUSHF				;save flag					     ;AN000;
	CMP	CS:MAIN_EMS_FLAG, 0	;EMS enabled ?? 				     ;AN000;
	JNE	REST_PUSH_REGS		;yes, restore registers
	JMP	SHORT RESTORE_EXIT	;no, exit					     ;AN000;
					;yes, restore page registers
REST_PUSH_REGS:
	PUSH	AX			; save function code
	PUSH	DS									     ;AN000;
	PUSH	SI									     ;AN000;

	MOV	AX, SEG EMS_PAGE_ARRAY
	MOV	DS,AX
	LEA	SI,EMS_PAGE_ARRAY	; DS:SI-->Page array
	MOV	AH,EMS_RESTORE_STATE	;
	MOV	AL,1			;
	INT	EMS_INT 		; restre page state
					; Don't care about error cause
					; there's nothing that can be
					; done at this point if there
					; one

	POP	SI									      ;AN000;
	POP	DS									      ;AN000;
	POP	AX			; restore function code

RESTORE_EXIT:
	POPF
	RET										      ;AN000;

RESTORE_PAGE_STATE    ENDP



;---------------------------------------------------------HKN 8/26/88-------
;	procedure name		:	map_page
;	Inputs			: 	ems_page_number = physical page frame
;							  number.
;					ems_save_handle1 = emm_handle.
;	Output			: 	CY - error
;					NC - page is mapped to logical page 0
;----------------------------------------------------------------------------
map_page	proc	near

	push	ax
	push	bx
	push	dx

	xor	bx, bx
	mov	ax, cs:ems_page_number	; contains the page number obtained 
					; during fastopen intialization.
	mov	ah, 44h
	mov	dx, cs:ems_save_handle1	; contains the emm handle that was
					; obtained during fast init.
	int	ems_int
	add	AH,0ffh 		; Set carry if AH != 0

map_page_done:
	pop	dx
	pop	bx
	pop	ax
	ret

map_page	endp

	
					 ; NOTE:
CSEG_MAIN   ENDS			 ; End of the first portion of the
					 ; Cseg_Main segment.  Remaining
					 ; portion is in Fastinit.asm

;-----------------------------------------------------------------------------





;==============================================================================
; All Fastopen functions are kept in a seperate segment.  These are accessed
; by a FAR indirect call from the MAIN routine.
; ADDRESSABILTY: CS is used for accessing local data in Cseg_Open segment
;		 DS is used for accessing data in the drive cache buffer
;					  in the Cseg_Init segment
;		 ES is used for accessing data in the name cache buffer
;					  in the Cseg_Init segment
;
;*****************************************************************************
CSEG_OPEN   SEGMENT   PARA   PUBLIC 'code'
  ASSUME  cs:cseg_open,ds:nothing,es:nothing,ss:nothing
;*****************************************************************************

PUBLIC	 Open_name_cache_seg									   ;AN000;
PUBLIC	 Open_name_Drive_Buff									   ;AN000;
PUBLIC	 End_Open										   ;AN000;
PUBLIC	 Chk_Flag										   ;AN000;

;---- FastOpen Functions Local Variables --------------

Current_Node	     DW    ?	     ;address of current node entry buffer		     ;AN000;
Current_Sibling      DW    ?	     ;address of current sibling node entry buffer		;AN000;
Current_Drive	     DW    ?	     ;address of current drive header			     ;AN000;
Matching_Node	     DW    -1	     ;flag						       ;AN000;
From_Delete	     DW    0	     ;= 1 if call is from DELETE function		    ;AN000;
Old_SI		     DW    0	     ;SI save area				     ;AN000;
Flag		     DB    0									;AN000;
Level		     DB    0	     ;depth level of the path					;AN000;
Dir_Info_Buffer      DD    ?	     ;Dir_Info buffer inside DOS				;AN000;
Extended_Info_Buffer DD    ?	     ;Extended Info buffer inside DOS			;AN000;
New_FEI_clusnum      DW    0									;AN000;
Packed_Name	     DB    11 dup (0)	   ;Space for packed dir name				;AN000;
Top		     DW    0									;AN000;
Temp		     DW    0									;AN000;
Bottom		     DW    0									;AN000;
Depth		     DB    0									;AN000;

Chk_Flag	     dw    0	     ; flag used by the analyser
func_cod	     db    0	     ; function code for analyser

;Following data area is filled during initialization
Open_name_cache_seg	   DW	 Cseg_Init     ; address of name cache buffer
Open_name_Drive_Buff	   DW	 0	       ; address of first drive buffer




;
;==============================================================================
;		    Pathname Tree Search
;
;  Element of each path name is represented by a node in the tree.  First
;  node is connected to the the Drive header through first child pointer
;  (DCH_Child_Ptr).  The first node may have one or more nodes underneath.
;  The first one is called the Child of this node and the others are the siblings
;  of the child node.  Previous node is connected to the first node through
;  the child pointer (nChild_Ptr) and the siblings are connected through the
;  sibling pointer (nSibling_Ptr).  Each node is connected to the previous
;  node through a backward pointer (nBackward_Ptr).  For example, to go to the
;  previous node from any of the siblings. It is necessary to go to the
;  child through previous siblings (if any) and then to the previous from the
;  child.  All this backward movement is using nBackward_Ptr.
;  Similarly to go to a child or sibling, nChild_ptr or nSibling_Ptr should be
;  used.  The strucure of drive header and the node are defined in Fastopen.inc
;

;==============================================================================
;Subroutine:  LOOKUP
;
;INPUT:
;    DS:SI -> path  (drive letter D: will be validated by Find_Drive_Cache_hdr)
;    ES:DI -> DIR_INFO buffer to be returned inside DOS
;    ES:CX -> FASTOPEN_Extended_Info buffer inside DOS
;    ES:BP -> Drive_Cache_Heade
;
;
;OUTPUT:
;     If the whole path is found,
;	 DS:SI--> 0
;	 ES:DI--> DIR_INFO buffer is filled with directory info
;	 ES:CX--> EXT_INFO buffer is filled with extended info
;
;     If partially found the path,
;	 DS:SI--> '\' after the matching directory name
;	 ES:DI--> DIR_INFO buffer is filled with directory info
;	 ES:CX--> EXT_INFO buffer is filled with extended info
;
;     If the Name_cache tree is empty, i.e.,no root directory name,
;	 DS:SI--> '\' after ':'
;	 ES:DI--> DIR_INFO buffer is undetermined
;	 ES:CX--> EXT_INFO buffer is undetermined
;
;==============================================================================

LOOKUP	PROC   FAR

	mov	cs:func_cod,al		   ; save function code
	cmp	From_Delete, 0		   ;call from DELETE function ??
	je	Look_Pack_Dir		   ;no, dont restore DS
	mov	DS,bx			   ;yes, restore DS
	ASSUME	DS:Cseg_Init
	jmp	short Look_save_regs	   ;save registers

Look_Pack_Dir:
	CALL	PACK_DIR_NAME		   ;on return drive letter => DL,

	CALL	FIND_DRIVE_CACHE_HEADER    ;find drive header address
					   ;on return ES:BP-->drive header
	jnc	look_save_regs		   ;drive buffer found
	jmp	lookup_error		   ;drive buffer not found

Look_Save_Regs:
	push	es
	push	di
	push	cx
	mov	ax, cs:Open_Name_Cache_Seg							   ;AN000;
	mov	es, ax			   ;ES = Name_Cache_Seg 				      ;AN000;
	ASSUME	es:Cseg_Init									   ;AN000;
	CALL	SET_LRU 		   ;set the Real LRU, if any.

	or	cs:Flag,Is_drive_head	   ;level of the tree. Drive header
	mov	cs:Matching_Node, -1	   ;Nothing found yet.
	mov	cs:Current_Drive, BP	   ;drive header
	mov	cs:Level, 0		   ;path level is 0

Lookup_Path:
	mov	cs:Current_Node, BP	   ;save current node address
	mov	cs:Current_Sibling,0fffeh  ;set no sibligs yet.
	mov	cs:Old_SI, si		   ;save current path address

	CALL	PACK_DIR_NAME		   ;get the next dir name from the path
	jc	Lookup_Done		   ;yes, found the whole path.

	test	cs:Flag, Is_drive_head	   ;dir name = drive header ?
	jz	Lp_Path1		   ;no-

	push	ds			   ;yes-drive header
	mov	ds,cs:Open_Name_Cache_Seg
	ASSUME	ds:Cseg_Init
	mov	BP, DS:[BP.DCH_Child_ptr]  ;BP-->first child node under drive hdr
	pop	ds
	ASSUME	ds:nothing
	jmp	short Lp_Path2

Lp_Path1:
	mov	BP, ES:[BP.nChild_ptr]	   ;BP--> child of current node

Lp_Path2:
	cmp	BP, -1			   ;no child?
	je	Lookup_Done		   ;Not found or partially found
	mov	cs:Current_Node, BP	   ;current_node = found node
	and	cs:Flag, Not_drive_head    ;reset the flag.

Lp_Cmpare:
	CALL	CMPARE			   ;look for path in current node
	je	Lookup_Found		   ;Yes, found a match. Next level for
					   ;possible remianing path

	mov	BP, ES:[BP.nSibling_ptr]   ;not found. Any siblings?
	mov	cs:Current_Sibling,BP
	cmp	BP, -1			   ;any more sibling?
	je	Lookup_Done		   ;no - done

	mov	cs:Current_Node, BP	   ;yes- make the found sibling as a current
	jmp	short Lp_Cmpare 	   ;node and search path in this node

Lookup_Found:
	inc	cs:Level
	mov	cs:Matching_Node,BP	   ;Used by Unfold_Name_Record

	CALL	PRE_LRU_STACK		   ;set the TEMP_LRU_Stack
	jmp	Lookup_Path		   ;continue to the next dir

Lookup_Done:
	mov	si, cs:Old_SI
	pop	cx			   ;restore Extended_Info buffer
	pop	di			   ;restore Dir_Info buffer
	pop	es			   ;the segment for the above buffers

	cmp	ax, -1
	je	Lookup_ERR		   ;error occured in Pack_Dir_Name.
	clc				   ;clear carry.
	jmp	short Lookup_Done1

Lookup_ERR:				   ;error exit
	stc

Lookup_Done1:
	test	cs:Flag, is_delete	   ;called by delete?
	jnz	Lookup_Return
	jc	Lookup_Exit		   ;If it was an error, don't change the carry flag

	CALL	UNFOLD_NAME_RECORD	   ;unfold the current node's record
Lookup_Exit:
	jmp	short Lookup_Return	   ;return to DOS.

Lookup_Error:				   ;error exit
	stc
	mov    ax,-1

Lookup_Return:				   ;return to Delete routine.
	CALL	Check_It		   ;check tree structure
	ret

LOOKUP	 ENDP





;==============================================================================
;SUBROUTINE: INSERT
;
;INPUT:    DS:DI -> Dir_Info in DOS
;	   ES:BX -> Fastopen_Extended_Info in DOS
;	   Current_Node, Current_Sibling, Current_Drive, Flag
;
;OUTPUT:   Information inserted into Name_cache_tree.
;
;   Any Sequential Insert operation should be preceded by a Look_up
;   operation. For ex., if the DOS wants to insert C:\DIR1\DIR2\File1
;   and suppose there is no matching name cache record for DIR1 in the tree.
;   Firstly DOS will try to look up C:\DIR1\DIR2\File1.  FASTOPEN will
;   return to DOS with DS:SI points to "\" after the drive letter.
;   Then, DOS will simply ask an insert operation with DS:DI, ES:BX
;   points to the information on "DIR1".  FASTOPEN will insert DIR1
;   onto the tree.  After that DOS will ask another insert
;   operation for DIR2.  FASTOPEN will insert DIR2.  Finally DOS will
;   ask to insert File1.
;
;   Suppose when DOS try to look up C:\DIR1\DIR2\File2 at this moment.
;   FASTOPEN will return to DOS with DS:SI points to "\" after DIR2 (since
;   DIR2 information is already in the name cache tree).  Then DOS will ask
;   to insert File2.
;
;   Any Insert operation of subdirectory name which is deeper than (Number_
;   of_Entries - 1) will not be inserted but will just return.
;   Also, for the safety reason, if the would be freed node (=LRU node) is
;   the same as the Current_Node, there will be no insertion. (This is a simple
;   safety valve.  A more smart logic can look for the next **legitimately
;   available** LRU node to use, or sometimes, simply replace the contents of the
;   entry if adequate. But this will increase the complexity greatly, and I
;   think the current logic is still practical enough to use despite of the
;   possible small window of performance degradation in a very special cases. J.K.)
;
;==============================================================================

INSERT	PROC   FAR
	mov	cs:func_cod,al			; save function code
	inc	cs:Level			;increment directory level
	xor	ax,ax
	mov	al, cs:Level
	inc	al
	mov	bp, cs:Current_Drive		;BP-->address of current drive header
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg	;DS=name cache segment

	ASSUME	ds:Cseg_Init									   ;AN000;
	cmp	ax, ds:[bp.DCH_Num_Entries]	;Level > (Num_Entries - 1) ?
	pop	ds
	ASSUME	ds:nothing
	jbe	Insert_it			;no- insert it
	jmp	short Insert_return		;yes return

Insert_it:
	or	cs:Flag, is_insert

	CALL	GET_FREE_NODE		   ;AX = offset value of the available
					   ;name_record in Name_Cache_Seg.
	jc	I_Exit			   ;Current node = would-be freed node.

	CALL	MAKE_NAME_RECORD	   ;Fill the above name record entry.
					   ;ES was changed to Name_Cache_Seg.

	mov	bp, cs:Current_Node	   ;set BP to current_node
	mov	bx, bp			   ;save it into bx
	cmp	cs:Current_Sibling,0fffeh  ;current node sibling node ??
	je	I_Child 		   ;no-child of preceding node
	mov	es:[bp.nSibling_ptr], ax   ;yes-make new node sibling of
	jmp	short I_Done		   ;current node

I_Child:				   ;set nChild_ptr
	test	cs:Flag,Is_drive_head	   ;drive level?
	jnz	I_Child_first		   ;Yes, must be the first child
	mov	es:[bp.nChild_ptr], ax	   ;no-make ndew node child of
	jmp	short I_Done		   ;current node

I_Child_first:				   ;this is the first child in this drive.
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg							   ;AN000;
	ASSUME	ds:Cseg_Init									   ;AN000;
	mov	ds:[bp.DCH_Child_ptr],ax   ;make new node 1st child current drive
	pop	ds
	ASSUME	ds:nothing
	mov	bx, cs:Current_Drive	   ;change bx to Current_Drive
	and	cs:Flag, Not_drive_head    ;reset the flag

I_Done:
	mov	bp, ax
	mov	es:[bp.nBackward_ptr],bx ;set the backward ptr of the inserted node.

	CALL	PRE_LRU_STACK		   ;save this inserted record temporarily.

	mov	cs:Current_Node,bp	   ;make new node current node
					   ;any subsequent insert operation
	mov	cs:Current_Sibling,0fffeh  ;should be installed as a child

I_Exit:
	and	cs:Flag, not_insert	   ;set not insert flag

Insert_return:
	CALL	Check_It		   ;check tree structure
	ret				   ;return

INSERT	ENDP






;==============================================================================
;Subroutine: DELETE
;
;INPUT:   DS:SI -> path
;	  ES:BP -> drive_cache_header (for Look_Up operation)
;
;OUTPUT:  if found, then remove the matching Name_Record will be removed from
;	  the tree and from the LRU chain.  The freed entry will be placed
;	  on top of the LRU chain.
;
;==============================================================================

DELETE	 PROC	FAR

	mov	cs:func_cod,al		   ; save function code
	CALL	PACK_DIR_NAME		   ;drive letter => DL, 				      ;AN000;

	CALL	FIND_DRIVE_CACHE_HEADER    ;find drive header address
					   ;on return ES:BP-->drive header
	jc	d_err_exit		   ;error exit

	or	cs:Flag, is_delete	   ;set the flag for Look_up.
	push	ds			   ;save DS in BX since it is going to be
	pop	bx			   ;changed for jumping to other segment
	push	ds
	mov	ax,cseg_Main
	mov	ds,ax			   ;DS=Main segment ID
	assume	ds:Cseg_Main
	mov	cs:From_Delete, 1	   ;set flag indicate that the call
					   ;is from DELETE function
	CALL	VECTOR_LOOKUP		   ;FAR call to Lookup function

	mov	cs:From_Delete, 0	   ;reset from delete flag
	pop	ds
	ASSUME	ds:nothing
	jc	D_err_Exit		   ;indirectly in the same segment

	cmp	byte ptr ds:[si], 0	   ;found the whole path?
	jne	D_err_Exit		   ;No.

;At this point, Current_Node = BP.
	mov	bx, cs:Open_Name_Cache_Seg
	mov	es, bx			   ;set ES to name_cache_seg.
	ASSUME	es:Cseg_Init

Delete_Node:
	cmp	es:[bp.nChild_ptr], -1	   ;No children?
	jne	D_err_Exit
	CALL	REMOVEFROMTREE		   ;remove the node while maintaing the
					   ;integrity of the tree.

	mov	es:[bp.nCmpct_Dir_Info], ' ' ;mark that this entry is free!!!

D_LRU_MRU:
	CALL	REMOVEFROMLRUCHAIN	   ;Remove BP from the LRU,MRU chain

	mov	si, cs:Current_Drive	   ;Now let the deleted node to be the
	push	ds			   ; LRU node
	mov	ds,cs:Open_Name_Cache_Seg
	ASSUME	ds:Cseg_Init									   ;AN000;

	mov	bx, ds:[si.DCH_LRU_ROOT]   ;es:bx -> first node
	mov	es:[bp.nLRU_ptr],bx	   ;Target.nLRU_ptr -> first node
	mov	es:[bx.nMRU_ptr],bp	   ;First_node.nMRU_ptr -> target
	mov	ds:[si.DCH_LRU_ROOT],bp    ;LRU_ROOT -> target
	mov	es:[bp.nMRU_ptr],-1
	pop	ds
	ASSUME	ds:nothing
	jmp	short	D_Exit		   ;exit

D_err_Exit:				   ;error exit
	stc
	mov	ax, -1

D_Exit:
	and	cs:Flag, not_delete	   ;reset the flag
	CALL	Check_It		   ;check tree structure
	ret				   ;return

DELETE	 ENDP






;==============================================================================
;Subroutine: RENAME
;
;INPUT:   DS:SI -> path
;	  DS:DI -> New directory name
;
;OUTPUT:  If found, rename the current directory name entry by the destination
;	  name.
;==============================================================================

RENAME	 PROC	FAR

	PUSH	DI			   ;;BN00X save new name address
	mov	cs:func_cod,al		   ;;BN00X save function code
	CALL	PACK_DIR_NAME		   ;;BN00X drive letter => DL,					     ;AN000;

	CALL	FIND_DRIVE_CACHE_HEADER    ;;BN00X find drive header address
					   ;;BN00X on return ES:BP-->drive header
	POP	DI			   ;;BN00X restore new name address
	jc	R_err_exit		   ;;BN00X error exit

	or	cs:Flag, is_delete	   ;;BN00X set the flag for Look_up.
	push	ds			   ;;BN00X save DS in BX since it is going to be
	pop	bx			   ;;BN00X changed for jumping to other segment
	push	ds
	mov	ax,cseg_Main
	mov	ds,ax			   ;;BN00X DS=Main segment ID
	assume	ds:Cseg_Main
	mov	cs:From_Delete, 1	   ;;BN00X set flag indicate that the call
					   ;;BN00X is from DELETE function
	PUSH	DI			   ;;BN00X save new name address
	CALL	VECTOR_LOOKUP		   ;;BN00X FAR call to Lookup function

	mov	cs:From_Delete, 0	   ;;BN00X reset from delete flag
	POP	DI			   ;;BN00X restore new name address
	pop	ds
	ASSUME	ds:nothing
	jc	D_err_Exit		   ;;BN00X indirectly in the same segment

	cmp	byte ptr ds:[si], 0	   ;;BN00X found the whole path?
	jne	D_err_Exit		   ;;BN00X No.

;At this point, Current_Node = BP.
	mov	bx, cs:Open_Name_Cache_Seg ;;BN00X
	mov	es, bx			   ;;BN00X set ES to name_cache_seg.
	ASSUME	es:Cseg_Init

; Rename the directory name entry by the destination name
Rename_Node:
	mov	si,di			   ;;BN00X SI-->new name
	mov	di,bp			   ;;BN00X DI-->directory name entry
	add	di,nCmpct_Dir_Info	   ;;BN00X ES:DI-->directory area
	mov	cx,11			   ;;BN00X 11 bytes
	REP	MOVSB			   ;;BN00X copy new name to the entry
	CLC
	JMP	SHORT R_Exit		   ;;BN00X then return

R_err_Exit:				   ;;BN00X error exit
	stc				   ;;BN00X
	mov	ax, -1			   ;;BN00X

R_Exit:
	and	cs:Flag, not_delete	   ;;BN00X reset the flag
	CALL	Check_It		   ;;BN00X check tree structure
	ret				   ;;BN00X return

RENAME	 ENDP				   ;;BN00X




;==============================================================================
;Subroutine:  UPDATE
;
;INPUT:  If AH = 0, then update Dir_Entry area.
;	     ES:DI -> Dir_entry ("dir_first" is the key to search).
;	     DL = Logical Drive number (0 = A, 1 = B, ...).
;
;	 If AH = 1, then update "Fastopen_extended_info.FEI_clusnum".
;	     DL = Logical Drive number (0 = A, 1 = B, ...)
;	     CX = The value of "dir_first" to search.
;	     BP = new value of FEI_clusnum in the extended_info area.
;
;	If AH = 2, then delete the entry. Same effect as Delete function
;	     except this time the keys used to delete are;
;	     DL = logical drive number
;	     CX = the value of "dir_first" to search.
;
;	If AH = 3, then delete the entry. Same effect as Delete function
;	     except this time the keys used to delete are;
;	     DL = logical drive number
;	     DH = directory position
;	     DI = directory sector (low value)
;	     CX = directory sector (high value)
;
;
;OUT:  if found, then data is updated
;      else CY and AX = -1.
;
;    This routine use "starting cluster number" and "drive letter"
;    as a key to find the name record.	Usually the reason is DOS
;    does not have any "full path" information about the file when
;    it has to call this routine to update the information.
;    It follows the MRU chain until it finds the name record or
;    until it reaches the free name record (identified by the
;    Directory name starting with ' '), or until the end of
;    the MRU chain.
;
;==============================================================================

UPDATE	PROC	FAR

	mov	cs:func_cod,al		 ; save function code
	cmp	ah, 0			 ;update directory entry ?
	je	Update_Dir_Entry	 ;yes-
	cmp	ah, 1			 ;update extended info ?
	je	Update_Extended_clusnum  ;yes-
	cmp	ah, 2			 ;delete based on first clus num ?
	je	Update_Delete		 ;yes-
	cmp	ah, 3			 ;delete based directory sector ?
	je	Update_Delete1		 ;yes-

U_ERROR:				 ;no - error exit
	stc
	jmp	short  Update_Exit

Update_Delete:				; same as delete
	CALL	FIND_CLUSTER_NUMBER	; find name entry using first cluster
	jc	U_ERROR
	jmp	Delete_Node		; if found, delete entry

Update_Delete1: 			; same as delete (PTR P3718  3/10/88)
	CALL	FIND_DIR_SECTOR 	; find name entry using directory
	jc	U_ERROR 		; sector and directory position
	jmp	Delete_Node		; if found, delete node

Update_Dir_Entry:
	mov	cx, es:[di.dir_first]
	push	es			;save Dir_Info pointer ES:DI
	push	di
	CALL	FIND_CLUSTER_NUMBER
	pop	si			;restore Dir_Info pointer in DS:SI
	pop	ds
	jc	U_ERROR 		;error-if not found

	push	bp			;found the entry
	pop	di
	add	di, nCmpct_Dir_Info	;ES:DI->Name_Record.nCmpct_Dir_Info
	mov	cx, ODI_head_leng
	REP	MOVSB			;update Cmpct_dir_info head section
	add	si, ODI_skip_leng
	mov	cx, ODI_tail_leng
	REP	MOVSB			;update tail section
	jmp	short  Update_Exit	;exit

Update_Extended_clusnum:		;update extended info field
	mov	cs:New_FEI_clusnum,bp
	CALL	FIND_CLUSTER_NUMBER	;Find entry based first cluster number
	jc	U_ERROR

	add	bp, nExtended_Info	;es:bp -> Name_record.nExtended_Info
	mov	bx, cs:New_FEI_clusnum
	mov	es:[bp.FEI_clusnum],bx

Update_Exit:
	CALL	Check_It		   ;check tree structure
	ret				;return

UPDATE	 ENDP






;==============================================================================
;Subroutine:  FP_PURGE	  Rest Name Cache Buffers
;
;INPUT:  Main_Name_Drive_Buff  -  Offset to Name cache buffer
;	 Main_Name_Cache_Seg   -  Name cache seg id
;	 DL = Drive ID
;
;OUT:	 Buffer is purged
;
;==============================================================================

FP_PURGE   PROC    FAR

	mov	si,Open_Name_Drive_Buff        ; SI-->first Name drive cache buff
	mov	es,Open_Name_Cache_Seg	       ; ES = name cache seg ID
	mov	bx,es:[si].DCH_Name_Buff       ; BX-->Name cache buffer
	inc	dl			       ; DL=drive number
	add	dl,040H 		       ; convert drive num to drive letter

; Search for the name drive header corresponds to the drive letter
Purge_Drv_Loop:
	cmp	es:[si].DCH_Drive_Letter,dl    ; drive letter match ??
	je	Purge_drive_cache	       ; yes - set drive cache
	add	si, size Drive_Cache_Header    ; no - get address of next drive cache
	jmp	purge_drv_loop		       ; try next name drive header

Purge_Drive_Cache:			       ; SI-->drive header
	mov	bx,es:[si].DCH_Name_Buff       ; BX-->Name cache buffer
	mov	cx,es:[si].DCH_num_entries     ; get number of name records
	mov	ax,bx			       ; save last name record address
	mov	es:[bx].nMRU_ptr, -1	       ; make first MRU -1
	jmp	short set_start

Set_Up_Names:
	mov	es:[bx].nMRU_ptr,ax		;save last name record as MRU entry
	add	ax, size Name_Record		;AX = last name record = current name record

Set_Start:
	mov	es:[bx].nChild_ptr, -1		;no children or siblings
	mov	es:[bx].nsibling_ptr, -1	;right now
	mov	es:[bx].nBackward_ptr, -1

	push	di
	push	ax
	mov	ax, '  '                        ;AX = ' '
	mov	di, bx				;DI-->current name record
	add	di, nCmpct_Dir_Info		;blank out the Dir name area
	stosb					;in the name record
	stosw
	stosw
	stosw
	stosw
	stosw
	pop	ax				; AX = last name record address
	pop	di

	dec	cx				;update record count
	jcxz	purge_exit			;exit if last name record is done
	mov	dx,bx
	add	dx, size Name_Record		;DX-->next name record
	mov	es:[bx].nLRU_ptr,dx		   ;set LRU pointer - next name record
	add	bx, size Name_Record
	jmp	set_up_names			;set next name record

Purge_exit:
	clc
	ret

FP_PURGE    ENDP



;----------------------------------------------------------------------------
;		    FASTOPEN  SUPPORT ROUTINES
;----------------------------------------------------------------------------
;
; PROCEDURE:  Find_Drive_Cache_Header
;
; Function:  Validate drive ID and find address of drive cache header
;
;IN:   DL - drive letter
;      Drive_Header_Start ;label
;      Flag.
;
;OUT:  If CY = 0    Drive Header found
;	     ES:BP -> Drive_Cache_Header,
;
;      If CY = 1    Drive Header not found
;
;----------------------------------------------------------------------------

FIND_DRIVE_CACHE_HEADER   PROC	  NEAR

	mov	bp, cs:Open_name_drive_buff
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg							   ;AN000;
	ASSUME	ds:Cseg_Init				;DS:BP-->first drive header    ;AN000;

FDCH_while:
	cmp	byte ptr ds:[bp.DCH_Drive_Letter], dl	; drive letter match
	jne	fdch_chk_end				; no - check next header
	clc						; yes - exit
	jmp	short FDCH_Exit

FDCH_Chk_End:
	cmp	byte ptr ds:[bp.DCH_Sibling_ptr], -1	; is this last header ?
	je	FDCH_Not_Found				; yes - header not found
	add	bp, size Drive_Cache_Header		; no - get next header
	jmp	short	FDCH_while			; look for match

FDCH_Not_Found:
	stc						;not found

FDCH_Exit:						;ES:BP-->header if found
	pop    ds
	ASSUME ds:nothing				;return
	ret

FIND_DRIVE_CACHE_HEADER     endp




;----------------------------------------------------------------------
; PROCEDURE:  GET_FREE_NODE
;
; called by Insert. The LRU node pointed DCH_LRU_ROOT is returned in AX
; and DCH_LRU_ROOT points to the following node in LRU chain.
; If the node is not an empty node, then it will be removed from the
; tree.
;
; IN:  Current_Drive, Current_Node
;
; OUT: AX = offset of the free node in Name_Cache_Seg
;     Other registers saved.
;----------------------------------------------------------------------

GET_FREE_NODE	PROC	NEAR

	push	es				 ;save registers
	push	di
	push	si
	push	bp

	mov	ax, cs:Open_Name_Cache_Seg							   ;AN000;
	mov	es, ax				;ES=Name cache segment				  ;AN000;
	ASSUME	es:Cseg_Init									   ;AN000;
	mov	si, cs:Current_Drive		;SI-->drive_cache_header
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg
	ASSUME	ds:Cseg_Init
	mov	ax, ds:[si.DCH_LRU_ROOT]	;get the LRU node
	pop	ds
	ASSUME	ds:nothing

	cmp	ax, cs:current_Node		;LRU node=Current Node ??
	je	GFN_skip			;yes-

	mov	bp, ax				;BP=Current node
	mov	di, es:[bp.nLRU_ptr]		;DI= current LRU node's following node
	mov	es:[di.nMRU_ptr],-1		;set that node's MRU ptr
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg	;DS=Name cache segment
	ASSUME	ds:Cseg_Init
	mov	ds:[si.DCH_LRU_ROOT],di 	;connect previous node to
	pop	ds				;next node
	ASSUME	ds:nothing

	cmp	byte ptr es:[bp.nCmpct_Dir_Info],' ';an empty node?
	je	GFN_OK			      ;then no problem.

	CALL	RemoveFromTree		    ;otherwise, it should be removed
					    ;from the tree.
GFN_OK:
	clc
	jmp	short	GFN_ret

GFN_Skip:
	stc

GFN_ret:
	pop	bp
	pop	si
	pop	di
	pop	es
	ret				    ;return

GET_FREE_NODE	endp




;
;----------------------------------------------------------------------
; PROCEDURE:   PRE_LRU_STACK
;
; When called by Look_up, Insert routine, the requested target node (BP)
; will be temporarily removed from LRU,MRU chain (until SET_LRU routine
; call), and will be pushed into a logical stack.  Actually, this routine
; will not use a stack, but try to get the effect of the use of stack
; to keep the history of target nodes in "REVERSE" LRU order as follows;
; {    inc Depth;
;      if Depth == 1 then Bottom = BP;
;			  Bottom.LRU_ptr = -1;
;			  Bottom.MRU_ptr = -1;
; else if Depth == 2 then Top = BP;
;			  Top.LRU_ptr = Bottom;
;			  Bottom.MRU_ptr = Top;
;			  Top.MRU_ptr = -1;
; else if Depth >= 3 then Temp = Top;
;			  Top = BP;
;			  Top.LRU_ptr = Temp;
;			  Temp.MRU_ptr = Top;
;			  Top.MRU_ptr = -1;
; }
;
;IN:  Depth, Top, Bottom, Temp,
;     Requested target node (BP)
;     ES = Name_Cache_Seg
;
;OUT: Target node removed from LRU,MRU chain.
;     Target node's history saved in reverse LRU order.
;     If called by "Delete" routine, then will just exit.
;     If called by "Insert" routine, then will not attempt
;     to remove the target node.
;----------------------------------------------------------------------

PRE_LRU_STACK	PROC	NEAR

	test	cs:Flag, is_delete	   ;invoked by Delete routine
	jnz	PLS_Exit
	test	cs:Flag, is_insert	   ;called by Insert routine
	jnz	PLS_Push

	CALL	RemoveFromLRUChain	;remove BP from the chain.

PLS_Push:
	push	di

	inc	cs:Depth
	cmp	cs:Depth, 1
	jne	PLS_Top
	mov	cs:Bottom, bp		   ;bottom = bp
	mov	es:[bp.nLRU_ptr], -1
	jmp	short PLS_Done

PLS_Top:
	cmp	cs:Depth, 2
	jne	PLS_Temp
	mov	cs:Top, bp		   ;Top = bp
	mov	di, cs:bottom		   ;di = bottom

PLS_com:
	mov	es:[bp.nLRU_ptr],di	;Top.LRU_ptr = bottom
	mov	es:[di.nMRU_ptr],bp	;Bottom.MRU_ptr = top
	jmp	short PLS_Done

PLS_Temp:
	mov	di, cs:Top		   ;di = Top
	mov	cs:Temp, di		   ;Temp = di
	mov	cs:Top, bp		   ;Top = bp
	jmp	short PLS_com

PLS_Done:
	mov	es:[bp.nMRU_ptr],-1
	pop	di

PLS_Exit:
	ret

PRE_LRU_STACK	endp
;





;----------------------------------------------------------------------
;PROCEDURE:  SET_LRU
;
;INPUT:  Depth, Top, Bottom, Current_Drive, ES = Name_Cache_Seg
;
;OUT: If Depth == 0 then exit
; Pre_LRU_Stack procedure already maintained a reverse order LRU
; mini chain.  Set_LRU will just put the top after the last node
; of the current LRU chain;
; { Get the last node of LRU chain.
;   if Depth == 0 then exit;
;   if Depth == 1 then Last_Node.LRU_ptr = Bottom;
;		       Bottom.MRU_ptr = Last_Node;
;		       MRU_ROOT = Bottom;
;   if Depth >= 2 then Last_Node.LRU_ptr = Top;
;		       Top.MRU_ptr = Last_Node;
;		       MRU_ROOT = Bottom;
;   Depth = 0;
; }
;----------------------------------------------------------------------

SET_LRU   PROC	  NEAR

	cmp	cs:Depth, 0		   ;nothing in the stack?
	je	SL_Exit

	push	si
	push	di
	push	bx
	mov	si, cs:Current_Drive	   ;cs:si -> Drive_Cache_Header
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg							   ;AN000;
	ASSUME	ds:Cseg_Init									   ;AN000;
	mov	di, ds:[si.DCH_MRU_ROOT] ;es:di -> Last node in LRU chain

	cmp	cs:Depth, 1
	jne	SL_Other

	mov	bx, cs:Bottom
	mov	es:[di.nLRU_ptr],bx	;Last_Node.LRU_ptr = Bottom
	mov	es:[bx.nMRU_ptr],di	;Bottom.MRU_ptr = Last_Node
	mov	ds:[si.DCH_MRU_ROOT],bx ;MRU_ROOT = Bottom
	jmp	short SL_Done

SL_Other:				;Depth >= 2
	mov	bx, cs:Top
	mov	es:[di.nLRU_ptr],bx
	mov	es:[bx.nMRU_ptr],di
	mov	bx, cs:Bottom
	mov	ds:[si.DCH_MRU_ROOT],bx

SL_Done:
	pop	ds
	ASSUME	ds:nothing
	mov	cs:Depth, 0		   ;reset the Depth
	pop	bx
	pop	di
	pop	si

SL_Exit:
	ret

Set_LRU endp





;----------------------------------------------------------------------
; Procedure RemoveFromLRUChain
;
;IN:  Target node (BP) to be removed
;     Current_drive
;     ES - Name_Cache_Seg
;
;OUT:  Target node removed from the LRU,MRU chain. LRU,MRU chain
;     updated.
;
;----------------------------------------------------------------------

RemoveFromLRUChain     PROC    near

	push	bx
	push	di
	push	si

	mov	si, cs:Current_drive	   ;cs:si-> Drive_cache_header
	mov	bx, es:[bp.nMRU_ptr]	;es:bx-> Preceding node
	mov	di, es:[bp.nLRU_ptr]	;es:di-> Following node
	cmp	bx, -1			;Is target the first node?
	je	RFLC_first_node
	cmp	di, -1			;Is target the last node of LRU chain?
	je	RFLC_last_node
	mov	es:[bx.nLRU_ptr],di	;Preceding.LRU_ptr->following node
	mov	es:[di.nMRU_ptr],bx	;Following.MRU_ptr->preceding node
	jmp	short RFLC_done

RFLC_first_node:
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg							   ;AN000;
	ASSUME	ds:Cseg_Init									   ;AN000;
	mov	ds:[si.DCH_LRU_ROOT],di ;LRU_ROOT-> following node
	pop	ds
	ASSUME	ds:nothing
	mov	es:[di.nMRU_ptr], -1	;Following node's MRU_ptr
	jmp	short RFLC_done

RFLC_last_node:
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg
	ASSUME	ds:Cseg_Init
	mov	ds:[si.DCH_MRU_ROOT],bx ;MRU_ROOT-> preceding node
	mov	es:[bx.nLRU_ptr], -1	;Preceding node's LRU_ptr
	pop	ds
	ASSUME	ds:nothing

RFLC_done:
	pop	si
	pop	di
	pop	bx
	ret

RemoveFromLRUChain	endp
;



;----------------------------------------------------------------------
; Proceure  RemoveFromTree
;
;IN:  BP - offset of node to be removed from the tree
;	   This node shoud not be a subdirectory that is not empty!!!
;      ES - Name_Cache_Seg
;      Current_Drive
;
;OUT:  The node will be freed from the tree.
;     The neighbor's Child_ptr, Sibling_ptr, Backward_ptr are adjusted
;     accordingly.
;     The freed node's child_ptr, sibling_ptr, backward_ptr are reset to -1.
;----------------------------------------------------------------------

REMOVEFROMTREE	 PROC	 NEAR

	push	bx
	push	dx

	mov	bx, es:[bp.nBackward_ptr]	;get the preceding node
	mov	dx, es:[bp.nSibling_ptr]	;get the sibling node
	cmp	bx, cs:Current_Drive
	je	RFT_First_Child 	;bp is the first child
	cmp	es:[bx.nChild_ptr],bp
	je	RFT_Child		;bp is the child of the preceding node
	mov	es:[bx.nSibling_ptr],dx ;bp is the Sibling of the preceding node
					;Update the preceding node's Sibling ptr
	jmp	short RFT_Reset

RFT_First_Child:
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg							   ;AN000;
	ASSUME	ds:Cseg_Init									   ;AN000;
	mov	ds:[bx.DCH_Child_ptr],dx
	pop	ds
	ASSUME	ds:nothing
	jmp	short RFT_Reset

RFT_Child:
	mov	es:[bx.nChild_ptr],dx

RFT_Reset:				;reset the deleted node's tree pointers
	mov	es:[bp.nChild_ptr],-1
	mov	es:[bp.nSibling_ptr],-1
	mov	es:[bp.nBackward_ptr],-1

	xchg	dx,bx			;now, dx=preceding node, bx=following node
	cmp	bx,-1			;end of sibling?
	je	RFT_ret
	mov	es:[bx.nBackward_ptr],dx;modify backward_ptr of the sibling node

RFT_ret:
	pop	dx
	pop	bx
	ret				;return

REMOVEFROMTREE	endp
;




;----------------------------------------------------------------------
; Procedure CMPARE
;
;IN: Packed name
;    BP = target node
;
;OUT: ZERO flag set when compare O.K.
;     DI destroyed.
;----------------------------------------------------------------------

CMPARE	PROC	near

	push	ds
	push	si
	mov	cx, 11
	push	cs
	pop	ds
	mov	si, offset cs:Packed_Name	   ;ds:si -> Packed_Name
	mov	di,bp
	add	di,nCmpct_Dir_Info		;es:di -> bp.nCmpact_Dir_Info
	REPE	CMPSB
	pop	si
	pop	ds
	ret
CMPARE	endp




;
;----------------------------------------------------------------------
; Procedure:  MAKE_NAME_RECORD
;
;IN:  DS:DI -> Dir_Info, ES:BX -> Extended_Info
;     AX = offset of the Name_Record entry in Name_Cache_Seg.
;
;OUT: Name_Record in Name_Cache_Seg filled.
;     nLRU_ptr, nChild_ptr, nSibling_ptr and nMRU_ptr are set to -1 for now.
;     ES, SI, DI destroyed.  ES will be Name_Cache_Seg.
;----------------------------------------------------------------------

MAKE_NAME_RECORD      PROC     NEAR

	push	ds			;save DS
	push	ax

	push	es			;save Extended_Info seg in DOS
	push	di
	pop	si			;DS:SI -> Dir_Info
	mov	di, cs:Open_Name_Cache_Seg							   ;AN000;
	mov	es, di										   ;AN000;
	ASSUME	es:Cseg_Init									   ;AN000;
	mov	di, ax			;ES:DI -> Name_Record
	mov	ax, -1
	mov	es:[di.nLRU_ptr],ax	;initialize pointers
	mov	es:[di.nChild_ptr],ax
	mov	es:[di.nSibling_ptr],ax
	mov	es:[di.nMRU_ptr],ax
	add	di, nCmpct_Dir_Info	;ES:DI -> Name_Record.nCmpct_Dir_Info
	mov	cx, ODI_head_leng	;currently 10.
	rep	movsb			;Move header part
	add	si, ODI_skip_leng	;DS:SI -> tail part of Dir_Info
	mov	cx, ODI_tail_leng
	REP	MOVSB			;move tail part.

	pop	ds			;restore Extended_Info seg in DS!!!
	mov	si, bx			;DS:SI -> Extended_Info
	mov	cx, size Fastopen_Extended_Info
	rep	movsb			;Move Extended_Info
	pop	ax
	pop	ds			;Restore DS

	ret				;return

MAKE_NAME_RECORD	ENDP
;




;----------------------------------------------------------------------
; Procedure Unfold_Name_Record
;
;IN:  Matching_Node, ES:DI -> Dir_Info buffer, ES:CX -> Extended_Info buffer
;
;OUT: if no matching node is found, then just return
;     else Dir_Info, Extended_Info buffer are filled.
;----------------------------------------------------------------------

Unfold_Name_Record     PROC	near

	cmp	cs:Matching_Node, -1
	je	UNR_Exit		;just exit
	push	ds
	push	si
	push	di
	push	cx			;save extended_info addr

	mov	si, cs:Open_Name_Cache_Seg							   ;AN000;
	mov	ds, si										   ;AN000;
	ASSUME	ds:Cseg_Init									   ;AN000;
	mov	si, cs:Matching_Node
	add	si, nCmpct_Dir_Info	;DS:SI -> Cmpct_Dir_Info

	mov	cx, ODI_head_leng	;Dir_Info header length
	REP	MOVSB			;Cmpct_Dir_Info.CDI_file_name -> ODI_head

	add	di, ODI_skip_leng	;length of Skiped part of Dir_Info
	mov	cx, ODI_tail_leng	;Dir_Info tail length
	REP	movsb			;Cmpct_Dir_Info.CDI_Time -> ODI_tail
					;At this moment, SI -> nExtended_Info

	pop	di			;ES:DI -> Extended_info
	push	di			;save di again for cx.
	mov	cx, size Fastopen_Extended_Info
	REP	movsb

	pop	cx			;restore extended_info addr
	pop	di
	pop	si
	pop	ds
	ASSUME	ds:nothing
UNR_Exit:
	ret				;return

Unfold_Name_Record	endp
;




;----------------------------------------------------------------------
; PROCEDURE:  PACK DIR_NAME
;
; Parse the name off of DS:SI into Packed_Name.  If called first time and
; DS:[SI+1] = ':' then it is ASSUMEd to be a drive letter and it will be
; returned in DL and SI will points to '\' after ':'.  If it was a directory
; name then Packed_Name will be set and SI points to '\' or 0 after the
; parsed directory name or filename.  This routine will check DS:[SI] when
; called to see if it points to '\' or 0.  If it points to '\' then
; it is ASSUMEd that the user want to skip the delimiter.  If it was 0,
; then this routine will set carry.  So, with a given drive,path string,
; the user is going to keep calling this routine until it returns
; with carry set that tells the end.
;----------------------------------------------------------------------

PACK_DIR_NAME	PROC	NEAR

	cmp	byte ptr ds:[si], 0	;end of path ??
	jne	PDN_Drive		;no-check for drive letter
	stc
	jmp	short PDN_Exit		;yes-exit

PDN_Drive:
	cmp	byte ptr ds:[si+1], ':' ;drive letter terminater?
	jnz	PDN_chk_skip		;no -
	mov	dl, byte ptr ds:[si]	;yes-set DL to the drive letter
	inc	si
	inc	si			;set SI -> '\' after ':'
	jmp	short PDN_Exit		;then exit

PDN_chk_skip:
	cmp	byte ptr ds:[si], '\'   ;delimeter?
	jne	PDN_Path		;no-
	inc	si			;yes-skip delimiter
	cmp	byte ptr ds:[si], 0	;end of path ??
	jne	PDN_Path		;no-pack path name
	stc				;yes-In fact, the input from DOS was
	mov	ax, -1			;D:\,0.  FASTOPEN will treate
	jmp	short PDN_Exit		;this as an error.

PDN_Path:				;pack path name
	push	es
	push	di
	push	ax

	push	cs
	pop	es
	mov	di, offset cs:Packed_Name   ;ES:DI-->pack buffer

	mov	ax,'  '
	STOSB				;blank out the Packed_Name
	STOSW
	STOSW
	STOSW
	STOSW
	STOSW
	mov	di, offset cs:Packed_Name

PDN_GetName:
	LODSB				;DS:SI => AL, SI++
	cmp	al,'.'
	jz	PDN_SetExt
	or	al,al
	jz	PDN_GetDone
	cmp	al,'\'
	jz	PDN_GetDone
	STOSB

ifdef DBCS
	call	IsDBCSLeadByte
	jnz	PDN_GetName		; if this is not lead byte
	movsb				; copy tail byte
endif

	jmp	short PDN_GetName

PDN_SetExt:
	mov	di, offset cs:Packed_Name+8

PDN_GetExt:
	LODSB
	or	al,al
	jz	PDN_GetDone
	cmp	al,'\'
	jz	PDN_GetDone

PDN_StoExt:
	STOSB

ifdef DBCS
	call	IsDBCSLeadByte
	jnz	PDN_GetEXT		; if this is not lead byte
	movsb				; copy tail byte
endif

	jmp	PDN_GetExt

PDN_GetDone:
	dec	si			;set SI back to the delimeter or 0.
	pop	ax
	pop	di
	pop	es

PDN_Exit:
	ret

PACK_DIR_NAME	endp





;----------------------------------------------------------------------
; PROCEDURE:  FIND_CLUSTER_NUMBER
;
;IN:  DL = driver # (0 = A, 1 = B,...)
;     CX = The value of Dir_First in Name_Record to search.
;     Search Name_Record entries to find the matching starting cluster number.
;     The search uses MRU chain for efficiency.
;
;OUT: ES = Name_Cache_Seg
;     BP = Name_Record
;     if not found, carry bit.
;     ES, BP register changed.
;----------------------------------------------------------------------

FIND_CLUSTER_NUMBER    PROC    NEAR

	push	ax
	push	cx
	push	dx
	add	dl, 'A'                 ;convert to a drive letter

	CALL	FIND_DRIVE_CACHE_HEADER ;ES:BP -> driver header if found
	jc	FCN_exit		;exit if not found

	mov	dx, cx			;save the key in DX					   ;AN000;
	mov	ax, cs:Open_Name_Cache_Seg							   ;AN000;
	mov	es, ax										   ;AN000;
	ASSUME	es:Cseg_Init

	CALL	SET_LRU 		;clean up the LRU stack

	mov	cs:Current_Drive,bp   ;set Current_Drive (You should not set
					;Current_Drive before SET_LRU at any time!!!
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg
	ASSUME	ds:Cseg_Init
	mov	cx, ds:[bp.DCH_Num_Entries]	;Max number to try
	mov	bp, ds:[bp.DCH_MRU_ROOT]	;get the start of MRU chaing
	pop	ds
	ASSUME	ds:nothing

FCN_while:
	cmp	es:[bp.nCmpct_Dir_Info], ' ' ;Is it a free node ?
	je	FCN_not_found		;then no reason to continue search.

	cmp	dx, es:[bp.nCmpct_Dir_Info.CDI_cluster] ;matching starting cluster # ?
	je	FCN_exit		;found it!!!

	mov	bp, es:[bp.nMRU_ptr]	;next MRU entry address
	cmp	bp, -1			;It was the end of MRU chain?
	je	FCN_not_found		;not found. End of search
	LOOP	FCN_while		;else compare cluster and contine...

FCN_Not_found:
	stc

FCN_exit:
	pop	dx
	pop	cx
	pop	ax
	ret

FIND_CLUSTER_NUMBER	ENDP




;----------------------------------------------------------------------
; PROCEDURE:  FIND_DIR_SECTOR	 (PTR 3718  3/10/88)
;
;     Search Name_Record using directory sector and directory position
;     for the name entry.
;
;IN:  DL = driver # (0 = A, 1 = B,...)
;     DI = Dirctory sector Low	value
;     CX = Dirctory sector high value
;     DH = Dirctory position
;
;OUT: ES = Name_Cache_Seg
;     BP = Name_Record
;     if not found, carry bit.
;     ES, BP register changed.
;----------------------------------------------------------------------

FIND_DIR_SECTOR   PROC	  NEAR

	push	ax
	push	cx
	push	dx
	add	dl, 'A'                  ;convert to a drive letter

	CALL	FIND_DRIVE_CACHE_HEADER  ;ES:BP -> driver header if found
	jc	FDIR_exit		 ; error if not found

	mov	ax, cs:Open_Name_Cache_Seg							   ;AN000;
	mov	es, ax										   ;AN000;
	ASSUME	es:Cseg_Init

	CALL	SET_LRU 		;clean up the LRU stack

	mov	ax,cx			; save directory sector high value
	mov	cs:Current_Drive,bp	;set Current_Drive (You should not set
					;Current_Drive before SET_LRU at any time!!!
	push	ds
	mov	ds,cs:Open_Name_Cache_Seg
	ASSUME	ds:Cseg_Init
	mov	cx, ds:[bp.DCH_Num_Entries]	;Max number to try
	mov	bp, ds:[bp.DCH_MRU_ROOT]	;get the start of MRU chaing
	pop	ds
	ASSUME	ds:nothing

FDIR_while:
	cmp	es:[bp.nCmpct_Dir_Info], ' ' ;Is it a free node ?
	je	FDIR_NOT_FOUND		;then no reason to continue search.

	cmp	di, word ptr es:[bp.nExtended_Info.FEI_dirsec] ;matching directory sector hi?
	jne	FDIR_Next		;check next entry

	cmp	ax, word ptr es:[bp.nExtended_Info.FEI_dirsec+2] ;matching directory sector low ?
	jne	FDIR_Next		;check next entry

	cmp	dh, es:[bp.nExtended_Info.FEI_dirpos] ;matching directory postion ?
	je	FDIR_Exit		;check next entry

FDIR_Next:
	mov	bp, es:[bp.nMRU_ptr]	;next MRU entry address
	cmp	bp, -1			;It was the end of MRU chain?
	je	FDIR_not_found		;not found. End of search
	loop	FDIR_while		;else compare cluster and contine...

FDIR_Not_found: 			; no found
	stc

FDIR_exit:
	pop	dx
	pop	cx
	pop	ax
	ret

FIND_DIR_SECTOR     ENDP





;--------------------------------------------------------------------------
; Procedure: CHECK_IT	   Call Fastopen  Tree Analyser to check the
;			   consistency of the Directory/File Tree strucutre.
;--------------------------------------------------------------------------
CHECK_IT   PROC    NEAR

       pushf				      ; save all registers
       push   ax
       push   bx
       push   cx
       push   dx
       push   si
       push   di
       push   ds
       push   es
       cmp    cs:Chk_flag,0		      ;Fastopen analyser enabled ??
       je     Check_Exit		      ;no - exit

       mov    ax,cs:Open_Name_Cache_Seg       ;yes-set multiplex function call
       mov    es,ax
       mov    ah,091h			      ;load Multiplex ID
       xor    al,al
       xor    cx,cx
       mov    cl,cs:func_cod		      ;CL=Fastopen Function code
       mov    di,cs:Current_Drive	      ;ES:DI-->current drive header
       INT    2FH			      ;call the analyser

Check_Exit:
       pop    es			      ;restore all registers
       pop    ds
       pop    di
       pop    si
       pop    dx
       pop    cx
       pop    bx
       pop    ax
       popf				      ;return
       ret

CHECK_IT    ENDP

ifdef DBCS
;
;	Test if the character is DBCS Lead Byte
;
;	input:	AL = character to check
;	outpit:	ZF = 1 if DBCS Lead Byte
;

	public	DBCSLeadByteTable
DBCSLeadByteTable	dd	0

IsDBCSLeadByte		proc	near
	push	ax
	push	si
	push	ds
	lds	si,cs:DBCSLeadByteTable
idlb_check:
	cmp	word ptr [si],0
	jz	idlb_not		; if end of table
	cmp	al,[si]
	jb	idlb_next		; if below low value
	cmp	al,[si+1]
	jbe	idlb_yes		; if below high value
idlb_next:
	add	si,2			; do next
	jmp	short idlb_check
idlb_not:
	or	al,1			; reset ZF
	jmp	short idlb_end
idlb_yes:
	and	al,0			; set ZF
idlb_end:
	pop	ds
	pop	si
	pop	ax
	ret
IsDBCSLeadByte		endp

endif





; Calculate the size of the CSEG_OPEN Module in bytes
	IF  ($-Cseg_Open) MOD 16								   ;AN000;
	   ORG ($-Cseg_Open)+16-(($-Cseg_Open) MOD 16)						   ;AN000;
	ENDIF											   ;AN000;

END_OPEN   label   word




CSEG_OPEN    ends
     end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\fgetl.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/* fgetl.c - expand tabs and return lines w/o separators */

#include "tools.h"

int min(int a, int b);

/* returns line from file (no CRLFs); returns NULL if EOF */
fgetl (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
    register int c;
    register char *p;

    /* remember NUL at end */
    len--;
    p = buf;
    while (len) {
	c = getc (fh);
	if (c == EOF || c == '\n')
	    break;
#if MSDOS
	if (c != '\r')
#endif
	    if (c != '\t') {
		*p++ = (char)c;
		len--;
		}
	    else {
		c = min (8 - ((p-buf) & 0x0007), len);
		Fill (p, ' ', c);
		p += c;
		len -= c;
		}
	}
    *p = 0;
    return ! ( (c == EOF) && (p == buf) );
}

/* writes a line to file (with trailing CRLFs) from buf, return <> 0 if
 * writes fail
 */
fputl (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
#if MSDOS
    return (fwrite (buf, 1, len, fh) != len || fputs ("\r\n", fh) == EOF) ? EOF : 0;
#else
    return (fwrite (buf, 1, len, fh) != len || fputs ("\n", fh) == EOF) ? EOF : 0;
#endif
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\itoupper.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
include version.inc
include cmacros.inc
.list

sBegin  code
assumes cs,code

;
; c = IToupper (c, routine);
;
;       c is char to be converted
;       routine is case map call in international table
;

cProc   IToupper,<PUBLIC>
parmW   c
parmD   routine
cBegin
        mov     ax,c
        or      ah,ah
        jnz     donothing
        cmp     al,'a'
        jb      noconv
        cmp     al,'z'
        ja      noconv
        sub     al,20H
noconv:
        call    routine
donothing:
cEnd


sEnd

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\getl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; blindingly fast assembly help for Z
;

.xlist
include	version.inc
include cmacros.inc
.list

sBegin  data
assumes ds,data

bufstart    dd     ?
staticW bufsrc,?
staticW buflen,?
staticW buflength,?
staticW buffh,?
globalB fGetlCR,?
bufpos      dd      ?

sEnd
sBegin code

assumes cs,code

;
; getlpos returns current seek position in file
;
cProc   getlpos,<PUBLIC>
cBegin
        mov     dx,word ptr bufpos+2
        mov     ax,word ptr bufpos
cEnd

;
; getlinit (buf, len, fh) initializes the getl routine for buffer buf and fh fh
;
cProc   getlinit,<PUBLIC>
parmD   buf
parmW   len
parmW   fh
cBegin
        mov     ax,off_buf
        mov     word ptr bufstart,ax
        mov     ax,seg_buf
        mov     word ptr bufstart+2,ax
        mov     ax,fh
        mov     buffh,ax
        mov     ax,len
        mov     buflength,ax
        mov     buflen,0
        mov     word ptr bufpos,0
        mov     word ptr bufpos+2,0
        mov     fGetlCR,0
cEnd

;
; getl (dst, len) returns TRUE if a line was read.
;
cProc   getl,<PUBLIC>,<DS,SI,DI>
parmW   dst
parmW   dstlen
cBegin
        assumes ss,data
        cld
        push    ds
        pop     es
        mov     ds,word ptr bufstart+2
        assumes ds,nothing
        mov     si,bufsrc
        mov     di,dst
        mov     cx,buflen
        mov     dx,dstlen
        dec     dx                  ; room for NUL at end
        jcxz    fill

movc:   lodsb                       ; get a byte
        cmp     al,13               ; is it special?
        jbe     spec                ; yes, go handle special case
stoc:   stosb                       ; put character in buffer
        dec     dx                  ; one less space in buffer
endl:   loopnz  movc                ; go back for more characters
        jnz     fill                ; no more characters => go fill buffer
                                    ; cx = 0, buflen = length moved
fin:    dec     cx
fin1:   xor     ax,ax
        stosb
        mov     bufsrc,si           ; length moved = buflen - cx
        xchg    buflen,cx
        sub     cx,buflen
        add     word ptr bufpos,cx
        adc     word ptr bufpos+2,0
        not     ax
        jmp     short getldone

fill:
        mov     cx, buflen          ; add length moved to bufpos
        add     word ptr bufpos,cx
        adc     word ptr bufpos+2,0
        push    dx
        mov     dx,word ptr bufstart
        mov     cx,buflength
        mov     bx,buffh
        mov     ah,3Fh
        int     21h
        mov     cx,ax
        mov     buflen,ax
        mov     si,dx
        pop     dx
        or      ax,ax
        jnz     movc
; if we've stored chars then terminate line else return with 0
        cmp     di,dst
        jnz     fin1
        jmp     short getldone

setnz:  or      al,1
        mov     fGetlCR,-1              ; indicate we've seen a CR
        jmp     endl

spec:   jz      setnz
        cmp     al,10
        jz      fin
        cmp     al,9
        jnz     stoc
        push    cx
        mov     ax,di
        sub     ax,dst
        and     ax,7
        mov     cx,8
        sub     cx,ax
        cmp     cx,dx
        jbe     ok
        mov     cx,dx
ok:     sub     dx,cx
        mov     al," "
        rep     stosb
        pop     cx
        jmp     endl

getldone:
cEnd

sEnd

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\maxmin.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; maximum and minimum routines.
;

.xlist
include	version.inc
include cmacros.inc
.list

sBegin	code
assumes cs,code

cProc	max,<PUBLIC>
parmW	a
parmW	b
cBegin
	mov	ax,a
	cmp	ax,b
	jg	maxdone
	mov	ax,b
maxdone:
cEnd

cProc	min,<PUBLIC>
parmW	a
parmW	b
cBegin
	mov	ax,a
	cmp	ax,b
	jl	mindone
	mov	ax,b
mindone:
cEnd

sEnd

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\fc.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*
 *  This file contains the constants, globals, structure definitions,
 *  extern declarations, and macro definitions for the FC utility.
 */


/* #define  DEBUG  FALSE */

/*
 *  Constant Definitions
 */
#define byte  unsigned char
#define word  unsigned short

#define SUCCESS 0
#define HELPTEXT  1
#define MAXFNAME 80

extern unsigned char _ctype_[];
#define _SPACE        0x8              /* tab, carriage return, new line, */
#define ISSPACE(c)     ( (_ctype_+1)[c] & _SPACE )


/*
 *   Structure Definitions
 */
struct lineType {
    int     line;                      /* line number */
    unsigned char    text[MAXARG];     /* body of line */
};

struct lineType *buffer1,
                *buffer2;

byte line[MAXARG];                     /* single line buffer */

byte *extBin[] = { ".EXE", ".OBJ", ".LIB",
                            ".COM", ".BIN", ".SYS", NULL };

/*
 *  Global Declarations
 */
int ctSync  = -1,                      /* number of lines required to sync */
    cLine   = -1;                      /* number of lines in internal buffs */

flagType fAbbrev = FALSE,              /* abbreviated output */
         fBinary = FALSE,              /* binary comparison */
         fLine   = FALSE,              /* line comparison */
         fNumb   = FALSE,              /* display line numbers */
         fCase   = TRUE,               /* case is significant */
         fIgnore = FALSE;              /* ignore spaces and blank lines */

#ifdef  DEBUG
  flagType fDebug = FALSE;
#endif


/*
 *  Extern Declarations for routines defined in ttypes.h
 */
extern int fgetl();
extern int strcmp();
extern byte toupper(int c);
extern char *strstr();
extern char *strrchr();
extern char *strupr();


/*
 *  Forward Declarations
 */
int main(int c, byte *v[]);
void usage (unsigned char *p,unsigned int pcode);
int BinaryCompare(unsigned char *f1,unsigned char *f2);
char compare(int l1,int s1,int l2,int s2,int ct);
void LineCompare(unsigned char *f1,unsigned char *f2);
int xfill(struct lineType *pl,struct _iobuf *fh,int ct,int *plnum);
int adjust(struct lineType *pl,int ml,int lt);
void dump(struct lineType *pl,int start,int end);
void pline(struct lineType *pl);
int strcmpi(unsigned char *str1,unsigned char *str2);
int strcmps(unsigned char *p1,unsigned char *p2);
int strcmpis(unsigned char *p1,unsigned char *p2);
Boolean has_extension(char *s);
void ParseFileNames(char *, char *);
char *FindFileName(char *);
Boolean HasWildcard(char *);
void CheckWildcard(char *, char *);
int ExpandFile2(char *, char *);                 /* M001 */
void comp(char *, char *);

int fgetl(char *buf,int len,struct _iobuf *fh);
int fputl(char *buf,int len,struct _iobuf *fh);
char *error(void);
int max(int a, int b);
int min(int a, int b);
char *strpbrk(char *string1, char *string2);

#ifdef DBCS
int	checkspace(unsigned char *);
int	IsDBCSLeadByte(unsigned char);
int	CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif


/*
 *  Function Pointers
 */
int (*funcRead) (),                    /* function to use to read lines */
    (*fCmp) ();                        /* function to use to compare lines */


/*
 *  DOS major/minor version numbers
 */
extern unsigned char _NEAR _CDECL _osmajor;
extern unsigned char _NEAR _CDECL _osminor;



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\move.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; memory routines
;

.xlist
include	version.inc
include cmacros.inc
.list

sBegin	code
assumes cs,code

cProc	Move,<PUBLIC>,<DS,SI,DI>
parmD	src
parmD	dst
parmW	count
cBegin
	mov	cx,count
	jcxz	NoByte			; No characters to move
	les	di,dst			; grab pointers
	lds	si,src
	cld
	mov	ax,ds
	cmp	ax,Seg_dst
	jnz	SimpleMove		; segments are NOT the same, no opt
	cmp	si,di			; is the start of source before dest
	jb	TestMove		; yes, try to optimize

SimpleMove:
	shr	cx,1
	rep	movsw
	jnc	NoByte
	movsb
	jmp	short NoByte

TestMove:
	mov	ax,di
	sub	ax,si			; ax = difference between regions
	cmp	ax,cx			; is difference greater than region?
	jae	SimpleMove		; yes, no optimize
	mov	ax,cx			; optimize by copying down from top
	dec	ax
	add	di,ax
	add	si,ax
	std
	rep	movsb			; no word optimization here

NoByte:
	cld
cEnd

cProc	Fill,<PUBLIC>,<DI>
parmD	dst
parmB	value
parmW	count
cBegin
	cld
	les	di,dst
	mov	al,value
	mov	ah,value
	mov	cx,count
	shr	cx,1
	jcxz	fill1
	rep	stosw
fill1:
	jnc	fill2
	stosb
fill2:
cEnd

sEnd

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\internat.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*
	Data structure for international table
 */

struct InterTbl
{
	unsigned dateform ;	/* Date format				   */
	char	currsym[5] ;	/* Currency symbol as ASCIZ string	   */
	char	thousp[2] ;	/* Thousands separator as ASCIZ string	   */
	char	decsp[2] ;	/* Decimal   separator as ASCIZ string	   */
	char	datesp[2] ;	/* Date      separator as ASCIZ string	   */
	char	timesp[2] ;	/* Time      separator as ASCIZ string	   */
	unsigned char bits ;	/* Bit field				   */
	unsigned char numdig ;	/* Number of signifigant decimal digits    */
	unsigned char timeform ;/* Time format				   */
	unsigned long casecall ;/* Case mapping call			   */
	char	datasp[2] ;	/* Data list separator as ASCIZ string	   */
	int	reserv[5] ;	/* RESERVED				   */
} ;


#define DATEFORM_USA	0
#define DATEFORM_EUROPE 1
#define DATEFORM_JAPAN	2

#define BITS_CURRENCY	0x0001
#define BITS_NUMSPC	0x0002

#define TIMEFORM_12	0
#define TIMEFORM_24	1

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\kstring.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
#include "internat.h"
#include <dos.h>
#define   NULL    0
#define   TRUE    0xffff
#define   FALSE   0
#ifndef DBCS
#define   DBCS   TRUE	
#endif
char	haveinttab = FALSE;
/*
 * ECS Support - This module provides support for international >7FH and 
 * TWO-BYTE character sets.  The toupper routine uses the DOS MAP_CASE call.
 * In addition, STRING.C contains a default_tab containing a default lead
 * byte table for two byte character sets.  If single byte operation is
 * desired, modify this table as follows:  ="\000".  If this utility 
 * is run on a DOS with Function 63H support, the default table will 
 * be replaced by the table in the DOS.  The lbtbl_ptr is the far ptr to
 * which ever table is in use.
*/
long  lbtbl_ptr;
char  *default_tab="\201\237\340\374\000\000";
char	have_lbtbl = FALSE;

struct	InterTbl Currtab;

int toupper(int c);
char *strupr(char *string);
char *strpbrk(char *string1,char *string2);
IToupper(int c, long routine);
#ifdef DBCS
int	IsDBCSLeadByte(unsigned char);
int	CheckDBCSTailByte(unsigned char *,unsigned char *);
#endif

int toupper(c)
int c;
{
	union REGS regs ;

	if(!haveinttab) {
	    regs.x.ax = 0x3800 ;
	    regs.x.dx = (unsigned) &Currtab ;
	    intdos (&regs, &regs) ;		/* INIT the table */

	    haveinttab = (char)TRUE;
	}

	return(IToupper(c,Currtab.casecall));

}

char *strupr(string)
char *string;
{
	register char *p1;

	p1 = string;
	while (*p1 != NULL) {
	/*
	 *  A note about the following " & 0xFF" stuff. This is
	 *  to prevent the damn C compiler from converting bytes
	 *  to words with the CBW instruction which is NOT correct
	 *  for routines like toupper
	 */
#ifdef DBCS
	 if(IsDBCSLeadByte(*p1 & 0xFF))
		p1 += 2 ;
	    else
		*p1++ = toupper(*p1 & 0xFF);
#else
	    *p1++ = toupper(*p1 & 0xFF);
#endif
	}
	return(string);
}

char *strpbrk(string1,string2)
char *string1;
char *string2;
{
	register char *p1;

	while (*string1 != NULL) {
	/*
	 *  A note about the following " & 0xFF" stuff. This is
	 *  to prevent the damn C compiler from converting bytes
	 *  to words with the CBW instruction which is NOT correct
	 *  for routines like toupper
	 */
#ifdef DBCS
	    if(IsDBCSLeadByte(*string1 & 0xFF))
		string1 += 2 ;
	    else {
#endif
		p1 = string2;
		while (*p1 != NULL) {
		    if(*p1++ == *string1)
			return(string1);
		}
		string1++;
#ifdef DBCS
	    }
#endif

	}
	return(NULL);			/* no matches found */
}

#ifdef DBCS
/*
	Test if the character is DBCS lead byte

	input:	c = character to test
	output:	TRUE if leadbyte
*/

int	IsDBCSLeadByte(c)
unsigned char c;
{
	static unsigned char far *DBCSLeadByteTable = NULL;

	union REGS inregs,outregs;
	struct SREGS segregs;
	unsigned char far *p;

	if (DBCSLeadByteTable == NULL)
	{
		inregs.x.ax = 0x6300;		/* get DBCS lead byte table */
		intdosx(&inregs, &outregs, &segregs);
		FP_OFF(DBCSLeadByteTable) = outregs.x.si;
		FP_SEG(DBCSLeadByteTable) = segregs.ds;
	}

	p = DBCSLeadByteTable;
	while (p[0] || p[1])
	{
		if (c >= p[0] && c <= p[1])
			return TRUE;
		p += 2;
	}
	return FALSE;
}

/*
	Check if the character point is at tail byte

	input:	*str = strart pointer of the string
		*point = character pointer to check
	output:	TRUE if at the tail byte
*/

int	CheckDBCSTailByte(str,point)
unsigned char *str,*point;
{
	unsigned char *p;

	p = point;
	while (p != str)
	{
		p--;
		if (!IsDBCSLeadByte(*p))
		{
			p++;
			break;
		}
	}
	return ((point - p) & 1 ? TRUE : FALSE);
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\ntoi.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/* convert an arbitrary based number to an integer */

#include <ctype.h>
#include "tools.h"

/* p points to characters, return -1 if no good characters found
 * and base is 2 <= base <= 16
 */
int ntoi (p, base)
char *p;
int base;
{
    register int i, c;
    flagType fFound;

    if (base < 2 || base > 16)
	return -1;
    i = 0;
    fFound = FALSE;
    while (c = *p++) {
	c = tolower (c);
	if (!isxdigit (c))
	    break;
	if (c <= '9')
	    c -= '0';
	else
	    c -= 'a'-10;
	if (c >= base)
	    break;
	i = i * base + c;
	fFound = TRUE;
	}
    if (fFound)
	return i;
    else
	return -1;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\syserr.c ===
/***
*syserr.c - clone of the system error list that appears in the
*           standard library.
*
*   Copyright (c) 1987-1990, Microsoft Corporation. All rights reserved.
*   Adapted by TerryF for IPG October 1991.
*
*Purpose:
*   Defines the System Error List, containing the full messages for
*   all errno values set by the library routines.
*   Defines sys_errlist.
*
*******************************************************************************/

/* standard lib uses the name sys_errlist */
char *sys_errorlist[] =
{
#include "syserr.msg"    /* TerryF -> IPG, localize syserr.msg */
};

/* standard lib uses the name sys_nerr */
int system_nerr = sizeof( sys_errorlist ) / sizeof( sys_errorlist[ 0 ] ) - 1;

/* The above array contains all the errors including unknown error # 37
   which is used if msg_num is unknown */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\string.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; string functions for lattice C
;

.xlist
include	version.inc
include cmacros.inc
.list

sBegin	data
assumes ds,data

externB XLTab
externB XUTab

sEnd

sBegin	code
assumes cs,code

externP strlen

ifdef DBCS
externP IsDBCSLeadByte
externP CheckDBCSTailByte
endif

;
; strbscan (string, set) returns pointer to 1st char in set or end
;
cProc	strbscan,<PUBLIC>,<SI,DI>
parmW	str
parmW	set
cBegin
	push	ds
	pop	es
	cCall	strlen,<set>
	inc	ax
	mov	bx, ax
	mov	si,str
	cld
bscan:
	lodsb
	mov	cx,bx
	mov	di,set
;
; While not in the set
;
ifdef DBCS
bscan_pass:
endif
	repnz	scasb
	jnz	bscan
ifdef DBCS
	dec	di
	cCall	CheckDBCSTailByte,<set,di>
	inc	di
	or	ax,ax
	jnz	bscan_pass		; pass if this is tail byte
endif
	lea	ax,[si-1]
cEnd

;
; strbskip ( string, set ) returns pointer to 1st char not in set
;
cProc	strbskip,<PUBLIC>,<SI,DI>
parmW	str
parmW	set
cBegin
	push	ds
	pop	es
	cCall	strlen,<set>
	inc	ax
	mov	bx, ax
	mov	si,str
	cld
bskip:
	lodsb
	or	al,al
	jz	eskip
	mov	cx,bx
	mov	di,set
;
; While not in the set
;
ifdef DBCS
bskip_pass:
endif
	repnz	scasb
	jz	bskip
ifdef DBCS
	dec	di
	cCall	CheckDBCSTailByte,<set,di>
	inc	di
	or	ax,ax
	jnz	bskip_pass		; pass if this is tail byte
endif
eskip:
	lea	ax,[si-1]
cEnd

;
; strpre (s1, s2) returns -1 if s1 is a prefix of s2, 0 otherwise. Ignores
; case.
;
cProc	strpre,<PUBLIC>,<si,di>
parmW	pref
parmW	str
cBegin
	cld
	mov	si,pref
	mov	di,str
	mov	bx,dataOFFSET xltab
preCompare:
	lodsb
	mov	ah,[di]
	inc	di

ifdef DBCS
	push	ax
	xor	ah,ah
	cCall	IsDBCSLeadByte,<ax>
	mov	dl,al			; save pref char type
	pop	ax
	push	ax
	mov	al,ah
	xor	ah,ah
	cCall	IsDBCSLeadByte,<ax>
	mov	dh,al			; save str char type
	pop	ax
	cmp	dl,dh
	jnz	preDif			; if char type not same
	or	dl,dl
	jz	@f			; if not lead byte
	cmp	al,ah
	jnz	preDif			; if lead byte not same
	lodsb				; get tail byte
	mov	ah,[di]
	inc	di
	cmp	al,ah
	jnz	preDif			; if tail byte not same
	or	al,al
	jz	preYes			; if end
	jmp	short preCompare
@@:
endif

	xlat
	xchg	ah,al
	xlat

	cmp	ah,al
	jnz	preDif
	or	ah,ah
	jnz	preCompare
preYes:
	mov	ax,-1
	jmp	short preDone
preDif:
	or	ah,ah
	jz	preYes
	xor	ax,ax
preDone:
cEnd

sEnd

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\xtab.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;
; xlat tables for case conversion
;

.xlist
include	version.inc
include cmacros.inc
.list

sBegin	data

public	_XLTab, _XUTab

assumes ds,data

;
; table for lowercase translation
;

_XLTab	 LABEL BYTE

    db	000h, 001h, 002h, 003h, 004h, 005h, 006h, 007h
    db	008h, 009h, 00Ah, 00Bh, 00Ch, 00Dh, 00Eh, 00Fh

    db	010h, 011h, 012h, 013h, 014h, 015h, 016h, 017h
    db	018h, 019h, 01Ah, 01Bh, 01Ch, 01Dh, 01Eh, 01Fh

    db	' !"#$%&', 027h
    db	'()*+,-./'

    db	'01234567'
    db	'89:;<=>?'

    db	'@abcdefg'
    db	'hijklmno'

    db	'pqrstuvw'
    db	'xyz[\]^_'

    db	'`abcdefg'
    db	'hijklmno'

    db	'pqrstuvw'
    db	'xyz{|}~', 07Fh

    db	080h, 081h, 082h, 083h, 084h, 085h, 086h, 087h
    db	088h, 089h, 08Ah, 08Bh, 08Ch, 08Dh, 08Eh, 08Fh
    db	090h, 091h, 092h, 093h, 094h, 095h, 096h, 097h
    db	098h, 099h, 09Ah, 09Bh, 09Ch, 09Dh, 09Eh, 09Fh
    db	0A0h, 0A1h, 0A2h, 0A3h, 0A4h, 0A5h, 0A6h, 0A7h
    db	0A8h, 0A9h, 0AAh, 0ABh, 0ACh, 0ADh, 0AEh, 0AFh
    db	0B0h, 0B1h, 0B2h, 0B3h, 0B4h, 0B5h, 0B6h, 0B7h
    db	0B8h, 0B9h, 0BAh, 0BBh, 0BCh, 0BDh, 0BEh, 0BFh
    db	0C0h, 0C1h, 0C2h, 0C3h, 0C4h, 0C5h, 0C6h, 0C7h
    db	0C8h, 0C9h, 0CAh, 0CBh, 0CCh, 0CDh, 0CEh, 0CFh
    db	0D0h, 0D1h, 0D2h, 0D3h, 0D4h, 0D5h, 0D6h, 0D7h
    db	0D8h, 0D9h, 0DAh, 0DBh, 0DCh, 0DDh, 0DEh, 0DFh
    db	0E0h, 0E1h, 0E2h, 0E3h, 0E4h, 0E5h, 0E6h, 0E7h
    db	0E8h, 0E9h, 0EAh, 0EBh, 0ECh, 0EDh, 0EEh, 0EFh
    db	0F0h, 0F1h, 0F2h, 0F3h, 0F4h, 0F5h, 0F6h, 0F7h
    db	0F8h, 0F9h, 0FAh, 0FBh, 0FCh, 0FDh, 0FEh, 0FFh

_XUTab	 LABEL	 BYTE

    db	000h, 001h, 002h, 003h, 004h, 005h, 006h, 007h
    db	008h, 009h, 00Ah, 00Bh, 00Ch, 00Dh, 00Eh, 00Fh
    db	010h, 011h, 012h, 013h, 014h, 015h, 016h, 017h
    db	018h, 019h, 01Ah, 01Bh, 01Ch, 01Dh, 01Eh, 01Fh
    db	' !"#$%&', 027h
    db	'()*+,-./'
    db	'01234567'
    db	'89:;<=>?'
    db	'@ABCDEFG'
    db	'HIJKLMNO'
    db	'PQRSTUVW'
    db	'XYZ[\]^_'
    db	'`ABCDEFG'
    db	'HIJKLMNO'
    db	'PQRSTUVW'
    db	'XYZ{|}~', 07Fh
    db	080h, 081h, 082h, 083h, 084h, 085h, 086h, 087h
    db	088h, 089h, 08Ah, 08Bh, 08Ch, 08Dh, 08Eh, 08Fh
    db	090h, 091h, 092h, 093h, 094h, 095h, 096h, 097h
    db	098h, 099h, 09Ah, 09Bh, 09Ch, 09Dh, 09Eh, 09Fh
    db	0A0h, 0A1h, 0A2h, 0A3h, 0A4h, 0A5h, 0A6h, 0A7h
    db	0A8h, 0A9h, 0AAh, 0ABh, 0ACh, 0ADh, 0AEh, 0AFh
    db	0B0h, 0B1h, 0B2h, 0B3h, 0B4h, 0B5h, 0B6h, 0B7h
    db	0B8h, 0B9h, 0BAh, 0BBh, 0BCh, 0BDh, 0BEh, 0BFh
    db	0C0h, 0C1h, 0C2h, 0C3h, 0C4h, 0C5h, 0C6h, 0C7h
    db	0C8h, 0C9h, 0CAh, 0CBh, 0CCh, 0CDh, 0CEh, 0CFh
    db	0D0h, 0D1h, 0D2h, 0D3h, 0D4h, 0D5h, 0D6h, 0D7h
    db	0D8h, 0D9h, 0DAh, 0DBh, 0DCh, 0DDh, 0DEh, 0DFh
    db	0E0h, 0E1h, 0E2h, 0E3h, 0E4h, 0E5h, 0E6h, 0E7h
    db	0E8h, 0E9h, 0EAh, 0EBh, 0ECh, 0EDh, 0EEh, 0EFh
    db	0F0h, 0F1h, 0F2h, 0F3h, 0F4h, 0F5h, 0F6h, 0F7h
    db	0F8h, 0F9h, 0FAh, 0FBh, 0FCh, 0FDh, 0FEh, 0FFh

sEnd

end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\ttypes.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/* ttypes.h - type definitions for tools library */

#include <stdio.h>

/* assembly routines */
flagType int25 (char, char far *, unsigned int, unsigned int);
flagType int26 (char, char far *, unsigned int, unsigned int);
flagType kbhit ();
char getch ();
void Move (char far *, char far *, unsigned int);
void Fill (char far *, char, unsigned int);
char *strbscan (char *, char *);
char *strbskip (char *, char *);
flagType strpre (char *, char *);
int strcmpi (unsigned char *, unsigned char *);
char *fcopy (char *, char *);
long getlpos ();
void getlinit ( char far *, int, int);
int getl (char *, int);

/* c routines */
/*global*/  char  *lower(char  *);
/*global*/  char  *upper(char  *);
/*global*/  char  *error(void);
/*global*/  long fexpunge(char  *,FILE *);
/*global*/  char  *fcopy(char  *,char  *);
/*global*/  int fgetl(char  *,int ,FILE  *);
/*global*/  int fputl(char  *,int ,FILE  *);
/*global*/  int ffirst(char  *,int ,struct findType  *);
/*global*/  int fnext(struct findType  *);
/*global*/ /* char forsemi(char  *,char ( *)(), ); */   
         /* nobody is calling forsemi and it generates a warning so i */
         /* commented it out - leaf, mar 1990 */
/*global*/  long freespac(int );
/*global*/  long sizeround(long ,int );
/*global*/  /* int rspawnl(char  *,char  *,char  *, ); */
         /* ditto as forsemi */
/*global*/  int rspawnv(char  *,char  *,char  *,char  *[0]);
/*global*/  char  *MakeStr(char  *);
/*global*/  int mapenv(char  *,char  *);
/*global*/  char  *ismark(char  *);
/*global*/  FILE  *swopen(char  *,char  *);
/*global*/  int swclose(FILE  *);
/*global*/  int swread(char  *,int ,FILE  *);
/*global*/  char  *swfind(char  *,FILE *,char  *);
/*global*/  char *getenvini(char  *,char  *);
/*global*/  char fPathChr(int );
/*global*/  char fSwitChr(int );
/*global*/  char fPFind(char  *,unsigned int * *);
/*global*/  char findpath(char  *,char  *,char );
/*global*/  FILE  *pathopen(char  *,char  *,char  *);
/*global*/  /* int forfile(char  *,int ,void ( *)(), ); */
         /* ditto as forsemi and rspawnl */
/*global*/  int rootpath(char  *,char  *);
/*global*/  int sti(char  *,int );
/*global*/  int ntoi(char  *,int );
/*global*/  int strcmps(unsigned char  *,unsigned char  *);
/*global*/  int strcmpis(unsigned char  *,unsigned char  *);
/*global*/  char  *strend(char  *);
/*global*/  int upd(char  *,char  *,char  *);
/*global*/  int drive(char  *,char  *);
/*global*/  int extention(char  *,char  *);
/*global*/  int filename(char  *,char  *);
/*global*/  int filenamx(char  *,char  *);
/*global*/  int path(char  *,char  *);
/*global*/  int curdir(char  *,char );
/*global*/  int getattr(char  *);
/*global*/  int fdelete(char  *);
/*global*/  char *fmove(char  *, char *);
/*global*/  char *fappend(char  *, int);
/*global*/  long ctime2l(char *);
/*global*/  struct tm *ctime2tm(char *);
/*global*/  long date2l(int, int, int, int, int, int);
/*global*/  struct vectorType *VectorAlloc(int);
/*global*/  flagType fAppendVector(struct vectorType**, unsigned int);
/*global*/  unsigned char *skipwhite(unsigned char *);

char * _CDECL strcat(char *, const char *);
char * _CDECL strchr(const char *, int);
int    _CDECL strcmp(const char *, const char *);
char * _CDECL strcpy(char *, const char *);
size_t _CDECL strlen(const char *);
char * _CDECL strstr(const char *, const char *);
char * _CDECL strrchr(const char *, int);
char * _CDECL strupr(const char *);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\update.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*
 * update takes a def string and update and fills the
 * update with missing defs the update allowing
 * specification of missing parameters.
 * the parts are: ^{[~:]#:}{%#</|\>}{[~.]#}{.[~./\:]}$
 * maximum size of MAXPATHLEN (80) bytes
 *
 *   4/14/86  dl use U_ flags
 *
 */

#include "tools.h"
#include "ttypes.h"

fileext  (char *src, char *dst);

int upd (def, update, dst)
char *def, *update, *dst;
{
    char *p, buf[MAXPATHLEN];
    int f;

    f = 0;
    p = buf;
#if MSDOS
    if (drive(update, p) || drive (def, p))
        SETFLAG(f, U_DRIVE);
    p += strlen (p);
#endif

    if (path(update, p) || path (def, p))
        SETFLAG(f, U_PATH);
    p += strlen (p);

    if (filename(update, p) || filename (def, p))
        SETFLAG(f, U_NAME);
    p += strlen (p);

    if (extention(update, p) || extention (def, p))
        SETFLAG(f, U_EXT);

    strcpy (dst, buf);

    return f;
}

#if MSDOS
/* copy a drive from source to dest if present, return TRUE if we found one */
drive (src, dst)
char *src, *dst;
{
    register char *p;

    p = strbscan (src, ":");
    if (*p++ == NULL)
        p = src;
    strcpy (dst, src);
    dst[p-src] = 0;
    return strlen (dst) != 0;
}
#endif

/*  copy an extention from source to dest if present.  include the period.
    Return TRUE if one found.
 */
extention (src, dst)
char *src, *dst;
{
    register char *p, *p1;

    p = src - 1;
    while (*(p=strbscan(1+(p1=p), ".")) != NULL)
        ;
    /* p1 points to last . or begin of string  p points to eos */
    if (*strbscan (p1, "\\/:") != NULL || *p1 != '.')
        p1 = p;
    strcpy (dst, p1);
    return strlen (dst) != 0;
}

/*  copy a filename part from source to dest if present.  return true if one
    is found
 */
filename (src, dst)
char *src, *dst;
{
    register char *p, *p1;

    p = src-1;
    while (*(p=strbscan (p1=p+1, "\\/:")) != NULL)
        ;
    /* p1 points after last / or at bos */
    p = strbscan (p1, ".");
    strcpy (dst, p1);
    dst[p-p1] = 0;
    return strlen (dst) != 0;
}

/*  copy a filename.ext part from source to dest if present.  return true if one
    is found
 */
fileext  (src, dst)
char *src, *dst;
{
    *dst = '\0';
    if ( filename (src, dst) ) {
        dst += strlen (dst);
        extention (src, dst);
        return TRUE;
        }
    return FALSE;
}

/*  copy the paths part of the file description.  return true if found
 */
path (src, dst)
char *src, *dst;
{
    register char *p, *p1;

    if (*(p=strbscan (src, ":")) != NULL)
        src = p+1;
    p = src-1;
    /* p points to beginning of possible path (after potential drive spec) */
    while (*(p=strbscan (p1=p+1, "\\/:")) != NULL)
        ;
    /* p1 points after  final / or bos */;
    strcpy (dst, src);
    dst[p1-src] = 0;
    return strlen (dst) != 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fc\tools.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
/*
 *  tools.h - Header file for accessing TOOLS.LIB routines
 *  includes stdio.h and ctype.h
 *
 *   4/14/86  dl added U_* flags for upd return values
 *
 *	31-Jul-1986 mz	Add Connect definitions
 */

#define TRUE	-1
#define FALSE	0

#if MSDOS
#define     PSEPSTR "\\"
#define     PSEPCHR '\\'
#else
#define     PSEPSTR "/"
#define     PSEPCHR '/'
#endif

typedef char flagType;
typedef long ptrType;

#define SETFLAG(l,f)	((l) |= (f))
#define TESTFLAG(v,f)	(((v)&(f))!=0)
#define RSETFLAG(l,f)	((l) &= ~(f))

#define SHIFT(c,v)	{c--; v++;}

#define LOW(w)		((int)(w)&0xFF)
#define HIGH(w) 	LOW((int)(w)>>8)
#define WORD(h,l)	((LOW((h))<<8)|LOW((l)))
#define POINTER(seg,off) ((((long)(seg))<<4)+ (long)(off))

#define FNADDR(f)	(f)

#define SELECT		if(FALSE){
#define CASE(x) 	}else if((x)){
#define OTHERWISE	}else{
#define ENDSELECT	}

/* buffer description for findfirst and findnext */

struct findType {
    char reserved[21];			/* reserved for start up	     */
    char attr;				/* attribute found		     */
    unsigned time;			/* time of last modify		     */
    unsigned date;			/* date of last modify		     */
    long length;			/* file size			     */
    char name[13];			/* asciz file name		     */
};

/* attributes */
#define A_RO	1			/* read only			     */
#define A_H	2			/* hidden			     */
#define A_S	4			/* system			     */
#define A_V	8			/* volume id			     */
#define A_D	16			/* directory			     */
#define A_A	32			/* archive			     */

#define A_MOD	(A_RO+A_H+A_S+A_A)	/* changeable attributes	     */

#define HASATTR(a,v)	TESTFLAG(a,v)	/* true if a has attribute v	     */

extern char XLTab[], XUTab[];

#define MAXARG	128
#define MAXPATHLEN  128

#include "ttypes.h"

struct vectorType {
    int max;				/* max the vector can hold	     */
    int count;				/* count of elements in vector	     */
    unsigned elem[1];			/* elements in vector		     */
};

/* return flags for upd */
#define U_DRIVE 0x8
#define U_PATH	0x4
#define U_NAME	0x2
#define U_EXT	0x1

/*  Connect definitions */

#define REALDRIVE	0x8000
#define ISTMPDRIVE(x)	(((x)&REALDRIVE)==0)
#define TOKTODRV(x)	((x)&~REALDRIVE)

/*  Heap Checking return codes */

#define HEAPOK           0
#define HEAPBADBEGIN    -1
#define HEAPBADNODE     -2

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\bootrec.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
;******************************************************************************
;
;  Change Log:
;
;    Date    Who   #                      Description
;  --------  ---  ---  ------------------------------------------------------
;  12/13/90  EGH  C36  Added support for 8 fixed disks.
;
;******************************************************************************
;       Static Name Aliases
;
        TITLE   bootrec.asm - master boot record images for fdisk

_TEXT   SEGMENT BYTE PUBLIC 'CODE'
_TEXT   ENDS
_DATA   SEGMENT WORD PUBLIC 'DATA'
_DATA   ENDS
CONST   SEGMENT WORD PUBLIC 'CONST'
CONST   ENDS
_BSS    SEGMENT WORD PUBLIC 'BSS'
_BSS    ENDS

DGROUP  GROUP     CONST,  _BSS,   _DATA
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP, ES: DGROUP

_DATA   SEGMENT  WORD PUBLIC 'DATA'

;
;               extern  struct struct-name BootRecordData;
;
;
;

;                                                                         ;*C36
; The following equate must match MAX_HDISK in FDISK.H                    ;*C36
;                                                                         ;*C36
MAX_HDISK       EQU     8                                                 ;*C36

PUBLIC  _master_boot_record
        public  _master_boot_record
_master_boot_record label   byte

include fdboot.inc
include fdboot.inc

IF MAX_HDISK GT 2                                                         ;*C36
include fdboot.inc      ;for disk 3
ENDIF                                                                     ;*C36
IF MAX_HDISK GT 3                                                         ;*C36
include fdboot.inc      ;for disk 4
ENDIF                                                                     ;*C36
IF MAX_HDISK GT 4                                                         ;*C36
include fdboot.inc	;for disk 5
ENDIF                                                                     ;*C36
IF MAX_HDISK GT 5                                                         ;*C36
include fdboot.inc	;for disk 6
ENDIF                                                                     ;*C36
IF MAX_HDISK GT 6                                                         ;*C36
include fdboot.inc	;for disk 7
ENDIF                                                                     ;*C36
IF MAX_HDISK GT 7                                                         ;*C36
include fdboot.inc      ;for disk 8                                       ;*C36
ENDIF                                                                     ;*C36

_DATA      ENDS

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\diskout.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "extern.h"                                                     /* AN000 */


/*  */
void write_info_to_disk()

BEGIN

    char            i;
    unsigned char   j;
    unsigned        extended_location;
    char            extended_index;
    char            temp;
/*C00    char            first_found;    */
    char            changed_flag;
    char            temp_disk;

    /* Change invalid value for temp to 0xff. NUL is a valid value for
       the index and cannot be used */

    temp = 0xff;                                                  /* AN009 */
    temp_disk = cur_disk;
    /* See if need to update the master boot record */
    for (j = uc(0); j < number_of_drives; j++)                      /* AC000 */
       BEGIN

        /* Save disk number */
        cur_disk = ((char)(j));

        /* See if there were any errors on that drive */
        if (good_disk[j])
           BEGIN
            for (i=c(0); i < c(4); i++)                             /* AC000 */
               BEGIN
                if (part_table[j][i].changed)
                   BEGIN
                    write_master_boot_to_disk(j);
                    break;
                   END
               END
            /* See if the extended partition exists - if not, don't fool with the logical*/
            /* drives - there is nothing to point to thier structures. Otherwise you get into */
            /* a chicken and the egg situation, where you are trying to write out 'deletes' of */
            /* the logical drive based on the start of the extended partition, but there isn't one */
            /* because it has already been deleted already. Bad things happen - PTM P941  */

            /* SR; 9/26/89; Removed semi-colon at the end of the if
               statement that caused the block of code to always execute*/

            if (find_partition_type(uc(EXTENDED)))                 /* AC000 */
               BEGIN
                /* See if any extended partitions need to be updated */
                changed_flag = FALSE;

                for (i=c(0);i <c(23); i++)                          /* AC000 */
                   BEGIN
                    if (ext_table[j][i].changed)
                       BEGIN
                        changed_flag = TRUE;
                        break;
                       END
                   END
                if (changed_flag)
                   BEGIN
                    /* First,get them in order - drive letters are assigned in the order */
                    /* that they exist on the disk */
                    sort_ext_table(c(23));                          /* AC000 */

                    for (i=c(0);i < c(23); i++)                     /* AC000 */

                       BEGIN
                        /* If there is a valid drive existing, write it out */
                        if (ext_table[j][sort[i]].sys_id != uc(0))  /* AC000 */
                           BEGIN
                            write_ext_boot_to_disk(i,j);
                           END
                       END

                    /* Find start of extended partition */
                    extended_index = find_partition_location(uc(EXTENDED));     /* AC000 */
                    extended_location = part_table[j][extended_index].start_cyl;

                    /* See if the first entry in EXTENDED DOS partition will be written out */
                    /* Need to find the first drive in the sorted list */
                    for (i=c(0);i < c(23); i++)                     /* AC000 */
                       BEGIN
                        if (ext_table[j][sort[i]].sys_id != uc(0))  /* AC000 */
                           BEGIN
                            temp = sort[i];
                            break;
                           END
                       END
                    /* See if drive written out */
                    /* SR; 9/28/89; Check for the special case when the
                       volume is deleted and write out only a pointer
                       for it */

                    if ((temp == c(0xff)) ||
                        (extended_location != ext_table[j][temp].start_cyl))   /* AC009 */
                       BEGIN
                        /* If not, make a special case and go do it */
                        /* Use the 24 entry in the array to set up a dummy entry */
                        /* This one isn't used for anything else */
                        /* Indicate this is special by passing along a deleted entry - the subroutine will catch it and handle correctly */
                        ext_table[j][23].sys_id = uc(0);            /* AC000 */
                        ext_table[j][23].start_cyl = part_table[j][extended_index].start_cyl;
                        ext_table[j][23].start_head = uc(0);        /* AC000 */
                        ext_table[j][23].start_sector = uc(1);      /* AC000 */

                        /* Write out our modified first location - only pointer info will be sent to the disk*/
                        write_ext_boot_to_disk(c(23),j);            /* AC000 */
                       END
                   END
               END
           END
       END
    cur_disk = temp_disk;
    return;
END

/*  */
char write_master_boot_to_disk(disk)

unsigned char   disk;

BEGIN

    unsigned        char i;
    unsigned        j;
/*C00    unsigned        x;         */
/*C00    unsigned        temp;      */
    unsigned long   long_temp;
    unsigned        index;
/*C00    char            location;  */
/*C00    unsigned        byte_temp; */

    /* Clean out the boot_record */
    for (j=u(0);j < u(BYTES_PER_SECTOR); j++)                       /* AC000 */
       BEGIN
        boot_record[j] = uc(0);                                     /* AC000 */
       END

    /* Copy the master boot record to boot_record */
    for (j=u(0); j < u(BYTES_PER_SECTOR); j++)                      /* AC000 */
       BEGIN
        boot_record[j] = master_boot_record[disk][j];
       END

    /* Copy the partition tables over - only bother with the changed ones */
    for (i=uc(0); i < uc(4); i++)                                   /* AC000 */
       BEGIN
        index = ((unsigned)i)*16;
        if (part_table[disk][i].changed)
           BEGIN
            /* Get boot ind */
            boot_record[0x1BE+(index)] = part_table[disk][i].boot_ind;

            /* Start head */
            boot_record[0x1BF+(index)] = part_table[disk][i].start_head;

            /* Start sector - scramble it to INT 13 format*/
            boot_record[0x1C0+(index)] = (part_table[disk][i].start_sector & 0x3F)  |
                                           ((unsigned char)((part_table[disk][i].start_cyl/256) << 6));

            /* Start cyl - scramble it to INT 13 format*/
            boot_record[0x1C1+(index)] = ((unsigned char)(part_table[disk][i].start_cyl%256));

            /* System id */
            boot_record[0x1C2+(index)]= part_table[disk][i].sys_id;

            /* End head */
            boot_record[0x1C3+(index)] = part_table[disk][i].end_head;

            /* End sector - scramble it to INT 13 format*/
            boot_record[0x1C4+(index)] = (part_table[disk][i].end_sector & 0x3F)  |
                                            ((unsigned char)((part_table[disk][i].end_cyl/256) << 6));

            /* End cyl - scramble it to INT 13 format*/
            boot_record[0x1C5+(index)] = ((unsigned char)(part_table[disk][i].end_cyl%256));

            /* Relative sectors */
            long_temp = part_table[disk][i].rel_sec;
            boot_record[0x1C9+(index)] = uc((long_temp >> 24));                     /* AC000 */
            boot_record[0x1C8+(index)] = uc(((long_temp & 0x00FF0000l) >> 16));     /* AC000 */
            boot_record[0x1C7+(index)] = uc(((long_temp & 0x0000FF00l) >> 8));      /* AC000 */
            boot_record[0x1C6+(index)] = uc((long_temp & 0x000000FFl));             /* AC000 */


            /* Number of sectors */
            long_temp = part_table[disk][i].num_sec;
            boot_record[0x1CD+(index)] = uc(long_temp >> 24);                       /* AC000 */
            boot_record[0x1CC+(index)] = uc((long_temp & 0x00FF0000l) >> 16);       /* AC000 */
            boot_record[0x1CB+(index)] = uc((long_temp & 0x0000FF00l) >> 8);        /* AC000 */
            boot_record[0x1CA+(index)] = uc(long_temp & 0x000000FFl);               /* AC000 */
          END
       END
    boot_record[510] = uc(0x55);                                    /* AC000 */
    boot_record[511] = uc(0xAA);                                    /* AC000 */

    return(write_boot_record(u(0),disk));                           /* AC000 */
END

/*  */
char write_ext_boot_to_disk(entry,disk)

char entry;
unsigned char disk;
BEGIN

    char            i;
    unsigned        j;
    unsigned long   long_temp;
/*C00    unsigned        index;  */
    char            location;
    char            next_drive;
    char            pointer;
    char            write;

    /* Clean out the boot_record */
    for (j=u(0);j < u(BYTES_PER_SECTOR); j++)                       /* AC000 */
       BEGIN
        boot_record[j] = uc(0);                                     /* AC000 */
       END

    /* First - setup the logical devices */
    /* See if it has been deleted - if so, leave entries as zero */
    /* Otherwise - go unscramble everything out of the arrays */

    /* SR; 9/28/89; If entry=23, then sort[entry] is undefined and we
       can have unpredictable results. Check for this special case */

    if (entry != 23 && ext_table[disk][sort[entry]].sys_id != uc(0))               /* AC000 */
       BEGIN
        /* Get boot ind */
        boot_record[0x1BE] = ext_table[disk][sort[entry]].boot_ind;

        /* Start head */
        boot_record[0x1BF] = ext_table[disk][sort[entry]].start_head;

        /* Start sector - scramble it to INT 13 format*/
        boot_record[0x1C0] = (ext_table[disk][sort[entry]].start_sector & 0x3F) |
                ((ext_table[disk][sort[entry]].start_cyl/256) << 6);

        /* Start cyl - scramble it to INT 13 format*/
        boot_record[0x1C1] = ((unsigned char)(ext_table[disk][sort[entry]].start_cyl%256));

        /* System id */
        boot_record[0x1C2]= ext_table[disk][sort[entry]].sys_id;

        /* End head */
        boot_record[0x1C3] = ext_table[disk][sort[entry]].end_head;

        /* End sector - scramble it to INT 13 format*/
        boot_record[0x1C4] = (ext_table[disk][sort[entry]].end_sector & 0x3F) |
              ((ext_table[disk][sort[entry]].end_cyl/256) << 6);

        /* End cyl - scramble it to INT 13 format*/
        boot_record[0x1C5] = ((unsigned char)(ext_table[disk][sort[entry]].end_cyl%256));

        /* Relative sectors */
        long_temp = ext_table[disk][sort[entry]].rel_sec;
        boot_record[0x1C9] = uc((long_temp >> 24));                 /* AC000 */
        boot_record[0x1C8] = uc(((long_temp & 0x00FF0000l) >> 16)); /* AC000 */
        boot_record[0x1C7] = uc(((long_temp & 0x0000FF00l) >> 8));  /* AC000 */
        boot_record[0x1C6] = uc((long_temp & 0x000000FFl));         /* AC000 */

        /* Number of sectors */
        long_temp = ext_table[disk][sort[entry]].num_sec;
        boot_record[0x1CD] = uc((long_temp >> 24));                 /* AC000 */
        boot_record[0x1CC] = uc(((long_temp & 0x00FF0000l) >> 16)); /* AC000 */
        boot_record[0x1CB] = uc(((long_temp & 0x0000FF00l) >> 8));  /* AC000 */
        boot_record[0x1CA] = uc((long_temp & 0x000000FFl));         /* AC000 */
       END

    /* set up pointer to next logical drive unless this is # 23 */
    if (entry != c(22))                                             /* AC000 */
       BEGIN
        /* Find the drive to be pointed to */
        pointer = entry+1;

        /* Handle the special case of a deleted or empty first entry in partition*/
        if (entry == c(23))                                          /* AC000 */
           BEGIN
            pointer = c(0);                                          /* AC000 */
           END
        for (i = pointer; i <c(23); i++)                             /* AC000 */
           BEGIN
            next_drive = ((char)(INVALID));

            /* Go look for the next valid drive */
            if (ext_table[disk][sort[i]].sys_id != uc(0))            /* AC000 */
               BEGIN
                next_drive = sort[i];
                break;
               END
           END
        if (next_drive != ((char)(INVALID)))
           BEGIN
            /* Get boot ind */
            boot_record[0x1CE] = uc(0);                             /* AC000 */

            /* Start head */
            boot_record[0x1CF] = uc(0);                             /* AC000 */

            /* Start sector - scramble it to INT 13 format*/
            boot_record[0x1D0] = uc(0x01) | ((ext_table[disk][next_drive].start_cyl/256) << 6);  /* AC000 */


            /* System id */
            boot_record[0x1D2]= uc(EXTENDED);                       /* AC000 */

            /* End head */
            boot_record[0x1D3] = uc(max_head[disk] -1);             /* AC004 */

            /* End sector - scramble it to INT 13 format*/
            boot_record[0x1D4] =(max_sector[disk] & 0x3F) | ((ext_table[disk][next_drive].end_cyl/256) << 6);


            /* Start cyl - scramble it to INT 13 format*/
            boot_record[0x1D1] = ((unsigned char)(ext_table[disk][next_drive].start_cyl%256));

            /* End cyl - scramble it to INT 13 format*/
            boot_record[0x1D5] = ((unsigned char)(ext_table[disk][next_drive].end_cyl%256));

            /* Relative sectors - this is from the front of the extended volume */
            /* Find the extended partition */
            location = find_partition_location(uc(EXTENDED));
            long_temp = ((unsigned long)(ext_table[disk][next_drive].start_cyl - part_table[disk][location].start_cyl))
                          * max_head[disk] *  max_sector[disk];
            boot_record[0x1D9] = uc((long_temp >> 24));                   /* AC000 */
            boot_record[0x1D8] = uc(((long_temp & 0x00FF0000l) >> 16));   /* AC000 */
            boot_record[0x1D7] = uc(((long_temp & 0x0000FF00l) >> 8));    /* AC000 */
            boot_record[0x1D6] = uc((long_temp & 0x000000FFl));           /* AC000 */

            /* Number of sectors in the next volume*/
            long_temp = ((unsigned long)(ext_table[disk][next_drive].end_cyl - ext_table[disk][next_drive].start_cyl+1))
                        * max_head[disk] * max_sector[disk];
            boot_record[0x1DD] = uc((long_temp >> 24));                   /* AC000 */
            boot_record[0x1DC] = uc(((long_temp & 0x00FF0000l) >> 16));   /* AC000 */
            boot_record[0x1DB] = uc(((long_temp & 0x0000FF00l) >> 8));    /* AC000 */
            boot_record[0x1DA] = uc((long_temp & 0x000000FFl));           /* AC000 */
           END
       END
    boot_record[510] = uc(0x55);                                    /* AC000 */
    boot_record[511] = uc(0xAA);                                    /* AC000 */

    /* Write the boot record out */
    if (entry != c(23))                                             /* AC000 */
       BEGIN
        write = write_boot_record(ext_table[disk][sort[entry]].start_cyl,disk);
       END
    else
       BEGIN
        /* Write the special case of the first entry only having a pointer */
        write = write_boot_record(ext_table[disk][23].start_cyl,disk);
       END
    return(write);
END





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\convert.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  10/10/90  EGH  C30  Don't try to determine if a drive > Z: is formatted,
*                      just return unformatted.
*  10/19/90  EGH  C32  Added code to handle multiple primary DOS partitions.
*  12/07/90  EGH  C34  Added support for fixed disks greater than 4G.
*
******************************************************************************/
#include "fdisk.h"
#include "subtype.h"
#include "dos.h"
#include "extern.h"
#include "string.h"
#include "ctype.h"


/******************************************************************************/
/*Routine name:  MBYTES_TO_CYLINDERS                                          */
/******************************************************************************/
/*                                                                            */
/*Description:   This routine will take input of MBtes and                    */
/*               convert it to cylinders rounding up to the next largest      */
/*               cylinder boundry.  Rounding up is done to make sure the      */
/*               requester is getting at least what he asked for to the       */
/*               next cylinder boundry.                                       */
/*                                                                            */
/*Called Procedures:    none                                                  */
/*                                                                            */
/*                                                                            */
/*Change History: Created        5/30/87         DRM                          */
/*                                                                            */
/*Input: Input                                                                */
/*                                                                            */
/*Output: Cylinders_out                                                       */
/*                                                                            */
/******************************************************************************/


unsigned  mbytes_to_cylinders(mbytes_in,which_disk)

XFLOAT		mbytes_in;
char		which_disk;



BEGIN

unsigned	cylinders_out;
unsigned long	cylinders_out1;
unsigned long	number_of_sectors;
unsigned long	number_of_tracks;
unsigned long	divide_by;

           /* If trying to create a 3.30 compatible 32 MB partition */
           /* Set the 32mb limit - round down                       */
           if (mbytes_in == (XFLOAT)32)
               BEGIN
               cylinders_out1 = ul(DOS_MAX);

	       divide_by = ul((max_head[which_disk]) * ul(max_sector[which_disk]));
	       cylinders_out = u(cylinders_out1 / divide_by);
               END
           else
               BEGIN
				  /* SR; 9/26/89; Long calulation incorrect */

	       number_of_sectors = ((ul(mbytes_in) * ul(ONE_MEG))/BYTES_PER_SECTOR);

				  /* SR; 9/26/89; Incorrect cast to int. Actually this modulo is */
				  /* always 0 because ONE_MEG mod BYTES_PER_SECTOR = 0 			  */
	       if (((mbytes_in * ONE_MEG) % BYTES_PER_SECTOR) != (int)0)
		 number_of_sectors++;
	       number_of_tracks = ul((number_of_sectors / max_sector[which_disk]));

				  /* SR; 9/26/89; Changed int cast to unsigned */
	       if (((unsigned)number_of_sectors % max_sector[which_disk]) != 0)
		  number_of_tracks++;
	       cylinders_out = u((number_of_tracks / max_head[which_disk]));

				  /* SR; 9/26/89; Changed int cast to unsigned */
	       if (((unsigned)number_of_tracks % max_head[which_disk]) != 0)
		  cylinders_out++;
               END

	   return(cylinders_out);
END



/*  */
/*******************************************************************************/
/*Routine name:  CYLINDERS_TO_MBYTES                                           */
/*******************************************************************************/
/*                                                                             */
/*Description:   This routine will take input of cylinders and convert         */
/*               it to MBytes.                                                 */
/*                                                                             */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*                                                                             */
/*Change History: Created        5/16/87         DRM                           */
/*                                                                             */
/*Input: Cylinders_in                                                          */
/*                                                                             */
/*Output: MBytes_out                                                           */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*******************************************************************************/

XFLOAT	   cylinders_to_mbytes(cylinders_in,which_disk)

unsigned	cylinders_in;
char		which_disk;

BEGIN

unsigned	 mbytes_out;
/*C34 unsigned long    number_of_bytes; */
unsigned long	 number_of_sectors;
unsigned long	 number_of_tracks;
unsigned long	 bytes_in_one_sector;

     bytes_in_one_sector = BYTES_PER_SECTOR;
     number_of_tracks = (ul(cylinders_in) * ul(max_head[which_disk]));
     number_of_sectors = (number_of_tracks * ul(max_sector[which_disk]));
/*C34 number_of_bytes = (ul(number_of_sectors) * ul(bytes_in_one_sector)); */
/*C34 mbytes_out =  f(number_of_bytes / ONE_MEG);                          */
/*C34 if ((number_of_bytes % ONE_MEG) >= (ONE_MEG / 2)) mbytes_out++;      */
     mbytes_out = numsecs_to_mbytes(number_of_sectors);                 /*C34*/
     return(mbytes_out);

END

XFLOAT	   numsecs_to_mbytes(numsecs)
unsigned	long numsecs;
{

unsigned long	 bytes_in_one_sector;
/*C34 unsigned long    number_of_bytes; */
unsigned         sectors_in_one_meg;                                    /*C34*/
unsigned	 mbytes_out;

     bytes_in_one_sector = BYTES_PER_SECTOR;
/*C34 number_of_bytes = (numsecs * ul(bytes_in_one_sector));        */
/*C34 mbytes_out =  f((number_of_bytes + ul(ONE_MEG/2)) / ONE_MEG); */
     sectors_in_one_meg = u(ONE_MEG / bytes_in_one_sector);             /*C34*/
     mbytes_out = f((numsecs + ul(sectors_in_one_meg/2)) / sectors_in_one_meg); /*C34*/
     return(mbytes_out);
}



/*  */
/*******************************************************************************/
/*Routine name:  CYLINDERS_TO_PERCENT                                          */
/*******************************************************************************/
/*                                                                             */
/*Description:   This routine will take input of cylinders and convert         */
/*               it to Percent.                                                */
/*                                                                             */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*                                                                             */
/*Change History: Created        5/16/87         DRM                           */
/*                                                                             */
/*Input: Cylinders_in                                                          */
/*                                                                             */
/*Output: percent_out                                                          */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*******************************************************************************/

unsigned  cylinders_to_percent(cylinders_in,total_cylinders)

unsigned      cylinders_in;
unsigned      total_cylinders;

BEGIN

unsigned      percentage_out;

/* SR; 9/26/89; Changed from double to unsigned long */
unsigned long large_number;

     /* This is the same as (cyl_in / tot_cyl) * 100 to get the percentage */
     /* because * 100 is really 100/1 which is (cyl_in*100)/(tot_cyl*1).   */

	 /* SR; 9/26/89; Check for cylinders_in = 0 because round off errors
		may cause total_cylinders = 1 but cylinders_in = 0 */
	 if (cylinders_in == 0)
		percentage_out = 0;
     else if (total_cylinders == 0)
         percentage_out = 0;
     else
         BEGIN

		  /* SR; 9/26/89; Changed double to unsigned long */
	 large_number = (unsigned long)(ul(cylinders_in) * 100l);
	 percentage_out = u(large_number / total_cylinders);
         END
     /* this should round up to the next percent if more than .5 percent */

	 /* SR; 9/26/89; Need type cast  to long or results truncated */
     if ((((long)cylinders_in * 100l) % total_cylinders) >= (total_cylinders / 2))
       percentage_out++;
     if (percentage_out > u(100)) percentage_out = u(100);
     return(percentage_out);
END

unsigned  mbytes_to_percent(mbytes_used, total_cap)

unsigned      mbytes_used;
XFLOAT      total_cap;

BEGIN

unsigned      percentage_out;

unsigned long large_number;

	if (mbytes_used) {
		large_number = ( mbytes_used * 100L ) +total_cap/2;
		percentage_out = (unsigned) (large_number/total_cap);
		if (percentage_out > u(100)) percentage_out = u(100);
	}
	else percentage_out = 0;
     	return(percentage_out);
END


/*  */
/******************************************************************************/
/*Routine name:  PERCENT_TO_CYLINDERS                                         */
/******************************************************************************/
/*                                                                            */
/*Description:   This routine will take input of percentage and               */
/*               convert it to cylinders rounding up to the next largest      */
/*               cylinder boundry.  Rounding up is done to make sure the      */
/*               requester is getting at least what he asked for to the       */
/*               next cylinder boundry.                                       */
/*                                                                            */
/*Called Procedures:    none                                                  */
/*                                                                            */
/*                                                                            */
/*Change History: Created        5/30/87         DRM                          */
/*                                                                            */
/*Input: Input                                                                */
/*                                                                            */
/*Output: Cylinders_out                                                       */
/*                                                                            */
/******************************************************************************/


XFLOAT percent_to_cylinders(percent_in,total_cylinders)

unsigned     percent_in;
unsigned     total_cylinders;


BEGIN

	XFLOAT	     cylinders_out;
        cylinders_out = (unsigned)((ul(percent_in) * ul(total_cylinders)) / 100);
		 /* SR; 9/26/89; Typecast to long needed */
	if (((ul(percent_in) * ul(total_cylinders)) % 100) != u(0))
	   cylinders_out++;
	return(cylinders_out);
END






/*  */
/*******************************************************************************/
/*Routine name:  DOS_UPPER                                                     */
/*******************************************************************************/
/*                                                                             */
/*Description:   This routine will uppcase a character using get country       */
/*               information (65H) with the capitalize single character        */
/*               call (20H).                                                   */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*Change History: Updated        5/31/87         DRM                           */
/*                                                                             */
/*Input: drive_value                                                           */
/*                                                                             */
/*Output: input_value                                                          */
/*                                                                             */
/*******************************************************************************/

char dos_upper(drive_value)                                             /* AN000 */

char drive_value;                                                       /* AN000 */

BEGIN                                                                   /* AN000 */

          char output;                                                  /* AN000 */

            regs.x.ax = (unsigned)CAPCHAR;   /* Get extended country information - AN000 */
            regs.h.dl = (unsigned char)drive_value;     /* Move input_value to register DL  - AN000 */
            int86((int)INT21,&regs,&regs);                              /* AN000 */
            output  = (char)regs.h.dl;                                  /* AN000 */

#ifdef DEBUG
            output = toupper(drive_value);
#endif

            return(output);                                             /* AN000 */
END                                                                     /* AN000 */





/*  */
/*******************************************************************************/
/*Routine name:  CHECK_YN_INPUT                                                  */
/*******************************************************************************/
/*                                                                             */
/*Description:   Get single character input, which must be a country           */
/*               dependent (Y/N).  Will be verified using new uppercase table  */
/*               function calls.  Will accept default value.                   */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*                                                                             */
/*                                                                             */
/*Change History: Updated        5/31/87         DRM                           */
/*                                                                             */
/*Input: input_value                                                           */
/*                                                                             */
/*Output: input                                                                */
/*        valid_input                                                          */
/*                                                                             */
/*******************************************************************************/

char check_yn_input(input_value)                                        /* AN000 */

         char   input_value;                                            /* AN000 */

BEGIN
         char   input;                                                  /* AN000 */

         /* Get extended country information */
         regs.x.ax = (unsigned)CAP_YN;                                  /* AN000 */
         /* Move input_value to register DL  */
         regs.h.dl = (unsigned char)input_value;                        /* AN000 */
         int86((int)INT21,&regs,&regs);                                 /* AN000 */

         /* check carry flag for error */
         if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)                 /* AN000 */
         /* input will be 0 for NO and 1 for YES in AX */
            input = c(NO_GOOD);    /* input will equal not 0 or 1 */    /* AN000 */
         else                                                           /* AN000 */
            input = c(regs.x.ax);                                       /* AN000 */

#ifdef DEBUG

        input = NO_GOOD;
        if ( (input_value == (char) 'Y') || (input_value == (char) 'y') ) input = c(1);
        if ( (input_value == (char) 'N') || (input_value == (char) 'n') ) input = c(0);

#endif

         return(input);                                                 /* AN000 */
END                                                                     /* AN000 */




/*  */
/*******************************************************************************/
/*Routine name:  GET_FS_AND_VOL                                                */
/*******************************************************************************/
/*                                                                             */
/*Description:   This routine will invoke INT21 44h (Block Generic IOCTL       */
/*               Subfunction) call to get volume label and file system type.   */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*Change History: Created        6/01/87         DRM                           */
/*                                                                             */
/*Input: input_drive                                                           */
/*                                                                             */
/*Output: pointer to dx register                                               */
/*                                                                             */
/*******************************************************************************/

FLAG get_fs_and_vol(input_drive)                                        /* AN000 */

          char input_drive;                                             /* AN000 */

BEGIN                                                                   /* AN000 */

          char output;

          /* Set up registers for Generic IOCTL INT21 (44h) get media ID */
          regs.x.ax = u(GENERIC_IOCTL);                                 /* AN000 */
          regs.h.bh = uc(ZERO);                                         /* AN000 */
          regs.h.bl = (((unsigned char)input_drive - 'A') + 1);        /* AN000 */
          regs.x.cx = u(GET_MEDIA_ID);                                  /* AN000 */
          regs.x.dx = (unsigned)&dx_buff;                               /* AN000 */
          segread(&segregs);
          intdosx(&regs,&regs,&segregs);                                /* AN000 */

          /* see if carry flag was zero or one */
          if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)                /* AN000 */
             output = FALSE;                                            /* AN000 */
          else                                                          /* AN000 */
             output = TRUE;                                             /* AN000 */

          return(output);                                               /* AN000 */
                                                                        /* AN000 */
END



/*  */
/*******************************************************************************/
/*Routine name:  GET_VOLUME_STRING                                             */
/*******************************************************************************/
/*                                                                             */
/*Description:   This routine will invoke INT21 4Eh (Find First Matching File) */
/*               and return the disk volume label.                             */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*Change History: Created        6/01/87         DRM                           */
/*                                                                             */
/*Input: input_drive                                                           */
/*                                                                             */
/*Output: volume_out                                                           */
/*                                                                             */
/*******************************************************************************/
void get_volume_string(input_drive,vol_label_addr)                      /* AN000 */
        char input_drive;                                               /* AN000 */
        char *vol_label_addr;                                           /* AN000 */
BEGIN                                                                   /* AN000 */

          char  first_string[13];                                       /* AC000 */
          char  find_first_buffer[50];                                  /* AN000 */
          unsigned i,j;                                                 /* AC000 */

          /* clear out any garbage in volume label field */
          for (i = u(0); i < u(12); i++)                                /* AN015 */
              BEGIN                                                     /* AN015 */
                  vol_label_addr[i] = u(0);                             /* AN015 */
              END                                                       /* AN015 */

          /* Point the DTA to our buffer so we can get the FindFirst output */
          regs.h.ah = uc(0x1A);                                         /* AN000 */
          regs.x.dx = (unsigned)&find_first_buffer[0];                      /* AN000 */
          segread(&segregs);
          intdosx(&regs,&regs,&segregs);                                /* AN000 */

          /* Find the first volume id */
          first_string[0] = input_drive;       /* Find the vol label  -   AN000 */
          first_string[1] = (char) '\0';
          strcat(first_string,FILE_NAME);                               /* AN000 */
          regs.h.ah = uc(FIND_FIRST_MATCH);                             /* AN000 */
          regs.x.cx = u(VOL_LABEL);                                     /* AN000 */
          regs.x.dx = (unsigned)&first_string[0];                           /* AN000 */
          intdos(&regs,&regs);                                /* AN000 */

/* AC000 The following is modified to take care of "." in the middle of the */
/*name */

          if ((regs.x.cflag & CARRY_FLAG) != CARRY_FLAG)                /* AN000 AC015 */
            BEGIN                                                       /* AN000 */
            for (i=j=u(0); i < strlen (&find_first_buffer[30]) ; i++)   /* AN000 */
                BEGIN                                                   /* AN000 */
                if (find_first_buffer[30+i] != PERIOD)                  /* AN003 */
                        vol_label_addr[i-j] = find_first_buffer[30+i];  /* AN000 */
                else                                                    /* AN000 */
                        j = u(1);                                       /* AN000 */
                END                                                     /* AN000 */
            END                                                         /* AN000 */
          return;                                                       /* AN000 */
END                                                                     /* AN000 */


/*  */
/*******************************************************************************/
/*Routine name:  CHECK_FORMAT                                                  */
/*******************************************************************************/
/*                                                                             */
/*Description:   This routine will invoke INT21 44h (Block Generic IOCTL       */
/*               Subfunction) call to see if the drive has been previously     */
/*               formatted by using a undocumented call.                       */
/*                                                                             */
/*Called Procedures:                                                           */
/*                                                                             */
/*Change History: Created        2/07/88         DRM                           */
/*                                                                             */
/*Input: input_drive                                                           */
/*                                                                             */
/*Output: pointer to dx register                                               */
/*                                                                             */
/*******************************************************************************/

FLAG check_format(input_drive)                                          /* AN002 */

          char input_drive;                                             /* AN002 */

BEGIN                                                                   /* AN002 */

          char formatted;                                               /* AN002 */

/*C32     if (input_drive <= 'Z') */                                    /*C30*/
          if ((input_drive >= 'C') && (input_drive <= 'Z'))             /*C32*/                  /*C30*/
          {                                                             /*C30*/
          /* Set up registers for Generic IOCTL INT21 (44h) check media  */
          regs.x.ax = u(GENERIC_IOCTL);                                 /* AN002 */
          regs.h.bh = uc(ZERO);                                         /* AN002 */
          regs.h.bl = (((unsigned char)input_drive - 'A') + 1);         /* AN002 */
          regs.x.cx = u(SPECIAL_FUNCTION);                              /* AN002 */
          regs.x.dx = (unsigned)&disk_access;                           /* AN002 */
          segread(&segregs);                                            /* AN002 */
          intdosx(&regs,&regs,&segregs);                                /* AN002 */

          /* see if buffer returned good or not */
          if (disk_access.dac_access_flag == ZERO)                      /* AN002 */
             formatted = FALSE;                                         /* AN002 */
          else                                                          /* AN002 */
             formatted = TRUE;                                          /* AN002 */
          }                                                             /*C30*/
          else                                                          /*C30*/
             formatted = FALSE;                                         /*C30*/

          return(formatted);                                            /* AN002 */

END                                                                     /* AN002 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\c_menus.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/07/90  EGH  C02  Problem fixed - Cannot create logical volumes, reports
*                      no free space.  Fix allows creation, reports correct
*                      free space.
*  03/07/90  EGH  C06  Problem fixed - Allows creation of partitions when
*                      100% of disk is used.  Fix does not allow partition
*                      less than 64 sectors.
*  03/07/90  EGH  C07  Problem fixed - 'Internal error' received when creating
*                      24 logical volumes & no primary exists.  Fix prevents
*                      more than 23 logical volumes from being created.
*  03/20/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  03/20/90  EGH  C13  This message is now displayed in the wait_for_ESC()
*                      routine.
*  10/19/90  EGH  C32  Added code to handle multiple primary DOS partitions.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */
#include "stdio.h"

/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: CREATE_PARTITION                           */
/*                                                             */
/* DESCRIPTIVE NAME: Create DOS related partition(s)           */
/*                                                             */
/* FUNCTION:                                                   */
/*      This routine verifies if there are free partitions,    */
/*      posts an status message if there is not, otherwise     */
/*      prints a screen asking what type of partition to       */
/*      be created, and passes control to the requested        */
/*      function.                                              */
/*                                                             */
/* NOTES: This is a screen control module only, no data is     */
/*        modified. Routine also will only allow 1 DOS and     */
/*        1 Ext DOS partitions per disk, if one already exists,*/
/*        then status message is displayed when the create     */
/*        option for that type partition is selected           */
/*                                                             */
/*        The following screen in managed                      */
/*                                                             */
/*       0000000000111111111122222222223333333333            */
/*       0123456789012345678901234567890123456789            */
/*     Ĵ            */
/*     00                                                    */
/*     01                                                    */
/*     02                                                    */
/*     03                                                    */
/*     04Create DOS Partition                                */
/*     05                                                    */
/*     06Current Fixed Disk Drive: #                         */
/*     07                                                    */
/*     08Choose one of the following:                        */
/*     09                                                    */
/*     10    1.  Create Primary DOS partition                */
/*     11    2.  Create EXTENDED DOS partition               */
/*     12    3.  Create logical DOS drive(s) in              */
/*     13        the EXTENDED DOS partition                  */
/*     14                                                    */
/*     15                                                    */
/*     16                                                    */
/*     17                                                    */
/*     18Enter choice: [ ]                                   */
/*     19                                                    */
/*     20                                                    */
/*     21                                                    */
/*     22                                                    */
/*     23Press ESC to return to FDISK Options                */
/*                 */
/*                                                             */
/* ENTRY POINTS: create_partition                              */
/*      LINKAGE: create_partition();                           */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      find_free_partition                                    */
/*      dos_create_partition                                   */
/*      ext_create_partition                                   */
/*      volume_create                                          */
/*      internal_program_error                                 */
/*      find_partition_type                                    */
/*      get_num_input                                          */
/*      display                                                */
/*      wait_for_ESC                                           */
/*      clear_screen                                           */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void create_partition()

BEGIN

char   input;
char   default_value;
char   max_input;




    input = c(NUL);                                                     /* AC000 */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
    /* put up heading and ESC */
    display(menu_8);
    display(menu_11);

    /* Setup current drive msg */
    insert[0]=cur_disk+1+'0';
    display(menu_5);

    /* See if there are free partitions */
    /* SR; 9/26/89; This check should be done only if the user asks to
       create a primary or extended partition and not for logical volumes */
/**SR; 9/26/89;     if (find_free_partition() != ((char)(NOT_FOUND)))                  /* AC000 */
/**SR; 9/26/89;         BEGIN	***/

        /* display menu */
        display(menu_3);                                                /* AN000 */
        display(menu_9);

        /* ############# ADD CODE HERE FOR THIS FUNCTION ############## */
        /* Do something about highlighting the available options and    */
        /* setting up defaults                                          */
        default_value = c(1);                                          /* AC000 */
        /* ############################################################ */
        /* setup default for prompt */
        insert[0] = c('1');                                            /* AC000 */
        display(menu_7);
        display(menu_10);

        max_input = c(3);                                               /* AC000 */

        input = get_num_input(default_value,max_input,input_row,input_col);

        /* SR; 9/26/89; We check here for the extended volume creation case
           and remove it from the switch statement */

        if (input == '3')
           {       /* Create a volume */
            if (find_partition_type(uc(EXTENDED)))
                volume_create();
            else
               {
                display(error_35);
                clear_screen(u(17),u(0),u(17),u(79));
                wait_for_ESC();
               }
           }
        else if (find_free_partition() != ((char)(NOT_FOUND)))
           {

            /* Go branch to the requested function */
            switch(input)
               BEGIN
                case '1':
                    dos_create_partition();
                    break;

            	case '2':
                    if ((cur_disk >= c(1)) || (find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) ||
                        (find_partition_type(uc(DOSNEW))))                   /* AN000 */                         /* AC000 */
                    	ext_create_partition();
                    else
                       BEGIN                                               /* AN000 */
                    	/* don't have a primary partition yet, can't create an ext */
                    	display(error_19);                                  /* AN000 */
                    	clear_screen(u(17),u(0),u(17),u(79));               /* AN000 */
                    	wait_for_ESC();                                     /* AN000 */
                       END                                                 /* AN000 */
                    break;

/* SR; 9/26/89; This case has been handled before the switch  */
#if 0
                case '3':
                   BEGIN
                    if (find_partition_type(uc(EXTENDED)))                  /* AC000 */
                        volume_create();
                    else                                                    /* AN000 */
                       BEGIN                                               /* AN000 */
                    	display(error_35);                                  /* AN000 */
                    	clear_screen(u(17),u(0),u(17),u(79));               /* AN000 */
                    	wait_for_ESC();                                     /* AN000 */
                       END                                                 /* AN000 */
                    break;
                   END
#endif

                case ESC:
                    break;

                default:
                    internal_program_error();
                    break;

               END
           }
        else
           {
            /* Display prompt telling there is no avail partition */
            display(error_10);
            input = wait_for_ESC();
           }
    /* clear the screen before going back to main menu */
    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DOS_CREATE_PARTITION                       */
/*                                                             */
/* DESCRIPTIVE NAME: Create default DOS partition on disk      */
/*                                                             */
/* FUNCTION: User is prompted to see if he wishes to use to    */
/*           set up a DOS partition in the maximum available   */
/*           size (limited to 32mb). If option is selected     */
/*           than partition is created and marked active. The  */
/*           partition is scanned to insure there are enough   */
/*           contiguous good sectors for DOS.                  */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is created and nothing will change         */
/*                                                             */
/*        The following screen is managed:                     */
/*                                                             */
/*       0000000000111111111122222222223333333333            */
/*       0123456789012345678901234567890123456789            */
/*     Ĵ            */
/*     00                                                    */
/*     01                                                    */
/*     02                                                    */
/*     03                                                    */
/*     04Create DOS Partition                                */
/*     05                                                    */
/*     06Current Fixed Disk Drive: #                         */
/*     07                                                    */
/*     08Do you wish to use the maximum size                 */
/*     09for a DOS partition and make the DOS                */
/*     10partition active (Y/N).........? [Y]                */
/*     11                                                    */
/*     12                                                    */
/*     13                                                    */
/*     14                                                    */
/*     15                                                    */
/*     16                                                    */
/*     17                                                    */
/*     18                                                    */
/*     19                                                    */
/*     20                                                    */
/*     21                                                    */
/*     22                                                    */
/*     23Press ESC to return to FDISK Options                */
/*                 */
/*                                                             */
/* ENTRY POINTS: dos_create_partition                          */
/*      LINKAGE: dos_create_partition();                       */
/*               NEAR CALL                                     */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      display                                                */
/*      get_yn_input                                           */
/*      wait_for_ESC                                           */
/*      input_dos_create                                       */
/*      make_partition                                         */
/*      check_bad_tracks                                       */
/*                                                             */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void dos_create_partition()


BEGIN

    char   input;
    char   temp;
    char   second_disk_flag;                                            /* AN000 */

    /* SR; 9/26/89; These variables are added for the various fixes */

    unsigned long total_sectors;
    unsigned char  i;
    char  defined_drives;
    char  temp_cur_disk;

    second_disk_flag = (FLAG)FALSE;                                     /* AN000 */
    input = c(NUL);                                                     /* AC000 */
    /* clear off screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Put up header */
    display(menu_12);

    /* Set up current disk message */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* Display ESC prompt */
    display(menu_11);

    /* See if already exists */
    if ((!find_partition_type(uc(DOS12))) && (!find_partition_type(uc(DOS16))) && (!find_partition_type(uc(DOSNEW))))  /* AC000 */

       BEGIN

        /* SR; 9/26/89; Ported from Olivetti fix. The min. no. of sectors
           in a partition must be >64 for BIOS to recognize the drive */

        temp = find_part_free_space(c(PRIMARY));
        total_sectors = (long)free_space[temp].space * max_sector[cur_disk] * max_head[cur_disk];
        if (total_sectors < 64)
           {
            display(error_10);      /**** No room on disk */
            input = wait_for_ESC();
            return;  /*C06*/
           }
        /* SR; 9/26/89; We do not allow creation of a drive on the second
           hard disk if there are already 23 drives on the 1st hard disk */
/*C07   else if (cur_disk == c(1))  */
        else                   /*C07*/
           {
            defined_drives = c(0);
            temp_cur_disk = cur_disk;

            /* Search both drives for defined drives */
            for (i = 0; i < number_of_drives; i++)
               {
                cur_disk = (c(i));

                /* See if there is a primary drive letter */
                if ((find_partition_type(uc(DOS12))) ||
                    (find_partition_type(uc(DOS16))) ||
                    (find_partition_type(uc(DOSNEW))))
                    defined_drives++;

                /* See if extended partition on disk */
                if (find_partition_type(uc(EXTENDED)))
                    /* Get number of logical drives */
                    defined_drives += get_num_logical_dos_drives();
               }
            /* Restore cur_disk  to original */
            cur_disk = temp_cur_disk;

            /* See if 26 or less drives total */
            if (defined_drives > c(23))
               /* Reached the maximum */
               {
                clear_screen(u(16),u(0),u(23),u(79));
                display(error_27);
                input = wait_for_ESC();
                return;
               }
           }

        /* Display prompt, depending on what disk */
        if (cur_disk == c(0))                                           /* AC000 */
            /* Put up make active partition message */
            display(menu_13);
        else
            BEGIN
            /* Second disk, so don;t put up prompt mentioning active partition */
            second_disk_flag = (FLAG)TRUE;                              /* AN000 */
            display(menu_45);                                           /* AC000 */
            END
        /* Get Y/N input */
        input = get_yn_input(c(Yes),input_row,input_col);               /* AC000 AC011 */

        /* Go handle input */
        switch(input)
            BEGIN
            case 1:                                                     /* AC000 */
                if ( second_disk_flag == (FLAG)FALSE)
                    BEGIN
                    /* Go get the biggest area left */
                    temp = find_part_free_space(c(PRIMARY));            /* AC000 */
                    make_partition(free_space[temp].space,temp,uc(ACTIVE),c(PRIMARY)); /* AC000 */
                    reboot_flag = (FLAG)TRUE;                           /* AC000 */
                    if (number_of_drives == uc(1))                      /* AN000 */
                        BEGIN                                           /* AN000 */
                        write_info_to_disk();
                        reboot_system();                                /* AC000 */
                        END                                             /* AN000 */
                    clear_screen(u(16),u(0),u(23),u(79));               /* AN000 */

                    /* made another partition, increment partition count */
/*C32               primary_partition_count++; */

                    display(status_12);                                 /* AN000 */
                    wait_for_ESC();
                    break;
                    END
                else
                    BEGIN                                               /* AN000 */
                    /* Go get the biggest area left */                  /* AN000 */
                    temp = find_part_free_space(c(PRIMARY));            /* AN000 */
                    make_partition(free_space[temp].space,temp,uc(NUL),c(PRIMARY)); /* AN000 */
                    reboot_flag = (FLAG)TRUE;                           /* AN000 */
                    clear_screen(u(16),u(0),u(23),u(79));               /* AN000 */

                    /* made another partition, increment partition count */
/*C32               primary_partition_count++; */

                    display(status_12);                                 /* AN000 */
                    wait_for_ESC();
                    break;
                    END

            case  0:
                input_dos_create();                               /* AC000 */
                break;

            case ESC:
                break;   /* take no action */

            default:
                internal_program_error();
            END
        END
    else
        BEGIN
        /* Display partition table-it will return if no partitions there */
        table_display();

        /* Primary partition already exists message */
        display(error_8);
        wait_for_ESC();
        END
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: INPUT_DOS_CREATE                           */
/*                                                             */
/* DESCRIPTIVE NAME: Create DOS partition on disk              */
/*                                                             */
/* FUNCTION: Gets user specified size for partition (maximum   */
/*           is 32mb or largest contiguous freespace, which-   */
/*           ever is smaller). Default is largest avail free   */
/*           space. Partition is created to default size,unless*/
/*           user enters different size, but is not marked     */
/*           active. User specified size must be smaller or    */
/*           equal to the default size                         */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is created and nothing will change         */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*       0000000000111111111122222222223333333333            */
/*       0123456789012345678901234567890123456789            */
/*     Ĵ            */
/*     00                                                    */
/*     01                                                    */
/*     02                                                    */
/*     03                                                    */
/*     04Create DOS partition                                */
/*     05                                                    */
/*     06Current Fixed Disk Drive: #                         */
/*     07                                                    */
/*     08Partition Status   Type  Start  End Size            */
/*     09                                                    */
/*     10                                                    */
/*     11                                                    */
/*     12                                                    */
/*     13                                                    */
/*     14Total disk space is #### cylinders.                 */
/*     15Maximum space available for partition               */
/*     16is #### cylinders.                                  */
/*     17                                                    */
/*     18Enter partition size............: [####]            */
/*     19                                                    */
/*     20                                                    */
/*     21                                                    */
/*     22                                                    */
/*     23Press ESC to return to FDISK Options                */
/*                 */
/*                                                             */
/* ENTRY POINTS: input_dos_create                              */
/*      LINKAGE: input_dos_create();                           */
/*               NEAR CALL                                     */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      table_display                                          */
/*      get_num_input                                          */
/*      display                                                */
/*      wait_for_ESC                                           */
/*      make_partition                                         */
/*      check_bad_tracks                                       */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void input_dos_create()

BEGIN

    unsigned  input;
    unsigned  default_entry;
    char      temp;
/*C00    char      location;  */

    input = u(NUL);                                                     /* AC000 */
    /* clear off screen */
    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */

    /* Put up heading */
    display(menu_12);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* Print ESC prompt */
    display(menu_11);

    /* Display partition table-it will return if no partitions there */
    table_display();

    sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
    display(menu_15);

    /* Get the free space */
    temp = find_part_free_space(c(PRIMARY));                           /* AC000 */

    /* Is there any ?*/
    if (free_space[temp].mbytes_unused != u(0))                        /* AC000 */

        BEGIN
        /* Display disk space */
        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
        display(menu_15);

        /* Setup and print max partition size */

        sprintf(insert,"%4.0d%3.0d%%",
                free_space[temp].mbytes_unused,
                free_space[temp].percent_unused);
        display(menu_16);

        /* Force repeats on the input until something valid (Non-Zero return) */
        default_entry = (unsigned)free_space[temp].mbytes_unused;      /* AC000 */
        valid_input = (FLAG)FALSE;                                     /* AC000 */

        while (!valid_input)

            BEGIN
            /* Display prompt */
            sprintf(insert,"%4.0d",default_entry);
            display(menu_39);

            input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,free_space[temp].percent_unused,menu_39,u(0),error_13);       /* AC000 */

            /* Update default in case of error, so it gets displayed and used */
            /* if user presses CR only */

            default_entry = input;
            clear_screen(u(19),u(0),u(23),u(79));                      /* AC000 */
            END

        if (input != ((unsigned)(ESC_FLAG)))                               /* AC000 */

            BEGIN
            /* Change input to cylinders */
            /* check to see if input was in percent or mbytes */

            if (PercentFlag)                                          /* AN000 */
                BEGIN                                                 /* AN000 */
                if (input == free_space[temp].percent_unused)
                    input = free_space[temp].space;                   /* AN000 */
                else                                                  /* AN000 */
                    input = percent_to_cylinders(input,total_disk[cur_disk]);
                END                                                   /* AN000 */
            else                                                      /* AN000 */
                BEGIN                                                 /* AN000 */
                if (input == free_space[temp].mbytes_unused)
                    input = free_space[temp].space;                   /* AN000 */
                else                                                  /* AN000 */
                    input = (unsigned)mbytes_to_cylinders(input,
                                                          cur_disk);  /* AN004 */
                END                                                   /* AN000 */

            /* Initialize PecentFlag back to FALSE */
            PercentFlag = (FLAG)FALSE;                                  /* AN000 */

            /* SR; 9/26/89; Display error message if input value = 0 */

            if (input == 0)
               {
                display(error_28);
                wait_for_ESC();
               }
            else
               {
            	/* Go create the partition */
            	make_partition(input,temp,uc(NUL),c(PRIMARY));            /* AC000 */

            	/* clear off the old prompt */
            	clear_screen(u(13),u(0),u(19),u(79));                     /* AC000 */

                /* made another partition, increment partition count */
/*C32           primary_partition_count++; */

            	/* Reissue the partition info */
            	table_display();

            	/* display the "okay, we did it" msg */
            	if (number_of_drives == uc(1))                              /* AN000 */
                	display(status_5);
            	else
                    BEGIN                                                   /* AN000 */
                    clear_screen(u(16),u(0),u(23),u(79));                   /* AN000 */
                    display(status_12);                                     /* AN000 */
                    END                                                     /* AN000 */

            	wait_for_ESC();

            	reboot_flag = TRUE;
               }

            END
        END
    /* SR; 9/26/89; Display error if insufficient space for partition */
    else
        {
        display(error_10);
        wait_for_ESC();
        }
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: EXT_CREATE_PARTITION                       */
/*                                                             */
/* DESCRIPTIVE NAME: Create EXTENDED DOS partition             */
/*                                                             */
/* FUNCTION: Gets user specified size for EXTENDED partition   */
/*           (Maximum is largest contiguous freespace). The    */
/*           default is the largest available freespace.       */
/*           space. Partition is created to default size,      */
/*           unless user enters different size, but is not     */
/*           marked as active. User specified size must be     */
/*           smaller or equal to default size                  */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is created and nothing will change         */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*    0000000000111111111122222222223333333333               */
/*    0123456789012345678901234567890123456789               */
/*  Ĵ               */
/*  00                                                       */
/*  01                                                       */
/*  02                                                       */
/*  03                                                       */
/*  04Create EXTENDED DOS partition                          */
/*  05                                                       */
/*  06Current Fixed Disk Drive: #                            */
/*  07                                                       */
/*  08Partition Status   Type  Start  End Size               */
/*  09                                                       */
/*  10                                                       */
/*  11                                                       */
/*  12                                                       */
/*  13                                                       */
/*  14Total disk space is  #### cylinders.                   */
/*  15Maximum space available for partition                  */
/*  16is #### cylinders.                                     */
/*  17                                                       */
/*  18Enter partition size............: [####]               */
/*  19                                                       */
/*  20                                                       */
/*  21                                                       */
/*  22                                                       */
/*  23Press ESC to return to FDISK Options                   */
/*                 */
/*                                                             */
/* ENTRY POINTS: EXTENDED_create_partition                     */
/*      LINKAGE: EXTENDED_create_partition();                  */
/*               NEAR CALL                                     */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      table_display                                          */
/*      get_num_input                                          */
/*      display                                                */
/*      find_partition_type                                    */
/*      wait_for_ESC                                           */
/*      make_partition                                         */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void ext_create_partition()


BEGIN

    unsigned  input;
    unsigned  default_entry;
    char      temp;


    input = u(NUL);                                                    /* AC000 */
    /* clear off screen */
    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */

    /* Put up heading */
    display(menu_17);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* print ESC prompt */
    display(menu_11);

    /* Display partition table-it will return if no partitions there */
        table_display();

    /* Go see if primary already exists and ext doesn't */
    if ((cur_disk >= c(1)) || (find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) ||
        (find_partition_type(uc(DOSNEW))))                                            /* AC000 */
        BEGIN
        if (!find_partition_type(uc(EXTENDED)))                         /* AC000 */
            /* We can go create one now */
            BEGIN

            /* Get the free space */
            temp = find_part_free_space(c(EXTENDED));                    /* AC000 */

            /* Is there any ?*/
            /* SR; 9/26/89; Instead of checking only the percentage which
               could be off because of rounding errors, we also check the
               mbytes available */

            if (free_space[temp].space != u(0) &&                  /* AC000 */
                (free_space[temp].percent_unused != u(0) ||
                 free_space[temp].mbytes_unused != u(0)))
                BEGIN

                /* Display disk space */
                sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
                display(menu_15);

                /* Setup and print max partition size */

                sprintf(insert,"%4.0d%3.0d%%",
                        free_space[temp].mbytes_unused,
                        free_space[temp].percent_unused);
                display(menu_16);

                /* Force repeats on the input until something valid (Non-Zero return) */
                /* Display MBytes unless MBytes == 0, then display percent */
                if (free_space[temp].mbytes_unused == u(0))             /* AN000 */
                    BEGIN                                               /* AN000 */
                    default_entry = (unsigned)free_space[temp].percent_unused; /* AC000 */
                    PercentFlag = (FLAG)TRUE;                           /* AN000 */
                    END                                                 /* AN000 */
                else                                                    /* AN000 */
                    BEGIN
                    default_entry = (unsigned)free_space[temp].mbytes_unused; /* AC000 */
                    PercentFlag = (FLAG)FALSE;                          /* AN000 */
                    END

                valid_input = (FLAG)FALSE;                              /* AC000 */

                while (!valid_input)
                    BEGIN
                    /* Display prompt */
                    if (!PercentFlag)                                   /* AN000 */
                        sprintf(insert,"%4.0d",default_entry);
                    else                                                /* AN000 */
                        sprintf(insert,"%3.0d%%",default_entry);        /* AN000 */
                    display(menu_42);                                   /* AC000 */

                    input = get_large_num_input(default_entry,free_space[temp].mbytes_unused,free_space[temp].percent_unused,menu_42,u(0),error_13);   /*  AC000 */

                    /* Update default in case of error, so it gets displayed and used */
                    /* if user presses CR only */

                    default_entry = input;
                    clear_screen(u(19),u(0),u(23),u(79));                /* AC000 */
                    END

                if (input != ((unsigned)(ESC_FLAG)))                          /* AC000 */
                    BEGIN

                    /* Change input to cylinders */
                    if (PercentFlag)                                          /* AN000 */
                        BEGIN                                                 /* AN000 */
                        if (input == free_space[temp].percent_unused)
                            input = free_space[temp].space;                   /* AN000 */
                        else                                                  /* AN000 */
                            input = percent_to_cylinders(input,total_disk[cur_disk]);
                        END                                                   /* AN000 */
                    else                                                      /* AN000 */
                        BEGIN                                                 /* AN000 */
                        if (input == free_space[temp].mbytes_unused)
                            input = free_space[temp].space;                   /* AN000 */
                        else                                                  /* AN000 */
                            input = (unsigned)mbytes_to_cylinders(input,
                                                                  cur_disk);  /* AN004 */
                        END                                                   /* AN000 */


                    /* Initialize PecentFlag back to FALSE */
                    PercentFlag = (FLAG)FALSE;                                  /* AN000 */

                    /* SR; 9/26/89; Display error message if input value = 0 */

                    if (input == 0)
                       {
                        display(error_28);
                        wait_for_ESC();
                       }
                    else
                       {

                    	/* Go create the partition */
                    	make_partition(input,temp,uc(NUL),c(EXTENDED));     /* AC000 */

                    	/* clear off the old prompt */
                    	clear_screen(u(13),u(0),u(19),u(79));               /* AC000 */

                    	/* Display the updated partition information */
                    	table_display();

                    	/* Hit esc to continue line */
/*C13                   clear_screen(u(24),u(0),u(24),u(79));  */           /* AN000 */
/*C13                   display(menu_46);                      */           /* AN000 */

                    	/* Tell user we created it */
                    	display(status_6);
                    	wait_for_ESC();

                    	reboot_flag = (FLAG)TRUE;                           /* AC000 */

                    	/* Go allow him to create disk volumes */
                    	volume_create();
                       }
                    END
                END
            else
                BEGIN
                /* No room */
                display(error_10);
                wait_for_ESC();
                END
            END
        else
            BEGIN
            /* Already have ext partition, tell user and bow out */
            display(error_9);
            wait_for_ESC();
            END
        END
    else
        BEGIN
        /* don't have a primary partition yet, can't create an ext */
        display(error_19);
        wait_for_ESC();
        END

    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: VOLUME_CREATE                              */
/*                                                             */
/* DESCRIPTIVE NAME: Create DOS disk volumes                   */
/*                                                             */
/* FUNCTION: Create the boot record/partition table structure  */
/*           needed to support the DOS disk volume arch in     */
/*           the EXTENDED partition. Volume is created to the  */
/*           the default size (largest contiguous freespace or */
/*           32mb, whichever smaller) or to the user specified */
/*           size (must be smaller or equal to default size).  */
/*           The volume boot record is created, and the appro- */
/*           priate pointers in other volume partition tables  */
/*           are generated.                                    */
/*                                                             */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is created and nothing will change         */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00Create DOS Disk Volume                                */
/*   01                                                      */
/*   02Vol Start End  Size                                   */
/*   03 #  ####  #### ####                                   */
/*   04                                                      */
/*   05                                                      */
/*   06                                                      */
/*   07                                                      */
/*   08                                                      */
/*   09                                                      */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14                                                      */
/*   15                                                      */
/*   16Total partition size is #### cylinders.               */
/*   17Maximum space available for disk                      */
/*   18volume is #### cylinders.                             */
/*   19                                                      */
/*   20Enter disk volume size..........: [####]              */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Volume_Create                                 */
/*      LINKAGE: Volume_Create ()                              */
/*           NEAR CALL                                         */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      display                                                */
/*      volume_display                                         */
/*      get_num_input                                          */
/*      wait_for_ESC                                           */
/*      make_partition                                         */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void volume_create()

BEGIN

    unsigned  input;
    unsigned  default_entry;
/*C00    char  temp;              */
    char  drive_letter;
/*C00    char  default_value;     */
    char  location;
/*C00    char  previous_location; */
    char  ext_location;
    unsigned char  i;
    char  defined_drives;
    char  temp_cur_disk;
    unsigned ext_part_percent_unused;                                   /* AN000 */
    unsigned ext_part_num;                                              /* AN000 */

    input = u(NUL);                                                     /* AC000 */

    /* clear off screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display header */
    display (menu_18);

    /* print ESC prompt */
    display(menu_11);

    /* Display volume info */
    drive_letter = volume_display();

    /* Loop until done */
    input = u(NUL);                                                     /* AC000 */
    while (input != ((unsigned)(ESC_FLAG)))                                  /* AC000 */

        BEGIN
        /* See if we have hit the max number of drives */
        defined_drives = c(0);                                          /* AC000 */
        temp_cur_disk = cur_disk;

        /* Search both drives for defined drives */
        for (i = uc(0); i < number_of_drives; i++)                      /* AC000 */

            BEGIN
            cur_disk = ((char)(i));

            /* See if there is a primary drive letter */
            if ((find_partition_type(uc(DOS12))) || (find_partition_type(uc(DOS16))) || (find_partition_type(uc(DOSNEW)))) /*AC000*/
                defined_drives++;

            /* See if extended partition on disk */
            if (find_partition_type(uc(EXTENDED)))                      /* AC000 */
                BEGIN
                /* Get number of logical drives */
                defined_drives = defined_drives + get_num_logical_dos_drives();
                END
            END
        /* Restore cur_disk  to original */
        cur_disk = temp_cur_disk;

        /* See if 26 or less drives total */
/*C07   if (defined_drives < c(24))                      */             /* AC000 */
        if ((defined_drives < c(24)) &&             /*C07*/
            (get_num_logical_dos_drives() < c(23))) /*C07*/
            BEGIN
            location = find_ext_free_space();

            /* find the number of the extended partiton to figure out percent */
            ext_part_num = find_partition_location(uc(EXTENDED));                   /* AN000 */

            /* Set the percent used */
            ext_part_percent_unused =
                cylinders_to_percent(free_space[location].space,
                ((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));                         /* AN00

            /* Is there any ?*/

            /* SR; 9/26/89; Instead of checking only the percentage which
               could be off because of rounding errors, we also check the
               mbytes available */

/*C02       if (free_space[temp].space != u(0) &&
                (free_space[temp].percent_unused != u(0) ||
                 free_space[temp].mbytes_unused != u(0)))             */
            if (free_space[location].space != u(0) &&
                (free_space[location].percent_unused != u(0) ||
                 free_space[location].mbytes_unused != u(0)))    /*C02*/
/*SR; 9/26/89;  if (ext_part_percent_unused != u(0))             /* AC000 */
                BEGIN

                /* Display disk space */
                sprintf(insert,"%4.0d",get_partition_size(uc(EXTENDED)) );
                display(menu_21);

                /* Setup and print max partition size */

                sprintf(insert,"%4.0d%3.0d%%",
                        free_space[location].mbytes_unused,
                        ext_part_percent_unused);
                display(menu_22);

                /* Force repeats on the input until something valid (Non-Zero return) */
                /* If MBytes unused  is equel to zero, display percent unused */
                if (free_space[location].mbytes_unused == u(0))         /* AN000 */
                    BEGIN                                               /* AN000 */
                    default_entry = (unsigned)ext_part_percent_unused;     /* AN000 */
                    PercentFlag = (FLAG)TRUE;                           /* AN000 */
                    END                                                 /* AN000 */
                else                                                    /* AN000 */
                    BEGIN                                               /* AN000 */
                    default_entry = (unsigned)free_space[location].mbytes_unused;     /* AC000 */
                    PercentFlag = (FLAG)FALSE;                          /* AN000 */
                    END                                                 /* AN000 */

                valid_input = (FLAG)FALSE;                              /* AC000 */

                while (!valid_input)
                    BEGIN
                    /* Display prompt */
                    if (!PercentFlag)                                   /* AN000 */
                        sprintf(insert,"%4.0d",default_entry);
                    else                                                /* AN000 */
                        sprintf(insert,"%3.0d%%",default_entry);        /* AN000 */

                    display(menu_40);

                    input = get_large_num_input(default_entry,free_space[location].mbytes_unused,ext_part_percent_unused,menu_40,u(0),error_12); /* AC000*/

                    /* Update default in case of error, so it gets displayed and used */
                    /* if user presses CR only */

                    default_entry = input;
                    clear_screen(u(19),u(0),u(23),u(79));               /* AC000 */
                    END

                if (input != ((unsigned)(ESC_FLAG)))                    /* AC000 */
                    BEGIN

                    /* Change input to cylinders */
                    if (PercentFlag)                                          /* AN000 */
                        BEGIN                                                 /* AN000 */
                        if (input == ext_part_percent_unused)
                            input = free_space[location].space;                   /* AN000 */
                        else                                                  /* AN000 */
                            input = percent_to_cylinders(input,((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));
                        END                                                   /* AN000 */
                    else                                                      /* AN000 */
                        BEGIN                                                 /* AN000 */
                        if (input == free_space[location].mbytes_unused)
                            input = free_space[location].space;                   /* AN000 */
                        else                                                  /* AN000 */
                            input = (unsigned)mbytes_to_cylinders(input,
                                                                  cur_disk);  /* AN004 */
                        END                                                   /* AN000 */

                    /* Initialize PecentFlag back to FALSE */
                    PercentFlag = (FLAG)FALSE;                                  /* AN000 */

                    /* SR; 9/26/89; Display error message if input value = 0 */

                    if (input == 0)
                       {
                        display(error_28);
                        wait_for_ESC();
                       }
                    else
                       {
                    	/* go create the entry and find out where it put it */
                    	ext_location = make_volume(input,location);

                    	/* clear off the old prompt */
                    	clear_screen(u(15),u(0),u(19),u(79));               /* AC000 */

                    	reboot_flag = (FLAG)TRUE;                           /* AC000 */

                    	/* Display the updated partition information */
                    	drive_letter = volume_display();

                    	/* Tell user we created it */
                    	display(status_7);
                       }
                    END
                END
            else
                BEGIN
                /* No space left or already max'd on the devices */
                /* Get rid of the size prompts */
                clear_screen(u(17),u(0),u(21),u(79));                   /* AC000 */
                display(error_20);
                volume_display();
                wait_for_ESC();                         /* KWC, 11-01-87 */
                input = u(ESC_FLAG);                    /* KWC, 11-01-87 */
                END
            END
        else
            BEGIN
            /* Reached the maximum */
            /* Get rid of the size prompts */
            clear_screen(u(17),u(0),u(21),u(79));                       /* AC000 */
            display(error_27);
            /* Force an exit with ESC */
            wait_for_ESC();                         /* KWC, 11-01-87 */
            input = u(ESC_FLAG);                    /* KWC, 11-01-87 */
            END
        END
    clear_screen(u(0),u(0),u(24),u(79));                               /* AC000 */
    return;
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\d_menus.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/07/90  EGH  C01  Problem fixed - Messages not properly displayed when
*                      deleting primary partition.  Code for 'RETAIL40' was
*                      rearranged and now uses standard message display
*                      routines.  (Also changes in FDISK.MSG, FDISKMSG.H, and
*                      USA-MS.MSG)
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  03/22/90  EGH  C14  Added support for deleting Non-DOS partitions.
*  05/25/90  EGH  C21  Added a prompt for the volume label when deleting a
*                      primary DOS partition to be consistent with deleting
*                      logical DOS drives.
*  05/29/90  EGH  C17  Don't display message "Press ESC to return to FDISK
*                      options" if it is immediately going to be overwritten
*                      by "Press ESC to continue".
*  09/18/90  EGH  C26  Call routines remove_partition() and remove_volume()
*                      to reduce code size.
*  10/03/90  EGH  C28  Delete Logical Volume prompts you to enter invalid
*                      letters if drives exist beyond z:.
*  10/19/90  EGH  C32  Added code to handle multiple primary DOS partitions.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */
#include "string.h"                                                     /* AN000 */
#include "ctype.h"                                                      /* AN000 */
#include "stdio.h"                                                      /* AN000 */

/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DELETE_PARTITION                           */
/*                                                             */
/* DESCRIPTIVE NAME: Delete partition selection menu           */
/*                                                             */
/* FUNCTION: User is prompted as to what type of DOS partition */
/*           he wishes to delete.                              */
/*                                                             */
/* NOTES: The delete volume option is only displayed if some   */
/*        disk volumes exist                                   */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00                                                      */
/*   01                                                      */
/*   02                                                      */
/*   03                                                      */
/*   04Delete DOS Partition                                  */
/*   05                                                      */
/*   06Current Fixed Disk Drive: #                           */
/*   07                                                      */
/*   08Enter the type of DOS partition you                   */
/*   09wish to delete..............?                         */
/*   10                                                      */
/*   11    1.  Normal DOS partition                          */
/*   12    2.  EXTENDED DOS Partition                        */
/*   13    3.  Disk volume in the EXTENDED                   */
/*   14        DOS Partition                                 */
/*   15                                                      */
/*   16                                                      */
/*   17                                                      */
/*   18Enter choice: [#]                                     */
/*   19                                                      */
/*   20                                                      */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Delete_Partition                              */
/*      LINKAGE: delete_partition()                            */
/*           NEAR CALL                                         */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      wait_for_ESC                                           */
/*      get_num_input                                          */
/*      internal_program_error                                 */
/*      dos_delete                                             */
/*      ext_delete                                             */
/*      vol_delete                                             */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void delete_partition()

BEGIN

    unsigned i;
    char input;
    char temp;
    char        max_input;


    input = c(NUL);                                                     /* AC000 */
    /* clear_screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display header */
    display(menu_25);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* print ESC prompt */
/*C17    display(menu_11);*/

    /* check to see if there is an avail partition                 */
    temp = c(0);                                                        /* AC000 */
    for (i = u(0); i < u(4);i++)                                        /* AC000 */
       BEGIN

        /* See if any non - zero system id bytes */
        temp = temp | part_table[cur_disk][i].sys_id ;
       END
    /* Any entry that isn't zero means */
    if (temp != c(0))                                                   /* AC000 */
       BEGIN
        /* ############# ADD CODE HERE FOR THIS FUNCTION ############## */
        /* Do something about defaults and highlighting                 */
        /*                                                              */
        /* ############################################################ */

        /* Display enter prompts */
        /* display dos delete menu without input prompt */
        display(menu_3);
        display(menu_25);
        display(menu_26);
        display(menu_7);

        /* print ESC prompt */                                          /*C17*/
        display(menu_11);                                               /*C17*/

        display(menu_27);                                               /* AC000 */
        display(menu_57);                                               /*C14*/
/*C14   max_input = c(3); */                                            /* AC000 */
        max_input = c(4);                                               /*C14*/

        input = get_num_input(c(NUL),max_input,input_row,input_col);    /* AC000 */
        /* Go branch to the requested function */
        switch(input)
           BEGIN
            case '1':
                if (find_partition_type(uc(DOS12)) ||             /* AN016 AC016 */
                    find_partition_type(uc(DOS16)) ||             /* AN016 AC016 */
                    find_partition_type(uc(DOSNEW)))              /* AN016 AC016 */
                    dos_delete();
                else                                              /* AN000 */
                    BEGIN                                         /* AN000 */
                    /* No Pri partition to delete */
                    clear_screen(u(17),u(0),u(17),u(79));         /* AN000 */
                    display(error_6);                             /* AN000 */
                    wait_for_ESC();                               /* AN000 */
                    END                                           /* AN000 */
                break;

            case '2':
                if (find_partition_type(uc(EXTENDED)))            /* AN000 */
                    ext_delete();
                else                                              /* AN000 */
                    BEGIN                                         /* AN000 */
                    /* No Ext partition to delete */
                    clear_screen(u(17),u(0),u(17),u(79));         /* AN000 */
                    display(error_7);                             /* AN000 */
                    wait_for_ESC();                               /* AN000 */
                    END                                           /* AN000 */
                break;

            case '3':
                if ((find_partition_type(uc(EXTENDED))) && (find_logical_drive()))  /* AC000 */
                    volume_delete();
                else
                    BEGIN
                    clear_screen(u(17),u(0),u(17),u(79));         /* AN000 */
                    display(error_36);                            /* AN000 */
                    wait_for_ESC();                               /* AN000 */
                    END                                           /* AN000 */
                break;

            case '4':                                                   /*C14*/
                if (find_non_dos_partition())                           /*C14*/
                    non_dos_delete();                                   /*C14*/
                else                                                    /*C14*/
                    BEGIN                                               /*C14*/
                    clear_screen(u(17),u(0),u(17),u(79));               /*C14*/
                    display(error_38);                                  /*C14*/
                    wait_for_ESC();                                     /*C14*/
                    END                                                 /*C14*/
                break;                                                  /*C14*/

            case ESC:
                break;

            default :
                internal_program_error();
                 break;
           END
       END
    else
       BEGIN
        display(error_14);
        wait_for_ESC();
       END
    /* clear the screen before going back to main menu */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DOS_DELETE                                 */
/*                                                             */
/* DESCRIPTIVE NAME: Delete DOS partition                      */
/*                                                             */
/* FUNCTION: Delete the DOS partition. Prompt user with dire   */
/*           warning first. Default entry on prompt is (N)     */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is deleted and nothing will change         */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00                                                      */
/*   01                                                      */
/*   02                                                      */
/*   03                                                      */
/*   04Delete DOS Partition                                  */
/*   05                                                      */
/*   06Current Fixed Disk Drive: #                           */
/*   07                                                      */
/*   08Partition Status   Type  Start  End Size              */
/*   09    #        #   #######  #### #### ####              */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14Total disk space is #### cylinders.                   */
/*   15                                                      */
/*   16                                                      */
/*   17                                                      */
/*   18Warning! Data in the DOS partition                    */
/*   19will be lost. Do you wish to                          */
/*   20continue..........................? [N]               */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: DOS_Delete                                    */
/*      LINKAGE: dos_delete                                    */
/*          NEAR CALL                                          */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if invalid input    */
/*             returned to this level                          */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES                                                  */
/*      table_display                                          */
/*      clear_screen                                           */
/*      wait_for_ESC                                           */
/*      get_yn_input                                           */
/*      display                                                */
/*      Write_Boot_Record                                      */
/*      find_part_free_space                                   */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void dos_delete()

BEGIN

    char input;
    unsigned i;
    unsigned char   string_input[12];                                   /*C21*/
/************** Support to delete primary partition for 4.0 retail ***********/
/* The following code adds support to fdisk to remove normal partitions      */
/* from the current hard disk if there are multiple partitions on the disk.  */
/* This is to support the multiple partition schemes of OEMs on DOS versions */
/* before DOS 3.30                                                           */
#if RETAIL40
    int     j;
    int     pri;
    int     ext;
    int     cnt;
    int     pnum;
#endif
/*************** End of 4.0 retail enhancement *******************************/

    input = c(NUL);                                                     /* AC000 */
    /* clear screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display header */
    display(menu_28);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* print ESC prompt */
    display(menu_11);

    /* Display partition data and double check if partition exists*/
    if (table_display())
       BEGIN

        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
        display(menu_15);

        /* See if drive 1 and extended partition exists */

/************** Support to delete primary partition for 4.0 retail ***********/
#if RETAIL40
        cnt = 0;
        pri = 0;
        ext = 0;

        /* Find the total number of partitions, the number of normal         */
        /* partitions, and whether there is an extended partition on the     */
        /* current hard disk                                                 */

        for (i = u(0); i < u(4); i++)
            if (part_table[cur_disk][i].sys_id != uc(0))
               {
                cnt++;
                if ((part_table[cur_disk][i].sys_id == uc(DOS12)) ||
                    (part_table[cur_disk][i].sys_id == uc(DOS16)) ||
                    (part_table[cur_disk][i].sys_id == uc(DOSNEW))  )
                   {
                    pri++;
                   }
                else if (part_table[cur_disk][i].sys_id == uc(LOGICAL))
                   {
                    ext = 1;
                   }
               }

        /* The partition can be deleted if the the number of normal          */
        /* partitions is greater than one or if there is only one but it is  */
        /* not the first hard disk or if there is only one normal partition  */
        /* on the first hard disk but no extended partition.                 */

        if ((pri > 1) ||
            (pri == 1 && cur_disk != c(0)) ||
            (pri == 1 && cur_disk == c(0) && !ext))
           BEGIN
            /* Display partition number prompt */
            display(menu_55);

            /* Get the partition number from the user */
            input = get_num_input(c(1),c(cnt),input_row,input_col);

            if (input != ESC)
               {
                pnum = (int)input - '0';

                /* The number that the user has entered is the sorted numbering  */
                /* of the partition table. We have to retrieve the actual        */
                /* position of this partition in the partition table             */

                j = 0;
                for (i = 0; i < 4; i++)
                   {
                    if (part_table[cur_disk][sort[i]].sys_id != 0)
                       {
                        j++;
                        if (j == pnum)
                            break;
                       }
                   };
                i = sort[i];

                /* Verify selected partition is a primary partition */

                if ((part_table[cur_disk][i].sys_id==uc(DOS12)) ||
                    (part_table[cur_disk][i].sys_id==uc(DOS16)) ||
                    (part_table[cur_disk][i].sys_id==uc(DOSNEW)) )
                   {
#else
        if (!(find_partition_type(uc(EXTENDED)) && (cur_disk == c(0))))
           BEGIN
            /* find partition entry to delete */
            for (i=u(0); i < u(4); i++)
                if ( (part_table[cur_disk][i].sys_id==uc(DOS12)) ||
                     (part_table[cur_disk][i].sys_id==uc(DOS16)) ||
                     (part_table[cur_disk][i].sys_id==uc(DOSNEW)) )
                    break;

            /* Display warning message */
            display(menu_29);
#endif
/*************** End of 4.0 retail enhancement *******************************/

                    /* delete privious volume mismatch message */       /*C21*/
                    string_input[0] = uc(NUL);                          /*C21*/
                                                                        /*C21*/
                    /* Get input volume label */                        /*C21*/
                    display(menu_41);                                   /*C21*/
                    get_string_input(input_row,input_col,string_input); /*C21*/
                    if (string_input[0] != uc(ESC))                     /*C21*/
                       {                                                /*C21*/
                        /* See if the volume id matches the drive */    /*C21*/
                        if (strcmp(part_table[cur_disk][i].vol_label,   /*C21*/
                            string_input) == (int)ZERO)                 /*C21*/
                           {                                            /*C12*/
                            /* Display Y/N prompt */
                            display(menu_34);

                            /* Get yes/no prompt */
                            input = get_yn_input(c(No),input_row,input_col);        /* AC000 AC011 */
                            switch(input)
                               BEGIN
                                case 1:                                             /* AC000 */
                                   BEGIN
                                    /* Set Partition entry to zero */
                                    remove_partition(cur_disk,i);       /*C26*/
/*C26                               part_table[cur_disk][i].boot_ind = uc(0);        *//* AC000 */
/*C26                               part_table[cur_disk][i].start_head = uc(0);      *//* AC000 */
/*C26                               part_table[cur_disk][i].start_sector = uc(0);    *//* AC000 */
/*C26                               part_table[cur_disk][i].start_cyl = u(0);        *//* AC000 */
/*C26                               part_table[cur_disk][i].sys_id = uc(0);          *//* AC000 */
/*C26                               part_table[cur_disk][i].end_head = uc(0);        *//* AC000 */
/*C26                               part_table[cur_disk][i].end_sector = uc(0);      *//* AC000 */
/*C26                               part_table[cur_disk][i].end_cyl = u(0);          *//* AC000 */
/*C26                               part_table[cur_disk][i].rel_sec = ul(0);         *//* AC000 */
/*C26                               part_table[cur_disk][i].num_sec = ul(0);         *//* AC000 */
/*C26                               part_table[cur_disk][i].changed = (FLAG)TRUE;    *//* AC000 */
/*C26                               part_table[cur_disk][i].mbytes_used = f(0);      *//* AN000 */
/*C26                               part_table[cur_disk][i].percent_used = u(0);     *//* AN000 */

/*C26                               strcpy(part_table[cur_disk][i].system,c(NUL));   *//* AN000 */
/*C26                               strcpy(part_table[cur_disk][i].vol_label,c(NUL));*//* AN000 */

                                    /* Redisplay the partition info */
                                    table_display();

                                    /* clear the prompt off */
                                    clear_screen(u(16),u(0),u(23),u(79));    /* AC000 */

                                    /* Decrement primary partition count */
/*C32                               primary_partition_count--; */

                                    /* Set the reboot flag */
                                    reboot_flag = (FLAG)TRUE;                /* AC000 */

                                    /* Say that you deleted it */
                                    display(status_1);

                                    wait_for_ESC();
                                    break;
                                   END

                                case 0:
                                    break;                                   /* AC000 */

                                case ESC:
                                    break;

                                default:
                                   BEGIN
                                    internal_program_error();
                                    break;
                                   END
                               END
                           }                                            /*C21*/
                        else                                            /*C21*/
                           {                                            /*C21*/
                            /* Tell user volume name was incorrect */   /*C21*/
                            display(error_34);                          /*C21*/
                            wait_for_ESC();                             /*C21*/
                           }                                            /*C21*/
                       }                                                /*C21*/

/************** Support to delete primary partition for 4.0 retail ***********/
#if RETAIL40
                   }
                else
                   {
                    /* Tell user he can only delete primary partition */
                    display(error_37);
                    wait_for_ESC();
                   }
               }
#endif
/*************** End of 4.0 retail enhancement *******************************/
           END
        else
           BEGIN
            /* Tell user he can't do it while extended exists on drive 1 */
            display(error_32);
            wait_for_ESC();
           END
       END

    else
       BEGIN
        internal_program_error();
       END
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: EXT_DELETE                                 */
/*                                                             */
/* DESCRIPTIVE NAME: Delete EXTENDED DOS partition             */
/*                                                             */
/* FUNCTION: Delete the EXTENDED DOS partition. Prompt with    */
/*           warning first. Default entry on prompt is (N)     */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is deleted and nothing will change         */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00                                                      */
/*   01                                                      */
/*   02                                                      */
/*   03                                                      */
/*   04Delete EXTENDED DOS Partition                         */
/*   05                                                      */
/*   06Current Fixed Disk Drive: #                           */
/*   07                                                      */
/*   08Partition Status   Type  Start  End Size              */
/*   09    #        #   #######  #### #### ####              */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14Total disk space is #### cylinders.                   */
/*   15                                                      */
/*   16                                                      */
/*   17                                                      */
/*   18Warning! Data in the EXTENDED DOS                     */
/*   19partition will be lost. Do you wish                   */
/*   20to continue.......................? [N]               */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Ext_Delete                                    */
/*      LINKAGE: ext_delete ()                                 */
/*          NEAR CALL                                          */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if invalid input    */
/*             returned to this routine                        */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      table_display                                          */
/*      clear_screen                                           */
/*      wait_for_ESC                                           */
/*      get_yn_input                                           */
/*      display                                                */
/*      Write_Boot_Record                                      */
/*      Internal_Program_Error                                 */
/*      Find_Free_Space                                        */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void ext_delete()


BEGIN

    char   input;
    unsigned i;
/*C00    unsigned j;  */                                                       /* AN000 */


    input = c(NUL);                                                     /* AC000 */
    /* Clear the screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display header */
    display(menu_30);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* print ESC prompt */
    display(menu_11);

    /* Display partition data and double check if partition exists*/
    table_display();                                                    /* AC000 */
    sprintf(insert,"%4.0d",total_mbytes[cur_disk]);
    display(menu_15);

       BEGIN
        /* See if there are still volumes */
        if (!find_logical_drive())
           BEGIN
            /* Display Y/N prompt */
            display(menu_31);

            /* Get yes/no prompt */
            input = get_yn_input(c(No),input_row,input_col);            /* AC000 AC011 */
            switch(input)
               BEGIN
                case 1:                                                 /* AC000 */
                   BEGIN
                    for (i=u(0); i < u(4); i++)                      /* AC000 */
                    /* Note: This will delete all occurances of EXTENDED DOS partitions found */
                       BEGIN
                        if (part_table[cur_disk][i].sys_id == uc(EXTENDED))  /* AC000 */
                           BEGIN
                            /* Set Partition entry to zero */
                            remove_partition(cur_disk,i);               /*C26*/
/*C26                       part_table[cur_disk][i].boot_ind = uc(0);        *//* AC000 */
/*C26                       part_table[cur_disk][i].start_head = uc(0);      *//* AC000 */
/*C26                       part_table[cur_disk][i].start_sector = uc(0);    *//* AC000 */
/*C26                       part_table[cur_disk][i].start_cyl = u(0);        *//* AC000 */
/*C26                       part_table[cur_disk][i].sys_id = uc(0);          *//* AC000 */
/*C26                       part_table[cur_disk][i].end_head = uc(0);        *//* AC000 */
/*C26                       part_table[cur_disk][i].end_sector = uc(0);      *//* AC000 */
/*C26                       part_table[cur_disk][i].end_cyl = u(0);          *//* AC000 */
/*C26                       part_table[cur_disk][i].rel_sec = ul(0);         *//* AC000 */
/*C26                       part_table[cur_disk][i].num_sec = ul(0);         *//* AC000 */
/*C26                       part_table[cur_disk][i].changed = (FLAG)TRUE;    *//* AC000 */
/*C26                       part_table[cur_disk][i].mbytes_used = f(0);      *//* AN000 */
/*C26                       part_table[cur_disk][i].percent_used = u(0);     *//* AN000 */

/*C26                       strcpy(part_table[cur_disk][i].system,c(NUL));   *//* AN000 */
/*C26                       strcpy(part_table[cur_disk][i].vol_label,c(NUL));*//* AN000 */

                            /* Redisplay the partition info */
                            table_display();

                            /* clear the prompt off */
                            clear_screen(u(17),u(0),u(23),u(79));    /* AC000 */

                            /* Say that you deleted it */
                            display(status_2);

                            /* Set the reboot flag */
                            reboot_flag = (FLAG)TRUE;                /* AC000 */
                           END
                       END
                    wait_for_ESC();
                    break;
                   END

                case 0:
                    break;                                       /* AC000 */

                case ESC:

                     break;

                default:
                     internal_program_error();
                     break;
               END
           END
        else
           BEGIN
            /* Logical drives still exist, can't delete partition */
            display(error_21);
            wait_for_ESC();
           END
       END
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: VOL_DELETE                                 */
/*                                                             */
/* DESCRIPTIVE NAME: Delete DOS disk Volume                    */
/*                                                             */
/* FUNCTION: Prompts user to delete a DOS disk volume          */
/*                                                             */
/* NOTES: Screen can be exited via the ESC command before      */
/*        partition is deleted and nothing will change         */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00Delete DOS Disk Volume                                */
/*   01                                                      */
/*   02Vol Start End  Size                                   */
/*   03 #  ####  #### ####                                   */
/*   04                                                      */
/*   05                                                      */
/*   06                                                      */
/*   07                                                      */
/*   08                                                      */
/*   09                                                      */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14                                                      */
/*   15                                                      */
/*   16Total partition size is #### cylinders.               */
/*   17                                                      */
/*   18Warning! Data in the DOS disk volume                  */
/*   19will be lost. What volume do you wish                 */
/*   20to delete.........................? [#]               */
/*   21                                                      */
/*   22Are you sure......................? [N]               */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Vol_Delete                                    */
/*      LINKAGE: vol_delete ()                                 */
/*          NEAR CALL                                          */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if invalid input    */
/*             returned to this routine                        */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      display                                                */
/*      volume_display                                         */
/*      get_num_input                                          */
/*      wait_for_ESC                                           */
/*      get_yn_input                                           */
/*      Write_Boot_Record                                      */
/*      Find_Free_Space                                        */
/*      Internal_Program_Error                                 */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void volume_delete()

BEGIN

    char   input;
    char   drive_input;
    char   high_drive;
    char   low_drive;
    char   error_low_drive;
    char   error_high_drive;
    char   drives_reassigned;
    int    list_index;
    int    i;
    int    j;                                                           /* AN011 */
    int    point;
    FLAG   delete_drive;
    unsigned char   drive_list[23][2];
    int    column;
    int    row;
    FLAG   drives_exist;
    FLAG   vol_matches;
    char   temp;
    unsigned char drive_temp;
    char far *s;
    unsigned char   string_input[12];                                   /* AN000 */

    input = c(NUL);
    string_input[0] = uc(NUL);                                          /* AN000 */

    /* Clear screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display header */
    display(menu_32);

    /* print ESC prompt */
    display(menu_11);

    /* Display logical drives and get the highest drive letter assigned*/
    high_drive = volume_display();

    /* Get the first avail drive letter to be deleted */
    low_drive = (high_drive - get_num_logical_dos_drives()+1);

    if (low_drive <= c('Z'))                                            /*C28*/
    {                                                                   /*C28*/
    if (high_drive > c('Z'))                                            /*C28*/
        high_drive = c('Z');                                            /*C28*/
                                                                        /*C28*/
    temp = low_drive;

    /* Initialize array of drive letters that exist at this point */
    for (i=(int)0; i < (int)23; i++)                                    /* AC000 */
        BEGIN
        /* See if we've exceeded the drive letter range */
        if (temp <= high_drive)
            BEGIN
            /* Put in drive letter */
            drive_list[i][0] = ((unsigned char)(temp));
            /* Initialize the offsets into the array to something harmless */
            drive_list[i][1] = uc(INVALID);                             /* AC000 */
            END
        else
            BEGIN
            /* No drive there, put in NUL */
            drive_list[i][0] = uc(NUL);                                 /* AC000 */
            drive_list[i][1] = uc(INVALID);                             /* AC000 */
            END

        /* Check for next drive */
        temp++;
        END

    /* Set up partition size message */
    sprintf(insert,"%4.0d",get_partition_size( uc(EXTENDED) ) );
    display(menu_21);

    /* Assume no drives deleted */
    drives_reassigned = (FLAG)FALSE;                                    /* AC000 */

    /* Loop until ESC or all deleted */
    while (input != c(ESC))                                             /* AC000 */
        BEGIN

        /* Are there any drives left?*/
        drives_exist = (FLAG)FALSE;                                     /* AC000 */
        error_low_drive = ((char)(NUL));
        error_high_drive = ((char)(NUL));

        for (i=(int)0;i < (int)23; i++)                                 /* AC000 */
            BEGIN
            drive_temp = drive_list[i][0];
            if ((drive_temp != uc(NUL)) && (drive_list[i][1] != uc(DELETED))) /* AC011 */
                BEGIN
                drives_exist = (FLAG)TRUE;                              /* AC000 */

                /* Find last existing drive letter */
                error_high_drive = ((char)(drive_temp));

                /* See if we've found the first drive yet */
                if (error_low_drive == ((char)(NUL)))
                    error_low_drive = ((char)(drive_temp));
                END
            END

        /* If there are drives, go let user try to delete them */
        if (drives_exist)
            BEGIN

            /* Get input until given a correct drive */
            valid_input = (FLAG)FALSE;                                  /* AC000 */
            while ( (!valid_input) && (input != c(ESC)) )
                BEGIN

                /* Prompt for input */
                display(menu_33);

                /* Get input between first and highest drive letters */
                clear_screen( u(21), u(0), u(21), u(79) );
                input = get_alpha_input(low_drive,high_drive,input_row,input_col,error_low_drive,error_high_drive);
                drive_input = input;

                /* See if it has been deleted already or ESC pressed */
                drives_exist = FALSE;
                for (i=(int)0;i < (int)23; i++)                         /* AC000 */
                    BEGIN
                    if (drive_list[i][0] == ((unsigned char)(drive_input)) &&
                       (drive_list[i][1] != ((unsigned char) DELETED))) /* AC013 */
                        BEGIN
                        drives_exist = TRUE;
                        list_index = i;
                        END
                    if (ext_table[cur_disk][i].drive_letter == c(drive_input) )
                        point = i;
                    END
                END

            /* Input volume string to confirm delete */
            vol_matches = FALSE;
            if (input != c(ESC))
                BEGIN
                if (drives_exist)
                    BEGIN
                    /* delete privious volume mismatch message */
                    string_input[0] = uc(NUL);                          /* AN000 */
                    clear_screen( u(22), u(0), u(23), u(79) );
                    /* Get input volume label */
                    display(menu_41);                                       /* AN000 */
                    get_string_input(input_row,input_col,string_input);     /* AN000 */
                    if (string_input[0] == uc(ESC)) input = c(ESC);

                    /* See if the volume id matches the selected drive */            /* AN000 */
                    if (strcmp(ext_table[cur_disk][point].vol_label,string_input) == (int)ZERO)
                           vol_matches = TRUE;                          /* AN000 */
                    else if (input != c(ESC)) display(error_34);
                    END
                 else
                    BEGIN
                    /* Tell user the drive has already been deleted */
                    insert[0] = dos_upper(drive_input);                 /* AC000 */
                    insert[1] = c(DRIVE_INDICATOR);                     /* AC000 */
                    clear_screen( u(21), u(0), u(22), u(79) );          /* AN000 */
                    display(error_29);
                    END
                END

                /* If it is a valid drive indicate that the input was ok */
                if ( (input != c(ESC)) && (drives_exist) && (vol_matches) )                /* AC000 */
                    BEGIN
                    valid_input = TRUE;

                    /* At this point we have a valid drive letter to delete */

                    /* Get the offset into the array for the drive to be deleted */
                    delete_drive = find_ext_drive(drive_input - low_drive);

                    /* Got a drive letter - prompt are you sure */
                    display(menu_34);

                    /* Get Y/N input, default is NO */
                    input = get_yn_input(c(No),input_row,input_col);    /* AC000 AC011 */

                    /* Clear everything out on screen in prompt area */
                    clear_screen(u(23),u(0),u(23),u(79));               /* AC000 */

                    /* Go handle the delete */
                    switch(input)
                        BEGIN
                        case 1:                                         /* AC000 */
                            BEGIN
                            /* Go ahead and mark it deleted in list array */

                            /* Throw up a flag to indicate we need to delete this one for real later */
                            /* This is because if we change the ext_table array now, we lose the ability */
                            /* to match up drive letters with locations, or at least it become more */
                            /* complicated than I felt like figuring out, so mark it now and do it later */
                            drive_list[list_index][1] = (unsigned char)DELETED;     /* AC011 */

                            drives_reassigned = TRUE;

                            /* Put prompt up on screen */
                            for (i=(int)0; i < (int)23; i++)           /* AC000 */
                                BEGIN
                                /* See if drive deleted */
                                if (drive_list[i][1] == uc(DELETED))   /* AC011 */
                                    BEGIN
                                    /* Wipe out the drive info and print deleted message */
                                    /* See what column it is in */
                                    if (i < (int)12)                   /* AC000 */
                                        BEGIN
                                        column = (int)4;               /* AC000 */
                                        row = (int)(4 + i - (int)0);
                                        clear_screen( (unsigned)row, (unsigned)column,
                                                      (unsigned)row, (unsigned)39 );
                                        END
                                    else
                                        BEGIN
                                        column = (int)45;              /* AC000 */
                                        row = (int)(4 + i - (int)12);
                                        clear_screen( (unsigned)row, (unsigned)column,
                                                      (unsigned)row, (unsigned)79 );
                                        END

                                    /* Put the start row,col of message in the message string */
                                    s=status_3;
                                    s++;
                                    *s++ = ((char)(row/10))+'0';
                                    *s++ = ((char)(row%10))+'0';
                                    *s++ = ((char)(column/10))+'0';
                                    *s = ((char)(column%10))+'0';
                                    display(status_3);
                                    END
                                END
                            /* Set the reboot flag */
                            reboot_flag = TRUE;
                            clear_screen( u(21), u(0), u(23), u(79) ); /* AN000 */
                            break;
                            END

                        case ESC:
                        case 0:
                            clear_screen( u(21), u(0), u(23), u(79) );  /* AN000 */
                            break;                                      /* AC000 */

                        default:
                            internal_program_error();
                            break;
                        END
                    END

            END
         else     /* drives do not exist! */
            BEGIN
            /* No more logical drives to delete */
            clear_screen(u(16),u(0),u(21),u(79));                       /* AC000 */
            display(error_22);
            input = wait_for_ESC();
            END
        END /* while input != esc */

    if (drives_reassigned)
        BEGIN
        /* If anything got deleted, lets go do it for real */
        for (i=(int)0; i < (int)23;i++)                                 /* AC000 */
            BEGIN
            if (drive_list[i][1] == uc(DELETED))                        /* AC011 */
                BEGIN                                                   /* AN011 */
                for (j=(int)0; j < (int)23;j++)                         /* AN011 */
                    BEGIN                                               /* AN011 */
                    if (drive_list[i][0] == ext_table[cur_disk][j].drive_letter)  /* AN011 */
                        BEGIN
                        /* Zero sys id and show it changed */
                        remove_volume(cur_disk,i);                      /*C26*/
/*C26                   ext_table[cur_disk][j].boot_ind = uc(0);        *//* AC000 */
/*C26                   ext_table[cur_disk][j].start_head = uc(0);      *//* AC000 */
/*C26                   ext_table[cur_disk][j].start_sector = uc(0);    *//* AC000 */
/*C26                   ext_table[cur_disk][j].start_cyl = u(0);        *//* AC000 */
/*C26                   ext_table[cur_disk][j].sys_id = uc(0);          *//* AC000 */
/*C26                   ext_table[cur_disk][j].end_head = uc(0);        *//* AC000 */
/*C26                   ext_table[cur_disk][j].end_sector = uc(0);      *//* AC000 */
/*C26                   ext_table[cur_disk][j].end_cyl = u(0);          *//* AC000 */
/*C26                   ext_table[cur_disk][j].rel_sec = ul(0);         *//* AC000 */
/*C26                   ext_table[cur_disk][j].num_sec = ul(0);         *//* AC000 */
/*C26                   ext_table[cur_disk][j].mbytes_used = f(0);      *//* AN000 */
/*C26                   ext_table[cur_disk][j].percent_used = u(0);     *//* AN000 */
/*C26                   ext_table[cur_disk][j].changed = TRUE;          *//* AN000 */
/*C26                   ext_table[cur_disk][j].drive_letter = NUL;      *//* AN000 */
/*C26                   strcpy(ext_table[cur_disk][j].system,c(NUL));   *//* AN000 */
/*C26                   strcpy(ext_table[cur_disk][j].vol_label,c(NUL));*//* AN000 */
                        END                                             /* AN011 */
                    END                                                 /* AN011 */
                END
            END

        /* Show new drive letters */
        volume_display();

        /* Say that drive letters changed */
        clear_screen(u(16),u(0),u(23),u(79));                           /* AC000 */
        display(status_10);
        wait_for_ESC();
        END
    }                                                                   /*C28*/
    else     /* drives do not exist! */                                 /*C28*/
    {                                                                   /*C28*/
        /* No more logical drives to delete */                          /*C28*/
        clear_screen(u(16),u(0),u(21),u(79));                           /*C28*/
        display(error_36);                                              /*C28*/
        wait_for_ESC();                                                 /*C28*/
    }                                                                   /*C28*/
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    return;

END

/*  */
/******************* START OF SPECIFICATIONS *******************/       /*C14*/
/*                                                             */       /*C14*/
/* SUBROUTINE NAME: NON_DOS_DELETE                             */       /*C14*/
/*                                                             */       /*C14*/
/* DESCRIPTIVE NAME: Delete Non-DOS partition                  */       /*C14*/
/*                                                             */       /*C14*/
/* FUNCTION: Delete the Non-DOS partition. Prompt user with    */       /*C14*/
/*           warning first. Default entry on prompt is (N)     */       /*C14*/
/*                                                             */       /*C14*/
/* NOTES: Screen can be exited via the ESC command before      */       /*C14*/
/*        partition is deleted and nothing will change         */       /*C14*/
/*                                                             */       /*C14*/
/*        The following screen is managed                      */       /*C14*/
/*                                                             */       /*C14*/
/*     0000000000111111111122222222223333333333              */       /*C14*/
/*     0123456789012345678901234567890123456789              */       /*C14*/
/*   Ĵ              */       /*C14*/
/*   00                                                      */       /*C14*/
/*   01                                                      */       /*C14*/
/*   02                                                      */       /*C14*/
/*   03                                                      */       /*C14*/
/*   04Delete Non-DOS Partition                              */       /*C14*/
/*   05                                                      */       /*C14*/
/*   06Current Fixed Disk Drive: #                           */       /*C14*/
/*   07                                                      */       /*C14*/
/*   08Partition Status   Type  Start  End Size              */       /*C14*/
/*   09    #        #   #######  #### #### ####              */       /*C14*/
/*   10                                                      */       /*C14*/
/*   11                                                      */       /*C14*/
/*   12                                                      */       /*C14*/
/*   13                                                      */       /*C14*/
/*   14Total disk space is #### cylinders.                   */       /*C14*/
/*   15                                                      */       /*C14*/
/*   16                                                      */       /*C14*/
/*   17                                                      */       /*C14*/
/*   18Warning! Data in the Non-DOS partition                */       /*C14*/
/*   19will be lost. Do you wish to                          */       /*C14*/
/*   20continue..........................? [N]               */       /*C14*/
/*   21                                                      */       /*C14*/
/*   22                                                      */       /*C14*/
/*   23Press ESC to return to FDISK Options                  */       /*C14*/
/*                 */       /*C14*/
/*                                                             */       /*C14*/
/* ENTRY POINTS: Non_DOS_Delete                                */       /*C14*/
/*      LINKAGE: non_dos_delete                                */       /*C14*/
/*          NEAR CALL                                          */       /*C14*/
/*                                                             */       /*C14*/
/* INPUT: None                                                 */       /*C14*/
/*                                                             */       /*C14*/
/* EXIT-NORMAL: ERROR=FALSE                                    */       /*C14*/
/*                                                             */       /*C14*/
/* EXIT-ERROR: ERROR=TRUE                                      */       /*C14*/
/*             GOTO internal_program_error if invalid input    */       /*C14*/
/*             returned to this level                          */       /*C14*/
/*                                                             */       /*C14*/
/* EFFECTS: No data directly modified by this routine, but     */       /*C14*/
/*          child routines will modify data.                   */       /*C14*/
/*                                                             */       /*C14*/
/* INTERNAL REFERENCES:                                        */       /*C14*/
/*   ROUTINES                                                  */       /*C14*/
/*      table_display                                          */       /*C14*/
/*      clear_screen                                           */       /*C14*/
/*      wait_for_ESC                                           */       /*C14*/
/*      get_yn_input                                           */       /*C14*/
/*      display                                                */       /*C14*/
/*      Write_Boot_Record                                      */       /*C14*/
/*      find_part_free_space                                   */       /*C14*/
/*                                                             */       /*C14*/
/* EXTERNAL REFERENCES:                                        */       /*C14*/
/*   ROUTINES:                                                 */       /*C14*/
/*                                                             */       /*C14*/
/******************** END OF SPECIFICATIONS ********************/       /*C14*/
                                                                        /*C14*/
/*  */                                                                 /*C14*/
void non_dos_delete()                                                   /*C14*/
                                                                        /*C14*/
BEGIN                                                                   /*C14*/
                                                                        /*C14*/
    char input;                                                         /*C14*/
    unsigned i;                                                         /*C14*/
    int     j;                                                          /*C14*/
    int     cnt;                                                        /*C14*/
    int     pnum;                                                       /*C14*/
                                                                        /*C14*/
    input = c(NUL);                                                     /*C14*/
    /* clear screen */                                                  /*C14*/
    clear_screen(u(0),u(0),u(24),u(79));                                /*C14*/
                                                                        /*C14*/
    /* Display header */                                                /*C14*/
    display(menu_58);                                                   /*C14*/
                                                                        /*C14*/
    /* Setup and print current disk */                                  /*C14*/
    insert[0] = cur_disk+1+'0';                                         /*C14*/
    display(menu_5);                                                    /*C14*/
                                                                        /*C14*/
    /* print ESC prompt */                                              /*C14*/
    display(menu_11);                                                   /*C14*/
                                                                        /*C14*/
    /* Display partition data and double check if partition exists*/    /*C14*/
    if (table_display())                                                /*C14*/
       BEGIN                                                            /*C14*/
                                                                        /*C14*/
        sprintf(insert,"%4.0d",total_mbytes[cur_disk]);                 /*C14*/
        display(menu_15);                                               /*C14*/
                                                                        /*C14*/
        /* count the number of partitions */                            /*C14*/
        cnt = 0;                                                        /*C14*/
        for (i = u(0); i < u(4); i++)                                   /*C14*/
            if (part_table[cur_disk][i].sys_id != uc(0))                /*C14*/
                cnt++;                                                  /*C14*/
                                                                        /*C14*/
        /* Display partition number prompt */                           /*C14*/
        display(menu_59);                                               /*C14*/
                                                                        /*C14*/
        /* Get the partition number from the user */                    /*C14*/
        input = get_num_input(c(1),c(cnt),input_row,input_col);         /*C14*/
                                                                        /*C14*/
        if (input != ESC)                                               /*C14*/
           BEGIN                                                        /*C14*/
            pnum = (int)input - '0';                                    /*C14*/
                                                                        /*C14*/
            /* The number that the user has entered is the sorted */    /*C14*/
            /* numbering of the partition table.  We have to      */    /*C14*/
            /* retrieve the actual position of this partition in  */    /*C14*/
            /* the partition table.                               */    /*C14*/
                                                                        /*C14*/
            j = 0;                                                      /*C14*/
            for (i = 0; i < 4; i++)                                     /*C14*/
               BEGIN                                                    /*C14*/
                if (part_table[cur_disk][sort[i]].sys_id != 0)          /*C14*/
                   BEGIN                                                /*C14*/
                    j++;                                                /*C14*/
                    if (j == pnum)                                      /*C14*/
                        break;                                          /*C14*/
                   END                                                  /*C14*/
               END                                                      /*C14*/
            i = sort[i];                                                /*C14*/
                                                                        /*C14*/
            /* Verify selected partition is a non-DOS partition */      /*C14*/
                                                                        /*C14*/
            if ((part_table[cur_disk][i].sys_id!=uc(DOS12))  &&         /*C14*/
                (part_table[cur_disk][i].sys_id!=uc(DOS16))  &&         /*C14*/
                (part_table[cur_disk][i].sys_id!=uc(DOSNEW)) &&         /*C14*/
                (part_table[cur_disk][i].sys_id!=uc(EXTENDED)) )        /*C14*/
               BEGIN                                                    /*C14*/
                /* Display Y/N prompt */                                /*C14*/
                display(menu_56);                                       /*C14*/
                                                                        /*C14*/
                /* Get yes/no prompt */                                 /*C14*/
                input = get_yn_input(c(No),input_row,input_col);        /*C14*/
                switch(input)                                           /*C14*/
                   BEGIN                                                /*C14*/
                    case 1:                                             /*C14*/
                       BEGIN                                            /*C14*/
                        /* Set Partition entry to zero */               /*C14*/
                        remove_partition(cur_disk,i);                   /*C26*/
/*C26                   part_table[cur_disk][i].boot_ind = uc(0);       *//*C14*/
/*C26                   part_table[cur_disk][i].start_head = uc(0);     *//*C14*/
/*C26                   part_table[cur_disk][i].start_sector = uc(0);   *//*C14*/
/*C26                   part_table[cur_disk][i].start_cyl = u(0);       *//*C14*/
/*C26                   part_table[cur_disk][i].sys_id = uc(0);         *//*C14*/
/*C26                   part_table[cur_disk][i].end_head = uc(0);       *//*C14*/
/*C26                   part_table[cur_disk][i].end_sector = uc(0);     *//*C14*/
/*C26                   part_table[cur_disk][i].end_cyl = u(0);         *//*C14*/
/*C26                   part_table[cur_disk][i].rel_sec = ul(0);        *//*C14*/
/*C26                   part_table[cur_disk][i].num_sec = ul(0);        *//*C14*/
/*C26                   part_table[cur_disk][i].changed = (FLAG)TRUE;   *//*C14*/
/*C26                   part_table[cur_disk][i].mbytes_used = f(0);     *//*C14*/
/*C26                   part_table[cur_disk][i].percent_used = u(0);    *//*C14*/
                                                                        /*C14*/
/*C26                   strcpy(part_table[cur_disk][i].system,c(NUL));   *//*C14*/
/*C26                   strcpy(part_table[cur_disk][i].vol_label,c(NUL));*//*C14*/
                                                                        /*C14*/
                        /* Redisplay the partition info */              /*C14*/
                        table_display();                                /*C14*/
                                                                        /*C14*/
                        /* clear the prompt off */                      /*C14*/
                        clear_screen(u(16),u(0),u(23),u(79));           /*C14*/
                                                                        /*C14*/
                        /* Set the reboot flag */                       /*C14*/
                        reboot_flag = (FLAG)TRUE;                       /*C14*/
                                                                        /*C14*/
                        /* Say that you deleted it */                   /*C14*/
                        display(status_13);                             /*C14*/
                                                                        /*C14*/
                        wait_for_ESC();                                 /*C14*/
                        break;                                          /*C14*/
                       END                                              /*C14*/
                                                                        /*C14*/
                    case 0:                                             /*C14*/
                        break;                                          /*C14*/
                                                                        /*C14*/
                    case ESC:                                           /*C14*/
                        break;                                          /*C14*/
                                                                        /*C14*/
                    default:                                            /*C14*/
                       BEGIN                                            /*C14*/
                        internal_program_error();                       /*C14*/
                        break;                                          /*C14*/
                       END                                              /*C14*/
                   END                                                  /*C14*/
               END                                                      /*C14*/
            else                                                        /*C14*/
               BEGIN                                                    /*C14*/
                /* Tell user he can only delete non-DOS partition */    /*C14*/
                display(error_39);                                      /*C14*/
                wait_for_ESC();                                         /*C14*/
               END                                                      /*C14*/
           END                                                          /*C14*/
       END                                                              /*C14*/
    else                                                                /*C14*/
       BEGIN                                                            /*C14*/
        internal_program_error();                                       /*C14*/
       END                                                              /*C14*/
    clear_screen(u(0),u(0),u(24),u(79));                                /*C14*/
    return;                                                             /*C14*/
END                                                                     /*C14*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\doscall.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/*static char *SCCSID = "@(#)doscall.h	6.25 86/06/03";*/
/***	doscall.h
 *
 *	Shirleyd
 *	                                         
 *	12/13/85
 *
 *	Description:
 *
 *		Function declarations to provide strong type checking
 *		on arguments to DOS 4.0 function calls
 *
 *	Major Modifications 04/28/86 by S. S.
 *	Major Modifications 04/30/86 by K. D.
 *	Minor Modifications 04/30/86 by S. S. (DosTimerAsync/Start)
 *	Major Modifications 05/01/86 by S. S. (fix Sems,add Queues)
 *	Minor Modifications 05/14/86 by K. D. (DosFileLocks)
 *	Minor Modifications 05/16/86 by S. S. (NLS routines)
 *	Minor Modifications 05/20/86 by S. S. (Get/SetPrty,CreateThread)
 *	Minor Modifications 05/20/86 by S. S. (add DosSetVector)
 *	Minor Modifications 06/02/86 by S. S. (GetHugeShift, MuxSemWait)
 *	Major Modifications 06/03/86 by S. S. (Mouse calls)
 */



/***	CursorData - structure that contains the characteristics
 *	of the cursor
 */

struct CursorData {
	unsigned cur_start;		/* Cursor start line */
	unsigned cur_end;		/* Cursor end line */
	unsigned cur_width;		/* Cursor width */
	unsigned cur_attribute;		/* Cursor attribute */
	};



/***	DateTime - structure for date and time */

struct DateTime {
	unsigned char hour;		/* current hour */
	unsigned char minutes;		/* current minute */
	unsigned char seconds;		/* current second */
	unsigned char hundredths;	/* current hundredths of a second */
	unsigned char day;		/* current day */
	unsigned char month;		/* current month */
	unsigned year;			/* current year */
	unsigned timezone;		/* minutes of time west of GMT */
	unsigned char day_of_week;	/* current day of week */
	};



/***	FileFindBuf - structure of area where the filesystem driver
 *	returns the results of the search
 */

struct FileFindBuf {
	unsigned create_date;		/* date of file creation */
	unsigned create_time;		/* time of file creation */
	unsigned access_date;		/* date of last access */
	unsigned access_time;		/* time of last access */
	unsigned write_date;		/* date of last write */
	unsigned write_time;		/* time of last write */
	unsigned long file_size;	/* file size (end of data) */
	unsigned long falloc_size;	/* file allocated size */
	unsigned attributes;		/* attributes of the file */
	char string_len;		/* returned length of ascii name str. */
					/* length does not include null byte */
	char file_name[12];		/* name string */
	};


/***	FileStatus - structure of information list used by DosQFileInfo */

struct FileStatus {
	unsigned create_date;		/* date of file creation */
	unsigned create_time;		/* time of file creation */
	unsigned access_date;		/* date of last access */
	unsigned access_time;		/* time of last access */
	unsigned write_date;		/* date of last write */
	unsigned write_time;		/* time of last write */
	unsigned long file_size;	/* file size (end of data) */
	unsigned long falloc_size;	/* file allocated size */
	unsigned block_size;		/* blocking factor */
	unsigned attributes;		/* attributes of the file */
	};


/***	FSAllocate - structure of file system allocation */

struct FSAllocate {
	unsigned long filsys_id;	/* file system ID */
	unsigned long sec_per_unit;	/* number sectors per allocation unit */
	unsigned long num_units;	/* number of allocation units */
	unsigned long avail_units;	/* avaliable allocation units */
	unsigned bytes_sec;		/* bytes per sector */
	};



/***	KbdStatus - structure in which the keyboard support will information */

struct KbdStatus {
	unsigned length;		/* length in words of data structure */
	unsigned bit_mask;		/* bit mask */
	unsigned turn_around_char;	/* turnaround character */
	unsigned interim_char_flags;	/* interim character flags */
	unsigned shift_state;		/* shift state */
	};



/***	KeyData - structure that contains character data */

struct KeyData {
	char char_code;			/* ASCII character code */
	char scan_code;			/* scan code */
	char status;			/* indicates state of the character */
	unsigned shift_state;		/* state of the shift keys */
	unsigned long time;		/* time stamp of the keystroke */
	};



/***	ModeData - structure that contains characteristics of the mode */

struct ModeData {
	unsigned length;		/* Length of structure */
	char type;			/* Text or graphics */
	char color;			/* Color or monochrome */
	unsigned col;			/* Column resolution */
	unsigned row;			/* Row resolution */
	unsigned hres;			/* horizontal resolution */
	unsigned vres;			/* vertical resolution */
	};




/***	ProcIDsArea - structure of the address of the area where the
 *	ID's will be placed
 */

struct ProcIDsArea {
	unsigned procid_cpid;		/* current process' process ID */
	unsigned procid_ctid;		/* current process' thread ID */
	unsigned procid_ppid;		/* process ID of the parent */
	};



/***	PVBData - structure that contains information about the
 *	physical video buffer
 */

struct PVBData {
	unsigned pvb_size;		/* size of the structure */
	unsigned long pvb_ptr;		/* returns pointer to the pvb buffer */
	unsigned pvb_length;		/* length of PVB */
	unsigned pvb_rows;		/* buffer dimension (rows) */
	unsigned pvb_cols;		/* buffer dimension (cols) */
	char pvb_type;			/* color or mono */
	};



/***	SchedParmsArea - structure of address in which the scheduler
 *	parms will be placed
 */

struct SchedParmsArea {
	char dynvar_flag;		/* dynamic variation flag, 1=enabled */
	char maxwait;			/* maxwait (sec) */
	unsigned mintime;		/* minimum timeslice (ms) */
	unsigned maxtime;		/* maximum timeslice (ms) */
	};



/***	Tasking Processes:
 *
 *		DosCreateThread
 *		DosCwait
 *		DosEnterCritSec
 *		DosExecPgm
 *		DosExit
 *		DosExitCritSec
 *		DosExitList
 *		DosGetPID
 *		DosGetPrty
 *		DosGetSchedParms
 *		DosSetFgnd
 *		DosSetPrty
 *		DosKillProcess
 */



/***	DosCreateThread - Create another thread of execution
 *
 *	Creates an asynchronous thread of execution under the
 *	current process
 */

extern unsigned far pascal DOSCREATETHREAD (
	void (far *)(void),		/* Starting Address for new thread */
	unsigned far *,			/* Address to put new thread ID */
	unsigned char far * );		/* Address of stack for new thread */



/***	DosCwait - Wait for child termination
 *
 *	Places the current thread in a wait state until a child process
 *	has terminated, then returns the ending process' process ID and
 *	termination code.
 */

extern unsigned far pascal DOSCWAIT (
	unsigned,			/* Action (execution) codes */
	unsigned,			/* Wait options */
	unsigned far *,			/* Address to put result code */
	unsigned far *,			/* Address to put process ID */
	unsigned );			/* ProcessID of process to wait for */



/***	DosEnterCritSec - Enter critical section of execution
 *
 *	Disables thread switching for the current process
 */

extern void far pascal DOSENTERCRITSEC (void);



/***	DosExecPgm - Execute a program
 *
 *	Allows a program to request another program be executed as a
 *	child process.	The requestor's process may optionally continue
 *	to execute asynchronous to the new program
 */

extern unsigned far pascal DOSEXECPGM (
	unsigned,			/* 0=synchronous, 1=asynchronous with */
					/* return code discarded, 2=async */
					/* with return code saved */
	unsigned,			/* Trace process */
	char far *,			/* Address of argument string */
	char far *,			/* Address of environment string */
	unsigned far *, 		/* Address to put Process ID */
	char far * );			/* Address of program filename */



/***	DosExit - Exit a program
 *
 *	This call is issued when a thread completes its execution.
 *	The current thread is ended.
 */

extern void far pascal DOSEXIT (
	unsigned,			/* 0=end current thread, 1=end all */
	unsigned );			/* Result Code to save for DosCwait */



/***	DosExitCritSec - Exit critical section of execution
 *
 *	Re-enables thread switching for the current process
 */

extern void far pascal DOSEXITCRITSEC (void);



/***	DosExitList - Routine list for process termination
 *
 *	Maintains a list of routines which are to be executed when the
 *	current process ends, normally or otherwise
 */

extern unsigned far pascal DOSEXITLIST (
	unsigned,			/* Function request code */
	void (far *)(void) );		/* Address of routine to be executed */



/***	DosGetPID - Return process ID
 *
 *	Returns the current process's process ID (PID), thread ID,
 *	and the PID of the process that spawned it
 */

extern void far pascal DOSGETPID (
	struct ProcIDsArea far *);	/* ProcID structure */



/***	DosGetPrty - Get Process's Priority
 *
 *	Allows the caller to learn the priority of a process or thread
 */

extern unsigned far pascal DOSGETPRTY (
	unsigned,			/* Indicate thread or process ID */
	unsigned far *,			/* Address to put priority */
	unsigned );			/* PID of process/thread of interest */



/***	DosGetSchedParms - Get scheduler's parameters
 *
 *	Gets the scheduler's current configuration parameters
 */

extern void far pascal DOSGETSCHEDPARMS (
	struct SchedParmsArea far * );	/* Address to put parameters */



/***	DosSetFgnd - Set Foreground Process
 *
 *	Allows the session manager to designate which process
 *	is to receive favored dispatching
 */

extern unsigned far pascal DOSSETFGND (
	unsigned );			/* Process ID of target process */



/***	DosSetPrty - Set Process Priority
 *
 *	Allows the caller to change the base priority or priority
 *	class of a child process or a thread in the current process
 */

extern unsigned far pascal DOSSETPRTY (
	unsigned,			/* Indicate scope of change */
	unsigned,			/* Priority class to set */
	unsigned,			/* Priority delta to apply */
	unsigned );			/* Process or Thread ID of target */



/***	DosKillProcess - Terminate a Process
 *
 *	Terminates a child process and returns its termination code
 *	to its parent (if any)
 */

extern unsigned far pascal DOSKILLPROCESS (
	unsigned,			/* 0=kill child processes also, */
					/* 1=kill only indicated process */
	unsigned );			/* Process ID of process to end */




/***	Asynchronous Notification (Signals):
 *
 *		DosHoldSignal
 *		DosSendSignal
 *		DosSetSigHandler
 */



/***	DosHoldSignal - Disable / Enable signals
 *
 *	Used to termporarily disable or enable signal processing
 *	for the current process.
 */

extern void far pascal DOSHOLDSIGNAL (
	unsigned );			/* 0=enable signal, 1=disable signal */



/***	DosSendSignal - Issue signal
 *
 *	Used to send a signal event to an arbitrary process or
 *	command subtree.
 */

extern unsigned far pascal DOSSENDSIGNAL (
	unsigned,			/* Process ID to signal */
	unsigned,			/* 0=notify entire subtree, 1=notify */
					/* only the indicated process */
	unsigned,			/* Signal argument */
	unsigned );			/* Signal number */



/***	DosSetSigHandler - Handle Signal
 *
 *	Notifies CP/DOS of a handler for a signal.  It may also be used
 *	to ignore a signal or install a default action for a signal.
 */

extern unsigned far pascal DOSSETSIGHANDLER (
	void (far *)(),			/* Signal handler address */
	unsigned long far *,		/* Address of previous handler */
	unsigned far *,			/* Address of previous action */
	unsigned,			/* Indicate request type */
	unsigned );			/* Signal number */




/***	Pipes:
 *
 *		DosMakePipe
 */



/***	DosMakePipe - Create a Pipe */

extern unsigned far pascal DOSMAKEPIPE (
	unsigned far *,			/* Addr to place the read handle */
	unsigned far *,			/* Addr to place the write handle */
	unsigned );			/* Size to reserve for the pipe */




/***	Queues:
 *
 *		DosCloseQueue
 *		DosCreateQueue
 *		DosOpenQueue
 *		DosPeekQueue
 *		DosPurgeQueue
 *		DosQueryQueue
 *		DosReadQueue
 *		DosWriteQueue
 */

/***	DosCloseQueue - Close a Queue
 *
 *	close a queue which is in use by the requesting process
 *
 */

extern unsigned far pascal DOSCLOSEQUEUE (
	unsigned ) ;			/* queue handle */


/***	DosCreateQueue - Create a Queue
 *
 *	creates a queue to be owned by the requesting process
 *
 */

extern unsigned far pascal DOSCREATEQUEUE (
	unsigned far *,			/* queue handle */
	unsigned,			/* queue priority */
	char far * ) ;			/* queue name */


/***	DosOpenQueue - Open a Queue
 *
 *	opens a queue for the current process
 *
 */

extern unsigned far pascal DOSOPENQUEUE (
	unsigned far *,			/* PID of queue owner */
	unsigned far *,			/* queue handle */
	char far * ) ;			/* queue name */



/***	DosPeekQueue - Peek at a Queue
 *
 *	retrieves an element from a queue without removing it from the queue
 *
 */

extern unsigned far pascal DOSPEEKQUEUE (
	unsigned,			/* queue handle */
	unsigned long far *,		/* pointer to request */
	unsigned far *,			/* length of datum returned */
	unsigned long far *,		/* pointer to address of datum */
	unsigned far *,			/* indicator of datum returned */
	unsigned char,			/* wait indicator for empty queue */
	unsigned char far *,		/* priority of element */
	unsigned long ) ;		/* semaphore handle */



/***	DosPurgeQueue - Purge a Queue
 *
 *	purges all elements from a queue
 *
 */

extern unsigned far pascal DOSPURGEQUEUE (
	unsigned ) ;			/* queue handle */



/***	DosQueryQueue - Query size of a Queue
 *
 *	returns the number of elements in a queue
 *
 */

extern unsigned far pascal DOSQUERYQUEUE (
	unsigned,			/* queue handle */
	unsigned far * );		/* pointer for number of elements */



/***	DosReadQueue - Read from a Queue
 *
 *	retrieves an element from a queue
 *
 */

extern unsigned far pascal DOSREADQUEUE (
	unsigned,			/* queue handle */
	unsigned long far *,		/* pointer to request */
	unsigned far *,			/* length of datum returned */
	unsigned long far *,		/* pointer to address of datum */
	unsigned,			/* indicator of datum returned */
	unsigned char,			/* wait indicator for empty queue */
	unsigned char far *,		/* priority of element */
	unsigned long ) ;		/* semaphore handle */



/***	DosWriteQueue - Write to a Queue
 *
 *	adds an element to a queue
 *
 */

extern unsigned far pascal DOSWRITEQUEUE (
	unsigned,			/* queue handle */
	unsigned,			/* request */
	unsigned,			/* length of datum */
	unsigned char far *,		/* address of datum */
	unsigned char );		/* priority of element */





/***	Semaphores:
 *
 *		DosSemClear
 *		DosSemRequest
 *		DosSemSet
 *		DosSemWait
 *		DosSemSetWait
 *		DosMuxSemWait
 *		DosCloseSem
 *		DosCreatSem
 *		DosOpenSem
 */



/***	DosSemClear - Unconditionally clears a semaphore
 *
 *	Unconditionally clears a semaphore; i.e., sets the
 *	state of the specified semaphore to unowned.
 */

extern unsigned far pascal DOSSEMCLEAR (
	unsigned long );		/* semaphore handle */



/***	DosSemRequest - Wait until next DosSemClear
 *
 *	Blocks the current thread until the next DosSemClear is
 *	issued to the indicated semaphore
 */

extern unsigned far pascal DOSSEMREQUEST (
	unsigned long,			/* semaphore handle */
	unsigned long );		/* Timeout, -1=no timeout, */
					/* 0=immediate timeout, >1=number ms */


/***	DosSemSet - Unconditionally take a semaphore
 *
 *	Unconditionally takes a semaphore; i.e., sets the status
 *	of the specified semaphore to owned.
 */

extern unsigned far pascal DOSSEMSET (
	unsigned long );		/* semaphore handle */



/***	DosSemSetWait - Wait for a semaphore to be cleared and set it
 *
 *	Blocks the current thread until the indicated semaphore is
 *	cleared and then establishes ownership of the semaphore
 */

extern unsigned far pascal DOSSEMSETWAIT (
	unsigned long,			/* semaphore handle */
	unsigned long );		/* Timeout, -1=no timeout, */
					/* 0=immediate timeout, >1=number ms */


/***	DosSemWait - Wait for a semaphore to be cleared
 *
 *	Blocks the current thread until the indicated semaphore is
 *	cleared but does not establish ownership of the semaphore
 */

extern unsigned far pascal DOSSEMWAIT (
	unsigned long,			/* semaphore handle */
	unsigned long );		/* Timeout, -1=no timeout, */
					/* 0=immediate timeout, >1=number ms */


/***	DosMuxSemWait - Wait for 1 of N semaphores to be cleared
 *
 *	Blocks the current thread until the indicated semaphore is
 *	cleared but does not establish ownership of the semaphore
 */

extern unsigned far pascal DOSMUXSEMWAIT (
	unsigned far *,			/* address for event index number */
	unsigned far *,			/* list of semaphores */
	unsigned long );		/* Timeout, -1=no timeout, */
					/* 0=immediate timeout, >1=number ms */



/***	DosCloseSem - Close a system semaphore
 *
 *	closed the specified system semaphore
 */

extern unsigned far pascal DOSCLOSESEM (
	unsigned long );		/* semaphore handle */



/***	DosCreateSem - Create a system semaphore
 *
 *	create a system semaphore
 */

extern unsigned far pascal DOSCREATESEM (
	unsigned,			/* =0 indicates exclusive ownership */
	unsigned long far *,		/* address for semaphore handle */
	char far * );			/* name of semaphore */


/***	DosOpenSem - Open a system semaphore
 *
 *	open a system semaphore
 */

extern unsigned far pascal DOSOPENSEM (
	unsigned long far *,		/* address for semaphore handle */
	char far * );			/* name of semaphore */




/***	Timer Services:
 *
 *		DosSleep
 *		DosGetTimerInt
 *		DosTimerAsync
 *		DosTimerStart
 *		DosTimerStop
 */



/***	DosSetDateTime - Set the current date and time
 *
 *	Used to set the date and time that are maintained by the
 *	operating system
 */

extern unsigned far pascal DOSSETDATETIME (
	struct DateTime far * );



/***	DosSleep - Delay Process Execution
 *
 *	Suspends the current thread for a specified interval of time,
 *	or if the requested interval is '0', simply gives up the
 *	remainder of the current time slice.
 */

extern unsigned far pascal DOSSLEEP (
	unsigned long );		/* TimeInterval - interval size */



/***	DosGetTimerInt - Get the timer tick interval in 1/10000 sec.
 *
 *	Gets a word that contains the timer tick interval in ten
 *	thousandths of a second.  This is the amount of time that
 *	elapses with every timer tick
 */

extern unsigned far pascal DOSGETTIMERINT (
	unsigned far * );		/* interval size */



/***	DosTimerAsync - Start an asynchronous time delay
 *
 *	Starts a timer that runs asynchronously to the thread issuing
 *	the request.  It sets a RAM semaphore which can be used by the
 *	wait facility
 */

extern unsigned far pascal DOSTIMERASYNC (
	unsigned long,			/* Interval size */
	unsigned long,			/* handle of semaphore */
	unsigned far * );		/* handle of timer */



/***	DosTimerStart - Start a Periodic Interval Timer
 *
 *	Starts a periodic interval timer that runs asynchronously to
 *	the thread issuing the request.  It sets a RAM semaphore which
 *	can be used by the wait facility.  The semaphore is continually
 *	signalled at the specified time interval until the timer is
 *	turned off by DosTimerStop
 */

extern unsigned far pascal DOSTIMERSTART (
	unsigned long,			/* Interval size */
	unsigned long,			/* handle of semaphore */
	unsigned far * );		/* handle of timer */



/***	DosTimerStop - Stop an interval timer
 *
 *	Stops an interval timer that was started by DosTimerStart
 */

extern unsigned far pascal DOSTIMERSTOP (
	unsigned );			/* Handle of the timer */




/***	Memory Management:
 *
 *		DosAllocSeg
 *		DosAllocShrSeg
 *		DosGetShrSeg
 *		DosReallocSeg
 *		DosAllocHuge
 *		DosGetHugeShift
 *		DosReallocHuge
 *		DosCreateCSAlias
 */



/***	DosAllocSeg - Allocate Segment
 *
 *	Allocates a segment of memory to the requesting process.
 */

extern unsigned far pascal DOSALLOCSEG (
	unsigned,			/* Number of bytes requested */
	unsigned far *,			/* Selector allocated (returned) */
	unsigned );			/* Indicator for sharing */



/***	DosAllocShrSeg - Allocate Shared Segment
 *
 *	Allocates a shared memory segment to a process.
 */

extern unsigned far pascal DOSALLOCSHRSEG (
	unsigned,			/* Number of bytes requested */
	char far *,			/* Name string */
	unsigned far * );		/* Selector allocated (returned) */



/***	DosGetShrSeg - Access Shared Segment
 *
 *	Allows a process to access a shared memory segment previously
 *	allocated by another process.  The reference count for the
 *	shared segment is incremented.
 */

extern unsigned far pascal DOSGETSHRSEG (
	char far *,			/* Name string */
	unsigned far * );		/* Selector (returned) */



/***	DosGiveSeg - Give access to Segment
 *
 *	Gives another process access to a shares memory segment
 */

extern unsigned far pascal DOSGIVESEG (
	unsigned,			/* Caller's segment handle */
	unsigned,			/* Process ID of recipient */
	unsigned far * );		/* Recipient's segment handle */



/***	DosReallocSeg - Change Segment Size
 *
 *	Changes the size of a segment already allocated.
 */

extern unsigned far pascal DOSREALLOCSEG (
	unsigned,			/* New size requested in bytes */
	unsigned );			/* Selector */



/***	DosAllocHuge - Allocate Huge Memory
 *
 *	Allocates memory greater than the maximum segment size
 */

extern unsigned far pascal DOSALLOCHUGE (
	unsigned,			/* Number of 65536 byte segments */
	unsigned,			/* Number of bytes in last segment */
	unsigned far *,			/* Selector allocated (returned) */
	unsigned );			/* Max number of 65536-byte segments */



/***	DosGetHugeShift - Get shift count used with Huge Segments
 *
 *	Returns the shift count used in deriving selectors
 *	to address memory allocated by DosAllocHuge.
 */

extern unsigned far pascal DOSGETHUGESHIFT (
	unsigned far *);		/* Shift Count (returned) */



/***	DosReallocHuge - Change Huge Memory Size
 *
 *	Changes the size of memory originally allocated by DosAllocHuge
 */

extern unsigned far pascal DOSREALLOCHUGE (
	unsigned,			/* Number of 65536 byte segments */
	unsigned,			/* Number of bytes in last segment */
	unsigned );			/* Selector */



/***	DosCreateCSAlias - Create CS Alias
 *
 *	Creates an alias descriptor for a data type descriptor passed
 *	as input.  The type of the new descriptor is executable.
 */

extern unsigned far pascal DOSCREATECSALIAS (
	unsigned,			/* Data segment selector */
	unsigned far * );		/* Code segment selector (returned) */




/***	Memory Sub-Allocation Package (MSP)
 *
 *		DosSubAlloc
 *		DosSubFree
 *		DosSubSet
 */



/***	DosSubAlloc - Allocate Memory
 *
 *	Allocates memory from a segment previously allocated by
 *	DosAllocSeg or DosAllocShrSeg and initialized by DosSubSet
 */

extern unsigned far pascal DOSSUBALLOC (
	unsigned,			/* Segment selector */
	unsigned far *,			/* Address of block offset */
	unsigned );			/* Size of requested block */



/***	DosSubFree - Free Memory
 *
 *	Frees memory previously allocated by DosSubAlloc
 */

extern unsigned far pascal DOSSUBFREE (
	unsigned,			/* Segment selector */
	unsigned,			/* Offset of memory block to free */
	unsigned );			/* Size of block in bytes */



/***	DosSubSet - Initialize or Set Allocated Memory
 *
 *	Can be used either to initialize a segment for sub-allocation
 *	of to notify MSP of a change in the size of a segment already
 *	initialized.
 */

extern unsigned far pascal DOSSUBSET (
	unsigned,			/* Segment selector */
	unsigned,			/* Parameter flags */
	unsigned );			/* New size of the block */




/***	Program Execution Control:
 *
 *		DosLoadModule
 *		DosFreeModule
 *		DosGetProcAddr
 *		DosGetModHandle
 *		DosGetModName
 */



/***	DosLoadModule - Load Dynamic Link Routines
 *
 *	Loads a dynamic link module and returns a handle for the module
 */

extern unsigned far pascal DOSLOADMODULE (
	char far *,			/* Module name string */
	unsigned far * );		/* Module handle (returned) */



/***	DosFreeModule - Free Dynamic Link Routines
 *
 *	Frees the reference to the dynamic link module for this process.
 *	If the dynamic link module is no longer used by any process, the
 *	module will be freed from system memory.
 */

extern unsigned far pascal DOSFREEMODULE (
	unsigned );			/* Module handle */



/***	DosGetProcAddr - Get Dynamic Link Procedure Address
 *
 *	Retruns a far address to the desired procedure within a dynamic
 *	link module.
 */

extern unsigned far pascal DOSGETPROCADDR (
	unsigned,			/* Module handle */
	char far *,			/* Module name string */
	unsigned long far * );		/* Procedure address (returned) */



/***	DosGetModHandle - Get Dynamic Link Module Handle
 *
 *	Returns the handle to a dynamic link module that was previously
 *	loaded.  The interface provides a mechanism for testing whether
 *	a dynamic link module is already loaded.
 */

extern unsigned far pascal DOSGETMODHANDLE (
	char far *,			/* Module name string */
	unsigned far *);		/* Module handle (returned) */



/***	DosGetModName - Get Dynamic Link Module Name
 *
 *	returns the fully qualified drive, path, filename, and
 *	extension associated with the referenced modul handle
 */

extern unsigned far pascal DOSGETMODNAME (
	unsigned,			/* Module handle */
	unsigned,			/* Maximum buffer length */
	unsigned far * );		/* Buffer (returned) */




/***	Device I/O Services:
 *
 *		DosBeep
 *		DosDevConfig
 *		DosScrDirectIO
 *		DosScrRedrawWait
 *		DosScrLock
 *		DosScrUnLock
 *		DosSGInit
 *		DosSGNum
 *		DosSGRestore
 *		DosSGSave
 *		DosSGSwitch
 *		DosSGSwitchMe
 *		DosVioAttach
 *		DosVioRegister
 *		KbdCharIn
 *		KbdFlushBuffer
 *		KbdGetStatus
 *		KbdPeek
 *		KbdSetStatus
 *		KbdStringIn
 *		VioRegister
 *		VioFreePhysBuf
 *		VioGetBuf
 *		VioGetCurPos
 *		VioGetCurType
 *		VioGetMode
 *		VioGetPhysBuf
 *		VioReadCellStr
 *		VioReadCharStr
 *		VioScrollDn
 *		VioScrollUp
 *		VioScrollLf
 *		VioScrollRt
 *		VioSetCurPos
 *		VioSetCurType
 *		VioSetMode
 *		VioShowBuf
 *		VioWrtCellStr
 *		VioWrtCharStr
 *		VioWrtCharStrAtt
 *		VioWrtNAttr
 *		VioWrtNCell
 *		VioWrtNChar
 *		VioWrtTTY
 *		VioSetANSI
 *		VioGetANSI
 *		VioPrtScreen
 *		VioSaveRedrawWait
 *		VioSaveRedrawWaitUndo
 *		VioScrLock
 *		VioScrUnlock
 *		VioSetMnLockTime
 *		VioSetMXSaveTime
 *		VioGetTimes
 *		VioPopUp
 *		VioEndPopUp
 */



/***	DosBeep - Generate Sound From Speaker */

extern unsigned far pascal DOSBEEP (
	unsigned,			/* Hertz (25H-7FFFH) */
	unsigned );			/* Length of sound  in ms */



/***	DosDevConfig - Get Device Configurations
 *
 *	Get information about attached devices
 */

extern unsigned far pascal DOSDEVCONFIG (
	unsigned char far *,		/* Returned information */
	unsigned,			/* Item number */
	unsigned );			/* Reserved */



/***	DosScrDirectIO - Direct Screen I/O
 *
 *	Indicate direct screen I/O
 */

extern unsigned far pascal DOSSCRDIRECTIO (
	unsigned );			/* Indicates state of direct I/O */
					/* 0=on, 1=off */



/***	DosScrRedrawWait - Screen Refresh
 *
 *	Wait for notification to refresh or redraw screen
 */

extern unsigned far pascal DOSSCRREDRAWWAIT (void);



/***	DosScrLock - Lock Screen
 *
 *	Lock the screen for I/O
 */

extern unsigned far pascal DOSSCRLOCK (
	unsigned,			/* Block or not - 0=return if */
					/* screen unavailable, 1=wait */
	unsigned far *);		/* Return status of lock - */
					/* 0=sucessful, 1=unsuccessful */



/***	DosScrUnLock - Unlock Screen
 *
 *	Unlock the screen for I/O
 */

extern unsigned far pascal DOSSCRUNLOCK (void) ;



/***	DosSGInit - Initialize Screen Group
 *
 *	Initialize the specified screen group
 */

extern unsigned far pascal DOSSGINIT (
	unsigned );			/* Number of screen group */



/***	DosSGNum - Get Number of Screen Groups
 *
 *	Get the number of screen groups
 */

extern unsigned far pascal DOSSGNUM (
	unsigned far *);		/* Total number of screen groups */



/***	DosSGRestore - Restore Screen Group
 *
 *	Restore the current screen group
 */

extern unsigned far pascal DOSSGRESTORE (void);



/***	DosSGSave - Save Screen Group
 *
 *	Save the current screen group
 */

extern unsigned far pascal DOSSGSAVE (void);



/***	DosSGSwitch - Switch Screen Groups
 *
 *	Switch the specified screen group to the active screen group
 */

extern unsigned far pascal DOSSGSWITCH (
	unsigned );			/* Number of screen group */



/***	DosSGSwitchMe - Put Process in Screen Group
 *
 *	Switch the caller into the specified screen group
 */

extern unsigned far pascal DOSSGSWITCHME (
	unsigned );			/* Number of screen groups */



/***	DosVioAttach - Attach to Video Subsystem
 *
 *	Attach to the current video subsystem for the current screen
 *	group.	This must be done prior to using any VIO functions.
 */

extern unsigned far pascal DOSVIOATTACH (void);



/***	DosVioRegister - Register Video Subsystem
 *
 *	Register a video subsystem for a screen group
 */

extern unsigned far pascal DOSVIOREGISTER (
	char far *,			/* Module name */
	char far * );			/* Table of entries supported by */
					/* the VIO dynamic link module */



/***	KbdCharIn - Read Character, Scan Code
 *
 *	Return a character and scan code from the standard input device
 */

extern unsigned far pascal KBDCHARIN (
	struct KeyData far *,		/* Buffer for character code */
	unsigned,			/* I/O wait - 0=wait for a */
					/* character, 1=no wait */
	unsigned );			/* keyboard handle */



/***	KbdFlushBuffer - Flush Keystroke Buffer
 *
 *	Clear the keystroke buffer
 */

extern unsigned far pascal KBDFLUSHBUFFER (
	unsigned );			/* keyboard handle */



/***	KbdGetStatus - Get Keyboard Status
 *
 *	Gets the current state of the keyboard.
 */

extern unsigned far pascal KBDGETSTATUS (
	struct KbdStatus far *,		/* data structure */
	unsigned );			/* Keyboard device handle */



/***	KbdPeek - Peek at Character, Scan Code
 *
 *	Return the character/scan code, if available, from the
 *	standard input device without removing it from the buffer.
 */

extern unsigned far pascal KBDPEEK (
	struct KeyData far *,		/* buffer for data */
	unsigned );			/* keyboard handle */



/***	KbdSetStatus - Set Keyboard Status
 *
 *	Sets the characteristics of the keyboard.
 */

extern unsigned far pascal KBDSETSTATUS (
	struct KbdStatus far *,		/* data structure */
	unsigned );			/* device handle */



/***	KbdStringIn - Read Character String
 *
 *	Read a character string (character codes only) from the
 *	standard input device.	The character string may optionally
 *	be echoed at the standard output device if the echo mode
 *	is set (KbdSetEchoMode)
 */

extern unsigned far pascal KBDSTRINGIN (
	char far *,			/* Char string buffer */
	unsigned far *,			/* Length of buffer */
	unsigned,			/* I/O wait- 0=wait for a */
					/* character, 1=no wait */
	unsigned );			/* keyboard handle */



/***	VioRegister - Register Video Subsystem
 *
 *	Register a video subsystem within a screen group
 *
 */

extern unsigned far pascal VIOREGISTER (
	char far *,			/* Module name */
	char far *,			/* Entry Point name */
	unsigned long,			/* Function mask 1 */
	unsigned long );		/* Function mask 2 */



/***	VioFreePhysBuf - Free Physical Video Buffer
 *
 *	Release the physical video buffer
 */

extern unsigned far pascal VIOFREEPHYSBUF (
	char far * );			/* Physical video buffer */



/***	VioGetBuf - Get Logical Video Buffer
 *
 *	Return the address of the logical video buffer
 */

extern unsigned far pascal VIOGETBUF (
	unsigned long far *,		/* Will point to logical video buffer */
	unsigned far *,			/* Length of Buffer */
	unsigned );			/* Vio Handle */



/***	VioGetCurPos - Get Cursor Position
 *
 *	Return the cursor position
 */

extern unsigned far pascal VIOGETCURPOS (
	unsigned far *,			/* Current row position */
	unsigned far *,			/* Current column position */
	unsigned );			/* Vio Handle */



/***	VioGetCurType - Get Cursor Type
 *
 *	Return the cursor type
 */

extern unsigned far pascal VIOGETCURTYPE (
	struct CursorData far *,	/* Cursor characteristics */
	unsigned );			/* Vio Handle */



/***	VioGetMode - Get Display Mode
 *
 *	Return the mode of the display
 */

extern unsigned far pascal VIOGETMODE (
	struct ModeData far *,		/* Length of Buffer */
	unsigned );			/* Vio Handle */



/***	VioGetPhysBuf - Get Physical Video Buffer
 *
 *	Return the address of the physical video buffer
 */

extern unsigned far pascal VIOGETPHYSBUF (
	char far *,			/* Buffer start address */
	char far *,			/* Buffer end address */
	unsigned far *,			/* Address of selector list */
	unsigned );			/* Length of selector list */



/***	VioReadCellStr - Read Character/Attributes String
 *
 *	Read a string of character/attributes (or cells) from the
 *	screen starting at the specified location.
 */

extern unsigned far pascal VIOREADCELLSTR (
	char far *,			/* Character Buffer */
	unsigned far *,			/* Length of cell string buffer */
	unsigned,			/* Starting location (row) */
	unsigned,			/* Starting location (col) */
	unsigned );			/* Vio Handle */



/***	VioReadCharStr - Read Character String
 *
 *	Read a character string from the display starting at the
 *	current cursor position
 */

extern unsigned far pascal VIOREADCHARSTR (
	char far *,			/* Character Buffer */
	unsigned far *,			/* Length of cell string buffer */
	unsigned,			/* Starting location (row) */
	unsigned,			/* Starting location (col) */
	unsigned );			/* Vio Handle */



/***	VioScrollDn - Scroll Screen Down
 *
 *	Scroll the current screen down
 */

extern unsigned far pascal VIOSCROLLDN (
	unsigned,			/* Top row of section to scroll */
	unsigned,			/* Left column of section to scroll */
	unsigned,			/* Bottom row of section to scroll */
	unsigned,			/* Right column of section to scroll */
	unsigned,			/* Number of blank lines at bottom */
	char far *,			/* pointer to blank Char,Attr */
	unsigned );			/* Vio Handle */



/***	VioScrollUp - Scroll Screen Up
 *
 *	Scroll the active page (or display) up
 */

extern unsigned far pascal VIOSCROLLUP (
	unsigned,			/* Top row of section to scroll */
	unsigned,			/* Left column of section to scroll */
	unsigned,			/* Bottom row of section to scroll */
	unsigned,			/* Right column of section to scroll */
	unsigned,			/* Number of blank lines at bottom */
	char far *,			/* pointer to blank Char,Attr */
	unsigned );			/* Vio Handle */



/***	VioScrollLf - Scroll Screen Left
 *
 *	Scroll the current screen left
 */

extern unsigned far pascal VIOSCROLLLF (
	unsigned,			/* Top row of section to scroll */
	unsigned,			/* Left column of section to scroll */
	unsigned,			/* Bottom row of section to scroll */
	unsigned,			/* Right column of section to scroll */
	unsigned,			/* Number of blank columsn at right */
	char far *,			/* pointer to blank Char,Attr */
	unsigned );			/* Vio Handle */



/***	VioScrollLf - Scroll Screen Right
 *
 *	Scroll the current screen right
 */

extern unsigned far pascal VIOSCROLLRT (
	unsigned,			/* Top row of section to scroll */
	unsigned,			/* Left column of section to scroll */
	unsigned,			/* Bottom row of section to scroll */
	unsigned,			/* Right column of section to scroll */
	unsigned,			/* Number of blank columsn at left */
	char far *,			/* pointer to blank Char,Attr */
	unsigned );			/* Vio Handle */



/***	VioSetCurPos - Set Cursor Position
 *
 *	Set the cursor position
 */

extern unsigned far pascal VIOSETCURPOS (
	unsigned,			/* Row return data */
	unsigned,			/* Column return data */
	unsigned );			/* Vio Handle */



/***	VioSetCurType - Set Cursor Type
 *
 *	Set the cursor type
 */

extern unsigned far pascal VIOSETCURTYPE (
	struct CursorData far *,	/* Cursor characteristics */
	unsigned );			/* Vio Handle */



/***	VioSetMode - Set Display Mode
 *
 *	Set the mode of the display
 */

extern unsigned far pascal VIOSETMODE (
	struct ModeData far *,		/* Mode characteristics */
	unsigned );			/* Vio Handle */



/***	VioShowBuf - Display Logical Buffer
 *
 *	Update the display with the logical video buffer
 */

extern unsigned far pascal VIOSHOWBUF (
	unsigned,			/* Offset into buffer */
	unsigned,			/* Length of area to be updated */
	unsigned );			/* Vio Handle */



/***	VioWrtCellStr - Write Character/Attribute String
 *
 *	Write a character,attribute string to the display
 */

extern unsigned far pascal VIOWRTCELLSTR (
	char far *,			/* String to be written */
	unsigned,			/* Length of string */
	unsigned,			/* Starting position for output (row) */
	unsigned,			/* Starting position for output (col) */
	unsigned );			/* Vio Handle */



/***	VioWrtCharStr - Write Character String
 *
 *	Write a character string to the display
 */

extern unsigned far pascal VIOWRTCHARSTR (
	char far *,			/* String to be written */
	unsigned,			/* Length of string */
	unsigned,			/* Starting position for output (row) */
	unsigned,			/* Starting position for output (col) */
	unsigned );			/* Vio Handle */



/***	VioWrtCharStrAtt - Write Character String With Attribute
 *
 *	Write a character string with repeated attribute to the display
 */

extern unsigned far pascal VIOWRTCHARSTRATT (
	char far *,			/* String to be written */
	unsigned,			/* Length of string */
	unsigned,			/* Starting position for output (row) */
	unsigned,			/* Starting position for output (col) */
	char far *,			/* Attribute to be replicated */
	unsigned );			/* Vio Handle */



/***	VioWrtNAttr - Write N Attributes
 *
 *	Write an attribute to the display a specified number of times
 */

extern unsigned far pascal VIOWRTNATTR (
	char far *,			/* Attribute to be written */
	unsigned,			/* Length of write */
	unsigned,			/* Starting position for output (row) */
	unsigned,			/* Starting position for output (col) */
	unsigned );			/* Vio Handle */



/***	VioWrtNCell - Write N Character/Attributes
 *
 *	Write a cell (or character/attribute) to the display a
 *	specified number of times
 */

extern unsigned far pascal VIOWRTNCELL (
	char far *,			/* Cell to be written */
	unsigned,			/* Length of write */
	unsigned,			/* Starting position for output (row) */
	unsigned,			/* Starting position for output (col) */
	unsigned );			/* Vio Handle */



/***	VioWrtNChar - Write N Characters
 *
 *	Write a character to the display a specified number of times
 */

extern unsigned far pascal VIOWRTNCHAR (
	unsigned,			/* Character to be written */
	unsigned,			/* Length of write */
	unsigned,			/* Starting position for output (row) */
	unsigned,			/* Starting position for output (col) */
	unsigned );			/* Vio Handle */



/***	VioWrtTTY - Write TTY String
 *
 *	Write a character string from the current cursor position in
 *	TTY mode to the display.  The cursor will be positioned at the
 *	end of the string+1 at the end of the write.
 */

extern unsigned far pascal VIOWRTTTY (
	char far *,			/* String to be written */
	unsigned,			/* Length of string */
	unsigned );			/* Vio Handle */



/***	VioSetAnsi - Set ANSI On or Off
 *
 *	Activates or deactivates ANSI support
 *
 */

extern unsigned far pascal VIOSETANSI (
	unsigned,			/* ON (=1) or OFF (=0) indicator */
	unsigned );			/* Vio Handle */



/***	VioGetAnsi - Get ANSI State
 *
 *	Returns the current ANSI state (0=inactive, 1=active)
 *
 */

extern unsigned far pascal VIOGETANSI (
	unsigned far *,			/* ANSI state (returned) */
	unsigned );			/* Vio Handle */



/***	VioPrtScreen - Print Screen
 *
 *	Copies the screen to the printer
 *
 */

extern unsigned far pascal VIOPRTSCREEN (
	unsigned );			/* Vio Handle */



/***	VioSaveRedrWait - Screen Save Redraw Wait
 *
 *	Allows a process to be notified when it must
 *	save or redraw its screen
 *
 */

extern unsigned far pascal VIOSAVEREDRAWWAIT (
	unsigned,			/* Save/Redraw Indicator */
	unsigned far *,			/* Notify type (returned) */
	unsigned );			/* Vio Handle */



/***	VioSaveRedrWaitUndo - Undo Screen Save Redraw Wait
 *
 *	Allows a one thread within a process to cancel a
 *	VIOSAVREDRAWWAIT issued by another thread within
 *	that same process.  Ownership of the VIOSAVREDRAWWAIT
 *	can either be reserved or given up.
 *
 */

extern unsigned far pascal VIOSAVEREDRAWWAITUNDO (
	unsigned,			/* Ownership Indicator */
	unsigned,			/* Terminate Indicator */
	unsigned );			/* Vio Handle */



/***	VioScrLock -  Lock Screen
 *
 *	Tells a process if I/O to the physical screen buffer can occur.
 *
 */

extern unsigned far pascal VIOSCRLOCK (
	unsigned,			/* Wait Flag */
	unsigned char far *,		/* Status of lock (returned) */
	unsigned );			/* Vio Handle */



/***	VioScrUnlock -	Unlock Screen
 *
 *	Unlocks the physical screen buffer for I/O.
 *
 */

extern unsigned far pascal VIOSCRUNLOCK (
	unsigned );			/* Vio Handle */



/***	VioSetMnLockTime - Set Minimum Screen Lock Time
 *
 *	Sets the minimum amount of time that the system will allow a
 *	process to have exclusive use of the screen via VIOSCRLOCK.
 *
 */

extern unsigned far pascal VIOSETMNLOCKTIME (
	unsigned,			/* Number of seconds */
	unsigned );			/* Vio Handle */



/***	VioSetMxSaveTime - Set Maximum Screen Save/Restore Time
 *
 *	Sets the maximum amount of time (in msec) that the system will
 *	allow a process to take before issuing a VIOSAVREDRWAIT call
 *	after being notified by the Session Mgr that one is needed.
 *
 */

extern unsigned far pascal VIOSETMXSAVETIME (
	unsigned,			/* Number of milliseconds */
	unsigned );			/* Vio Handle */



/***	VioGetTimes - Return VIO Lock and Save/Redraw Times
 *
 *	Returns the 2 word values set by the calls
 *	VIOSETMNLOCKTIME and VIOSETMXSAVETIME.
 *
 */

extern unsigned far pascal VIOGETTIMES (
	unsigned far *,			/* Min. Lock time (in seconds) */
	unsigned far *,			/* Max. Save time (in msec) */
	unsigned );			/* Vio Handle */



/***	VioPopUp - Allocate a PopUp Display Screen
 *
 *	Creates a temporary window to display a momentary message
 *
 */

extern unsigned far pascal VIOPOPUP (
	unsigned far *,			/* Wait/Nowait Bit flags */
	unsigned );			/* Vio Handle */



/***	VioEndPopUp - Deallocate a PopUp Display Screen
 *
 *	Closes a PopUp window
 *
 */

extern unsigned far pascal VIOENDPOPUP (
	unsigned );			/* Vio Handle */




/***	Mouse Services
 *
 *	MouRegister
 *	MouGetNumButtons
 *	MouGetNumMickeys
 *	MouGetDevStatus
 *	MouReadEventQueue
 *	MouGetNumQueEl
 *	MouGetEventMask
 *	MouGetScaleFact
 *	MouSetScaleFact
 *	MouSetEventMask
 *	MouOpen
 *	MouClose
 *	MouSetPtrShape
 *	MouRemovePtr
 *	MouDrawPtr
 *	MouSetHotKey
 */


/***	MouRegister - Register a Mouse Subsystem or Environment Manager
 *
 */

extern unsigned far pascal MOUREGISTER (
	char far *,			/* Module name */
	char far *,			/* Entry Point name */
	unsigned long,			/* Function mask */
	unsigned );			/* Mouse Device Handle */



/***	MouGetNumButtons - returns the number of mouse buttons supported
 *
 */

extern unsigned far pascal MOUGETNUMBUTTONS (
	unsigned far *,			/* Number of mouse buttons (returned) */
	unsigned );			/* Mouse Device Handle */



/***	MouGetNumMickeys - returns the number of mickeys per centimeter
 *
 */

extern unsigned far pascal MOUGETNUMMICKEYS (
	unsigned far *,			/* Number of Mickeys/cm (returned) */
	unsigned );			/* Mouse Device Handle */



/***	MouGetDevStatus - returns the mouse driver status flags
 *
 */

extern unsigned far pascal MOUGETDEVSTATUS (
	unsigned far *,			/* Device Status (returned) */
	unsigned );			/* Mouse Device Handle */



/***	MouReadEventQueue - reads an event from the mouse event queue
 *
 */

extern unsigned far pascal MOUREADEVENTQUEUE (
	unsigned,			/* Type of read operation */
	unsigned char far *,		/* Event Queue Entry (returned) */
	unsigned );			/* Mouse Device Handle */



/***	MouGetNumQueEl - returns the status of the Mouse Event Queue
 *
 */

extern unsigned far pascal MOUGETNUMQUEEL (
	unsigned far *,			/* Maximum # of Elements in Queue */
	unsigned far *,			/* Current # of Elements in Queue */
	unsigned );			/* Mouse Device Handle */



/***	MouGetEventMask - Returns the current mouse 1-word event mask
 *
 */

extern unsigned far pascal MOUGETEVENTMASK (
	unsigned far *,			/* Event Mask (returned) */
	unsigned );			/* Mouse Device Handle */



/***	MouGetScaleFact - Returns the current mouse scaling factors
 *
 */

extern unsigned far pascal MOUGETSCALEFACT (
	unsigned far *,			/* Y Coordinate Scaling Factor */
	unsigned far *,			/* X Coordinate Scaling Factor */
	unsigned );			/* Mouse Device Handle */



/***	MouSetScaleFact - Sets the current mouse scaling factors
 *
 */

extern unsigned far pascal MOUSETSCALEFACT (
	unsigned,			/* Y Coordinate Scaling Factor */
	unsigned,			/* X Coordinate Scaling Factor */
	unsigned );			/* Mouse Device Handle */



/***	MouSetEventMask - Set the current mouse 1-word event mask
 *
 */

extern unsigned far pascal MOUSETEVENTMASK (
	unsigned,			/* Event Mask */
	unsigned );			/* Mouse Device Handle */



/***	MouOpen - Open the mouse device
 *
 */

extern unsigned far pascal MOUOPEN (
	unsigned far * );		/* Mouse Device Handle (returned) */



/***	MouClose - Close the mouse device
 *
 */

extern unsigned far pascal MOUCLOSE (
	unsigned );			/* Mouse Device Handle */



/***	MouSetPtrShape - Set the shape and size of the mouse pointer image
 *
 */

extern unsigned far pascal MOUSETPTRSHAPE (
	unsigned char far *,		/* Pointer Shape (returned) */
	unsigned long,			/* Size of data passed */
	unsigned,			/* Height of Ptr Shape */
	unsigned,			/* Width of Ptr Shape */
	unsigned,			/* Offset to Ptr Column Center */
	unsigned,			/* Offset to Ptr Row Center */
	unsigned );			/* Mouse Device Handle */



/***	MouRemovePtr - Restricts the Mouse Ptr from occurring in a region
 *
 */

extern unsigned far pascal MOUREMOVEPTR (
	unsigned far *,			/* Pointer Area */
	unsigned );			/* Mouse Device Handle */



/***	MouDrawPtr - Unrestricts the Mouse Ptr
 *
 */

extern unsigned far pascal MOUDRAWPTR (
	unsigned );			/* Mouse Device Handle */


/***	MouSetHotKey - Determines which Mouse Key is the system hot key
 *
 */

extern unsigned far pascal MOUSETHOTKEY (
	unsigned,			/* Mouse Button Mask */
	unsigned );			/* Mouse Device Handle */




/***	Device Monitor Services
 *
 *		DosMonOpen
 *		DosMonClose
 *		DosMonReg
 *		DosMonRead
 *		DosMonWrite
 */



/***	DosMonOpen - Open a Connection to a CP/DOS Device Monitor
 *
 *	This call is issued once by a process which wishes to use
 *	device monitors
 */

extern unsigned far pascal DOSMONOPEN (
	char far *,			/* Ascii string of device name */
	unsigned far * );		/* Address for handle return value */



/***	DosMonClose - Close a Connection to a CP/DOS Device Monitor
 *
 *	This call is issued once by a process which wishes to terminate
 *	monitoring.  This call causes all monitor buffers associated to
 *	be flushed and closed.
 */

extern unsigned far pascal DOSMONCLOSE (
	unsigned );			/* Handle from DosMonOpen */



/***	DosMonReg - Register a Set of Buffers as a Monitor
 *
 *	This call is issued to establish a pair of buffer structures -
 *	one input and one output - to monitor an I/O stream
 */

extern unsigned far pascal DOSMONREG (
	unsigned,			/* Handle from DosMonOpen */
	unsigned char far *,		/* Address of monitor input buffer */
	unsigned char far *,		/* Address of monitor output buffer */
	unsigned,			/* Position flag - 0=no positional */
					/* preference, 1=front of list, */
					/* 2=back of the list */
	unsigned );			/* Index */



/***	DosMonRead - Read Input From Monitor Structure
 *
 *	This call is issued to wait for and read input records from
 *	the monitor buffer structure
 */

extern unsigned far pascal DOSMONREAD (
	unsigned char far *,		/* Address of monitor input buffer */
	unsigned char,			/* Block/Run indicator - 0=block */
					/* input ready, 1=return */
	unsigned char far *,		/* Address of data buffer */
	unsigned far * );		/* Number of bytes in the data record */



/***	DosMonWrite - Write Output to Monitor Structure
 *
 *	Writes data to the monitor output buffer structure
 */

extern unsigned far pascal DOSMONWRITE (
	unsigned char far *,		/* Address of monitor output buffer */
	unsigned char far *,		/* Address of data buffer */
	unsigned );			/* Number of bytes in data record */




/***	File I/O Services:
 *
 *		DosBufReset
 *		DosChdir
 *		DosChgFilePtr
 *		DosClose
 *		DosCreateUn
 *		DosDelete
 *		DosDupHandle
 *		DosFindClose
 *		DosFindFirst
 *		DosFindNext
 *		DosFileLocks
 *		DosGetInfoSeg
 *		DosMkdir
 *		DosMove
 *		DosNewSize
 *		DosOpen
 *		DosQCurDir
 *		DosQCurDisk
 *		DosQFHandState
 *		DosQFileInfo
 *		DosQFileMode
 *		DosQFSInfo
 *		DosQHandType
 *		DosQSwitChar
 *		DosQVerify
 *		DosRead
 *		DosReadAsync
 *		DosRmdir
 *		DosSelectDisk
 *		DosSetFileInfo
 *		DosSetFileMode
 *		DosSetFHandState
 *		DosSetFSInfo
 *		DosSetMaxFH
 *		DosSetVerify
 *		DosWrite
 *		DosWriteAsync
 */



/***	DosBufReset - Commit File's Cache Buffers
 *
 *	Flushes requesting process's cache buffers for the specified
 *	format
 */

extern unsigned far pascal DOSBUFRESET (
	unsigned );			/* File handle */



/***	DosChdir - Change The Current Directory
 *
 *	Define the current directory for the requesting process
 */

extern unsigned far pascal DOSCHDIR (
	char far *,			/* Directory path name */
	unsigned long );		/* Reserved (must be 0) */



/***	DosChgFilePtr - Change (Move) File Read Write Pointer
 *
 *	Move the read/write pointer according to the method specified
 */

extern unsigned far pascal DOSCHGFILEPTR (
	unsigned,			/* File handle */
	long,				/* Distance to move in bytes */
	unsigned,			/* Method of moving (0,1,2) */
	unsigned long far * );		/* New pointer location */



/***	DosClose - Close a File Handle
 *
 *	Closes the specified file handle
 */

extern unsigned far pascal DOSCLOSE (
	unsigned );			/* File handle */



/***	DosCreateUn - Create a Unique File Path Name
 *
 *	Generates a unique file path name
 */

extern unsigned far pascal DOSCREATEUN (
	char far * );			/* File path name area */



/***	DosDelete - Delete a File
 *
 *	Removes a directory entry associated with a filename
 */

extern unsigned far pascal DOSDELETE (
	char far *,			/* Filename path */
	unsigned long );		/* Reserved (must be 0) */



/***	DosDupHandle - Duplicate a File Handle
 *
 *	Returns a new file handle for an open file that refers to the
 *	same file at the same position
 */

extern unsigned far pascal DOSDUPHANDLE (
	unsigned,			/* Existing file handle */
	unsigned far * );		/* New file handle */



/***	DosFindClose - Close Find Handle
 *
 *	Closes the association between a directory handle and a
 *	DosFindFirst or DosFindNext directory search function
 */

extern unsigned far pascal DOSFINDCLOSE (
	unsigned );			/* Directory search handle */



/***	DosFindFirst - Find First Matching File
 *
 *	Finds the first filename that matches the specified file
 *	specification
 */

extern unsigned far pascal DOSFINDFIRST (
	char far *,			/* File path name */
	unsigned far *,			/* Directory search handle */
	unsigned,			/* Search attribute */
	struct FileFindBuf far *,	/* Result buffer */
	unsigned,			/* Result buffer length */
	unsigned far *, 		/* Number of entries to find */
	unsigned long );		/* Reserved (must be 0) */



/***	DosFindNext - Find Next Matching File
 *
 *	Finds the next directory entry matching the name that was
 *	specified on the previous DosFindFirst or DosFindNext function
 *	call
 */

extern unsigned far pascal DOSFINDNEXT (
	unsigned,			/* Directory handle */
	struct FileFindBuf far *,	/* Result buffer */
	unsigned,			/* Result buffer length */
	unsigned far * );		/* Number of entries to find */



/***	DosFileLocks - File Lock Manager
 *
 *	Unlock and/or lock multiple ranges in an opened file
 */

extern unsigned far pascal DOSFILELOCKS (
	unsigned,			/* File handle */
	long far *,			/* Unlock Range */
	long far * );			/* Lock Range */



/***	DosGetInfoSeg - Get addresses of system variable segments
 *
 *	Returns 2 selectors: one for the global information segment,
 *	the other for a process information segment
 */

extern unsigned far pascal DOSGETINFOSEG (
	unsigned far *,			/* Selector for Global Info Seg */
	unsigned far * );		/* Selector for Process Info Seg */



/***	DosMkdir - Make Subdirectory
 *
 *	Creates the specified directory
 */

extern unsigned far pascal DOSMKDIR (
	char far *,			/* New directory name */
	unsigned long );		/* Reserved (must be 0) */



/***	DosMove - Move a file or SubDirectory
 *
 *	Moves the specified file or directory
 */

extern unsigned far pascal DOSMOVE (
	char far *,			/* Old path name */
	char far *,			/* New path name */
	unsigned long );		/* Reserved (must be 0) */



/***	DosNewSize - Change File's Size
 *
 *	Changes a file's size
 */

extern unsigned far pascal DOSNEWSIZE (
	unsigned,			/* File handle */
	unsigned long );		/* File's new size */



/***	DosOpen - Open a File
 *
 *	Creates the specified file (if necessary) and opens it
 */

extern unsigned far pascal DOSOPEN (
	char far *,			/* File path name */
	unsigned far *,			/* New file's handle */
	unsigned far *,			/* Action taken - 1=file existed, */
					/* 2=file was created */
	unsigned long,			/* File primary allocation */
	unsigned,			/* File attributes */
	unsigned,			/* Open function type */
	unsigned,			/* Open mode of the file */
	unsigned long );		/* Reserved (must be zero) */



/***	DosQCurDir - Query Current Directory
 *
 *	Get the full path name of the current directory for the
 *	requesting process for the specified drive
 */

extern unsigned far pascal DOSQCURDIR (
	unsigned,			/* Drive number - 1=A, etc */
	char far *,			/* Directory path buffer */
	unsigned far * );		/* Directory path buffer length */



/***	DosQCurDisk - Query Current Disk
 *
 *	Determine the current default drive for the requesting process
 */

extern unsigned far pascal DOSQCURDISK (
	unsigned far *,			/* Default drive number */
	unsigned long far * );		/* Drive-map area */




/***	DosQFHandState - Query file handle state
 *
 *	Query the state of the specified handle
 */

extern unsigned far pascal DOSQFHANDSTATE (
	unsigned,			/* File Handle */
	unsigned far * );		/* File handle state */



/***	DosQFileInfo - Query a File's Information
 *
 *	Returns information for a specific file
 */

extern unsigned far pascal DOSQFILEINFO (
	unsigned,			/* File handle */
	unsigned,			/* File data required */
	char far *,			/* File data buffer */
	unsigned );			/* File data buffer size */


/***	DosQFileMode - Query File Mode
 *
 *	Get the mode (attribute) of the specified file
 */

extern unsigned far pascal DOSQFILEMODE (
	char far *,			/* File path name */
	unsigned far *,			/* Data area */
	unsigned long );		/* Reserved (must be zero) */



/***	DosQFSInfo - Query File System Information
 *
 *	Gets information from a file system device
 */

extern unsigned far pascal DOSQFSINFO (
	unsigned,			/* Drive number - 0=default, 1=A, etc */
	unsigned,			/* File system info required */
	char far *,			/* File system info buffer */
	unsigned );			/* File system info buffer size */



/***	DosQHandType - Query Handle type
 *
 *	Returns a flag as to whether a handle references a device or
 *	a file, and if a device, returns device driver attribute word
 */

extern unsigned far pascal DOSQHANDTYPE (
	unsigned,			/* File Handle */
	unsigned far *,			/* Handle Type (0=file, 1=device) */
	unsigned far * );		/* Device Driver Attribute Word */



/***	DosQSwitChar - Query Switch Character
 *
 *	Returns the system switch character
 */

extern unsigned far pascal DOSQSWITCHAR (
	unsigned char far * );		/* Switch Character (returned) */



/***	DosQVerify - Query Verify Setting
 *
 *	Returns the value of the Verify flag
 */

extern unsigned far pascal DOSQVERIFY (
	unsigned far * );		/* Verify setting - 0=verify mode */
					/* not active, 1=verify mode active */



/***	DosRead - Read from a File
 *
 *	Reads the specified number of bytes from a file to a
 *	buffer location
 */

extern unsigned far pascal DOSREAD (
	unsigned,			/* File handle */
	char far *,			/* Address of user buffer */
	unsigned,			/* Buffer length */
	unsigned far * );		/* Bytes read */



/***	DosReadAsync - Async Read from a File
 *
 *	Reads the specified number of bytes from a file to a buffer
 *	location asynchronously with respect to the requesting process's
 *	execution
 */

extern unsigned far pascal DOSREADASYNC (
	unsigned,			/* File handle */
	unsigned long far *,		/* Address of Ram semaphore */
	unsigned far *,			/* Address of I/O error return code */
	char far *,			/* Address of user buffer */
	unsigned,			/* Buffer length */
	unsigned far * );		/* Number of bytes actually read */



/***	DosRmDir - Remove Subdirectory
 *
 *	Removes a subdirectory from the specified disk
 */

extern unsigned far pascal DOSRMDIR (
	char far *,			/* Directory name */
	unsigned long );		/* Reserved (must be zero) */



/***	DosSelectDisk - Select Default Drive
 *
 *	Select the drive specified as the default drive for the
 *	calling process
 */

extern unsigned far pascal DOSSELECTDISK (
	unsigned );			/* Default drive number */



/***	DosSetFHandState - Set File Handle State
 *
 *	Get the state of the specified file
 */

extern unsigned far pascal DOSSETFHANDSTATE (
	unsigned,			/* File handle */
	unsigned);			/* File handle state */


/***	DosSetFSInfo - Set File System Information
 *
 *	Set information for a file system device
 */

extern unsigned far pascal DOSSETFSINFO (
	unsigned,			/* Drive number - 0=default, 1=A, etc */
	unsigned,			/* File system info required */
	char far *,			/* File system info buffer */
	unsigned );			/* File system info buffer size */



/***	DosSetFileInfo - Set a File's Information
 *
 *	Specifies information for a file
 */

extern unsigned far pascal DOSSETFILEINFO (
	unsigned,			/* File handle */
	unsigned,			/* File info data required */
	char far *,			/* File info buffer */
	unsigned );			/* File info buffer size */



/***	DosSetFileMode - Set File Mode
 *
 *	Change the mode (attribute) of the specified file
 */

extern unsigned far pascal DOSSETFILEMODE (
	char far *,			/* File path name */
	unsigned,			/* New attribute of file */
	unsigned long );		/* Reserved (must be zero) */



/***	DosSetMaxFH - Set Maximum File Handles
 *
 *	Defines the maximum number of file handles for the
 *	current process
 */

extern unsigned far pascal DOSSETMAXFH (
	unsigned );			/* Number of file handles */



/***	DosSetVerify - Set/Reset Verify Switch
 *
 *	Sets the verify switch
 */

extern unsigned far pascal DOSSETVERIFY (
	unsigned );			/* New value of verify switch */



/***	DosWrite - Synchronous Write to a File
 *
 *	Transfers the specified number of bytes from a buffer to
 *	the specified file, synchronously with respect to the
 *	requesting process's execution
 */

extern unsigned far pascal DOSWRITE (
	unsigned,			/* File handle */
	char far *,			/* Address of user buffer */
	unsigned,			/* Buffer length */
	unsigned far * );		/* Bytes written */



/***	DosWriteAsync - Asynchronous Write to a File
 *
 *	Transfers the specified number of bytes from a buffer to
 *	the specified file, asynchronously with respect to the
 *	requesting process's execution
 */

extern unsigned far pascal DOSWRITEASYNC (
	unsigned,			/* File handle */
	unsigned long far *,		/* Address of RAM semaphore */
	unsigned far *,			/* Address of I/O error return code */
	char far *,			/* Address of user buffer */
	unsigned,			/* Buffer length */
	unsigned far * );		/* Bytes written */




/***	Hard Error Handling
 *
 *		DosError
 */



/***	DosError - Enable Hard Error Processing
 *
 *	Allows a CP/DOS process to receive hard error notification
 *	without generating a hard error signal.  Hard errors generated
 *	under a process which has issued a DosError call are FAILed and
 *	the appropriate error code is returned.
 */

extern unsigned far pascal DOSERROR (
	unsigned );			/* Action flag */



/***	Machine Exception Handling
 *
 *		DosSetVector
 */



/***	DosSetVec - Establish a handler for an Exception
 *
 *	Allows a process to register an address to be
 *	called when a 286 processor exception occurs.
 */

extern unsigned far pascal DOSSETVEC (
	unsigned,			/* Exception Vector */
	void (far *)(void),		/* Address of exception handler */
	void (far * far *)(void) );	/* Address to store previous handler */



/***	Message Functions
 *
 *		DosGetMessage
 *		DosInsMessage
 *		DosPutMessage
 */



/***	DosGetMessage - Return System Message With Variable Text
 *
 *	Retrieves a message from the specified system message file
 *	and inserts variable information into the body of the message
 */

extern unsigned far pascal DOSGETMESSAGE (
	char far * far *,		/* Table of variables to insert */
	unsigned,			/* Number of variables */
	char far *,			/* Address of message buffer */
	unsigned,			/* Length of buffer */
	unsigned,			/* Number of the message */
	char far *,			/* Message file name */
	unsigned far * );		/* Length of returned message */



/***	DosInsMessage - Insert Variable Text into Message
 *
 *	Inserts variable text string information into the body ofa message.
 */

extern unsigned far pascal DOSINSMESSAGE (
	char far * far *,		/* Table of variables to insert */
	unsigned,			/* Number of variables */
	char far *,			/* Address of output buffer */
	unsigned,			/* Length of output buffer */
	unsigned,			/* Length of message */
	char far *,			/* Address of input string */
	unsigned far * );		/* Length of returned message */



/***	DosPutMessage - Output Message Text to Indicated Handle
 *
 *	Outputs a message in a buffer passed by a caller to the
 *	specified handle.  The function formats the buffer to
 *	prevent words from wrapping if displayed to a screen.
 */

extern unsigned far pascal DOSPUTMESSAGE (
	unsigned,			/* Handle of output file/device */
	unsigned,			/* Length of message buffer */
	char far * );			/* Message buffer */



/***	RAS Services
 *
 *		DosSysTrace
 */



/***	DosSysTrace - Add a Trace record to the System Trace Buffer
 *
 *	Allows a subsystem or system extension to add information to the
 *	System trace buffer.  This call can only be made from protected
 *	mode.
 */

extern unsigned far pascal DOSSYSTRACE (
	unsigned,			/* Major trace event code (0-255) */
	unsigned,			/* Length of area to be recorded */
	unsigned,			/* Minor trace event code (0-FFFFH) */
	char far * );			/* Pointer to area to be traced */



/***	Program Startup Conventions
 *
 *		DosGetEnv
 *		DosGetVersion
 */



/***	DosGetEnv - Get the Address of Process' Environment String
 *
 *	Return the address of the current process' environment string
 */

extern unsigned far pascal DOSGETENV (
	unsigned far *,			/* Address to place segment handle */
	unsigned far * );		/* Address for command line start */



/***	DosGetVersion - Get DOS Version
 *
 *	Returns the DOS version number
 */

extern unsigned far pascal DOSGETVERSION (
	unsigned far * );		/* Address to put version number */



/***	World Trade Support
 *
 *	All of these functions declarations have the string NLS in a comment.
 *	This is required in the generation of the Imports Library DOSCALLS.LIB
 *
 *		DosGetCtryInfo
 *		DosSetCtryCode
 *		DosGetDBCSEv
 *		DosCaseMap
 *		DosGetSpecChar
 *		DosCollate
 */



/***	DosGetCtryInfo
 *
 *	Returns the country dependant formatting information that
 *	resides in the NLSCDIT.SYS World Trade Support file
 */

extern unsigned far pascal DOSGETCTRYINFO (			/*<NLS>*/
	unsigned,			/* Length of data area provided */
	unsigned long far *,		/* Country code */
	char far *, 			/* Memory buffer */
	unsigned far * );		/* Length of returned data */



/***	DosSetCrtyCode
 *
 *	Sets the current country code for the system
 */

extern unsigned far pascal DOSSETCTRYCODE (			/*<NLS>*/
	unsigned long far * );		/* Country code */



/***	DosGetDBCSEv - Get the DBCS Environment Vector
 *
 *	Used to obtain the DBCS environmental vector that resides in
 *	the NLSDBCS.SYS World Trade Support file.
 */

extern unsigned far pascal DOSGETDBCSEV (			/*<NLS>*/
	unsigned,			/* Length of data area provided */
	unsigned long far *,		/* Country code */
	char far * );			/* Pointer to data area */



/***	DosCaseMap
 *
 *	Used to perform case mapping on a string of binary values which
 *	represent ASCII characters.
 */

extern unsigned far pascal DOSCASEMAP (				/*<NLS>*/
	unsigned,			/* Length of string to case map */
	unsigned long far *,		/* Country code */
	char far * );			/* Address of string of binary values */



/***	DosGetSpecChar
 *
 *	Gets a list of special characters that are valid in file names, etc.
 *	The list corresponds to the byte values 128-255.
 */

extern unsigned far pascal DOSGETSPECCHAR (			/*<NLS>*/
	unsigned,			/* Length of data area provided */
	unsigned long far *,		/* Country Code */
	unsigned char far * );		/* Data area */



/***	DosCollate
 *
 *	Undocumented NLS feature
 */

extern unsigned far pascal DOSCOLLATE (				/*<NLS>*/
	unsigned,			/* Buffer Length */
	unsigned long far *,		/* Country Code */
	char far * );			/* Buffer Address */



/* End of File */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\display.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */


#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "stdio.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "doscall.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */
#include "ctype.h"                                                      /* AN000 */

/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DISPLAY                                    */
/*                                                             */
/* DESCRIPTIVE NAME: Display full screen interface messages    */
/*                                                             */
/* FUNCTION: Displays messages and handles control characters  */
/*                                                             */
/* NOTES:                                                      */
/*  FDISK MESSAGES                                             */
/* Portions of the screen that are handled in the msg are      */
/* indicated on the listing of the screen with the message     */
/* name given.  If the text message is defined in another      */
/* screen, then the name is followed by a "#" character        */
/*                                                             */
/* NOTE TO TRANSLATORS The characters inside the <> and the [] */
/* are control characters and should not be translated.  The   */
/* Control characters are defined as follows:                  */
/*                                                             */
/* <H> - Highlight the following text                          */
/* <R> - Regular text                                          */
/* <B> - Blink the following text                              */
/* <O> - Turn blinking off                                     */
/* <Y> - Print YES character, as set by define                 */
/* <N> - Print NO character, as set by define                  */
/* <W> - Sound the beep                                        */
/* <S> - Save cursor position for later use                    */
/* <I> - Insert character from insert[] string. This string    */
/*       must be set up prior to displaying the message. The   */
/*       first <I> will insert Insert[0], the second           */
/*       insert[1], etc....This will move the cursor one       */
/*       postition. The insert[] string will be initialized    */
/*                                                             */
/* Multiple control characters can be between the <>.          */
/*                                                             */
/* The ^####^indicates Row and column for the text and has the */
/* format of [rrcc] where the numbers are decimal and zero     */
/* based (first row/col is 00.  The numbers are in decimal,    */
/* and must be 2 characters, which means rows/cols 0-9 should  */
/* be listed as 00-09.  For example, the 5th row, 3rd column   */
/* on the screen would be listed as ^0402^.                    */
/*                                                             */
/* The column number is always the column desired.  The row    */
/* number is an offset from the previous row.  For example, if */
/* the text just printed is on row 6, and the next text should */
/* be printed 2 rows down in column 0, then the control strin  */
/* would be ^0201^.  The first row specified in the message is */
/* assumed to be based off of row 0, it would actually specify */
/* the actual row for the start of the msg to be printed.      */
/*                                                             */
/* ENTRY POINTS: display(*message_name);                       */
/*      LINKAGE: Near call                                     */
/*                                                             */
/* INPUT: char *message_name                                   */
/*                                                             */
/* EXIT-NORMAL:                                                */
/*                                                             */
/* EXIT-ERROR:                                                 */
/*                                                             */
/* EFFECTS:                                                    */
/* input_row changed if <S> control character in message       */
/* input_col changed if <S> control character in message       */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/* viowrtcharstratt();                                         */
/******************** END OF SPECIFICATIONS ********************/
/*  */
void display(s)

char far *s;

BEGIN
        unsigned      row;
        unsigned      col;
        char          attribute;
        char far      *attribute_ptr = &attribute;
        unsigned      insert_count;


        /* Initialize row and col, and index into array */
        row = u(0);                                                     /* AC000 */
        col = u(0);                                                     /* AC000 */
        insert_count = u(0);                                            /* AC000 */
        /* check for a request to display a null string */
        if (*s == c('\0'))                                              /* AC000 */
           BEGIN
            /* Message string error */
            insert[0] = c('1');                                         /* AC000 */
            display(debug_msg);
           END
        else
           BEGIN
            /* There is data there, lets go handle it */

			  if (status_flag == TRUE )
				 	attribute = video_attribute;
			  else
           	   attribute = c(0x00);                                        /* AC000 */

            /* Go until end of string */
            while (*s != c('\0'))                                       /* AC000 */
               BEGIN

                /* Check for any imbedded control strings */
                switch (*s)
                   BEGIN
                    /* Check for control characters */
                    case '<':
                              BEGIN
                               s++;
                               while ( (*s != c('>')) && (*s != c('\0')) ) /* AC000 */
                                  BEGIN
                                   switch (*s++)
                                      BEGIN
                                       case 'H':	 if (status_flag == FALSE)
																	{				
																 	if (mono_flag == TRUE)                                 /* AN006 */
                                                      	attribute = (attribute & 0x80) | HIWHITE_ON_BLACK; /* AN006 */
                                                  	else                                                   /* AN006 */
                                                      	attribute = (attribute & 0x80) | HIWHITE_ON_BLUE;  /* AC006 */
																	}
																 else
																	attribute = (attribute & 0x80) | video_attribute;
																 break;


                                       case 'R':	 if (status_flag == FALSE)
																	{				
																 	if (mono_flag == TRUE)                                  /* AN006 */
                                                      	attribute = (attribute & 0x80) | GRAY_ON_BLACK;     /* AN006 */
                                                  	else                                                    /* AN006 */
                                                      	attribute = (attribute & 0x80) | WHITE_ON_BLUE;     /* AC006 */
																	}
																 else
																	attribute = (attribute & 0x80) | video_attribute;
																 break;

                                       case 'B': attribute |= 0x80;
                                                 break;

                                       case 'O': attribute &= 0x7F;
                                                 break;

                                       case 'W': DOSBEEP(u(900),u(400)); /* AC000 */
                                                 break;

                                       case 'I': if (status_flag == TRUE)
																	attribute = video_attribute;
																else
                                                 	BEGIN
                                                   	/* display next element in the array */
                                                  	if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
                                                      	attribute = c(GRAY_ON_BLACK);                       /* AN006 */
                                                  	if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
                                                      	attribute = c(WHITE_ON_BLUE);                       /* AC006 */
																	END
                                                  VIOWRTCHARSTRATT(pinsert+insert_count++,u(1),row,col++,attribute_ptr,u(0));
                                                  break;


                                       case 'Y':                                                          /* AC011 */
                                                 BEGIN
                                                  /* display YES character in next location */
                                                  if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
                                                      attribute = c(GRAY_ON_BLACK);                       /* AN006 */
                                                  if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
                                                      attribute = c(WHITE_ON_BLUE);                       /* AC006 */
                                                  VIOWRTCHARSTRATT(&Yes,u(1),row,col++,attribute_ptr,u(0));  /* AC000 */
                                                  break;
                                                 END

                                       case 'N':                                                          /* AC011 */
                                                 BEGIN
                                                  /* display NO character in next location */
                                                  if ((mono_flag == TRUE) && (attribute == c(0x00)))      /* AN006 */
                                                      attribute = c(GRAY_ON_BLACK);                       /* AN006 */
                                                  if ((mono_flag == FALSE) && (attribute == c(0x00)))     /* AN006 */
                                                      attribute = c(WHITE_ON_BLUE);                       /* AC006 */
                                                  VIOWRTCHARSTRATT(&No,u(1),row,col++,attribute_ptr,u(0));  /* AC000 */
                                                  break;
                                                 END


                                       case 'S':
                                                 BEGIN
                                                  input_row = row;
                                                  input_col = col;
                                                  break;
                                                 END


                                       case 'C':
                                                 BEGIN
                                                  /* Clear from current position to end of line */
                                                  clear_screen(row,col,row,u(79));                         /* AC000 */
                                                  break;
                                                 END

                                       case '\0':
                                                 BEGIN
                                                  /* Message string error - string ended in the middle of control string*/
                                                  insert[0] = c('7');   /* AC000 */
                                                  display(debug_msg);
                                                  break;
                                                 END

                                       default:
                                                 BEGIN
                                                  /* Message string error - no valid control char found */
                                                  insert[0] = c('6');   /* AC000 */
                                                  display(debug_msg);
                                                  break;
                                                 END
                                      END /* Switch */
                                  END /* While */
                               /* Get the pointer past the '>' */
                               s++;
                               break;
                              END /* control characters */

                    /* Check for row,col */
                    case '':                                           /* AC000 */
                              BEGIN
                               s++;
                               /* determine the row to put the message on */
                               if ( !isdigit(*s) )
                                  BEGIN
                                   /* Message string error */
                                   insert[0] = c('2');                  /* AC000 */
                                   display(debug_msg);
                                  END
                               else
                                  BEGIN
                                   row = row+((unsigned)(((*s++ - '0')*10)));
                                   if ( !isdigit(*s) )
                                     BEGIN
                                      /* Message string error */
                                      insert[0] = c('2');               /* AC000 */
                                      display(debug_msg);
                                     END
                                   else
                                      BEGIN
                                       row = row+((unsigned)(*s++ - '0'));
                                       /* determine the col to put the message on */
                                       if ( !isdigit(*s) )
                                          BEGIN
                                           /* Message string error */
                                           insert[0] = c('3');          /* AC000 */
                                           display(debug_msg);
                                          END
                                       else
                                          BEGIN
                                           col = ((unsigned)(*s++ - '0'));
                                           if ( !isdigit(*s) )
                                              BEGIN
                                               /* Message string error */
                                               insert[0] = c('3');      /* AC000 */
                                               display(debug_msg);
                                              END
                                           else
                                              BEGIN
                                               col = ((unsigned)((col* 10) + (*s++ - '0')));
                                               if (*s++ != c(''))      /* AC000 */
                                                  BEGIN
                                                   /* Message string error */
                                                   insert[0] = c('4');  /* AC000 */
                                                   display(debug_msg);
                                                  END /* 2nd sq bracket */
                                              END /* 2nd digit col */
                                          END /* 1st digit col */
                                      END /* 2nd digit row */
                                  END /* 1st digit row */
                               break;
                              END
                    /* Handle anything else */


                    default:
                            BEGIN
                             /* See if attribute set to anything */
                             if ((mono_flag == FALSE) && (attribute == c(0x00)))                                  /* AN006 */
                                 attribute = c(WHITE_ON_BLUE);                        /* AC006 */
                             if ((mono_flag == TRUE) && (attribute == c(0x00)))                                  /* AN006 */
                                 attribute = c(GRAY_ON_BLACK);                        /* AN006 */
#ifdef	    DBCS				    /* MSKK01 07/18/89 */
                             VIOWRTCHARSTRATT(s,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
			     if (IsDBCSLeadByte( (unsigned char)*s ))
				 VIOWRTCHARSTRATT(++s,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
			     s++;
#else
                             VIOWRTCHARSTRATT(s++,u(1),row,col++,attribute_ptr,u(0)); /* AC000 */
#endif
                             break;
                            END
                   END
               END /* End of string check */
           END /* No characters in string check */
        return;

END

/*  */

void number_in_msg(number,start)

XFLOAT      number;
unsigned    start;

BEGIN

char    mbytes[32];

        /* Divide the space down and get it into decimal */
        sprintf(mbytes,"%4.0d",number);
        insert[start+0] = mbytes[0];
        insert[start+1] = mbytes[1];
        insert[start+2] = mbytes[2];
        insert[start+3] = mbytes[3];

        return;

END


/*  */
void percent_in_msg(number,start)                                       /* AN000 */

unsigned    number;                                                     /* AN000 */
unsigned    start;                                                      /* AN000 */

BEGIN                                                                   /* AN000 */


char    percent[32];

        /* Divide the space down and get it into decimal */
        sprintf(percent,"%3.0d%%",number);                              /* AC000 */
        insert[start+0] = percent[0];                                   /* AC000 */
        insert[start+1] = percent[1];                                   /* AC000 */
        insert[start+2] = percent[2];                                   /* AC000 */
        insert[start+3] = percent[3];                                   /* AC000 */

        return;

END                                                                     /* AN000 */

/*  */
void string_in_msg(string_ptr,start)                                    /* AN000 */

char far    *string_ptr;                                                /* AN000 */
unsigned    start;                                                      /* AN000 */

BEGIN                                                                   /* AN000 */

unsigned     i;                                                         /* AN000 */

        /* init the 8 spots to blanks */
        for (i = u(0); i < u(8);i++)                                    /* AN000 */
            BEGIN                                                       /* AN000 */
             insert[start+i] = c(' ');                                  /* AN000 */
            END                                                         /* AN000 */
        /* Put characters into the array */
           BEGIN                                                        /* AN000 */
            insert[start+0] = *(string_ptr+0);                          /* AN000 */
            insert[start+1] = *(string_ptr+1);                          /* AN000 */
            insert[start+2] = *(string_ptr+2);                          /* AN000 */
            insert[start+3] = *(string_ptr+3);                          /* AN000 */
            insert[start+4] = *(string_ptr+4);                          /* AN000 */
            insert[start+5] = *(string_ptr+5);                          /* AN000 */
            insert[start+6] = *(string_ptr+6);                          /* AN000 */
            insert[start+7] = *(string_ptr+7);                          /* AN000 */
           END                                                          /* AN000 */
        return;                                                         /* AN000 */
END                                                                     /* AN000 */


/*  */
void volume_in_msg(string_ptr,start)                                    /* AN000 */

char far    *string_ptr;                                                /* AN000 */
unsigned    start;                                                      /* AN000 */

BEGIN                                                                   /* AN000 */

unsigned     i;                                                         /* AN000 */

        /* init the 11 spots to blanks */
        for (i = u(0); i < u(11);i++)                                   /* AN000 */
            BEGIN                                                       /* AN000 */
             insert[start+i] = c(' ');                                  /* AN000 */
            END                                                         /* AN000 */
        /* Put characters into the array */
           BEGIN                                                        /* AN000 */
            insert[start+0]  = *(string_ptr+0);                         /* AN000 */
            insert[start+1]  = *(string_ptr+1);                         /* AN000 */
            insert[start+2]  = *(string_ptr+2);                         /* AN000 */
            insert[start+3]  = *(string_ptr+3);                         /* AN000 */
            insert[start+4]  = *(string_ptr+4);                         /* AN000 */
            insert[start+5]  = *(string_ptr+5);                         /* AN000 */
            insert[start+6]  = *(string_ptr+6);                         /* AN000 */
            insert[start+7]  = *(string_ptr+7);                         /* AN000 */
            insert[start+8]  = *(string_ptr+8);                         /* AN000 */
            insert[start+9]  = *(string_ptr+9);                         /* AN000 */
            insert[start+10] = *(string_ptr+10);                        /* AN000 */
           END                                                          /* AN000 */
        return;                                                         /* AN000 */
END                                                                     /* AN000 */

#ifdef		DBCS		/* MSKK01 07/18/89 */

IsDBCSLeadByte( c )
unsigned char	c;
{
	static unsigned char far	*DBCSVector = NULL;
	union	REGS			r;
	struct	SREGS			s;
	unsigned char far		*p;


	if (DBCSVector == NULL) {

		/* Get current DBCS vector from DOS */

		r.x.ax = 0x6300;
		intdosx(&r, &r, &s);
		FP_OFF(DBCSVector) = r.x.si;
		FP_SEG(DBCSVector) = s.ds;

	}

	p = DBCSVector;
	while ( p[0] || p[1] ) {

		if ( c >= p[0] && c <= p[1] )
			return 1;
		p += 2;
	}
	return 0;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\extern.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  05/23/90  EGH  C18  Added support for /MBR switch to update the master boot
*                      record.
*
******************************************************************************/

/*  */
/*                                                                          */
/****************************************************************************/
/* Declare Global variables                                                 */
/****************************************************************************/
/*                                                                          */



extern  char    cur_disk;
extern  FLAG    good_disk[MAX_HDISK];
extern  unsigned char    number_of_drives;
extern  FLAG    reboot_flag;
extern  char    errorlevel;
extern  char    max_partition_size;
extern  char    sort[24];
extern  FLAG    no_fatal_error;                                         /* AC000 */
extern  char    valid_input;
extern  unsigned char   video_mode;
extern  unsigned char   display_page;
extern  unsigned char   video_attribute;                                /* AN006 */

extern  unsigned        total_disk[MAX_HDISK];                                  /* AN000 */
extern  XFLOAT          total_mbytes[MAX_HDISK];                                /* AN000 */
extern  unsigned char   max_sector[MAX_HDISK];
extern  unsigned        max_head[MAX_HDISK];                                    /* AC004 */
extern  unsigned        required_cyls[MAX_HDISK];

extern  unsigned       input_row;
extern  unsigned       input_col;
extern  char           insert[800];                                     /* AC000 */
extern  char           *pinsert;

extern unsigned char   master_boot_record[MAX_HDISK][512];
extern unsigned char   boot_record[512];

extern  char            next_letter;                                    /* AN000 */
extern  FLAG            primary_flag;                                   /* AN000 */
extern  FLAG            extended_flag;                                  /* AN000 */
extern  FLAG            logical_flag;                                   /* AN000 */
extern  FLAG            disk_flag;                                      /* AN000 */
extern  FLAG            quiet_flag;                                     /* AN000 */

extern  FLAG            status_flag;
extern  FLAG            mbr_flag;                                       /*C18*/

extern  unsigned        primary_buff;                                   /* AN000 */
extern  unsigned        extended_buff;                                  /* AN000 */
extern  unsigned        logical_buff;                                   /* AN000 */
extern  char            cur_disk_buff;                                  /* AN000 */
extern  unsigned long   NOVAL;                                          /* AN000 */
extern  char            next_letter;                                    /* AN000 */
extern  FLAG            PercentFlag;                                    /* AN000 */

extern  FLAG            mono_flag;                                      /* AN006 */

extern  char            Yes;                                            /* AN012 */
extern  char            No;                                             /* AN012 */

extern  unsigned        Parse_Ptr;                                      /* AN010 */

extern  char            primary_partition_count;
/*  */
/*                                                                          */
/****************************************************************************/
/* Define Global structures                                                 */
/****************************************************************************/
/*                                                                          */

extern  struct entry part_table[MAX_HDISK][4];
extern  struct entry ext_table[MAX_HDISK][24];
extern  struct freespace free_space[24];
extern  struct KeyData *input_data;
extern  struct dx_buffer_ioctl dx_buff;                                 /* AN000 */
extern  struct SREGS segregs;
extern  struct subst_list sublist;                                      /* AN000 */
extern  struct diskaccess disk_access;                                  /* AN002 */
extern  struct sublistx sublistp[1];                                    /* AN010 */

/*                                                                          */
/****************************************************************************/
/* Define UNIONS                                                            */
/****************************************************************************/
/*                                                                          */

extern  union REGS regs;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\dos.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*
******************************************************************************/
/* dos.h
 *
 * Defines the structs and unions used to handle the input and output
 * registers for the DOS interface routines defined in the V2.0 to V3.0
 * compatability package.  It also includes macros to access the segment
 * and offset values of MS C "far" pointers, so that they may be used by
 * these routines.
 *
 */

/* word registers */

struct WORDREGS {
	unsigned ax;
	unsigned bx;
	unsigned cx;
	unsigned dx;
	unsigned si;
	unsigned di;
	unsigned cflag;
	};

/* byte registers */

struct BYTEREGS {
	unsigned char al, ah;
	unsigned char bl, bh;
	unsigned char cl, ch;
	unsigned char dl, dh;
	};

/* general purpose registers union - overlays the corresponding word and
 * byte registers.
 */

union REGS {
	struct WORDREGS x;
	struct BYTEREGS h;
	};

/* segment registers */

struct SREGS {
	unsigned es;
	unsigned cs;
	unsigned ss;
	unsigned ds;
	};

/* dosexterror struct */

struct DOSERROR {
	int exterror;
	char class;
	char action;
	char locus;
	};

/* macros to break MS C "far" pointers into their segment and offset
 * components
 */

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))

/* function declarations for those who want strong type checking
 * on arguments to library function calls
 */
#define LINT_ARGS 1                                                     /*C00*/

#ifdef LINT_ARGS		/* arg. checking enabled */

int bdos(int, unsigned int, unsigned int);
int dosexterr(struct DOSERROR *);
int intdos(union REGS *, union REGS *);
int intdosx(union REGS *, union REGS *, struct SREGS *);
int int86(int, union REGS *, union REGS *);
int int86x(int, union REGS *, union REGS *, struct SREGS *);
void segread(struct SREGS *);

#endif	/* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\fdchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
.xlist
;
;
;*****************************************************************************
;*                                                                           *
;* Change list to FDISK modules                                              *
;*                                                                           *
;* Lines are tagged ANxxx for new, ACxxx for changed                         *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.0 Spec additions and DCR's thru unit/function test           *
;*         Date: 12/31/87  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.0 DCR D468 Add errorlevel 1 on exit if there is no PRIMARY   *
;*         partition and the /Q switch is specified.  This was done for      *
;*         SELECT.                                                           *
;*         Date: 02/06/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  002 - DOS 4.0 PTM P3383 Add logic to use undocumented int 21 to check    *
;*         media to see if it has been formatted or not. CHECK_FORMAT added. *
;*         Date: 02/08/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  003 - DOS 4.0 PTM P3589 Change CONVERT.C to compare for a period in the  *
;*         get_volume_string routine.  It does a find first on the logical   *
;*         drive for the volume name and must copy it without the period.    *
;*         Date: 02/22/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  004 - DOS 4.0 PTM P3744 Change FDISK logic to display and handle a hard  *
;*         file of up to 4,000 MB.                                           *
;*         Date: 03/04/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  005 - DOS 4.0 PTM P3618 Add errorlevel 2 on exit if there is no changes  *
;*         made and the /Q switch is specified.  This was done for           *
;*         SELECT.                                                           *
;*         Date: 02/25/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  006 - DOS 4.0 PTM P3617 Change FDISK to color screens.  This is done for *
;*         SELECT.                                                           *
;*         Date: 02/25/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  007 - DOS 4.0 DCR D490  Change FDISK IOCTL 63 to 66 in FDISK.H.          *
;*         Date: 02/26/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  008 - DOS 4.0 PTM P3698 Logic change for PTM 3618 was bad and had to     *
;*         to be corrected.                                                  *
;*         Also changed FDISK IOCTL 64 to 67 in FDISK.H.                     *
;*         Date: 02/26/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  009 - DOS 4.0 PTM P3938 A variable (temp) in subroutine                  *
;*         write_info_to_disk was not initialized on entry.                  *
;*         Date: 03/22/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  010 - DOS 4.0 PTM P4071 Changed the parsar logic to output the correct   *
;*         error message when parse is not correct.                          *
;*         Date: 03/30/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  011 - DOS 4.0 PTM P4837 When deleting and allocating FDISK logical drives*
;*         FDISK was deleting the wrong drives.                              *
;*         Date: 05/12/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  012 - DOS 4.0 PTM P4835 FDISK had Y and N hard coded for YES and NO.     *
;*         Need to pick up 'Y' and 'N' translations from message file.       *
;*         Date: 05/12/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  013 - DOS 4.0 PTM P4883 FDISK will allow the deletion of a logical       *
;*         drive that has already been deleted.  This error was caused by    *
;*         the logic change of P4837.                                        *
;*         Date: 05/17/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  014 - DOS 4.0 PTM P4953 FDISK displays too many files open error message *
;*         when Cannot FDISK with Network Loaded message should be displayed.*
;*         Date: 05/23/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  015 - DOS 4.0 PTM P5019 FDISK displays Insufficient memory error message *
;*         when Invalid Parameter should be displayed.                       *
;*         Logic has also been added to only get the volume ID of a logical  *
;*         drive by doing a Int 21 11h instead of IOCTL call 0866h.          *
;*         Date: 06/02/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  016 - DOS 4.0 PTM P5031 FDISK displays the wrong error message with 4    *
;*         partitions allocated on same disk and trying to delete primary    *
;*         partition.                                                        *
;*         Date: 06/06/88  Developer: Dennis M                               *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*****************************************************************************
;* Note: This is file FDCHNG.INC for updating purposes                       *
;*****************************************************************************
.list


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\fdisk.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  05/22/90  EGH  C17  Don't display message "Press ESC to return to FDISK
*                      options" if it is immediately going to be overwritten
*                      by "Press ESC to continue".
*  05/24/90  EGH  C20  Problem fixed - a second reboot screen was added that
*                      does not instruct the user to insert a bootable DOS
*                      diskette.
*  06/19/90  EGH  C21  Added a prompt for the volume label when deleting a
*                      primary DOS partition to be consistent with deleting
*                      logical DOS drives.
*  10/19/90  EGH  C32  Added code to handle multiple primary DOS partitions.
*
******************************************************************************/

/*  */



/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SOURCE FILE NAME: FDISK                                     */
/*                                                             */
/* DESCRIPTIVE NAME: FIXED DISK PARTITIONING UTILITY           */
/*                                                             */
/* FUNCTION:                                                   */
/*     Allows creation and deletion of DOS related partitions  */
/*     on fixed disk devices 80-81h (int 13h BIOS defined,     */
/*     DOS). Also allows display of all partitions, and will   */
/*     allow a partition to be marked active (bootable). The   */
/*     user will be prompted for action thru a full screen     */
/*     interface. The user can also create, delete and display */
/*     logical DOS drives within a EXTENDED DOS Partition. If a*/
/*     regular DOS partition is created, the beginning of the  */
/*     partition will be scanned to insure a contiguous area of*/
/*     good sectors on the disk large enough to satisfy the    */
/*     DOS system requirements. If a bad spot is found, the    */
/*     start of the partition will be moved out until a good   */
/*     area is located                                         */
/*                                                             */
/* NOTES: The program will work by setting up a logical image  */
/*        of all relevant disk information at initilization    */
/*        time. All operations will be performed on this       */
/*        logical image, thus reducing disk accesses to only   */
/*        those required to initially set up the logical image,*/
/*        and to write the changed information at the end. The */
/*        user will be informed if there is a problem writing  */
/*        the logical image back to the disk.                  */
/*                                                             */
/*        FDISK will interface with the partition table in the */
/*        master boot record as defined in the PC-DOS technical*/
/*        reference manual. It will also create and manage the */
/*        EXTENDED DOS partition architecture as defined in the*/
/*        PC-DOS 3.30 functional spec (CP/DOS spec dcr pending)*/
/*                                                             */
/* ENTRY POINTS: MAIN                                          */
/*    LINKAGE: [d:] [path] FDISK                               */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*              Fixed Disk Master Boot Record                  */
/*              EXTENDED Partition Volume Boot Records         */
/*   Note: Both of the above are physical data structures on   */
/*         the surface of the disk                             */
/*                                                             */
/* P.S. - To whoever winds up maintaining this, I will         */
/*        apoligize in advance. I had just learned 'C' when    */
/*        writing this, so out of ignorance of the finer points*/
/*        of the langauge I did a lot of things by brute force.*/
/*        Hope this doesn't mess you up too much - MT 5/20/86  */
/******************** END OF SPECIFICATIONS ********************/

#include <dos.h>
#include <fdisk.h>
#include <subtype.h>
#include <extern.h>
#include <doscall.h>
#include <ctype.h>
#include <string.h>                                                     /* AN000 */
#include <fdiskmsg.h>                                                   /* AN000 */
#include "msgret.h"                                                     /* AN000 */
#include <process.h>                                                    /* AN000 */
#include <stdio.h>                                                      /* AN000 */

/*  */
/**************************************************************************/
/*                                                                        */
/*   UTILITY NAME:         FDISK.com                                      */
/*   SOURCE FILE NAME:     FDISK.c                                        */
/*   STATUS:               FDISK utility, DOS 3.3                         */
/*   CHANGE HISTORY:       UPDATED        5-29-87     DOS4.0       DRM    */
/*   SYNTAX (Command line)                                                */
/*                                                                        */
/*         [d:][path]FDISK                                                */
/*                                                                        */
/*         or                                                             */
/*                                                                        */
/*         [d:][path]FDISK  d  [/PRI:m  |  /EXT:n  |  /LOG:o ...]         */
/*                                                                        */
/*         d:      Drive to load FDISK utility from                       */
/*                                                                        */
/*         path    path to the directory on specified drive to            */
/*                 load FDISK from                                        */
/*                                                                        */
/*         d       Drive (1 or 2) that FDISK should operate on            */
/*                                                                        */
/*         /PRI:m  Size of Primary DOS partition to create in K           */
/*                                                                        */
/*         /EXT:n  Size of Extended DOS partition to create in K          */
/*                                                                        */
/*         /LOG:o  Size of Logical drive to create in K in the            */
/*                 extended partition                                     */
/*                                                                        */
/*   UTILITY FUNCTION:                                                    */
/*     Allows you to create, set up, display, and delete the              */
/*     DOS partitions on a fixed disk.                                    */
/*                                                                        */
/**************************************************************************/

/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: CHANGE_ACTIVE_PARTITION                    */
/*                                                             */
/* DESCRIPTIVE NAME: Change bootable partition                 */
/*                                                             */
/* FUNCTION: Will allow user to select the partition that will */
/*           recieve control when system is IPL'd. This is     */
/*           only for the first hardfile as far as booting is  */
/*           concerned, although partitions can be set active  */
/*           the second. There are reserved partitions that may*/
/*           not be set active and this routine will enforce   */
/*           that.                                             */
/*                                                             */
/* NOTES: If no valid partition is specified, then the active  */
/*        partition setting is left unchanged. Screen can be   */
/*        exited via the ESC command before active partition   */
/*        is changed and no action will take place             */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00                                                      */
/*   01                                                      */
/*   02                                                      */
/*   03                                                      */
/*   04Change Active Partition                               */
/*   05                                                      */
/*   06Current Fixed Disk Drive: #                           */
/*   07                                                      */
/*   08Partition Status   Type  Start  End Size              */
/*   09    #        #   #######  #### #### ####              */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14Total disk space is #### cylinders.                   */
/*   15                                                      */
/*   16                                                      */
/*   17                                                      */
/*   18Enter the number of the partition you                 */
/*   19want to make active...............: [#]               */
/*   20                                                      */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Change_Active_Partition                       */
/*      LINKAGE: change_active_partition ()                    */
/*           NEAR CALL                                         */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if invalid num      */
/*             input is returned to this level                 */
/*                                                             */
/* EFFECTS: Display prompts needed to guide user input, and    */
/*          gets input from user.                              */
/*                                                             */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      display                                                */
/*      get_num_input                                          */
/*      table_display                                          */
/*      wait_for_ESC                                           */
/*      internal_program_error                                 */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void change_active_partition()

BEGIN

/*C00    char   temp;           */
/*C00    char   default_value;  */
    char   input;
    unsigned        i;
    unsigned        x;
    char   num_partitions;
    char   valid_partitions;
    char   num_of_bootable_partitions;
    char   valid_input;
    char   input_default;



    input = c(NUL);
    /* Clear screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display header */
    display(menu_23);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* print ESC prompt */
/*C17    display(menu_11); */

    /* Only allow active partitions on the first (and bootable) disk */
    if (cur_disk == c(0))                                               /* AC000 */

       BEGIN
	/* Display partition info and see if any partitions exist*/
	if (table_display())

	   BEGIN
	    /* See if active partition is bootable */
	    for (i=u(0); i < u(4); i++)                                 /* AC000 */
	       BEGIN
		if (part_table[cur_disk][i].sys_id != uc(0) &&
		    part_table[cur_disk][i].boot_ind == uc(0x80))  /* AC000 */
		   BEGIN
		    if ((part_table[cur_disk][i].sys_id == uc(BAD_BLOCK)) ||
			(part_table[cur_disk][i].sys_id==uc(EXTENDED)))  /* AC000 */
		       BEGIN
			/* The active partition is not bootable, so warn user */
			display(error_24);
		       END
		   END
	       END

	    /* Check to see if only one partition */
	    num_partitions = c(0) ;                                     /* AC000 */
	    num_of_bootable_partitions = c(0);                          /* AC000 */
	    for (i=u(0); i < u(4); i++)                                 /* AC000 */

	       BEGIN
		if (part_table[cur_disk][i].sys_id != uc(0))                   /* AC000 */
		   BEGIN
		    /* Get a count of partitions */
		    num_partitions++;

		    /* Get a count of the number of defined partitions but don't*/
		    /* count those we know aren't bootable */
		    if ((part_table[cur_disk][i].sys_id != uc(BAD_BLOCK)) &&
			(part_table[cur_disk][i].sys_id != uc(EXTENDED)))  /* AC000 */
		       BEGIN
			num_of_bootable_partitions++;
		       END
		   END
	       END
	    /* If only one partition found, see if it is active already */
	    if (num_of_bootable_partitions == c(1))                     /* AC000 */
	       BEGIN

		/* Find the partition and see if it is already active */
		for (i=u(0); i < u(4); i++)                             /* AC000 */

		   BEGIN
		    if (part_table[cur_disk][i].sys_id !=uc(0) &&
			part_table[cur_disk][i].boot_ind == uc(0x80))  /* AC000 */

		       BEGIN
			/* Make sure it is not unbootable partition again*/
			if ((part_table[cur_disk][i].sys_id != uc(BAD_BLOCK)) &&
			    (part_table[cur_disk][i].sys_id!=uc(EXTENDED)))  /* AC000 */

			   BEGIN
			    /* Once it is found, put out the message */
			    display(error_15);

			    /* Wait for ESC, then get out */
			    wait_for_ESC();

			    /* clear the screen before going back to main menu*/
			    clear_screen(u(0),u(0),u(24),u(79));        /* AC000 */
			    return;
			   END
		       END
		   END
	       END
	    /* See if any bootable partitions exist */
	    if (num_of_bootable_partitions == c(0))                     /* AC000 */
	       BEGIN
		/* At this point, we know at least one partition does exist due to*/
		/* getting past the table_display call, so the only ones around   */
		/* must be unbootable  */

		/* Display this fact then get out of here */
		display(error_25);
	       END
	    else
	       BEGIN
		/* All is okay to go and set one, do display prompts */
		number_in_msg((XFLOAT)total_mbytes[cur_disk],u(0));          /* AC000 */
		display(menu_15);

		/* print ESC prompt */                                  /*C17*/
		display(menu_11);                                       /*C17*/

		/* Put up input prompt */
		display(menu_24);

		/* Assume bad input until proven otherwise */
		valid_input = FALSE;
		valid_partitions = num_partitions;
		input_default = c(NUL);                               /* AC000 */

		while (!valid_input)
		   BEGIN
		    /* Go get partition to make active */
		    input = get_num_input(input_default,num_partitions,input_row,input_col);

		    /* Save the input for next time in case CR pressed */
		    input_default = input-'0';

		    clear_screen(u(18),u(0),u(23),u(79));             /* AC000 */

		    if (input != c(ESC))                              /* AC000 */
		       BEGIN
			/* See if known unbootable partition */
			/* Set the new one */
			valid_partitions = c(0);                      /* AC000 */

			/* Make sure the partitions are in physical order*/
			sort_part_table(c(4));                        /* AC000 */

			/* Go find existing partitiona */
			for (i=u(0);i < u(4); i++)                    /* AC000 */
			   BEGIN
			    /* First we have to find it */
			    if (part_table[cur_disk][sort[i]].sys_id != uc(0))   /* AC000 */
			       BEGIN
				/* If this is the 'input'th one, then we got it */
				if (valid_partitions == (input-'1'))
				   BEGIN
				    /* See if it is an unbootable partition */
				    if ((part_table[cur_disk][sort[i]].sys_id != uc(BAD_BLOCK)) &&
				     (part_table[cur_disk][sort[i]].sys_id !=  uc(EXTENDED)))        /* AC000 */

				       BEGIN
					/* Its bootable, so we have good input */
					valid_input = c(TRUE);        /* AC000 */

					/* Remove the active indicator from the old partition */
					for (x=u(0); x < u(4); x++)   /* AC000 */
					   BEGIN

					    if (part_table[cur_disk][x].boot_ind == uc(0x80))  /* AC000 */
					       BEGIN
						part_table[cur_disk][x].changed = TRUE;
						part_table[cur_disk][x].boot_ind = uc(0);      /* AC000 */
					       END
					   END

					/* Put in new active indicator */
					part_table[cur_disk][sort[i]].boot_ind = uc(0x80);     /* AC000 */

					/* Indicate that it is changed */
					part_table[cur_disk][sort[i]].changed = TRUE;

					/* Set the reboot flag */       /*C32*/
					reboot_flag = (FLAG)TRUE;       /*C32*/

					/* Update the partition info display */
					table_display();

					/* Clear off the old prompts */
					clear_screen(u(16),u(0),u(21),u(79));     /* AC000 */

					/* Say you did it */
					insert[0] = input;
					display(status_4);
					break;
				       END
				    else
				       BEGIN
					/* It is, so setup message and tell user */
					insert[0] = input;
					display(error_17);
					break;
				       END
				   END
				else
				   BEGIN
				    /* Indicate we found one but keep going */
				    valid_partitions++;
				   END
			       END
			   END
		       END
		    else
		       BEGIN
			/* Mark ESC as ok input so we can get out of here */
			valid_input = c(TRUE);                        /* AC000 */
		       END
		   END /* While loop */
	       END
	   END /* table display test endif */
	else
	   BEGIN
	    /* No partitions to make active */
	    display(error_16);
	   END
       END
    else
       BEGIN
	display(error_26);
       END
    /* clear the screen before going back to main menu */
    if (input != c(ESC))                                                /* AC000 */
       BEGIN
	wait_for_ESC();
       END
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
    return;
END


/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DISPLAY_PARTITION_INFORMATION              */
/*                                                             */
/* DESCRIPTIVE NAME: Display partition information             */
/*                                                             */
/* FUNCTION: Displays defined partition information and prompt */
/*           user to display disk volumes if they exist        */
/*                                                             */
/* NOTES:                                                      */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   00                                                      */
/*   01                                                      */
/*   02                                                      */
/*   03                                                      */
/*   04Display Partition Information                         */
/*   05                                                      */
/*   06Current Fixed Disk Drive: #                           */
/*   07                                                      */
/*   08Partition Status   Type  Start  End Size              */
/*   09    #        #   #######  #### #### ####              */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14Total disk space is #### cylinders.                   */
/*   15                                                      */
/*   16                                                      */
/*   17                                                      */
/*   18The EXTENDED DOS partition contains DOS               */
/*   19disk volumes. Do you want to display                  */
/*   20the volume information............? [Y]               */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Display_Partition_Information                 */
/*      LINKAGE: display_partition_information ()              */
/*          NEAR CALL                                          */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if invalid input    */
/*             returned to this routine                        */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      wait_for_ESC                                           */
/*      display                                                */
/*      table_display                                          */
/*      get_yn_input                                           */
/*     find_partition_type                                     */
/*      display_volume_information                             */
/*      internal_program_error                                 */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void display_partition_information()

BEGIN

    char   input;
/*C00    char    temp;  */

    input = c(NUL);                                                     /* AC000 */
    /* Clear_screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display Header */
    display(menu_35);

    /* Setup and print current disk */
    insert[0] = cur_disk+1+'0';
    display(menu_5);

    /* print ESC prompt */
/*C17    display(menu_11); */

    /* Display information */
    if (table_display())
       BEGIN

	/* Setup and print disk space msg */
	number_in_msg((XFLOAT)total_mbytes[cur_disk],u(0));                     /* AC000 */
	display(menu_15);

	/* See if any logical drive stuff to display */
	if (find_partition_type(uc(EXTENDED)))                          /* AC000 */
	   BEGIN
	    /* See if any logical drives exist */
	    if (find_logical_drive())
	       BEGIN

		/* print ESC prompt */                                  /*C17*/
		display(menu_11);                                       /*C17*/

		/* Prompt to see if they want to see EXTENDED info */
		display(menu_36);

		/* Get Y/N input, default is YES */
		input = get_yn_input(c(Yes),input_row,input_col);       /* AC000 AC011 */
		switch(input)
		   BEGIN

		    case 1:    display_volume_information();            /* AC000 */
			       break;

		    case 0:    break;                                   /* AC000 */

		    case ESC:  break;

		    default:   internal_program_error();
			       break;
		   END
	       END
	    else
		input = wait_for_ESC();
	   END
	else
	    input = wait_for_ESC();
       END
    else
	input = wait_for_ESC();
    /* clear the screen before going back to main menu */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */
    return;
END



/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DISPLAY_VOLUME_INFORMATION                 */
/*                                                             */
/* DESCRIPTIVE NAME: Display DOS disk Volume Information       */
/*                                                             */
/* FUNCTION: Displays disk volume size and existence           */
/*                                                             */
/* NOTES:                                                      */
/*                                                             */
/*        The following screen is managed                      */
/*                                                             */
/*     0000000000111111111122222222223333333333              */
/*     0123456789012345678901234567890123456789              */
/*   Ĵ              */
/*   01Display DOS Disk Volume Information                   */
/*   02                                                      */
/*   03Vol Start End  Size  Vol Start End  Size              */
/*   04 #  ####  #### ####   #  ####  #### ####              */
/*   05                                                      */
/*   06                                                      */
/*   07                                                      */
/*   08                                                      */
/*   09                                                      */
/*   10                                                      */
/*   11                                                      */
/*   12                                                      */
/*   13                                                      */
/*   14                                                      */
/*   15                                                      */
/*   16                                                      */
/*   17                                                      */
/*   18                                                      */
/*   19                                                      */
/*   20                                                      */
/*   21                                                      */
/*   22                                                      */
/*   23Press ESC to return to FDISK Options                  */
/*                 */
/*                                                             */
/* ENTRY POINTS: Display_Volume_Information                    */
/*      LINKAGE: display_volume_information ()                 */
/*          NEAR CALL                                          */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      wait_for_ESC                                           */
/*      display                                                */
/*      volume_display                                         */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void display_volume_information()

BEGIN

    char   input;
    char    temp;

    input = c(NUL);                                                     /* AC000 */
    /* clear the screen */
    clear_screen(u(0),u(0),u(24),u(79));                                /* AC000 */

    /* Display Header */
    display(menu_37);

    /* Display information */
    temp = volume_display();

    /* Set up partition size message */
    sprintf(insert,"%4.0d",get_partition_size( uc(EXTENDED) ) );
    display(menu_21);

    /* print ESC prompt */
    display(menu_11);

    /* Wait to exit */
    input = wait_for_ESC();
    return;
END

/*  */
char check_valid_environment()
BEGIN

	/* See if the net is there */
	regs.x.ax = u(INSTALLATION_CHECK);                              /* AC000 */
	int86((int)NETWORK,&regs,&regs);                                /* AC000 */

#ifdef DEBUG                                                            /* AN006 */
	regs.h.al = uc(0);                                              /* AN006 */
#endif                                                                  /* AN006 */

	/* Is it ? */
	if (regs.h.al != uc(0))                                         /* AC000 */
	   BEGIN

	    /* See if server is loaded, otherwise okay */
	    if ((regs.x.bx & SERVER_CHECK) != u(0))                     /* AC000 */
	       BEGIN
		no_fatal_error = FALSE;
		display_msg((int)4,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class)); /* AN000 AC014*/
		return(FALSE);
	       END
	   END
	return(TRUE);
END



/*  */
void init_partition_tables()
BEGIN

unsigned i;
unsigned char j;
/*C00 unsigned k;       */
/*C00 unsigned l;       */
unsigned partition_location;
char temp;
char more_drives_exist;
char num_logical_drives;
/*C00 unsigned insert;  */
unsigned index;
unsigned char active_primary_count;                                     /*C32*/
unsigned char pri_part;                                                 /*C32*/

	/* initialize first drive found to "C" */
	next_letter = c(SEA);                                              /* AC000 */

	/* initialize primary partition count */
/*C32   primary_partition_count = 0; */

	/* Look at both disks */
	for (j = uc(0); j < number_of_drives; j++)                      /* AC000 */
	   BEGIN

	    /* initialize variables */                                  /*C32*/
	    primary_partition_count = 0;                                /*C32*/
	    active_primary_count = 0;                                   /*C32*/
	    pri_part = 0xFF;                                            /*C32*/

	    /* Initialize the cur_disk field to the drive in question so */
	    /* that the calls to the partition information routines will work */
	    cur_disk = ((char)(j));

	    /* Read in the master boot record and see if it was okay */
	    if (read_boot_record(u(0),j,uc(0),uc(1)))                      /* AC000 */
	       BEGIN

		/* See if there was a valid boot record there */
		if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA)))  /* AC000 */
		   BEGIN

		    /* What was on the disk is a valid boot record, so save it */
		    for (i=u(0);i < u(BYTES_PER_SECTOR); i++)           /* AC000 */
		       BEGIN
			master_boot_record[j][i] = boot_record[i];
		       END
		   END
		/* We've now got a copy of the master boot record saved. Now we need */
		/* to translate what in the boot record to the area that it's going  */
		/* to be worked on (part_table) */

		/* Read in the data from the master boot record partition entries*/
		for (i=u(0); i < u(4); i++)                             /* AC000 */
		   BEGIN
		    index = i*16;

		    /* Get boot ind */
		    part_table[j][i].boot_ind = master_boot_record[j][0x1BE+index];

		    /* Start head */
		    part_table[j][i].start_head = master_boot_record[j][0x1BF+index];

		    /* Start sector - unscramble it from INT 13 format*/
		    part_table[j][i].start_sector= (master_boot_record[j][0x1C0+index] & 0x3F);

		    /* Start cyl - unscramble it from INT 13 format*/
		    part_table[j][i].start_cyl= ((((unsigned)master_boot_record[j][0x1C0+index]) & 0x00C0) << 2)
						+ ((unsigned)master_boot_record[j][0x1C1+index]);

		    /* System id */
		    part_table[j][i].sys_id = master_boot_record[j][0x1C2+index];

		    /* End head */
		    part_table[j][i].end_head = master_boot_record[j][0x1C3+index];

		    /* End sector - unscramble it from INT 13 format*/
		    part_table[j][i].end_sector= (master_boot_record[j][0x1C4+index] & 0x3F);

		    /* End cyl - unscramble it from INT 13 format*/
		    part_table[j][i].end_cyl= ((((unsigned)master_boot_record[j][0x1C4+index]) & 0x00C0) << 2)
						+ ((unsigned)master_boot_record[j][0x1C5+index]);

		    /* Relative sectors */

		    part_table[j][i].rel_sec =
		       ((unsigned long)master_boot_record[j][0x1C9+index]) << 24;

		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
		       (((unsigned long)master_boot_record[j][0x1C8+index]) << 16);

		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
		       (((unsigned long)master_boot_record[j][0x1C7+index]) << 8);

		    part_table[j][i].rel_sec = part_table[j][i].rel_sec +
		       ((unsigned long)master_boot_record[j][0x1C6+index]);

		    /* Number of sectors */
		    part_table[j][i].num_sec =
		       ((unsigned long)master_boot_record[j][0x1CD+index]) << 24;

		    part_table[j][i].num_sec = part_table[j][i].num_sec +
		       (((unsigned long)master_boot_record[j][0x1CC+index]) << 16);

		    part_table[j][i].num_sec = part_table[j][i].num_sec +
		       (((unsigned long)master_boot_record[j][0x1CB+index]) << 8);

		    part_table[j][i].num_sec = part_table[j][i].num_sec +
		       ((unsigned long)master_boot_record[j][0x1CA+index]);

		    part_table[j][i].mbytes_used = (unsigned)
		       numsecs_to_mbytes(part_table[j][i].num_sec);

		    part_table[j][i].percent_used =
		       mbytes_to_percent(part_table[j][i].mbytes_used,total_mbytes[cur_disk]);

		    /* Set drive letter */
		    if ( (part_table[j][i].sys_id == DOS12) ||                                                  /* AN000 */
			 (part_table[j][i].sys_id == DOS16) ||                                                  /* AN000 */
			 (part_table[j][i].sys_id == DOSNEW)   )                                                /* AN000 */
		       {
/*C32                   part_table[j][i].drive_letter = next_letter++;*/                                /* AN000 */
			part_table[j][i].drive_letter = c(' ');         /*C32*/                         /* AN000 */
			if ((primary_partition_count == 0) ||           /*C32*/
			    ((part_table[j][i].boot_ind == 0x80) &&     /*C32*/
			     (active_primary_count == 0)))              /*C32*/
			    pri_part = c(i);                            /*C32*/
			if (part_table[j][i].boot_ind == 0x80)          /*C32*/
			    active_primary_count++;                     /*C32*/
			primary_partition_count++; /*Keep track of partition number */
		       }

		    /* Set changed flag */
		    part_table[j][i].changed = FALSE;
		   END
		if (pri_part != 0xFF)                                   /*C32*/
		   {                                                    /*C32*/
		    part_table[j][pri_part].drive_letter = next_letter++; /*C32*/
		    get_volume(j,pri_part);                             /*C21*/
		   }                                                    /*C32*/
	       END
	    else
	       BEGIN
		return;
	       END
	   END

	/* Look at both disks */
	for (j = uc(0); j < number_of_drives; j++)                      /* AC000 */
	   BEGIN

	    /* Initialize the cur_disk field to the drive in question so */
	    /* that the calls to the partition information routines will work */
	    cur_disk = ((char)(j));

	    /* Read in the master boot record and see if it was okay */
	    if (read_boot_record(u(0),j,uc(0),uc(1)))                      /* AC000 */
	       BEGIN
		/* Now, go read in extended partition info */
		if (find_partition_type(uc(EXTENDED)))                      /* AC000 */
		   BEGIN
		    /* Initialize the array to zero's - include one dummy entry */
		    for (i=u(0); i < u(24); i++)                            /* AC000 */
		       BEGIN
			ext_table[j][i].boot_ind = uc(0);                   /* AC000 */
			ext_table[j][i].start_head = uc(0);                 /* AC000 */
			ext_table[j][i].start_sector = uc(0);               /* AC000 */
			ext_table[j][i].start_cyl = u(0);                   /* AC000 */
			ext_table[j][i].sys_id = uc(0);                     /* AC000 */
			ext_table[j][i].end_head = uc(0);                   /* AC000 */
			ext_table[j][i].end_sector = uc(0);                 /* AC000 */
			ext_table[j][i].end_cyl = u(0);                     /* AC000 */
			ext_table[j][i].rel_sec = ul(0);                    /* AC000 */
			ext_table[j][i].num_sec = ul(0);                    /* AC000 */
			ext_table[j][i].mbytes_used = f(0);                 /* AN000 */
			ext_table[j][i].percent_used = u(0);                /* AN000 */
			ext_table[j][i].changed = FALSE;
			ext_table[j][i].drive_letter = NUL;                 /* AN000 */

			strcpy(ext_table[cur_disk][i].system,NUL);          /* AN000 */
			strcpy(ext_table[cur_disk][i].vol_label,NUL);       /* AN000 */

		       END

		    /* Find where the first extended boot record is */
		    temp = find_partition_location(uc(EXTENDED));        /* AC000 */
		    partition_location = part_table[j][temp].start_cyl;

		    /* Go find extended boot records as long as there are more of them */
		    more_drives_exist = TRUE;

		    /* Init the number of logical drives, for a array index */
		    num_logical_drives = c(0);                           /* AC000 */

		    while (more_drives_exist)
		       BEGIN
		       /* Assume we won't find another logical drive */
		       more_drives_exist = FALSE;

			 /*Read in the extended boot record */
			 if (read_boot_record(partition_location,
					      j,
					      uc(0),
					      uc(1)))   /* AC000 */
			    BEGIN
			     load_logical_drive(num_logical_drives,j);


			     /* find the next logical drive */
			     for (i = u(0); i < u(4); i++)                      /* AC000 */
				BEGIN
				 index = i*16;
				 /* See if a sys id byte of exteneded exists */
				 if (boot_record[0x1C2+index] == uc(EXTENDED))   /* AC000 */
				    BEGIN
				     /* Found another drive, now get its location */
				     partition_location= (((((unsigned)(boot_record[0x1C0 + index])) & 0x00C0) << 2));
				     partition_location = partition_location + ((unsigned)(boot_record[0x1C1+index]));

				     /* Indicate we found another one */
				     more_drives_exist = TRUE;

				     /* Up the count of found ones */
				     /* SR; 9/28/89; The count should be
					incremented only if there is a
					logical drive defined */
				     if (ext_table[j][num_logical_drives].sys_id != 0)
					 num_logical_drives++;
				     break;
				    END
				END
			    END
		       END
		   END
	       END
	   END

	/* Look at all disks */                                         /*C32*/
	for (j = uc(0); j < number_of_drives; j++)                      /*C32*/
	   BEGIN                                                        /*C32*/
									/*C32*/
	    /* Look at all active primary partitions */                 /*C32*/
	    for (i=u(0); i < u(4); i++)                                 /*C32*/
	       BEGIN                                                    /*C32*/
		/* Set drive letter */                                  /*C32*/
		if (((part_table[j][i].sys_id == DOS12) ||              /*C32*/                             /* AN000 */
		     (part_table[j][i].sys_id == DOS16) ||              /*C32*/                             /* AN000 */
		     (part_table[j][i].sys_id == DOSNEW)) &&            /*C32*/                             /* AN000 */
		    (part_table[j][i].boot_ind == 0x80))                /*C32*/                             /* AN000 */
		   {                                                    /*C32*/
		    if (part_table[j][i].drive_letter == c(' '))        /*C32*/
		       {                                                /*C32*/
			part_table[j][i].drive_letter = next_letter++;  /*C32*/                         /* AN000 */
			get_volume(j,i);                                /*C32*/
		       }                                                /*C32*/
		   }                                                    /*C32*/
	       END                                                      /*C32*/
									/*C32*/
	    /* Look at all non-active primary partitions */             /*C32*/
	    for (i=u(0); i < u(4); i++)                                 /*C32*/
	       BEGIN                                                    /*C32*/
		/* Set drive letter */                                  /*C32*/
		if (((part_table[j][i].sys_id == DOS12) ||              /*C32*/                             /* AN000 */
		     (part_table[j][i].sys_id == DOS16) ||              /*C32*/                             /* AN000 */
		     (part_table[j][i].sys_id == DOSNEW)) &&            /*C32*/                             /* AN000 */
		    (part_table[j][i].boot_ind != 0x80))                /*C32*/                             /* AN000 */
		   {                                                    /*C32*/
		    if (part_table[j][i].drive_letter == c(' '))        /*C32*/
		       {                                                /*C32*/
			part_table[j][i].drive_letter = next_letter++;  /*C32*/                         /* AN000 */
			get_volume(j,i);                                /*C32*/
		       }                                                /*C32*/
		   }                                                    /*C32*/
	       END                                                      /*C32*/
	   END                                                          /*C32*/

	return;
END


/*  */
void get_volume(j,i)                                                    /*C21*/
									/*C21*/
unsigned char j;                                                        /*C21*/
unsigned i;                                                             /*C21*/
									/*C21*/
BEGIN                                                                   /*C21*/
									/*C21*/
char     volume_label[13];                                              /*C21*/
unsigned k;                                                             /*C21*/
unsigned length;                                                        /*C21*/
									/*C21*/
    /* See if the disk has already been formated */                     /*C21*/
    if (check_format(part_table[j][i].drive_letter) == TRUE )           /*C21*/
       BEGIN                                                            /*C21*/
	/* get volume and system info */                                /*C21*/
									/*C21*/
	for (k = u(0); k < u(12); k++)                                  /*C21*/
	   BEGIN                                                        /*C21*/
	    part_table[j][i].vol_label[k]=u(0);                         /*C21*/
	   END                                                          /*C21*/
									/*C21*/
	for (k = u(0); k < u(9); k++)                                   /*C21*/
	   BEGIN                                                        /*C21*/
	    part_table[j][i].system[k]=u(0);                            /*C21*/
	   END                                                          /*C21*/
									/*C21*/
	get_volume_string(part_table[j][i].drive_letter,&volume_label[0]); /*C21*/
									/*C21*/
	for (k = u(0); k < strlen(volume_label); k++)                   /*C21*/
	   BEGIN                                                        /*C21*/
	    part_table[j][i].vol_label[k]=volume_label[k];              /*C21*/
	   END                                                          /*C21*/
									/*C21*/
	/* Now try to get it using GET MEDIA ID */                      /*C21*/
	if (get_fs_and_vol(part_table[j][i].drive_letter))              /*C21*/
	   BEGIN                                                        /*C21*/
	    for (k=u(0); k < u(8); k++)                                 /*C21*/
	       BEGIN                                                    /*C21*/
		if (dx_buff.file_system[k] != ' ')                      /*C21*/
		    length = k+1;                                       /*C21*/
	       END                                                      /*C21*/
	    strncpy(part_table[j][i].system,&dx_buff.file_system[0],u(length)); /*C21*/
	   END                                                          /*C21*/
	else                                                            /*C21*/
	   BEGIN                                                        /*C21*/
	    if (part_table[j][i].num_sec > (unsigned long)FAT16_SIZE)   /*C21*/
		strcpy(part_table[j][i].system,FAT16);                  /*C21*/
	    else                                                        /*C21*/
		strcpy(part_table[j][i].system,FAT12);                  /*C21*/
	   END                                                          /*C21*/
       END                                                              /*C21*/
    else                                                                /*C21*/
       BEGIN                                                            /*C21*/
	/* set up to no file system or volume label */                  /*C21*/
	strcpy(part_table[j][i].vol_label,NOVOLUME);                    /*C21*/
	strcpy(part_table[j][i].system,NOFORMAT);                       /*C21*/
       END                                                              /*C21*/
    return;                                                             /*C21*/
END                                                                     /*C21*/

/*  */
void load_logical_drive(point,drive)

char   point;
unsigned char   drive;

BEGIN

char        volume_label[13];                                           /* AC000 *//*Used be 11*/
unsigned    ext_part_num;                                               /* AN000 */
unsigned    i;
/*C00 unsigned    j; */                                                         /* AN000 */
unsigned    k;                                                          /* AN000 */
unsigned    length;                                                     /* AN000 */
unsigned    index;
/*C00 unsigned    dx_pointer; */                                                /* AN000 */
unsigned    partition_location;                                         /* AN000 */

	/* Check to see if anything is there */
	if ((boot_record[510] == uc(0x55)) && (boot_record[511] == uc(0xAA)))  /* AC000 */
	    BEGIN
	    /* The boot record is there - read in the logical drive if it is there */
	    for (i = u(0); i < u(4); i++)                               /* AC000 */
		BEGIN

		index = i*16;
		/* See if it is a defined extended drive*/
		if ((boot_record[0x1C2 + index] != uc(0)) && (boot_record[0x1C2 + index] != uc(EXTENDED)))  /* AC000 */
		    BEGIN
		    /* Get boot ind */
		    ext_table[drive][point].boot_ind = boot_record[0x1BE + index];

		    /* Start head */
		    ext_table[drive][point].start_head = boot_record[0x1BF + index];

		    /* Start sector - unscramble it from INT 13 format*/
		   ext_table[drive][point].start_sector= (boot_record[0x1C0 + index] & 0x3F);

		    /* Start cyl - unscramble it from INT 13 format*/
		    ext_table[drive][point].start_cyl= ((((unsigned)boot_record[0x1C0+index]) & 0x00C0) << 2)
						+ ((unsigned)boot_record[0x1C1+index]);


		    /* System id */
		    ext_table[drive][point].sys_id = boot_record[0x1C2+index];

		    /* End head */
		    ext_table[drive][point].end_head = boot_record[0x1C3+index];

		    /* End sector - unscramble it from INT 13 format*/
		    ext_table[drive][point].end_sector= (boot_record[0x1C4+index] & 0x3F);


		    /* End cyl - unscramble it from INT 13 format*/
		    ext_table[drive][point].end_cyl= ((((unsigned)boot_record[0x1C4+index]) & 0x00C0) << 2)
						+ ((unsigned)boot_record[0x1C5+index]);

		    /* Relative sectors */
		    ext_table[drive][point].rel_sec =
			((unsigned long)boot_record[0x1C9+index]) << 24;

		    ext_table[drive][point].rel_sec =
			ext_table[drive][point].rel_sec+(((unsigned long)boot_record[0x1C8+index]) << 16);

		    ext_table[drive][point].rel_sec =
			ext_table[drive][point].rel_sec + (((unsigned long)boot_record[0x1C7+index]) << 8);

		    ext_table[drive][point].rel_sec =
			ext_table[drive][point].rel_sec + ((unsigned long)boot_record[0x1C6+index]);

		    /* Number of sectors */

		    ext_table[drive][point].num_sec =
			((unsigned long)boot_record[0x1CD+index]) << 24;

		    ext_table[drive][point].num_sec =
			ext_table[drive][point].num_sec+(((unsigned long)boot_record[0x1CC+index]) << 16);

		    ext_table[drive][point].num_sec =
			ext_table[drive][point].num_sec + (((unsigned long)boot_record[0x1CB+index]) << 8);

		    ext_table[drive][point].num_sec =
			ext_table[drive][point].num_sec + ((unsigned long)boot_record[0x1CA+index]);

		    ext_table[drive][point].mbytes_used =
			cylinders_to_mbytes(((ext_table[drive][point].end_cyl - ext_table[drive][point].start_cyl)+1),
					      cur_disk);                /* AN004 */

		    ext_part_num = find_partition_location(uc(EXTENDED));

		    ext_table[drive][point].percent_used =
			cylinders_to_percent(((ext_table[drive][point].end_cyl-ext_table[drive][point].start_cyl)+1),
			((part_table[drive][ext_part_num].end_cyl-part_table[drive][ext_part_num].start_cyl)+1));      /* AN000 */

		    ext_table[drive][point].drive_letter = next_letter++;                                      /* AN000 */

		    partition_location = ext_table[drive][point].start_cyl;

		    if (read_boot_record(ext_table[drive][point].start_cyl,
					 drive,
					 ext_table[drive][point].start_head,
					 ext_table[drive][point].start_sector));
			 BEGIN                                                                  /* AN000 */
			 /* See if the disk has already been formated */
			 if (check_format(ext_table[drive][point].drive_letter) == TRUE )       /* AN002 */
			     BEGIN                                                              /* AN000 */
			     /* get volume and system info */

			     /* AC000 Just for cleaning up purposes */

			     for (k = u(0); k < u(12); k++)                                     /* AC000 */
				 BEGIN                                                          /* AC000 */
				     ext_table[drive][point].vol_label[k]=u(0);                 /* AC000 */
				 END                                                            /* AC000 */

			     for (k = u(0); k < u(9); k++)                                      /* AC000 */
				 BEGIN                                                          /* AC000 */
				     ext_table[drive][point].system[k]=u(0);                    /* AC000 */
				 END                                                            /* AC000 */

			     get_volume_string(ext_table[drive][point].drive_letter,&volume_label[0]);   /* AN000 AC015 */

			      for (k = u(0); k < strlen(volume_label); k++)                     /* AC000 AC015 */
				   BEGIN                                                        /* AC000 AC015 */
				     ext_table[drive][point].vol_label[k]=volume_label[k];      /* AC000 AC015 */
				   END                                                          /* AC000 AC015 */

			     /* Now try to get it using GET MEDIA ID function */
			     if (get_fs_and_vol(ext_table[drive][point].drive_letter))          /* AN000 */

				BEGIN                                                           /* AN000 */
				/* AC000 Just use more conceptually simple logic */
				for (k=u(0); k < u(8); k++)                                     /* AC000 */

				    BEGIN                                                       /* AC000 */
				      if (dx_buff.file_system[k] != ' ')                        /* AC000 */
						length = k+1;                                   /* AC000 */
				    END                                                         /* AC000 */

				strncpy(ext_table[drive][point].system,&dx_buff.file_system[0],u(length)); /* AN000 */
				END                                                             /* AN000 */

			      else                                                              /* AN000 */

				BEGIN                                                           /* AN000 */
				if (ext_table[drive][point].num_sec > (unsigned long)FAT16_SIZE) /* AN000 */
				    strcpy(ext_table[drive][point].system,FAT16);               /* AN000 */
				else
				    strcpy(ext_table[drive][point].system,FAT12);               /* AN000 */
				END                                                             /* AN000 */
			     END                                                                /* AN000 */
			 else                                                                   /* AN000 */
			     BEGIN                                                              /* AN000 */
			     /* set up array to say no file system or volume label */
			     strcpy(ext_table[drive][point].vol_label,NOVOLUME);                /* AN000 */
			     strcpy(ext_table[drive][point].system,NOFORMAT);                   /* AN000 */
			     END                                                                /* AN000 */

			 regs.x.dx = u(0);
			 regs.x.ax = NETWORK_IOCTL;
			 regs.h.bl = ((ext_table[drive][point].drive_letter - 'A') + 1);
			 intdos(&regs,&regs);
			 if (regs.x.dx & 0x1000) strcpy(ext_table[drive][point].vol_label,REMOTE);
			 END
		    read_boot_record(ext_table[drive][point].start_cyl,
				     drive,
				     uc(0),
				     uc(1));                                                    /* AN000 */
		    END
		END
	    END

	return;

END


/*  */
void reboot_system()
BEGIN

    char far *boot_drive;                                               /*C20*/
    char     boot_letter;                                               /*C20*/
    char     i,j;                                                       /*C20*/
    FLAG     boot_changed;                                              /*C20*/

    clear_screen(u(0),u(0),u(24),u(79));                            /* AC000 */
    if (quiet_flag == FALSE)
	BEGIN
	regs.h.ah = 0x52;                                               /*C20*/
	intdosx(&regs,&regs,&segregs);                                  /*C20*/
	FP_SEG(boot_drive) = segregs.es;                                /*C20*/
	FP_OFF(boot_drive) = regs.x.bx + u(0x43);                       /*C20*/
	boot_letter = *boot_drive + c(0x40);                            /*C20*/
	if (boot_letter != 'A')                                         /*C20*/
	    {                                                           /*C20*/
	    boot_changed = TRUE;                                        /*C20*/
	    for (i=0; i<number_of_drives; i++)                          /*C20*/
		for (j=0; j<4; j++)                                     /*C20*/
		    if (part_table[i][j].drive_letter == boot_letter)   /*C20*/
			boot_changed = part_table[i][j].changed;        /*C20*/
	    if (boot_changed == FALSE)                                  /*C20*/
		display(menu_60);                                       /*C20*/
	    else                                                        /*C20*/
		display(menu_38);                                       /*C20*/
	    }                                                           /*C20*/
	else                                                            /*C20*/
	    display(menu_38);
	getch();
	reboot();
	END
    else
	BEGIN
	cur_disk = c(0);                                            /* AN001 */
	reset_video_information();                                  /* AN006 */
	if ( (find_partition_type(uc(DOS12))) ||
	     (find_partition_type(uc(DOS16))) ||
	     (find_partition_type(uc(DOSNEW))) )                    /* AN001 */
	    exit(ERR_LEVEL_0);                                      /* AN001 */
	else                                                        /* AN001 */
	    exit(ERR_LEVEL_1);                                      /* AN001 */
	END
END


/*  */
void internal_program_error()

BEGIN
   display(internal_error);
   DOSEXIT(u(0),u(0));                                                  /* AC000 */
   return;
END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\fdboot.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
;       BOOT - IBM hard disk boot record             6/8/82
;
;
; This is the standard boot record that will be shipped on all hard disks. It contains:
;
; 1. Code to load (and give control to) the boot record for 1 of 4 possible
;    operating systems.
;
; 2. A partition table at the end of the boot record, followed by the required signature.
;
;
_data   segment public
        assume  cs:_data,ds:_data

        org 600h

        cli             ;no interrupts for now
        xor ax,ax
        mov ss,ax
        mov sp,7c00h    ;new stack at 0:7c00
        mov si,sp       ;where this boot record starts - 0:7c00
        push ax
        pop es          ;seg regs the same
        push ax
        pop ds
        sti             ;interrupts ok now
        cld
        mov di,0600h    ;where to relocate this boot record to
        mov cx,100h
        repnz movsw     ;relocate to 0:0600
;       jmp entry2
        db   0eah
        dw   $+4,0
entry2:
        mov si,offset tab      ;partition table
        mov bl,4        ;number of table entries
next:
        cmp byte ptr[si],80h  ;is this a bootable entry?
        je boot         ;yes
        cmp byte ptr[si],0    ;no, is boot indicator zero?
        jne bad         ;no, it must be x"00" or x"80" to be valid
        add si,16       ;yes, go to next entry
        dec bl
        jnz next
        int 18h         ;no bootable entries - go to rom basic
boot:
        mov dx,[si]     ;head and drive to boot from
        mov cx,[si+2]   ;cyl, sector to boot from
        mov bp,si       ;save table entry address to pass to partition boot record
next1:
        add si,16       ;next table entry
        dec bl          ;# entries left
        jz tabok        ;all entries look ok
        cmp byte ptr[si],0    ;all remaining entries should begin with zero
        je next1        ;this one is ok
bad:
        mov si,offset m1 ;oops - found a non-zero entry - the table is bad
msg:
        lodsb           ;get a message character
        cmp al,0
        je  hold
        push si
        mov bx,7
        mov ah,14
        int 10h         ;and display it
        pop si
        jmp msg         ;do the entire message
;
hold:   jmp hold        ;spin here - nothing more to do
tabok:
        mov di,5        ;retry count
rdboot:
        mov bx,7c00h    ;where to read system boot record
        mov ax,0201h    ;read 1 sector
        push di
        int 13h         ;get the boot record
        pop di
        jnc goboot      ;successful - now give it control
        xor ax,ax       ;had an error, so
        int 13h         ;recalibrate
        dec di          ;reduce retry count
        jnz rdboot      ;if retry count above zero, go retry
        mov si,offset m2 ;all retries done - permanent error - point to message,
        jmp msg          ;go display message and loop
goboot:
        mov si,offset m3 ;prepare for invalid boot record
        mov di,07dfeh
        cmp word ptr [di],0aa55h ;does the boot record have the
                                   ;    required signature?
        jne msg         ;no, display invalid system boot record message
        mov si,bp       ;yes, pass partition table entry address
        db 0eah
        dw 7c00h,0

include fdisk5.cl1

        org 7beh
tab:                    ;partition table
        dw 0,0          ;partition 1 begin
        dw 0,0          ;partition 1 end
        dw 0,0          ;partition 1 relative sector (low, high parts)
        dw 0,0          ;partition 1 # of sectors (low, high parts)
        dw 0,0          ;partition 2 begin
        dw 0,0          ;partition 2 end
        dw 0,0          ;partition 2 relative sector
        dw 0,0          ;partition 2 # of sectors
        dw 0,0          ;partition 3 begin
        dw 0,0          ;partition 3 end
        dw 0,0          ;partition 3 relative sector
        dw 0,0          ;partition 3 # of sectors
        dw 0,0          ;partition 4 begin
        dw 0,0          ;partition 4 end
        dw 0,0          ;partition 4 relative sector
        dw 0,0          ;partition 4 # of sectors
signa   db 55h,0aah     ;signature

_data   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\global.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  05/23/90  EGH  C18  Added support for /MBR switch to update the master boot
*                      record.
*
******************************************************************************/

#include "fdisk.h"
#include "dos.h"

/*  */
/*                                                                          */
/****************************************************************************/
/* Declare Global variables                                                */
/****************************************************************************/
/*                                                                          */



char    cur_disk;
char    good_disk[MAX_HDISK];
unsigned char    number_of_drives;
char    reboot_flag;
char    errorlevel;
char    max_partition_size;
char    sort[24];
char    no_fatal_error;
char    valid_input;
unsigned char   video_mode;
unsigned char   display_page;
unsigned char   video_attribute;                                        /* AN006 */


unsigned        total_disk[MAX_HDISK];
unsigned        total_mbytes[MAX_HDISK];                                        /* AN000 */
unsigned char   max_sector[MAX_HDISK];
unsigned        max_head[MAX_HDISK];                                            /* AC004 */
unsigned        required_cyls[MAX_HDISK];

unsigned       input_row;
unsigned       input_col;
char           insert[800];                                             /* AC000 */
char           *pinsert = insert;

extern unsigned char   master_boot_record[MAX_HDISK][512];
unsigned char   boot_record[512];

char            next_letter;                                            /* AN000 */
char            primary_flag;                                           /* AC000 */
char            extended_flag;                                          /* AC000 */
char            logical_flag;                                           /* AC000 */
char            disk_flag;                                              /* AC000 */
char            quiet_flag;                                             /* AC000 */

char            status_flag;
char            mbr_flag;                                               /*C18*/

unsigned        primary_buff;                                           /* AC000 */
unsigned        extended_buff;                                          /* AC000 */
unsigned        logical_buff;                                           /* AC000 */
char            cur_disk_buff;                                          /* AC000 */
unsigned long   NOVAL = (unsigned long) 0;                              /* AC000 */
FLAG            PercentFlag;                                            /* AC000 */

FLAG            mono_flag;                                              /* AC006 */

char            Yes;                                                    /* AC012 */
char            No;                                                     /* AC012 */

unsigned        Parse_Ptr;                                              /* AN010 */

char				primary_partition_count;
/*  */
/*                                                                          */
/****************************************************************************/
/* Define Global structures                                                 */
/****************************************************************************/
/*                                                                          */

struct entry part_table[MAX_HDISK][4];
struct entry ext_table[MAX_HDISK][24];
struct freespace free_space[24];
struct KeyData *input_data;
struct dx_buffer_ioctl dx_buff;                                         /* AN000 */
struct diskaccess disk_access;                                          /* AN002 */
struct SREGS segregs;
struct sublistx sublistp[1];                                            /* AN010 */

/*                                                                          */
/****************************************************************************/
/* Define UNIONS                                                            */
/****************************************************************************/
/*                                                                          */

union REGS regs;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\fdiskmsg.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/05/90  EGH  C01  Problem fixed - Some added messages for deleting more
*                      than one primary partition were defined in the code
*                      and were not being properly displayed.  Fix was to
*                      remove them from the code and put them in the standard
*                      internationalized form.  This resulted in the creation
*                      of menu_55, menu_56, and error_37.
*  03/22/90  EGH  C14  Added support for deleting non-DOS partitions.  This
*                      resulted in the creation of menu_57, menu_58, menu_59,
*                      status_13, error_38, and error_39.
*  03/22/90  EGH  C15  Added code to recognize additional partition types.
*  05/24/90  EGH  C20  Added code to determine whether or not the system 
*                      diskette needs to be inserted before a reboot.  This
*                      resulted in the creation of menu_60.
*
******************************************************************************/
/*           FDISK MESSAGE FILE                                         */

/************************************************************************/
/* Please log all modifications to this file:                           */
/*----------------------------------------------------------------------*/
/* Date: 04/04/86                                                       */
/* Changed by: Mark T                                                   */
/* Message changed: menu_1 - menu_38                                    */
/* Reason: Creation of file                                             */
/*----------------------------------------------------------------------*/
/* Date: 05/04/87                                                       */
/* Changed by: Dennis M                                                 */
/* Message changed: menu_1 - menu_44                                    */
/* Reason: DOS 3.3                                                      */
/*----------------------------------------------------------------------*/
/* Date:                                                                */
/* Changed by:                                                          */
/* Message changed:                                                     */
/* Reason:                                                              */
/*----------------------------------------------------------------------*/
/************************************************************************/

#define ACTIVE_PART  'A'   /* Character to indicate active status */
#define DRIVE_INDICATOR ':' /* Character displayed to indicate drive letter */

/*-------------------------------------------------------------*/
 extern char far *menu_1;                                               /* AN000 */
 extern char far *menu_2;                                               /* AN000 */
 extern char far *menu_3 ;                                              /* AN000 */
 extern char far *menu_4 ;                                              /* AN000 */
 extern char far *menu_5 ;                                              /* AN000 */
 extern char far *menu_6 ;                                              /* AN000 */
 extern char far *menu_7 ;                                              /* AN000 */
 extern char far *menu_8 ;                                              /* AN000 */
 extern char far *menu_9 ;                                              /* AN000 */
 extern char far *menu_10 ;                                             /* AN000 */
 extern char far *menu_11 ;                                             /* AN000 */
 extern char far *menu_12 ;                                             /* AN000 */
 extern char far *menu_13 ;                                             /* AN000 */
 extern char far *menu_14 ;                                             /* AN000 */
 extern char far *menu_15 ;                                             /* AN000 */
 extern char far *menu_16 ;                                             /* AN000 */
 extern char far *menu_39 ;                                             /* AN000 */
 extern char far *menu_17 ;                                             /* AN000 */
 extern char far *menu_42 ;                                             /* AN000 */
 extern char far *menu_18 ;                                             /* AN000 */
 extern char far *menu_19 ;                                             /* AN000 */
 extern char far *menu_43 ;                                             /* AN000 */
 extern char far *menu_20 ;                                             /* AN000 */
 extern char far *menu_44 ;                                             /* AN000 */
 extern char far *menu_21 ;                                             /* AN000 */
 extern char far *menu_22 ;                                             /* AN000 */
 extern char far *menu_40 ;                                             /* AN000 */
 extern char far *menu_23 ;                                             /* AN000 */
 extern char far *menu_24 ;                                             /* AN000 */
 extern char far *menu_25 ;                                             /* AN000 */
 extern char far *menu_26 ;                                             /* AN000 */
 extern char far *menu_27 ;                                             /* AN000 */
 extern char far *menu_28 ;                                             /* AN000 */
 extern char far *menu_29 ;                                             /* AN000 */
 extern char far *menu_30 ;                                             /* AN000 */
 extern char far *menu_31 ;                                             /* AN000 */
 extern char far *menu_32 ;                                             /* AN000 */
 extern char far *menu_33 ;                                             /* AN000 */
 extern char far *menu_34 ;                                             /* AN000 */
 extern char far *menu_41 ;                                             /* AN000 */
 extern char far *menu_35 ;                                             /* AN000 */
 extern char far *menu_36 ;                                             /* AN000 */
 extern char far *menu_37 ;                                             /* AN000 */
 extern char far *menu_38 ;                                             /* AN000 */
 extern char far *menu_45 ;                                             /* AN000 */
 extern char far *menu_46 ;                                             /* AN000 */
 extern char far *menu_47 ;
 extern char far *menu_48 ;
 extern char far *menu_49 ;
 extern char far *menu_50 ;
 extern char far *menu_51 ;
 extern char far *menu_52 ;
 extern char far *menu_53 ;
 extern char far *menu_54 ;
 extern char far *menu_55 ;                                             /*C01*/
 extern char far *menu_56 ;                                             /*C01*/
 extern char far *menu_57 ;                                             /*C14*/
 extern char far *menu_58 ;                                             /*C14*/
 extern char far *menu_59 ;                                             /*C14*/
 extern char far *menu_60 ;                                             /*C20*/

/*-------------------------------------------------------------*/
 extern char far *status_1 ;                                            /* AN000 */
 extern char far *status_2 ;                                            /* AN000 */
 extern char far *status_3 ;                                            /* AN000 */
 extern char far *status_4 ;                                            /* AN000 */
 extern char far *status_5 ;                                            /* AN000 */
 extern char far *status_6 ;                                            /* AN000 */
 extern char far *status_7 ;                                            /* AN000 */
 extern char far *status_8 ;                                            /* AN000 */
 extern char far *status_9 ;                                            /* AN000 */
 extern char far *status_10 ;                                           /* AN000 */
 extern char far *status_11 ;                                           /* AN000 */
 extern char far *status_12 ;                                           /* AN000 */
 extern char far *status_13 ;                                           /*C14*/
/*-------------------------------------------------------------*/
 extern char far *error_1 ;                                             /* AN000 */
 extern char far *error_2 ;                                             /* AN000 */
 extern char far *error_3 ;                                             /* AN000 */
 extern char far *error_4 ;                                             /* AN000 */
 extern char far *error_5 ;                                             /* AN000 */
 extern char far *error_6 ;                                             /* AN000 */
 extern char far *error_7 ;                                             /* AN000 */
 extern char far *error_8 ;                                             /* AN000 */
 extern char far *error_9 ;                                             /* AN000 */
 extern char far *error_10 ;                                            /* AN000 */
 extern char far *error_12 ;                                            /* AN000 */
 extern char far *error_13 ;                                            /* AN000 */
 extern char far *error_14 ;                                            /* AN000 */
 extern char far *error_15 ;                                            /* AN000 */
 extern char far *error_16 ;                                            /* AN000 */
 extern char far *error_17 ;                                            /* AN000 */
 extern char far *error_19 ;                                            /* AN000 */
 extern char far *error_20 ;                                            /* AN000 */
 extern char far *error_21 ;                                            /* AN000 */
 extern char far *error_22 ;                                            /* AN000 */
 extern char far *error_23 ;                                            /* AN000 */
 extern char far *error_24 ;                                            /* AN000 */
 extern char far *error_25 ;                                            /* AN000 */
 extern char far *error_26 ;                                            /* AN000 */
 extern char far *error_27 ;                                            /* AN000 */
 extern char far *error_28 ;                                            /* AN000 */
 extern char far *error_29 ;                                            /* AN000 */
 extern char far *error_30 ;                                            /* AN000 */
 extern char far *error_31 ;                                            /* AN000 */
 extern char far *error_32 ;                                            /* AN000 */
 extern char far *error_33 ;                                            /* AN000 */
 extern char far *error_34 ;                                            /* AN000 */
 extern char far *error_35 ;                                            /* AN000 */
 extern char far *error_36 ;                                            /* AN000 */
 extern char far *error_37 ;                                            /*C01*/
 extern char far *error_38 ;                                            /*C14*/
 extern char far *error_39 ;                                            /*C14*/
/*-------------------------------------------------------------*/
 extern char far *debug_msg ;                                           /* AN000 */
 extern char far *internal_error ;                                      /* AN000 */
/*-------------------------------------------------------------*/
 extern char *REMOTE;

 extern char *DOS_part ;                                            /* AN000 */
 extern char *XENIX_part ;                                          /* AN000 */
 extern char *EXTENDED_part ;                                       /* AN000 */
 extern char *BAD_BLOCK_part ;                                      /* AN000 */
 extern char *PCIX_part ;                                           /* AN000 */
 extern char *HPFS_part ;                                               /*C15*/
 extern char *NOVELL_part ;                                             /*C15*/
 extern char *CPM_part ;                                                /*C15*/
 extern char *NON_DOS_part ;                                        /* AN000 */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\int13.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
******************************************************************************/
#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */

#include "string.h"
#include "stdio.h"
#include "stdlib.h"

/* int     printf(char *, ...); */

/*  */
char get_disk_info()

BEGIN

    unsigned char   i;

    /* Initialize values */
    number_of_drives = uc(0);                                       /* AC000 */
    for (i=uc(0); i < uc(MAX_HDISK); i++)                           /* AC000 */
       BEGIN
        total_disk[i] = u(0);                                       /* AC000 */
        total_mbytes[i] = f(0);                                     /* AC000 */
        max_sector[i] = uc(0);                                      /* AC000 */
        max_head[i] = u(0);                                         /* AC004 */
       END

    /* See how many drives there are */
    if (get_drive_parameters(uc(0x80)))                             /* AC000 */

       BEGIN
        /* Get the drive parameters for all drives */
        for (i = uc(0); i < number_of_drives;i++)                   /* AC000 */

           BEGIN
            if (get_drive_parameters(uc(0x80)+i))                   /* AC000 */

               BEGIN
                /* Save drive parameters */
                max_sector[i] = ((unsigned char)(regs.h.cl & 0x3F));
                max_head[i] = ((unsigned)(regs.h.dh +1));          /* AC004 */
                total_disk[i] = ((((unsigned)(regs.h.cl & 0xc0)) << 2) | regs.h.ch) + 1;
                total_mbytes[i] = cylinders_to_mbytes(total_disk[i],i);  /* AN004 */
               END
            else
               BEGIN
                good_disk[i] = FALSE;
                return(FALSE);
               END
           END
        return(TRUE);
       END
    else
        /* No drives present */
        BEGIN
         no_fatal_error = FALSE;
         return(FALSE);
        END
END



/*  */
char write_boot_record(cylinder,which_disk)

unsigned    cylinder;
unsigned char   which_disk;

BEGIN

/*C00    char i;  */
/*C00    char j;  */
    char far *buffer_pointer = boot_record;

    /* Setup read, always on a cylinder boundary */
    regs.h.ah = uc(WRITE_DISK);                                     /* AC000 */
    regs.h.al = uc(1);                                              /* AC000 */
    regs.h.dh = uc(0);                                              /* AC000 */
    regs.h.cl = uc(0x01);                                           /* AC000 */

    /* Specify the disk */
    regs.h.dl = which_disk + 0x80;

    /* Need to scramble CX so that sectors and cyl's are in INT 13 format */

    if (cylinder > u(255))                                          /* AC000 */
       BEGIN
        regs.h.cl = regs.h.cl | ((unsigned char)((cylinder /256) << 6));
       END
    regs.h.ch = (unsigned char)(cylinder & 0xFF);

    /* Point at the place to read the boot record */
    regs.x.bx = FP_OFF(buffer_pointer);
    segregs.es = FP_SEG(buffer_pointer);

    /* write the boot record */
    DiskIo(&regs,&regs,&segregs);                         /* AC000 */

    /* Check for error reading it */
    if ((regs.x.cflag & 1) != u(1))                                 /* AC000 */
       BEGIN
        return(TRUE);
       END
    else
       BEGIN
        /* Tell user there was an error */
        clear_screen(u(0),u(0),u(24),u(79));                        /* AC000 */
        display(error_2);
        no_fatal_error = FALSE;
        return(FALSE);
       END
END

/*  */
unsigned verify_tracks(pointer,type)

char pointer;
char type;

BEGIN
    unsigned        i;

    /* SR; 9/29/89; Temp store */
    unsigned                 j;
/*C00    unsigned        location;     */
    unsigned        sectors_per_fat;
    unsigned        cur_cyl;
    unsigned        verify_cyl;
    unsigned        num_tracks;
    unsigned                        retry_flg;
    unsigned long   total_sectors;
    char   golden_tracks;
    char   retry;
    unsigned        char   cur_head;                                        /* AC004 */

    char far *buffer_pointer = boot_record;
/*C00    char head;                    */



    for (i=u(0); i< u(BYTES_PER_SECTOR);i++)                        /* AC000 */
       BEGIN
        /* Put something other then 0's so that unformatted FAT looks full */

        boot_record[i] = uc(0xF6);                                  /* AC000 */
       END

    /* Get the start cylinder for the sweep */
    cur_cyl = free_space[pointer].start;

    /* Also keep track of what it is */
    verify_cyl = cur_cyl;

    /* Initialize the start head -assume 0*/
    cur_head = uc(0);                                               /* AC004 */

    /* SR; 9/29/89; cur_head should be 1 for extended partitions too */
    if (((type == c(PRIMARY)) && (cur_cyl == u(0))) || type == c(EXTENDED))                  /* AC000 */
      BEGIN

       /* It's head 1 - NOTE: This is convience for PC-DOS because it is */
       /* always this way - This may have to be beefed up for IFS  */
       cur_head = uc(1);                                            /* AC004 */
      END

    /* Now go figure out the number of golden sectors needed. Use the */
    /* allocation equation in the fixed disk section of DOS Tech Ref. */
    /*                                                                */
    /*  TS = Free cyl's * sector/track * track/cyl                    */
    /*  RS = 1                                                        */
    /*  D  = 512                                                      */
    /*  BPD = 32                                                      */
    /*  BPS = BYTES_PER_SECTOR                                        */
    /*  CF = 2                                                        */
    /*  SPF = Solve                                                   */
    /*  SPC = 4 or 8                                                  */
    /*  BPC = 1.5 or 2                                                */
    /*                                                                */
    /*  Golden Sectors = RS + 2(SPF) + BPD(D)  + (DOSFILES)           */
    /*                                    if bootable           */
    /*                                  BPS                           */

    total_sectors = ((unsigned long)free_space[pointer].space) * max_head[cur_disk] * max_sector[cur_disk];

    /* Chop off one track if it starts on head 1 */
    if (cur_head == uc(1))                                          /* AC004 */
       BEGIN
        total_sectors = total_sectors - max_sector[cur_disk];
       END

    /* See if 12 or 16 bit fat */
    if (total_sectors > (unsigned long)FAT16_SIZE)
       BEGIN
        /* SR; 9/30/89; We have to round up the sectors_per_fat.
           Calculate the denominator first */

        j = 2 + (BYTES_PER_SECTOR * 2);
        /* 16 bit */
        /* SR; 9/30/89; To round up add j-1 and divide by j */
/*C00   sectors_per_fat = ((total_sectors - 33) + j - 1) / j;     */
        sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);        /*C00*/
       END
    else
       BEGIN
        /* SR; 9/30/89; We have to round up the sectors_per_fat.
        Calculate the denominator first. We have to round up the
        denominator too. The multiplying factor 16 = SPC * 2 */

        j = 2 + (( BYTES_PER_SECTOR * 16 ) + 2 ) / 3;
        /* 12 bit */
/*C00   sectors_per_fat = ((total_sectors - 33) + j - 1) / j;    */
        sectors_per_fat = u(((total_sectors - 33) + j - 1) / j);        /*C00*/
       END

    /* Round up one just to handle any rounding errors */
    /* SR; 9/30/89; We have taken care of the rounding */
    /***SR; 9/30/89;         sectors_per_fat++;     ***/

    /* Now see how many tracks */
    num_tracks = (sectors_per_fat*2) + 33;

    /* If primary and drive 0, add in enough for system files */
    if ((type == c(PRIMARY)) && (cur_disk == c(0)))                 /* AC000 */
       BEGIN
        num_tracks = num_tracks + SYSTEM_FILE_SECTORS;
       END

     /* Handle upward rounding */                                                                            /* The problem with the IBM code is      */
     if (num_tracks%max_sector[cur_disk] != u(0))                                    /* that if num_tracks is < max_sector[cur_disk] */
         BEGIN                                                                                                /* the num_tracks becomes 0 due to the integer  */
         num_tracks = num_tracks + max_sector[cur_disk];    /* division and num_tracks will not be inc'd .  */
         END                                                                                                  /* This section of code overcomes that.     */

     /* Now convert to tracks */
     num_tracks = num_tracks/max_sector[cur_disk];

     /* SR; 9/30/89; The number of tracks above does not take into
        account the wasted track 0 which contains the partition info.
        If cur_head = 0, then the above calculation would cause the
        last track in the partition to be not verified */

     if ( cur_head == 0 )
             num_tracks++;

     golden_tracks = FALSE;

#if 0	/************* Commented out ********************/

     while (!golden_tracks)
        BEGIN

         for (i = u(0);i < num_tracks; i++)                         /* AC000 */
            BEGIN
             retry = c(0);                                          /* AC000 */
             do
                BEGIN
                 retry++;
                 /* Specify the operation */
                 regs.h.ah = uc(WRITE_DISK);                        /* AC000 */

                 /* Specify number of sectors */
                 regs.h.al = ((unsigned char)max_sector[cur_disk]);

                 /* Specify the start sectors */
                 regs.h.cl = uc(1);                                 /* AC000 */

                 /* Need to scramble CX so that sectors and cyl's are in INT 13 format */
                 if (cur_cyl > u(255))                              /* AC000 */
                    BEGIN
                     regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6));
                    END
                 regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;

                 /* Specify the disk */
                 regs.h.dl = ((unsigned char)cur_disk) + 0x80;

                 /* Specify the head */
                 regs.h.dh = cur_head;                              /* AC004 */

                 /* Point at the place to write */
                 regs.x.bx = FP_OFF(buffer_pointer);
                 segregs.es = FP_SEG(buffer_pointer);

                 /* write the track */
                 DiskIo(&regs,&regs,&segregs);            /* AC000 */

                END
             while (((regs.x.cflag & 1) == u(1)) && (retry != c(5))); /* AC000 */

#endif   /***************Commented out *****************************/

     while (!golden_tracks)
         {                               /* this allows resetting the starting cyl of the golden tracks */
         for (i = u(0);i < num_tracks; i++)
             {               /* this for loop is to write the number of golden tracks  AC000 */
             retry = c(0);                           /* AC000 */
             do
                 {                                       /* this do loop is for retries */
                 retry++;
                 regs.h.ah = uc(VERIFY_DISK);                          /* BC001 */ /* Specify the operation */
                 regs.h.al = (unsigned char)max_sector[cur_disk];              /* Specify number of sectors */
                 regs.h.cl = 1;  /* Specify the start sectors */ /* AC000 BC001 Scramble CX so that sectors and cyl's are in INT 13 format*/
                 if (cur_cyl > u(255))                                 /* AC000 */
                     regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6));
                 regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;
                 regs.h.dl = ((unsigned char)cur_disk) + 0x80;         /* Specify the disk */
                 regs.h.dh = cur_head;                                 /* Specify the head */   /* AC004 */
                 int86((int)DISK, &regs, &regs);                       /* BC001 */ /* verify the track */
                     retry_flg = regs.x.cflag & 1;                         /* BN001 */
                 }
             while ((retry_flg) && (retry != c(3)));               /* BN001 */ /* retry loop */

             /************************************************************/
             /* Check to see if cylinder was verified w/o errors.        */
             /************************************************************/

             if (!retry_flg)
                 {                                               /* BN001 */
             /*********************************************************/
             /* Cylinder verified correctly. So write boot sector     */
             /* and bump cylinder count, then go verify that cylinder.*/
             /* Do not pass the end of the partition free space.      */
             /*********************************************************/
                 retry = 0;
                 do
                     {
                     retry++;
                     regs.h.ah = uc(WRITE_DISK);                             /* BN001 */ /* Specify the operation */
                     regs.h.al = 1;                                          /* BN001 */ /* Write one sector only */
                     regs.h.cl = 1;                                          /* BN001 */ /* Specify the start sectors */ /* AC000 BC001 Need to scramble CX for INT 13 format */
                     if (cur_cyl > u(255))                                   /* BN001 */
                             regs.h.cl = regs.h.cl | ((unsigned char)((cur_cyl/256) << 6)); /* BN001 */
                     regs.h.ch = ((unsigned char)cur_cyl) & 0xFF;            /* BN001 */
                     regs.h.dl = ((unsigned char)cur_disk) + 0x80;           /* BN001 */ /* Specify the disk */
                     regs.h.dh = cur_head;                                   /* BN001 */ /* Specify the head */   /* AC004 */
                     regs.x.bx = FP_OFF(buffer_pointer);                     /* BN001 */ /* Point at the place to write */
                     segregs.es = FP_SEG(buffer_pointer);                    /* BN001 */
                     DiskIo(&regs,&regs,&segregs);                           /* BN001 */ /* write the track */
                     retry_flg = regs.x.cflag & 1;                         /* BN001 */
                     }
                 while ((retry_flg) && (retry != c(3)));                 /* BN001 */ /* retry loop */
                 }

             /* See if we had a good read */
             if (!retry_flg)                        /* AC000 */
                 BEGIN
                 golden_tracks = TRUE;
                 /* Get the next head */
                 cur_head++;

                 /* SR; 9/29/89; Head no. is pre-incremented and cannot
                    subtract 1 from max_head[cur_disk] */
                 if (cur_head == (uc(max_head[cur_disk] )))       /* AC004 */
                     BEGIN
                     /* Up to the next cylinder */
                     cur_head = uc(0);                              /* AC004 */
                     cur_cyl++;

                     /* Check to see if we've reached the end of the free_space*/
                     if (cur_cyl > free_space[pointer].end)
                         BEGIN
                         /* It is, so return with the cyl offset equal to the freespace */
                         return(free_space[pointer].space);
                         END
                     END
                 END
             else
                 BEGIN
                 /* Get out of the for loop, with a false flag */
                 golden_tracks = FALSE;

                 /* Bump up to the next cylinder boundary */
                 cur_cyl++;

                 /* SR; 9/29/89; To get out of the loop we have to
                    check if there have been enough golden tracks or
                    not. The setting of the flag as above will not
                    get us out of the loop. We return with the cyl
                    offset equal to the freespace to indicate that
                    this freespace cannot be used */

                 if ( cur_cyl > free_space[pointer].end )
                     return( free_space[pointer].space );

                 cur_head = uc(0);                                  /* AC004 */

                 /* Save the new verify start point */
                 verify_cyl = cur_cyl;

                 break;
                 END
             END  /* for num_tracks */
         } /*while !golden_tracks */

    /* All done, return the offset from original cyl to the new one */
    return(verify_cyl - free_space[pointer].start);
END


/*  */
char get_drive_parameters(drive)

unsigned char   drive;

BEGIN
    /* See how many drives there are */
    regs.h.ah = uc(DISK_INFO);                                      /* AC000 */
    regs.h.dl = drive;
    DiskIo(&regs,&regs,&segregs);                                   /* AC000 */

    /* See if any drives exist */
    if ((regs.h.dl == uc(0)) || ((regs.x.cflag & 1) == u(1)))       /* AC000 */
       BEGIN
        display(error_1);
        return(FALSE);
       END
    else
       BEGIN
        /* Save the number of drives */
        number_of_drives = regs.h.dl;
        if (number_of_drives > MAX_HDISK)
            number_of_drives = MAX_HDISK;
        return(TRUE);
       END
END

/*  */
char read_boot_record(cylinder,which_disk,which_head,which_sector)      /* AC000 */

unsigned        cylinder;
unsigned char   which_disk;
unsigned char   which_head;                                             /* AN000 */
unsigned char   which_sector;                                           /* AN000 */

BEGIN

    char far *buffer_pointer = boot_record;

    /* Setup read, always on a cylinder boundary */
    regs.h.ah = uc(READ_DISK);                                      /* AC000 */
    regs.h.al = uc(1);                                              /* AC000 */
    regs.h.dh = which_head;                                         /* AC000 */
    regs.h.cl = which_sector;                                       /* AC000 */

    /* Specify the disk */
    regs.h.dl = which_disk + 0x80;

    /* Need to scramble CX so that sectors and cyl's are in INT 13 format */

    if (cylinder > u(255))                                          /* AC000 */
       BEGIN
        regs.h.cl = regs.h.cl | ((char)((cylinder /256) << 6));
       END
    regs.h.ch = (unsigned char)(cylinder & 0xFF);

    /* Point at the place to write the boot record */
    regs.x.bx = FP_OFF(buffer_pointer);
    segregs.es = FP_SEG(buffer_pointer);

    /* read in the boot record */
    DiskIo(&regs,&regs,&segregs);                         /* AC000 */
    /* Check for error reading it */
    if ((regs.x.cflag & 1) != u(1))                                 /* AC000 */
       BEGIN
        return(TRUE);
       END
    else
       BEGIN
        /* Tell user there was an error */
        good_disk[which_disk] = FALSE;
        clear_screen(u(0),u(0),u(24),u(79));                        /* AC000 */
        return(FALSE);
       END
END

/*  */
void DiskIo(InRegs,OutRegs,SegRegs)
union   REGS    *InRegs;
union   REGS    *OutRegs;
struct  SREGS   *SegRegs;

BEGIN

/*C00    char    *WritePtr;  */

#ifdef DEBUG

    char    *WritePtr;  /*C00*/

    switch(InRegs->h.ah)
        {
        case 0:
        case 1:
        case 2:
        case 4:
        case 8:
        case 15:
        case 16:
            int86x((int)DISK,InRegs,OutRegs,SegRegs);                         /* AC000 */
            break;

        default:
            WritePtr = getenv("WRITE");
            if (strcmpi(WritePtr,"ON") != 0)
                BEGIN
                printf("\nDisallowing Disk I/O Request\n");
                printf("AX:%04X BX:%04X CX:%04X DX:%04X ES:%04X\n",
                        InRegs->x.ax,InRegs->x.bx,InRegs->x.cx,InRegs->x.dx,SegRegs->es);

                OutRegs->h.ah = (unsigned char) 0;
                OutRegs->x.cflag = (unsigned) 0;
                END
            else int86x((int)DISK,InRegs,OutRegs,SegRegs);

            break;

        }

#else

    int86x((int)DISK,InRegs,OutRegs,SegRegs);                         /* AC000 */

#endif

    return;

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\input.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/07/90  EGH  C03  Problem fixed - Ctrl-C allowed as input causing screen
*                      to scroll.  Fix is to use INT21 function 07h instead of
*                      08h.
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  03/08/90  EGH  C09  Problem fixed - user selected input difficult to read.
*                      Fix is to use hi-white on black or hi-white on blue,
*                      depending on the video mode, for user input.
*  03/20/90  EGH  C12  Problem fixed - if user enters an invalid partition
*                      size, recovery is awkward.  Fix is to modify user
*                      interface.  STR #2027
*  03/20/90  EGH  C13  Problem fixed - the cursor is in the wrong position
*                      when the "Press ESC to continue" message is displayed.
*                      Fix is to to determine cursor position based on
*                      input_row and input_col variables.  This also makes
*                      internationalization easier.
*  05/22/90  EGH  C16  Problem fixed - graphic characters were appearing in
*                      input fields when CTRL or ALT key combinations were
*                      pressed.  Fix is to to determine whether or not input
*                      is valid before displaying it.  Invalid input will
*                      result in a beep and error message.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "ctype.h"                                                      /* AN000 */
#include "string.h"                                                     /* AN000 */
#include "stdio.h"
#include "fdiskmsg.h"                                                   /* AN000 */
#include "doscall.h"                                                    /* AN000 */

/*  */
char get_num_input(input_default,max_num,row,col)

char   max_num;
unsigned        row;
unsigned        col;
char            input_default;

BEGIN

    char  input;

    /* SR;9/25/89; Initialize this on entry */
    char   default_used = FALSE;
    char   input_value;

    char            attribute;
    char far        *attribute_ptr = &attribute;
    char far *input_ptr = &input;

    if (mono_flag == TRUE)
/*C09   attribute = GRAY_ON_BLACK;  */
        attribute = HIWHITE_ON_BLACK; /*C09*/
    else
/*C09   attribute = WHITE_ON_BLUE;  */
        attribute = HIWHITE_ON_BLUE;  /*C09*/

    /* print default entry if there is one */
    if (input_default != c(NUL))                                        /* AC000 */

        BEGIN
        default_used = TRUE;
        /* position the cursor */
        VIOSETCURPOS(row,col,u(0));                                     /* AC000 */

        /* Display the default character */

        input = c(input_default+'0');
        VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
        END

    /* Assume bad input */
    valid_input = FALSE;

    /* Loop until we get good stuff */
    while (valid_input == FALSE)
        BEGIN

        /* position the cursor */
        VIOSETCURPOS(row,col,u(0));                                     /* AC000 */

        /* Flush the keyboard buffer and get the next pressed key */
        input = get_char_input();

        /* Do world trade get country information */
        input = dos_upper(input);                                       /* AN000 */

        /* Go handle different inputs */
        switch(input)
            BEGIN
            case ESC:
                BEGIN
                valid_input = TRUE;
                break;
                END

            case  CR:
                BEGIN
                /* Set the input to the default if there is one there */
                if (default_used)
                    BEGIN
                    if (input_default != c(NUL))
                        BEGIN
                        input_value = input_default+'0';
                        END
                    else
                        BEGIN
                        /* Make the enter look like a blank for error message */
                        input_value = c(' ');                           /* AC000 */
                        END
                    END
                /* See if it is digit and less or equal to max */
                if ( (isdigit(input_value))         &&
                     (input_value <= (max_num+'0')) &&
                     (input_value != c('0')) )
                    BEGIN
                    valid_input = TRUE;
                    input = input_value;
                    END
                else
                    BEGIN
                    if (isdigit(input_value))
                        BEGIN
                        /* Setup error message */
                        insert[0] = input_value;
                        insert[1] = c('1');                    /* AC000 */
                        insert[2] = c('-');                    /* AC000 */
                        insert[3] = max_num+'0';
                        display(error_23);
                        END
                    else
                        BEGIN
                        insert[0] = c('1');                    /* AC000 */
                        insert[1] = c('-');                    /* AC000 */
                        insert[2] = max_num+'0';
                        display(error_31);
                        END
                    END
                break;
                END

            default:
                BEGIN
                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
/*C16           if ( input != 0x03 )                                             */
/*C16               VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); */
/*C16           else                                                             */
/*C16               {                                                            */
/*C16               DOSBEEP( 900, 400 );                                         */
/*C16               input = c(' ');                                              */
/*C16               VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); */
/*C16               }                                                            */
                if ( (isdigit(input))         &&                        /*C16*/
                     (input <= (max_num+'0')) &&                        /*C16*/
                     (input != c('0')) )                                /*C16*/
                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
                else                                                    /*C16*/
                    {                                                   /*C16*/
                    if (isdigit(input))                                 /*C16*/
                        {                                               /*C16*/
                        /* Setup error message */                       /*C16*/
                        insert[0] = input;                              /*C16*/
                        insert[1] = c('1');                             /*C16*/
                        insert[2] = c('-');                             /*C16*/
                        insert[3] = max_num+'0';                        /*C16*/
                        display(error_23);                              /*C16*/
                        }                                               /*C16*/
                    else                                                /*C16*/
                        {                                               /*C16*/
                        insert[0] = c('1');                             /*C16*/
                        insert[1] = c('-');                             /*C16*/
                        insert[2] = max_num+'0';                        /*C16*/
                        display(error_31);                              /*C16*/
                        }                                               /*C16*/
                    input = c(' ');                                     /*C16*/
                    }                                                   /*C16*/
                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
                default_used = FALSE;
                input_value = input;
                break;
                END
            END
        END
     return(input);
END



/*  */

char get_yn_input(input_default,row,col)

unsigned        row;
unsigned        col;
char            input_default;

BEGIN

    char   input;
    char   default_used;
    char   input_value;

    char            attribute;
    char far        *attribute_ptr = &attribute;
    char far *input_ptr = &input;

    if (mono_flag == TRUE)
/*C09   attribute = GRAY_ON_BLACK;  */
        attribute = HIWHITE_ON_BLACK; /*C09*/
    else
/*C09   attribute = WHITE_ON_BLUE;  */
        attribute = HIWHITE_ON_BLUE;  /*C09*/

    /* print default entry if there is one */
    if (input_default != c(NUL))                                      /* AC000 */

        BEGIN
        default_used = TRUE;
        /* position the cursor */
        VIOSETCURPOS(row,col,u(0));                                   /* AC000 */

        /* Display the default character */
		 input = input_default;
		 VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0));
        END

    /* Assume bad input */
    valid_input = FALSE;

    /* Loop until we get good stuff */
    while (valid_input == FALSE)
        BEGIN

        /* position the cursor */
        VIOSETCURPOS(row,col,u(0));                                   /* AC000 */

        /* Flush the keyboard buffer and get the next pressed key */
        input = get_char_input();
        input = dos_upper(input);

        /* Go handle different inputs */
        switch(input)
            BEGIN
            case ESC:
                BEGIN
                valid_input = TRUE;
                break;
                END

            case  CR:
                BEGIN
                /* Set the input to the default if there is one there */
                if (default_used)
                    BEGIN
                    if (input_default != c(NUL))                        /* AC000 */
                        BEGIN
                        input_value = input_default;
                        END
                    else
                        BEGIN
                        internal_program_error();
                        END
                    END
                /* See if YES or NO */

                /* Do world trade get country information */
                input = check_yn_input(input_value);                    /* AN000 */

                if ((input == c(1)) || (input == c(0)))                 /* AC000 */
                    BEGIN
                    valid_input = TRUE;
                    END
                else
                    BEGIN
                    /* Setup error message */
                    insert[0] = c(Yes);                        /* AC000 AC011 */
                    insert[1] = c('-');                        /* AC000 */
                    insert[2] = c(No);                         /* AC000 AC011 */
                    display(error_31);
                    END
                break;
                END

            default:
                BEGIN
                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
/*C16           if ( input != 0x03 )                                             */
/*C16               VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); */
/*C16           else                                                             */
/*C16               {                                                            */
/*C16               DOSBEEP( 900, 400 );                                         */
/*C16               input = c(' ');                                              */
/*C16               VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); */
/*C16               }                                                            */
                if ((check_yn_input(input) == c(1)) ||                  /*C16*/
                    (check_yn_input(input) == c(0)))                    /*C16*/
                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
                else                                                    /*C16*/
                    {                                                   /*C16*/
                    /* Setup error message */                           /*C16*/
                    insert[0] = c(Yes);                                 /*C16*/
                    insert[1] = c('-');                                 /*C16*/
                    insert[2] = c(No);                                  /*C16*/
                    display(error_31);                                  /*C16*/
                    input = c(' ');                                     /*C16*/
                    }                                                   /*C16*/
                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
                default_used = FALSE;
                input_value = input;
                break;
                END
            END
         END
     return(input);
END


/*  */
char wait_for_ESC()

BEGIN
    char  input;

    clear_screen(u(24),u(0),u(24),u(79));                               /*C13*/
    display(menu_46);                                                   /*C13*/
    while (input != c(ESC))                                             /* AC000 */
        BEGIN
        /* position the cursor at the end of the ESC prompt */
/*C13   VIOSETCURPOS(u(24),u(39),u(0));  */                             /* AC000 */
        VIOSETCURPOS(input_row,input_col,u(0));                         /*C13*/

        /* Get input */
        input = get_char_input();

        END
    return(c(ESC));                                                     /* AC000 */
END




XFLOAT get_large_num_input(input_default,max_num,max_percent,input_message,prompt_location,error_message)

unsigned    input_default;                                              /* AC000 */
unsigned    max_num;
unsigned    max_percent;
char far   *input_message;
char far   *error_message;
unsigned   prompt_location;

BEGIN

    char           input;
    XFLOAT         large_input;                                         /* AC000 */
    char           default_used;
/*C12    unsigned long  very_big_input; */
    FLAG           enter_flag;                                          /*C12*/

    /* Assume bad input */
    valid_input = FALSE;

    /* Assume no input, and use default */
    default_used = TRUE;

    /* Assume ENTER key not pressed yet */                              /*C12*/
    enter_flag = FALSE;                                                 /*C12*/

    /* Initialize the input value */
    large_input = u(0);                                                 /* AC000 */

    /* Loop until we get good stuff */
    while (valid_input == FALSE)

        BEGIN
        /* position the cursor */
        VIOSETCURPOS(input_row,input_col,u(0));                     /* AC000 */

        /* Flush the keyboard buffer and get the next pressed key */

        input = get_char_input();

        /* Go handle different inputs */
        switch(input)
            BEGIN
            case ESC:
                valid_input = TRUE;
                large_input = ((unsigned)(ESC_FLAG));
                break;

            case CR:
                BEGIN
                if (PercentFlag)
                    BEGIN
                    /* Set the input to the default if there is one there and nothing else entered */
                    if ((input_default != u(NUL)) && (default_used))  /* AC000 */
                        large_input = input_default;
                    /* See if input is less or equal to max_value */
                    if (large_input <= max_percent)
                        BEGIN
                        if (large_input != u(0))
                            valid_input = TRUE;
                        else
                            display(error_28);
                        END
                    else
                        display(error_message);
                    END
                else
                    BEGIN
                    /* Set the input to the default if there is one there and nothing else entered */
                    if ((input_default != u(NUL)) && (default_used))  /* AC000 */
                        large_input = input_default;
                    /* See if input is less or equal to max_value */
                    if (large_input <= max_num)
                        BEGIN
                        if (large_input != u(0))
                            valid_input = TRUE;
                        else
                            display(error_28);
                        END
                    else
                        display(error_message);
                    END
                enter_flag = TRUE;                                      /*C12*/
                break;
                END

            case BACKSPACE:
                if (PercentFlag)
                    PercentFlag = (FLAG)FALSE;                      /* AN000 */
                else
                    large_input = large_input / 10;

                /* Indicate that we are not using the default */
                default_used = FALSE;
                sprintf(&insert[prompt_location],"%4.0d",large_input);  /* AN000 */
                display(input_message);
                break;

            case PERCENT:                                           /* AN000 */

                if (PercentFlag == (FLAG)FALSE)
                    BEGIN                                           /* AN000 */
                    PercentFlag = (FLAG)TRUE;                       /* AN000 */
                    /* Round down if > 999.9 */
                    if (large_input > u(999))                       /* AN000 */
                        large_input = (large_input%1000);           /* AN000 */
                    sprintf(&insert[prompt_location],"%3.0d%%",large_input);  /* AN000 */
                    /* Indicate that we are not using the default */
                    default_used = FALSE;                           /* AN000 */
                    display(input_message);                         /* AN000 */
                    END                                             /* AN000 */
                else
                    display(error_33);                              /* AN000 */

                break;                                              /* AN000 */

            case '0':                                                   /*C12*/
            case '1':                                                   /*C12*/
            case '2':                                                   /*C12*/
            case '3':                                                   /*C12*/
            case '4':                                                   /*C12*/
            case '5':                                                   /*C12*/
            case '6':                                                   /*C12*/
            case '7':                                                   /*C12*/
            case '8':                                                   /*C12*/
            case '9':                                                   /*C12*/
                if (enter_flag == TRUE)                                 /*C12*/
                    BEGIN                                               /*C12*/
                    large_input = u(0);                                 /*C12*/
                    default_used = FALSE;                               /*C12*/
                    PercentFlag = FALSE;                                /*C12*/
                    enter_flag = FALSE;                                 /*C12*/
                    END                                                 /*C12*/
                if ((PercentFlag == FALSE) && (large_input < 1000))     /*C12*/
                    BEGIN                                               /*C12*/
                    /* Add this digit in */                             /*C12*/
                    large_input = (large_input * 10) +                  /*C12*/
                                  (XFLOAT)(input - '0');                /*C12*/
                                                                        /*C12*/
                    /* Put it in the message */                         /*C12*/
                    number_in_msg((XFLOAT)large_input,prompt_location); /*C12*/
                    display(input_message);                             /*C12*/
                                                                        /*C12*/
                    /* Indicate that we are not using the default */    /*C12*/
                    default_used = FALSE;                               /*C12*/
                    PercentFlag = (FLAG)FALSE;                          /*C12*/
                    END                                                 /*C12*/
                else                                                    /*C12*/
                    display(error_33);                                  /*C12*/
                break;                                                  /*C12*/
                                                                        /*C12*/
            default:                                                    /*C12*/
                if ((PercentFlag == FALSE) && (large_input < 1000))     /*C12*/
                    BEGIN                                               /*C12*/
                    /* Setup error message */                           /*C12*/
                    insert[0] = c('0');                                 /*C12*/
                    insert[1] = c('-');                                 /*C12*/
                    insert[2] = c('9');                                 /*C12*/
                    display(error_31);                                  /*C12*/
                    END                                                 /*C12*/
                else                                                    /*C12*/
                    display(error_33);                                  /*C12*/

#if 0                                                                   /*C12*/
            default:
                BEGIN

                /* Make sure it is numerical input */

                if ( (isdigit(input)) && ((!PercentFlag) || (default_used)) )     /* AN000 */
                    BEGIN
                    /* Add this digit in */
                    very_big_input= (((unsigned long)(large_input)) * 10) + ((unsigned long)input - '0');   /* AC000 */

                    /* Round down if > 9999.9 */
                    large_input = ((unsigned)(very_big_input%10000));

                    /* Put it in the message */
                    number_in_msg((XFLOAT)large_input,prompt_location);  /* AN000 */
                    display(input_message);

                    /* Indicate that we are not using the default */
                    default_used = FALSE;
                    PercentFlag = (FLAG)FALSE;                      /* AN000 */
                    END
                else
                    BEGIN
                    if (!PercentFlag)                               /* AN000 */
                        BEGIN                                       /* AN000 */
                        /* Setup error message */
                        insert[0] = c('0');                         /* AC000 */
                        insert[1] = c('-');                         /* AC000 */
                        insert[2] = c('9');                         /* AC000 */
                        display(error_31);
                        END                                         /* AN000 */
                    else                                            /* AN000 */
                        BEGIN                                       /* AN000 */
                        display(error_33);                          /* AN000 */
                        END                                         /* AN000 */
                    END
                END
#endif                                                                  /*C12*/
            END
        END

    return(large_input);
END


/*  */
char get_alpha_input(low_letter,high_letter,row,col,error_low_letter,error_high_letter)

unsigned     row;
unsigned     col;
char         low_letter;
char         high_letter;
char         error_low_letter;
char         error_high_letter;

BEGIN

    char   input;
    char   default_used;
    char   input_value;

    char            attribute;
    char far        *attribute_ptr = &attribute;
    char far *input_ptr = &input;

    if (mono_flag == TRUE)
/*C09   attribute = GRAY_ON_BLACK;  */
        attribute = HIWHITE_ON_BLACK; /*C09*/
    else
/*C09   attribute = WHITE_ON_BLUE;  */
        attribute = HIWHITE_ON_BLUE;  /*C09*/

    /* Assume bad input */
    valid_input = FALSE;

    /* Init input_value to something non-alpha */
    input_value = c(0);                                                 /* AC000 */

    /* Loop until we get good stuff */
    while (valid_input == FALSE)
        BEGIN

        /* position the cursor */
        VIOSETCURPOS(row,col,u(0));                                     /* AC000 */

        /* Flush the keyboard buffer and get the next pressed key */
        input = get_char_input();
        input = dos_upper(input);

        /* Go handle different inputs */
        switch(input)
            BEGIN
            case ESC:
                BEGIN
                valid_input = TRUE;
                break;
                END

            case  CR:
                BEGIN
                /* See if it is digit and between given letters*/
                /* Do world trade get country information */
                input = dos_upper(input_value);                         /* AN000 */
                if ((isalpha(input))       &&
                    (input >= low_letter)  &&
                    (input <= high_letter) &&
                    (isalpha(input_value)))
                    BEGIN
                    valid_input = TRUE;
                    END
                else
                    BEGIN
                    if (isalpha(input_value))
                        BEGIN
                        /* Setup error message */
                        insert[0] = input;
                        insert[1] = error_low_letter;
                        insert[2] = c('-');                             /* AC000 */
                        insert[3] = error_high_letter;
                        display(error_23);
                        END
                    else
                        BEGIN
                        insert[0] = error_low_letter;
                        insert[1] = c('-');                             /* AC000 */
                        insert[2] = error_high_letter;
                        display(error_31);
                        END
                    END
                break;
                END

            default:
                BEGIN
                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
/*C16           if ( input != 0x03 )                                             */
/*C16               VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); */
/*C16           else                                                             */
/*C16               {                                                            */
/*C16               DOSBEEP( 900, 400 );                                         */
/*C16               input = c(' ');                                              */
/*C16               VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); */
/*C16               }                                                            */
                if ((isalpha(input))       &&                           /*C16*/
                    (dos_upper(input) >= low_letter)  &&                /*C16*/
                    (dos_upper(input) <= high_letter))                  /*C16*/
                    clear_screen(u(23),u(0),u(23),u(79));               /*C16*/
                else                                                    /*C16*/
                    {                                                   /*C16*/
                    if (isalpha(input))                                 /*C16*/
                        {                                               /*C16*/
                        /* Setup error message */                       /*C16*/
                        insert[0] = input;                              /*C16*/
                        insert[1] = error_low_letter;                   /*C16*/
                        insert[2] = c('-');                             /*C16*/
                        insert[3] = error_high_letter;                  /*C16*/
                        display(error_23);                              /*C16*/
                        }                                               /*C16*/
                    else                                                /*C16*/
                        {                                               /*C16*/
                        insert[0] = error_low_letter;                   /*C16*/
                        insert[1] = c('-');                             /*C16*/
                        insert[2] = error_high_letter;                  /*C16*/
                        display(error_31);                              /*C16*/
                        }                                               /*C16*/
                    input = c(' ');                                     /*C16*/
                    }                                                   /*C16*/
                VIOWRTCHARSTRATT(input_ptr,u(1),row,col,attribute_ptr,u(0)); /*C16*/
                default_used = FALSE;
                input_value = input;
                break;
                END
            END
        END
    return(input);
END


/*  */
char    get_char_input()

BEGIN
    regs.h.ah = uc(0x0C);                                           /* AC000 */
    regs.h.al = uc(0x07);                                           /* AC000 */
    intdos(&regs,&regs);
    if (regs.h.al == uc(0))                                         /* AC000 */
        BEGIN
        DOSBEEP(u(900),u(400));                                     /* AC000 */
        END
    return(((char)(regs.h.al)));

END



/*  */                                                                 /* AN000 */
                                                                        /* AN000 */
void get_string_input(StartRow,StartCol,string_ptr)                     /* AN000 */
                                                                        /* AN000 */
unsigned        StartRow;                                               /* AN000 */
unsigned        StartCol;                                               /* AN000 */
char far        *string_ptr;                                            /* AN000 */
                                                                        /* AN000 */
BEGIN                                                                   /* AN000 */

    #define MAX_STRING_INPUT_LENGTH 11
                                                                        /* AN000 */
    unsigned char   input;                                              /* AN000 */
/*C00     char   input_value; */                                                    /* AN000 */
    char   far *WorkingPtr;                                             /* AN000 */
    char   far *DeletePtr;                                              /* AN000 */
    char   Done;                                                        /* AN000 */
    unsigned        Row;                                                /* AN000 */
    unsigned        Col;                                                /* AN000 */
/*C00     int             i;  */                                                    /* AN000 */
                                                                        /* AN000 */

    char            attribute;
    char far        *attribute_ptr = &attribute;
    char far *input_ptr = &input;

    if (mono_flag == TRUE)
/*C09   attribute = GRAY_ON_BLACK;  */
        attribute = HIWHITE_ON_BLACK; /*C09*/
    else
/*C09   attribute = WHITE_ON_BLUE;  */
        attribute = HIWHITE_ON_BLUE;  /*C09*/

                                                                        /* AN000 */
    WorkingPtr = string_ptr;                                            /* AN000 */

    Row = StartRow;                                                     /* AN000 */
    Col = StartCol;                                                     /* AN000 */
    VIOSETCURPOS(Row,Col,u(0));                                         /* AN000 */

    while(*WorkingPtr != c(NUL))                                        /* AN000 */
        BEGIN                                                           /* AN000 */
        VIOWRTCHARSTRATT(WorkingPtr,u(1),Row,Col,attribute_ptr,u(0));
        WorkingPtr++;
        Col++;                                                          /* AN000 */
        VIOSETCURPOS(Row,Col,u(0));                                     /* AN000 */
        END                                                             /* AN000 */

    regs.h.ah = uc(12);                                                 /* AN000 */
/*C03    regs.h.al = uc(8); */                                                 /* AN000 */
    regs.h.al = uc(7); /*C03*/
    intdos(&regs,&regs);                                                /* AN000 */
    input = regs.h.al;                                                  /* AN000 */

    /* Loop until we get good stuff */                                  /* AN000 */
    Done = FALSE;                                                       /* AN000 */
    while (!Done)                                                       /* AN000 */
        BEGIN                                                           /* AN000 */

        /* Go handle different inputs */

        if (input < 32)                                                 /* AN000 */
            BEGIN                                                       /* AN000 */
            switch(input)                                               /* AN000 */
                BEGIN                                                   /* AN000 */
                case ESC:                                               /* AN000 */
                    Done=TRUE;                                          /* AN000 */
                    *string_ptr++ = c(ESC);                             /* AN000 */
                    *string_ptr++ = c('\0');                            /* AN000 */
                    break;                                              /* AN000 */

                case  CR:                                               /* AN000 */
                    Done=TRUE;                                          /* AN000 */
                    break;                                              /* AN000 */

                case 8: /* backspace */                                 /* AN000 */
                    if (Col > StartCol)                                 /* AN000 */
                        BEGIN                                           /* AN000 */
                        WorkingPtr--;                                   /* AN000 */
                        Col--;                                          /* AN000 */
                        VIOSETCURPOS(Row,Col,u(0));                     /* AN000 */
							  input = c(' ');
                        VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
                        VIOSETCURPOS(Row,Col,u(0));                     /* AN000 */
                        DeletePtr = WorkingPtr;                         /* AN000 */
                        while ( *(DeletePtr+1) != c('\0')  )            /* AN000 */
                            BEGIN                                       /* AN000 */
                            *DeletePtr = *(DeletePtr+1);                /* AN000 */
                            VIOWRTCHARSTRATT(DeletePtr,u(1),Row,Col,attribute_ptr,u(0));
                            DeletePtr++;                                /* AN000 */
                            END                                         /* AN000 */
                        *DeletePtr = c('\0');                           /* AN000 */
							  input = c(' ');
                        VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col+1,attribute_ptr,u(0));
                        VIOSETCURPOS(Row,Col,u(0));                     /* AN000 */
                        END                                             /* AN000 */
                    else DOSBEEP(u(900),u(400));                        /* AN000 */
                break;                                                  /* AN000 */

                case  0:                                                /* AN000 */
/*C03                    regs.h.ah = uc(0x08); */                              /* AN000 */
                    regs.h.ah = uc(0x07); /*C03*/
                    intdos(&regs,&regs);                                /* AN000 */
                    input = regs.h.al;                                  /* AN000 */
                    switch(input)                                       /* AN000 */
                        BEGIN                                           /* AN000 */
                        case 71: /* HOME */                             /* AN000 */
                            WorkingPtr = string_ptr;                    /* AN000 */
                            Row = StartRow;                             /* AN000 */
                            Col = StartCol;                             /* AN000 */
                            VIOSETCURPOS(Row,Col,u(0));                 /* AN000 */
                            break;                                      /* AN000 */

                        case 79: /* END  */                             /* AN000 */
                            while (*WorkingPtr != c('\0') )             /* AN000 */
                                BEGIN                                   /* AN000 */
                                WorkingPtr++;                           /* AN000 */
                                Col++;                                  /* AN000 */
                                VIOSETCURPOS(Row,Col,u(0));             /* AN000 */
                                END                                     /* AN000 */
                            break;                                      /* AN000 */


                        case 75: /* Cursor Left */                      /* AN000 */
                            if (Col > StartCol)                         /* AN000 */
                                BEGIN                                   /* AN000 */
                                WorkingPtr--;                           /* AN000 */
                                Col--;                                  /* AN000 */
                                VIOSETCURPOS(Row,Col,u(0));             /* AN000 */
                                END                                     /* AN000 */
                            else DOSBEEP(u(900),u(400));                /* AN000 */
                            break;                                      /* AN000 */


                        case 77: /* Cursor Right */                     /* AN000 */
                            if ( *WorkingPtr != c('\0') )               /* AN000 */
                                BEGIN                                   /* AN000 */
                                WorkingPtr++;                           /* AN000 */
                                Col++;                                  /* AN000 */
                                VIOSETCURPOS(Row,Col,u(0));             /* AN000 */
                                END                                     /* AN000 */
                            else DOSBEEP(u(900),u(400));                /* AN000 */
                            break;                                      /* AN000 */


                        default:                                        /* AN000 */
                            DOSBEEP(u(900),u(400));                     /* AN000 */
                            break;                                      /* AN000 */

                        END                                             /* AN000 */
                    break;                                              /* AN000 */

                default:                                                /* AN000 */
                        DOSBEEP(u(900),u(400));                         /* AN000 */
                        break;                                          /* AN000 */
                END                                                     /* AN000 */

            END                                                         /* AN000 */
         else     /* input is >= 32 */                                  /* AN000 */
            BEGIN                                                       /* AN000 */
            input = dos_upper(input);                                   /* AN000 */
            if ( (strchr(".\"/\\[]:|<>+=;,",input) == NULL) &&
                 (Col < StartCol + MAX_STRING_INPUT_LENGTH)    )        /* AN000 */
                BEGIN                                                   /* AN000 */
                /* SR; 10/2/89; If Ctrl-C, display blank and beep */
                if ( input != 0x03 )
                    VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
                else
                    {
                    DOSBEEP( 900, 400 );
                    input = c(' ');
                    VIOWRTCHARSTRATT(input_ptr,u(1),Row,Col,attribute_ptr,u(0));
                    }
                *WorkingPtr = input;                                    /* AN000 */
                *(WorkingPtr+1) = c('\0');                              /* AN000 */
                if (Col < (StartCol + MAX_STRING_INPUT_LENGTH - 1) )    /* AN000 */
                    BEGIN                                               /* AN000 */
                    Col++;                                              /* AN000 */
                    WorkingPtr++;                                       /* AN000 */
                    END                                                 /* AN000 */
                VIOSETCURPOS(Row,Col,u(0));                             /* AN000 */
                END                                                     /* AN000 */
            else DOSBEEP(u(900),u(400));                                /* AN000 */
            END                                                         /* AN000 */

        if (!Done)                                                      /* AN000 */
            BEGIN                                                       /* AN000 */
            /* Get a character */                                       /* AN000 */
/*C03            regs.h.ah = uc(0x08); */                                    /* AN000 */
            regs.h.ah = uc(0x07); /*C03*/
            intdos(&regs,&regs);                                        /* AN000 */
            input = regs.h.al;                                          /* AN000 */
            END                                                         /* AN000 */
        END                                                             /* AN000 */

    return;                                                             /* AN000 */
END                                                                     /* AN000 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\fdparse.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  05/23/90  EGH  C18  Added support for /MBR switch to update the master boot
*                      record.
*  01/09/91  EGH  C34  Added support for fixed disks greater than 4G.
*  01/09/91  EGH  C36  Added code to support 8 fixed disks.
*
******************************************************************************/
#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "parse.h"                                                      /* AN000 */
#include "string.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "msgret.h"                                                     /* AN000 */

void DisplayOptionsExit(void);
void exit(int);

/*  */
/******************************************************************************/
/*Routine name:  PARSE_COMMAND_LINE                                           */
/******************************************************************************/
/*                                                                            */
/*Description:   Sets up flags, preloads messages, and parses the command     */
/*               line for switchs.                                            */
/*                                                                            */
/*Called Procedures:                                                          */
/*                                                                            */
/*Change History: Created        5/30/87         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/


char parse_command_line(argc,argv)                                      /* AN000 */

char *argv[];                                /* array of pointer arguments AN000 */
int  argc;

BEGIN                                                                   /* AN000 */


        char    cmd_line[128];                                          /* AN000 */
        char    finished;                                               /* AN000 */
        int     i;                                                      /* AN000 */
        char    parse_good;                                             /* AN000 */
        char    far *cmdline;

		  argc;	/* defeat warning messages */
		  argv;

		  parse_init();                                                   /* AN000 */

        /* Initialize parse_flag to true and don't change unless error */
        parse_good = TRUE;                                              /* AN000 */

        regs.h.ah = (unsigned char) 0x62;
        intdosx(&regs, &regs, &segregs);

        FP_OFF(cmdline) = 0x81;
        FP_SEG(cmdline) = regs.x.bx;

        i = 0;
        while ( *cmdline != (char) '\x0d' ) cmd_line[i++] = *cmdline++;
        cmd_line[i++] = (char) '\x0d';
        cmd_line[i++] = (char) '\0';

        regs.x.si = (unsigned)cmd_line;                                 /* AN000 make DS:SI point to source */
        regs.x.cx = u(0);                                               /* AN000 operand ordinal (whatever that means) */
        regs.x.dx = u(0);                                               /* AN000 operand ordinal (whatever that means) */
        regs.x.di = (unsigned)&p_p;                                     /* AN000 address of parm list */
        Parse_Ptr = (unsigned)cmd_line;                                 /* AN010 */
        regs.x.si = (unsigned)cmd_line;                                 /* AN010 */

        finished = FALSE;
        while ( !finished )                                            /* AN000 */
         BEGIN                                                         /* AN000 */

          Parse_Ptr = regs.x.si;                                       /* AN010  point to next parm       */
          parse(&regs,&regs);                                          /* AN000 Call DOS PARSE service routines*/

          if (regs.x.ax == u(NOERROR))                                 /* AN000 If there was an error*/
             BEGIN
              if (regs.x.dx == (unsigned)&p_buff)                      /* AN000 */
                check_disk_validity();                                 /* AN000 It's a drive letter */

              if (regs.x.dx == (unsigned)&sp_buff)                     /* AN000 */
                process_switch();                                      /* AN000 It's a switch*/
             END
          else
             BEGIN
              if (regs.x.ax == u(0xffff))
                 finished = TRUE;                                      /* AN000 Then we are done*/
              else
                BEGIN
                 Parse_msg(regs.x.ax,STDERR,Parse_err_class);          /* AN010  */
                 parse_good = FALSE;
                 finished = TRUE;                                      /* AN000 Then we are done*/
                END
              END
          END /* End WHILE */                                          /* AN000 */

        return(parse_good);                                             /* AN000 Return to caller*/

END     /* end parser */                                                /* AN000 */


/*  */
/******************************************************************************/
/*Routine name:  INIT_PARSE                                                   */
/******************************************************************************/
/*                                                                            */
/*Description:   Sets up ALL VALUES AND STRUCTS FOR PARSER.                   */
/*                                                                            */
/*Called Procedures:                                                          */
/*                                                                            */
/*Change History: Created        6/15/87         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/


void parse_init()                                                       /* AN000 */

BEGIN                                                                   /* AN000 */


  primary_flag            = FALSE;                                      /* AN000 */
  extended_flag           = FALSE;                                      /* AN000 */
  logical_flag            = FALSE;                                      /* AN000 */
  disk_flag               = FALSE;                                      /* AN000 */
  quiet_flag              = FALSE;                                      /* AN000 */

  status_flag             = FALSE;
  mbr_flag                = FALSE;                                      /*C18*/

  p_p.p_parmsx_ptr        = (unsigned)&p_px;                            /* AN000 Address of extended parm list */
  p_p.p_num_extra         = uc(1);                                      /* AN000 */
  p_p.p_len_extra_delim   = uc(1);                                      /* AN000 */
  p_p.p_extra_delim       = c(SEMICOLON);                               /* AN000 */

  p_px.p_minp             = uc(0);                                      /* AN000 1 required positional */
  p_px.p_maxp             = uc(1);                                      /* AN000 1 maximum positionals */
  p_px.p_con1_ptr         = (unsigned)&p_con;                           /* AN000 pointer to next control blk */
  p_px.p_maxs             = uc(5);  /* 4 to 5; 3 to 4; SR: Changed from 2 to 3 */        /* AN000 number of switches */
  p_px.p_swi1_ptr         = (unsigned)&p_swi1;                          /* AN000 pointer to next control blk */
  p_px.p_swi2_ptr         = (unsigned)&p_swi2;                          /* AN000 pointer to next control blk */

  p_px.p_swi3_ptr         = (unsigned)&p_swi3;
  p_px.p_swi4_ptr         = (unsigned)&p_swi4;
  p_px.p_swi5_ptr         = (unsigned)&p_swi5;                          /*C18*/

  p_px.p_maxk             = uc(NOVAL);                                  /* AN000 no keywords */

  p_con.p_match_flag     = u(0x8001);                                   /* AN000 DRIVE NUMBER 1 OR 2 optional */
  p_con.p_function_flag  = u(0x0000);                                   /* AN000 DO NOTHING FOR FUNCTION FLAG */
  p_con.p_buff1_ptr      = (unsigned)&p_buff;                           /* AN000 */
  p_con.p_val1_ptr       = (unsigned)&p_val;                            /* AN000 */
  p_con.p_nid            = uc(0);                                       /* AN000 */

  p_swi1.sp_match_flag    = u(0x8000);                                   /* AN000 Optional (switch) */
  p_swi1.sp_function_flag = u(0x0000);                                   /* AN000 DO NOTHING FOR FUNCTION FLAG */
  p_swi1.sp_buff1_ptr     = (unsigned)&sp_buff;                          /* AN000 */
  p_swi1.sp_val1_ptr      = (unsigned)&sp_val;                           /* AN000 */
  p_swi1.sp_nid           = uc(3);                                       /* AN000 3 switches allowed */
  strcpy((char *) p_swi1.sp_switch1,PRI);                                /* AN000 /a switch */
  strcpy((char *) p_swi1.sp_switch2,EXT);                                /* AN000 /a switch */
  strcpy((char *) p_swi1.sp_switch3,LOG);                                /* AN000 /a switch */

  p_swi2.sp_match_flag    = u(0x0001);                                   /* AN000 Optional (switch) */
  p_swi2.sp_function_flag = u(0x0000);                                   /* AN000 DO NOTHING FOR FUNCTION FLAG */
  p_swi2.sp_buff1_ptr     = (unsigned)&sp_buff;                          /* AN000 */
  p_swi2.sp_val1_ptr      = (unsigned)NOVAL;                             /* AN000 */
  p_swi2.sp_nid           = uc(1);                                       /* AN000 3 switches allowed */
  strcpy((char *) p_swi2.sp_switch4,QUIET);                                /* AN000 /a switch */

  p_swi3.sp_match_flag    = u(0x0001);
  p_swi3.sp_function_flag = u(0x0000);
  p_swi3.sp_buff1_ptr     = (unsigned)&sp_buff;
  p_swi3.sp_val1_ptr      = (unsigned)NOVAL;
  p_swi3.sp_nid           = uc(1);
  strcpy((char *) p_swi3.sp_switch5,STATUS);

  p_swi4.sp_match_flag    = u(0x0000);
  p_swi4.sp_function_flag = u(0x0000);
  p_swi4.sp_buff1_ptr     = (unsigned)&sp_buff;
  p_swi4.sp_val1_ptr      = (unsigned)NOVAL;
  p_swi4.sp_nid           = uc(1);
  strcpy((char *) p_swi4.sp_switch6,OPTIONS);

  p_swi5.sp_match_flag    = u(0x0001);                                  /*C18*/
  p_swi5.sp_function_flag = u(0x0000);                                  /*C18*/
  p_swi5.sp_buff1_ptr     = (unsigned)&sp_buff;                         /*C18*/
  p_swi5.sp_val1_ptr      = (unsigned)NOVAL;                            /*C18*/
  p_swi5.sp_nid           = uc(1);                                      /*C18*/
  strcpy((char *) p_swi5.sp_switch7,MBR);                               /*C18*/

  p_val.p_values         =  uc(1);                                      /* AN000 - Number of values items returned */
  p_val.p_range          =  uc(1);                                      /* AN000 - Number of ranges */
  p_val.p_range_one      =  uc(1);                                      /* AN000 - range number one */
  p_val.p_low_range      =  ul(1);                                      /* AN000 - low value for range */
/*C36  p_val.p_high_range     =  ul(7); *//*SR; Changed from 2 to 7 */         /* AN000 - high value for range */
  p_val.p_high_range     =  ul(MAX_HDISK);                              /*C36*/         /* AN000 - high value for range */

  sp_val.p_values      =  uc(1);                                        /* AN000 - Number of values items returned */
  sp_val.p_range       =  uc(1);                                        /* AN000 - Number of ranges */
  sp_val.p_range_one   =  uc(1);                                        /* AN000 - range number one */
  sp_val.p_low_range   =  ul(1);                                        /* AN000 - low value for range */
/*C34  sp_val.p_high_range  =  ul(4000); */                                    /* AN000 - high value for range */
  sp_val.p_high_range  =  ul(8064); /* max disk size=7.875GB=8064MB */  /*C34*/

  return;                                                               /* AN000 */

END
                                                                        /* AN000 */
/*  */
/******************************************************************************/
/*Routine name:  CHECK_DISK_VALIDITY                                          */
/******************************************************************************/
/*                                                                            */
/*Description:   Checks the return buffer from parse for the positional       */
/*               value to be equal to 0 or 1.                                 */
/*                                                                            */
/*Called Procedures:                                                          */
/*                                                                            */
/*Change History: Created        6/18/87         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/


void check_disk_validity()                                              /* AN000 */

BEGIN                                                                   /* AN000 */

        disk_flag = (FLAG)TRUE;                                         /* AN000 */
        cur_disk_buff = ((char)p_buff.p_value - 1);                     /* AN000 */
        return;                                                         /* AN000 */
END                                                                     /* AN000 */

/*  */
/******************************************************************************/
/*Routine name:  PROCESS_SWITCH                                               */
/******************************************************************************/
/*                                                                            */
/*Description:   This function looks at the return buffer of the parse and    */
/*               determins the switch, places value in buffer, and sets       */
/*               flag for specific switch.                                    */
/*                                                                            */
/*Called Procedures:                                                          */
/*                                                                            */
/*Change History: Created        6/18/87         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/


void process_switch()                                                   /* AN000 */

BEGIN                                                                   /* AN000 */


       BEGIN                                                            /* AN000 */
           if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch1)        /* AN000 */
            BEGIN                                                       /* AN000 */
             primary_flag = (FLAG)TRUE;                                 /* AN000 */
             primary_buff = (unsigned)sp_buff.p_value;                  /* AN000 */
            END                                                         /* AN000 */

           if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch2)        /* AN000 */
            BEGIN                                                       /* AN000 */
             extended_flag = (FLAG)TRUE;                                /* AN000 */
             extended_buff = (unsigned)sp_buff.p_value;                 /* AN000 */
            END                                                         /* AN000 */

           if (sp_buff.p_synonym == (unsigned)p_swi1.sp_switch3)        /* AN000 */
            BEGIN                                                       /* AN000 */
             logical_flag = (FLAG)TRUE;                                 /* AN000 */
             logical_buff = (unsigned)sp_buff.p_value;                  /* AN000 */
            END                                                         /* AN000 */

           if (sp_buff.p_synonym == (unsigned)p_swi2.sp_switch4)        /* AN000 */
            BEGIN                                                       /* AN000 */
             quiet_flag = (FLAG)TRUE;                                   /* AN000 */
            END                                                         /* AN000 */

           if (sp_buff.p_synonym == (unsigned)p_swi3.sp_switch5)
            BEGIN
             status_flag = (FLAG)TRUE;
            END

           if (sp_buff.p_synonym == (unsigned)p_swi4.sp_switch6)
            BEGIN
             DisplayOptionsExit();
            END

           if (sp_buff.p_synonym == (unsigned)p_swi5.sp_switch7)        /*C18*/
            BEGIN                                                       /*C18*/
             mbr_flag = (FLAG)TRUE;                                     /*C18*/
            END                                                         /*C18*/

       END                                                              /* AN000 */
        return;                                                         /* AN000 Return to caller*/
END     /* end parser */                                                /* AN000 */

/************************************************************************/                                                       /* ;an000; */
/* Parse_Message                - This routine will print only those    */
/*                                messages that require 1 replaceable   */
/*                                parm.                                 */
/*                                                                      */
/*      Inputs  : Msg_Num       - number of applicable message          */
/*                Handle        - display type                          */
/*                Message_Type  - type of message to display            */
/*                Replace_Parm  - pointer to parm to replace            */
/*                                                                      */
/*      Outputs : message                                               */
/*                                                                      */
/*      Date    : 03/28/88                                              */
/*      Version : DOS 4.00                                              */
/************************************************************************/

void Parse_msg(Msg_Num,Handle,Message_Type)                             /* AN010 */
                                                                        /* AN010 */
int             Msg_Num;                                                /* AN010 */
int             Handle;                                                 /* AN010 */
unsigned char   Message_Type;                                           /* AN010 */

BEGIN                                                                   /* AN010 */
char    far *Cmd_Ptr;                                                   /* AN010 */


        BEGIN                                                           /* AN010 */
        segread(&segregs);                                              /* AN010 */
        FP_SEG(Cmd_Ptr) = segregs.ds;                                   /* AN010 */
        FP_OFF(Cmd_Ptr) = regs.x.si;                                    /* AN010 */
        *Cmd_Ptr        = '\0';                                         /* AN010 */

        FP_SEG(sublistp[0].value) = segregs.ds;                         /* AN010 */
        FP_OFF(sublistp[0].value) = Parse_Ptr;                          /* AN010 */
        sublistp[0].size      = Sublist_Length;                         /* AN010 */
        sublistp[0].reserved  = Reserved;                               /* AN010 */
        sublistp[0].id        = 0;                                      /* AN010 */
        sublistp[0].flags     = Char_Field_ASCIIZ+Left_Align;           /* AN010 */
        sublistp[0].max_width = 80;                                     /* AN010 */
        sublistp[0].min_width = 01;                                     /* AN010 */
        sublistp[0].pad_char  = Blank;                                  /* AN010 */

        regs.x.ax = Msg_Num;                                            /* AN010 */
        regs.x.bx = Handle;                                             /* AN010 */
        regs.x.cx = SubCnt1;                                            /* AN010 */
        regs.h.dl = No_Input;                                           /* AN010 */
        regs.h.dh = Message_Type;                                       /* AN010 */
        regs.x.si = (unsigned int)&sublistp[0];                         /* AN010 */
        sysdispmsg(&regs,&regs);                                        /* AN010 */
        END                                                             /* AN010 */
        return;                                                         /* AN010 */
END                                                                     /* AN010 */


/************************************************************************/                                                       /* ;an000; */
/* DisplayOptionsExit           - Displays the options help message     */
/*                                lines onto standard output, and then  */
/*                                exits the program so the user can     */
/*                                retry the command.                    */
/*                                                                      */
/*      Inputs  : MSG_OPTIONS_FIRST - #defined with the number of the   */
/*                                    first message line to output.     */
/*                MSG_OPTIONS_LAST  - #defined with the number of the   */
/*                                    last message line to output.      */
/*                                                                      */
/*      Outputs : Options help lines as defined in FDISK.SKL            */
/*                Exits to DOS                                          */
/*                                                                      */
/*      Date    : 04/23/90  c-PaulB                                     */
/*      Version : DOS 5.00                                              */
/************************************************************************/

void
DisplayOptionsExit()
BEGIN
	int	iMsgNbr;

	/*
	 * Display each of the options message lines.
	 * Parse_message can't be used because it tries to display
	 * the text of an offending command.
	 */

	for (iMsgNbr = MSG_OPTIONS_FIRST;     /* defined in parse.h */
		iMsgNbr <= MSG_OPTIONS_LAST;
		iMsgNbr++)
	BEGIN
		  regs.x.ax = iMsgNbr;             /* message #     */
        regs.x.bx = STDOUT;              /* output handle */
        regs.x.cx = SUBCNT0;             /* # of subs     */
        regs.h.dl = No_Input;            /* input flag    */
        regs.h.dh = UTILITY_MSG_CLASS;   /* message class */
        regs.x.si = 0;                   /* sub list ptr  */
        sysdispmsg(&regs,&regs);
	END

	/*
	 * Exit the program so the user can retry the command.
	 */

	exit(ERR_LEVEL_0);

END

/* end of fdparse.c */



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\messages.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */

#include "dos.h"                                                        /* AN000 */
#include "msgret.h"                                                     /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "stdio.h"                                                      /* AN000 */

/*  */
/******************************************************************************/
/*Routine name:  PRELOAD_MESSAGES                                             */
/******************************************************************************/
/*                                                                            */
/*Description:   Preloads messages for Display_Msg and returns error code     */
/*               if incorrect DOS version, insuffient memory, or unable to    */
/*               to find messages.                                            */
/*                                                                            */
/*Called Procedures:    sysloadmsg                                            */
/*                      display_msg                                           */
/*                                                                            */
/*Change History: Created        5/30/87         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/


char preload_messages()                                                 /* AN000 */

BEGIN                                                                   /* AN000 */

char message_flag;                                                      /* AN000 */

     /* load all messages for FDISK */
     message_flag = c(TRUE);                                            /* AN000 */
     sysloadmsg(&regs,&regs);                                           /* AN000   load the messages         */

     if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)                     /* AN000   If msg load problem       */
       BEGIN
        sysdispmsg(&regs,&regs);                                        /* AN000   write the error message */
        message_flag = FALSE;                                           /* AN000 */
       END
     return(message_flag);                                              /* AN000 */

END                                                                     /* AN000 */

/*  */
/**/
/*                                                                           */
/*    Subroutine Name: display_msg                                           */
/*                                                                           */
/*    Subroutine Function:                                                   */
/*       Display the requested message to the standard output device         */
/*                                                                           */
/*    Input:                                                                 */
/*        (1) Number of the message to be displayed (see FDISK.SKL)          */
/*        (2) Number of substitution parameters (%1,%2)                      */
/*        (3) Offset of sublist control block                                */
/*        (4) Message Class, 0=no input, 1=input via INT 21 AH=1             */
/*                                                                           */
/*    Output:                                                                */
/*        The message is written to the standard output device.  If input    */
/*        was requested, the character code of the key pressed is returned   */
/*        in regs.x.ax.                                                      */
/*                                                                           */
/*    Normal exit: Message written to handle                                 */
/*                                                                           */
/*    Error exit: None                                                       */
/*                                                                           */
/*    Internal References:                                                   */
/*              None                                                         */
/*                                                                           */
/*    External References:                                                   */
/*              Sysdispmsg (module _msgret.sal)                              */
/*                                                                           */
/**/

void display_msg(msgnum,msghan,msgparms,msgsub,msginput,msgclass) /*;AN000 AC014;                           */
int   msgnum;                           /*;AN000; message number              */
int   msghan;                           /*;AN000; output device               */
int   msgparms;                         /*;AN000; number of substitution parms*/
int   *msgsub;                          /*;AN000; offset of sublist           */
char  msginput;                         /*;AN000; 0=no input, else input func */
char  msgclass;                         /*;AN014; 0=no input, else input func */

BEGIN
        regs.x.ax = u(msgnum);             /*;AN000; set registers               */
        regs.x.bx = u(msghan);             /*;AN000;                             */
        regs.x.cx = u(msgparms);           /*;AN000;                             */
        regs.h.dh = uc(msgclass);          /*;AN014;                             */
        regs.h.dl = uc(msginput);          /*;AN000;                             */
        regs.x.si = u(msgsub);             /*;AN000;                             */
        sysdispmsg(&regs,&regs);           /*;AN000;  write the messages         */

        return;                            /*;AN000;                             */
END

/*  */
/******************************************************************************/
/*Routine name:  GET_YES_NO_VALUES                                            */
/******************************************************************************/
/*                                                                            */
/*Description:   Uses SYSGETMSG to get the translated values for Y and N      */
/*               for display purposes.                                        */
/*                                                                            */
/*Called Procedures:    sysgetmsg                                             */
/*                      sysdispmsg                                            */
/*                                                                            */
/*Change History: Created        5/11/88         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/


char get_yes_no_values()                                                /* AN012 */

BEGIN                                                                   /* AN012 */

char            message_flag;                                           /* AN012 */
char far        *msg_buff;                                              /* AN012 */

     message_flag = c(TRUE);                                            /* AN012 */

     /* do sysgetmsg for 'Y' */
     regs.x.ax = YesMsg;                                                /* AN012 */
     regs.h.dh = uc(utility_msg_class);                                 /* AN012 */
     sysgetmsg(&regs,&segregs,&regs);                                   /* AN012 */

     FP_OFF(msg_buff) = regs.x.si;                                      /* AN012 */
     FP_SEG(msg_buff) = segregs.ds;                                     /* AN012 */

     Yes = *msg_buff;                                                   /* AN012 */

     if ((regs.x.cflag & CARRY_FLAG) != CARRY_FLAG)                     /* AN012   If msg load problem       */
          BEGIN                                                         /* AN012 */
          /* do sysgetmsg for 'N' */
          regs.x.ax = NoMsg;                                            /* AN012 */
          regs.h.dh = uc(utility_msg_class);                            /* AN012 */
          sysgetmsg(&regs,&segregs,&regs);                              /* AN012 */

          FP_OFF(msg_buff) = regs.x.si;                                 /* AN012 */
          FP_SEG(msg_buff) = segregs.ds;                                /* AN012 */

          No = *msg_buff;                                               /* AN012 */

          END                                                           /* AN012 */

     if ((regs.x.cflag & CARRY_FLAG) == CARRY_FLAG)                     /* AN012   If msg load problem       */
       BEGIN                                                            /* AN012 */
        sysdispmsg(&regs,&regs);                                        /* AN012   write the error message */
        message_flag = FALSE;                                           /* AN012 */
       END                                                              /* AN012 */

     return(message_flag);                                              /* AN012 */

END                                                                     /* AN012 */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\msgret.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/*  */
/*----------------------------------------------------------------------+
|                                                                       |
| This file contains the structures and defines that are needed to use  |
| the message retriever C program.                                      |
|                                                                       |
|                                                                       |
| Date:         6-27-87                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define NORMAL_PRELOAD         0                                        /* AN000 */
#define ALL_UTILITY_MESSAGES  -1                                        /* AN000 */
#define Utility_Msg_Class     -1                                        /* AN014 */
#define Ext_Err_Class          1                                        /* AN014 */

#define DosStdEr        2               /*;AN000;  standard error             */

#define nosubptr        0               /*;AN000;  no sublist pointer         */
#define nosubcnt        0               /*;AN000;  0 substitution count       */
#define oneparm         1               /*;AN000;  1 substitution count       */
#define twoparm         2               /*;AN000;  2 substitution count       */
#define noinput         0               /*;AN000;  no user input              */


#define utility_msg_class 0xff /*;AN000; Utility message type                */


/* Sublist Flag Values                                                 */

/* Alignment Indicator                                                 */
#define sf_left         0x00      /*;AN000; left align                 */
#define sf_right        0x80      /*;AN000; right align                */

/* Field Type                                                          */
#define sf_char         0x00      /*;AN000; character                  */
#define sf_unsbin2d     0x01      /*;AN000; unsigned binary to decimal */
#define sf_sbin         0x02      /*;AN000; signed binary to decimal   */
#define sf_unsbin2h     0x03      /*;AN000; unsigned binary to hex     */
#define sf_date         0x04      /*;AN000; date                       */
#define sf_time12       0x05      /*;AN000; time 12-hour               */
#define sf_time24       0x06      /*;AN000; time 24-hour               */


/* Data Variable Size                                                  */

#define sf_ch           0x00      /*;AN000; single character           */
#define sf_asciiz       0x10      /*;AN000; asciiz string              */
#define sf_word         0x20      /*;AN000; word                       */
#define sf_dword        0x30      /*;AN000; double word                */
#define sf_word         0x20      /*;AN000; word                       */

#define YesMsg          0x09                                            /* AN012 */
#define NoMsg           0x0A                                            /* AN012 */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\print.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */

  clear_screen(0,0,24,39);
  printf("boot_ind=%d\n", part_table[temp][cur_disk].boot_ind);
    printf("start head=%d\n", part_table[temp][cur_disk].start_head);
      printf("start sec=%d\n", part_table[temp][cur_disk].start_sector);
      printf("start cyl=%d\n", part_table[temp][cur_disk].start_cyl);
	printf("sys id=%d\n", part_table[temp][cur_disk].sys_id);
	printf("end head=%d\n", part_table[temp][cur_disk].end_head);
		printf("end sec=%d\n", part_table[temp][cur_disk].end_sector);
	printf("end cyl=%d\n", part_table[temp][cur_disk].end_cyl);
	  printf("rel sec=%d\n", part_table[temp][cur_disk].rel_sec);
	     printf("num sec=%d\n", part_table[temp][cur_disk].num_sec);

		 wait_for_esc();

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\parse.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  05/23/90  EGH  C18  Added support for /MBR switch to update the master boot
*                      record.
*  11/06/90  EGH  C33  STDOUT was incorrectly defined as 0 rather than 1.
*
******************************************************************************/

/*  */
/*----------------------------------------------------------------------+
|                                                                       |
| This file contains the structures and defines that are needed to use  |
| the parser from a C program.                                          |
|                                                                       |
|                                                                       |
| Date:         6-15-87                                                 |
|                                                                       |
+----------------------------------------------------------------------*/


#define p_len_parms             4               /* AN000 - length of p_parms  */
#define p_i_use_default         0               /* AN000 - no extra stuff specified */
#define p_i_have_delim          1               /* AN000 - extra delimiter specified  */
#define p_i_have_eol            2               /* AN000 - extra EOL specified */
#define PRI                     "/PRI"          /* AN000 */
#define EXT                     "/EXT"          /* AN000 */
#define LOG                     "/LOG"          /* AN000 */
#define QUIET                   "/Q"            /* AN000 */
#define STATUS                  "/STATUS"
#define OPTIONS                 "/?"            /* for /? options help */
#define MBR                     "/MBR"                                  /*C18*/

struct p_parms                                  /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned        p_parmsx_ptr;           /* AN000 - address of p_parmsx */
        unsigned char   p_num_extra;            /* AN000 - number of extra stuff */
        unsigned char   p_len_extra_delim;      /* AN000 - length of extra delimiter */
        char            p_extra_delim;          /* AN000 - extra delimiters */
       END;                                     /* AN000 */

struct p_parmsx                                 /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned char   p_minp;                 /* AN000 - Minimum positional number */
        unsigned char   p_maxp;                 /* AN000 - Maximum positional number  */
        unsigned        p_con1_ptr;             /* AN000 - Address of the 1st CONTROL block */
        unsigned char   p_maxs;                 /* AN000 - Maximum number of switches */
        unsigned        p_swi1_ptr;             /* AN000 - Address of the 1st CONTROL block */
        unsigned        p_swi2_ptr;             /* AN000 - Address of the 2nd CONTROL block */
        unsigned        p_swi3_ptr;             /* SR; Addr. of 3rd CONTROL BLOCK */
        unsigned        p_swi4_ptr;             /* address of 4th switch block */
        unsigned        p_swi5_ptr;                                     /*C18*/
        unsigned char   p_maxk;                 /* AN000 - Any keyworks?? */
       END;                                     /* AN000 */


struct p_control_blk                            /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned        p_match_flag;           /* AN000 - Controls type matched */
        unsigned        p_function_flag;        /* AN000 - Function should be taken */
        unsigned        p_buff1_ptr;            /* AN000 - Result buffer address */
        unsigned        p_val1_ptr;             /* AN000 - Value list address */
        unsigned char   p_nid;                  /* AN000 - # of keyword/SW synonyms */
       END;                                     /* AN000 */

struct p_switch_blk                             /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned        sp_match_flag;          /* AN000 - Controls type matched */
        unsigned        sp_function_flag;       /* AN000 - Function should be taken */
        unsigned        sp_buff1_ptr;           /* AN000 - Result buffer address */
        unsigned        sp_val1_ptr;            /* AN000 - Value list address */
        unsigned char   sp_nid;                 /* AN000 - # of keyword/SW synonyms */
        unsigned char   sp_switch1[5];          /* AN000 - keyword or sw */
        unsigned char   sp_switch2[5];          /* AN000 - keyword or sw */
        unsigned char   sp_switch3[5];          /* AN000 - keyword or sw */
       END;                                     /* AN000 */

struct p_switch1_blk                            /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned        sp_match_flag;          /* AN000 - Controls type matched */
        unsigned        sp_function_flag;       /* AN000 - Function should be taken */
        unsigned        sp_buff1_ptr;           /* AN000 - Result buffer address */
        unsigned        sp_val1_ptr;            /* AN000 - Value list address */
        unsigned char   sp_nid;                 /* AN000 - # of keyword/SW synonyms */
        unsigned char   sp_switch4[3];          /* AN000 - keyword or sw */
       END;                                     /* AN000 */

struct p_switch2_blk
       BEGIN
        unsigned        sp_match_flag;
        unsigned        sp_function_flag;
        unsigned        sp_buff1_ptr;
        unsigned        sp_val1_ptr;
        unsigned char   sp_nid;
        unsigned char   sp_switch5[8];
       END;

struct p_switch3_blk                            /* for /? */
       BEGIN
        unsigned        sp_match_flag;
        unsigned        sp_function_flag;
        unsigned        sp_buff1_ptr;
        unsigned        sp_val1_ptr;
        unsigned char   sp_nid;
        unsigned char   sp_switch6[3];
       END;

struct p_switch4_blk                            /* for /MBR */          /*C18*/
       BEGIN                                                            /*C18*/
        unsigned        sp_match_flag;                                  /*C18*/
        unsigned        sp_function_flag;                               /*C18*/
        unsigned        sp_buff1_ptr;                                   /*C18*/
        unsigned        sp_val1_ptr;                                    /*C18*/
        unsigned char   sp_nid;                                         /*C18*/
        unsigned char   sp_switch7[5];                                  /*C18*/
       END;                                                             /*C18*/

struct p_result_buff                            /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned char   p_type;                 /* AN000 - type returned */
        unsigned char   p_item_tag;             /* AN000 - Matched item tag */
        unsigned        p_synonym;              /* AN000 - Synonym list */
        unsigned long   p_value;                /* AN000 - result value */
       END;                                     /* AN000 */

struct p_value_list                             /* AN000 */
       BEGIN                                    /* AN000 */
        unsigned char   p_values;               /* AN000 - number of values */
        unsigned char   p_range;                /* AN000 - number of ranges */
        unsigned char   p_range_one;            /* AN000 - range one */
        unsigned long   p_low_range;            /* AN000 - low value of range */
        unsigned long   p_high_range;           /* AN000 - high value of range */
       END;                                     /* AN000 */

/* Match_Flags */

#define p_num_val               0x8000          /* AN000 - Numeric Value */
#define p_snum_val              0x4000          /* AN000 - Signed numeric value */
#define p_simple_s              0x2000          /* AN000 - Simple string */
#define p_date_s                0x1000          /* AN000 - Date string */
#define p_time_s                0x0800          /* AN000 - Time string */
#define p_cmpx_s                0x0400          /* AN000 - Complex string */
#define p_file_spc              0x0200          /* AN000 - File Spec */
#define p_drv_only              0x0100          /* AN000 - Drive Only */
#define p_qu_string             0x0080          /* AN000 - Quoted string */
#define p_ig_colon              0x0010          /* AN000 - Ignore colon at end in match */
#define p_repeat                0x0002          /* AN000 - Repeat allowed */
#define p_optional              0x0001          /* AN000 - Optional */

/*----------------------------------------------------------------------+
|                                                                       |
|  Function flags                                                       |
|                                                                       |
+----------------------------------------------------------------------*/

#define p_cap_file              0x0001          /* AN000 - CAP result by file table */
#define p_cap_char              0x0002          /* AN000 - CAP result by character table */
#define p_rm_colon              0x0010          /* AN000 - Remove ":" at the end */
/*C33 #define STDOUT                  0x0000 */
#define STDOUT                  0x0001                                  /*C33*/
#define STDERR                  0x0002          /* AN010 */
#define Parse_err_class         0x0002          /* AN010 */
#define UTILITY_MSG_CLASS       0xFF
#define Sublist_Length          0x000b          /* AN010 */
#define Reserved                0x0000          /* AN010 */
#define Char_Field_ASCIIZ       0x0010          /* AN010 */
#define Left_Align              0x0000          /* AN010 */
#define Blank                   0x0020          /* AN010 */
#define SUBCNT0                 0x0000          /* no substitution list */
#define SubCnt1                 0x0001          /* AN010 */
#define No_Input                0x0000          /* AN010 */

#define	MSG_OPTIONS_FIRST		300
#define MSG_OPTIONS_LAST		301

#define p_nval_none             0               /* AN000 - no value list ID */
#define p_nval_range            1               /* AN000 - range list ID */
#define p_nval_value            2               /* AN000 - value list ID */
#define p_nval_string           3               /* AN000 - string list ID */
#define p_len_range             9               /* AN000 - Length of a range choice(two DD plus one DB) */
#define p_len_value             5               /* AN000 - Length of a value choice(one DD plus one DB) */
#define p_len_string            3               /* AN000 - Length of a string choice(one DW plus one DB) */


/*----------------------------------------------------------------------+
|                                                                       |
|  type                                                                 |
|                                                                       |
+----------------------------------------------------------------------*/

#define p_eol                   0               /* AN000 - End of line */
#define p_number                1               /* AN000 - Number */
#define p_list_idx              2               /* AN000 - List Index */
#define p_string                3               /* AN000 - String */
#define p_complex               4               /* AN000 - Complex */
#define p_file_spec             5               /* AN000 - File Spec */
#define p_drive                 6               /* AN000 - Drive */
#define p_date_f                7               /* AN000 - Date */
#define p_time_f                8               /* AN000 - Time */
#define p_quoted_string         9               /* AN000 - Quoted String */

#define p_no_tag                0x0FF           /* AN000 - No ITEM_TAG found */

/*----------------------------------------------------------------------+
|                                                                       |
|  following return code will be returned in the AX register.           |
|                                                                       |
+----------------------------------------------------------------------*/

#define p_no_error              0               /* AN000 - No error */
#define p_too_many              1               /* AN000 - Too many operands */
#define p_op_missing            2               /* AN000 - Required operand missing */
#define p_not_in_sw             3               /* AN000 - Not in switch list provided */
#define p_not_in_key            4               /* AN000 - Not in keyword list provided */
#define p_out_of_range          6               /* AN000 - Out of range specified */
#define p_not_in_val            7               /* AN000 - Not in value list provided */
#define p_not_in_str            8               /* AN000 - Not in string list provided */
#define p_syntax                9               /* AN000 - Syntax error */
#define p_rc_eol                0x0ffff         /* AN000 - End of command line */


/*----------------------------------------------------------------------+
|                                                                       |
|  following are the structure intializations                           |
|                                                                       |
+----------------------------------------------------------------------*/

struct p_parms  p_p;                                                    /* AN000 */
struct p_parmsx  p_px;                                                  /* AN000 */
struct p_control_blk  p_con;                                            /* AN000 */
struct p_switch_blk   p_swi1;                                           /* AN000 */
struct p_switch1_blk  p_swi2;                                           /* AN000 */
struct p_switch2_blk  p_swi3;  	/* SR; Code merge */
struct p_switch3_blk  p_swi4;	/* for /? options help */
struct p_switch4_blk  p_swi5;   /* /MBR */                              /*C18*/

struct p_result_buff  p_buff;                                           /* AN000 */
struct p_value_list   p_val;                                            /* AN000 */
struct p_result_buff  sp_buff;                                          /* AN000 */
struct p_value_list   sp_val;                                           /* AN000 */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\partinfo.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/22/90  EGH  C14  Added support for deleting Non-DOS partitions.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "extern.h"                                                     /* AN000 */

/*  */
char find_free_partition()

BEGIN
 char  i;

    /* Look at all four partition entries for empty partition */
    for (i = c(0); i < c(4);i++)                                        /* AC000 */
       BEGIN

        /* if we find an empty one, return which one */
        if (part_table[cur_disk][i].num_sec == ul(0))                   /* AC000 */
           BEGIN
            return(i);
            break;
           END
       END
    /* Did not find one, return NOT_FOUND */
    return(c(NOT_FOUND));                                               /* AC000 */
END

/*  */
char find_partition_type(type)

unsigned char type;

BEGIN
 char  i;

/*  Look at all four partition entries for system id byte that matches */
 for (i = c(0); i < c(4);i++)                                           /* AC000 */
    BEGIN

     /* if we find a match, do a TRUE return */
     if (part_table[cur_disk][i].sys_id == type)
        BEGIN
         return(TRUE);
         break;
        END
    END
 /* Did not find one, return FALSE */
 return(FALSE);
END



/*  */
char find_non_dos_partition()                                           /*C14*/
                                                                        /*C14*/
BEGIN                                                                   /*C14*/
 char  i;                                                               /*C14*/
                                                                        /*C14*/
 /* Look at all four partition entries for system id byte that is  */   /*C14*/
 /* not NUL, DOS12, DOS16, DOSNEW, or EXTENDED.                    */   /*C14*/
 for (i = c(0); i < c(4);i++)                                           /*C14*/
    BEGIN                                                               /*C14*/
                                                                        /*C14*/
     /* if we find a match, do a TRUE return */                         /*C14*/
     if ((part_table[cur_disk][i].sys_id != NUL)    &&                  /*C14*/
         (part_table[cur_disk][i].sys_id != DOS12)  &&                  /*C14*/
         (part_table[cur_disk][i].sys_id != DOS16)  &&                  /*C14*/
         (part_table[cur_disk][i].sys_id != DOSNEW) &&                  /*C14*/
         (part_table[cur_disk][i].sys_id != EXTENDED))                  /*C14*/
        BEGIN                                                           /*C14*/
         return(TRUE);                                                  /*C14*/
         break;                                                         /*C14*/
        END                                                             /*C14*/
    END                                                                 /*C14*/
 /* Did not find one, return FALSE */                                   /*C14*/
 return(FALSE);                                                         /*C14*/
END                                                                     /*C14*/



/*  */
XFLOAT get_partition_size(type)                                   /* AC000 */

unsigned char type;                                                     /* AC000 */

BEGIN
 char  i;

 /*  Look at all four partition entries for system id byte that matches */
 for (i = c(0); i < c(4);i++)                                           /* AC000 */
    BEGIN

     /* if we find a match, get the size */
     if (part_table[cur_disk][i].sys_id == type)
        BEGIN
         /* Get the size of the partition from the array */
         return(part_table[cur_disk][i].mbytes_used);         /* AC000 */
        END
    END
 /* Did not find one, something bad wrong happened */
 internal_program_error();
END

/*  */
char find_active_partition()

BEGIN

unsigned  char   i;

       /* See if there is an active partition */
       for (i = uc(0); i < uc(4);i++)                                   /* AC000 */
          BEGIN

           /* if we find an active one, TRUE return */
           if (part_table[cur_disk][i].boot_ind == uc(ACTIVE))          /* AC000 */
              BEGIN
               return(TRUE);
               break;
              END
          END
        /* Did not find one, return FALSE */
        return(FALSE);
END


/*  */
char find_partition_location(type)

unsigned char type;

BEGIN
 char  i;

/*  Look at all four partition entries for system id byte that matches */
 for (i = c(0); i < c(4);i++)                                           /* AC000 */
    BEGIN

     /* if we find a match, do a TRUE return */
     if (part_table[cur_disk][i].sys_id == type)
        BEGIN
         return(i);
         break;
        END
    END
 /* Did not find one, return */
 return(c(NOT_FOUND));                                                  /* AC000 */
END

/*  */
char find_free_ext()

BEGIN

 char   i;

    /* Look at all 23 extended entries for empty partition */
    for (i = c(0); i < c(23);i++)                                       /* AC000 */
       BEGIN

        /* if we find an empty one, return which one */
        if (ext_table[cur_disk][i].sys_id == uc(0))                     /* AC000 */
           BEGIN
            return(i);
            break;
           END
       END
    return(c(NOT_FOUND));                                               /* AC000 */
END

/*  */
char find_logical_drive()

BEGIN

unsigned  char  i;

       /* See if there is a logical drive defined in Extended Partition */
       for (i = uc(0); i < uc(23);i++)                                  /* AC000 */
          BEGIN

           /* See if we find a sys id that is not 0 */
           if (ext_table[cur_disk][i].sys_id != uc(0))                  /* AC000 */
              BEGIN
               return(TRUE);
               break;
              END
          END
        return(FALSE);
END

/*  */
char get_num_logical_dos_drives()
BEGIN

char   i;
char number;

       number = c(0);                                                   /* AC000 */
       /* See if there is a logical drive defined in Extended Partition */
       for (i = c(0); i < c(23);i++)                                    /* AC000 */
          BEGIN

           /* See if we find a sys id that is DOS */
           if ((ext_table[cur_disk][i].sys_id == uc(DOS12)) || (ext_table[cur_disk][i].sys_id == uc(DOS16)) ||
              (ext_table[cur_disk][i].sys_id == uc(DOSNEW)))                                                     /* AC000 */
              BEGIN
               number++;
              END
          END
        return(number);
END

/*  */
char find_ext_drive(offset)

char   offset;

BEGIN

char   number_found;
char   i;

        number_found = c(0);                                            /* AC000 */

        /* Go look for the nth extended drive */
        for (i=c(0); i < c(23); i++)                                    /* AC000 */
           BEGIN

            /* See if there is a drive we know about */
            if ((ext_table[cur_disk][i].sys_id == uc(DOS12)) || (ext_table[cur_disk][i].sys_id == uc(DOS16)) ||
               (ext_table[cur_disk][i].sys_id == uc(DOSNEW)))                                   /* AC000 */
               BEGIN
                /* Is this the one we were looking for ? */
                if (number_found == offset)
                   BEGIN
                    /* Yes it is, return where we found it */
                    return(i);
                    break;
                   END
                /* Show we found one and go look for the next */
                number_found++;
               END
           END
        /* We should never get here */
        internal_program_error();
        return(c(INVALID));                                             /* AC000 */
END


/*  */
char find_previous_drive(offset)

char   offset;

BEGIN

char   number_found;
char   last_found;
char   i;

        number_found = c(0);                                            /* AC000 */
        last_found = c(0);                                              /* AC000 */

        /* Go look for the nth extended drive */
        for (i=c(0); i < c(23); i++)                                    /* AC000 */
           BEGIN

            /* See if there is a drive */
            if (ext_table[cur_disk][i].sys_id != uc(0))                 /* AC000 */
               BEGIN
                /* Is this the one we were looking for ? */
                if (number_found == offset)
                   BEGIN
                    /* Yes it is, return where we found the previous one */
                    return(last_found);
                   END
                /* This is the latest one we found, but not the limit, so save it */
                last_found = i;

                /* Show we found one and go look for the next */
                number_found++;
               END
           END
        /* We should never get here */
        internal_program_error();
        return(c(INVALID));                                             /* AC000 */
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\main.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  05/23/90  EGH  C18  Added support for /MBR switch to update the master boot
*                      record.
*
******************************************************************************/

/*  */

/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SOURCE FILE NAME: FDISK                                     */
/*                                                             */
/* DESCRIPTIVE NAME: FIXED DISK PARTITIONING UTILITY           */
/*                                                             */
/* FUNCTION:                                                   */
/*     Allows creation and deletion of DOS related partitions  */
/*     on fixed disk devices 80-86h (int 13h BIOS defined,     */
/*     DOS). Also allows display of all partitions, and will   */
/*     allow a partition to be marked active (bootable). The   */
/*     user will be prompted for action thru a full screen     */
/*     interface. The user can also create, delete and display */
/*     logical DOS drives within a EXTENDED DOS Partition. If a*/
/*     regular DOS partition is created, the beginning of the  */
/*     partition will be scanned to insure a contiguous area of*/
/*     good sectors on the disk large enough to satisfy the    */
/*     DOS system requirements. If a bad spot is found, the    */
/*     start of the partition will be moved out until a good   */
/*     area is located                                         */
/*                                                             */
/* NOTES: The program will work by setting up a logical image  */
/*        of all relevant disk information at initilization    */
/*        time. All operations will be performed on this       */
/*        logical image, thus reducing disk accesses to only   */
/*        those required to initially set up the logical image,*/
/*        and to write the changed information at the end. The */
/*        user will be informed if there is a problem writing  */
/*        the logical image back to the disk.                  */
/*                                                             */
/*        FDISK will interface with the partition table in the */
/*        master boot record as defined in the PC-DOS technical*/
/*        reference manual. It will also create and manage the */
/*        EXTENDED DOS partition architecture as defined in the*/
/*        PC-DOS 3.30 functional spec (CP/DOS spec dcr pending)*/
/*                                                             */
/* ENTRY POINTS: MAIN                                          */
/*    LINKAGE: [d:] [path] FDISK                               */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*              Fixed Disk Master Boot Record                  */
/*              EXTENDED Partition Volume Boot Records         */
/*   Note: Both of the above are physical data structures on   */
/*         the surface of the disk                             */
/*                                                             */
/* P.S. - To whoever winds up maintaining this, I will         */
/*        apoligize in advance. I had just learned 'C' when    */
/*        writing this, so out of ignorance of the finer points*/
/*        of the langauge I did a lot of things by brute force.*/
/*        Hope this doesn't mess you up too much - MT 5/20/86  */
/******************** END OF SPECIFICATIONS ********************/

#include <dos.h>                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include <subtype.h>                                                    /* AN000 */
#include <doscall.h>                                                    /* AN000 */
#include <ctype.h>                                                      /* AN000 */
#include <extern.h>                                                     /* AN000 */
#include <signal.h>                                                     /* AN000 */
#include <string.h>                                                     /* AN000 */
#include <fdiskmsg.h>                                                   /* AN000 */
#include "msgret.h"                                                     /* AN000 */
#include <process.h>                                                    /* AN001 */
#include <stdio.h>                                                      /* AN000 */

/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: MAIN                                       */
/*                                                             */
/* DESCRIPTIVE NAME: Main control routine                      */
/*                                                             */
/* FUNCTION: Main will handle call routines to handle the      */
/*           setup of the video for the full screen interface, */
/*           get physical data on the drive characteristics,   */
/*           initilize all data fields with the current status */
/*           of the disk partitioning information. Before the  */
/*           program is terminated, the video is reset to the  */
/*           mode it was in previous to the routine entry. It  */
/*           will also handle the case of an improper setup    */
/*                                                             */
/* NOTES: FDISK requires at least 1 hardfile to operate        */
/*                                                             */
/* ENTRY POINTS: main();                                       */
/*      LINKAGE:                                               */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: Return Code = 0                                */
/*                                                             */
/* EXIT-ERROR: Return Code =  1                                */
/*                                                             */
/* EFFECTS: Sets up status variables, sets up video for full   */
/*          screen interface, and then restores the video mode */
/*          before exiting program                             */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      init_video_information                                 */
/*      get_disk_information                                   */
/*      check_valid_environment                                */
/*      do_main_menu                                           */
/*      init_partition_tables                                  */
/*      reset_video_information                                */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*       DosExit                                               */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/


/*  */
/**************************************************************************/
/*                                                                        */
/*   UTILITY NAME:         FDISK.com                                      */
/*   SOURCE FILE NAME:     FDISK.c                                        */
/*   STATUS:               FDISK utility, DOS 3.3			  */
/*   CHANGE HISTORY:       UPDATED        5-29-87     DOS4.0       DRM    */
/*   SYNTAX (Command line)                                                */
/*                                                                        */
/*     [d:][path]FDISK                                                    */
/*                                                                        */
/*     or                                                                 */
/*                                                                        */
/*     [d:][path]FDISK d [/PRI:m | /EXT:n | /LOG:o | /Q | /STATUS | /MBR] */
/*                                                                        */
/*         d:      Drive to load FDISK utility from                       */
/*                                                                        */
/*         path    path to the directory on specified drive to            */
/*                 load FDISK from                                        */
/*                                                                        */
/*         d       Drive (1 or 2) that FDISK should operate on            */
/*                                                                        */
/*         /PRI:m  Size of Primary DOS partition to create in K           */
/*                                                                        */
/*         /EXT:n  Size of Extended DOS partition to create in K          */
/*                                                                        */
/*         /LOG:o  Size of Logical drive to create in K in the            */
/*                 extended partition                                     */
/*                                                                        */
/*         /Q      This suppresses the reboot screen and returns          */
/*                 FDISK to DOS even if partitons have changed.           */
/*                                                                        */
/*         /STATUS This gives a display of the data portion of the        */
/*                 Change Current Fixed Disk Drive menu.                  */
/*                                                                        */
/*   UTILITY FUNCTION:                                                    */
/*     Allows you to create, set up, display, and delete the              */
/*     DOS partitions on a fixed disk.                                    */
/*                                                                        */
/* PSEUDOCODE:                                                            */
/*                                                                        */
/*      Disable CTRL-break                                                */
/*      IF Preload_messages and get_yes_no_values                         */
/*          IF Parse Command Line                                         */
/*              IF no switches set                                        */
/*                  IF Valid Environment                                  */
/*                      Change video information                          */
/*                      IF Get disk information                           */
/*                          Initialize tables                             */
/*                          IF status_flag == TRUE                        */
/*                              display current drive information         */
/*                          else                                          */
/*                              display main menu                         */
/*                              write information to disk                 */
/*                              IF reboot_flag == TRUE                    */
/*                                  reboot                                */
/*                              else                                      */
/*                                  reset video mode                      */
/*                              ENDIF  reboot flag                        */
/*                          ENDIF  status flag                            */
/*                      ENDIF  get disk info                              */
/*                  ENDIF  valid environment                              */
/*              else                                                      */
/*                  IF all flags == FALSE                                 */
/*                      display error message                             */
/*                  else                                                  */
/*                      IF get_disk_info                                  */
/*                          IF drive number not valid                     */
/*                              display error message                     */
/*                          else                                          */
/*                              init_partition_tables                     */
/*                              IF PRIMARY flag == true                   */
/*                                  find available free space             */
/*                                  IF asking for too much                */
/*                                      reset ask to available space      */
/*                                  else                                  */
/*                                      change request to cylinders       */
/*                                  ENDIF                                 */
/*                                  make the partition                    */
/*                              ENDIF                                     */
/*                              IF EXTENDED flag == true                  */
/*                                  find available free space             */
/*                                  IF asking for too much                */
/*                                      reset ask to available space      */
/*                                  else                                  */
/*                                      change request to cylinders       */
/*                                  ENDIF                                 */
/*                                  make the partition                    */
/*                              ENDIF                                     */
/*                              IF LOGICAL flag == true                   */
/*                                  find available free space in extended */
/*                                  IF asking for too much                */
/*                                      reset ask to available space      */
/*                                  else                                  */
/*                                      change request to cylinders       */
/*                                  ENDIF                                 */
/*                                  make the partition                    */
/*                              ENDIF                                     */
/*                              Write information to disk                 */
/*                          ENDIF                                         */
/*                      ENDIF                                             */
/*                  ENDIF                                                 */
/*              ENDIF                                                     */
/*          ENDIF                                                         */
/*      ENDIF                                                             */
/*      IF no PRIMARY on disk 1 and /Q switch                             */
/*          exit errorlevel 1                                             */
/*      else                                                              */
/*          IF no switches set and /Q option                              */
/*              exit errorlevel 2                                         */
/*          else                                                          */
/*              exit errorlevel 0                                         */
/*          ENDIF                                                         */
/*      ENDIF                                                             */
/*                                                                        */
/**************************************************************************/
/*  */
void main(argc,argv)                                                    /* AC000 */

int     argc;                                                           /* AN000 */
char    *argv[];                                                        /* AN000 */

BEGIN

 	unsigned   i;

    char       temp;                                                    /* AN000 */
    unsigned   input;

    /* DISABLE CNTL-BREAK HERE */
    /* Gets defines from signal.h */
    signal( (int) SIGINT, SIG_IGN );                                    /* AN000 */

    no_fatal_error = TRUE;                                              /* AN000 */

    /* Preload messages and return */
    if ( preload_messages() &&
         get_yes_no_values() )                                          /* AN000 AC012 */
    BEGIN                                                               /* AN000 */

        /* Parse the command line for syntax and switches */
        if(parse_command_line(argc,argv))                               /* AN000 */

        BEGIN                                                           /* AN000 */
        /* check to see if switches were set */
/*C18   if ((primary_flag == FALSE)  && */
/*C18       (extended_flag == FALSE) && */
/*C18       (logical_flag == FALSE)  && */
/*C18       (disk_flag == FALSE))       */                              /* AN000 */
        if ((primary_flag == FALSE)  &&                                 /*C18*/
            (extended_flag == FALSE) &&                                 /*C18*/
            (logical_flag == FALSE)  &&                                 /*C18*/
            (disk_flag == FALSE)     &&                                 /*C18*/
            (mbr_flag == FALSE))                                        /*C18*/

            BEGIN                                                       /* AN000 */
            reboot_flag = FALSE;
            /* See if running evironment is ok (Got hardfile, no network */
            if (check_valid_environment())
                BEGIN                                                   /* AN000 */
                /* Get and save screen mode information */
                init_video_information();
                clear_screen(u(0),u(0),u(24),u(79));                    /* AC006 */

                /* Get disk size information */
                for (i=0; i < u(MAX_HDISK); i++)
                    good_disk[i] = TRUE;

                if (get_disk_info())
                    BEGIN
                    /* build memory model of partitions */
                    init_partition_tables();

                    cur_disk = 0;
                    if (status_flag == TRUE)
                       change_current_drive();
                    else
                        {
                    	/* Go do main screen */
                    	do_main_menu();
                    	write_info_to_disk();
                        }
                    END
                if (!status_flag)
                   {
                if (reboot_flag)
                    BEGIN                                               /* AN000 */
                    reboot_system();
                    DOSEXIT((unsigned) 0,(unsigned) 0);                 /* AC000 */
                    END                                                 /* AN000 */

                /* Nearly done, go reset screen mode */
                if (no_fatal_error)
                    BEGIN
                    reset_video_information();
                    END                                                 /* AN000 */
                    }
                /* this is end of check valid environment */
                END                                                     /* AN000 */
            /* This is end for no switches set */
            END                                                         /* AN000 */

        else                                                            /* AN000 */

            BEGIN                                                       /* AN000 */
/*C18       if ( ((primary_flag == FALSE)  && */
/*C18             (extended_flag == FALSE) && */
/*C18             (logical_flag == FALSE)) || */
/*C18             (disk_flag == FALSE)  )     */                        /* AN000 */
            if ((((primary_flag == FALSE)  &&                           /*C18*/
                  (extended_flag == FALSE) &&                           /*C18*/
                  (logical_flag == FALSE)) ||                           /*C18*/
                  (disk_flag == FALSE))    &&                           /*C18*/
                  (mbr_flag == FALSE))                                  /*C18*/
                display_msg((int)8,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class)); /*;AN000; AC014 AC015 */

            else
                BEGIN
                reboot_flag = FALSE;                                        /* AN000 */
                /* Get disk size information */                             /* AN000 */
                for ( i=0; i < u(MAX_HDISK); i++)
                    good_disk[i] = TRUE;                                        /* AN000 */

                if (get_disk_info())                                        /* AN000 */
                    BEGIN
                    if (number_of_drives < (cur_disk_buff+1))
                        display_msg((int)8,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class)); /*;AN000; AC014 AC015*/
                    else
                      if(mbr_flag == TRUE)                                                                                      /*C18*/
                        BEGIN                                                                                                   /*C18*/
                        if(!read_boot_record(0,0,0,1))                                                                          /*C18*/
                            display_msg((int)11,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class));     /*C18*/
                        else                                                                                                    /*C18*/
                            BEGIN                                                                                               /*C18*/
                            if((boot_record[0x1FE]==0x55) && (boot_record[0x1FF]==0xAA))                                        /*C18*/
                                for(i=0; i<=0x1BD; i++)                                                                         /*C18*/
                                    boot_record[i] = master_boot_record[0][i];                                                  /*C18*/
                            else                                                                                                /*C18*/
                                for(i=0; i<=0x1FF; i++)                                                                         /*C18*/
                                    boot_record[i] = master_boot_record[0][i];                                                  /*C18*/
                            if(!write_boot_record(0,0))                                                                         /*C18*/
                                display_msg((int)11,(int)DosStdEr,(int)nosubcnt,(int)nosubptr,c(noinput),c(Utility_Msg_Class)); /*C18*/
                            END                                                                                                 /*C18*/
                        END                                                                                                     /*C18*/
                      else                                                                                                      /*C18*/
                        BEGIN                                                   /* AN000 */
                        /* build memory model of partitions */
                        init_partition_tables();                                /* AN000 */

                        /* set cur_disk to current disk */
                        cur_disk = cur_disk_buff;                               /* AN000 */

                        /* If /PRI: was specified, create primary partition */
                        /* check to see if a primary partition already exists */
                        if ( (primary_flag == TRUE)            &&                               /* AN000 */
                           ( (!find_partition_type(uc(DOS12))) &&
                             (!find_partition_type(uc(DOS16))) &&
                             (!find_partition_type(uc(DOSNEW))) ) )  /* AC000 */
                            BEGIN
                            temp = find_part_free_space((char) PRIMARY);        /* AN000 */
                            if (primary_buff >= free_space[temp].mbytes_unused) /* AN000 */
                                input = free_space[temp].space;                 /* AN000 */
                            else                                                /* AN000 */
                                input = (unsigned)mbytes_to_cylinders(primary_buff,
                                                                      cur_disk_buff);   /* AN004 */
                            make_partition(input,temp,uc(ACTIVE),(char)PRIMARY);        /* AN000 */
                            END

                        /* If /EXT: was specified, create extended partition */
                        /* Check and see if there is a primary partition before you create an extended */
                        if ( (extended_flag == TRUE)        &&                             /* AN000 */
                           ( (cur_disk >= c(1))             ||
                           (find_partition_type(uc(DOS12))) ||
                           (find_partition_type(uc(DOS16))) ||
                           (find_partition_type(uc(DOSNEW))) ) )        /* AC000 */
                           BEGIN
                           /* Make sure there isn't an extended already there */
                           if (!find_partition_type(uc(EXTENDED)))                         /* AC000 */
                               BEGIN
                               temp = find_part_free_space((char) EXTENDED);       /* AN000 */
                               if (extended_buff >= free_space[temp].mbytes_unused) /* AN000 */
                                   input = free_space[temp].space;                 /* AN000 */
                               else                                                /* AN000 */
                                   input = (unsigned)mbytes_to_cylinders(extended_buff,
                                                                         cur_disk_buff);    /* AN004 */
                               make_partition(input,temp,(unsigned char) NUL,(char) EXTENDED);      /* AN000 */
                               END
                            END

                        /* If /LOG: was specified, create logical partition */
                        if ( (logical_flag == TRUE) &&
                             (find_partition_type(uc(EXTENDED))) )                               /* AN000 */
                            BEGIN                                               /* AN000 */
                            temp = find_ext_free_space();                       /* AN000 */
                            if (logical_buff >= free_space[temp].mbytes_unused) /* AN000 */
                                input = free_space[temp].space;                 /* AN000 */
                            else                                                /* AN000 */
                                input = (unsigned)mbytes_to_cylinders(logical_buff,
                                                                      cur_disk_buff);    /* AN004 */
                            make_volume(input,temp);                            /* AN000 */
                            END

                        /* This is end of switch execution */
                        write_info_to_disk();                                   /* AN000 */
                        END                                                     /* AN000 */
                    /* This is the end of compare cur_disk_buff for valid drive */
                    END
                /* This is the end of just disk_flag set */
                END
            /* This is end of if switch is present */
            END
        /* This is end of Parse command line */
        END                                                             /* AN000 */
    /* This end of Preload_messages function */
    END                                                                 /* AN000 */
    cur_disk = c(0);                                                    /* AN001 */
    if ( (quiet_flag == TRUE) &&
         (!find_partition_type(uc(DOS12))) &&
         (!find_partition_type(uc(DOS16))) &&
         (!find_partition_type(uc(DOSNEW))) )                           /* AN001 */
        exit(ERR_LEVEL_1);                                              /* AN001 */
    else
        BEGIN                                                           /* AN005 */
        if ((quiet_flag == TRUE)     &&                                 /* AN005 */
            (primary_flag == FALSE)  &&                                 /* AN008 */
            (extended_flag == FALSE) &&                                 /* AN008 */
            (logical_flag == FALSE))                                    /* AN008 */
            exit(ERR_LEVEL_2);                                          /* AN005 */
        else                                                            /* AN005 */
            exit(ERR_LEVEL_0);                                          /* AN001 */
        END                                                             /* AN005 */
END



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\mainmenu.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  12/13/90  EGH  C36  Added code to support 8 fixed disks.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */

/*  */
/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DO_MAIN_MENU                               */
/*                                                             */
/* DESCRIPTIVE NAME: Main menu display and input routine       */
/*                                                             */
/* FUNCTION:                                                   */
/*    Displays the main FDISK menu, accepts and validates      */
/*    input from menu and passes control to requested function */
/*                                                             */
/* NOTES: The following screen is managed by this routine:     */
/*                                                             */
/*       0000000000111111111122222222223333333333            */
/*       0123456789012345678901234567890123456789            */
/*     Ĵ            */
/*     00                                                    */
/*     01                                                    */
/*     02                                                    */
/*     03                                                    */
/*     04FDISK Options                                       */
/*     05                                                    */
/*     06Current Fixed Disk Drive: #                         */
/*     07                                                    */
/*     08Choose one of the following:                        */
/*     09                                                    */
/*     10    1.  Create DOS partition                        */
/*     11    2.  Change Active Partition                     */
/*     12    3.  Delete DOS Partition                        */
/*     13    4.  Display Partition Data                      */
/*     14    5.  Select Next Fixed Disk Drive                */
/*     15                                                    */
/*     16                                                    */
/*     17                                                    */
/*     18Enter choice: [#]                                   */
/*     19                                                    */
/*     20                                                    */
/*     21WARNING! No partitions marked active                */
/*     22                                                    */
/*     23Press ESC to return to DOS                          */
/*                 */
/*                                                             */
/* ENTRY POINTS: do_main_menu                                  */
/*      LINKAGE: do_main_menu();                               */
/*               NEAR CALL                                     */
/*                                                             */
/* INPUT: None                                                 */
/*                                                             */
/* EXIT-NORMAL: ERROR=FALSE                                    */
/*                                                             */
/* EXIT-ERROR: ERROR=TRUE                                      */
/*             GOTO internal_program_error if case statement   */
/*             failure when branching to requested function    */
/*                                                             */
/* EFFECTS: No data directly modified by this routine, but     */
/*          child routines will modify data.                   */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*      clear_screen                                           */
/*      display                                                */
/*      get_num_input                                          */
/*      create_partition                                       */
/*      change_active_partition                                */
/*      delete_partition                                       */
/*      display_partition_information                          */
/*      find_active_partition                                  */
/*      change_drive                                           */
/*      internal_program_error                                 */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/******************** END OF SPECIFICATIONS ********************/

/*  */
void do_main_menu()

BEGIN

char   input;
char   max_input;

FLAG	error_switch;

unsigned    temp;
unsigned    i;


   input = c(NUL);                                                      /* AC000 */
   PercentFlag = (FLAG)FALSE;                                           /* AN000 */
   /* Intialize cur_disk indicator. It is 0 based for array usage */
   /* See if first disk readable */
   cur_disk = c(0);                                                     /* AC000 */
   if (!good_disk[0])
      BEGIN
       cur_disk++;
      END

   /* See if we have a valid combo of disk */
/*C36   if ((good_disk[0]) ||                                     */
/*C36          ((good_disk[1]) && (number_of_drives == uc(2))) || */                                            /* AC000 */
/*C36          ((good_disk[2]) && (number_of_drives == uc(3))) || */
/*C36          ((good_disk[3]) && (number_of_drives == uc(4))) || */
/*C36          ((good_disk[4]) && (number_of_drives == uc(5))) || */
/*C36          ((good_disk[5]) && (number_of_drives == uc(6))) || */
/*C36          ((good_disk[6]) && (number_of_drives == uc(7))) )  */
   temp = u(0);                                                         /*C36*/
   for (i=u(0);i<u(number_of_drives);i++)                               /*C36*/
       if (good_disk[i])                                                /*C36*/
           temp = u(1);                                                 /*C36*/
   if (temp == u(1))                                                    /*C36*/

      BEGIN
       clear_screen(u(0),u(0),u(24),u(79));                             /* AC000 */
       /* Display the copyright */
       display(menu_1);

       /* See if we couldn't access drive 1 */
		for (i = 0; i < number_of_drives; i++)
			BEGIN
			 if (!good_disk[i] && (error_switch == FALSE))
				{
           	insert[0] = c(i+'1');                                          /* AC000 */
           	display(error_30);
			 	error_switch = TRUE;
			   }
          END

       /* Display the menu every time this routine is returned to until ESC */
       input = c(NUL);                                                  /* AC000 */
       while (input !=c(ESC))                                           /* AC000 */
          BEGIN
            /* Put up most of the menu */
            display(menu_2);
            display(menu_3);
            display(menu_7);

            /* Put correct disk in current disk message */
            insert[0]=cur_disk+1+'0';
            display(menu_5);

            /* Display warning prompt if no active partitions */
            /* check to see if there is an avail partition                 */
            temp = u(0);                                                /* AC000 */
            for (i = u(0); i < u(4);i++)                                /* AC000 */
               BEGIN

                /* See if any non - zero system id bytes */
                temp = temp | part_table[cur_disk][i].sys_id ;
               END
            /* Any entry that isn't zero means */
            if (temp != u(0))                                           /* AC000 */
               BEGIN
                /* If there isn't an active partition and this is disk 1, then yell) */
                if ((!find_active_partition()) && (cur_disk == c(0)))   /* AC000 */
                   display(menu_6);
               END

            /* Get the menu input */

            /* See if more than one fixed disk */
            if (number_of_drives > uc(1))                              /* AC000 */
              BEGIN
               display(menu_4);
               max_input = c(5);                                        /* AC000 */
              END
            else     /* only 4 options */
                max_input = c(4);                                       /* AC000 */
            /* Setup default and go get input */
            input = get_num_input(c(1),max_input,input_row,input_col);  /* AC000 */
            switch(input)
              BEGIN
               case  '1': create_partition();
                          break;

               case  '2': change_active_partition();
                          break;

               case  '3': delete_partition();
                          break;

               case  '4': display_partition_information();
                          break;

               case  '5': change_current_drive();
				  				 break;

               case  ESC: break;  /* ESC case */

               default:   internal_program_error();
              END
          END
      END
   else
      BEGIN
       /* Can't read any drive, so quit */
       no_fatal_error = c(FALSE);                                       /* AC000 */
       display(error_2);
      END
   return;
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\makepart.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  05/30/90  EGH  C22  Commented out the routine clear_directory and all
*                      references to it.  It wasn't working and it may have
*                      been causing problems.
*  07/03/90  EGH  C23  Fixed assignment of system ID on lolgical volumes.
*                      Bug #1474
*  09/13/90  EGH  C21  We need to set the volume label and system for primary
*                      partitions now that we are using this information.
* 
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "string.h"                                                     /* AN000 */

#if 0                                                                   /*C22*/

/***************************************************************************/
/****  SR; 9/30/89; Calculates the first sector of the directory for    ****/
/****  the newly created partition and writes zeros to the first        ****/
/****  directory sector to eliminate garbage in the volume label.       ****/
/****                                                                   ****/
/***************************************************************************/

void clear_directory (unsigned long total_sectors, unsigned start_cylinder)
{

    char           retry;
    unsigned long  j;
    unsigned long  sectors_per_fat;
    char far       *buffer_pointer = boot_record;

    for (j = 0; j < BYTES_PER_SECTOR; j++)
        boot_record[j] = 0;                     /* Zero sector buffer  */

    retry = 0;
    do
    {
        retry++;
        if (total_sectors > ul(FAT16_SIZE))
        {                                       /* 16 bit FAT */
            j = 2 + (BYTES_PER_SECTOR * 2);
            sectors_per_fat = ((total_sectors - 33) + j - 1) / j;
        }
        else
        {                                       /* 12 bit FAT */
            j = 2 + ((BYTES_PER_SECTOR * 16) + 2) / 3;
            sectors_per_fat = ((total_sectors - 33) + j - 1) / j;
        }

        regs.x.bx = FP_OFF(buffer_pointer);
        segregs.es = FP_SEG(buffer_pointer);
        regs.h.dl = uc(cur_disk) + uc(0x80);
        j = 1 + (2 * sectors_per_fat);          /* sectors before directory */
        regs.h.cl = uc(1 + (j % max_sector[cur_disk]));
        regs.x.ax = u((j / max_sector[cur_disk]) + 1);
        regs.h.dh = uc(regs.x.ax % max_head[cur_disk]);
        regs.x.ax = u(regs.x.ax / max_head[cur_disk]);
        regs.x.ax = regs.x.ax + start_cylinder;
        regs.h.ch = regs.h.al;
        regs.h.cl = regs.h.cl | (regs.h.ah << 6);
        regs.h.ah = uc(WRITE_DISK);
        regs.h.al = 1;                          /* write one sector */
        DiskIo(&regs,&regs,&segregs);
    }
    while (regs.x.cflag && (retry < 5));
}

#endif                                                                  /*C22*/

/*  */

void make_partition(size,free_pointer,bootable,type)

unsigned        size;
char            free_pointer;
unsigned char   bootable;
char            type;

BEGIN

    char table_pointer;
    unsigned i;
    unsigned char   temp;
    unsigned long   total_sectors;

    /* Find a free spot to put it in */
    table_pointer = find_free_partition();

    if (table_pointer != ((char)(NOT_FOUND)))
        BEGIN
        /* found a free partition, now lets go fill it up */

        /* Do we need to make it active? */
        if (bootable == ((unsigned char)(ACTIVE)))
            BEGIN

            /* Go clear out a previously active one */
            for (i=u(0); i <u(4); i++)                                  /* AC000 */
                BEGIN
                if (part_table[cur_disk][i].boot_ind == uc(0x80))       /* AC000 */
                    BEGIN
                    part_table[cur_disk][i].changed = TRUE;
                    part_table[cur_disk][i].boot_ind = uc(0);           /* AC000 */
                    END
                END

                /* Now mark the new one active */
                part_table[cur_disk][table_pointer].boot_ind = uc(0x80); /* AC000 */
            END
        else
            BEGIN
            /* Mark it as not active, leaving the others alone */
            part_table[cur_disk][table_pointer].boot_ind = uc(0);       /* AC000 */
            END

            /* Go get the start cylinder */
            part_table[cur_disk][table_pointer].start_cyl = free_space[free_pointer].start;

            /* Setup end cylinder */
            part_table[cur_disk][table_pointer].end_cyl = part_table[cur_disk][table_pointer].start_cyl + size - 1;

            /* Start sector is always 1 */
            part_table[cur_disk][table_pointer].start_sector = uc(1);   /* AC000 */

            /* End sector is always the last sector */
            part_table[cur_disk][table_pointer].end_sector = max_sector[cur_disk];

            /* End head is always the last head */
            part_table[cur_disk][table_pointer].end_head = uc(max_head[cur_disk] -1);      /* AC004 */

            /* Start head is always 0 unless this is track 0 - then it is 1 */
            temp = uc(0);                                               /* AC000 */
            if (part_table[cur_disk][table_pointer].start_cyl == u(0))  /* AC000 */
                BEGIN
                temp = uc(1);                                           /* AC000 */
                END
            part_table[cur_disk][table_pointer].start_head = temp;

            /* Figure out the total number of sectors */
            /* Total sectors in partition =                    */
            /* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
            /* - [start_head * max_sector]                     */
            /* Note: This is assuming a track or cylinder aligned partition */

            /* First - get the total size in Cylinders assuming head 0 start*/
            total_sectors = ((unsigned long)(part_table[cur_disk][table_pointer].end_cyl -
                              part_table[cur_disk][table_pointer].start_cyl+1));

            /* Now multiply it by the number of sectors and heads per track */
            total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];

            /* This will give us the total of sectors if it is cyl aligned */
            /* Now, if it isn't aligned on head 0, we need to subtract off */
            /* the skipped tracks in the first cylinder  */

            /* Because the head is zero based, we can get the total number of */
            /* skipped sectors by multipling the head number by sectors per track */
            total_sectors = total_sectors - ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
                              max_sector[cur_disk];
            part_table[cur_disk][table_pointer].num_sec = total_sectors;

            /* Get the relative sector */
            /* Figure out the total number of sectors */
            /* Total sectors before partition =                */
            /* (start_cyl)*(max_sector)*(max_head)]            */
            /* + [start_head * max_sector]                     */
            /* Note: This is assuming a track or cylinder aligned partition */

            /* Start cyl will work because it is zero based */
            total_sectors = ((unsigned long)part_table[cur_disk][table_pointer].start_cyl);

            /* Get sectors up to head 0 of the partition */
            total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];

            /* Because the head is zero based, we can get the total number of */
            /* skipped sectors by multipling the head number by sectors per track */
            total_sectors = total_sectors + ((unsigned long)part_table[cur_disk][table_pointer].start_head) *
                              max_sector[cur_disk];

            /* Save it! */
            part_table[cur_disk][table_pointer].rel_sec = total_sectors;

            /* Setup the system id byte */
            if (type == ((char)(EXTENDED)))
                BEGIN
                temp = uc(EXTENDED);                                    /* AC000 */
                END
            else
                BEGIN
                if (type == ((char)(PRIMARY)))
                    BEGIN
                    /* Always set to 06h - let format worry about setting to correct value */
                    /* SR; 9/30/89; We fix up the size ourselves here. The
                       calculation is simple. If total_sectors > 65536 then
                       type = 06 else if total_sectors > 32680 then type = 04
                       else type = 01 */

                    /* SR; 9/30/89; Calculate total_sectors from start
                       including the hidden sectors */

                    total_sectors += part_table[cur_disk][table_pointer].num_sec;

                    if ( (total_sectors >> 16) > 0 )
                        temp = uc(DOSNEW); /* Partition extends beyond the 32M boundary */
                    else if (part_table[cur_disk][table_pointer].num_sec > ul( FAT16_SIZE ))
                        temp = uc(DOS16);
                    else
                        temp = uc(DOS12);                                  /* AC000 */                            /*  AN000  */
                    END
                else
                    BEGIN
                    internal_program_error();
                    END
                END

            /* We got the sys id, now put it in */
            part_table[cur_disk][table_pointer].sys_id = temp;

            /* Set the changed flag */
            part_table[cur_disk][table_pointer].changed = TRUE;

            /* Set the mbytes used */
            part_table[cur_disk][table_pointer].mbytes_used =
                cylinders_to_mbytes(size,cur_disk);                     /* AN004 */

            /* Set the percent used */
            part_table[cur_disk][table_pointer].percent_used =
                cylinders_to_percent(((part_table[cur_disk][table_pointer].end_cyl-part_table[cur_disk][table_pointer].start_cyl)+1),
                total_disk[cur_disk]);                                  /* AN000 */

            /* set the system to unknown and volume label to blanks */  /*C21*/
            strcpy(part_table[cur_disk][table_pointer].system,NOFORMAT); /*C21*/
            strcpy(part_table[cur_disk][table_pointer].vol_label,NOVOLUME); /*C21*/

            /* SR; 9/30/89; Fill the first directory sector with zeros to
               eliminate garbage in the volume label */

/*C22       clear_directory (part_table[cur_disk][table_pointer].num_sec,    */
/*C22                        part_table[cur_disk][table_pointer].start_cyl); */

        END
    else

        BEGIN
        /* This should not have happened */
        internal_program_error();
        return;
        END

    return;
END


/*  */
char make_volume(size,free_pointer)

unsigned    size;
char   free_pointer;

BEGIN

    char table_pointer;
/*C00    unsigned i;        */
    unsigned ext_part_num;                                                  /* AN000 */
    unsigned char   temp;
    unsigned long   total_sectors;

    /* Find a free spot to put it in */
    table_pointer = find_free_ext();

    if (table_pointer != ((char)(NOT_FOUND)))
       BEGIN
        /* found a free partition, now lets go fill it up */


        /* This can never be marked active */
        ext_table[cur_disk][table_pointer].boot_ind = uc(0);        /* AC000 */


        /* Go get the start cylinder */
        ext_table[cur_disk][table_pointer].start_cyl = free_space[free_pointer].start;

        /* Setup end cylinder */
        ext_table[cur_disk][table_pointer].end_cyl = ext_table[cur_disk][table_pointer].start_cyl + size - 1;

        /* Start sector is always 1 */
        ext_table[cur_disk][table_pointer].start_sector = uc(1);    /* AC000 */

        /* End sector is always the last sector */
        ext_table[cur_disk][table_pointer].end_sector = max_sector[cur_disk];

        /* End head is always the last head */
        ext_table[cur_disk][table_pointer].end_head = uc(max_head[cur_disk]-1);  /* AC004 */

        /* Start head is always 1 - NOTE: This is a shortcut for PC-DOS */
        /* If this is being modified for IFS drivers this may not be the */
        /* the case - use caution */
        ext_table[cur_disk][table_pointer].start_head = uc(1);    /* AC000 */

        /* Figure out the total number of sectors */
        /* Total sectors in partition =                    */
        /* [(end_cyl - start_cyl)*(max_sector)*(max_head)] */
        /* - [start_head * max_sector]                     */
        /* Note: This is assuming a track or cylinder aligned partition */

        /* First - get the total size in Cylinders assuming head 0 start*/
        total_sectors = ((unsigned long)(ext_table[cur_disk][table_pointer].end_cyl -
           ext_table[cur_disk][table_pointer].start_cyl+1));

        /* Now multiply it by the number of sectors and heads per track */
        total_sectors = total_sectors * max_sector[cur_disk] * max_head[cur_disk];

        /* This will give us the total of sectors if it is cyl aligned */
        /* Now, if it isn't aligned on head 0, we need to subtract off */
        /* the skipped tracks in the first cylinder  */

        /* Because the head is zero based, we can get the total number of */
        /* skipped sectors by multipling the head number by sectors per track */
        total_sectors = total_sectors - ((unsigned long)(ext_table[cur_disk][table_pointer].start_head *
                           max_sector[cur_disk]));

        ext_table[cur_disk][table_pointer].num_sec = total_sectors;

        /* Get the relative sector */
        /* Figure out the total number of sectors */
        /* Total sectors before partition = max_sector     */
        /* NOTE: Again, this is a PC-DOS 3.30 shortcut - by definition */
        /* a logical drive always starts on head 1, so there is always */
        /* one tracks worth of sectors before it. Hence, max_sector */

        /* Save it! */
        ext_table[cur_disk][table_pointer].rel_sec = ((unsigned long)(max_sector[cur_disk]));

        /* Setup the system id byte */
        /* Set to 06h - format will fix later on */
        /* EGH; 7/03/90; We fix up the size ourselves here. The
           calculation is simple. If total_sectors > 65536 then
           type = 06 else if total_sectors > 32680 then type = 04
           else type = 01 */

        if (ext_table[cur_disk][table_pointer].num_sec > ul(65536))     /*C23*/
            temp = uc(DOSNEW);                                         /* AC000 */                                    /*  AN000  */
        else if (ext_table[cur_disk][table_pointer].num_sec > ul(FAT16_SIZE)) /*C23*/
            temp = uc(DOS16);                                           /*C23*/
        else                                                            /*C23*/
            temp = uc(DOS12);                                           /*C23*/

        /* We got the sys id, now put it in */
        ext_table[cur_disk][table_pointer].sys_id = temp;

        /* Set the changed flag */
        ext_table[cur_disk][table_pointer].changed = TRUE;

        /* Set the mbytes used */
        ext_table[cur_disk][table_pointer].mbytes_used =
            cylinders_to_mbytes(size,cur_disk);                   /* AN004 */

        /* find the number of the extended partiton to figure out percent */
        ext_part_num = find_partition_location(uc(EXTENDED));              /* AN000 */

        /* Set the percent used */
        ext_table[cur_disk][table_pointer].percent_used =
            cylinders_to_percent(((ext_table[cur_disk][table_pointer].end_cyl-ext_table[cur_disk][table_pointer].start_cyl)+1),
            ((part_table[cur_disk][ext_part_num].end_cyl-part_table[cur_disk][ext_part_num].start_cyl)+1));      /* AN000 */

        /* set the system to unknown and volume label to blanks */
        strcpy(ext_table[cur_disk][table_pointer].system,NOFORMAT);     /* AN000 */
        strcpy(ext_table[cur_disk][table_pointer].vol_label,NOVOLUME);  /* AN000 */

        /* SR; 9/30/89; Fill the first directory sector with zeros to
           eliminate garbage in the volume label */

/*C22   clear_directory (part_table[cur_disk][table_pointer].num_sec,    */
/*C22                    part_table[cur_disk][table_pointer].start_cyl); */

       END
    else

       BEGIN
        /* This should not have happened */
        internal_program_error();
       END

    return(table_pointer);
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\rempart.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  09/18/90  EGH  C26  This module was created to contain the routines
*                      remove_partition() and remove_volume().  These
*                      routines eliminate duplicate code.
*
******************************************************************************/

#include "dos.h"
#include "fdisk.h"
#include "extern.h"
#include "subtype.h"
#include "string.h"

/*  */

void remove_partition(drive,entry)

char        drive;
unsigned    entry;

BEGIN

    /* Set Partition entry to zero */
    part_table[drive][entry].boot_ind = uc(0);
    part_table[drive][entry].start_head = uc(0);
    part_table[drive][entry].start_sector = uc(0);
    part_table[drive][entry].start_cyl = u(0);
    part_table[drive][entry].sys_id = uc(0);
    part_table[drive][entry].end_head = uc(0);
    part_table[drive][entry].end_sector = uc(0);
    part_table[drive][entry].end_cyl = u(0);
    part_table[drive][entry].rel_sec = ul(0);
    part_table[drive][entry].num_sec = ul(0);
    part_table[drive][entry].changed = (FLAG)TRUE;
    part_table[drive][entry].mbytes_used = f(0);
    part_table[drive][entry].percent_used = u(0);

    strcpy(part_table[drive][entry].system,c(NUL));
    strcpy(part_table[drive][entry].vol_label,c(NUL));

    return;
END


/*  */
void remove_volume(drive,entry)

char        drive;
unsigned    entry;

BEGIN

    /* Set volume entry to zero */
    ext_table[drive][entry].boot_ind = uc(0);
    ext_table[drive][entry].start_head = uc(0);
    ext_table[drive][entry].start_sector = uc(0);
    ext_table[drive][entry].start_cyl = u(0);
    ext_table[drive][entry].sys_id = uc(0);
    ext_table[drive][entry].end_head = uc(0);
    ext_table[drive][entry].end_sector = uc(0);
    ext_table[drive][entry].end_cyl = u(0);
    ext_table[drive][entry].rel_sec = ul(0);
    ext_table[drive][entry].num_sec = ul(0);
    ext_table[drive][entry].mbytes_used = f(0);
    ext_table[drive][entry].percent_used = u(0);
    ext_table[drive][entry].changed = TRUE;
    ext_table[drive][entry].drive_letter = NUL;

    strcpy(ext_table[drive][entry].system,c(NUL));
    strcpy(ext_table[drive][entry].vol_label,c(NUL));

    return;
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\reboot.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
; ========================================================

COMMENT #

	REBOOT.ASM

	JH - 12/01/89

END COMMENT #

;-----------------------------------------------------------------------------;
;	K E Y B O A R D   S C A N   C O D E S				      ;
;-----------------------------------------------------------------------------;

KB_INTERCEPT	EQU	4fh

DEL_KEY		EQU	53h
ALT_SHIFT	EQU	08h
CTL_SHIFT	EQU	04h

WARM_BOOT_CODE	EQU	1234h	

MIN_DELAY	EQU	1
MAX_DELAY	EQU	255

;-----------------------------------------------------------------------------;
;             SYSTEM   BOARD   I/O   PORTS                     		      ;
;-----------------------------------------------------------------------------;

;-----------------------------------------------------------------------------;
;   The system bus control port.  It is responsible for generating a          ;
;   "fast" shutdown pulse.                                                    ;
;-----------------------------------------------------------------------------;
SYSTEM_CONTROL_PORT		EQU	92h
	SYSTEM_SHUTDOWN_BIT	EQU	00000001b

;-----------------------------------------------------------------------------;
;   The 8042 microcontroller command port.                                    ;
;-----------------------------------------------------------------------------;
PARALLEL_PORT_A			EQU	60h		; Programmable Interface Adapter of IBM system board used for controlling
	WRITE_OUTPUT_PORT_CMD	EQU	0D1h		; Write to controller output port
	GATE_A20_CMD		EQU	0DFh		; Gate A20 command
	RESET_SYSTEM_CMD	EQU	0FEh		; Shutdown system command

;-----------------------------------------------------------------------------;
;   The 8042 microcontroller status port.                                     ;
;-----------------------------------------------------------------------------;
STAT_CMD_PORT			EQU	64h		; 8042 microcontroller status port.
	INT_BUFF_FULL_STAT	EQU	00000010b	; Key pressed status

;-----------------------------------------------------------------------------;
;   MACRO:   IO_DELAY                                                         ;
;            Insert a delay to allow back-to-back I/O on slow peripherals.    ;
;            Jumps are usually used.  There are four in this macro to 	      ;
;            guarantee working on a 30 MHz+ 486.                              ;
;-----------------------------------------------------------------------------;
IO_DELAY   		MACRO
	jmp		$+2
	jmp		$+2
	jmp		$+2
	jmp		$+2
			ENDM

;-----------------------------------------------------------------------------;
;	BIOS DATA AREA LOCATED AT 40:00
;-----------------------------------------------------------------------------;

ROM_DATA SEGMENT AT 040h

	org	17h
KB_FLAG		LABEL BYTE


	org	072h
WarmBootFlag	LABEL WORD

ROM_DATA ENDS

;-----------------------------------------------------------------------------;
;	CPU POWER-ON STARTUP LOCATION AT ffff:00
;-----------------------------------------------------------------------------;

ROM_BIOS SEGMENT AT 0ffffh
	org	0

PowerOnReset	LABEL FAR

ROM_BIOS ENDS

;-----------------------------------------------------------------------------;

_text	segment byte public 'code'
	assume	cs:_TEXT
	assume	ds:nothing
	assume	es:nothing
	assume	ss:nothing

;-----------------------------------------------------------------------------;
;   Procedure Name:   ShutdownSystem                                          ;
;           Author:   WJK
;             Date:   3/29/88                                                 ;
;      Description:   This procedure tries to shut down a ISA or MCA system   ;
;                     using a combination of hardware and software methods.   ;
;                                                                             ;
;                     The hardware methods are nearly foolproof but require   ;
;                     a keyboard controller or a parallel port that has       ;
;                     main-processor-reset hardware capabilities.  Either of  ;
;                     the hardware methods cause a reset signal to be         ;
;                     generated, thereby resetting the CPU, and in some       ;
;                     system architectures (MCA specifically) all the add-in  ;
;                     hardware in a system as well.  All AT class, new XT     ;
;                     class, and all MCA class systems tested have either     ;
;                     one or both of these hardware capabilities.  The        ;
;                     hardware methods work extremely well for systems that   ;
;                     have 286, 386, 486 CPUs because they can effect a       ;
;                     shutdown independent of processor mode.  The only       ;
;                     exception would be a 386/486 running in virtual mode    ;
;                     with software that trapped port accesses to these ports ;
;                     and prevented the data from being output.               ;
;                                                                             ;
;                     The hardware methods are tried first.  Failing these    ;
;                     shutdown methods, the proc reverts to software          ;
;                     techniques.  The first technique is simply jumping to   ;
;                     processors power-on entry address.  The second is       ;
;                     generating an INT 19h.  Because of the possibility      ;
;                     of DOS/TSR trapping INT 19h & not restoring all the     ;
;                     necessary int vectors properly, the second method       ;
;                     does not work well with all versions of DOS or in       ;
;                     all configurations.  It's included but never executed.  ;
;                     The first software method is used and has worked well   ;
;                     in the systems tested.                                  ;
;                                                                             ;
;           Passed:   None                                                    ;
;         Returned:   Normally, there is NO return from this procedure.       ;
;                                                                             ;
;            Calls:   XmitKybCntrlCmd                                         ;
;                                                                             ;
;        Registers:   ax  bx  cx                                              ;
;                                                                             ;
;        Modified/                                                            ;
;       Referenced:   ROM_BIOS_RAM_AREA:WarmBootFlag                          ;
;-----------------------------------------------------------------------------;
	public	_reboot
_reboot proc	near

	;**   Disable interrupts while shutting down.
;       cli                         ; restore this line if h/w mechanism used

	;**   Set the warm-boot-flag in the ROM BIOS communications area.
	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA

	mov	WarmBootFlag, WARM_BOOT_CODE

COMMENT #
        The hardware reboot mechanisms have been disabled for the time
        being to avoid problems with random hardware with non-standard
        reboot needs.


	;**   Gate A20 on.   -------------------------------------------------;
	;   This is necessary because some old flaky BIOS'/controllers don't  ;
	;   turn on A20 soon enough after a reset generated by the keyboard   ;
	;   controller.  This causes the BIOS to erroneously determine that   ;
	;   there is no memory above 1 Mbyte.  So it's done FIRST before the  ;
	;   shutdown.                                                         ;
	;---------------------------------------------------------------------;
	mov	al, WRITE_OUTPUT_PORT_CMD
	mov	bx, MIN_DELAY
	call	NEAR PTR XmitKybCntrlCmd

	mov	al, GATE_A20_CMD
	out	PARALLEL_PORT_A, al

		; Try shutting down the processor by using the kybd controller.

	mov	al, RESET_SYSTEM_CMD
	mov	bx, MAX_DELAY
	call	NEAR PTR XmitKybCntrlCmd

		; The keyboard controller method didn't work.
		; Try shutting down the system by using a PS2 "fast" shutdown.

	in	al, SYSTEM_CONTROL_PORT
	and	al, NOT (SYSTEM_SHUTDOWN_BIT)
	IO_DELAY
	out	SYSTEM_CONTROL_PORT, al
	or	al, SYSTEM_SHUTDOWN_BIT
	IO_DELAY
	out	SYSTEM_CONTROL_PORT, al

		; Wait while the hardware emits the reset pulse.
	mov	bx, MAX_DELAY
	call	NEAR PTR Delay

	;---------------------------------------------------------------------;
	;   Neither of the h/w reset techniques worked.			      ;
	;---------------------------------------------------------------------;

        FDisk relies on the software reboot mechanisms only now.
END COMMENT #
        
	mov	AX,3515h
	int	21h			; Get int 15h vector in ES:BX
	mov	AX,ES			; AX == Segment
	or	AX,BX			; Is this a NULL ptr
	jz	WarmBoot		; If zero we can't do an int 15h

DoInt15:
	mov	ax, seg WarmBootFlag
	mov	ds, ax
	assume	DS:ROM_DATA

	mov	KB_FLAG,ALT_SHIFT OR CTL_SHIFT
	mov	AX,(KB_INTERCEPT SHL 8) OR DEL_KEY
	int	15h			; Put Ctrl/Alt/Del into key buffer

WarmBoot:
		; Jump to the processor power-on address FFFF:0000h

	jmp	PowerOnReset

_reboot 	ENDP


COMMENT #

        These helper routines also pulled because of hardware compatibility
        problems.
page
;-----------------------------------------------------------------------------;
;   Procedure Name:   XmitKybCntrlCmd                                         ;
;           Author:   W J K
;             Date:   7/12/88                                                 ;
;      Description:   This procedures sends the command in al to the          ;
;                     keyboard microcontroller.                               ;
;                                                                             ;
;           Passed:   al = Keyboard controller command.                       ;
;                     bx = End of keyboard controller command delay constant. ;
;         Returned:   None.                                                   ;
;                                                                             ;
;        Called By:   ShutdownSystem                                          ;
;            Calls:   Delay                                                   ;
;                                                                             ;
;        Registers:   ax  bx  cx                                              ;
;                                                                             ;
;        Modified/                                                            ;
;       Referenced:   Keyboard controller port.                               ;
;-----------------------------------------------------------------------------;

XmitKybCntrlCmd	proc	NEAR

		; Save the command & set max loop count for the wait loop.

	mov	ah, al		; (ah) = kybd controller cmd
	mov	CX,0ffffh
	
xkcc01:		; Wait for keyboard controller to indicate a buffer empty status.
	jcxz	EndLoop1
	in	al, STAT_CMD_PORT
	test	al, INT_BUFF_FULL_STAT
	loopnz	xkcc01

EndLoop1:
		; Restore the command & output the keyboard controller command.

	mov	al, ah		; (al) = kybd controller cmd
	out	STAT_CMD_PORT, al

		; Wait here while the keyboard controller processes the command.

	call	Delay		; (bx) = requested no. of delays
	ret

XmitKybCntrlCmd	endp

;-----------------------------------------------------------------------------;
;   Procedure Name:   Delay                                                   ;
;           Author:   W J K
;             Date:   7/12/88                                                 ;
;      Description:   This procedure waits for a number of CPU cycles.        ;
;                     It's used to wait for the keyboard controller           ;
;                     while it responds to commands that are sent to it.      ;
;                                                                             ;
;           Passed:   bx = End of keyboard controller command delay constant. ;
;         Returned:   None.                                                   ;
;                                                                             ;
;        Called By:   ShutdownSystem                                          ;
;                     XmitKybdCntrlCmd                                        ;
;            Calls:   Nothing                                                 ;
;                                                                             ;
;        Registers:   bx  cx                                                  ;
;                                                                             ;
;        Modified/                                                            ;
;       Referenced:   Nothing                                                 ;
;-----------------------------------------------------------------------------;
Delay	proc	NEAR

		; Exit if no delay is requested.
	or	bx, bx
	jz	del02

		; Delay a fixed large number of CPU cycles.
	xor	cx, cx
del01:	loop	del01

		; Repeat till the number of delays are done.
	dec	bx
	jnz	del01
del02:	ret

Delay		endp

END COMMENT #
; ========================================================

_text	ends

	END

; ========================================================

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\tdisplay.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  03/22/90  EGH  C15  Added code to recognize additional partition types.
*  08/01/90  EGH  C24  Problem fixed - on a two drive system with only a single
*                      primary partition on drive 2, the display partition
*                      information screen reported the partiton as drive D:.
*  08/27/90  EGH  C25  Added support for displaying the volume label when
*                      creating/deleting primary partitions.                     logical DOS drives.
*  10/19/90  EGH  C32  Added code to handle multiple primary DOS partitions.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */
#include "stdio.h"
#include "string.h"
#include "memory.h"

/*  */
char table_display()

BEGIN


    unsigned    i;
/*C00    unsigned    x;  */
    unsigned    io;
    char       *ThisPartitionType;
    char        ThisPartitionLetter[3];
    FLAG        partition_found;
    char        partition_num;

    /* initialize all the inserts to blanks */
/*C25    memset(insert,c(' '),4*21); */
    memset(insert,c(' '),4*38);                                         /*C25*/
    io = u(0);

    /* Get current drive letters */                                     /*C32*/
    get_letters();                                                      /*C32*/

    /* Sort the partitions */
    sort_part_table(c(4));                                             /* AC000 */

    /* loop thru the partitions, only print stuff if it is there */
    partition_found = FALSE;
    partition_num = c(0);                                              /* AC000 */

    for (i=u(0); i < u(4); i++)                                        /* AC000 */
        BEGIN

        if (part_table[cur_disk][sort[i]].sys_id != uc(0))             /* AC000 */
            BEGIN

            partition_found = TRUE;

            strcpy(ThisPartitionLetter,"  ");
            switch(part_table[cur_disk][sort[i]].sys_id)
                BEGIN
                case DOSNEW:                                           /* AN000 */
                case DOS16:
                case DOS12:
                    ThisPartitionType = DOS_part;
/*C32               part_table[cur_disk][sort[i]].drive_letter = table_drive_letter(); */      /* AN000 */
                    sprintf(ThisPartitionLetter,"%c%c",
                            part_table[cur_disk][sort[i]].drive_letter,
                            ( part_table[cur_disk][sort[i]].drive_letter == c(' ') ) ? ' ' : ':');
                    break;
                case EXTENDED:
                    ThisPartitionType = EXTENDED_part;
                    break;
                case BAD_BLOCK:
                    ThisPartitionType = BAD_BLOCK_part;
                    break;
                case XENIX1:
                    ThisPartitionType = XENIX_part;
                    break;
                case XENIX2:
                    ThisPartitionType = XENIX_part;
                    break;
                case PCIX:
                    ThisPartitionType = PCIX_part;
                    break;
                case HPFS:                                              /*C15*/
                    ThisPartitionType = HPFS_part;                      /*C15*/
                    break;                                              /*C15*/
                case NOVELL:                                            /*C15*/
                    ThisPartitionType = NOVELL_part;                    /*C15*/
                    break;                                              /*C15*/
                case CPM:                                               /*C15*/
                    ThisPartitionType = CPM_part;                       /*C15*/
                    break;                                              /*C15*/
                default:
                    ThisPartitionType = NON_DOS_part;
                    break;
                END

/*C25       io += sprintf(&insert[io],"%-2.2s%c%c%-7.7s%4.0d%3.0d%%",                     */
/*C25                  ThisPartitionLetter,                                               */
/*C25                  partition_num+'1',                                                 */
/*C25                  (part_table[cur_disk][sort[i]].boot_ind == uc(0x80)) ? 'A' : ' ',  */
/*C25                  ThisPartitionType,                                                 */
/*C25                  part_table[cur_disk][sort[i]].mbytes_used,                         */
/*C25                  part_table[cur_disk][sort[i]].percent_used);                       */

            io += sprintf(&insert[io],"%-2.2s%c%c%-7.7s%-11.11s%4.0d%-8.8s%3.0d%%",       /*C25*/
                       ThisPartitionLetter,                                               /*C25*/
                       partition_num+'1',                                                 /*C25*/
                       (part_table[cur_disk][sort[i]].boot_ind == uc(0x80)) ? 'A' : ' ',  /*C25*/
                       ThisPartitionType,                                                 /*C25*/
                       part_table[cur_disk][sort[i]].vol_label,                           /*C25*/
                       part_table[cur_disk][sort[i]].mbytes_used,                         /*C25*/
                       part_table[cur_disk][sort[i]].system,                              /*C25*/
                       part_table[cur_disk][sort[i]].percent_used);                       /*C25*/

            partition_num++;

            END

        END

    /* Do a clearscreen to erase previous data */
    clear_screen(u(8),u(0),u(12),u(79));                               /* AC000 */

    if (partition_found) display(menu_14);
        else display(status_8);

    /* Return true if partitions exist, false otherwise */
    if (partition_found) return(TRUE);

    return(FALSE);

END

/*  */
#if 0	/******************** New routine replaces this ********/

char table_drive_letter()

BEGIN
    char drive_letter;

    /* Put in drive letter in display */
    if (cur_disk == c(0))                                             /* AC000 */
       BEGIN
        /* There is a primary partition on 80h, so drive C: */
        drive_letter = c('C');                                        /* AC000 */
       END
    else
       BEGIN
        /* We are on drive 81h, so assume D: */
        drive_letter = c('D');                                        /* AC000 */

        /* See if primary exists on 80h drive */

        /* Check for primary on drive 80h */
        if (!(find_partition_type(uc(DOS12)) || find_partition_type(uc(DOS16)) || find_partition_type(uc(DOSNEW)))) /* AC000 */
           BEGIN
            drive_letter = c('C');                                    /* AC000 */
           END
       END
    return(drive_letter);
END
#endif	/***************** New routine (below) ********************/

#if 0   /******************** New routine replaces this ********/       /*C24*/
char table_drive_letter()

BEGIN
char drive_letter;

    /* Put in drive letter in display */
    drive_letter = c('C') + cur_disk;                            /* AC000 */

    /* Check for primary on drive 80h */
    if (!(find_partition_type(uc(DOS12)) || find_partition_type(uc(DOS16)) || find_partition_type(uc(DOSNEW)))) /* AC000 */
       BEGIN
        drive_letter = c('C');                                    /* AC000 */
       END

    return(drive_letter);
END
#endif  /***************** New routine (below) ********************/    /*C24*/

#if 0   /* Routine no longer needed */                                  /*C32*/
char table_drive_letter()                                               /*C24*/
                                                                        /*C24*/
BEGIN                                                                   /*C24*/
char drive_letter;                                                      /*C24*/
char temp;                                                              /*C24*/
                                                                        /*C24*/
    /* Initialize drive letter */                                       /*C24*/
    drive_letter = c(0);                                                /*C24*/
                                                                        /*C24*/
    /* Save current disk */                                             /*C24*/
    temp = cur_disk;                                                    /*C24*/
                                                                        /*C24*/
    /* Count the number of primary partitons on the preceeding disks */ /*C24*/
    cur_disk = c(0);                                                    /*C24*/
    while(cur_disk < temp)                                              /*C24*/
       {                                                                /*C24*/
       if (find_partition_type(uc(DOS12)) ||                            /*C24*/
           find_partition_type(uc(DOS16)) ||                            /*C24*/
           find_partition_type(uc(DOSNEW)))                             /*C24*/
           drive_letter++;                                              /*C24*/
       cur_disk++;                                                      /*C24*/
       }                                                                /*C24*/
                                                                        /*C24*/
    /* Restore current disk */                                          /*C24*/
    cur_disk = temp;                                                    /*C24*/
                                                                        /*C24*/
    /* Get drive letter */                                              /*C24*/
    drive_letter += c('C');                                             /*C24*/
                                                                        /*C24*/
    return(drive_letter);                                               /*C24*/
END                                                                     /*C24*/
#endif                                                                  /*C32*/


void get_letters()                                                      /*C32*/
BEGIN                                                                   /*C32*/
                                                                        /*C32*/
unsigned char i,j;                                                      /*C32*/
unsigned char active_primary_count;                                     /*C32*/
unsigned char pri_part;                                                 /*C32*/
                                                                        /*C32*/
    /* initialize next letter */                                        /*C32*/
    next_letter = c(SEA);                                               /*C32*/
                                                                        /*C32*/
    /* get primary DOS partition letters on all drives */               /*C32*/
    for (j = uc(0); j < number_of_drives; j++)                          /*C32*/
       BEGIN                                                            /*C32*/
        /* initialize variables */                                      /*C32*/
        primary_partition_count = 0;                                    /*C32*/
        active_primary_count = 0;                                       /*C32*/
        pri_part = 0xFF;                                                /*C32*/
                                                                        /*C32*/
        /* Look at all partitions */                                    /*C32*/
        for (i=u(0); i < u(4); i++)                                     /*C32*/
           BEGIN                                                        /*C32*/
            /* Compute e letter */                                      /*C32*/
            if ( (part_table[j][i].sys_id == DOS12) ||                  /*C32*/
                 (part_table[j][i].sys_id == DOS16) ||                  /*C32*/
                 (part_table[j][i].sys_id == DOSNEW)   )                /*C32*/
               BEGIN                                                    /*C32*/
                part_table[j][i].drive_letter = c(' ');                 /*C32*/                         /* AN000 */
                if ((primary_partition_count == 0) ||                   /*C32*/
                    ((part_table[j][i].boot_ind == 0x80) &&             /*C32*/
                     (active_primary_count == 0)))                      /*C32*/
                    pri_part = c(i);                                    /*C32*/
                if (part_table[j][i].boot_ind == 0x80)                  /*C32*/
                    active_primary_count++;                             /*C32*/
                primary_partition_count++;                              /*C32*/
               END                                                      /*C32*/
           END                                                          /*C32*/
        if ((pri_part != 0xFF) && (next_letter <= c('Z')))              /*C32*/
            part_table[j][pri_part].drive_letter = next_letter++;       /*C32*/
       END                                                              /*C32*/
                                                                        /*C32*/
    /* get logical DOS drive letters on all drives */                   /*C32*/
    for (j = uc(0); j < number_of_drives; j++)                          /*C32*/
       BEGIN                                                            /*C32*/
        /* Look at all partitions */                                    /*C32*/
        for (i=u(0); i < u(23); i++)                                    /*C32*/
           BEGIN                                                        /*C32*/
            /* Set drive letter */                                      /*C32*/
            if ( (ext_table[j][i].sys_id == DOS12) ||                   /*C32*/
                 (ext_table[j][i].sys_id == DOS16) ||                   /*C32*/
                 (ext_table[j][i].sys_id == DOSNEW)   )                 /*C32*/
                if (next_letter <= c('Z'))                              /*C32*/
                    ext_table[j][i].drive_letter = next_letter++;       /*C32*/
                else                                                    /*C32*/
                    ext_table[j][i].drive_letter = c(' ');              /*C32*/
           END                                                          /*C32*/
       END                                                              /*C32*/
                                                                        /*C32*/
    /* get enhdisk partition letters on all drives */                   /*C32*/
    for (j = uc(0); j < number_of_drives; j++)                          /*C32*/
       BEGIN                                                            /*C32*/
        /* Look at all active primary partitions */                     /*C32*/
        for (i=u(0); i < u(4); i++)                                     /*C32*/
           BEGIN                                                        /*C32*/
            /* Set drive letter */                                      /*C32*/
            if (((part_table[j][i].sys_id == DOS12) ||                  /*C32*/
                 (part_table[j][i].sys_id == DOS16) ||                  /*C32*/
                 (part_table[j][i].sys_id == DOSNEW)) &&                /*C32*/
                (part_table[j][i].boot_ind == 0x80))                    /*C32*/                             /* AN000 */
                if ((part_table[j][i].drive_letter == c(' ')) &&        /*C32*/
                    (next_letter <= c('Z')))                            /*C32*/
                    part_table[j][i].drive_letter = next_letter++;      /*C32*/                         /* AN000 */
           END                                                          /*C32*/
        /* Look at all non-active primary partitions */                 /*C32*/
        for (i=u(0); i < u(4); i++)                                     /*C32*/
           BEGIN                                                        /*C32*/
            /* Set drive letter */                                      /*C32*/
            if (((part_table[j][i].sys_id == DOS12) ||                  /*C32*/
                 (part_table[j][i].sys_id == DOS16) ||                  /*C32*/
                 (part_table[j][i].sys_id == DOSNEW)) &&                /*C32*/
                (part_table[j][i].boot_ind != 0x80))                    /*C32*/                             /* AN000 */
                if ((part_table[j][i].drive_letter == c(' ')) &&        /*C32*/
                    (next_letter <= c('Z')))                            /*C32*/
                    part_table[j][i].drive_letter = next_letter++;      /*C32*/                         /* AN000 */
           END                                                          /*C32*/
       END                                                              /*C32*/
                                                                        /*C32*/
    return;                                                             /*C32*/
                                                                        /*C32*/
END                                                                     /*C32*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\profile.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */

/*                                                                          */
/****************************************************************************/
/* Define statements                                                        */
/****************************************************************************/
/*                                                                          */

#define BEGIN    {
#define END      }
#define ESC     0x1B
#define NUL     0x00
#define NOT_FOUND 0xFF
#define DELETED   0xFF
#define INVALID   0xFF
#define FALSE   (1==0)
#define TRUE    !FALSE
#define CR      0x0D

/*                                                                          */
/****************************************************************************/
/* Declare Global variables                                                */
/****************************************************************************/
/*                                                                          */




unsigned       input_row;
unsigned       input_col;
char           insert[200];
char           *pinsert = insert;


/*                                                                          */
/****************************************************************************/
/* Subroutine Definitions                                                  */
/****************************************************************************/
/*                                                                          */

void             clear_screen(unsigned,unsigned,unsigned,unsigned);
void             display(char far *);
char             wait_for_ESC(void);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\space.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/07/90  EGH  C04  Problem fixed - Partitions can be created that overlap.
*                      Fix prevents this creation.
*  03/07/90  EGH  C05  Problem fixed - FDISK could create primary partitions
*                      and logical volumes greater than DOS can handle.  Fix
*                      limits creation of these partitions to 2048MB.
*
******************************************************************************/

#include "dos.h"
#include "fdisk.h"
#include "extern.h"
#include "subtype.h"

/*  */
char find_part_free_space(type)

char   type;

BEGIN


char        i;
char        partition_count;
char        last_found_partition;
unsigned    temp;
char        freespace_count;
char        any_partition;
unsigned    temp_size;

        /* Sort the partition table */
        sort_part_table(c(4));                                          /* AC000 */


        /* Intialize free space to zero */
        for (i = c(0); i < c(5); i++)                                   /* AC000 */
           BEGIN
            free_space[i].space = u(0);                                 /* AC000 */
            free_space[i].start = u(0);                                 /* AC000 */
            free_space[i].end = u(0);                                   /* AC000 */
            free_space[i].mbytes_unused = f(0);                         /* AC000 */  /* AN000 */
            free_space[i].percent_unused = u(0);                        /* AC000 */     /* AN000 */
           END

        /* Find space between start of disk and first partition */
        partition_count = c(0);                                         /* AC000 */

        any_partition = FALSE;
        for (i = c(0); i < c(4); i++)                                   /* AC000 */
           BEGIN
            if (part_table[cur_disk][sort[i]].sys_id != uc(0))          /* AC000 */
               BEGIN
                /* Found a partition, get the space */

                free_space[0].start = u(0);                             /* AC000 */

                /* This is a special case - the extended partition can not start */
                /* on cylinder 0 due too its archetecture. Protect against that here */
                if (type == c(EXTENDED))                                /* AC000 */
                   BEGIN
                    free_space[0].start = u(1);                         /* AC000 */
                   END

                /* free space ends before start of next valid partition */
                if (part_table[cur_disk][sort[i]].start_cyl > u(0))     /* AC000 */
                   BEGIN
                    free_space[0].end = part_table[cur_disk][sort[i]].start_cyl-1;
                    free_space[0].space = part_table[cur_disk][sort[i]].start_cyl-free_space[0].start; /*C04*/
                   END

/*C04                free_space[0].space = part_table[cur_disk][sort[i]].start_cyl;  */
                free_space[0].mbytes_unused =
                    cylinders_to_mbytes(free_space[0].space,cur_disk);  /* AN004 */
                free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */

                partition_count = i;
                last_found_partition = sort[i];
                any_partition = TRUE;
                break;
               END
           END
        /* See if any partitions were there */
        if (any_partition)
           BEGIN
            /* Look for space between the rest of the partitions */
            freespace_count = c(1);                                     /* AC000 */
            for (i = partition_count+1; i < c(4); i++)                  /* AC000 */
               BEGIN
                if (part_table[cur_disk][sort[i]].sys_id != uc(0))      /* AC000 */
                   BEGIN

                    /* Check to see if more than one partition on a cylinder (i.e. XENIX bad block)  */
                    /* If so, leave the space at zero */

                    if (part_table[cur_disk][sort[i]].start_cyl != part_table[cur_disk][last_found_partition].end_cyl)

                       BEGIN
                        /* No, things are normal */
                        /* Get space between the end of the last one and the start of the next one */
                        free_space[freespace_count].space = part_table[cur_disk][sort[i]].start_cyl
                           - (part_table[cur_disk][last_found_partition].end_cyl+1);

                        temp_size = (part_table[cur_disk][sort[i]].start_cyl -
                             part_table[cur_disk][last_found_partition].end_cyl);

                        if (temp_size != u(0) )                         /* AC000 */
                           BEGIN
                            free_space[freespace_count].space = temp_size - u(1);  /* AC000 */
                           END
                       END

                    free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
                    free_space[freespace_count].end = part_table[cur_disk][sort[i]].start_cyl -1;
                    free_space[freespace_count].mbytes_unused =
                         cylinders_to_mbytes(free_space[freespace_count].space,cur_disk); /* AN004 */
                    free_space[freespace_count].percent_unused = (unsigned)
                         cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);  /* AN000 */



                    /* update the last found partition */
                    last_found_partition = sort[i];
                    freespace_count++;
                   END
               END
            /* Find the space between the last partition and the end of the disk */
            /* SR; 10/10/89; Make sure that freespace cannot become negative */

            if ( total_disk[cur_disk] >
                 part_table[cur_disk][last_found_partition].end_cyl )
               {
            	free_space[freespace_count].space = (total_disk[cur_disk]
                                     	-  part_table[cur_disk][last_found_partition].end_cyl)-1;
            	free_space[freespace_count].start = part_table[cur_disk][last_found_partition].end_cyl+1;
            	free_space[freespace_count].end = total_disk[cur_disk]-1;
            	free_space[freespace_count].mbytes_unused =
                 	cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);    /* AN004 */
            	free_space[freespace_count].percent_unused =
                 	cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);                       /* AN000 */
               }
            END
         else
           BEGIN
            /* No partitions found, show entire space as free */
            free_space[0].start = u(0);                                 /* AC000 */

            /* This is a special case - the extended partition can not start */
            /* on cylinder 0 due too its architecture. Protect against that here */
            if (type == c(EXTENDED))                                    /* AC000 */
               BEGIN
                free_space[0].start = u(1);                             /* AC000 */
               END
            free_space[0].end = total_disk[cur_disk]-1;
            free_space[0].space = (free_space[0].end - free_space[0].start)+1;
            free_space[0].mbytes_unused =
                 cylinders_to_mbytes(free_space[0].space,cur_disk);    /* AN004 */
            free_space[0].percent_unused =
                 cylinders_to_percent(free_space[0].space,total_disk[cur_disk]);                       /* AN000 */
           END



         /* Find largest free space, and verify the golden tracks while we are at it */
         do
            BEGIN
             temp = u(0);                                               /* AC000 */

             /* Zip thru the table */
             for (i = c(0); i < c(5); i++)                              /* AC000 */
                BEGIN
                 /* Is this one bigger ? */
                 if (free_space[i].space > temp)
                    BEGIN
                     temp = free_space[i].space;
                     last_found_partition = i;

                    END
                END

             /* If there is any free space, go verify it */
             temp = u(0);
             if (free_space[last_found_partition].space != u(0))        /* AC000 */
               BEGIN

                /* Go verify the tracks */
                temp = verify_tracks(last_found_partition,c(PRIMARY));  /* AC000 */
               END
             /* Move up to next golden track */
             free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
             free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
             free_space[last_found_partition].mbytes_unused =
                  cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);    /* AN004 */
             free_space[last_found_partition].percent_unused = (unsigned)
                  cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);                      /* AN000 */
             END

            /* Repeat the loop if the start was moved due to bad tracks */
            /* Unless we're past the end of the free space */
            while ((temp != u(0)) && (free_space[last_found_partition].space != u(0)));    /* AC000 */

        /* Don't create a partition larger than DOS can handle */                                       /*C05*/
        if((type == c(PRIMARY)) && (free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE))) /*C05*/
          BEGIN                                                                                         /*C05*/
          free_space[last_found_partition].space =                                                      /*C05*/
           mbytes_to_cylinders(f(MAX_PART_SIZE),cur_disk) - 1;                                          /*C05*/
          free_space[last_found_partition].end =                                                        /*C05*/
           free_space[last_found_partition].start+free_space[last_found_partition].space-1;             /*C05*/
          free_space[last_found_partition].mbytes_unused =                                              /*C05*/
           cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);                        /*C05*/
          free_space[last_found_partition].percent_unused = (unsigned)                                  /*C05*/
           cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);           /*C05*/
          END                                                                                           /*C05*/

        /* Return with the pointer to the largest free space */
        return(last_found_partition);
END



/*  */
void sort_part_table(size)

char size;

BEGIN

char  changed;
char  temp;
char   i;

        /* Init the sorting parameters */

        for (i=c(0); i < size; i++)                                     /* AC000 */
           BEGIN
            sort[i] = i;
           END

        /* Do a bubble sort */
        changed = TRUE;

        /* Sort until we don't do a swap */
        while (changed)

           BEGIN
            changed = FALSE;
            for (i=c(1); i < size; i++)                                 /* AC000 */
               BEGIN

                /* Does the partition entry start before the previous one, or */
                /* is it empty (0 ENTRY). If empty, it automatically gets shoved */
                /* to the front, if the previous entry isn't also empty */

                if ((part_table[cur_disk][sort[i]].end_cyl < part_table[cur_disk][sort[i-1]].end_cyl)
                   || ((part_table[cur_disk][sort[i]].num_sec == ul(0))
                   &&  (part_table[cur_disk][sort[i-1]].num_sec != ul(0))))  /* AC000 */

                   BEGIN
                    /* Swap the order indicators */
                    temp = sort[i-1];
                    sort[i-1] = sort[i];
                    sort[i] = temp;

                 /* printf("\nI-1 =%d\n",part_table[cur_disk][sort[i-1]].start_cyl);*/
                 /* printf("I =%d\n",part_table[cur_disk][sort[i]].start_cyl);*/
                 /* printf("Sort[i-1] = %d\n",sort[i-1]);*/
                 /* printf("Sort[i] = %d\n",sort[i]); */
                 /* wait_for_ESC(); */


                    /* indicate we did a swap */
                    changed = TRUE;
                   END
               END
           END
        return;
END




/*  */
char find_ext_free_space()


BEGIN


char   i;
char   partition_count;
char   last_found_partition;
unsigned    temp;
char   freespace_count;
char   any_partition;
char   ext_location;

        /* Sort the partition table */
        sort_ext_table(c(23));                                          /* AC000 */


        /* Initialize free space to zero */
        for (i = c(0); i < c(24); i++)                                  /* AC000 */
           BEGIN
            free_space[i].space = u(0);                                 /* AC000 */
            free_space[i].start = u(0);
            free_space[i].end = u(0);                                   /* AC000 */
            free_space[i].mbytes_unused = f(0);                         /* AN000 */
            free_space[i].percent_unused = u(0);                        /* AN000 */
           END

        /* Find space between start of Extended partition and first volume */
        ext_location = find_partition_location(uc(EXTENDED));           /* AC000 */

        partition_count = c(0);                                         /* AC000 */

        any_partition = FALSE;
        for (i = c(0); i < c(23); i++)                                  /* AC000 */
           BEGIN
            if (ext_table[cur_disk][sort[i]].sys_id != uc(0))           /* AC000 */
               BEGIN
                /* Found a partition, get the space */
                free_space[0].space = ext_table[cur_disk][sort[i]].start_cyl - part_table[cur_disk][ext_location].start_cyl;
                free_space[0].start = part_table[cur_disk][ext_location].start_cyl;
                free_space[0].end = ext_table[cur_disk][sort[i]].start_cyl-1;
                free_space[0].mbytes_unused =
                     cylinders_to_mbytes(free_space[0].space,cur_disk); /* AN004 */
                free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */

                partition_count = i;
                last_found_partition = sort[i];
                any_partition = TRUE;
                break;
               END
           END
        /* See if any partitions were there */
        if (any_partition)
           BEGIN
            /* Look for space between the rest of the partitions */
            freespace_count = c(1);                                     /* AC000 */
            for (i = partition_count+1; i < c(23); i++)                 /* AC000 */
               BEGIN
                if (ext_table[cur_disk][sort[i]].sys_id != uc(0))       /* AC000 */
                   BEGIN

                    /* Get space between the end of the last one and the start of the next one */
                    temp = ext_table[cur_disk][sort[i]].start_cyl - (ext_table[cur_disk][last_found_partition].end_cyl+1);
                    free_space[freespace_count].space = temp;
                    free_space[freespace_count].start = ext_table[cur_disk][last_found_partition].end_cyl+1;
                    free_space[freespace_count].end = ext_table[cur_disk][sort[i]].start_cyl -1;
                    free_space[freespace_count].mbytes_unused =
                         cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);       /* AN004 */
                    free_space[freespace_count].percent_unused = (unsigned)
                         cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);                         /* AN000 */


                    /* update the last found partition */
                    last_found_partition = sort[i];
                    freespace_count++;
                   END
               END
            /* Find the space between the last partition and the end of the extended partition */
            temp = part_table[cur_disk][ext_location].end_cyl -  ext_table[cur_disk][last_found_partition].end_cyl;
            free_space[freespace_count].space = temp;
            free_space[freespace_count].start = ext_table[cur_disk][last_found_partition].end_cyl+1;
            free_space[freespace_count].end = part_table[cur_disk][ext_location].end_cyl;
            free_space[freespace_count].mbytes_unused =
                 cylinders_to_mbytes(free_space[freespace_count].space,cur_disk);    /* AN004 */
            free_space[freespace_count].percent_unused = (unsigned)
                 cylinders_to_percent(free_space[freespace_count].space,total_disk[cur_disk]);                      /* AN000 */

           END
        else
           BEGIN
            /* No partitions found, show entire space as free */
            free_space[0].space = (part_table[cur_disk][ext_location].end_cyl - part_table[cur_disk][ext_location].start_cyl) + 1;
            free_space[0].start = part_table[cur_disk][ext_location].start_cyl;
            free_space[0].end = part_table[cur_disk][ext_location].end_cyl;
            free_space[0].mbytes_unused =
                 cylinders_to_mbytes(free_space[0].space,cur_disk);  /* AN004 */
            free_space[0].percent_unused = (unsigned)cylinders_to_percent(free_space[0].space,total_disk[cur_disk]); /* AN000 */
           END

         /* Find largest free space */
         temp = u(0);                                                   /* AC000 */


         /* Find largest free space, and verify the golden tracks while we are at it */
         do
            BEGIN
             temp = u(0);                                               /* AC000 */

             /* Zip thru the table */
             for (i = c(0); i < c(24); i++)                             /* AC000 */
                BEGIN
                 /* Is this one bigger ? */
                 if (free_space[i].space > temp)
                    BEGIN
                     temp = free_space[i].space;
                     last_found_partition = i;
                    END
                END
             /* If there is any free space, go verify it */
             temp = u(0);
             if (free_space[last_found_partition].space != u(0))        /* AC000 */
                BEGIN

                 /* Go verify the tracks */
                 temp = verify_tracks(last_found_partition,c(EXTENDED)); /* AC000 */
                END
             /* Move up to next golden track */
             free_space[last_found_partition].start = free_space[last_found_partition].start+temp;
             free_space[last_found_partition].space = free_space[last_found_partition].space-temp;
             free_space[last_found_partition].mbytes_unused =
                  cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);    /* AN004 */
             free_space[last_found_partition].percent_unused =
                  cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);                       /* AN000 */
             END
             /* Repeat the loop if the start was moved due to bad tracks */
            /* Unless we're past the end of the free space */
            while ((temp !=u(0)) && (free_space[last_found_partition].space!= u(0)));  /* AC000 */

        /* Don't create a partition larger than DOS can handle */                              /*C05*/
        if(free_space[last_found_partition].mbytes_unused > u(MAX_PART_SIZE))                  /*C05*/
          BEGIN                                                                                /*C05*/
          free_space[last_found_partition].space =                                             /*C05*/
           mbytes_to_cylinders(f(MAX_PART_SIZE),cur_disk) - 1;                                 /*C05*/
          free_space[last_found_partition].end =                                               /*C05*/
           free_space[last_found_partition].start+free_space[last_found_partition].space-1;    /*C05*/
          free_space[last_found_partition].mbytes_unused =                                     /*C05*/
           cylinders_to_mbytes(free_space[last_found_partition].space,cur_disk);               /*C05*/
          free_space[last_found_partition].percent_unused = (unsigned)                         /*C05*/
           cylinders_to_percent(free_space[last_found_partition].space,total_disk[cur_disk]);  /*C05*/
          END                                                                                  /*C05*/

        /* Return with the pointer to the largest free space */
        return(last_found_partition);
END


/*  */
void sort_ext_table(size)

char size;

BEGIN

char  changed;
char  temp;
char i;

        /* Init the sorting parameters */

        for (i=c(0); i < size; i++)                                     /* AC000 */
           BEGIN
            sort[i] = i;
           END

        /* Do a bubble sort */
        changed = TRUE;

        /* Sort until we don't do a swap */
        while (changed)

           BEGIN
            changed = FALSE;
            for (i=c(1); i < size; i++)                                 /* AC000 */
               BEGIN

                if (ext_table[cur_disk][sort[i]].start_cyl < ext_table[cur_disk][sort[i-1]].start_cyl)
                   BEGIN

                    temp = sort[i-1];
                    sort[i-1] = sort[i];
                    sort[i] = temp;
                    /* indicate we did a swap */
                    changed = TRUE;
                   END
               END
           END
        return;
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\test.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
test()

BEGIN

int	i;
int	x;

	       for (i=0;i<24;i++)
		  BEGIN
		   for (x=0;x <2; x++)
		      BEGIN
	       ext_part_entry[i][x].boot_ind = 0;
	       ext_part_entry[i][x].start_head = 0;
	       ext_part_entry[i][x].start_sector = 0;
	       ext_part_entry[i][x].start_cyl = 0;
	       ext_part_entry[i][x].sys_id = 0;
	       ext_part_entry[i][x].end_head = 0;
	       ext_part_entry[i][x].end_sector = 0;
	       ext_part_entry[i][x].end_cyl = 0;
	       ext_part_entry[i][x].rel_sec = 0;
	       ext_part_entry[i][x].num_sec = 0;
		      END
		  END
	       return;
END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\profile.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */

#include        <doscall.h>
#include        <profile.h>
#include        <fdiskc.msg>
#include        <subtype.h>
#include        <ctype.h>


void    main()

BEGIN

unsigned i;

        /* Main Menu */
        clear_screen(0,0,24,79);
        display(menu_1);
        display(menu_2);
        display(menu_3);
        display(menu_4);
        insert[0] = 'C';
        display(menu_5);
        display(menu_6);
        display(menu_7);

        wait_for_ESC();


        /* Type of DOS partition for create */
        clear_screen(0,0,24,39);
        display(menu_3);
        insert[0] = 'C';
        display(menu_5);
        display(menu_7);
        display(menu_8);
        display(menu_9);
        display(menu_10);
        display(menu_11);
        wait_for_ESC();

        /* Shortcut screen C:*/
        clear_screen(0,0,24,39);
        display(menu_12);
        insert[0] = 'C';
        display(menu_5);
        display(menu_11);
        display(menu_12);
        display(menu_13);
        wait_for_ESC();

        /* Shortcut screen D:*/
        clear_screen(0,0,24,39);
        display(menu_12);
        insert[0] = 'C';
        display(menu_5);
        display(menu_11);
        display(menu_12);
        display(menu_41);
        wait_for_ESC();


/* Create primary DOS partition screen */
        display(menu_12);
        insert[0] = 'C';
        display(menu_5);
        for (i=0;i < 92;i++)
           BEGIN
            insert[i] = 'x';
           END
        display(menu_14);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_15);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_16);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_39);
        display(menu_11);
        wait_for_ESC();

/* Create Extended Partition */
        clear_screen(0,0,24,39);
        display(menu_17);
        insert[0] = 'C';
        display(menu_5);
        for (i=0;i < 92;i++)
           BEGIN
            insert[i] = 'x';
           END
        display(menu_14);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_15);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_16);
        display(menu_39);
        display(menu_11);
        wait_for_ESC();


/* Create logical drive screen */
        clear_screen(0,0,24,39);
        display(menu_18);
        for (i=0;i < 168;i++)
           BEGIN
            insert[i]= 'x';
           END
        display(menu_19);
        for (i=0;i < 168;i++)
           BEGIN
            insert[i]= 'x';
           END
        display(menu_20);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_21);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_22);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_40);
        display(menu_11);
        wait_for_ESC();


/* Change active partition screen */
        clear_screen(0,0,24,39);
        display(menu_23);
        insert[0] = 'C';
        display(menu_5);
        for (i=0;i < 92;i++)
           BEGIN
            insert[i] = 'x';
           END
        display(menu_14);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_15);
        display(menu_24);
        display(menu_11);
        wait_for_ESC();


/* Delete Partition Screen */
        clear_screen(0,0,24,39);
        display(menu_25);
        insert[0] = 'C';
        display(menu_5);
        display(menu_3);
        display(menu_26);
        display(menu_27);
        display(menu_7);
        display(menu_11);
        wait_for_ESC();

/* Delete Primary Screen */
        clear_screen(0,0,24,39);
        display(menu_28);
        insert[0] = 'C';
        display(menu_5);
        for (i=0;i < 92;i++)
           BEGIN
            insert[i] = 'x';
           END
        display(menu_14);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_15);
        display(menu_29);
        display(menu_11);
        wait_for_ESC();


/* Delete Extended Screen */
        clear_screen(0,0,24,39);
        display(menu_30);
        insert[0] = 'C';
        display(menu_5);
        for (i=0;i<92;i++)
           BEGIN
            insert[i] = 'x';
           END
        display(menu_14);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_15);
        display(menu_31);
        display(menu_11);
        wait_for_ESC();


/* Delete Logical Drives */
        clear_screen(0,0,24,39);
        display(menu_32);
        display(menu_18);
        for (i=0;i<168;i++)
           BEGIN
            insert[i]='x';
           END
        display(menu_19);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_21);
        display(menu_33);
        display(menu_11);
        wait_for_ESC();

/* Display Partition Information */
        clear_screen(0,0,24,39);
        display(menu_35);
        insert[0] = 'C';
        display(menu_5);
        for (i=0;i<92;i++)
           BEGIN
            insert[i] = 'x';
           END
        display(menu_14);
        insert[0] = 'x';
        insert[1] = 'x';
        insert[2] = 'x';
        insert[3] = 'x';
        display(menu_15);
        display(menu_36);
        display(menu_11);
        wait_for_ESC();

/* Display Logical Drive Info */
        clear_screen(0,0,24,39);
        display(menu_37);
        for (i=0;i<168;i++)
           BEGIN
            insert[i]='x';
           END
        display(menu_19);
        for (i=0;i<168;i++)
           BEGIN
            insert[i]='x';
           END
        display(menu_20);
        display(menu_11);
        wait_for_ESC();

/* Reboot Screen */
        clear_screen(0,0,24,39);
        display(menu_38);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_1);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_2);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_3);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        insert[0] = 'x';
        display(status_4);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_5);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_6);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_7);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_8);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_9);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(status_10);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_1);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_2);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_3);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_4);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_5);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_6);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_7);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_8);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_9);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_10);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_12);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_13);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_14);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_15);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_16);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_17);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_19);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_20);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_21);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_22);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        insert[0]='x';
        insert[1]='y';
        insert[2]='-';
        insert[3]='z';
        display(error_23);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_24);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_25);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_26);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_27);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_28);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        insert[0]='X';
        insert[1]=':';
        display(error_29);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        insert[0]='X';
        display(error_30);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        insert[0]='x';
        insert[1]='-';
        insert[2]='y';
        display(error_31);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        display(error_32);
        wait_for_ESC();

        clear_screen(0,0,24,39);
        DOSEXIT(0,0);

END


/******************* START OF SPECIFICATIONS *******************/
/*                                                             */
/* SUBROUTINE NAME: DISPLAY                                    */
/*                                                             */
/* DESCRIPTIVE NAME: Display full screen interface messages    */
/*                                                             */
/* FUNCTION: Displays messages and handles control characters  */
/*                                                             */
/* NOTES:                                                      */
/*  FDISK MESSAGES                                             */
/* Portions of the screen that are handled in the msg are      */
/* indicated on the listing of the screen with the message     */
/* name given.  If the text message is defined in another      */
/* screen, then the name is followed by a "#" character        */
/*                                                             */
/* NOTE TO TRANSLATORS The characters inside the <> and the [] */
/* are control characters and should not be translated.  The   */
/* Control characters are defined as follows:                  */
/*                                                             */
/* <H> - Highlight the following text                          */
/* <R> - Regular text                                          */
/* <B> - Blink the following text                              */
/* <O> - Turn blinking off                                     */
/* <Y> - Print YES character, as set by define                 */
/* <N> - Print NO character, as set by define                  */
/* <W> - Sound the beep                                        */
/* <S> - Save cursor position for later use                    */
/* <I> - Insert character from insert[] string. This string    */
/*       must be set up prior to displaying the message. The   */
/*       first <I> will insert Insert[0], the second           */
/*       insert[1], etc....This will move the cursor one       */
/*       postition. The insert[] string will be initialized    */
/*                                                             */
/* Multiple control characters can be between the <>.          */
/*                                                             */
/* The %####%indicates Row and column for the text and has the */
/* format of [rrcc] where the numbers are decimal and zero     */
/* based (first row/col is 00.  The numbers are in decimal,    */
/* and must be 2 characters, which means rows/cols 0-9 should  */
/* be listed as 00-09.  For example, the 5th row, 3rd column   */
/* on the screen would be listed as %0402%.                    */
/*                                                             */
/* The column number is always the column desired.  The row    */
/* number is an offset from the previous row.  For example, if */
/* the text just printed is on row 6, and the next text should */
/* be printed 2 rows down in column 0, then the control strin  */
/* would be %0201%.  The first row specified in the message is */
/* assumed to be based off of row 0, it would actually specify */
/* the actual row for the start of the msg to be printed.      */
/*                                                             */
/* ENTRY POINTS: display(*message_name);                       */
/*      LINKAGE: Near call                                     */
/*                                                             */
/* INPUT: char *message_name                                   */
/*                                                             */
/* EXIT-NORMAL:                                                */
/*                                                             */
/* EXIT-ERROR:                                                 */
/*                                                             */
/* EFFECTS:                                                    */
/* input_row changed if <S> control character in message       */
/* input_col changed if <S> control character in message       */
/*                                                             */
/* INTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/* EXTERNAL REFERENCES:                                        */
/*   ROUTINES:                                                 */
/*                                                             */
/* viowrtcharstratt();                                         */
/******************** END OF SPECIFICATIONS ********************/
void display(s)

char far *s;

BEGIN
        unsigned      row;
        unsigned      col;
        char          attribute;
        char far      *attribute_ptr = &attribute;
        unsigned      insert_count;


        /* Initialize row and col, and index into array */
        row = 0;
        col = 0;
        insert_count = 0;
        /* check for a request to display a null string */
        if (*s == '\0')
           BEGIN
            /* Message string error */
            insert[0] = '1';
            display(debug_msg);
           END
        else
           BEGIN
            /* There is data there, lets go handle it */

            attribute = 0x00;
            /* Go until end of string */
            while (*s != '\0')
               BEGIN

                /* Check for any imbedded control strings */
                switch (*s)
                   BEGIN
                    /* Check for control characters */
                    case '<':
                              BEGIN
                               s++;
                               while ( (*s != '>') && (*s != '\0') )
                                  BEGIN
                                   switch (*s++)
                                      BEGIN
                                       case 'H': attribute = (attribute & 0x80) | 0x0F;
                                                 break;


                                       case 'R': attribute = (attribute & 0x80) | 0x07;
                                                 break;

                                       case 'B': attribute |= 0x80;
                                                 break;

                                       case 'O': attribute &= 0x7F;
                                                 break;

                                       case 'W': DOSBEEP(900,400);
                                                 break;

                                       case 'I':
                                                 BEGIN
                                                   /* display next element in the array */
                                                  if (attribute == 0x00)
                                                      attribute = 0x07;
                                                  VIOWRTCHARSTRATT(pinsert+insert_count++,1,row,col++,attribute_ptr,0);
                                                  break;
                                                 END


                                       case 'Y':
                                                 BEGIN
                                                  /* display YES character in next location */
                                                  *--s = YES;
                                                  if (attribute == 0x00)
                                                      attribute = 0x07;
                                                  VIOWRTCHARSTRATT(s++,1,row,col++,attribute_ptr,0);
                                                  break;
                                                 END

                                       case 'N':
                                                 BEGIN
                                                  /* display NO character in next location */
                                                  *--s = NO;
                                                  if (attribute == 0x00)
                                                      attribute = 0x07;
                                                  VIOWRTCHARSTRATT(s++,1,row,col++,attribute_ptr,0);
                                                  break;
                                                 END


                                       case 'S':
                                                 BEGIN
                                                  input_row = row;
                                                  input_col = col;
                                                  break;
                                                 END

                                       case 'C':
                                                 BEGIN
                                                  /* Clear from current position to end of line */
                                                  clear_screen(row,col,row,39);
                                                  break;
                                                 END

                                       case '\0':
                                                 BEGIN
                                                  /* Message string error - string ended in the middle of control string*/
                                                  insert[0] = '7';
                                                  display(debug_msg);
                                                  break;
                                                 END

                                       default:
                                                 BEGIN
                                                  /* Message string error - no valid control char found */
                                                  insert[0] = '6';
                                                  display(debug_msg);
                                                  break;
                                                 END
                                      END /* Switch */
                                  END /* While */
                               /* Get the pointer past the '>' */
                               s++;
                               break;
                              END /* control characters */

                    /* Check for row,col */
                    case '%':
                              BEGIN
                               s++;
                               /* determine the row to put the message on */
                               if ( !isdigit(*s) )
                                  BEGIN
                                   /* Message string error */
                                   insert[0] = '2';
                                   display(debug_msg);
                                  END
                               else
                                  BEGIN
                                   row = row+((unsigned)(((*s++ - '0')*10)));
                                   if ( !isdigit(*s) )
                                     BEGIN
                                      /* Message string error */
                                      insert[0] = '2';
                                      display(debug_msg);
                                     END
                                   else
                                      BEGIN
                                       row = row+((unsigned)(*s++ - '0'));
                                       /* determine the col to put the message on */
                                       if ( !isdigit(*s) )
                                          BEGIN
                                           /* Message string error */
                                           insert[0] = '3';
                                           display(debug_msg);
                                          END
                                       else
                                          BEGIN
                                           col = ((unsigned)(*s++ - '0'));
                                           if ( !isdigit(*s) )
                                              BEGIN
                                               /* Message string error */
                                               insert[0] = '3';
                                               display(debug_msg);
                                              END
                                           else
                                              BEGIN
                                               col = ((unsigned)((col* 10) + (*s++ - '0')));
                                               if (*s++ != '%')
                                                  BEGIN
                                                   /* Message string error */
                                                   insert[0] = '4';
                                                   display(debug_msg);
                                                  END /* 2nd sq bracket */
                                              END /* 2nd digit col */
                                          END /* 1st digit col */
                                      END /* 2nd digit row */
                                  END /* 1st digit row */
                               break;
                              END
                    /* Handle anything else */


                    default:
                            BEGIN
                             /* See if attribute set to anything */
                             if (attribute == 0x00)
                                  attribute = 0x07;
                             VIOWRTCHARSTRATT(s++,1,row,col++,attribute_ptr,0);
                             break;
                            END
                   END
               END /* End of string check */
           END /* No characters in string check */
        return;

END

void number_in_msg(number,start)

unsigned    number;
unsigned    start;

BEGIN

unsigned     i;

        /* init the four spots to zero's */
        for (i = 0; i < 4;i++)
            BEGIN
             insert[start+i] = ' ';
            END
        /* Divide the space down and get it into decimal */
        if (number > 999)
           BEGIN
            insert[start] = ((char)(number/1000))+'0';
            insert[start+1] = '0';
            insert[start+2] = '0';
            insert[start+3] = '0';
            number = number%1000;
           END
        if (number > 99)
           BEGIN
            insert[start+1] = ((char)(number/100))+'0';
            insert[start+2] = '0';
            insert[start+3] = '0';
            number = number%100;
           END
        if (number > 9)
           BEGIN
            insert[start+2] = ((char)(number/10))+'0';
            insert[start+3] = '0';
            number = number%10;
           END
        insert[start+3] = ((char)(number +'0'));
        return;
END



void clear_screen(TopRow,LeftCol,BotRow,RightCol)

unsigned     TopRow;
unsigned     LeftCol;
unsigned     BotRow;
unsigned     RightCol;

BEGIN

char    attribute;
char    *attribute_ptr = &attribute;

   attribute = 0x07;
   VIOSCROLLUP(TopRow,LeftCol,BotRow,RightCol,0,attribute_ptr,0);
   return;
END



char wait_for_ESC()

BEGIN
     char  input;

    while (input != ESC)
       BEGIN
        /* position the cursor at the end of the ESC prompt */
        VIOSETCURPOS(24,39,0);

        /* Get input */
        KBDFLUSHBUFFER(0);
      /*KBDCHARIN(input_data,0,0);*/
      /*input = input_data->char_code;*/
          input = ((char)(getch()));
       END
    return(ESC);
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\subtype.h ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/22/90  EGH  C14  Added support for deleting Non-DOS partitions.
*  09/18/90  EGH  C26  Added module DELPART.C
*  11/07/90  EGH  C21  Added routine get_volume()
*  11/07/90  EGH  C32  Removed routine table_drive_letter() and added routine
*                      get_letters()
*
******************************************************************************/
/*************************************************************/
/* DISPLAY.C ROUTINES                                        */
/*************************************************************/
void     display(char far *);
void     number_in_msg(XFLOAT,unsigned);
void     percent_in_msg(unsigned,unsigned);                             /* AN000 */
void     string_in_msg(char far *,unsigned);                            /* AN000 */
void     volume_in_msg(char far *,unsigned);                            /* AN000 */

/*************************************************************/
/* VIDEO.C ROUTINES                                          */
/*************************************************************/
void     clear_screen(unsigned,unsigned,unsigned,unsigned);
void     init_video_information(void);
void     reset_video_information(void);
void     get_video_attribute(void);                                     /* AN006 */


/*************************************************************/
/* DISKOUT.C ROUTINES                                        */
/*************************************************************/
void     write_info_to_disk(void);
char     write_master_boot_to_disk(unsigned char);
char     write_ext_boot_to_disk(char,unsigned char);


/*************************************************************/
/* PARTINFO.C ROUTINES                                       */
/*************************************************************/
char     find_free_partition(void);
char     find_partition_type(unsigned char);
char     find_non_dos_partition(void);                                  /*C14*/
XFLOAT   get_partition_size(unsigned char);
char     find_active_partition(void);
char     find_partition_location(unsigned char);
char     find_free_ext(void);
char     find_logical_drive(void);
char     get_num_logical_dos_drives(void);
char     find_ext_drive(char);
char     find_previous_drive(char);

/*************************************************************/
/* MAKEPART.C ROUTINES                                       */
/*************************************************************/
void     make_partition(unsigned,char,unsigned char,char);
char     make_volume(unsigned,char);

/*************************************************************/         /*C26*/
/* REMPART.C ROUTINES                                        */         /*C26*/
/*************************************************************/         /*C26*/
void     remove_partition(char,unsigned);                               /*C26*/
void     remove_volume(char,unsigned);                                  /*C26*/

/*************************************************************/
/* INPUT.C ROUTINES                                          */
/*************************************************************/
char     get_num_input(char,char,unsigned,unsigned);
char     get_yn_input(char,unsigned,unsigned);
char     wait_for_ESC(void);
unsigned get_large_num_input(unsigned,unsigned,unsigned,char far *,unsigned,char far *);
char     get_alpha_input(char,char,unsigned,unsigned,char,char);
char     get_char_input(void);
void     get_string_input(unsigned,unsigned,char far *);


/*************************************************************/
/* SPACE.C ROUTINES                                          */
/*************************************************************/
char     find_part_free_space(char);
void     sort_part_table(char);
char     find_ext_free_space(void);
void     sort_ext_table(char);


/*************************************************************/
/* INT13.C ROUTINES                                          */
/*************************************************************/
char     get_disk_info(void);
char     read_boot_record(unsigned,unsigned char,unsigned char,unsigned char);         /* AC000 */
char     write_boot_record(unsigned,unsigned char);
unsigned verify_tracks(char,char);
char     get_drive_parameters(unsigned char);
void     DiskIo(union REGS *,union REGS *, struct SREGS *);

/*************************************************************/
/* VDISPLAY.C ROUTINES                                       */
/*************************************************************/
char     volume_display(void);

void 	  change_current_drive(void);

/*************************************************************/
/* TDISPLAY.C ROUTINES                                       */
/*************************************************************/
char     table_display(void);
/*C32 char     table_drive_letter(void); */
void     get_letters(void);                                             /*C32*/

/*************************************************************/
/* FDISK.C ROUTINES                                          */
/*************************************************************/
void     main(int,char * []);
void     load_logical_drive(char,unsigned char);
void     get_volume(unsigned char,unsigned);                            /*C21*/
void     init_partition_tables(void);
char     check_valid_environment(void);
void     reboot_system(void);
void     display_volume_information(void);
void     display_partition_information(void);
void     volume_delete(void);
void     ext_delete(void);
void     delete_partition(void);
void     dos_delete(void);
void     change_active_partition(void);
void     volume_create(void);
void     ext_create_partition(void);
void     input_dos_create(void);
void     dos_create_partition(void);
void     create_partition(void);
void     do_main_menu(void);
void     internal_program_error(void);
void     reboot(void);
void     non_dos_delete(void);                                          /*C14*/

/*************************************************************/
/* CONVERT ROUTINES                                          */
/*************************************************************/
void     get_volume_string(char,char *);                                /* AN000 */
unsigned mbytes_to_cylinders(XFLOAT,char);                              /* AN004 */
XFLOAT   percent_to_cylinders(unsigned,XFLOAT);                         /* AN000 */
XFLOAT   cylinders_to_mbytes(unsigned,char);                            /* AN004 */
unsigned cylinders_to_percent(unsigned,unsigned);                       /* AN000 */
char     dos_upper(char);                                               /* AN000 */
char     check_yn_input(char);                                          /* AN000 */
FLAG     get_fs_and_vol(char);                                          /* AN000 */
FLAG     check_format(char);                                            /* AN002 */
XFLOAT   numsecs_to_mbytes(unsigned long);
unsigned mbytes_to_percent(unsigned,XFLOAT);

/*************************************************************/
/* PARSE ROUTINES                                            */
/*************************************************************/
char     parse_command_line(int,char * []);                             /* AN000 */
void     parse_init(void);                                              /* AN000 */
void     check_disk_validity(void);                                     /* AN000 */
void     process_switch(void);                                          /* AN000 */
void     parse(union REGS *, union REGS *);                             /* AN000 */
void     Parse_msg(int,int,unsigned char);                              /* AN010 */


/*************************************************************/
/* MESSAGES ROUTINES                                         */
/*************************************************************/
char     preload_messages(void);                                        /* AN000 */
void     display_msg(int,int,int,int *,char,char);                      /* AN000 AC014 */
void     sysloadmsg(union REGS *, union REGS *);                        /* AN000 */
void     sysdispmsg(union REGS *, union REGS *);                        /* AN000 */
void     sysgetmsg(union REGS *, struct SREGS *, union REGS *);         /* AN012 */
char     get_yes_no_values(void);                                       /* AN012 */


/*************************************************************/
/* C ROUTINES                                                */
/*************************************************************/

int      getch(void);
void     putch(int);

int      int86x(int, union REGS *, union REGS *, struct SREGS *);
int      int86(int, union REGS *, union REGS *);
int      intdos(union REGS *, union REGS *);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\vdisplay.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
/******************************************************************************
*
*  Change Log:
*
*    Date    Who   #                      Description
*  --------  ---  ---  ------------------------------------------------------
*  03/08/90  EGH  C00  Cleaned up build by removing unused variables, declaring
*                      functions properly, changing long JMPs to short JMPs,
*                      etc.
*  03/19/90  EGH  C11  Problem - the change current disk menu hangs if one of
*                      the drives is bad.  Fix is to not use the routine
*                      get_part_free_space().  This fix will also eliminate the
*                      delay that occurs when switching to this menu.
*  05/24/90  EGH  C19  Problem - garbage was appearing on the change current
*                      disk screen when the maximum number of logical drives
*                      were present.  Fix is to initialize all 32 entries of
*                      the variable INSERT rather than just 31.
*  10/01/90  EGH  C26  Problem - on the change current disk screen, garbage
*                      characters were appearing as drive letters on partitons
*                      past z:.
*  10/19/90  EGH  C32  Added code to handle multiple primary DOS partitions.
*
******************************************************************************/

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "subtype.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */
#include "string.h"
#include "stdio.h"
#include "memory.h"

/*  */
char volume_display()

BEGIN

    unsigned    i;

/*C32    unsigned          k; */

/*C00    unsigned    x;      */
    char        drive_found;
    char        drive_letter;
    char        drive_num;
/*C32    char        temp;   */
    char        first_display;
    char        second_display;
    char        third_display;
    char        fourth_display;
    unsigned    insert_offset;

    first_display = FALSE;
    second_display = FALSE;
    third_display = FALSE;
    fourth_display = FALSE;

#if 0                                                                   /*C32*/
    /* See what the starting drive letter is */
    drive_letter = c(SEA);                                          /* AC000 */

    /* See if primary on drive 1 */
    temp = cur_disk;

    for (i=0; i < number_of_drives; i++)
        {
/*C00   cur_disk = i;         */
        cur_disk = c(i); /*C00*/

        if ((find_partition_type(uc(DOS12))) ||
            (find_partition_type(uc(DOS16))) ||
            (find_partition_type(uc(DOSNEW)))) /* AC000 */

            /* There is a Primary partition on drive 1, so increment for first logical drive */
            drive_letter++;
        }

    /* Are we on drive 2? If so, we got to find all the drives on drive 1 */

    /* Get drive information and put into array */
    for (k=0; k < temp; k++)
        {
        /* Next, we need to see what is on drive 1 */
        for (i=u(0); i < u(23); i++)                            /* AC000 */
            BEGIN
            /* See if there is a logical drive we understand in PC-DOS land */
            if ( (ext_table[k][i].sys_id == uc(DOS12)) ||
                 (ext_table[k][i].sys_id == uc(DOS16)) ||
                 (ext_table[k][i].sys_id == uc(DOSNEW)) )                    /* AC000  */
                BEGIN
                /* Found one, so kick up the first available drive letter */
                drive_letter++;
                END
            END
        }

    /* Reset the cur_drive to where it was */
    cur_disk = temp;
#endif                                                                  /*C32*/

    /* get the current drive letters */                                 /*C32*/
    get_letters();                                                      /*C32*/

    /* loop thru the partitions, only print stuff if it is there */

    /* Get the drives in order by location on disk */
    sort_ext_table(c(23));                                          /* AC000 */

    /* initialize all the inserts to blanks */
    memset(insert,c(' '),(24*29));

    drive_num = c(0);                                               /* AC000 */
    drive_found = FALSE;
    first_display = TRUE;
    insert_offset = 0;

    for (i=u(0); i < u(23); i++)                                    /* AC000 */
       BEGIN

        /* See if entry exists */
        if ( (ext_table[cur_disk][sort[i]].sys_id == uc(DOS12)) ||
             (ext_table[cur_disk][sort[i]].sys_id == uc(DOS16)) ||
             (ext_table[cur_disk][sort[i]].sys_id == uc(DOSNEW)) )  /* AC000  */
           BEGIN

            /* We found one, now get the info */
            drive_found = TRUE;

/*C32*/     /* Get the drive letter - make sure it is Z: or less*/
/*C32*/     /* Put it in the message, and set it up for next time */
/*C32       if (drive_letter > c('Z'))                                     */
/*C32               ext_table[cur_disk][sort[i]].drive_letter = c(' ');    */
/*C32       else ext_table[cur_disk][sort[i]].drive_letter = drive_letter; */

            insert_offset += sprintf(&insert[insert_offset],"%c%c%-11.11s%4.0d%-8.8s%3.0d%%",
                    ext_table[cur_disk][sort[i]].drive_letter,
                    ( ext_table[cur_disk][sort[i]].drive_letter == c(' ') ) ? ' ' : ':',
                    ext_table[cur_disk][sort[i]].vol_label,
                    ext_table[cur_disk][sort[i]].mbytes_used,
                    ext_table[cur_disk][sort[i]].system,
                    ext_table[cur_disk][sort[i]].percent_used );


/*C32       drive_letter++; */
            drive_letter = ext_table[cur_disk][sort[i]].drive_letter;   /*C32*/
            drive_num++;

           END
       END

    /* Display the column of drives */
    if (drive_found)
       BEGIN

        clear_screen(u(2),u(0),u(15),u(79));                    /* AC000 */

        if ( drive_num > 0 )
            BEGIN
            pinsert = &insert[0];
            display(menu_19);
            END

        if ( drive_num > 6 )
            BEGIN
            pinsert = &insert[6*29];
            display(menu_43);
            END

        if ( drive_num > 12 )
            BEGIN
            pinsert = &insert[12*29];
            display(menu_20);
            END

        if ( drive_num > 18 )
            BEGIN
            pinsert = &insert[18*29];
            display(menu_44);
            END
        pinsert = &insert[0];
        END
    else
       BEGIN
        /* Didn't find any */
        if (first_display)
           BEGIN
            /* Wipe out display and put up message */
            clear_screen(u(2),u(0),u(15),u(79));                    /* AC000 */
            display(status_9);
           END
       END
    /* Return the highest drive letter found */
/*C32    drive_letter--; */
    return(drive_letter);

END


/******************************************************************************/
/*Routine name:  CHANGE_CURRENT_DRIVE                                         */
/******************************************************************************/
/*                                                                            */
/*Description:   This routine will change the current drive for FDISK         */
/*               to any valid drive (up to 7).  It will also display a        */
/*               menu with disk information on all disks available for        */
/*               the system be FDISKed.                                       */
/*                                                                            */
/*Called Procedures:    Display                                               */
/*                      Find_part_free_space                                  */
/*                      Sort_Ext_Table                                        */
/*                      Get_Num_Input                                         */
/*                      Clear_Screen                                          */
/*                                                                            */
/*Change History: Created        1/06/89         DRM                          */
/*                                                                            */
/*Input:  None                                                                */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/
void change_current_drive()                                         /* BN000 */

BEGIN                                                               /* BN000 */

    unsigned    i;                                                  /* BN000 */
/*C00    unsigned    j;    */                                                      /* BN000 */
    unsigned    k;                                                  /* BN000 */
/*C32    char        drive_letter;         */                            /* BN000 */
/*C32    char        primary_drive_letter; */                            /* BN000 */
    char        drive_num;                                          /* BN000 */
    char        temp;                                               /* BN000 */
/*C11    char        temp1; */                                      /* BN000 */
    unsigned    temp1;                                                  /*C11*/
    unsigned    mbytes_free;                                            /*C11*/
    unsigned    percent_used;                                           /*C11*/
    unsigned    insert_offset;                                      /* BN000 */
    unsigned    input;                                              /* BN000 */
    char        max_input;                                          /* BN000 */
/*C00    char        blanks[9]; */                                                 /* BN000 */

    /* Initialize some variables */
    insert_offset = 0;                                              /* BN000 */
    drive_num = c(0);                                               /* BN000 */
/*C32    primary_drive_letter = c(SEA); */                               /* BN000 */

    /* get the current drive letters */                                 /*C32*/
    get_letters();                                                      /*C32*/

    /* Clear the whole screen for display */
    clear_screen(u(0),u(0),u(24),u(79));                            /* BN000 */

    /* initialize all the inserts to blanks */
/*C19    memset(insert,c(' '),(31*15)); */                                 /* BN000 */
    memset(insert,c(' '),(32*15));                                      /*C19*/

    /* Save current disk */
    temp = cur_disk;                                                /* BN000 */

    /* Display the heading */
    if (status_flag == FALSE)                                       /* BN000 */
        display(menu_47);                                           /* BN000 */
    else                                                            /* BN000 */
        display(menu_54);                                           /* BN000 */

    /* Figure out which drive letter the extended partitions begin with  */
/*C32    drive_letter = (c(SEA) + primary_partition_count); */           /* BN000 */

    /* Get the drive information in ascending order and put into array */
    for (i=u(0); i < u(number_of_drives); i++)                      /* BN000 */

        BEGIN                                                           /* BN000 */

        /* find freespace on current drive and display drive information */
        cur_disk = c(i);                                            /* BN000 */
/*C11   temp1 = find_part_free_space(PRIMARY); */                   /* BN000 */
        temp1 = part_table[cur_disk][0].mbytes_used +                   /*C11*/
                part_table[cur_disk][1].mbytes_used +                   /*C11*/
                part_table[cur_disk][2].mbytes_used +                   /*C11*/
                part_table[cur_disk][3].mbytes_used;                    /*C11*/
        if (temp1 < total_mbytes[cur_disk])                             /*C11*/
            mbytes_free = total_mbytes[cur_disk] - temp1;               /*C11*/
        else                                                            /*C11*/
            mbytes_free = u(0);                                         /*C11*/
        temp1 = part_table[cur_disk][0].percent_used +                  /*C11*/
                part_table[cur_disk][1].percent_used +                  /*C11*/
                part_table[cur_disk][2].percent_used +                  /*C11*/
                part_table[cur_disk][3].percent_used;                   /*C11*/
        if (temp1 < u(100))                                             /*C11*/
            percent_used = temp1;                                       /*C11*/
        else                                                            /*C11*/
            percent_used = u(100);                                      /*C11*/
        insert_offset += sprintf(&insert[insert_offset],"%1.0d%c%c%4.0d%4.0d%3.0d%%",
            (cur_disk + 1),
            ' ',
            ' ',
            total_mbytes[cur_disk],
/*C11       free_space[temp1].mbytes_unused,               */
/*C11       (u(100) - free_space[temp1].percent_unused));  */       /* BN000 */
            mbytes_free,                                                /*C11*/
            percent_used);                                              /*C11*/
        drive_num++;                                                /* BN000 */

        /* Sort the partitions */
        sort_part_table(c(4));                                      /* BN000 */
        /* Now look at the partitions in order */
        for (k=u(0); k < u(4); k++)                                 /* BN000 */
            BEGIN                                                       /* BN000 */
            /* see if there is a primary partition */
            if( (part_table[cur_disk][sort[k]].sys_id == DOSNEW) ||
                (part_table[cur_disk][sort[k]].sys_id == DOS16) ||
                (part_table[cur_disk][sort[k]].sys_id == DOS12) )
                BEGIN                                                   /* BN000 */
                insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
                    ' ',
/*C32               c(primary_drive_letter),               */
/*C32               (drive_letter == c(' ') ) ? ' ' : ':', */
                    part_table[cur_disk][sort[k]].drive_letter,         /*C32*/
                    (part_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':', /*C32*/     /*C32*/
                    part_table[cur_disk][sort[k]].mbytes_used,
                    ' ');                                           /* BN000 */
                    drive_num++;                                    /* BN000 */
/*C32               primary_drive_letter++; */                      /* BN000 */
                END                                                     /* BN000 */
            END                                                         /* BN000 */

        /* loop thru the partitions, only print stuff if it is there */

        /* Get the drives in order by location on disk */
        sort_ext_table(c(23));                                      /* BN000 */

        for (k=u(0); k < u(23); k++)                                /* BN000 */
            BEGIN                                                       /* BN000 */
            /* if last drive letter was Z, print spaces */
/*C32       if ((drive_letter > c('Z')) ) */
/*C32            drive_letter = c(' ');   */                        /* BN000 */
            /* If it has a size, print it */
            if ( (ext_table[cur_disk][sort[k]].mbytes_used != u(0)) ||
                 (ext_table[cur_disk][sort[k]].percent_used != u(0)) ) /* BN000 */

                BEGIN
                insert_offset += sprintf(&insert[insert_offset],"%c%c%c%4.0d%8c",
                    ' ',
/*C32               drive_letter, */
/*C32               (drive_letter == c(' ') ) ? ' ' : ':', */
                    ext_table[cur_disk][sort[k]].drive_letter,          /*C32*/
                    (ext_table[cur_disk][sort[k]].drive_letter == c(' ') ) ? ' ' : ':', /*C32*/
                    ext_table[cur_disk][sort[k]].mbytes_used,
                    ' ');                                           /* BN000 */
                    drive_num++;                                    /* BN000 */
/*C32               drive_letter++; */                              /* BN000 */
                END                                                     /* BN000 */
            END                                                         /* BN000 */
        END                                                             /* BN000 */

    /* Display the column of drives */
    BEGIN                                                           /* BN000 */

    if ( drive_num > 0 )                                            /* BN000 */
        BEGIN                                                       /* BN000 */
        pinsert = &insert[0];                                       /* BN000 */
        display(menu_48);                                           /* BN000 */
        END                                                         /* BN000 */

    if ( drive_num > 8 )                                            /* BN000 */
        BEGIN                                                       /* BN000 */
        pinsert = &insert[8*15];                                    /* BN000 */
        display(menu_49);                                           /* BN000 */
        END                                                         /* BN000 */

    if ( drive_num > 16 )                                           /* BN000 */
        BEGIN                                                       /* BN000 */
        pinsert = &insert[16*15];                                   /* BN000 */
        display(menu_50);                                           /* BN000 */
        END                                                         /* BN000 */

    if ( drive_num > 24 )                                           /* BN000 */
        BEGIN                                                       /* BN000 */
        pinsert = &insert[24*15];                                   /* BN000 */
        display(menu_51);                                           /* BN000 */
        END                                                         /* BN000 */
    pinsert = &insert[0];                                           /* BN000 */
    END                                                             /* BN000 */

    /* display Mbytes = line */
    display(menu_52);                                               /* BN000 */

    /* reset current disk back to original */
    cur_disk = temp;                                                /* BN000 */

    if (status_flag == FALSE)                                       /* BN000 */
        BEGIN
        /* Display prompt of which disk */
        sprintf(insert,"%1.0d%1.0d",number_of_drives,(cur_disk+1)); /* BN000 */
        display(menu_53);                                           /* BN000 */

        /* ESC line at bootom of screen */
        display(menu_11);                                           /* BN000 */

        max_input = c(number_of_drives);                            /* BN000 */

        valid_input = (FLAG)FALSE;                                  /* BN000 */

        /* Get the input from screen */
        while (!valid_input)                                        /* BN000 */
            BEGIN                                                   /* BN000 */
            input = get_num_input(c(cur_disk+1),max_input,input_row,input_col);  /* BN000 */
            clear_screen(u(21),u(0),u(23),u(79));                   /* BN000 */

            /* set current disk to zero base */
            if (input != u(ESC)) cur_disk = c(input-'1');           /* BN000 */
            END                                                     /* BN000 */

        /* clear the screen before going back to main menu */
        clear_screen(u(0),u(0),u(24),u(79));                        /* BN000 */
        END                                                         /* BN000 */
    return;                                                         /* BN000 */
END                                                                     /* BN000 */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\find\find.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;;
;;  Long Conditional Jump Macros
;;
lja		macro	Farlabel
		local	Nearlabel
		jna	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljae		macro	Farlabel
		local	Nearlabel
		jnae	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljb		macro	Farlabel
		local	Nearlabel
		jnb	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljc		macro	Farlabel
		local	Nearlabel
		jnc	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljbe		macro	Farlabel
		local	Nearlabel
		jnbe	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
lje		macro	Farlabel
		local	Nearlabel
		jne	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljz		macro	Farlabel
		local	Nearlabel
		jnz	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljg		macro	Farlabel
		local	Nearlabel
		jng	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljge		macro	Farlabel
		local	Nearlabel
		jnge	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljl		macro	Farlabel
		local	Nearlabel
		jnl	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljle		macro	Farlabel
		local	Nearlabel
		jnle	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljnc		macro	Farlabel
		local	Nearlabel
		jc	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljne		macro	Farlabel
		local	Nearlabel
		je	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljnz		macro	Farlabel
		local	Nearlabel
		jz	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljno		macro	Farlabel
		local	Nearlabel
		jo	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm
ljo		macro	Farlabel
		local	Nearlabel
		jno	Nearlabel
		jmp	Farlabel
Nearlabel:
		endm

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\_msgret.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
page	       60,132
name	       _msgret
title	       C to Message Retriever
;-------------------------------------------------------------------
;
;	MODULE: 	_msgret
;
;	PURPOSE:	Supplies an interface between C programs and
;			the DOS 3.3 message retriever
;
;	CALLING FORMAT:
;			msgret(&inregs,&outregs);
;
;	DATE:		5-21-87
;
;-------------------------------------------------------------------

	INCLUDE SYSMSG.INC		;PERMIT SYSTEM MESSAGE HANDLER DEFINITION ;AC010;

	MSG_UTILNAME <FDISK>		;IDENTIFY THE COMPONENT 		;AC010;

;-------------------------------------------------------------------
;-------------------------------------------------------------------


_TEXT	SEGMENT BYTE PUBLIC 'CODE'					;AC010;
_TEXT	ENDS								;AC010;
_DATA	SEGMENT WORD PUBLIC 'DATA'					;AC010;
_DATA	ENDS								;AC010;
CONST	SEGMENT WORD PUBLIC 'CONST'					;AC010;
CONST	ENDS								;AC010;
_BSS	SEGMENT WORD PUBLIC 'BSS'					;AC010;
_BSS	ENDS								;AC010;

DGROUP	GROUP	CONST, _BSS, _DATA					;AC010;
	ASSUME	CS: DGROUP, DS: DGROUP, SS: DGROUP, ES: NOTHING 	;AC010;

	public	data_sysloadmsg 					;AC010;
	public	data_sysdispmsg 					;AC010;
	public	data_sysgetmsg						;AC010;

_DATA	SEGMENT 							;AC010;

	MSG_SERVICES <MSGDATA>						;AC010;
	MSG_SERVICES <LOADmsg,FARmsg>					;AC010;
	MSG_SERVICES <DISPLAYmsg,GETmsg,CHARmsg,NUMmsg> 		;AC010;
	MSG_SERVICES <FDISK.CLA,FDISK.CLB,FDISK.CL1,FDISK.CL2,FDISK.CTL> ;AC010;		       ;AC010;


data_sysloadmsg proc far

	push	bp			; save user's base pointer      ;AC010;
	mov	bp,sp			; set bp to current sp		;AC010;
	push	di			; save some registers		;AC010;
	push	si							;AC010;

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)		;AC010;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di			;AC010;
	push	ax			; the di value from inregs is now on stack ;AC010;

	mov	ax,[di+00]		; get inregs.x.ax		;AC010;
	mov	bx,[di+02]		; get inregs.x.bx		;AC010;
	mov	cx,[di+04]		; get inregs.x.cx		;AC010;
	mov	dx,[di+06]		; get inregs.x.dx		;AC010;
	mov	si,[di+08]		; get inregs.x.si		;AC010;
	pop	di			; get inregs.x.di from stack	;AC010;

	push	bp			; save base pointer		;AC010;

;-------------------------------------------------------------------

	call	sysloadmsg		; call the message retriever	;AC010;

;-------------------------------------------------------------------

	pop	bp			; restore base pointer		;AC010;
	push	di			; the di value from call is now on stack ;AC010;
	mov	di,[bp+6+4]		  ; fix di (arg 1)		;AC010;

	mov	[di+00],ax		; load outregs.x.ax		;AC010;
	mov	[di+02],bx		; load outregs.x.bx		;AC010;
	mov	[di+04],cx		; load outregs.x.cx		;AC010;
	mov	[di+06],dx		; load outregs.x.dx		;AC010;
	mov	[di+08],si		; load outregs.x.si		;AC010;

	lahf				; get flags into ax		;AC010;
	mov	al,ah			; move into low byte		;AC010;
	mov	[di+0ch],ax		; load outregs.x.cflag		;AC010;

	pop	ax			; get di from stack		;AC010;
	mov	[di+0ah],ax		; load outregs.x.di		;AC010;

;-------------------------------------------------------------------

	pop	si			; restore registers		;AC010;
	pop	di							;AC010;
	mov	sp,bp			; restore sp			;AC010;
	pop	bp			; restore user's bp             ;AC010;
	ret

data_sysloadmsg endp							;AC010;


data_sysdispmsg proc far						;AC010;

	push	bp			; save user's base pointer      ;AC010;
	mov	bp,sp			; set bp to current sp		;AC010;
	push	di			; save some registers		;AC010;
	push	si							;AC010;

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)		;AC010;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di			;AC010;
	push	ax			; the di value from inregs is now on stack ;AC010;

	mov	ax,[di+00]		; get inregs.x.ax		;AC010;
	mov	bx,[di+02]		; get inregs.x.bx		;AC010;
	mov	cx,[di+04]		; get inregs.x.cx		;AC010;
	mov	dx,[di+06]		; get inregs.x.dx		;AC010;
	mov	si,[di+08]		; get inregs.x.si		;AC010;
	pop	di			; get inregs.x.di from stack	;AC010;

	push	bp			; save base pointer		;AC010;

;-------------------------------------------------------------------

	call	sysdispmsg						;AC010;

;-------------------------------------------------------------------

	pop	bp			; restore base pointer		;AC010;
	push	di			; the di value from call is now on stack ;AC010;
	mov	di,[bp+6+4]		  ; fix di (arg 1)		;AC010;

	mov	[di+00],ax		; load outregs.x.ax		;AC010;
	mov	[di+02],bx		; load outregs.x.bx		;AC010;
	mov	[di+04],cx		; load outregs.x.cx		;AC010;
	mov	[di+06],dx		; load outregs.x.dx		;AC010;
	mov	[di+08],si		; load outregs.x.si		;AC010;

	lahf				; get flags into ax		;AC010;
	mov	al,ah			; move into low byte		;AC010;
	mov	[di+0ch],ax		; load outregs.x.cflag		;AC010;

	pop	ax			; get di from stack		;AC010;
	mov	[di+0ah],ax		; load outregs.x.di		;AC010;

;-------------------------------------------------------------------

	pop	si			; restore registers		;AC010;
	pop	di							;AC010;
	mov	sp,bp			; restore sp			;AC010;
	pop	bp			; restore user's bp             ;AC010;
	ret								;AC010;

data_sysdispmsg endp							;AC010;


data_sysgetmsg	proc far						;AC010;

	push	bp			; save user's base pointer      ;AC010;
	mov	bp,sp			; set bp to current sp		;AC010;
	push	di			; save some registers		;AC010;
	push	si							;AC010;

;	copy C inregs into proper registers

	mov	di,[bp+4+4]		  ; fix di (arg 0)		;AC010;

;-------------------------------------------------------------------

	mov	ax,[di+0ah]		; load di			;AC010;
	push	ax			; the di value from inregs is now on stack ;AC010;

	mov	ax,[di+00]		; get inregs.x.ax		;AC010;
	mov	bx,[di+02]		; get inregs.x.bx		;AC010;
	mov	cx,[di+04]		; get inregs.x.cx		;AC010;
	mov	dx,[di+06]		; get inregs.x.dx		;AC010;
	mov	si,[di+08]		; get inregs.x.si		;AC010;
	pop	di			; get inregs.x.di from stack	;AC010;

	push	bp			; save base pointer		;AC010;

;-------------------------------------------------------------------

	call	sysgetmsg		; call the message retriever	;AC010;

;-------------------------------------------------------------------

	pop	bp			; restore base pointer		;AC010;
	push	di			; the di value from call is now on stack ;AC010;
	mov	di,[bp+6+4]		  ; fix di (arg 1)		;AC010;

	push	ax			; save ax			;AC010;
	mov	[di+00],es		; load segregs.es		;AC010;
	mov	[di+06],ds		; load outregs.ds		;AC010;
	pop	ax			; restore ax			;AC010;

	pop	di			; restore di			;AC010;
	push	di			; save it			;AC010;
	mov	di,[bp+8+4]		  ; fix di (arg 2)		;AC010;
	mov	[di+00],ax		; load outregs.x.ax		;AC010;
	mov	[di+02],bx		; load outregs.x.bx		;AC010;
	mov	[di+04],cx		; load outregs.x.cx		;AC010;
	mov	[di+06],dx		; load outregs.x.dx		;AC010;
	mov	[di+08],si		; load outregs.x.si		;AC010;

	lahf				; get flags into ax		;AC010;
	mov	al,ah			; move into low byte		;AC010;
	mov	[di+0ch],ax		; load outregs.x.cflag		;AC010;

	pop	ax			; get di from stack		;AC010;
	mov	[di+0ah],ax		; load outregs.x.di		;AC010;

;-------------------------------------------------------------------

	pop	si			; restore registers		;AC010;
	pop	di							;AC010;
	mov	sp,bp			; restore sp			;AC010;
	pop	bp			; restore user's bp             ;AC010;
	ret								;AC010;

data_sysgetmsg	endp							;AC010;


_DATA	ends			; end code segment			;AC010;

_TEXT	SEGMENT 							;AC010;

	assume cs:_TEXT 						;AC010;

	public	_sysdispmsg						;AC010;
	public	_sysloadmsg						;AC010;
	public	_sysgetmsg						;AC010;

_sysdispmsg	proc	near						;AC010;
		call	data_sysdispmsg 				;AC010;
		ret							;AC010;
_sysdispmsg	endp							;AC010;

_sysloadmsg	proc	near						;AC010;
		call	data_sysloadmsg 				;AC010;
		ret							;AC010;
_sysloadmsg	endp							;AC010;

_sysgetmsg	proc	near						;AC010;
		call	data_sysgetmsg					;AC010;
		ret							;AC010;
_sysgetmsg	endp							;AC010;

_TEXT	ENDS								;AC010;
	end								;AC010;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\video.c ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */

#include "dos.h"                                                        /* AN000 */
#include "fdisk.h"                                                      /* AN000 */
#include "extern.h"                                                     /* AN000 */
#include "doscall.h"                                                    /* AN000 */
#include "fdiskmsg.h"                                                   /* AN000 */
#include "subtype.h"

/*  */

void clear_screen(TopRow,LeftCol,BotRow,RightCol)

unsigned     TopRow;
unsigned     LeftCol;
unsigned     BotRow;
unsigned     RightCol;

BEGIN

char    attribute;
char    *attribute_ptr = &attribute;

	if (status_flag == TRUE)
		attribute = video_attribute;
	else
		{
   		if (mono_flag == TRUE)                                               /* AN006 */
       		attribute = GRAY_ON_BLACK;                                       /* AN006 */
   		else                                                                 /* AN006 */
       		attribute = WHITE_ON_BLUE;                                       /* AC000 */
		}
   VIOSCROLLUP(TopRow,LeftCol,BotRow,RightCol,u(0),attribute_ptr,u(0)); /* AC000 */
   return;
END





/*  */
/*                                                                          */
/****************************************************************************/
/* Initializes the screen and stores the lower right hand corner            */
/* of the screen in the global variable LowerRightHandCorner.  This         */
/* is which is used for screen clears.  If the screen is in grahpics mode,  */
/* it is changed to BW 40x25.  This procedure is only called once at program*/
/* start. Also saves the current screen                                     */
/****************************************************************************/
/*                                                                          */


void init_video_information()

BEGIN
        mono_flag = FALSE;                                              /* AN006 */

        /* Get the current video state */
        regs.h.ah = uc(CURRENT_VIDEO_STATE);                            /* AC000 */
        int86((int)VIDEO,&regs,&regs);                                  /* AC000 */

        /* Save the mode and display page */
        video_mode = regs.h.al;
        display_page = regs.h.bh;

        get_video_attribute();                                          /* AN006 */

		 if (status_flag == FALSE)
        BEGIN
        	/* assume color mode */
        	regs.h.al = uc(Color80_25);                                     /* AC000 */

        	/* See if we are in MONOCHROME mode */
        	if ((video_mode == uc(MONO80_25)) || (video_mode == uc(MONO80_25A))) /* AC000 AC006 */
           	BEGIN

            	/* Nope,set to BW80x25*/
            	regs.h.al = uc(BW80_25);                                    /* AC000 */
            	mono_flag = TRUE;                                           /* AN006 */
           	END

        	/* go set the new mode */
        	regs.h.ah = uc(SET_MODE);                                       /* AC000 */
        	int86((int)VIDEO,&regs,&regs);                                  /* AC000 */

        	/* Set the display page */
        	regs.h.ah = uc(SET_ACTIVE_DISPLAY_PAGE);                        /* AC000 */
        	regs.h.al = uc(0);                                              /* AC000 */
        	int86((int)VIDEO,&regs,&regs);                                  /* AC000 */
        END

        return;
END

/*  */
/*                                             */
/* Resets the video mode to the original value */
/*                                             */

void reset_video_information()

BEGIN

char    *attribute_ptr = &video_attribute;                              /* AN006 */

		 /* Do this if we are not using the /STATUS switch */
		 if (status_flag == FALSE)
			{
        	/* Clear display with colors that were present when FDISK was invoked */
        	VIOSCROLLUP(u(0),u(0),u(24),u(79),u(0),attribute_ptr,u(0));     /* AN006 */

        	/* Reset the video mode */
        	regs.h.ah = SET_MODE;
        	regs.h.al = video_mode;
        	int86((int)VIDEO,&regs,&regs);                                  /* AC000 */

        	/* Set the page */
        	regs.h.ah = SET_PAGE;
        	regs.h.al = display_page;
        	int86((int)VIDEO,&regs,&regs);                                  /* AC000 */
			}
        return;

END

/******************************************************************************/
/*Routine name:  GET_VIDEO_ATTRIBUTE                                          */
/******************************************************************************/
/*                                                                            */
/*Description:   This routine will invoke interrupt 10 function 08h to        */
/*               get the current attributes at the cursor postition in order  */
/*               to restore the correct colors when returning out of FDISK.   */
/*                                                                            */
/*Called Procedures:    none                                                  */
/*                                                                            */
/*                                                                            */
/*Change History: Created        3/11/88         DRM                          */
/*                                                                            */
/*Input: None                                                                 */
/*                                                                            */
/*Output: None                                                                */
/*                                                                            */
/******************************************************************************/

void get_video_attribute()                                              /* AN006 */

BEGIN                                                                   /* AN006 */

        /* Get current attributes */
        regs.h.ah = CURRENT_VIDEO_ATTRIBUTE;                            /* AN006 */
        regs.h.bh = display_page;                                       /* AN006 */
        int86((int)VIDEO,&regs,&regs);                                  /* AN006 */
        video_attribute = regs.h.ah;                                    /* AN006 */
        return;                                                         /* AN006 */

END                                                                     /* AN006 */


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\find\findmes.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
      title   FIND Messages

Message macro	sym,text
public	sym,sym&_len
sym	db  text
sym&_len db  $-sym
endm

CR	equ	0dh			;A Carriage Return
LF	equ	0ah			;A Line Feed

code	segment public

	PUBLIC	heading
	message heading,<CR,LF,"---------- ">

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\fdisk\_parse.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1983 - 1991
; *                      All Rights Reserved.
; */
page           60,132
name           _parse
title          C to PARSER interface
;-------------------------------------------------------------------
;
;       MODULE:         _parse
;
;       PURPOSE:        Supplies an interface between C programs and
;                       the DOS 3.3 parser
;
;       CALLING FORMAT:
;                       parse(&inregs,&outregs);
;
;       DATE:           5-21-87
;
;-------------------------------------------------------------------

;       extrn   sysparse:far

        public  _parse

;-------------------------------------------------------------------
FarSW   equ     0       ; make sysparse be a NEAR proc
TimeSW  equ     0       ; Check time format
FileSW  equ     0       ; Check file specification
CAPSW   equ     0       ; Perform CAPS if specified
CmpxSW  equ     0       ; Check complex list
NumSW   equ     1       ; Check numeric value
KeySW   equ     0       ; Support keywords
SwSW    equ     1       ; Support switches
Val1SW  equ     1       ; Support value definition 1
Val2SW  equ     1       ; Support value definition 2
Val3SW  equ     0       ; Support value definition 3
DrvSW   equ     0       ; Support drive only format
QusSW   equ     0       ; Support quoted string format
;-------------------------------------------------------------------




_TEXT   SEGMENT BYTE PUBLIC 'CODE'
_TEXT   ENDS
_DATA   SEGMENT WORD PUBLIC 'DATA'
_DATA   ENDS
CONST   SEGMENT WORD PUBLIC 'CONST'
CONST   ENDS
_BSS    SEGMENT WORD PUBLIC 'BSS'
_BSS    ENDS


DGROUP  GROUP   CONST, _BSS, _DATA


_DATA   segment word public 'DATA'

        assume  cs:DGROUP
        assume  ss:dgroup

        public  SysParse

;-------------------------------------------------------------------
.xlist
include version.inc
include parse.asm               ; include the parser
.list
;-------------------------------------------------------------------

                public  CallParser
CallParser      proc    far

        push    ds
        PUSH    ES

        push    cs
        pop     ds
        assume  ds:DGROUP

        push    cs
        pop     es
        assume  es:DGROUP

        nop

        call    SysParse

        POP     ES
        pop     ds

        ret

CallParser      endp



_DATA   ends

_TEXT   segment byte public 'CODE'

        ASSUME  CS:_TEXT
        ASSUME  DS:DGROUP
        ASSUME  ES:NOTHING
        ASSUME  SS:DGROUP

_parse  proc    near

        push    bp              ; save user's base pointer
        mov     bp,sp           ; set bp to current sp
        push    di              ; save some registers
        push    si

;       copy C inregs into proper registers

        mov     di,[bp+4]       ; fix di (arg 0)

;-------------------------------------------------------------------

        mov     ax,[di+0ah]     ; load di
        push    ax              ; the di value from inregs is now on stack

        mov     ax,[di+00]      ; get inregs.x.ax
        mov     bx,[di+02]      ; get inregs.x.bx
        mov     cx,[di+04]      ; get inregs.x.cx
        mov     dx,[di+06]      ; get inregs.x.dx
        mov     si,[di+08]      ; get inregs.x.si
        pop     di              ; get inregs.x.di from stack

        push    bp              ; save base pointer

;-------------------------------------------------------------------
;-------------------------------------------------------------------

        call    CallParser      ; call the parser

;-------------------------------------------------------------------
;-------------------------------------------------------------------

        pop     bp              ; restore base pointer
        push    di              ; the di value from call is now on stack
        mov     di,[bp+6]       ; fix di (arg 1)

        mov     [di+00],ax      ; load outregs.x.ax
        mov     [di+02],bx      ; load outregs.x.bx
        mov     [di+04],cx      ; load outregs.x.cx
        mov     [di+06],dx      ; load outregs.x.dx
        mov     [di+08],si      ; load outregs.x.si

        xor     ax,ax           ; clear ax
        lahf                    ; get flags into ax
        mov     [di+0ch],ax     ; load outregs.x.cflag

        pop     ax              ; get di from stack
        mov     [di+0ah],ax     ; load outregs.x.di

;-------------------------------------------------------------------

        pop     si              ; restore registers
        pop     di
        mov     sp,bp           ; restore sp
        pop     bp              ; restore user's bp
        ret

_parse  endp

_TEXT   ends                    ; end code segment
        end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\find\find.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
        page    ,132
      title   DOS FIND  Utility
; 0
;********************************************************************
;*
;*   UTILITY NAME:         find.exe
;*
;*   SOURCE FILE NAME:     find.asm
;*
;*   STATUS:               Find utility, DOS Version 4.0
;*
;*   SYNTAX (Command line)
;*
;*         FIND [/V][/C][/N][/I] "string" [[d:][path]filename[.ext]...]
;*
;*         where:
;*
;*           /V - Display all lines NOT containing the string
;*           /C - Display only a count of lines containing string
;*           /N - Display number of line containing string
;*           /I - Ignore case   
;*
;*   UTILITY FUNCTION:
;*
;*     Searches the specified file(s) looking for the string the user
;*     entered from the command line.  If file name(s) are specifeied,
;*     those names are displayed, and if the string is found, then the
;*     entire line containing that string will be displayed.  Optional
;*     parameters modify that behavior and are described above.  String
;*     arguments have to be enclosed in double quotes.  (Two double quotes
;*     if a double quote is to be included).  Only one string argument is
;*     presently allowed.  The maximum line size is determined by buffer
;*     size.  Bigger lines will bomb the program.  If no file name is given
;*     then it will asssume the input is coming from the standard Input.
;*     No errors are reported when reading from standard Input.
;*
;*
;*   EXIT:
;*    The program returns errorlevel:
;*      0 - OK, and some matches
;*      1 - OK, but no matches
;*      2 - Some Error
;*
;*
;*   Revision History:
;*
;*    V1.1    8/23/82         M.A.U.  (Microsoft)
;*
;*    V1.2    9/22/82         M.A.U.  (Microsoft)
;*              Added the -c and -n options
;*
;*            9/23/82         M.A.U.  (Microsoft)
;*              Added DOS version number control
;*
;*            10/07/82  Rev.2         M.A.U.  (Microsoft)
;*              Changed quote for double quotes, and added
;*            file name printing
;*
;*            10/20/82  Rev.3         M.A.U.  (Microsoft)
;*              Modified IBM name to FIND, and changed the text
;*            of some messages.
;*
;*            10/25/82  Rev.4         M.A.U.  (Microsoft)
;*              Changed name to FIND and all messages to the
;*            IBM form.
;*
;*            10/27/82  Rev.5         M.A.U.  (Microsoft)
;*              Made the correct exit on version check in case
;*            of a 1.x DOS.
;*
;*            11/4/82 Rev. 5          A.R. Reynolds  (Microsoft)
;*               Messages moved to external module
;*
;*            11/10/82  Rev. 6        M.A. U.  (Microsoft)
;*              Corrected problem with line numbers, and a problem
;*            with seeking for 0 chars.
;*
;*            03/30/83  Rev. 7        M.A. U.  (Microsoft)
;*              Added patch area for bug fixing.
;*
;*            04/14/83  Rev. 8        M.A. U.  (Microsoft)
;*              Made changes for Kanji characters. (ugh!)
;*
;*            12/17/84  Rev. 9        Zibo  (Microsoft)
;*              Fix boundary case for buffer containing exact line
;*
;*    V4.0 :  6/29/87                 Russ W (IBM)
;*           Lines commented with ;AN000;
;*              Add support for IBM Parse service routines
;*              Add support for IBM Message Retriever Service Routines
;*              Add support for Code Page File Tags
;*              Made PROCs out of all labels that were targets of a call (not commented with AN000)
;*              Removed patch area for "bug fixing"
;*
;*    V4.0 :  9/15/87                 Bill L, (IBM)
;*           ;AN001; = DCR 201, changes to extended attributes support
;*           ;AN002; = PTM 1090
;*           ;AN003; = DCR 191
;*           ;AN004; = PTM 1630
;*           ;AN005; = PTM 1643, PTM 1675, PTM 1754
;*           ;AN006; = DBCS support
;*           ;AN007; = Optimizations to save disk space on ship diskettes
;*
;*    V5.0 :  8/9/90
;*	      M01	SA	Modified parser parameter block used by pre-parse
;*				so that switches within strings are not recognized.
;*				Modified pre-parse routine so that it continues
;*				parsing if a string or file-spec is identified.
;*	
;*            M002      MD      Improved segment usage, added international
;*                              upper casing, fixed /I bug.  Not all changes
;*                              marked.
;*
;*    V6.0 : 10/19/92
;*                      MD      Got return code working
;*
;**********************************************************************

;--------------------------
;-      MACRO DEFINITIONS
;--------------------------
BREAK   MACRO   subtitle
        SUBTTL  subtitle
        PAGE
ENDM


;---------------------------;
;-      INCLUDE FILES       ;
;---------------------------;
.xlist                      ;
.xcref                      ;
        INCLUDE SYSCALL.INC ;
        INCLUDE sysmsg.inc  ;   ;AN000; Include message equates and MACROS
        INCLUDE find.inc    ;   ;AN000; Include find equates and MACROS
.list                       ;
.cref                       ;
;---------------------------;

MSG_UTILNAME <FIND>             ;AN000;

;--------------------------
;-      EQUATES
;--------------------------
FALSE           equ     0
TRUE            equ     NOT FALSE

CR              equ     0dh             ;A Carriage Return
LF              equ     0ah             ;A Line Feed
quote_char      equ     22h             ;A double quote character


buffer_size     equ     4096            ;file buffer size
st_buf_size     equ     128             ;string arg. buffer size
fname_buf_size  equ     64              ;file name buffer size


;----- DOS EQUATES -----;
STDIN   equ     0                       ;AN000; Handle
STDOUT  equ     1                       ;AN000; Handle
STDERR  equ     2                       ;AN000; Handle

ERROR_ACCESS_DENIED     equ     5       ;AN000; Int 021h error return

;------------------------
;-      MESSAGE EQUATES
;------------------------

msg_file_not_found      equ     2       ;AN000; File not found %s
msg_access_denied       equ     5       ;AN000; Access denied %s
msg_read_error          equ    30       ;AN000; Read error in %s
msg_inv_num_parm        equ     2       ;AN000; Invalid number of parameters
msg_inv_parm            equ    10       ;AN000; Invalid Parameter %s
msg_required_missing    equ     2       ;AN005; Required parameter missing
msg_find                equ     4       ;AN000; FIND:
msg_code_page_mismatch  equ    37       ;AN005; Code Page mismatch
msg_switch              equ     3       ;AN005; Invalid switch

msg_opt1		equ	10      ; these three messages comprise the
msg_opt2		equ	11      ; explanation of the options allowed
msg_opt3		equ 	12      ; for find.      leaf, april 1990

MSG_OPTIONS_FIRST	equ	300	; first options help msg #
MSG_OPTIONS_LAST	equ	310	;  and last

;-----------------------
;--     Parser equates
;-----------------------
 
FarSW   equ     0                       ;AN000;
DateSW  equ     0                       ;AN000;
TimeSW  equ     0                       ;AN000;
FileSW  equ     1                       ;AN000;
CAPSW   equ     1                       ;AN000;
CmpxSW  equ     0                       ;AN000;
DrvSW   equ     0                       ;AN000;
QusSW   equ     1                       ;AN000;
NumSW   equ     0                       ;AN000;
KeySW   equ     0                       ;AN000;
SwSW    equ     1                       ;AN000;
Val1SW  equ     0                       ;AN000;
Val2SW  equ     0                       ;AN000;
Val3SW  equ     0                       ;AN000;

;------------------------
; SUBLIST Equates
;------------------------
Left_Align            equ     0      ;AN000; 00xxxxxx
Right_Align           equ     80h    ;AN000; 10xxxxxx

Char_Field_Char       equ     0      ;AN000; a0000000
Char_Field_ASCIIZ     equ     10h    ;AN000; a0010000

Unsgn_Bin_Byte        equ     11h    ;AN000; a0010001 - Unsigned Binary to Decimal character
Unsgn_Bin_Word        equ     21h    ;AN000; a0100001
Unsgn_Bin_DWord       equ     31h    ;AN000; a0110001

Sgn_Bin_Byte          equ     12h    ;AN000; a0010010 - Signed Binary to Decimal character
Sgn_Bin_Word          equ     22h    ;AN000; a0100010
Sgn_Bin_DWord         equ     32h    ;AN000; a0110010

Bin_Hex_Byte          equ     13h    ;AN000; a0010011 - Unsigned Binary to Hexidecimal character
Bin_Hex_Word          equ     23h    ;AN000; a0100011
Bin_Hex_DWord         equ     33h    ;AN000; a0110011

;---------------------------------------
;-------------- CODE SEGMENT -----------
;---------------------------------------

code    segment public
            assume   cs:code
            assume   ds:nothing
            assume   es:nothing
            assume   ss:stack

        jmp start

;
;--------------------
.xlist
.xcref
include version.inc
INCLUDE parse.asm
.list
.cref
;--------------------

        EXTRN   heading:byte,heading_len:byte

;-----------------------
;----- Misc  Data ------
bufferDB db     6 dup(0)        ;AN006;
dbcs_off dw     0               ;AN006;
dbcs_seg dw     0               ;AN006;
dbcs_len dw     0               ;AN006;

ccolon  db      ": "
n1_buf  db      "["
n2_buf  db      8 dup(0)                ;buffer for number conversion

; possible values of return code
MATCH_EXIT      equ     0               ; match found, no errors
NO_MATCH_EXIT   equ     1               ; no match found, no errors
ERROR_EXIT      equ     2               ; error encountered, search incomplete

errlevel        db      NO_MATCH_EXIT   ; assume no error, no match

GET_UPPER_TABLE equ     6502h           ; DOS get upper case table call    
ucasetab_bias   dw      0               ; value of (256-table size)
uppercase_table db      5 dup (?)       ; buffer for upper case table
                                        ; used of DOS Function 65h,
                                        ; and to store real table address

; command line switch flags

switches	db	0	; holds switches specified on command line

LINE_NUMS	equ	1	; /n - print line numbers with matched lines
NOT_MATCHED	equ	2	; /v - print lines not containing match
LINE_COUNT	equ	4	; /c - print count of matching lines only
NO_CASE 	equ	8	; /i - case insensitive search
HELP		equ	10h	; /? - display help message


;----- LINE COUNTERS
mtch_cntr dw    0                       ;matched lines counter
line_cntr dw    0                       ;line counter

;-------------------------------------------
;-      MESSAGE RETRIEVER SUBSTITUTION LIST
;-------------------------------------------

MSG_SERVICES <MSGDATA>          ;AN000;

sublist label dword             ;AN000;
sl_size db      11              ;AN000; SUBLIST Size, in bytes
sl_res  db      0               ;AN000; reserved
sl_ptr_o dw     ?               ;AN000; Offset  PTR to data item
sl_ptr_s dw     ?               ;AN000; Segment PTR to data item
sl_n    db      0               ;AN000; n of %n
sl_flag db      ?               ;AN000; Data-Type flags
sl_maxw db      0               ;AN000; Max width
sl_minw db      0               ;AN000; Min width
sl_pad  db      ' '             ;AN000; Pad character


parm         db ?               ;AN000; Save area for invalid parm

;******************************************************************************
;*                                               PARSER DATA STRUCTURES FOLLOW
;******************************************************************************

parms   label   byte            ;AN000;
        dw      parmsx          ;AN000; POINTER TO PARMS STRUCURE
        db      1               ;AN000; DELIMITER LIST FOLLOWS
        db      1               ;AN000; NUMBER OF ADDITIONAL DELIMITERS
        db      ";"             ;AN000; ADDITIONAL DELIMITER

parms1  label   byte            ;AN005;
        dw      parmsx1         ;AN005; POINTER TO PARMS STRUCURE
        db      1               ;AN005; DELIMITER LIST FOLLOWS
        db      1               ;AN005; NUMBER OF ADDITIONAL DELIMITERS
        db      ";"             ;AN005; ADDITIONAL DELIMITER

;------------------------------
;- STRUCTURE TO DEFINE FIND SYNTAX REQUIREMENTS
;------------------------------
parmsx  label   word            ;AN000;
        db      1,2             ;AN000; THERE ARE BETWEEN 1 AND 2 POSITIONAL PARMS
        dw      pos1            ;AN000; POINTER TO POSITIONAL DEFINITION AREA
        dw      pos2            ;AN000; POINTER TO POSITIONAL DEFINITION AREA
        db      1               ;AN000; THERE IS 1 SWITCH DEF AREA FOR "/V, /C, AND /N"
        dw      sw1             ;AN000; POINTER TO FIRST SWITCH DEFINITION AREA
        dw      0               ;AN000; THERE ARE NO KEYWORDS IN FIND SYNTAX

parmsx1 label   word            ;AN000;
        db      0,2             ;AN000; THERE ARE BETWEEN 0 AND 2 POSITIONAL PARMS
					;M01;allow minimum of 0 so that command line
					;M01;errors are caught by main parse (after pre-parse)
        dw      pos1            ;AN000; POINTER TO POSITIONAL DEFINITION AREA
        dw      pos2            ;AN000; POINTER TO POSITIONAL DEFINITION AREA
        db      1               ;AN000; THERE IS 1 SWITCH DEF AREA FOR "/V, /C, AND /N"
        dw      sw1             ;AN000; POINTER TO FIRST SWITCH DEFINITION AREA
        dw      0               ;AN000; THERE ARE NO KEYWORDS IN FIND SYNTAX
;M01;end

        ;------------------------------
        ;- STRUCTURE TO DEFINE POSITIONAL PARM
        ;------------------------------
pos1    label   word            ;AN000;
        dw      0080h           ;AN000; QUOTED STRING, REQUIRED
        dw      0000h           ;AN000; NO CAPITALIZE
        dw      ret_buff        ;AN000; PLACE RESULT IN RET_BUFF
        dw      novals          ;AN000; NO VALUE LIST
        db      0               ;AN000; NO KEYWORDS

        ;------------------------------
        ;- STRUCTURE TO DEFINE POSITIONAL PARM
        ;------------------------------
pos2    label   word            ;AN000;
        dw      0203h           ;AN000; FILE NAME, OPTIONAL, REPEATS ALLOWED
        dw      0001h           ;AN000; CAPITALIZE BY FILE TABLE
        dw      ret_buff        ;AN000; PLACE RESULT IN RET_BUFF
        dw      novals          ;AN000; NO VALUE LIST
        db      0               ;AN000; NO KEYWORDS


        ;------------------------------
        ;- STRUCTURE TO DEFINE THE SWITCHES
        ;------------------------------
	public	sw1
	public	n_swch

sw1     label   word            ;AN000;
        dw      0               ;AN000; NO MATCH FLAGS
        dw      2               ;AN005; capitalize
        dw      ret_buff        ;AN000; PLACE RESULT IN RET_BUFF
        dw      novals          ;AN000; NO VALUE LIST
	db	5		;AN000; Five SWITCHES IN FOLLOWING LIST
n_swch  db      "/N",0          ;AN000;
v_swch  db      "/V",0          ;AN000;
c_swch  db      "/C",0          ;AN000;
i_swch	db	"/I",0
?_swch  db      "/?",0


        ;------------------------------
        ;- VALUE LIST DEFINITION FOR NO VALUES
        ;------------------------------
novals  label   word            ;AN000;
        db      0               ;AN000;  VALUE LIST


        ;------------------------------
        ;- RETURN BUFFER FOR POSITIONAL PARAMETERS
        ;------------------------------
ret_buff        label   word    ;AN000;
rb_type         db      ?       ;AN000; TYPE RETURNED
rb_item_tag     db      ?       ;AN000; SPACE FOR ITEM TAG
rb_synonym      dw      ?       ;AN000; ES:rb_synonym points to synonym
rb_value_lo     dw      ?       ;AN000; SPACE FOR VALUE
rb_value_hi     dw      ?       ;AN000; SPACE FOR VALUE




did_file        db      FALSE   ;AN004;  if true then already processed a file
got_eol         db      FALSE   ;AN004;  if false then possibly more filenames on command line
got_filename    db      FALSE   ;AN004;  if true then parser found a filename on command line
got_srch_str    db      FALSE   ;AN000;  if true then parser found search string on command line
ordinal         dw      0       ;AN000; parser ordinal
crlf            db      CR,LF   ;AN000;


;
;************************************************************
;*
;*   SUBROUTINE NAME:      main
;*
;*   SUBROUTINE FUNCTION:
;*         Process the command line.  If there are no errors, then open
;*         the specified files, search for string, display it to the
;*         standard output device.
;*
;*   INPUT: Command line (described in program header)
;*
;*   OUTPUT:
;*         Files will be opened and read in.  Regardless of the command
;*         line parameters entered by the user, output will be written
;*         to the standard output device handle 1.
;*
;*   NORMAL EXIT:
;*         File(s) opened (if not STDIN), read successfully, and closed.
;*         Display requested information.
;*
;*   ERROR CONDITIONS:
;*         Incorrect DOS version
;*         Invalid number of parameters
;*         Syntax error
;*         Access denied
;*         File not found
;*         Invalid Parameter
;*         Read error in
;*
;*   INTERNAL REFERENCES:
;*         bin2asc
;*         clr_cntrs
;*         is_prefix
;*         next_kchar
;*         print_count
;*         prout
;*         prt_err
;*         prt_err_2
;*         prt_file_name
;*         prt_lcntr
;*
;**************************************************************************

        MSG_SERVICES <FIND.ctl,FIND.cla,FIND.cl1,FIND.cl2>      ;AN000;
        MSG_SERVICES <DISPLAYmsg,LOADmsg,CHARmsg,NOCHECKSTDIN>  ;AN003; Make retriever services available
START:

        mov     ax,cs                   ;load ES to the right area,
        mov     es,ax                   ;
        mov     ds,ax                   ;

        assume  ds:code, es:code

        call    sysloadmsg              ;AN000; Preload messages, Check DOS Version.
        jnc     Set_for_parse           ;AN000; If no error, parse command line

        call    prt_find                ;AN005;
        call    sysdispmsg              ;AN005;

        mov     errlevel,ERROR_EXIT     ; report error occurred
        call    terminate               ; does not return

;-----------------------------------
;- DOS version is ok. Parse cmd line
;-----------------------------------
Set_for_parse:
        call    get_dbcs_vector                         ;AN006; ;Get DOS dbcs table vector
;
        mov     ah,GetCurrentPSP                        ;AN000; Get PSP address, returned in BX
        int     021h                                    ;AN000;
        mov     ds,bx                                   ;AN000; Put PSP Seg in DS

        assume  ds:nothing

        mov     si,081h                                 ;AN000; Offset of command line in PSP
        xor     cx,cx                                   ;AN000; Number of args processed so far = 0
        mov     cs:ordinal,cx                           ;AN000; init parser ordinal

;--------------------------------------
; See if there was nothing entered
;--------------------------------------
        cmp     byte ptr ds:080h,0                      ;AN000; Check length of command line,
        jne     p_parse                                 ;AN005; Go process the parameters
        mov     ax,msg_inv_num_parm                     ;AN000; No parms, too bad!
        mov     dh,2                                    ;AN005; message class
        call    display_and_die                         ;AN000; Tell the unfortunate user
p_parse:
        mov     cs:got_filename,FALSE        ;AN004; input file default is STDIN

        push    cs                      ;A0005; ensure es is correct
        pop     es                      ;AN005;

        assume  es:code

        call    clr_cntrs               ;AN005; set all counters to zero
        mov     cx,ordinal              ;AN005; init parser ordinal
        call    pre_parse               ;AN005;
	test	switches,HELP
	jz	parser
	jmp	foo

PARSER:
        push    cs                      ;A0000; ensure es is correct
        pop     es

        assume  es:code

        call    clr_cntrs               ; set all counters to zero
        mov     cx,ordinal              ;AN000; init parser ordinal
        call    parse                   ;AN000; Parse command line

        push    si                      ;AN000; Save ptr to remaining command line
        push    ds

        push    cs                      ;Load new DS with CS
        pop     ds

        assume  ds:code

        mov     ordinal,cx              ;AN000; Save parser ordinal

;---------------------
; get filespec size
;---------------------
        mov     file_name_buf,di        ;save buffer offset from parser
        xor     bx,bx                   ;AN000;indicate no save again
        call    get_length              ;AN000;get filespec length
        mov     file_name_len,ax        ;save the name length

; Get pointer to upper case table if necessary - M002

        test    switches,NO_CASE        ; case ignore active?
        jz      open_file

        push    es
        mov     ax,GET_UPPER_TABLE
        mov     bx,-1                   ; current code page
        mov     cx,5                    ; size of info for upper case table
        mov     dx,bx                   ; current country id
        push    cs
        pop     es

        assume  es:code

        mov     di,offset uppercase_table ; point at buffer for table
        int     21h
                                        ; assume no error
        inc     di                      ; point at start of table
        les     di,[di]                 ; load table address

        assume  es:nothing

        mov     bx,es:[di]              ; load table size
        mov     ax,256                  ; compute table size bias
        sub     ax,bx
        mov     ucasetab_bias,ax        ; save it for later
        add     di,2                    ; point at translation table
        mov     word ptr uppercase_table,di   ; save tranlation table address
        mov     word ptr uppercase_table+2,es
        pop     es                                        

;---------------------
;-      OPEN FILE FOR READING
;---------------------                  ; M002 end
open_file:

        cmp     got_filename,TRUE       ;AN004; using STDIN
        je      o_cont                  ;AN004; no, open the file
        xor     ax,ax                   ;AN007; ;AN004; file handle (ax) = STDIN
	jmp	short say_name		;AN007; ;AN004; skip open of file
o_cont:                                 ;AN004;
        mov     dx,file_name_buf        ;AC000;addrss. of the file name
openit:
        mov     ah,open
        mov     al,0                    ;file open for reading
        int     021h                    ;call the DOS
	jc	do_open_error		;AN000;

;---------------------
;-      PRINT FILE NAME
;---------------------
say_name:
        push    ax                      ;save file handle
        cmp     got_filename,FALSE      ;AN004; using STDIN
        je      xx1                     ;AN004; yes, don't print a filename
        mov     dx,offset heading
        mov     cl,heading_len
        xor     ch,ch
        call    prout

        mov     dx,file_name_buf     
        mov     cx,file_name_len
        call    prout

	test	switches,LINE_COUNT   	;count only flag set?
	jnz	xx1

        mov     dx,offset crlf
        mov     cx,2
        call    prout
xx1:
        pop     ax

;---------------------
;-      Fill Buffer for Matching
;---------------------
fill:
        mov     bx,ax                   ;retrieve handle
refill:
        mov     dx,offset buffer        ;data buffer addrss.
        mov     cx,buffer_size
        mov     ah,read
        int     021h
        jnc     no_read_error           ;if carry then read error
        jmp     read_error

no_read_error:
        or      ax,ax                   ;if ax=0 then all done
        jnz     Truncate

DoNullRead:
	test	switches,LINE_COUNT	;count only flag set?
	jz	sj2
        call    print_count

sj2:
        and     bx,bx                  ;Using STD IN?
        jnz     regular
        jmp     foo                     ;if so: all done, exit

regular:
        mov     ah,close                ;otherwise close the file
        int     021h
        jmp     scan_rest               ;get another file

do_open_error:
        jmp     open_error              ;AN000;
;---------------------------
; We have read in an entire buffer.  Scan for a ^Z and terminate the buffer
; there.  Change only CX
;---------------------------
Truncate:
        push    di
        push    cx
        push    es
        mov     di,dx
        mov     cx,ax
        mov     ax,ds
        mov     es,ax

        assume  es:code

        mov     al,1Ah
        CLD
        repnz   scasb
;---------------------------
; If zero is set, the the previous character is a ^Z.  If it is reset then
; the previous character is the end of buffer.  With ^Z, we back up over the
; char.
;---------------------------
        jnz     chop
        dec     di
chop:
        mov     ax,di
        sub     ax,dx                   ; get true length of buffer
        pop     es

        assume  es:nothing

        pop     cx
        pop     di
        or      ax,ax
        jz      DoNullRead

;---------------------------
;----- MATCH ROUTINE
;---------------------------
;Note: If input is being taken from a file the stack contains
; (from top to bottom):
;       - Pointer to the next command in the command line
;       - Pointer to the program segment prefix (to be loaded into
;         DS to access the command line.
; if the input is from the standard input then NONE of it will be
; in the stack.
;---------------------------

go_match:
        push    bx                      ;save the file handle
        mov     bp,offset buffer        ;ptr to first line of file
;---------------------------
; At this point we must check to make sure there is AT LEAST one LF in the
;  buffer. If there is not, then we must insert one at the end so we
;  don't get stuck trying to get one complete line in the buffer when
;  we can't cause the buffer ain't big enough.
;---------------------------
        push    ax                      ; Save true buffer size
        mov     cx,ax                   ; scan whole buffer
        mov     al,LF                   ; for a LF
        mov     di,bp                   ; start of buffer
        repnz   scasb
        pop     ax                      ; recover buffer size
        mov     di,ax                   ;displacement from beg of buffer
        jnz     last_line               ; No line feeds, must insert one
;---------------------------
; Check to see if we reached EOF (return from READ less than buffer_size).
;  If EOF we must make sure we end with a CRLF pair.
;---------------------------
        cmp     ax,buffer_size-1        ;last line of the file?
        jg      no_last_line            ;nope
last_line:                              ;if yes, add a CRLF just in case
        mov     bx,bp
        cmp     byte ptr[bx+di-1],LF    ;finished with a LF?
        je      no_last_line            ;yes, it's an OK line.
        mov     byte ptr[bx+di],CR      ;put a CR at the end of the data
        inc     di
        mov     byte ptr[bx+di],LF      ;put a LF ...
        inc     di

no_last_line:
        push    di                      ;save the # of chars. in the buffer
        push    bp
        mov     dx,st_length            ;length of the string arg.
        dec     dx                      ;adjust for later use
        jmp     short try_again

more_stuff_o:
        jmp     more_stuff

;----- SCAN LINES IN THE BUFFER FOR A MATCH -------------------------;
;Note: at this point the stack contains (from top to bottom):
;       - Stuff mentioned before
;       - File Handle
;       - Number of chars. left in the buffer from the next line.
;       - Addrs. of the next line in the buffer.
;
; plus, DX has the adjusted length of the string argument.
;
; We are about to begin scanning a line.  We start by determining if there is
; a complete line in the buffer.  If so, we scan for the char.  If NOT, we go
; and grab new info.
;---------------------------
	public	try_again
try_again:
        pop     bp                      ;addrs. of next line in the buffer
        mov     di,bp                   ;points to beg. of a line
        pop     cx                      ;get # of chars left in the buffer
        mov     bx,cx                   ;save in case a non-complete line
        mov     al,LF                   ;search for a Line Feed
        jcxz    more_stuff_o            ;no chars left in buffer
        repnz   scasb
        jnz     more_stuff_o            ;no full line left in buffer
        push    cx                      ;save chars left in buffer
        push    di                      ;points to beg. of next line
        mov     cx,di
        sub     cx,bp                   ;length of the current line
        mov     bx,cx                   ;save in case it has a match
        dec     cx                      ;Discount the LF we found
        cmp     byte ptr ES:[DI-2],CR   ; Is there a CR to discount too?
        jnz     NO_SECOND_DEC           ; No there is not.
        dec     cx                      ;CR character discounted
NO_SECOND_DEC:
        inc     line_cntr               ;increment line counter
        jcxz    try_again_opt           ;if line empty go to next line
        mov     di,bp                   ;pointer to the beg. of current line
another_char:
;---------------------------
; On entry:
;       BX      line length
;       CX      adjusted line length
;       DX      adjusted string argument length
;       DI      points to beg. of line
;---------------------------
        push    dx                      ;save for next line
lop:
        pop     dx
        push    dx
        inc     dx                      ;different algorithm!
        mov     si,offset st_buffer     ;pointer to beg. of string argument

comp_next_char:
        push    di
        mov     di,si
        call    is_prefix               ;check for a prefix char
        pop     di
        jnc     nopre
        lodsw
        cmp     cx,1                    ; Can not compare a two byte char
        jbe     try_again_opt1          ; if there is only one available
        cmp     ax,word ptr [di]
        jz      kmatch1
        jmp     short back_up           ;AN007;

nopre:
        lodsb
        cmp     al,byte ptr [di]
        jz      kmatch
	test	switches,NO_CASE	; case insensitive search?
	jz	back_up 		; back up now if not
        mov     ah,[di]                 ; get other char in AH
        call    check_case              ; check case of both chars
	cmp	al,ah           	; compare again
	jz	kmatch

back_up:
        pop     ax                      ; Original length of comp string
        push    ax
        inc     ax
;---------------------------
    ; Our match failed IN THE MIDDLE of the string (partial match). We need
    ;  to back up in the line to the NEXT char after the one which matched
    ;  the first char of the search string and try again. The amount to
    ;  back up to where we started is ax-dx (the result MAY be 0, this is OK).
    ;  we then need to skip ONE char in the line.
;---------------------------
        sub     ax,dx                   ; AX = AX-DX
        sub     di,ax                   ; Do the back up.
        add     cx,ax                   ; restore count too!
        call    next_kchar              ;no match, advance di to next kanji
        jc      try_again_opt1          ;not enough chars left in line
        jmp     short lop               ;try another char in line

try_again_opt1:
        pop     dx
        jmp     short try_again_opt     ;AN007;


kmatch1:
        dec     dx                      ;last char had prefix so it was
                                        ; long.
kmatch:
        dec     dx
        jz      a_matchk                ; no chars left: a match!
        call    next_kchar
        jc      try_again_opt1
        jmp     comp_next_char          ; loop if chars left in arg.

a_matchk:
        mov     errlevel,MATCH_EXIT     ; match found, set return code
        pop     dx
	test	switches,NOT_MATCHED    ;is flag set?
	jz	prt_line		;no, print the line
        jmp     try_again

;---------------------------
;-      NO MATCH: CHECK FOR THE v OPTION
;---------------------------
try_again_opt:
	test	switches,NOT_MATCHED    ;is flag set?
	jnz	prt_line
	jmp	try_again		;no goto next line

;---------------------------
;-      PRINT THE LINE WITH THE MATCH
;Note: at this point the stack contains (top to bottom)
;       - Stuff mentioned before
;
; plus, BP points to begginig of the current line, BX has the length
;of the current line including the CRLF, and DX the adjusted length of
;the string argument.
;---------------------------

prt_line:
	test	switches,LINE_COUNT	;is count only flag set?
	jz	no_line_count
        inc     mtch_cntr               ;yes, increment counter
        jmp     try_again

no_line_count:
        push    dx                      ;save the adjusted string arg. length
	test	switches,LINE_NUMS	;is line number flag set?
	jz	no_line_nums
        call    prt_lcntr

no_line_nums:
        mov     dx,bp
        mov     cx,bx
        call    prout
        pop     dx                      ;restore
        jmp     try_again

;----- READ MORE TEXT LINES INTO THE BUFFER -------------------------;
; The scanning routines have detected that the buffer does not
;contain a full line any more. More lines have to be read into the
;buffer. But first perform a seek on the file in order to re-read
;the non-complete line into the begining of the buffer.
; Uppon entry BP contains points to the begining of the non-complete
;line, and BX has the number of characters left in the buffer.
; The Stack contains (top to bottom):
;       - Pointer to the next command in the command line
;       - Pointer to the program segment prefix (to be loaded into
;         DS to access the command line).
;       - File handle.

more_stuff:
        mov     dx,bx                   ;get chars left in buffer
        pop     bx                      ;get the handle
        or      dx,dx                   ;are there 0 left?
        jz      no_seek                 ;yes, do not seek
        neg     dx                      ;form two's complement
        mov     cx,-1
        mov     al,1                    ;seek from the current position
        mov     ah,lseek                ;seek on file
        int     021h
        jc      read_error
no_seek:
        jmp     refill                  ;no errors: refill the buffer
read_error:
        and     bx,bx                   ;AN007; ;Using STD IN?
        je      foo                     ;if so: all done, exit
        mov     ah,close                ;close the file
        int     021h
;---------------
;------ Set message number and go display it

        mov     ax,msg_read_error       ;AN000; Read error message
        jmp     short r_error           ;AN007;

;---------------------
;-      PRINT ERRORS
;---------------------
open_error:
        cmp     ax,ERROR_ACCESS_DENIED  ;AN000;
        jnz     DoNorm

        mov     ax,msg_access_denied    ;AN000; Message for Access Denied
        jmp     short r_error           ;AN007; ;AN000; Do the rest

DoNorm:                                 ;AN000;
        mov     ax,msg_file_not_found   ;AN000; Message for File Not Found

r_error:
        call    prt_find                ;AN005;
        mov     sl_ptr_s,ds          ;AN000; Save segment of subst text
        mov     cx,file_name_buf     ;AN000;
        mov     sl_ptr_o,cx          ;AN000; Save offset  of subst text
        mov     sl_flag,left_align+char_field_ASCIIZ ;AN000; Type of insertion text
        mov     bx,STDERR               ;AN000; Sent to STD OUT
        mov     cx,1                    ;AN000; One substitution string
        mov     dh,1                    ;AN000; Its a utility message

        call    display_msg             ;AN000; Display rror message
        mov     errlevel,ERROR_EXIT     ; signal exiting with error

;---------------------
;-      SCAN THE REST OF THE COMMAND LINE
;---------------------
scan_rest:
        pop     ds                      ;restore pointer to comm. line

        assume  ds:nothing

        pop     si                      ;restore pointer to next comm.
        mov     did_file,TRUE           ; tell parser we did a file, so if it doesn't find another, ok!
        cmp     got_eol,TRUE            ; Check if nothing left on command line
        je      foo                     ; no, nothing left on command line, exit
        jmp     parser

foo:
        call    terminate               ; terminate


;--------------------------
;       Clear Counters
;--------------------------
        assume  ds:nothing

clr_cntrs proc  near
        mov     byte ptr cs:mtch_cntr,0
        mov     byte ptr cs:line_cntr,0
        ret
clr_cntrs endp


;--------------------------
;       Print Count of Matched lines
;       Modifies: AX,CX,DX and DI
;--------------------------
        assume  ds:code

print_count     proc    near
        push    bx                      ;save handle
        and     bx,bx                   ;AN007; ;using STDIN?
        jz      sj3                     ;if so do not print file name

        mov     dx,offset ccolon
        mov     cx,2
        call    prout                   ;print colon
sj3:
        mov     ax,mtch_cntr
        mov     di,offset n2_buf        ;buffer for characters
        call    bin2asc                 ;convert to ascii
        mov     dx,offset n2_buf
        call    prout                   ;print the number
        mov     dx,offset crlf
        mov     cx,2
        call    prout                   ;print an end of line
        pop     bx
        ret
print_count     endp

;--------------------------
;       Print relative line number

;       Modifies: AX,CX and DI
;--------------------------
        assume  ds:code

prt_lcntr       proc    near
        push    bx
        push    dx
        mov     ax,line_cntr
        mov     di,offset n2_buf
        call    bin2asc
        mov     byte ptr[di],"]"
        inc     cx
        inc     cx
        mov     dx,offset n1_buf
        call    prout
        pop     dx
        pop     bx
        ret
prt_lcntr endp

;--------------------------
;       Print string to STDOUT
;--------------------------
        assume  ds:code

prout   proc    near
        mov     bx,STDOUT
        mov     ah,write
        int     021h
        ret
prout   endp

;--------------------------
;       Binary to Ascii conversion routine
; Entry:
;       AX      Binary number
;       DI      Points to one past the last char in the
;             result buffer.
; Exit:
;       Result in the buffer MSD first
;       CX      Digit count
; Modifies:
;       AX,BX,CX,DX and DI
;--------------------------
        assume  ds:code

bin2asc proc    near
        mov     bx,0ah
        xor     cx,cx
go_div:
        inc     cx
        cmp     ax,bx
        jb      div_done
        xor     dx,dx
        div     bx
        add     dl,'0'          ;convert to ASCII
        push    dx
        jmp     short go_div

div_done:
        add     al,'0'
        push    ax
        mov     bx,cx
deposit:
        pop     ax
        stosb
        loop    deposit
        mov     cx,bx
        ret
bin2asc endp

;--------------------------
;       Compares chars in AH and AL regardless of case
;               if either char is lower case, convert to upper and
;               compare.  On entry, we've already established the
;               chars don't compare as they are, so we need to check
;               if they compare after case mapping
;
;       entry:
;               AL,AH   have the characters to compare
;       exit:
;               AL,AH   converted to upper case
;       modifies:
;               AX
;--------------------------
;M002 modified this routine

        assume  ds:code

check_case proc	near

        cmp     al,80h                  ; if AL is extended char, get mapping
        jb      not_al_high             ; AL not extended char
        call    use_table               ; get mapping

not_al_high:
        xchg    ah,al
        cmp     al,80h
        jb      not_ah_high
        call    use_table

not_ah_high:
        cmp     al,'a'
        jb      not_al_lower
        cmp     al,'z'
        ja      not_al_lower
        and     al,0DFh

not_al_lower:
        xchg    ah,al
        cmp     al,'a'
        jb      not_ah_lower
        cmp     al,'z'
        ja      not_ah_lower
        and     al,0DFh

not_ah_lower:
        ret

use_table:
        push    bx
        push    di
        push    es

        les     di,dword ptr uppercase_table      ; get the table

        assume  es:nothing

        mov     bl,al
        xor     bh,bh
        sub     bx,ucasetab_bias        ; get the index
        mov     al,es:[di+bx]           ; get the char

        pop     es
        pop     di
        pop     bx
        ret                     

check_case endp



;--------------------------
;       ADVANCE POINTER TO NEXT KANJI CHARACTER
; entry:        DI  points to a Kanji string
;               CX  length in bytes of the string
; exit:         DI  points to next Kanji char
;               CX  has number of bytes left
; modifies:     AX
;--------------------------
        assume  ds:code

next_kchar      proc    near
        jcxz    no_kleft
        call    is_prefix
        jnc     no_p
        inc     di
        dec     cx
        jcxz    no_kleft                ; for insurance
no_p:
        inc     di
        dec     cx
        clc
        ret

no_kleft:
        stc
        ret
next_kchar      endp

;--------------------------
;       Get DOS dbcs table vector
; entry:  none
; exit:   none
; modifies: none
;--------------------------
get_dbcs_vector proc near             ;AN006;
        push es                       ;AN006;
        push di                       ;AN006;
        push ax                       ;AN006;
        push bx                       ;AN006;
        push cx                       ;AN006;
        push dx                       ;AN006;
;
        mov  ax,cs                    ;AN006; ;segment of return buffer
        mov  es,ax                    ;AN006;

        assume  es:code

        mov  di,offset bufferDB       ;AN006; ;offset of return buffer
        mov  ah,65h                   ;AN006; ;get extended country info
        mov  al,07h                   ;AN006; ;get DBCS environment table
        mov  bx,0ffffh                ;AN006; ;use active code page
        mov  cx,5                     ;AN006; ;number of bytes returned
        mov  dx,0ffffh                ;AN006; ;default country ID
        int  21h                      ;AN006; ;DOS function call,vector returned
                                      ;AN006; ; in ES:DI
        assume  es:nothing

        inc  di                       ;AN006; ;skip over id byte returned
        mov  ax,word ptr es:[di]      ;AN006; ;get offset of DBCS table
        mov  cs:dbcs_off,ax           ;AN006; ;save it
;
        add  di,2                     ;AN006; ;skip over offset to get segment
        mov  bx,word ptr es:[di]      ;AN006; ;get segment of DBCS table
        mov  cs:dbcs_seg,bx           ;AN006; ;save it
;
        mov  di,ax                    ;AN006; ;Point to DBCS table to get length
        mov  es,bx                    ;AN006;
        mov  ax,word ptr es:[di]      ;AN006;
        mov  cs:dbcs_len,ax           ;AN006;
        add  cs:dbcs_off,2            ;AN006; ;change offset to point to table
;
        pop  dx                       ;AN006;
        pop  cx                       ;AN006;
        pop  bx                       ;AN006;
        pop  ax                       ;AN006;
        pop  di                       ;AN006;
        pop  es                       ;AN006;
;
        ret                           ;AN006;
get_dbcs_vector endp                  ;AN006;


;--------------------------
;       FIND OUT IS THE BYTE IS A KANJI PREFIX
; entry:  DI    points to a kanji string
; exit:   Carry set if it is a kanji prefix
; modifies:     AX
;--------------------------
        assume  ds:code

is_prefix proc near                   ;AN006;
        push    es
        push    si
        push    ax
;
        mov     si,dbcs_off        ;ES:SI -> DOS dbcs table
        mov     ax,dbcs_seg
        mov     es,ax
;
        assume  es:nothing

        mov     al,byte ptr [di]   ;get first byte of string
;
; Two consecutive 00 bytes signifies end of table
;

is_loop:
        cmp  word ptr es:[si],00h     ;Check for two consecutive 00 bytes
        jne  is_next1                 ;no, continue
        clc                           ;clear carry - byte is not lead byte of db char
        jmp  short is_exit            ;AN007; ;yes, found them, quit

;
; Check if byte is within range values of DOS dbcs table
;

is_next1:
        cmp  al,byte ptr es:[si]      ;is byte >= first byte in range?
        jae  is_next2                 ;yes, continue
        jmp  short is_again           ;AN007; ;no, loop again

is_next2:
        cmp  al,byte ptr es:[si+1]    ;is byte <= last byte in range?
        jbe  is_found                 ;yes, found a lead byte of db char

is_again:
        add  si,2                     ;no, increment ptr to next range
        jmp  is_loop

is_found:
        stc                           ;byte is lead byte of db char, set carry

is_exit:
        pop  ax
        pop  si
        pop  es
;
        ret
is_prefix       endp


;
;---------------------
;- Terminate process
;---------------------
terminate       proc    near          ;AN000;
        mov     ah,exit               ;AN000; Terminate function call
        mov     al,cs:errlevel        ;AN000; Errorlevel placed in AL
        int     021h                  ;AN000; Terminate
        ret                           ;AN000; Meaningless return
terminate       endp                  ;AN000;


;
;************************************************************
;*
;*   SUBROUTINE NAME:      display_msg
;*
;*   SUBROUTINE FUNCTION:
;*         Display the requested message to the specified handle
;*
;*   INPUT:
;*      1)   AX = Number of the message to be displayed.
;*      2)   BX = Handle to be written to.
;*      3)   DH = Code indicating message class
;*
;*   OUTPUT:
;*      The message corresponding to the requested msg number will
;*      be written to the requested handle.
;*
;*   NORMAL EXIT:
;*      Message will be successfully written to requested handle.
;*
;*   ERROR EXIT:
;*      None.  Note that theoretically an error can be returned from
;*      SYSDISPMSG, but there is nothing that the application can do.
;*
;*   INTERNAL REFERENCES:
;*      System Display Message service routines
;*
;*   EXTERNAL REFERENCES:
;*      None
;*
;************************************************************
display_msg     proc    near            ;AN000;
        push    ds                      ;AN000; Save DS
        push    cs                      ;AN000; Substitution list segment
        pop     ds                      ;AN000;

        assume  ds:code

        mov     si,offset sublist       ;AN000; Substitution list offset
      ; mov     dh,-1                   ;AN000; Message class
                                        ; 1=DOS Extended error
                                        ; 2=DOS Parse error
                                        ; -1=Utility message
        mov     dl,0                    ;AN000;  DOS INT 21H function number to use for input
                                        ; 00H=No input, 01H=Keyboard input,
                                        ; 07H=Direct Console Input Without Echo,
                                        ; 08H=Console Input Without Echo, 0AH=Buffered Keyboard Input
        call    SYSDISPMSG              ;AN000; AX=Extended key value if wait for key
      ; jnc     disp_done               ;AN000; If CARRY SET then registers will contain extended error information
                                        ;       AX - Extended error Number
                                        ;       BH - Error Class
                                        ;       BL - Suggested action
                                        ;       CH - Locus
disp_done:                              ;AN000;
        pop     ds                      ;AN000; Restore DS

        assume  ds:nothing

        ret                             ;AN000;
display_msg     ENDP                    ;AN000;

        PAGE
;************************************************************
;*
;*   SUBROUTINE NAME:      parse
;*
;*   SUBROUTINE FUNCTION:
;*      Call the DOS PARSE Service Routines to process the command
;*      line. Search for valid switches (/N, /V, /I, and /C) and take
;*      appropriate action for each.  Extract the search string.
;*
;*   INPUT:        DS:SI points to string to parse
;*                 ES:DI parser parms
;*
;*   OUTPUT:       ES:DI points to filespec for text search
;*
;*   NORMAL EXIT:
;*
;*      If /V, /C, or /N entered, set appropriate flag.
;*      Save the search string.
;*
;*   ERROR EXIT:
;*
;*      If user enters any invalid parameter or switch, then this
;*      routine will display an error message and terminate with
;*      errorlevel 2.
;*
;************************************************************
EOL             equ    -1       ;AN000; Indicator for End-Of-Line
NOERROR         equ     0       ;AN000; Return Indicator for No Errors
SYNTAX          equ     9       ;AN000; Syntax error from parser

SWITCH          equ     3       ;AN000;
FILESPEC        equ     5       ;AN000;
QUOTED_STRING   equ     9       ;AN000;

parse   proc    near                                    ;AN000;
;--------------------------------------
; address of command line in DS:SI
;--------------------------------------
;------------------------------------------
;- Look for the search string and switches
;------------------------------------------
parse_loop:                                             ;
        mov     di,offset parms                         ; Address of parse control block at ES:DI
        xor     dx,dx                                   ; Reserved
        call    sysparse                                ; Parse parm at DS:SI
        cmp     ax,EOL                                  ; Are we at End Of Line ??
        jne     p_next                                  ; No eol found
        mov     cs:got_eol,TRUE                         ; no more filenames to get!
        cmp     cs:did_file,TRUE                        ; did we do a file already ?
	jne	end_parse       			; Yes, done here
	jmp	terminate                               ; otherwise finished

p_next:                                                 ; continue
        and     ax,ax                                   ; ;AN000; Was there an error?
        je      CONT2                                   ; No, continue processing

        mov     dh,2                                    ; Its a PARSE message
        call    display_and_die                         ;
CONT2:                                                  ; Something valid was entered
        cmp     cs:rb_type,QUOTED_STRING                ; Is it a quoted string ?
        je      its_a_quoted_string                     ; Yes, go process it
        cmp     cs:rb_type,FILESPEC                     ; Is it a filespec?
        jne     cont3                                   ;
        mov     di,cs:rb_value_lo                       ;  Look for another
        mov     cs:got_filename,TRUE                    ;  got a filename
        jmp     short end_parse                         ;  Look for another
cont3:
        cmp     cs:rb_type,SWITCH                       ; Is it a switch ?
	je	parse_loop				; pre_parse already checked
							; switches, don't need to here
        mov     ax,msg_inv_parm                         ; None of above, too bad
        mov     dh,2                                    ; message class
        call    display_and_die                         ; Tell the poor user and terminate

;-----------------------------
;- The search string was entered
;-----------------------------
its_a_quoted_string:                                    ; Found a quoted string
        cmp     cs:got_srch_str,TRUE                    ; Do we already have one?
        jne     its_ok                                  ; No, it's ok
        mov     ax,msg_inv_parm                         ; Yes, Invalid parm!
        mov     dh,2                                    ; message class
        call    display_and_die                         ; Tell user and die gracefully
its_ok:                                                 ;
        mov     di,cs:rb_value_lo                       ; Get pointer to it
        mov     bx,offset st_buffer                     ; save buffer offset
        call    get_length                              ; get string length
        mov     cs:st_length,ax                         ; save length
        mov     cs:got_srch_str,TRUE                    ; Indicate that we have it
        jmp     parse_loop                              ;

end_parse:                                              ; A filename should be next
        cmp     cs:got_srch_str,TRUE                    ; Do we already have one?
        je      rett                                    ;
        mov     ax,msg_required_missing                 ;
        mov     dh,-1                                   ; message class
        call    display_and_die                         ; Yes, tell the poor user and terminate
rett:                                                   ;
        ret                                             ;

parse   endp                                           


;------------------------------------
;-
;-  Procedure name: pre_parse
;-
;-  Purpose: parse for all switches now
;-      so that they can be applied for
;-      all filenames on command line.
;-
;-  INPUT: none
;-
;------------------------------------
        assume  ds:nothing

	public pre_parse
pre_parse proc near                     ;AN005;
        push    ax                      ;AN005;
        push    bx                      ;AN005;
        push    cx                      ;AN005;
        push    dx                      ;AN005;
        push    di                      ;AN005;
        push    si                      ;AN005;
        push    es                      ;AN005;
        push    ds                      ;AN005;
;
pp_loop:                                ;AN005;
	mov	di,offset parms1	;
        xor     dx,dx                   ;AN005; Reserved
        call    sysparse                ;AN005; Parse parm at DS:SI

        cmp     ax,EOL                  ;AN005; Are we at End Of Line ??
	jne	pp_chek_switch		;AN005; No eol found
	jmp	pp_end

pp_chek_switch:
        cmp     ax,SWITCH               ;AN005; invalid switch ?
        jne     pp_next                 ;AN005; no
; error
        mov     ax,msg_switch           ;AN005; Invalid switch
        mov     dh,2                    ;AN005; message class
        call    display_and_die         ;AN005; Yes, tell the poor user and terminate
pp_next:
        and     ax,ax                   ;AN007; ;AN005; Was there an error?
        jne     pp_loop                 ;AN005; No, continue processing

	cmp	cs:rb_type,QUOTED_STRING	;M01;get next parm if string
	je	pp_loop				;M01; or filespec
	cmp	cs:rb_type,FILESPEC		;M01
	je	pp_loop				;M01

        cmp     cs:rb_type,SWITCH       ;AN005; Is it a switch ?
        jne     pp_loop                 ;AN005;

; got a switch
        mov     bx,cs:rb_synonym        ;AN005; Get offset of switch entered
        cmp     bx,offset n_swch        ;AN005; Is it the /N switch?
        jne     pp_chek_v               ;AN005:  Yes, process it.
	or	cs:switches,LINE_NUMS	;AN005;  Set the corresponding flag
        jmp     pp_loop                 ;AN005;  Look for another
pp_chek_v:                              ;AN005;
	cmp	bx,offset v_swch	;AN005; Is it the /v switch?
	jne	pp_chek_i		;AN005:  Yes, process it.
	or	cs:switches,NOT_MATCHED ;AN005;  Set the corresponding flag
        jmp     pp_loop                 ;AN005;  Look for another
pp_chek_i:
	cmp	bx,offset i_swch	;AN005; Is it the /i switch?
	jne	pp_chek_c		;AN005:  Yes, process it.
	or	cs:switches,NO_CASE	;AN005;  Set the corresponding flag
        jmp     pp_loop                 ;AN005;  Look for another
pp_chek_c:                              ;AN005;
	cmp	bx,offset c_swch	;AN005; Is it the /c switch?
        jne     pp_chek_?               ;AN005:  Yes, process it.
	or	cs:switches,LINE_COUNT	;AN005;  Set the corresponding flag
        jmp     pp_loop                 ;AN005;  Look for another
pp_chek_?:
	cmp	bx,offset ?_swch
	jne	pp_error
	mov	cs:switches,HELP
	mov	ax, MSG_OPTIONS_FIRST   ; specify first of 3 option desc. msgs
	mov	bx,STDOUT               ; print msgs to standard out
	xor	cx,cx                   ; 0 substitution strings
	mov	dh,-1
@@:
	call	display_msg             ; print first option desc. msgs
	cmp	ax, MSG_OPTIONS_LAST	; last msg?
	je	@F			;  done if so
	inc	ax			; else bump msg number
	jmp	@B			;  and go do it
@@:
 	jmp	short  pp_end           ; get out

pp_error:                               ;AN005; None of the above (can we ever get here?)
        mov     ax,msg_switch           ;AN005; Invalid parameter
        mov     dh,2                    ;AN005; message class
        call    display_and_die         ;AN005; Yes, tell the poor user and terminate

pp_end:                                 ;AN005; A filename should be next
        pop     ds                      ;AN005;
        pop     es                      ;AN005;
        pop     si                      ;AN005;
        pop     di                      ;AN005;
        pop     dx                      ;AN005;
        pop     cx                      ;AN005;
        pop     bx                      ;AN005;
        pop     ax                      ;AN005;
;
        ret                             ;AN005;
pre_parse endp                          ;AN005;


;------------------------------------
;-
;-  Procedure name: prt_find
;-
;-  Purpose: When FIND is used as a filter,
;-      then display error messages with the
;-      prefix: "FIND: ".
;-
;-  INPUT: none
;-
;------------------------------------
        assume  ds:nothing

prt_find proc near                      ;AN005;
        cmp     cs:got_filename,TRUE    ;AN005; Check if should print "FIND:"
        je      prt_ret                 ;AN005;
        push    ax                      ;AN005; Save error
        push    dx                      ;AN005;
        mov     dh,-1                   ;AN005; Display FIND:
        mov     ax,msg_find             ;AN005;
        xor     cx,cx                   ;AN007; ;AN005; No substitution text
        mov     bx,STDERR               ;AN005; Sent to STD OUT
        call    display_msg             ;AN005; Display the message
        pop     dx                      ;AN005;
        pop     ax                      ;AN005; Restore error
prt_ret:
        ret                             ;AN005;
prt_find endp                           ;AN005;


;------------------------------------
;-
;-  Procedure name: display_and_die
;-
;-  Purpose: Called when the parser finds that
;-      required arguments were not entered
;-      from the command line.
;-
;-  INPUT: AX = Error number
;-
;------------------------------------
        assume  ds:nothing

display_and_die proc near
        call    prt_find                ;
        xor     cx,cx                   ; No substitution text
        mov     cs:errlevel,ERROR_EXIT  ; Error code for exit

        mov     bx,STDERR               ; Sent to STD OUT
        call    display_msg             ; Display the message
        call    terminate               ; and Terminate
        ret                             ;
display_and_die endp

;------------------------------------
;-
;-  Procedure name: get_length
;-
;-  Purpose: determine the length of a null
;-      ending string.
;-
;-  INPUT: ES:DI = string address
;-         ES:BX = save address (0=no save)
;-
;-  OUTPUT: AX   = length of string
;------------------------------------
        assume  ds:nothing

get_length      proc near
        push    di
        push    bx
        push    dx
        xor     dx,dx                   ;init string length
look_str:
        mov     al,es:[di]              ;get character
        or      bx,bx                   ;save it?
        jz      no_save
        mov     es:[bx],al              ;save character
        inc     bx                      ;save next character
no_save:                                ;AN007;
        and     al,al                   ;AN007; ;check for eol (asciiz string)
        je      done_look               ;if so, exit
        cmp     al,0dh                  ;AN005; check for eol (carriage return)
        je      done_look               ;AN005;
        inc     dx                      ;increment length
        inc     di                      ;look at next character
        jmp     look_str
done_look:
        xchg    ax,dx                   ;get length in AX
        pop     dx
        pop     bx
        pop     di
        ret
get_length      endp




;
;----- BUFFER AREA --------
st_length dw    0                       ;String argument length
st_buffer db    st_buf_size dup(?)      ;String argument buffer

file_name_len dw 0                      ;File name length
file_name_buf dw 0                      ;File name buffer offset

buffer        db buffer_size+2 dup(?)   ;file data buffer

include msgdcl.inc

code    ends

;--------------------------
;---   STACK SEGMENT    ---
;--------------------------
stack   segment para stack 'STACK'
        dw      (362 - 80h) +64 dup(?,?)    ;(362 - 80h)  == New - old IBM ROM
stack_top equ   $
stack   ends

        end     start

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\display.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;

;***************************************************************************
;***************************************************************************
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: DISPLAY.ASM
;
;
; Change List: AN000 - New code DOS 3.3 spec additions
;              AC000 - Changed code DOS 3.3 spec additions
;***************************************************************************
;***************************************************************************

EXTRN	SwitchMap	:WORD	; Command line sitch map

;***************************************************************************
; Define Segment ordering
;***************************************************************************



.SEQ

PSP     segment public  para    'DUMMY'
PSP     ends

data    segment public para 'DATA'
	Public Test_Data_Start
	Test_Data_Start label byte
data    ends

stack   segment para stack
        db      62 dup ("-Stack!-")	; (362-80h) is the additional IBM ROM
        assume ss:stack
stack   ends

code    segment public para 'CODE'
        assume  cs:code,ds:data
code    ends


End_Of_Memory    segment public para 'BUFFERS'
Public  Test_End
Test_End        label   byte
End_Of_Memory    ends



;***************************************************************************
; INCLUDE FILES
;***************************************************************************


.xlist
INCLUDE FORCHNG.INC
INCLUDE FOREQU.INC
INCLUDE FORMSG.INC
INCLUDE SYSMSG.INC
INCLUDE	FORSWTCH.INC
.list


;***************************************************************************
; Message Services
;***************************************************************************


MSG_UTILNAME  <FORMAT>


data    segment public  para    'DATA'


Msg_Services    <MSGDATA>


data    ends

code    segment public  para    'CODE'
Msg_Services    <NEARmsg>
Msg_Services    <LOADmsg>
Msg_Services    <DISPLAYmsg,CHARmsg,NUMmsg>
Msg_Services	<FORMAT.CLA,FORMAT.CLB,FORMAT.CLC,FORMAT.CL1,FORMAT.CL2,FORMAT.CTL>
code    ends

;***************************************************************************
; Public Declarations
;***************************************************************************

        Public  SysDispMsg
        Public  SysLoadMsg

;***************************************************************************
; Message Structures
;***************************************************************************

Message_Table struc

Entry1  dw      0
Entry2  dw      0
Entry3  dw      0
Entry4  dw      0
Entry5  db      0
Entry6  db      0
Entry7  dw      0

Message_Table ends


;***************************************************************************

code    segment public  para    'CODE'

;***************************************************************************

;***************************************************************************
;Routine name&gml Display_Interface
;***************************************************************************
;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg
;             routine. This information is contained in a message description
;             table pointed to by the DX register. Call SysDispMsg, then
;             restore registers. This routine assumes that the only time an
;             error will be returned is if an extended error message was
;             requested, so it will ignore error returns
;
;Called Procedures: SysDispMsg
;
;Change History&gml Created        4/22/87         MT
;
;Input&gml ES&gmlDX = pointer to message description
;
;Output&gml None
;
;Psuedocode
;----------
;
;       Save all registers
;       Setup registers for SysDispMsg from Message Description Tables
;       CALL SysDispMsg
;       Restore registers
;       ret
;***************************************************************************

Public  Display_Interface
Display_Interface   proc


        push    ds
        push    ax                              ;Save registers
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        mov     di,dx                           ;Change pointer
        mov     dx,data                         ;Point to data segment
        mov     ds,dx

	test	SwitchMap,SWITCH_SELECT
	jnz	DisplayDone

        mov     ax,[di].Entry1                  ;Message number
        mov     bx,[di].Entry2                  ;Handle
        mov     si,[di].Entry3                  ;Sublist
        mov     cx,[di].Entry4                  ;Count
        mov     dh,[di].Entry5                  ;Class
        mov     dl,[di].Entry6                  ;Function
        mov     di,[di].Entry7                  ;Input
        call    SysDispMsg                      ;Display the mes

DisplayDone:
        pop     di                              ;Restore registers
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        pop     ds
        ret                                     ;All done

Display_Interface      endp
code    ends
        end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\filesize.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;----------------------------------------------------------------------------
;
; M026	: B#5794. Updated DOS_SIZE.
;
;----------------------------------------------------------------------------
;
	%out ..filesize.inc

BIOS_SIZE	equ	 35000		;actually
DOS_SIZE	equ	 38000		;actually M026

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forexec.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;*****************************************************************************
;*****************************************************************************
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: FOREXEC.SAL
;
;
;
; Ŀ
; EXEC_FS_FORMAT
; 
;   
;   Ŀ
;   ôShrink
;   
;   Ŀ
;   ôSetup_EXEC
;   
;   Ŀ	  Ŀ
;   ôEXEC_ArgVĴEXEC_Program
;   	  
;   Ŀ Ŀ
;   ôEXEC_Cur_DirectoryĴEXEC_Program
;    
;   Ŀ	  Ŀ Ŀ
;   EXEC_RoutineĴBuild_Path_And_EXECĴEXEC_Program
;    	   
;
; Change List: AN000 - New code DOS 3.3 spec additions
;	       AC000 - Changed code DOS 3.3 spec additions
;*****************************************************************************
;*****************************************************************************

title	DOS	3.30 FORMAT EXEC Module

IF1
	%OUT	ASSEMBLING: DOS 3.3 FORMAT EXEC LOADER
	%OUT
ENDIF

code	segment public para 'code'
	assume	cs:code
code	ends

;*****************************************************************************
; Include files
;*****************************************************************************

.xlist

INCLUDE FORCHNG.INC
INCLUDE FORMACRO.INC
INCLUDE SYSCALL.INC
INCLUDE FOREQU.INC

.list

;*****************************************************************************
; Public Data
;*****************************************************************************

	Public	Drive_Letter_Msg

;*****************************************************************************
; Public Routines
;*****************************************************************************


IF FSExec

	Public	EXEC_FS_Format

ENDIF		;FSExec 		;end /FS: conditional



;***************************************************************************
; External Data Declarations
;***************************************************************************

	extrn	ExitStatus:Byte
	extrn	Fatal_Error:Byte
	extrn	FS_String_Buffer:Byte
	extrn	msgEXECFailure:Byte
	extrn	PSP_Segment:Word
	extrn	drive:byte

;**************************************************************************
; Structures
;**************************************************************************


Exec_Block_Parms struc
Segment_Env	dw	0
Offset_Command	dw	0
Segment_Command dw	0
Offset_FCB1	dw	0
Segment_FCB1	dw	0
Offset_FCB2	dw	0
Segment_FCB2	dw	0

Exec_Block_Parms ends


;**************************************************************************
; Equates
;**************************************************************************


String_Done	equ	0
No_Error	equ	0
Error		equ	1
Stderr		equ	2
Stack_Space	equ	02eh		; IBM addition ROM paras

;**************************************************************************
; PSP Area
;**************************************************************************

PSP	segment public	para   'DUMMY'

org	2Ch
PSP_ENV_SEGMENT label word

FCB1	equ	5Ch

FCB2	equ	6Ch

org	80h
Command_Line label byte


PSP	ends

;**************************************************************************
; Data Area
;**************************************************************************

data	segment public para 'DATA'
	assume	ds:data,es:nothing

Exec_Block Exec_Block_Parms <>
EXEC_Path db	66 dup(0)

Drive_Letter_Msg db "A:",0		;Drive for exec fail message

SP_Save 	dw	?
SS_Save 	dw	?


;These next two should stay togather
; ---------------------------------------

Path_String db	"PATH="
Len_Path_String equ $ - Path_String

;----------------------------------------

;These should stay togather
; ---------------------------------------

Search_FORMAT db "FORMAT"
Len_Search_FORMAT equ $ - Search_FORMAT
Search_Format_End equ $

;----------------------------------------


;These next two should stay togather
; ---------------------------------------

data	ends

;**************************************************************************

code	segment public para 'code'
	assume	cs:code,ds:data

;**************************************************************************
; Main Routine
;**************************************************************************


IF FSExec				;if /FS: desired

Procedure Exec_FS_Format

	Set_Data_Segment
	call	Set_FCB1_Drive
	call	Shrink
	mov	al,ExitStatus		;Setblock fail?

	cmp	al,Error
	JE	$$IF1
	call	Setup_Exec
	call	Exec_Argv		;try exec from dir BASIC loaded
	mov	al,ExitStatus

	cmp	al,Error
	JNE	$$IF2
	call	Exec_Cur_Directory
	mov	al,ExitStatus		;Try exec from cur directory

	cmp	al,Error
	JNE	$$IF2
	call	EXEC_Routine
	mov	al,ExitStatus

	cmp	al,Error
	JNE	$$IF2

	push	ds			;save ds
	push	si			;save si
	mov	si,PSP_Segment		;get psp
	mov	ds,si			;put psp in ds
	assume	ds:PSP

	mov	si,FCB1			;ptr to 1st. FCB
	mov	bl,byte ptr ds:[si]	;get drive ID

	pop	si			;restore si
	pop	ds			;restore ds
	Set_Data_Segment			;set segments

	cmp	bl,0			;Is it default drive?
	JNE	$$IF3
	push	ax			;Save exit code
	DOS_Call Get_Default_Drive	;Get the default drive
	add	al,"A"			;Turn into drive letter
	mov	Drive_Letter_Msg,al	;Save it in message
	pop	ax			;Get return code back

	JMP	SHORT $$EN3
$$IF3:
	add	bl,"A"-1		;Convert to drive letter
	mov	Drive_Letter_Msg,bl

$$EN3:
	Message msgEXECFailure
	JMP SHORT $$EN2

$$IF2:
	DOS_Call WaitProcess
	mov	ExitStatus,al

$$EN2:
$$IF1:
	mov	Fatal_Error,YES 	;Not really, indicates FS used
	ret

Exec_FS_Format endp

;****************************************************************************
; Shrink
;****************************************************************************

Procedure Shrink

	mov	ax,cs			;get code segment
	mov	bx,ds			;get data segment
	sub	ax,bx			;data seg size
	mov	bx,ax			;save paras
	mov	ax,offset End_Program	;Get the offset of end of loader
	mov	cl,4			;Div by 16 to get para's
	shr	ax,cl
	add	bx,ax			;add in code space
	add	bx,Stack_Space		;adjust for stack
	add	bx,11h			;give PSP space
	mov	ax,PSP_Segment
	mov	es,ax
	assume	es:nothing

	DOS_Call SetBlock
	JNC $$IF9
	Message msgEXECFailure
	mov	ExitStatus,Error	;Bad stuff, time to quit
$$IF9:
	ret

Shrink	endp

;**************************************************************************
; Setup_Exec
;**************************************************************************

Procedure Setup_Exec

	Set_Data_Segment
	mov	ax,PSP_Segment			;Get segment of PSP
	mov	ds,ax

	assume	ds:PSP
			;Setup dword pointer to command line to be passed

	mov	es:Exec_Block.Segment_Command,ax ;Segment for command line
	mov	es:Exec_Block.Offset_Command,offset ds:Command_Line

			;Setup dword pointer to first FCB to be passed

	mov	es:Exec_Block.Segment_FCB1,ax	;Segment for FCB1
	mov	es:Exec_Block.Offset_FCB1,offset ds:FCB1 ;Offset of FCB at 05Ch

			;Setup dword pointer to second FCB to be passed 			    ;

	mov	es:Exec_Block.Segment_FCB2,ax	;Segment for FCB2
	mov	es:Exec_Block.Offset_FCB2,offset ds:FCB2 ;Offset of FCB at 06Ch

			;Setup segment of Environment string, get from PSP			    ;

	mov	ax,ds:PSP_Env_Segment
	mov	es:Exec_Block.Segment_Env,ax
	Set_Data_Segment
	ret


Setup_EXEC endp

;****************************************************************************
; Exec_Argv
;****************************************************************************
;
; Read the environment to get the Argv(0) string, which contains the drive,
; path and filename that was loaded for FORMAT.COM. This will be used to find
; the xxxxxfmt.exe, assuming that it is in the same location or path as
; FORMAT.COM
;

Procedure EXEC_Argv

	Set_Data_Segment			;DS,ES = DATA
	cld
	mov	ax,Exec_Block.Segment_Env	;Get the environment
	mov	ds,ax				;Get addressability

	assume	ds:nothing

	xor	si,si				;Start at beginning
$$DO11:
$$DO12:
	inc	si				;Get character
	cmp	byte ptr [si-1],0		;Find string seperator?
	JNE	$$DO12
	inc	si				;Get next char
	cmp	byte ptr [si-1],0		;Are we at Argv(0)? (00?)
	JNE	$$DO11
	add	si,2				;Skip the word count
	mov	di,si				;Save where string starts

$$DO15: 					;Find length of Argv(0) string
	inc	si				;Get char
	cmp	byte ptr [si-1],0		;Is it the end?
						;End found if 0 found
	JNE $$DO15
	mov	cx,si				;Get number of bytes in string
	sub	cx,di				;Put in cx reg for rep count
	mov	si,di				;Point to path
	mov	di,offset es:EXEC_Path		;Point to where to put it
	rep	movsb				;Move the string
	Set_Data_Segment
	dec	di				;Point at end of ArgV string
	std					;Look backwards

$$DO17: 					;Find 'FORMAT' in ARGV string
	mov	cx,Len_Search_FORMAT		;Get length to compare
	mov	si,offset Search_FORMAT_End-1	;Look at comp string from end
	repe	cmpsb				;See if same string


	JNE	$$DO17
	mov	si,offset FS_String_Buffer
	inc	di				;DI = replacement point-1
	cld					;Set direction flag back
	mov	cx,Len_FS_String_Buffer 	;Length of string to move
	rep	movsb				;Build part of the path
	call	EXEC_Program
	ret

EXEC_ArgV endp

;****************************************************************************
; EXEC_Program
;****************************************************************************

Procedure EXEC_Program

	Set_Data_Segment
	mov	ExitStatus,No_Error	;Setup to Exec the file
	mov	dx,offset Exec_Path
	mov	bx,offset Exec_Block
	mov	al,0
	mov	word ptr SP_Save,sp	;save sp
	mov	word ptr SS_Save,ss	;save ss

	DOS_Call Exec

	cli				;turn off int's
	mov	sp,word ptr SP_Save	;retrieve sp
	mov	ss,word ptr SS_Save	;retrieve ss
	sti				;turn on int's


;	$IF	C			;CY means failure
	JNC $$IF19
	   mov	   ExitStatus,Error	;Set error code
;	$ENDIF
$$IF19:
	ret

EXEC_Program endp


;****************************************************************************
; EXEC_Routine
;****************************************************************************

Procedure EXEC_Routine

	Set_Data_Segment
	mov	ExitStatus,Error	;Assume the worst
	cld
	push	ds
	mov	ax,Exec_Block.Segment_Env ;Get the environment
	mov	ds,ax			;Get addressability
	assume	ds:nothing

	xor	si,si			;Start at beginning
;	$SEARCH
$$DO21:
	   cmp	   word ptr ds:[si],0	;End of the Evironment?
;	$EXITIF E			;Reached end, no more look
	JNE $$IF21

;	$ORELSE 			;Look for 'PATH=' in environment
	JMP SHORT $$SR21
$$IF21:
	   mov	   di,offset Path_String
	   mov	   cx,Len_Path_String
	   repe    cmpsb
;	$LEAVE	E			;Found if EQ
	JE $$EN21
;	$ENDLOOP			;Found PATH in environment
	JMP SHORT $$DO21
$$EN21:
	   call    Build_Path_And_Exec
;	$ENDSRCH
$$SR21:
	pop	ds
	ret

EXEC_Routine endp

;****************************************************************************
; Build_Path_For_EXEC
;****************************************************************************

Procedure Build_Path_And_Exec

$$DO27:
	cmp	byte ptr ds:[si],0	;All path entries done?

	JE	$$IF28
	mov	di,offset EXEC_Path	;Point at where to put path
	mov	byte ptr es:[di],0	;End path just in case

$$DO29:
	cmp	byte ptr ds:[si],0	;End of Path?

	JE	$$EN29
	cmp	 byte ptr ds:[si],';'	;End of entry?

	JNE	$$IF31
	inc	si			;point to next character
	jmp	EXIT_BPE_LOOP		;exit loop

$$IF31:
	movsb				;Put char in path string

	JMP SHORT $$DO29
$$EN29:

EXIT_BPE_LOOP:
					;Path filled in,get backslash
	cmp	byte ptr ds:[si-1],0	;Any path there?

	JE	$$IF34
					;Nope
	cmp	 byte ptr ds:[si-1],"\" ;Need a backslash?	     ;

	JE	$$IF35
	mov	byte ptr es:[di],"\"    ;Yes, put one in	     ;
	inc	di			;Line it up for next stuff
	inc	si

$$IF35:
	push	 si			;Save place in path
	push	 ds			;Save segment for environment
	push	 es			;Xchange ds/es
	pop	 ds
	mov	 si,offset FS_String_Buffer ;Fill in filename
	mov	 cx, Len_FS_String_Buffer
	rep	 movsb
	call	 Exec_Program
	cmp	 ExitStatus,No_Error	;E if EXEC okay
	pop	 ds			;Get Env segment back
	pop	 si			;Get place in path back

$$IF34:
$$IF28:

	JNE	$$DO27
	ret

Build_Path_And_EXEC Endp

;**************************************************************************
; Exec_Cur_Directory
;**************************************************************************

Procedure Exec_Cur_Directory

	Set_Data_Segment
	mov	si,offset FS_String_Buffer	;Setup path for current dir
	mov	di,offset EXEC_Path
	mov	cx,Len_FS_String_Buffer
	rep	movsb
	call	EXEC_Program
	ret

EXEC_Cur_Directory endp

;=========================================================================
; Set_FCB1_Drive	: This routine sets the 1st. byte of the FCB1,
;			  the drive identifier, to the default drive.
;=========================================================================

Procedure Set_FCB1_Drive		;set drive ID

	push	ds			;save ds
	push	si			;save si

	mov	si,PSP_Segment		;get segment of PSP
	mov	ds,si			;put it in ds
	assume	ds:PSP
	mov	si,FCB1 		;ptr to FCB1
	mov	byte ptr ds:[si],00h	;set drive ID to
					;      default drive
	pop	si			;restore si
	pop	ds			;restore ds
	Set_Data_Segment		;set up segmentation
	ret

Set_FCB1_Drive	endp

ENDIF		;FSExec 		;end /FS: conditional
					;assembly

;**************************************************************************

	public End_Program
End_Program label byte

;**************************************************************************

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\dskfrmt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 
; FILE: DSKFRMT.ASM
;
;===========================================================================

;===========================================================================
;Declaration of include files
;===========================================================================

debug	 equ	 0
	 .xlist
	 INCLUDE VERSION.INC
;	 INCLUDE VERSIONA.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
;	 INCLUDE DPB.INC
;	 INCLUDE CPMFCB.INC
;	 INCLUDE DIRENT.INC
;	 INCLUDE CURDIR.INC
;	 INCLUDE PDB.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 INCLUDE IOCTL.INC
	 INCLUDE FORSWTCH.INC
;	 INCLUDE SYSVAR.INC
	 .list

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Bytes
	EXTRN	fBigFat			:BYTE
	EXTRN	ExitStatus		:BYTE
	EXTRN	DblFlg			:BYTE
	EXTRN	Drive			:BYTE
	EXTRN	msgFormatFailure	:BYTE
	EXTRN	msgDiskUnusable 	:BYTE
	EXTRN	msgNotSystemDisk	:BYTE
	EXTRN	msgParametersNotSupported:BYTE
	EXTRN	msgParametersNotSupportedByDrive:BYTE
	EXTRN	msgHardDiskWarning	:BYTE
	EXTRN	msgInsertDisk		:BYTE
	EXTRN	msgCrLf			:BYTE
	EXTRN	msgCurrentTrack		:BYTE
	EXTRN	msgFormatComplete	:BYTE
	EXTRN	msgVerify		:BYTE
	EXTRN	ContinueMsg		:BYTE
	EXTRN	Extended_Error_Msg	:BYTE
	EXTRN	Clustbound_Flag 	:BYTE
	EXTRN	Fatal_Error		:BYTE

;Words
	EXTRN	FirstHead		:WORD
	EXTRN	FirstCylinder		:WORD
	EXTRN	TracksLeft		:DWORD	; M018
	EXTRN	TracksPerDisk		:DWORD	; M018
	EXTRN  	Formatted_Tracks_Low	:WORD
	EXTRN	Formatted_Tracks_High	:WORD
	EXTRN   Paras_Per_Fat		:WORD
	EXTRN	StartSector		:WORD
	EXTRN	SwitchMap		:WORD
	EXTRN	Relative_Sector_High	:WORD
	EXTRN	Relative_Sector_Low 	:WORD
	EXTRN	Clustbound_Buffer_Seg 	:WORD
	EXTRN	Clustbound_Adj_Factor	:WORD
	EXTRN	Clustbound_Spt_Count  	:WORD
	EXTRN	sector_in_buffer	:WORD
	EXTRN	sector_to_read		:WORD
	EXTRN	TotalClusters		:WORD

;Pointers
	EXTRN	SysSiz 			:DWORD
	EXTRN	BioSiz 			:DWORD
	EXTRN	Msg_Allocation_Unit_Val	:DWORD
	EXTRN	FatSpace	  	:DWORD
	EXTRN	FatSector		:DWORD

;Functions
	EXTRN	SetStartSector		:NEAR
	EXTRN	SetfBigFat		:NEAR
	EXTRN	Phase2Initialisation	:NEAR
;	EXTRN	More			:NEAR
	EXTRN	GetBioSize 		:NEAR
	EXTRN	GetDosSize 		:NEAR
	EXTRN	GetCmdSize 		:NEAR
	EXTRN	LastChanceToSaveIt 	:NEAR
	EXTRN	AccessDisk 		:NEAR
	EXTRN	Yes?  			:NEAR
	EXTRN	ExitProgram 		:NEAR
	EXTRN	User_String 		:NEAR
	EXTRN	Read_Disk		:NEAR
	EXTRN	Seg_Adj			:NEAR

;No more SAFE module
;	EXTRN	calc_sector_and_offset	:NEAR
;	EXTRN	ReadFatSector		:NEAR
;	EXTRN	GetFatSectorEntry	:NEAR
;	EXTRN	GetSetFatEntry		:NEAR


;Structures
	EXTRN	DeviceParameters	:BYTE
	EXTRN	FormatPacket		:BYTE
	EXTRN	Read_Write_Relative	:BYTE

;Constants
	EXTRN	EXIT_FATAL		:ABS
	EXTRN	EXIT_NO			:ABS
	EXTRN	EXIT_DRV_NOT_READY	:ABS
	EXTRN	EXIT_WRIT_PROTECT	:ABS
	EXTRN	EXIT_FATAL 		:ABS
	EXTRN	EXIT_NO			:ABS


;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

RWPacket		a_TrackReadWritePacket	<>

RW_TRF_Area		db	512	dup(0)
fLastChance		db	FALSE	; Flags reinvocation from
					; LastChanceToSaveIt. Used by DskPrm
FormatError		db	0
Format_End		db	FALSE
Track_Action		db	?	; Actual operation performed on disk

odd_entry		db	1	; flag for 12-bit FAT entry alignment

entry_offset		dw	?	; Offset of entry from start of sector

PercentComplete 	dw	0FFFFh	; Init non-zero so msg will display
					; first time
Fat_Init_Value		dw	0	; initializes the Fat
SysTrks 		dw	?
Sectors 		dw	?
CurrentHead		dw	0
CurrentCylinder		dw	0
Tracks_To_Format	dw	?
Track_Count		dw	?

CurrentCluster		dw	?	; holds the cluster currently being checked
					; in QuickFormat
BadClusValue		dw	?	; holds FAT entry value for bad cluster

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA

;===========================================================================
;EXTRNs needed in code segment
;===========================================================================

;Labels
;	EXTRN	SysLoop			:NEAR
	EXTRN	FatalExit		:NEAR
	EXTRN	CrLf			:NEAR

;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	Disk_Format_Proc
	PUBLIC	FrmtProb
	PUBLIC	fLastChance
	PUBLIC	CurrentHead
	PUBLIC	CurrentCylinder
	PUBLIC	Multiply_32_Bits
	PUBLIC	SetDeviceParameters
	PUBLIC	PercentComplete
	PUBLIC	Prompt_User_For_Disk

	PUBLIC	calc_sector_and_offset
	PUBLIC	ReadFatSector
	PUBLIC	GetSetFatEntry
	PUBLIC	GetFatSectorEntry
	PUBLIC	DetermineTrackAction
	PUBLIC	QuickFormat

;========================================================================
;
;  DISK_FORMAT_PROC : 	This procedure is used to call
;			the real DiskFormat procedure.
;  Returns :	NC --> Format successful
;		CY --> Format unsuccessful, go to next disk
;
;========================================================================

Disk_Format_Proc	proc	near

	call	DetermineTrackAction	; Check for safe format, and validity
					; of quick format switch
	push	ES

	call	Fat_Init		; initialize the Fat

	les	DI, FatSpace		; ES:DI --> FatSpace buffer
					; Store media descriptor byte
	mov	AL, DeviceParameters.DP_BPB.BPB_MediaDescriptor
	mov	AH, 0ffH
	stosw
	mov	AX, 00ffH
	test	fBigFat, TRUE
	jz	NotBig
	mov	AX, 0ffffH

NotBig:
	stosw
	pop	ES

	test	SwitchMap,SWITCH_Q	; Check for quick format
	jz	RegularFormat

	call	QuickFormat
	jc	FarExit			; procedure exit is too far for direct jump
	Message	msgFormatComplete
FarExit:
	jmp	Exit_Disk_Format_Proc

RegularFormat:
	call	DiskFormat		; Format the disk
	jnc	GetTrk			; check for problems

FrmtProb:

	test	SwitchMap,Switch_Select	; SELECT option?
	jnz	CheckForMore		; No - display message
	Message msgFormatFailure
	mov	ExitStatus, EXIT_FATAL

CheckForMore:
	stc				; Signal error which will be handled
					; in main routine (by prompting for
					; next disk)
	jmp	Exit_Disk_Format_Proc

		;Mark any bad Sectors in the Fats
		;And keep track of how	many bytes there are in	bad Sectors
GetTrk:
	call	BadSector		; Do bad track fix-up
	jc	FrmtProb		; Had an error in Fmt - can't recover
	CMP	AX,0			; Are we finished?
	jnz	TrkFnd			; No - check error conditions
	jmp	Exit_Disk_Format_Proc	; Yes

;--------------------------------------------------------------------------
; BUG NOTE:  The two sections in "if ibmcopyright..." here and	below are
;   to	correct	a bug.	If one of the Sectors just above the 32M boundary
;   were bad, it thought they were in the system area,	and hence that the
;   disk was unusable.
;
; PYS: IBMCOPYRIGHT removed
;
;--------------------------------------------------------------------------

TrkFnd:
						; Added IBM fix
	mov	BX,Relative_Sector_High		; get high word of the sector
	or	BX,BX				; is it	zero?
	jnz	ClrTest 			; if not, disk is usable

	mov	BX,WORD PTR Relative_Sector_Low ;get the low word of the sector
	cmp	BX,StartSector			; Any sec in the sys area bad?

	jae	ClrTest 			; MZ 2.26 unsigned compare
	Message msgDiskUnusable
	jmp	FrmtProb			; Bad disk -- try again

ClrTest:
	mov	Sectors,AX			; Save # sectors on the track
	test	SwitchMap,SWITCH_S		; If sys requested calc size
	jz	Bad100

	cmp	BYTE PTR DblFlg,0		; Is sys space aready calced?
	jnz	cmpTrks				; Yes - all ready for the compare
	inc	BYTE PTR DblFlg			; No -	set the	flag

	call	GetBioSize			; Get the size	of the Bios
	mov	DX,WORD PTR SysSiz+2
	mov	AX,WORD PTR SysSiz
	mov	WORD PTR BioSiz+2,DX
	mov	WORD PTR BioSiz,AX
	call	GETDOSSIZE
	call	GETCMDSIZE
	mov	DX,WORD PTR BioSiz+2
	mov	AX,WORD PTR BioSiz
	div	DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	AX,StartSector
	mov	SysTrks,AX			; Space Fat,Dir,and system
						; files require
cmpTrks:
						; Added IBM fix
	mov	BX, Relative_Sector_High	; get the high word of the sec
	or	BX, BX				; is it	zero?
	jnz	Bad100				; if not, DIsk is usable

	mov	BX,WORD PTR Relative_Sector_Low ;get the low word of the sector
	cmp	BX,SysTrks
	JA	Bad100				; MZ 2.26 unsigned compare
	mov	ExitStatus, EXIT_FATAL
	Message msgNotSystemDisk
	AND	SwitchMap,NOT SWITCH_S		; Turn off system transfer switch
	mov	WORD PTR SysSiz+2,0		; No system to transfer
	mov	WORD PTR SysSiz,0		; No system to transfer

Bad100:
	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK ;hard disk?
	jne	$$IF5				; yes
	call	Get_Bad_Sector_Hard		; see if a sector is bad
	jmp	SHORT $$EN5			;floppy disk

$$IF5:
	call	Get_Bad_Sector_Floppy		; mark entire track bad

$$EN5:
	jmp	GetTrk

Exit_Disk_Format_Proc:
	ret			

Disk_Format_Proc	ENDP

;==========================================================================
;
; DetermineTrackAction  :	This procedure sets the value of 
;				Track_Action based on the setting of
;				SWITCH_U, the unconditional format switch.
;				Track_Action is the function that is
;				actually performed on each track of the
;				disk to be formatted.
;
;  Inputs  :	SwitchMap
;  Output  :    SWITCH_U set   - Track_Action = Format and Verify
;		SWITCH_U clear - Track_Action = Verify only
;
;==========================================================================

DetermineTrackAction	proc	near

	test	SwitchMap,SWITCH_U
	jz	Verify_Only

Format_And_Verify:
	mov	Track_Action,FORMAT_TRACK		; regular format
	ret

Verify_Only:
	mov	Track_Action,VERIFY_TRACK	     	; safe format
	ret
DetermineTrackAction	endp

; =========================================================================
;    DiskFormat:
;	 Format	the tracks on the disk
;	 Since we do our SetDeviceParameters here, we also need	to
;	 detect	the legality of	/N /T if present and abort with	errors
;	 if not.
;	 This routine stops as soon as it encounters a bad track
;	 Then BadSector	is called to report the	bad track, and it continues
;	 the format
;
;    Algorithm:
;	 current track = first
;	 while not done
;	    if format track fails
;	       DiskFormatErrors	= true
;	       return
;	    next track
; =========================================================================

DiskFormat proc near
						; Initialise FatSpace

;	test	SwitchMap, SWITCH_C		; don't bother format if
;	jz	Keep_Going			; /c was given
;	jmp	FormatDone			; FormatDone is	to far away
;Keep_Going:

	mov	DeviceParameters.DP_SpecialFunctions, (INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD)
	lea	DX, DeviceParameters
	call	SetDeviceParameters
;	call	Cluster_Buffer_Allocate	; get room for retry buffer
;	call	Prompt_User_For_Disk
	test	SwitchMap,switch_8	; DCL 5/12/86 avoid Naples AH=18h
	jnz	stdBpB			; lackof support for 8 Secs/track

		; DCL 5/12/86 -	Always do the Status_FOR_FORMAT test, as we
		; don't know if the machine has this support.	For 3.2 /N:
		; & /T:	were not documented & therefore not fully supported
		; thru the ROM of Aquarius & Naples & Royal Palm


		;	test	SwitchMap, SWITCH_N or SWITCH_T ; IF (/N or /T)
		;	jz	StdBPB
		; THEN check if
		; supported

		; Check to see if device driver can handle specified parameters
	mov	FormatPacket.FP_SpecialFunctions, Status_FOR_FORMAT
	mov	AX, (IOCTL shl	8) or GENERIC_IOCTL
	mov	BL, Drive
	inc	BL
	mov	CX, (RAWIO shl	8) or FORMAT_TRACK
	lea	DX, FormatPacket
	int	21h

		;		switch ( FormatStatusCall)
		;	cmp	FormatPacket.FP_SpecialFunctions, \
		;		Format_No_ROM_Support
		;	jb	NTSupported	; 0 returned from IBMBIO
		;	ja	IllegalComb	; 2 returned - ROM Support
		;		Illegal Combination!

	cmp	FormatPacket.FP_SpecialFunctions,0 ; 0 --> Can support
	je	NTSupported
	cmp	FormatPacket.FP_SpecialFunctions,2 ; 2 --> Cannot support
	jne	$$IF28

	Message msgParametersNotSupportedByDrive
	mov	Fatal_Error,Yes			; Indicate quittin'type	err!
	jmp	SHORT $$EN28

$$IF28:
	cmp	FormatPacket.FP_SpecialFunctions,3 ; 3 --> No disk in drive
	jne	$$IF30
	mov	AX,Error_Not_Ready		; flag not ready
	call	CheckError			; set error level
	jmp	FrmtProb			; exit	program
	jmp	SHORT $$EN30			; DCL No ROM support is okay

$$IF30:
						; except for /N: & /T:
	test	SwitchMap, SWITCH_N or SWITCH_T ; DCL 5/12/86
	jz	$$IF32
	Message msgParametersNotSupported
	mov	Fatal_Error,Yes			; Indicate quittin 'type err!

$$IF32:
$$EN30:
$$EN28:
	cmp	Fatal_Error,Yes
	jne	StdBPB
	jmp	FatalExit
						; We have the support to carry
						; out the FORMAT
NTSupported:
StdBPB:
	mov	FormatPacket.FP_SpecialFunctions, 0
	mov	AX, FirstHead
	mov	FormatPacket.FP_Head, AX
	mov	AX, FirstCylinder
	mov	FormatPacket.FP_Cylinder, AX

;M018 - begin
	mov	AX, word ptr TracksPerDisk
	mov	word ptr TracksLeft, AX
	mov	AX, word ptr TracksPerDisk+2
	mov	word ptr TracksLeft+2, AX
;M018 - end

	mov	Format_End,False		; flag not at end of format
	call	Calc_MAX_Tracks_To_Format	; Max track count for
						; FormatTrack call
FormatLoop:
	call	Format_Loop			; Format until CY occurs
	cmp	Format_End,True			; End of Format?
	jne	$$IF36
	mov	FormatError,0			; signal good format
	clc					; clear CY
	jmp	SHORT $$EN36			; bad format

$$IF36:
	call	CheckError			; determine type of error
	jc	$$IF38
	call	LastChanceToSaveIt		; acceptable error?
	jnc	$$IF39				; yes
	mov	FormatError,1			; signal error type
	clc					; clear CY
	jmp	SHORT $$EN39			; not acceptable error

$$IF39:
	call	SetStartSector			; start from scratch
	call	SetfBigFat
	push	AX
	call	Phase2Initialisation
	clc
	pop	AX
	jmp	DiskFormat			; try again

$$EN39:
$$IF38:
$$EN36:
	return

FormatDone:
	mov	FormatError,0
	clc
	return

DiskFormat endp

;=========================================================================
; Fat_INIT:		 This routine initializes the Fat based	on the
;			 number	of paragraphs.
;
; input -  FatSpace
;	   FatSpace+2
;	   paras_per_Fat
;	   Fat_init_value
; output - Fat	space is initialized
;
; Assumes:	DS:DATA
;
;=========================================================================
	PUBLIC Fat_Init
Fat_Init PROC NEAR

	push	ES
	push	DI
	push	AX
	push	BX
	push	CX

	mov	DI, WORD PTR FatSpace+2	; Get segment of Fat space
	mov	ES,DI
	mov	DI, WORD PTR FatSpace
	mov	BX,Paras_Per_Fat	; Get number of paras
	mov	AX,Fat_init_value
	push	DX
	mov	DX,ES			; Grab ES into DX

$$DO87:
	cmp	BX,0			; do while BX not = 0
	je	$$EN87			; exit if 0
	mov	CX,10h			; Word move of paragraph
	rep	stosb			; Move the data to Fat
	xor	DI,DI			; Offset always init to 0
	inc	DX			; Next paragraph
	mov	ES,DX			; Put next para in ES
	dec	BX			; Loop iteration counter
	jmp	SHORT $$DO87

$$EN87:
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	pop	DI
	pop	ES

	ret

Fat_Init ENDP

;=========================================================================
;   SetDeviceParameters:
;	Set the	device parameters
;
;   Input:
;	Drive
;	DS:DX - pointer to device parameters
;=========================================================================

SetDeviceParameters proc near

	 mov	 AX, (IOCTL shl	8) or GENERIC_IOCTL
	 mov	 bl, Drive
	 inc	 bl
	 mov	 CX, (RAWIO shl	8) or SET_DEVICE_PARAMETERS
	 int	 21H
	 return

SetDeviceParameters endp


;=========================================================================
; Prompt_User_For_Disk		 : This	routine	prompts	the user for the
;				   disk	to be formatted.  An appropriate
;				   message is chosen based on the type
;				   of switch entered.  If the /SELECT
;				   switch is entered, the disk prompt is
;				   issued through the int 2fh services
;				   provided by SELECT.
;
;	 Inputs	 : SwitchMap	 - Switches chosen for format
;
;	 Outputs : Message printed as appropriate.
;=========================================================================

Procedure Prompt_User_For_Disk

	push	AX
	test	SwitchMap, (SWITCH_Backup or SWITCH_Select or SWITCH_AUTOTEST)
	jnz	$$IF186
	call    DskPrm				; prompt user for disk

$$IF186:
	 test	SwitchMap, (Switch_Select)	; /SELECT requested?
	 jz	$$IF188
	 mov	AL, Drive			; get drv to access for format
	 call	AccessDisk			; access the disk
	 mov	AX,Select_Disk_Message		; display disk prompt
	 int	2fh				; through int 2fh services

$$IF188:
	 pop	 AX
	 ret
Prompt_User_For_Disk	 ENDP

;==========================================================================
; DiskPrompt:
;
; This routine prompts for the insertion of the correct diskette
; into the Target Drive, UNLESS we are being re-entrantly invoked
; from LastChanceToSaveIt. If the target is a Hardisk we issue a
; warning message.
;
;	 INPUTS:
;		 DeviceParameters.DP_DeviceType
;		 fLastChance
;
;	 OUTPUTS:
;		 Prompt	string
;		 fLastChance	 := FALSE
;
;	 Registers affected:
;				 Flags
;
;==========================================================================

DskPrm PROC NEAR

	cmp	fLastChance,TRUE
	je	PrmptRet

	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK
	jne	GoPrnIt
	Message	msgHardDiskWarning
	call	Yes?

	pushf
	Message	msgCrlf
	popf

	jnc	OkToFormatHardDisk
	mov	ExitStatus, EXIT_NO
	jmp	ExitProgram

OkToFormatHardDisk:
	call	CrLf
	call	CrLf
	return

GoPrnIt:
	mov	AL, Drive
	call	AccessDisk
	Message msgInsertDisk
	Message ContinueMsg
	call	USER_STRING			; Wait for any key
	call	CrLf
	call	CrLf

PrmptRet:
	mov	fLastChance, FALSE
	ret

DskPrm	ENDP

;=========================================================================
;    CheckError:
;	 Input:
;	    AX - extended error	code
;	 Ouput:
;	    carry set if error is Fatal
;	    Message printed if Not Ready or Write Protect
;=========================================================================

CheckError proc near
	cmp	AX, error_write_protect
	je	WriteProtectError
	cmp	AX, error_not_ready
	je	NotReadyError
	cmp	CurrentCylinder, 0
	jne	CheckRealErrors
	cmp	CurrentHead, 0
	je	BadTrackZero

CheckRealErrors:
	cmp	AX, error_CRC
	je	JustABadTrack
	cmp	AX, error_sector_not_found
	je	JustABadTrack
	cmp	AX, error_write_fault
	je	JustABadTrack
	cmp	AX, error_read_fault
	je	JustABadTrack
	cmp	AX, error_gen_failure
	je	JustABadTrack

	stc
	ret

JustABadTrack:
	clc
	ret

WriteProtectError:
	test	SwitchMap,Switch_SELECT	; SELECT option?
	jnz	$$IF56				; no - display messages

	Message msgCrLf
	Message msgCrLf
	Extended_Message
	jmp	SHORT $$EN56			; yes - set error level

$$IF56:
	mov	ExitStatus,EXIT_WRIT_PROTECT	; signal write protect error

$$EN56:
	 stc					; signal Fatal error
	 ret					; return to caller

NotReadyError:
	test	SwitchMap,Switch_SELECT		; SELECT option?
	jnz	$$IF59				; no - display messages

	Message msgCrLf
	Message msgCrLf
	Extended_Message
	jmp	SHORT $$EN59			; yes - set error level

$$IF59:
	mov	ExitStatus,EXIT_DRV_NOT_READY	;signal Drive not ready

$$EN59:
	stc
	ret

BadTrackZero:
	Message msgDiskUnusable
	stc
	ret

CheckError endp

;=========================================================================
;
; Calc_MAX_Tracks_To_Format	 : This	routine	determines the maximum
;				   number of tracks to format at 1 time.
;
;	 Inputs	 : DeviceParameters - SectorsPerTrack
;				      BytesPerSector
;
;	 Outputs : Track_Count	    - MAX. # of	tracks to format in 1 call
;				      to FormatTrack
;=========================================================================

Procedure Calc_Max_Tracks_To_Format

	push	AX				; Save regs
	push	BX
	push	DX

	mov	AX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	mov	BX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	xor	DX,DX
	mul	BX				; Get total byte count
	mov	BX,AX				; Put count in BX
	mov	AX,MAX_Format_Size		; Max bytes to format
	div	BX				; Get track count
	mov	Track_Count,AX

	pop	DX
	pop	BX
	pop	AX

	ret

Calc_Max_Tracks_To_Format ENDP

;=========================================================================
; Format_Loop			 : This	routine	provides the main template
;				   for the formatting of a disk.  A disk
;				   will	be formatted as	long as	there are
;				   tracks remaining to be formatted.
;				   This	routine	can be exited on a carry
;				   condition; i.e., bad	track, last track, etc.
;
;	 Inputs	 : none
;
;	 Outputs : CY -	Set on exit from this routine
;		   AX -	Possible error condition code
;
;=========================================================================

Procedure Format_Loop

	clc					; Initialize to NC

$$DO173:					; While NC
	jc	$$EN173			   	; Exit on CY
	call	Calc_Current_Head_Cyl		; Head and cylinder calc.
	call	Determine_Format_Type		; Floppy/hard media?
	call	Determine_Track_Count		; How many tracks?
	call	FormatTrack			; Format track(s)
	jnc	$$IF175				; Formattrack failed

	pushf					; Save flags
	cmp	DeviceParameters.DP_DeviceType,Dev_HardDisk ; Harddisk?
	jne	$$IF176

	popf					; Restore flags
	call	Format_Track_Retry		; Find failing track
	jmp	SHORT $$EN176

$$IF176:
	popf					; Restore flags

$$EN176:
$$IF175:
	jnc	$$IF180				; Format error?
	pushf					; Yes - save flags
	push	AX				; Save return code
	call	CheckRealErrors 		; Check error type
	jc	$$IF181				; If non-Fatal
	call	DisplayCurrentTrack		; Display % formatted

$$IF181:
	pop	AX				; Restore regs
	popf

$$IF180:
	jc	$$EN173				; Exit on CY

	call	DisplayCurrentTrack		; Tell how much formatted
	call	Adj_Track_Count 		; Decrease track counter
	call	NextTrack			; Adjust head and cylinder
	jmp	SHORT $$DO173

$$EN173:
	ret

Format_Loop ENDP

;=========================================================================
; Calc_Current_Head_Cyl : Obtain the current head and cylinder	of the
;			   track being formatted.
;
;	 Inputs: FP_Cylinder	 - Cylinder of track being formatted
;		 FP_Head	 - Head	of track being formatted
;=========================================================================

Procedure Calc_Current_Head_Cyl

	push	CX				; save CX
	mov	CX,FormatPacket.FP_Cylinder	; get current cylinder
	mov	CurrentCylinder,CX		; put into variable
	mov	CX,FormatPacket.FP_Head		; get current head
	mov	CurrentHead,CX			; put into variable
	pop	CX				; restore CX
	ret

Calc_Current_Head_Cyl	 endp

; =========================================================================
; Determine_Format_Type :  This	routine	determines the type of format
;			   that	is to occur based on the media type.
;
;	 Inputs	  : Dev_HardDisk		 - Media type (harddisk)
;		    Multi_Track_Format	 - EQU 02h
;		    Single_Track_Format	 - EQU 00h
;
;	 Outputs  : FP_SpecialFunctions	 - Set appropriately for single
;					   or multi track format
; =========================================================================

Procedure Determine_Format_Type

	cmp	 DeviceParameters.DP_DeviceType,Dev_HardDisk	;harddisk?
	jne	 $$IF158
					; Set for multi track format
	mov	 FormatPacket.FP_SpecialFunctions,Multi_Track_Format
	jmp	 SHORT $$EN158

$$IF158:				; Set for single track format
	mov	 FormatPacket.FP_SpecialFunctions,Single_Track_Format

$$EN158:
	ret

Determine_Format_Type ENDP

;=========================================================================
;
; Determine_Track_Count	 : This	routine	determines the number of
;				   tracks to be	formatted, based on whether
;				   or not we have a hard disk.	If we have
;				   a hard disk we can use multi-track
;				   format/verify, otherwise we use the
;				   single track	format/verify.
;
;	 Inputs	 : Device_Type			 - Media type
;
;	 Outputs : Tracks_To_Format		 - MAX.	number of tracks
;						   to be formatted in one
;						   call
;=========================================================================

Procedure Determine_Track_Count

						; Harddisk?
	cmp	DeviceParameters.DP_DeviceType,Dev_HardDisk
	jne	$$IF163
	call	Calc_Track_Count		; Calc Tracks_To_Format
	jmp	SHORT $$EN163			; Removable media

$$IF163:
	mov	Tracks_To_Format,0001h		; Default to 1 track
;	$endif
$$EN163:

	ret

Determine_Track_Count ENDP

;=========================================================================
;
; Calc_Track_Count	 : This	routine	determines if we have enough tracks
;			   remaining to	use the	Max. number of tracks
;			   in the FormatTrack call.  If	the tracks remaining
;			   to be formatted is less that	the mAX. number	of
;			   allowable tracks for	the call, the mAX. number
;			   of allowable	tracks is set to the remaining track
;			   count.
;
;	 Inputs	 : Track_Count - MAX. number of	allowable tracks to be
;				 formatted in 1	FormatTrack call.
;		   TracksLeft  - Track count of	remaining tracks to be
;				 formatted.
;
;	 Outputs : Tracks_To_Format - Count of the tracks to be	formatted
;				      in the next FormatTrack call.
;
;=========================================================================

Procedure Calc_Track_Count

	push	AX				; Save regs

	mov	AX,Track_Count			; Max bytes to format

	cmp	word ptr TracksLeft+2,0		; M018; More than 64K of tracks?
	jnz	$$IF166				; M018; Then surely use Track_Count

	cmp	AX,word ptr TracksLeft		; M018; Too many tracks?
	JNA	$$IF166
	mov	AX,word ptr TracksLeft		; M018; Format remaining tracks

$$IF166:
	mov	Tracks_To_Format,AX		; Save track count
	pop	AX
	ret

Calc_Track_Count ENDP

;=========================================================================
; FormatTrack		 : This	routine	performs multi track or	single
;			   track formatting based on the state of the
;			   SpecialFunctions byte.
;
;	 Inputs	 : Tracks_To_Format	 - # of	tracks to format in 1 call
;		   FormatPacket		 - Parms for IOCTL call
;
;	 Outputs : NC			 - formatted track(s)
;		   CY			 - error in format
;		   AX			 - extended error on CY
;
;=========================================================================


Procedure FormatTrack

	mov	AX,(IOCTL shl 8) or Generic_IOCTL
	mov	BL,Drive			; Get Drive number
	inc	BL				; Make it 1 based
	mov	CX,(RawIO shl 8) 
	or 	CL,Track_Action 		; Track_Action is either
						; Format and Verify, or
						; Verify only
	mov	DX,Tracks_To_Format		; Get track count
	mov	FormatPacket.FP_TrackCount,DX	; Put count in parms list
	lea	DX,FormatPacket 		; Ptr to parms

;***
;***
;***	test	IsReal,0ffh
;***	jnz	DoRealInt21
;***
;***	xor	AX,AX
;***	clc
;***	jmp	SHORT  FormatTrackExit
;***
;***DoRealInt21:
;***
;***

	int	21h

	jnc	FormatTrackExit			; Error?
	mov	AH,59h				; Get extended error
	xor	BX,BX				; Clear BX
	int	21h

	cmp	AX,67				; Induced error from ENHDISK?
	jne	notInducedError
	clc
	ret
notInducedError:
	stc					; Flag an error

FormatTrackExit:
	ret

FormatTrack ENDP

;=========================================================================
;
; Format_Track_Retry	 : This	routine	performs the retry logic for
;			   the format multi-track.  It will retry each track
;			   until the failing track is encountered through
;			   a CY	condition.
;
;	 Inputs	 : none
;
;	 Outputs : CY -	indicates either a failing track or end	of format
;
;
;=========================================================================

Procedure Format_Track_Retry

	clc					; Clear existing CY
	mov	Tracks_To_Format,1		; Only format 1 track

$$DO168:					; While we have good tracks
	jc	$$EN168 			; Exit on bad track

	call	FormatTrack			; Format the track
	jc	$$IF170 			; Error?

	call	DisplayCurrentTrack		; Adjust percent counter
	call	Adj_Track_Count
	call	NextTrack			; Calc next track

$$IF170:
	jmp	SHORT $$DO168

$$EN168:
	ret

Format_Track_Retry ENDP

;=========================================================================
;
;  DisplayCurrentTrack :	This procedure prints the percentage of disk
;				formatted so far.
;				If /select is present, format can be exited
;				by returning AX!=0 from the int 2fh call, which
;				is handled by install.  This is to permit the
;				user to stop the format in progress.
;
;===========================================================================

DisplayCurrentTrack proc near

	push	DX
	push	CX
	push	AX

	push	DI		; M018
	push	SI		; M018

	mov	AX,Tracks_To_Format	 	;get track count

	add	Formatted_Tracks_Low,AX		;Indicate formatted a track
	adc	Formatted_Tracks_High,0
	mov	AX,Formatted_Tracks_Low
	mov	BX,Formatted_Tracks_High
	mov	CX,100				;Make integer calc for	div
	call	Multiply_32_Bits		; BX:AX = (Cyl	* Head *100)
	mov	DX,BX				;Set up divide
;M018	div	TracksPerDisk			;% = (Cyl * Head *100)/ # tracks
;M018 - begin
; DX:AX: 100*head*cylinder (should not be bigger than a DWORD)
; DI:SI: heads*cylinder 
; We need to assure a word division
	mov 	DI,word ptr TracksPerDisk+2
	mov	SI,word ptr TracksPerDisk
SetUpDivide:
	or	DI,DI
	jz	DivideOK
	shr	DI,1				; shift DI:SI 1 bit right
	rcr	SI,1
	shr	DX,1				; shift DX:AX 1	bit right
	rcr	AX,1
	jmp	short SetUpDivide
DivideOk:
	div	SI	
;M018 - end

	cmp	AX,PercentComplete		;Only print message when change
	je	ScreenUpdateDone

		; johnhe 02-27-90
		; Change added here for DOS 5.0 install program to do a
		; special interrupt to display the percent complete on
		; a gage. AX == special code, BX == percent complete

	test	SwitchMap,Switch_Select		; Was format spawned by the
	jz	NormalDisplay			; install program?
	mov	BX,AX				; BX == percent completed
	mov	AX,GAGE_UPDATE			; AX == special function code
	clc
	int	2fh				; Multiplex interrupt
	or	AX,AX				; AX <> 0 --> user wants to exit
	jz	ScreenUpdateDone
	jmp	FatalExit

		; End of code added for DOS 5.0 install program

NormalDisplay:
	mov	PercentComplete,AX		; Save it if changed
	Message msgCurrentTrack

ScreenUpdateDone:
	pop	SI				; M018
	pop	DI				; M018
	
	pop	AX
	pop	CX				; Restore register
	pop	DX
	return

DisplayCurrentTrack endp

;=========================================================================
; Adj_Track_Count	 : This	routine	adjusts	the track count	by the
;			   number of tracks that have been formatted
;			   in one FormatTrack call.
;
;	 Inputs	 : TracksLeft	 - # of	tracks remaining to be formatted
;		   Tracks_To_Format - Tracks formatted in 1 call
;
;	 Outputs : TracksLeft	 - # of	tracks remaining to be formatted
;=========================================================================

Procedure Adj_Track_Count

	push	AX			; save regs
	push	DX			; M018

;M018	mov	AX,TracksLeft		; get tracks remaining
;M018	sub	AX,Tracks_To_Format	; subtract amount formatted
;M018	mov	TracksLeft,AX		; save new tracks remaining value

;M018 - begin
	mov	DX,word ptr TracksLeft+2; get tracks remaining
	mov	AX,word ptr TracksLeft

	sub	AX,Tracks_To_Format	; subtract amount formatted
	sbb	DX,0

	mov	word ptr TracksLeft,AX	; save new tracks remaining value
	mov	word ptr TracksLeft+2,DX
;M018 - end
	
	pop	DX			; M018
	pop	AX			; restore regs
	ret

Adj_Track_Count endp

;=========================================================================
;
; NextTrack	 : This	routine	determines the next track to be
;		   formatted.
;
;	 Inputs	 : TracksLeft		 - # of	tracks remaining
;		   Tracks_To_Format	 - # of	tracks to format in 1 call
;		   FP_Head		 - disk	head
;		   FP_Cylinder		 - disk	cylinder
;
;	 Outputs : TracksLeft		 - # of	tracks remaining
;		   FP_Head		 - disk	head
;		   FP_Cylinder		 - disk	cylinder
;		   CY			 - no tracks left to format
;		   NC			 - tracks left to format
;
;=========================================================================

Procedure NextTrack


;M018	cmp	TracksLeft,00			; End of format?
;M018 - begin
	mov	CX,word ptr TracksLeft+2
	or	CX,Word ptr TracksLeft
;M018 - end
	jne	$$IF149 			; Yes

	stc					; Signal end of format
	mov	Format_End,True
	jmp	SHORT $$EN149

$$IF149:
	mov	CX,Tracks_To_Format		; Get mAX track count for call

$$DO151:					; While tracks remain
;M018: I don't get the next two lines. We are already sure TrackLeft<>0
;M018	cmp	TracksLeft,00			; End of format?
;M018	je	$$EN151 			; Yes

	cmp	CX,00				; End of head/cyl. adjustment?
	je	$$EN151 			; Yes

	inc	FormatPacket.FP_Head		; Next head
	mov	AX,FormatPacket.FP_Head 	; Get head for comp
	cmp	AX,DeviceParameters.DP_BPB.BPB_Heads ; Exceeded head count?
	jne	$$IF154 			; Yes

	mov	FormatPacket.FP_Head,00 	; Reinit. head
	inc	FormatPacket.FP_Cylinder	; Next cylinder

$$IF154:
	dec	CX				; Decrease counter
	jmp	SHORT $$DO151

$$EN151:
	clc					; Clear CY

$$EN149:
	ret

NextTrack ENDP

;=========================================================================
;	CurrentLogicalSector:
;	 Get the current logical sector	number
;
;    Input:
;	 current track = TracksPerDisk - TracksLeft
;	 SectorsPerTrack
;
;    Output:
;	 BX = logical sector number of the first sector	in the track we
;	      just tried to format
;=========================================================================

CurrentLogicalSector PROC NEAR

	push	AX				; Save regs
	push	BX
	push	DX

;M018	mov	AX, TracksPerDisk
;M018	sub	AX, TracksLeft
;M018	xor	DX,DX				; Clear DX
;M018 - begin
	mov	DX, word ptr TracksPerDisk+2
	mov	AX, word ptr TracksPerDisk
	sub	AX, word ptr TracksLeft
	sbb	DX, word ptr TracksLeft+2
;M018 - end
	mul	DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	mov	WORD PTR Relative_Sector_High,DX ; Save high word of sector #
	mov	WORD PTR Relative_Sector_Low,AX ; Save low word of sector #

	pop	DX				; Restore regs
	pop	BX
	pop	AX

	return

CurrentLogicalSector ENDP

;=========================================================================
;
;    BadSector:
;	 Reports the bad Sectors.
;	 Reports the track where DiskFormat stopped.
;	 From then on it formats until it reaches a bad	track, or end,
;	 and reports that.
;
;    Output:
;	 Carry:	set -->	Fatal error
;	 if Carry not set
;	    AX - The number of consecutive bad Sectors encountered
;		 AX == 0 --> no	More bad Sectors
;	    BX - The logical sector number of the first	bad sector
;
;    Algorithm:
;	 if DiskFormatErrors
;	    DiskFormatErrors = false
;	    return current track
;	 else
;	    next track
;	    while not done
;	       if format track fails
;		  return current track
;	       next track
;	    return 0
;=========================================================================

BadSector proc	 near
						; Don't bother to do the format
						; /c was given
;	test	SwitchMap, SWITCH_C
;	jnz	NoMoreTracks

	test	FormatError, 0ffH
	jz	ContinueFormat

	mov	FormatError, 0
	jmp	SHORT ReportBadTrack

ContinueFormat:
	call	Adj_Track_Count 		; Decrease track counter
	call	NextTrack			; Adjust head and cylinder
	cmp	Format_End,True 		; End of format?
	je	$$IF44				; No

	call	Format_Loop			; Format until CY
	cmp	Format_End,True 		; End of format?
	je	$$IF45				; No

	call	CheckError			; Must be error - which error?
	jc	$$IF46				; Non-Fatal error?

	call	CurrentLogicalSector		; Yes - get position
						; set tracksize
	mov	AX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	clc					; Signal O.K. to continue

$$IF46:
	jmp	SHORT $$EN45
$$IF45:
	jmp	SHORT NoMoreTracks		  ;End of format
$$EN45:
	jmp	SHORT $$EN44
$$IF44:
	jmp	SHORT NoMoreTracks		; end of format
$$EN44:
	return

ReportBadTrack:
	call	CurrentLogicalSector
	mov	AX, DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	clc
	return

NoMoreTracks:					; Don't display done msg
	test	SwitchMap,(Switch_Select or SWITCH_AUTOtest)
	jnz	$$IF52				; if EXEC'd by SELECT
	Message msgFormatComplete

$$IF52:
	mov	AX, 0
	clc
	return

BadSector endp

;=========================================================================
; Get_Bad_Sector_Hard	 : Determine the bad sector.
;
;	 Inputs	 :
;		Head of failing track
;		Cylinder of failing track
;		Relative_Sector_Low	- 1st. sector in track
;		Relative_Sector_High
;
;		ClustBound_Adj_Factor	- The number of Sectors
;					  that	are to be read
;					  at one time.
;		ClustBound_SPT_Count	- Used by Calc_Cluster_Boundary
;					  to track how	many Sectors
;					  have been read.
;		ClustBound_Flag	 	- True (Use cluster buffer)
;					- False (Use internal buffer)
;		ClustBound_Buffer_Seg	- Segment of buffer
;
;	 Outputs : Marked cluster as bad
;=========================================================================

	PUBLIC Get_Bad_Sector_Hard
Procedure Get_Bad_Sector_Hard

	push	CX				; Save CX
	mov	CX,0001h			; Set counter to start at 1
	mov	ClustBound_SPT_Count,00h	; Clear sector counter
	mov	ClustBound_Adj_Factor,01h	; Default value

						; DO WHILE Sectors left
$$DO115:					
	cmp	CX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack	;At end?
	ja	$$EN115 			; Yes,exit
	push	CX				; Save CX

	cmp	ClustBound_Flag,True		; Full buffer there?
	jne	$$IF117 			; Yes
	call	Calc_ClustBound_		; See if on boundary
	mov	AX,ClustBound_Buffer_Seg
						; Point to transfer area
	mov	WORD PTR RWPacket.TRWP_Transferaddress[0],0
	mov	WORD PTR RWPacket.TRWP_Transferaddress[2],AX
	jmp	SHORT $$EN117			; Default to  internal buffer

$$IF117:					; Point to transfer area
	mov	WORD PTR RWPacket.TRWP_Transferaddress[0],offset RW_TRF_Area
	mov	WORD PTR RWPacket.TRWP_Transferaddress[2],DS

$$EN117:
	call	Verify_Structure_Set_Up 	; Set up verify vars
	mov	AX,(IOCTL shl 8) or GENERIC_IOCTL
	xor	BX,BX				; Clear BX
	mov	BL,Drive			; Get Drive
	inc	BL				; Adjust it

;	mov	CX,(IOC_DC shl	8) or VERIFY_TRACK
	mov	CX,(IOC_DC shl	8) or READ_TRACK ; BUG BUG BUG
						; Buffer is only cluster size

	lea	DX,RWPacket			; Point to parms
	int	21h

	pop	CX				; Restore CX
	push	CX				; Save CX

	jnc	$$IF120 			; An error occurred
	call	Calc_Cluster_Position		; Determine which cluster
	call	BadClus 			; Mark the cluster as bad

$$IF120:
	pop	CX
	add	CX,ClustBound_Adj_Factor	; Adjust loop counter
	mov	AX,ClustBound_Adj_Factor	; Get adjustment factor
	xor	DX,DX
	add	AX,Relative_Sector_Low		; Add in low word
	adc	DX,Relative_Sector_High 	; Pick up carry in high word
	mov	Relative_Sector_Low,AX		; Save low word
	mov	Relative_Sector_High,DX 	; Save high word
	jmp	SHORT $$DO115

$$EN115:
	pop	CX
	ret

Get_Bad_Sector_Hard ENDP

;=========================================================================
; Get_Bad_Sector_Floppy : This	routine	marks an entire	track as bad
;			   since it is a floppy	disk.
;
;	 Inputs	 : Relative_Sector_Low	 - first sector
;
;	 Outputs : Fat marked with bad Sectors
;=========================================================================

Procedure Get_Bad_Sector_Floppy

	push	BX				; Save regs
	push	CX
						; Get Sectors/track
	mov	CX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack

$$DO123:					; While Sectors left
	cmp	CX,00				; At end
	je	$$EN123 			; Yes

	push	BX				; Save BX we destroy it
	push	CX				; Save CX we destroy it
	call	Calc_Cluster_Position		; Get cluster position
	call	BadClus 			; Mark it as bad
	pop	CX				; Restore regs
	pop	BX
	dec	CX				; Decrease loop counter
	inc	Relative_Sector_Low		; Next sector
	jmp	SHORT $$DO123

$$EN123:
	pop	CX				; Restore regs
	pop	BX
	ret

Get_Bad_Sector_Floppy ENDP

;=========================================================================
;
;   Inputs:	BX = Cluster number
;   Outputs:	The given cluster is marked as	invalid
;		Zero flag is set if the cluster was already marked bad
;
;   Registers modified: DX
;			SI
;
; BADCLUS	 :	 Marks off a bad cluster in the	Fat
;			 If a cluster has already been marked bad it
;			 will return with ZR.
;
;	 Inputs	 :	 DX:AX - Cluster Number
;
;	 Outputs :	 Cluster is marked invalid
;			 ZR set	if cluster already marked bad
;
;=========================================================================

BadClus	 proc		 near		; mark bad clusters

	push	DI			; save affected regs
	push	AX
	push	BX
	push	CX
	push	DX
	push	ES

	mov	ES, WORD PTR FatSpace + 2 ; obtain seg of Fat
	cmp	fBigFat,TRUE		; 16 bit Fat?
	je	$$IF8			; no - 12-bit Fat

	push	AX			; saves low cluster number
	mov	SI,DX			; pick up high word of cluster
	mov	DI,AX			; pick up low word of cluster
	mov	CX,2			; divide by 2
	call	divide_32_Bits		; 32 bit divide

	add	AX,DI			; add in low word of result
	adc	DX,SI			; pick up low word carry
					; cluster = cluster * 1.5
	add	AX,WORD PTR FatSpace	; add 0
	adc	DX,0			; pick up carry

	mov	BX,DX			; get high word for adjust
	mov	CX,ES			; place seg in AX
	call	BadClus_address_Adjust	; adjust segment offset
	mov	ES,CX			; new segment
	mov	SI,AX			; new offset

	mov	DX,0ff7h		; bad cluster flag
	mov	AX,0fffh		; mask value

	pop	CX			; restore AX in CX - low cluster #
	test	CX,1			; is old clus num odd?
	jz	$$IF9			; yes

	mov	CL,4			; set shift count
	shl	AX,CL			; get only 12 bits - fff0
	mov	CL,4			; set shift count
	shl	DX,CL			; get 12 bits - ff70

$$IF9:
	jmp	SHORT $$EN8		; 16-bit Fats here

$$IF8:
	xor	SI,SI			; clear si
	mov	BX,DX			; get high word for multiply
	mov	CX,2			; multiply by 2
	call	Multiply_32_Bits	; 32 bit multiply due to 2 bytes per
					; Fat cell. This gives us an offset
					; into the FAT

	mov	CX,ES			; place seg in CX
	call	BadClus_Address_Adjust	; adjust segment:offset
	mov	ES,CX			; new segment
	mov	SI,AX			; new offset

	mov	DX,0fff7h		; bad cluster value
	mov	AX,0ffffh		; mask value

$$EN8:
	mov	CX,ES:[SI]		; get contents of Fat cell
	and	CX,AX			; make it 12 or 16 bit
					; depending on value in AX
	not	AX			; set AX to 0

	and	ES:[SI],AX		; clear Fat entry

	or	ES:[SI],DX		; flag it a bad cluster
	cmp	DX,CX			; return op == badval;

	pop	ES
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	pop	DI
	return

badclus	endp

;=========================================================================
; Verify_Structure_Set_Up	 : Set up the fields for the Read IOCTL
;				   to verify the Sectors in a failing
;				   track.  Also, it displays the
;				   message notifying the user of the
;				   Sectors it is verifying.
;=========================================================================

Procedure	 Verify_Structure_Set_Up		; Set up verify structure

	mov	RWPacket.TRWP_SpecialFunctions,00h	; Reset special functions

	mov	AX,FormatPacket.FP_Head 		; Get current head
	mov	RWPacket.TRWP_Head,AX			; Get current head

	mov	AX,FormatPacket.FP_Cylinder		; Get current cylinder
	mov	RWPacket.TRWP_Cylinder,AX		; Get current cylinder

	dec	CX					; Make sector 0 based
	mov	RWPacket.TRWP_FirstSector,CX		; Get sector	to read

	mov	AX,ClustBound_Adj_Factor		; Get # of Sectors to read
	mov	RWPacket.TRWP_SectorsToReadWrite,AX	; Read only # sector(s)

	call	Calc_Cluster_Position			; Determine cluster number
	mov	WORD PTR Msg_Allocation_Unit_Val[+2],DX ; Save high word of cluster
	mov	WORD PTR Msg_Allocation_Unit_Val[+0],AX ; Save low word of cluster
	message MsgVerify

	ret

Verify_Structure_Set_Up ENDP

;=========================================================================
; Calc_Cluster_Position : This	routine	calculates which cluster the
;			   failing sector falls	in.
;
;	 Inputs	 : Relative_Sector_High	 - high	word of	sector position
;		   Relative_Sector_Low	 - low word of sector position
;
;	 Outputs : DX:AX - Cluster position
;=========================================================================

Procedure Calc_Cluster_Position

	push	CX				; Save regs
	push	DI
	push	SI

	mov	DX,WORD PTR Relative_Sector_High ; Get the high sector word
	mov	AX,WORD PTR Relative_Sector_Low  ; Get the low sector word

	sub	AX,StartSector			; Get relative sector #
	sbb	DX,0				; Pick up borrow

	mov	SI,DX				; Get high word
	mov	DI,AX				; Get low word
	xor	CX,CX				; Clear CX
						; Get Sectors/cluster
	mov	CL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	call	divide_32_Bits			; 32 bit division

	mov	DX,SI				; Get high word of result
	mov	AX,DI				; Get low word of result
	add	AX,2				; Adjust for cluster bias
	adc	DX,0				; Pick up carry

	pop	SI				; Restore regs
	pop	DI
	pop	CX
	ret

Calc_Cluster_Position ENDP

;=========================================================================
; Calc_ClustBound_ : This routine will determine where, within a
;			   cluster, a sector resides.
;
;	 Inputs	 : Relative_Sector_Low		- Sector
;		   Relative_Sector_High
;
;	 Outputs : ClustBound_Adj_Factor	- The number of Sectors
;						   remaining in	the cluster.
;		   ClustBound_SPT_Count	 	- The count of	Sectors
;						  having been accessed	for
;						  a track.
;=========================================================================

Procedure Calc_ClustBound_

	push	AX				; Save regs
	push	BX
	push	CX
	push	DX
	push	SI
	push	DI

	xor	DX,DX				; Clear high word
	mov	DX,WORD PTR Relative_Sector_High
	mov	AX,WORD PTR Relative_Sector_Low
	sub	AX,StartSector			; Get relative sector #
	sbb	DX,0				; Pick up borrow

	mov	SI,DX				; Get high word
	mov	DI,AX				; Get low word
	xor	CX,CX				; Clear CX
	mov	CL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	call	divide_32_Bits			; 32 bit division

	or	CX,CX				; See if remainder exists
	jz	$$IF132 			; Remainder exists

	xor	BX,BX
	mov	BL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	sub	BX,CX
	mov	ClustBound_Adj_Factor,BX	; Remainder = sector count
	jmp	SHORT $$EN132			; Noremainder

$$IF132:
	xor	BX,BX				; Clear BX
	mov	BL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	mov	ClustBound_Adj_Factor,BX

$$EN132:

	mov	AX,ClustBound_SPT_Count 	; Get current sector count
	xor	DX,DX				; Clear high word
	add	AX,ClustBound_Adj_Factor	; Get next sector count
						; Exceeded Sectors/track?
	cmp	AX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	jna	$$IF135 			; Yes
						; only use difference
	mov	AX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	sub	AX,ClustBound_SPT_Count 	; Get next sector count
	mov	ClustBound_Adj_Factor,AX

$$IF135:
	mov	AX,ClustBound_SPT_Count 	; Get sector count
	xor	DX,DX				; Clear high word
	add	AX,ClustBound_Adj_Factor	; Get new sector count
	mov	ClustBound_SPT_Count,AX 	; Save it

	pop	DI				; Restore regs
	pop	SI
	pop	DX
	pop	CX
	pop	BX
	pop	AX

	ret

Calc_ClustBound_ ENDP

;=========================================================================
;
; BadClus_address_Adjust	 - This	routine	adjusts	the segment and
;				   offset to provide addressibility into
;				   the Fat table.
;
;	 Inputs	 : BX	 - high	word to	adjust segment for
;		   AX	 - low word to adjust segment for
;		   CX	 - segment to be adjusted
;
;	 Outputs : CX	 - new segment value
;		   AX	 - new offset value
;
;=========================================================================

Procedure BadClus_address_Adjust

	push	BX				; Save regs
	push	DX
	push	DI
	push	SI

	mov	DX,CX				; Save segment value
	mov	SI,BX				; Get high word for divide
	mov	DI,AX				; Get low word for divide
	xor	CX,CX				; Clear CX
	mov	CL,Paragraph_Size		; Divide by 16
	call	divide_32_Bits			; Perform division

	add	DX,DI				; Adjust segment for result
	mov	AX,CX				; Pick up the remainder
	mov	CX,DX				; Pass back new segment

	pop	SI				; Restore regs
	pop	DI
	pop	DX
	pop	BX

	ret

BadClus_address_Adjust ENDP

;=========================================================================
;Routine name:	Multiply_32_Bits
;=========================================================================
;Description: A real sleazy 32	bit x 16 bit multiply routine. Works by	adding
;	       the 32 bit number to itself for each power of 2 contained in the
;	       16 bit number. Whenever a bit that is set in the	multiplier (CX)
;	       gets shifted to the bit 0 spot, it means	that that amount has
;	       been multiplied so far, and it should be	added into the total
;	       value. Take the example CX = 12 (1100). Using the associative
;	       rule, this is the same as CX = 8+4 (1000	+ 0100). The
;	       multiply	is done	on this	principle - whenever a bit that	is set
;	       is shifted down to the bit 0 location, the value	in BX:AX is
;	       added to	the running total in DI:SI. The	multiply is continued
;	       until CX	= 0. The routine will exit with	CY set if overflow
;	       occurs.
;
;
;Called Procedures: None
;
;Change History: Created	 7/23/87	 MT
;
;Input: BX:AX = 32 bit	number to be multiplied
;	 CX = 16 bit number to be multiplied. (Must be even number)
;
;Output: BX:AX	= output.
;	  CY set if overflow
;
;=========================================================================

	PUBLIC	Multiply_32_Bits
Multiply_32_Bits PROC

	push	DI
	push	SI
	xor	DI,DI			; Init result to zero
	xor	SI,SI
	cmp	CX,0			; Multiply by 0?
	je	$$IF75			; Keep going if not

$$DO76: 				; This works by adding result
	test	CX,1			; Need to add in sum of this bit?
	jz	$$IF77			; Yes
	add	SI,AX			; add in the total so far for
	adc	DI,BX			; this	bit multiplier (CY oflow)
	jmp	SHORT $$EN77		; Don't split multiplier

$$IF77:
	clc				; Force	non exit

$$EN77:
	jc	$$EN76			; Leave on overflow
	shr	CX,1			; See if need to multiply value
	cmp	CX,0			; by 2
	je	$$EN76			; Done if CX shifted down to zero

	add	AX,AX			; Each time CX is shifted, add
	adc	BX,BX			; value	to itself (Multiply * 2)
	jnc	$$DO76			; CY set on overflow

$$EN76:
	jc	$$IF83			; If no overflow, add in DI:SI
	mov	AX,SI			; which contains the original
	mov	BX,DI			; value if odd, 0 if even. This
	clc				; Set no overflow flag

$$IF83:
	jmp	SHORT $$EN75
$$IF75:
	xor	AX,AX
	xor	BX,BX			; Multiply by 0

$$EN75:
	pop	 SI
	pop	 DI
	ret

Multiply_32_Bits endp

;=========================================================================
; divide_32_Bits	 - This	routine	will perform 32bit division
;			   It works by first dividing the high word
;			   and leaving the remainder in DX and then
;			   dividing the low word with the remainder
;			   still in DX
;
;	 Inputs	 : SI:DI - value to be divided
;		   CX	 - divisor
;
;	 Outputs : SI:DI - result
;		   CX	 - remainder
;=========================================================================

Procedure divide_32_Bits

	push	AX			; Save regs
	push	BX
	push	DX


	xor	DX,DX			; clear DX
	mov	AX,SI			; get high word
	div	CX			; get high word result
	mov	SI,AX			; save high word result


	mov	AX,DI			; get low word
	div	CX			; get low word result
	mov	DI,AX			; save low word result
	mov	CX,DX			; pick up remainder

	pop	DX			; restore regs
	pop	BX
	pop	AX

	ret

divide_32_Bits	 endp


;=========================================================================
;
;  QuickFormat :	This procedure will perform a Quick format by
;			simply copying any bad cluster markers from the 
;			old FAT on the disk to the new FAT.  The old FAT is
;			read in one sector at a time using FatSector buffer.
;			The new FAT is held in FatSpace buffer.
;
;  Registers Destroyed : SI,AX,BX,CX
;
;  Assumes:	DS:DATA,ES:Nothing
;
;=========================================================================

QuickFormat	proc	near

	mov	SI,DATA
	mov	ES,SI				; Set ES to data segment

	assume	ES:DATA,DS:Nothing		; Assembler directive

						; Set device parameters here
	mov	ES:DeviceParameters.DP_SpecialFunctions,(INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD)
	lea	DX,ES:DeviceParameters
	call	SetDeviceParameters

	mov	ES:sector_in_buffer,0ffffh	; force first read to ensure
						; buffer validity

	test 	ES:fBigFAT,0ffh			; See if 16 bit fat
	jz	Set12BitEntry			; If zero then 12 bit fat
	mov	BX,0fff7h			; Set 16 bit value for bad cluster
	jmp	SHORT InitClusCount

Set12BitEntry:
	mov	BX,0ff7h			; Set 12 bit value for bad cluster

InitClusCount:
	mov	ES:CurrentCluster,2		; M015; No need to do the first 2
	mov	ES:BadClusValue,BX

QuickLoop:
	mov	AX,ES:CurrentCluster
	call	calc_sector_and_offset		; determine location of this entry

	mov	BX,ES:sector_in_buffer
	mov	AX,ES:sector_to_read
	cmp	AX,BX	      			; check if required sector is in buffer
	je	DontHaveToRead

	call	ReadFatSector			; read a sector of the FAT into buffer
	jc	ExitQuickFormat			; check for error

DontHaveToRead:
	mov	AX,ES:CurrentCluster		; AX = current cluster
	xor	CX,CX				; CX = get cluster contents signal
	lds	SI,ES:FatSector			; DS:SI --> FAT buffer
	call	GetFatSectorEntry		; AX = contents of FAT entry

	mov	BX,ES:BadClusValue		; Restore bad cluster value
	cmp	AX,BX				; Is this cluster marked bad?
	jne	NextCluster			; If AX<>BX good cluster

MarkInFormatBuffer:
	mov	CX,BX				; CX = value to set in FAT buffer
	mov	AX,ES:CurrentCluster		; AX = this cluster number
	lds	SI,ES:FatSpace			; DS:SI --> Format's FAT buffer
	call	GetSetFatEntry	       	   	; Set the cluster in Format's buffer
	
NextCluster:
;	call	DisplayProgress			; Show percentage complete
	inc	ES:CurrentCluster		; go to next cluster

	mov	AX,ES:CurrentCluster
	mov	BX,ES:TotalClusters
	cmp	AX,BX				; check for last cluster in FAT
	jna	QuickLoop

	clc

ExitQuickFormat:
	mov	BX,DATA	
	mov	DS,BX				; restore DS to DATA segment

	assume	DS:DATA,ES:DATA			; Assembler directive

	ret
QuickFormat	endp




;===========================================================================
;
; calc_sector_and_offset :	This procedure computes the logical sector
;				number the given FAT entry is in, and its
;				offset from the start of the sector.
;
;  Inputs :	AX = entry number
;		fBigFat = flag for 12- or 16-bit FAT entries
;		Number of reserved sectors
;
;  Output :	sector_to_read = logical disk sector holding FAT entry
;		entry_offset   = offset from start of sector
;		odd_entry      = flag for 12-bit entry alignment (1=odd,0=even)
;
;  Registers Destroyed : AX,BX,CX,DX 
;
;  Strategy :	This procedure assumes the sector size is 512 bytes.
;		The byte offset from the start of the FAT is first
;		calculated.  This is then divided by 512, so that
;			required sector = quotient
;			offset	        = remainder
;		The logical sector number is obtained by adding on the
;		number of reserved sectors.
;
; M017: The code does not assume 512 BytesPerSector (it is even simpler!)
;============================================================================

calc_sector_and_offset	proc	near

	assume	DS:NOTHING,ES:DATA
	xor	DX,DX
	test	ES:fBigFat,0ffh		; See if 16 bit FAT
	jz	FindOffset12		; If not do 12 bit FAT

FindOffset16:
	shl	AX,1			; AX *= 2
	adc	DX,0			; Add the carry
					; Now offset from start of FAT is
					; in DX:AX
	jmp	SHORT	FindSector

FindOffset12:
	mov	BX,AX			; BX = cluster number
	shl	AX,1
	add	AX,BX			; AX *= 3

	mov	ES:odd_entry,AL 	; lsb of AX determines even or odd
	and	ES:odd_entry,1

	shr	AX,1			; Divide by 2
					; Now offset from start of FAT is
					; in DX:AX

FindSector:
;M017 - begin
;	mov	ES:entry_offset,AX 	; required offset is in low 9 bits
;	and	ES:entry_offset,1ffh
;	
;	shr	AX,1
;	ror	DX,1			; place lsb into msb
;	or 	AX,DX			; need to rotate number in DX:AX, so
;					; bring lsb in DX to msb in AX
;	mov	CL,8			; perform 8 more shifts
;	shr	AX,CL				

; Since DX:AX can at most be 128K (ie DX<=1 by the above code)
; and GetTotalCluster assured us we had at least 32 BytesPerCLuster
; no check is required prior to the division.

	div	ES:DeviceParameters.DP_BPB.BPB_BytesPerSector
	mov	ES:entry_offset,DX
;M017 - end

	add	AX,ES:DeviceParameters.DP_BPB.BPB_RESERVEDSECTORS
	mov	ES:sector_to_read,AX	

	ret
calc_sector_and_offset	endp






;===========================================================================
;
; ReadFatSector :	This procedure will read in a sector of the FAT
;			into the FatSector buffer.  This is done by loading
;			the required parameters and calling ReadWriteSectors.
;
; Input :	sector_to_read
; Output:	loaded buffer
;		sector_in_buffer
;
; Registers destroyed: AX,BX,CX,DX
;
;===========================================================================

ReadFatSector	proc	near

	assume	DS:NOTHING,ES:DATA
	
	push	DS			; Preserve DS

	mov	AL,ES:Drive		; AL = DOS drive number
	mov	CX,1			; 1 sector only
	mov	DX,ES:sector_to_read	; DX = starting sector
	lds	BX,ES:FatSector		; DS:BX --> read buffer
						; we are accessing < 32mb
	mov	ES:Read_Write_Relative.Start_Sector_High,0
 
	call	Read_Disk		; perform read

	mov	ES:sector_in_buffer,DX	; update sector in memory

	pop	DS			; Restore DS

	ret
ReadFatSector	endp






;===========================================================================
; Routine name:	GetSetFatEntry
;===========================================================================
;
; Description: Returns or sets the contents of the specified fat
;	       entry from a specified buffer. The buffer may be
;	       up to 128K in length for 16 bit FATs and 16K for
;	       12 bit FATs.
;
; Arguments:		DS:SI --> Start of FAT buffer
;			AX = Cluster number
;			CX = 0 if get cluster else set cluster from CX
; ----------------------------------------------------------------
; Returns:   		AX    --> Contents of FAT entry
; -----------------------------------------------------
; Registers destroyed:	AX BX CX DX
; ----------------------------------------
; Strategy
; --------
;===========================================================================

GetSetFatEntry PROC

	assume	DS:NOTHING,ES:DATA

	push	SI			; Save regs for 'C' compatibility
	push	DS
	push	ES

;	mov	BX,DATA			; ES = DATA
;	mov	ES,BX

	call	Seg_Adj			; Normalize the pointer
	xor	DX,DX			; Find offset of entry in the buffer
	test	ES:fBigFat,0ffh		; See if 16 bit FAT
	jz	FindEntry12		; If not do 12 bit FAT

FindEntry16:
	shl	AX,1			; DS:AX *= 2
	adc	DX,0			; Add the carry

AddToBufStart:				; Offset in DX:AX may be > 64K
	mov	BX,16			; Convert DX:AX to paragraphs
	div	BX			; (AX = DX:AX / 16) (DX = DX:AX % 16)

	mov	BX,DS			; Add paragraphs to DS
	add	AX,BX
	mov	DS,AX

	add	SI,DX			; Add remaining offset in DX to SI
	jcxz	GetFatEntry16		; If CX == 0 then get entry

	mov	[SI],CX			; Set the entry
	jmp	SHORT GetSetEntryExit	; AX = FAT entry

GetFatEntry16:
	mov	AX,[SI]			; Move the entry into AX
	jmp	SHORT GetSetEntryExit	; AX = FAT entry

FindEntry12:
	mov	BX,AX			; BX = cluster number
	shl	AX,1
	add	AX,BX			; AX *= 3

	test	AX,1			; Test lsb of AX to see if even or odd
	pushf				; Save zero flag

	shr	AX,1			; Divid by 2
	add	SI,AX			; Address the cluster
	mov	AX,[SI]			; AX = entry + part of another entry
	popf				; Get bit test off the stack
	jnz	OddCluster		; If not zero then it's an odd cluster

EvenCluster:
	jcxz	GetEvenCluster		; Check for get or set
	and	AX,0f000h		; Zero out the value in 12 lsb
	or	AX,CX			; Set the new value
	mov	[SI],AX
	jmp	SHORT GetSetEntryExit	; AX = FAT entry

GetEvenCluster:
	and	AX,0fffh		; Mask off high 4 bits
	jmp	SHORT GetSetEntryExit	; AX = FAT entry

OddCluster:
	jcxz	GetOddCluster		; Check for get or set

	shl	CX,1			; Set the value
	shl	CX,1			; Shift left 4 bits
	shl	CX,1
	shl	CX,1
	and	AX,0fh			; Zero out existing value in 12 msb
	or	AX,CX			; Insert new value
	mov	[SI],AX
	jmp	SHORT GetSetEntryExit	; AX = FAT entry

GetOddCluster:
	shr	AX,1			; Shift over 4 bits to get entry
	shr	AX,1
	shr	AX,1
	shr	AX,1

GetSetEntryExit:
	pop	ES			; Restore regs for 'C' compatibility
	pop	DS
	pop	SI
	ret

GetSetFatEntry ENDP





;===========================================================================
; Routine name:	GetFatSectorEntry
;===========================================================================
;
; Description: Returns the contents of the specified fat
;	       entry from the FatSector buffer. It is assumed that the 
;	       required sector is in the buffer already.  If the entry is
;	       12 bits and overlaps sectors, the next sector will be read
;	       into the FatSector buffer.
;
; Arguments:		DS:SI --> Start of FatSector buffer
;			entry_offset = offset of entry from start of buffer
;			fBigFat = flag for 12- or 16-bit FAT
; -------------------------------------------------------------------------
; Returns:   		AX    --> Contents of FAT entry
; -----------------------------------------------------
; Registers destroyed:	AX BX CX DX
; ---------------------------------
;
;===========================================================================

GetFatSectorEntry PROC

	assume	DS:NOTHING,ES:DATA

	push	SI			; Save regs for 'C' compatibility
	push	DS
	push	ES

;	mov	BX,DATA			; ES = DATA
;	mov	ES,BX

	call	Seg_Adj			; Normalize the pointer

	test	ES:fBigFat,0ffh		; See if 16 bit FAT
	jz	Get12		; If not do 12 bit FAT

Get16:
	mov	DX,ES:entry_offset
	add	SI,DX  			; Add offset value in DX to SI
	mov	AX,[SI]			; Move the entry into AX
	jmp	SHORT GetFatSectorEntryExit	; AX = FAT entry			

Get12:
	mov	DX,ES:entry_offset
	add	SI,DX			; Address the cluster entry

	cmp	DX,1ffh			; Entry straddles two FAT sectors if
	jb	Does_Not_Straddle	; offset is 511 (last byte in sector) 

Does_Straddle:
	call	ReadInTwoParts		; Handle special case by reading in
	jmp	SHORT  GetFatSectorEntryExit	; the next FAT sector also

Does_Not_Straddle:
	mov	AX,[SI]			; AX = entry + part of another entry

	test  	ES:odd_entry,1
	jnz	GetOddCluster		; If not zero then it's an odd cluster

IsEvenCluster:
	and	AX,0fffh		; Mask off high 4 bits
	jmp	SHORT GetFatSectorEntryExit	; AX = FAT entry

IsOddCluster:
	shr	AX,1			; Shift over 4 bits to get entry
	shr	AX,1
	shr	AX,1
	shr	AX,1

GetFatSectorEntryExit:
	pop	ES			; Restore regs for 'C' compatibility
	pop	DS
	pop	SI
	ret

GetFatSectorEntry ENDP





;===========================================================================
;
;  ReadInTwoParts :	This procedure will determine the value of a 12-bit 
;			FAT entry which is straddled across two consecutive
;			sectors in the FAT.  The value is found by reading
;			the available part from the first sector, and then
;			loading the next sector in the FatSector buffer and
;			reading and combining the next part.
;  Input : odd_entry
;	   sector_to_read
;	   DS:SI pointer to required entry location in buffer (this is
;	    offset 511 from start of FatSector buffer)
;
;  Output: AX = entry value
;	   FatSector contains next FAT sector
;
;  Registers destroyed : AX
;
;  Strategy :	The position of the entry is different for odd and even
;		entries.  The 3-byte layout for two consecutive 12-bit entries
;		is shown below.  (The byte |X1 X0| or |Y2 X2| is the last 
;		in the buffer).
;
;		|X1 X0|Y0 X2|Y2 Y1|
;
;		Even entries start at X1 (thus need to get X2X1X0).
;		Odd entries start at Y0 (thus need to get Y2Y1Y0).
;
;===========================================================================

ReadInTwoParts	proc	near

	assume	DS:NOTHING,ES:DATA

	push	BX				; Save registers
	push	CX
	push	DX
	push	SI

	xor	AX,AX
	mov	AL,BYTE PTR [SI]		; read last byte of buffer

	mov	BX,ES:sector_to_read		; compute next sector to read
	inc	BX
	mov	ES:sector_to_read,BX

	test	ES:odd_entry,1
	jnz	OddEntry

EvenEntry:
	push	AX
	call	ReadFatSector			; read in the next FAT sector
	pop	AX
	
	lds	SI,ES:FatSector			; set DS:SI to start of buffer
	xor	BX,BX

	mov	BH,BYTE PTR [SI]		; read first byte of buffer
	and	BH,0fh				; mask out Y2
	or	AX,BX				; place X2 into position

	jmp	SHORT EndReadInTwo

OddEntry:
	and	AL,0f0h				; mask out X2
	mov	CL,4
	shr	AX,CL				; place Y0 into position
	
	push	AX
	call	ReadFatSector			; read in the next FAT sector
	pop	AX

	lds	SI,ES:FatSector			; set DS:SI to start of buffer
	
	xor	BX,BX
	mov	BL,BYTE PTR [SI]		; read first byte of buffer
	mov	CL,4
	shl	BX,CL	
	or	AX,BX				; place Y2 Y1 into position
	
EndReadInTwo:
	pop	SI				; Restore registers
	pop	DX
	pop	CX
	pop	BX

	ret
ReadInTwoParts	endp




;========================================================================
;
;  DisplayProgress :	This procedure will give the user a message 
;			indicating the percentage completion of the
;			formatting task.
;
;  Assumes:	ES:DATA,DS:Nothing
;
;========================================================================
;
;DisplayProgress	proc	near
;
;	push	AX
;	push	BX
;	push	DX
;
;	mov	AX,ES:CurrentCluster
;
;	test	AX,1			; Reduce #divides by half by displaying
;	jnz	UpdateDone		; only for even values of CurrentCluster
;
;	mov	BX,100
;	mul	BX
;	mov	BX,ES:TotalClusters
;	div	BX
;	
;	cmp	AX,ES:PercentComplete
;	je	UpdateDone
;	
;	mov	ES:PercentComplete,AX
;	Message	msgCurrentTrack
;
;UpdateDone:
;	pop	DX
;	pop	BX
;	pop	AX
;
;	ret
;DisplayProgress	endp


CODE ENDS


END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
;
;
;*****************************************************************************
;*                                                                           *
;* Change list to FORMAT modules                                             *
;*                                                                           *
;* Lines are tagged ANxxx for new, ACxxx for changed                         *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test          *
;*         Date: 8/3/87    Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 DCR D146 Add support for /F switch                        *
;*         Date: 8/13/87   Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  002 - DOS 4.00 DCR D166 Add logic to detect that switches entered        *
;*         multiple times, and print error message                           *
;*         Date: 8/13/87   Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  003 - DOS 4.00 PTM P233 Do not allow Cntrl-Break when writing file       *
;*        system out, only during the actual format                          *
;*        Date: 8/14/87    Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  004 - DOS 4.00 PTM P229 Volume serial number displayed in reverse word   *
;*        order from command.com and diskcopy. Reverse order of words        *
;*        Date: 8/17/87    Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  005 - DOS 4.00 DCR D64  Enable for 128k FAT                              *
;*        Date: 8/19/87    Developer: DMS	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  006 - DOS 4.00 PTM P320 Not detecting write protect. Needed to use       *
;*        extended error messages                                            *
;*        Date 8/20/87     Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  007 - DOS 4.00 PTM P170 Straighten out the switch check logic to allow   *
;*        /B with all diskette formats, add /B/S check, and remove /V/B      *
;*        check except for /8 sectored diskettes (old dir and boot record    *
;*        Date 8/21/87     Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  008 - DOS 4.00 PTM P402 Fields that determine switch type not cleared,   *
;*        so switches got checked multiple times, causing error              *
;*        Date 8/23/87     Developer: MT        , Dave Sewell                *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  009 - DOS 4.00 PTM P341 Check to make sure /N entered with /T            *
;*        Date 8/23/87     Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  010 - DOS 4.00 PTM P233 Capture the CTRL-BREAK interrupt and disable     *
;*        it during the writing of the FAT, DIR, and SYSTEM.                 *
;*        Date 8/25/87     Developer: DMS                                    *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  012 - DOS 4.00 DCR 200 If the NumberOfFATs field of the BPB is 0 we need *
;*        to calculate various values in the BPB to be used by FORMAT.       *
;*        Date 9/10/87    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  013 - DOS 4.00 DCR 208 Set FORMAT in order that the space available it   *
;*        reports is consistent with DIR.                                    *
;*        Date 9/11/87    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  014 - DOS 4.00 PTM 1535 Allow access to a non-formatted disk.            *
;*        Date 10/15/87   Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  015 - DOS 4.00 DCR 390  Multi-Track format of hard media                 *
;*        Date 12/9/87    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  016 - DOS 4.00 DCR 395  SELECT message support.  Use INT 2Fh, function   *
;*        ADC1h to print FORMAT disk prompt from SELECT.                     *
;*        Date 12/14/87   Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  017 - DOS 4.00 PTM 3125 SELECT message support. Disable write protect    *
;*        message under SELECT option.  Addition of exit codes 6 (Drive Not  *
;*        Ready" and 7 (Write Protect).                                      *
;*        Date 1/14/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  018 - DOS 4.00 PTM 3130 Provide for conditional assembly of the /FS:     *
;*        code, since it is not being shipped with DOS 4.00.                 *
;*        Date 1/26/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  019 - DOS 4.00 PTM 3994 FORMAT now has a "heartbeat" when it verifies    *
;*        bad sectors.  By doing so the user knows the FORMAT is still       *
;*        proceeding well.  Without this heartbeat, an AT appears to hang    *
;*        when the sectors are being verified.  This is caused by the slow   *
;*        head resets on an AT.                                              *
;*        Date 3/25/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  020 - DOS 4.00 PTM 4058 When an invalid Volume ID is entered at the      *
;*        volume prompt, FORMAT should go to the next line so that the       *
;*        user can see the invalid volume id.                                *
;*        Date 3/29/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  021 - DOS 4.00 PTM 4081 FORMAT was marking the incorrect cluster as      *
;*        bad under certain situations.  This caused that sector to fail     *
;*        when read or written to.                                           *
;*        Date 3/31/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  022 - DOS 4.00 PTM 4180 FORMAT was not performing an FCB Close after     *
;*        it had done an FCB Create.  This caused the change line counter    *
;*        to go "haywire".  Also a bug was found in the FORMAT retry logic.  *
;*        FORMAT was never entering the retry logic because of a CY flag     *
;*        always existing on entry to the routine.                           *
;*        Date 4/15/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  023 - DOS 4.00 DCR 524 FORMAT must accept a blank or carriage return to  *
;*        allow for a blank volume label.                                    *
;*        Date 4/19/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  024 - DOS 4.00 PTM 4487 FORMAT trys to get the A: drive when formatting  *
;*        drive B: and then hitting enter for the volume label.  There is a  *
;*        problem with FCB Close but logic was also changed in FORLABEL.SAL  *
;*        to eliminate this condition.                                       *
;*        Date 4/26/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  025 - DOS 4.00 PTM 4539 FORMAT accesses the default disk instead of the  *
;*        boot disk when the default disk is different than the boot disk.   *
;*        This is incorrect behavior because the user could receive a system *
;*        other than what they wanted.                                       *
;*        Date 4/28/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  026 - DOS 4.00 PTM 4805 FORMAT A: /B gives invalid bad byte count and    *
;*        FORMAT A: /F:160 on an 1.2 Mb drive gives parm error.              *
;*        Date 5/10/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  027 - DOS 4.00 PTM 4913 FORMAT A: /B displays the serial number of the   *
;*        diskette but never writes it to the diskette.  Format will no      *
;*        display the serial number when formatting with /8.                 *
;*        Date 5/19/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  028 - DOS 4.00 PTM 5023 FORMAT puts just the N of NO NAME in the volume  *
;*        label of the boot record.  This is corrected in IBMFOR.SAL by      *
;*        setting up the CX register correctly.                              *
;*        Date 6/09/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  030 - DOS 5.0           FORMAT major changes for supporting safe format  *
;*        wich creates an unformat file to be used by a program to restore   *
;*        the bootsector, fat, root, and first 2 clusters.		     *
;*        Date 10/22/89    Developer: johnhe                                 *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  031 - DOS 5.0           FORMAT made change in format.asm to have it      *
;*        do an int  2fh with AX == 4000h && BX == percent complete when     *
;*        the /SELECT switch is used.					     *
;*        Date 2/27/90    Developer: johnhe                                  *
;*****************************************************************************
;* Note: This is file FORCHNG.INC for updating purposes                      *
;*****************************************************************************
.list


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;                                              ;                               ;     ;

GAGE_UPDATE 	EQU	(4900h)

NO      equ     0
YES     equ     not NO


FSExec  equ     NO                              ;an018; dms;conditional assembly
ShipDisk equ    NO                              ;an000; dms;ship disk flag

Boot_ID equ   0AA55h
DOS_Found equ   0

Not_Include     equ     0
Do_Include         equ     1

INIT    equ     0

FAT12_File_System equ 01h
FAT16_File_System equ 04h
New_File_System equ 06h

FS_String_Max_Length    equ     5

Paragraph_Size  equ     16                      ;                               ;AN005;
Len_FS_String_Buffer    equ     13

Net_Check equ   1200h
Assign_Check equ 8000h

Found_Yes equ   1
Found_No equ    0

Asciiz_End equ  0
DBCS_Blank_hi	equ	81h
DBCS_Blank_lo	equ	40h
DBCS_Vector_Size equ 2
End_Of_Vector equ 0


Blank   equ     " "

Label_Length equ 11
CR      equ     13

DBCS_VECTOR equ NO

;Limits
BIG_FAT_THRESHOLD equ 4086

;-------------------------------------------------------------------------------





DRNUM   EQU     5CH



; Exit status defines
ExitOK  equ     0
ExitCtrlC equ   3
ExitFatal equ   4
ExitNo  equ     5


;-------------------------------------------------------------------------------
; These are the data structures which we will need


Media_ID struc
Media_ID_Info_Level dw 0
Media_ID_Serial_Number dd 0
Media_ID_Volume_Label db 11 dup(" ")
Media_ID_File_System db 8  dup(" ")
Media_ID ends


Relative_Sector_Buffer  struc                   ;                               ;AN000;

Start_Sector_Low        dw      ?               ;Low word of RBA sector         ;AN000;
Start_Sector_High       dw      ?               ;High word of RBA sector        ;AN000;
Number_Sectors          dw      ?               ;Number of sectors              ;AN000;
Buffer_Offset           dw      ?               ;Address of data buffer         ;AN000;
Buffer_Segment          dw      ?               ;                               ;AN000;

Relative_Sector_Buffer ends                     ;                               ;AN000;


;Per system file data structure

a_FileStructure struc
	fileHandle 		DW   	?
	fileSizeInParagraphs 	DW 	?
	fileSizeInBytes 	DD 	?
	fileOffset 		DD   	?
	fileStartSegment 	DW 	?
	fileDate 		DW     	?
	fileTime 		DW     	?
a_FileStructure ends

;-------------------------------------------------------------------------------

LOGBOOTSECT 		equ 	1
Set_Drv_Owner		equ 	0Fh             ; IOCTL subfunction
Custom_Media 		equ 	0F0H            ; Media byte for custom format
Dual_8_Media 		equ	0FFh            ; Dual sided 8 sectored
Single_8_Media 		equ	0FEh            ; Single sided 8 sectored
Dual_9_Media 		equ	0FDh            ; Dual sided 9 sectored
Single_9_Media 		equ	0FCh            ; Single sided 9 sectored
Dual_15_Media 		equ	0F9h            ; Dual sided 15 sectored
Fixed_Disk 		equ  	0F8h            ; Fixed Disk
Invalid_Drive   	equ     000Fh           ; Extended error 15
Max_Format_Size 	equ     0FFFFh          ; Max bytes to Format
Multi_Track_Format      equ     02h             ; Multi-track format
Single_Track_Format     equ     00h             ; Single track format
Select_Disk_Message     equ     0ADC1h


OFFSET_BPB		EQU	11		; Offset of BPB in boot record
BPB_LENGTH		EQU	25		; Length of BPB structure
OLD_BPB_LEN		EQU	19		; Length of CPM type bpb struc

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forinit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;


;*****************************************************************************
;*****************************************************************************
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: FORINIT.SAL
;
;
;
; Ŀ
;  Main_Init 
; 
;   
;   Ŀ     Ŀ
;   ôInit_Input_Output´Preload_Messages
;       
;   			    Ŀ   Ŀ
;   			    ôCheck_For_FS_Switch´Parse_For_FS_Switch
;   			      
;   			    			    Ŀ
;   			    			    EXEC_FS_Format
;   			    			     
;   			    Ŀ   Ŀ
;   			    Parse_Command_Line ĴInterpret_Parse
;   			        
;   Ŀ Ŀ
;   ôValidate_Target_Drive´Check_Target_Drive
;   ٳ
;   			    Ŀ
;   			    ôCheck_For_Network
;   			    
;   			    Ŀ
;   			    Check_Translate_Drive
;   			     
;   Ŀ
;   Hook_CNTRL_C
;    
;
;
; Change List: AN000 - New code DOS 3.3 spec additions
;	       AC000 - Changed code DOS 3.3 spec additions
;*****************************************************************************
;*****************************************************************************

;
;---------------------------------------------------------------------------
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc. Reclaimed
;		the msgBadDrive which was not being used. Removed the
;		unwanted EXTRN msgBadDrive. 
;
; 08/05/91 MD   Removed M030 changes.
;
;---------------------------------------------------------------------------
;

data	segment public para 'DATA'


Command_Line db NO
PSP_Segment dw	0

;These should stay togather
; ---------------------------------------
FS_String_Buffer db 13 dup(" ")
FS_String_End db "FMT.EXE",0
Len_FS_String_End equ $ - FS_String_End

;----------------------------------------

Vol_Label_Count  db 80h 			;max. string length
Vol_Label_Len	 db 00h 			;len. entered
Vol_Label_Buffer db 80h dup(0)
Vol_Label_Buffer_Length equ $ - Vol_Label_Buffer

Command_Line_Buffer db 80h dup(0)
Command_Line_Length equ $ - Command_Line_Buffer
Fatal_Error db	0

Command_Old_Ptr dw	?

data	ends

code	segment public para 'CODE'
	assume	cs:code,ds:data,es:data
code	ends

;
;*****************************************************************************
; Include files
;*****************************************************************************
;

.xlist
include bpb.inc
INCLUDE FORCHNG.INC
INCLUDE FORMACRO.INC
INCLUDE SYSCALL.INC
INCLUDE IOCTL.INC
INCLUDE FOREQU.INC
INCLUDE FORPARSE.INC
INCLUDE FORSWTCH.INC

INCLUDE VERSION.INC				;M032


.list

;
;*****************************************************************************
; Public Data
;*****************************************************************************
;

						; M033
						; Why declare variables BEFORE
						; include files?!
data	segment public para 'DATA'

Public	CMCDDFlag

CMCDDFlag		DB	?

data	ends


	Public	FS_String_Buffer
	Public	Command_Line
	Public	Fatal_Error
	Public	Vol_Label_Count
	Public	Vol_Label_Buffer
	Public	PSP_Segment
	Public	Command_Old_Ptr


;
;*****************************************************************************
; Public Routines
;*****************************************************************************
;


	Public	Main_Init

;
;*****************************************************************************
; External Routine Declarations
;*****************************************************************************
;

	Extrn	Main_Routine:Near
	Extrn	SysLoadMsg:Near
	Extrn	Get_11_Characters:Near
	Extrn	ControlC_Handler:Near
	Extrn	SysDispMsg:Near
	Extrn	SysLoadMsg:Near
	Extrn	Yes?:Near

;No more SAFE module
;	Extrn	Hook_INT_24:Near		;*Set fatal error handler
;	Extrn	Int_24_Handler:Near		;*Fatal error int handler


IF FSExec					;/FS: conditional assembly

	Extrn	EXEC_FS_Format:Near

ENDIF						;/FS: conditional assembly end

	Extrn	GetDeviceParameters:Near
;
;*****************************************************************************
; External Data Declarations
;*****************************************************************************
;

	Extrn	SwitchMap:Word
	Extrn	ExitStatus:Byte
	Extrn	Drive:Byte
	Extrn	DriveLetter:Byte
	Extrn	TranSrc:Byte
	Extrn	TrackCnt:Word
	Extrn	NumSectors:Word
	Extrn	BIOSFile:Byte
	Extrn	DOSFile:Byte
	Extrn	CommandFile:Byte
	Extrn	MsgNeedDrive:Byte
	Extrn	MsgBadVolumeID:Byte
;	Extrn	MsgBadDrive:Byte		; M024
	Extrn	MsgAssignedDrive:Byte
	Extrn	MsgNetDrive:Byte
	Extrn	msgOptions:Byte			; formsg.inc
	Extrn	msgDblspaceDrv:Byte
	Extrn	msgDblspaceHost:Byte
	Extrn	msgCrLf:Byte
	Extrn	MSG_OPTIONS_LAST:Abs
	Extrn	Parse_Error_Msg:Byte
	Extrn	Extended_Error_Msg:Byte
	Extrn	SizeMap:Byte
	Extrn	MsgSameSwitch:Byte
	Extrn	Org_AX:word			;AX on prog. entry
	Extrn	DeviceParameters:Byte
	Extrn	FAT_Flag:Byte
	Extrn	Sublist_MsgParse_Error:Dword

	EXTRN	EXIT_FATAL		:ABS

code	segment public	para	'CODE'

;*****************************************************************************
;Routine name:	Main_Init
;*****************************************************************************
;
;Description: Main control routine for init section
;
;Called Procedures: Message (macro)
;		    Check_DOS_Version
;		    Init_Input_Output
;		    Validate_Target_Drive
;		    Hook_CNTRL_C
;
;Input: None
;
;Output: None
;
;Change History: Created	5/1/87	       MT
;
;Psuedocode
; ---------
;
;	Get PSP segment
;	Fatal_Error = NO
;	Setup I/O (CALL Init_Input_Output)
;	IF !Fatal_Error
;	   Check target drive letter (CALL Validate_Target_Drive)
;	   IF !Fatal_Error
;	      Set up Control Break (CALL Hook_CNTRL_C)
;	      IF !Fatal_Error
;		 CALL Main_Routine
;	      ENDIF
;	   ENDIF
;	ENDIF
;	Exit program
;*****************************************************************************

Procedure Main_Init


	Set_Data_Segment		;Set DS,ES to Data segment
	DOS_Call GetCurrentPSP		;Get PSP segment address
	mov	PSP_Segment,bx		;Save it for later
	mov	Fatal_Error,No		;Init the error flag
	call	Init_Input_Output	;Setup messages and parse
	cmp	Fatal_Error,Yes 	;Error occur?

	JE	$$IF1			;Nope, keep going
	call	Validate_Target_Drive	;Check drive letter
	cmp	Fatal_Error,Yes		;Error occur?

	JE	$$IF2				;Nope, keep going

	call	Check_For_Dblspace	; is it a DblSpace drive?
	cmp	Fatal_Error,Yes		; Error occur?
	JE	$$IF2			;  exit if so

	call	Hook_CNTRL_C		;Set CNTRL -Break hook

;No more SAFE module			;*RUP - 10/09/89
;	call	Hook_Int_24		;*Set fatal error handler
					;*jh

	cmp	Fatal_Error,Yes		;Error occur?

	JE	$$IF3			;Nope, keep going
	jmp	SHORT End_Main_Init	;Go do the real program
$$IF3:
$$IF2:
$$IF1:
	mov	al,ExitStatus		;Get Errorlevel
	DOS_Call Exit			;Exit program
	int	20h			;If other exit fails

End_Main_Init:
	ret
Main_Init endp

;***	Check_For_Dblspace -- see if target drive is compressed, error if so
;
;	entry:
;	   Drive == 0 based drive number
;
;	exit:
;	   Fatal_Error == YES if it is
;	   ExitStatus == EXIT_FATAL

Check_For_Dblspace	proc	near

	mov	ax,4a11h		; See if DblSpace installed
	xor	bx,bx
	int	2fh
	or	ax,ax			; error?
	jnz	Check_For_Dblspace_exit	;  Dblspace will set ax == 0 if in
	cmp	bx,'DM'			;  and will set bx == 'DM'
	jnz	Check_For_Dblspace_exit

	mov	ax,4a11h
	mov	bx,1			; check drive map
	mov	dl,Drive
	int	2fh
	test	bl,80h			; compressed volume?
	jnz	cfd_is_compressed	;  yes, tell user 2 use dblspace/format

	; The target is not a DblSpace compressed drive, but it might be
	; a host for 1 or more compressed drives.  Get DblSpace drive map
	; info for each possible drive letter and see if any compressed
	; drives are hosted on the format target drive.

	xor	dx, dx			; zero based drive numbers
cfd_chk_host:
	mov	ax, 4a11h		; DblSpace ID
	mov	bx, 1			; get drive map info call
	int	2fh
	test	bl, 80h 		; is this a compressed drive?
	jz	cfd_nxt_host

	and	bl, 7fh 		; Yes, is it hosted on format target?
	cmp	bl, Drive
	je	cfd_is_host		;   yup, go tell user

cfd_nxt_host:
	inc	dl			; next drive to check
	cmp	dl, 26
	jb	cfd_chk_host
	jmp	short Check_For_Dblspace_exit

cfd_is_host:
	mov	al, Drive		; tell user target is a host
	Message msgDblspaceHost
	call	Yes?			; proceed with format (Y/N)?  CY set
					;   unless user says Yes
	pushf
	Message	msgCrlf
	popf
	jc	cfd_error		; CY set if user didn't say Yes
	jmp	short Check_For_Dblspace_exit

cfd_is_compressed:
	mov	al,Drive		; tell user to use dblspace/format
	Message msgDblspaceDrv		;   for this drive

cfd_error:
	mov	Fatal_Error,YES 	; terminate format
	mov	ExitStatus,EXIT_FATAL

Check_For_Dblspace_exit:
	ret

Check_For_Dblspace	endp

;*****************************************************************************
;Routine name: Init_Input_Output
;*****************************************************************************
;
;Description: Initialize messages, Parse command line, allocate memory as
;	      needed. If there is a /FS switch, go handle it first as
;	      syntax of IFS format may be different from FAT format.
;
;Called Procedures: Preload_Messages
;		    Parse_For_FS_Switch
;		    Parse_Command_Line
;
;Change History: Created	4/1/87	       MT
;
;Input: PSP command line at 81h and length at 80h
;	Fatal_Error  = No
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	Load messages (CALL Preload_Messages)
;	IF !Fatal_Error
;	   See if EXEC another file system (CALL Parse_For_FS_Switch)
;	   IF !FATAL_Error (in this case means FS was found and exec'd)
;	      CALL Parse_Command_Line
;	      IF !Fatal_Error
;		 CALL Interpret_Parse
;	      ENDIF
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Init_Input_Output

	Set_Data_Segment			;Set DS,ES to Data segment
	call	Preload_Messages		;Load up message retriever

IF FSExec					;/FS: conditional assembly

	cmp	Fatal_Error,YES 		;Quit?
	JE	$$IF7
	call	Check_For_FS_Switch		;Specify FS other than FAT?

ENDIF						;/FS: conditional assembly end

	cmp	Fatal_Error,YES			;drive is invalid for format?
	JE	$$IF8
	call	Parse_Command_Line		;Parse in command line input
	cmp	Fatal_Error,YES			; Quit?
	JE	$$IF9

	call	Determine_FAT_Non_FAT		;see if drive was non_FAT
	call	Check_For_Invalid_Drive		;Drive joined?
$$IF9:
$$IF8:

IF FSExec					;/FS: conditional assembly

$$IF7:

ENDIF						;/FS: conditional assembly end
	ret

Init_Input_Output endp

;*****************************************************************************
;Routine name: Preload_Messages
;*****************************************************************************
;
;Description: Preload messages using common message retriever routines.
;
;Called Procedures: SysLoadMsg
;
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	Preload All messages (Call SysLoadMsg)
;	IF error
;	   Display SysLoadMsg error message
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Preload_Messages

	Set_Data_Segment			;Set DS,ES to Data segment
	call	SysLoadMsg			;Preload the messages

	JNC	$$IF13				;Error?
	call	SysDispMsg			;Display preload msg
	mov	Fatal_Error, YES		;Indicate error exit

$$IF13:
	ret

Preload_Messages endp

;*****************************************************************************

IF FSExec					;/FS: conditional assembly

;*****************************************************************************
;Routine name: Check_For_FS_Switch
;*****************************************************************************
;
;Description: Parse to see if /FS switch entered, and if so, go EXEC the
;	      asked for file system. Set Fatal_Error = YES if FS found
;	      If we do find /FS, we need to build a string of xxxxxfmt.exe,0
;	      where xxxxx is the first 5 characters or less of /FS:xxxxx
;
;Called Procedures: Parse_For_FS_Switch
;		    EXEC_FS_Format
;
;Change History: Created	6/21/87 	MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 Exit_Status set
;
;Psuedocode
;----------
;
;	Parse for /FS switch (CALL Parse_For_FS_Switch)
;	IF !FATAL_ERROR
;	   IF /FS found
;	      Point at what was entered on /FS:xxxxx
;	      DO
;	      LEAVE end of entered string
;		Got good char, move into path
;	      ENDDO already got 5 chars (max in xxxxxfmt.exe)
;	      Tack on the rest of the string  (fmt.exe,0)
;	      Go exec the needed format (CALL EXEC_FS_Format)
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_For_FS_Switch

	Set_Data_Segment			;Set DS,ES to Data segment
	call	Parse_For_FS_Switch		;See if /FS entered
	cmp	Fatal_Error,YES 		;Bad stuff entered??

	JE	$$IF15				;Nope, cruise onward
	cmp	Switch_String_Buffer.Switch_Pointer,offset Switch_FS_Control.Keyword

	JNE	$$IF16				;We got the switch
	mov	Switch_FS_Control.Keyword,20h	;remove switch from table
	test	SwitchMap,Switch_FS		;Have this already?

	JNZ	$$IF17				;Nope
	push	ds				;Get addressibility
	pop	es

	assume	ds:nothing,es:data

						;Get the entered FS
	mov	ax,Switch_String_Buffer.Switch_String_Seg
	mov	ds,ax
	mov	si,es:Switch_String_Buffer.Switch_String_Off
	mov	cx,FS_String_Max_Length
	mov	di,offset es:FS_String_Buffer

$$DO18: 					;Move whatever user entered
	cmp	byte ptr [si],ASCIIZ_End	;End of the string?

	JE	$$EN18				;Yep
	movsb					;Put character in buffer
	dec	cx				;Dec character counter
	cmp	cx,0				;Nope, reached max # chars?

	JNE	$$DO18				;Yes
$$EN18:
	Set_Data_Segment			;Set DS,ES to Data segment
	mov	cx,Len_FS_String_End		;Tack the FMT.EXE onto it
	mov	si,offset es:FS_String_End	;DI still points at string
	rep	movsb				;We now have Asciiz path!
	call	EXEC_FS_Format			;Go try to EXEC it.....

	JMP	SHORT $$EN17
$$IF17:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN17:
$$IF16:
$$IF15:
	ret

Check_For_FS_Switch endp

;*****************************************************************************
;Routine name: Parse_For_FS_Switch
;*****************************************************************************
;
;Description: Copy the command line. Parse the new command line (Parse routines
;	      destroy the data being parsed, so need to work on copy so that
;	      complete command line can be passed to child format).
;	      The only thing we care about is if the /FS: switch exists, so
;	      parse until  end of command line found. If there was an error,
;	      and it occurred on the /FS switch, then give parse error,
;	      otherwise ignore the parse error, because it might be something
;	      file system specific that doesn't meet DOS syntax rules. Also
;	      check for drive letter, as it is alway required.
;
;Called Procedures: Message (macro)
;		    SysLoadMsg
;		    Preload_Error
;		    SysParse
;
;Change History: Created	5/1/87	       MT
;
;Input: Command line at 80h in PSP
;	   Fatal_Error = NO
;	   PSP_Segment
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	Copy command line to buffer
;	DO
;	   Parse command line (Call SysParse)
;	LEAVE end of parse
;	ENDDO found /FS
;	IF drive letter not found (This assumes drive letter before switches)
;	   Tell user
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Parse_For_FS_Switch

	Set_Data_Segment			;Set DS,ES to Data segment
	mov	Drive_Letter_Buffer.Drive_Number,Init
	mov	ds,PSP_Segment			;Get segment of PSP
	assume	ds:nothing

	mov	si,Command_Line_Parms		;Point at command line
	mov	di,offset data:Command_Line_Buffer ;Where to put a copy of it
	mov	cx,Command_Line_Length		;How long was input?
	repnz	movsb				;Copy it

	Set_Data_Segment			;Set DS,ES to Data segment
	xor	cx,cx
	xor	dx,dx				;Required for SysParse call
	mov	si,offset Command_Line_Buffer	;Pointer to parse line
	mov	di,offset Switch_FS_Table	;Pointer to control table

$$DO25: 					;Setup parse call
	call	SysParse			;Go parse
	cmp	ax,End_Of_Parse			;Check for end of parse

	JE	$$EN25				;Exit if it is end, or
	cmp	ax,Operand_Missing		; exit if positional missing

	JE	$$EN25				;In other words, no drive letter
	cmp	Switch_String_Buffer.Switch_Pointer, \
		offset Switch_FS_Control.Keyword

	JNE	$$DO25				;Exit if we find /FS

$$EN25: 					;Check for drive letter found
	cmp	Drive_Letter_Buffer.Drive_Type,Type_Drive

	JE	$$IF28				;Did we not find one?
	MESSAGE msgNeedDrive			;Must enter drive letter
	mov	Fatal_Error,Yes			;Indicate error on exit

$$IF28:
	ret

Parse_For_FS_Switch endp

ENDIF						;/FS: conditional assembly end


;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description: Parse the command line. Check for errors, and display error and
;		 exit program if found. Use parse error messages except in case
;		 of no parameters, which has its own message
;
;Called Procedures: Message (macro)
;		    SysParse
;		    Interpret_Parse
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;	PSP_Segment
;
;Output: Fatal_Error = YES/NO
;
;
;Psuedocode
;----------
;
;	Assume Fatal_Error = NO on entry
;	SEARCH
;	EXITIF Fatal_Error = YES,OR  (This can be set by Interpret_Parse)
;	   Parse command line (CALL SysParse)
;	EXITIF end of parsing command line
;	   Figure out last thing parsed (Call Interpret_Parse)
;	ORELSE
;	   See if parse error
;	LEAVE parse error,OR
;	   See what was parsed (Call Interpret_Parse)
;	LEAVE if interpret error such as bad volume label
;	ENDLOOP
;	   Display parse error message and print error operand
;	   Fatal_Error = YES
;	ENDSRCH
;	ret
;*****************************************************************************

Procedure Parse_Command_Line

	Set_Data_Segment			;Set DS,ES to Data segment
	push	ds
	mov	ds,PSP_Segment

	assume	ds:nothing,es:data

	xor	cx,cx				;Parse table @DI
	xor	dx,dx				;Parse line @SI
	mov	si,Command_Line_Parms		;Pointer to parse line
	mov	word ptr es:Command_Old_Ptr,si
	mov	di,offset es:Command_Line_Table ;Pointer to control table

$$DO30: 					;Loop until all parsed
	cmp	es:Fatal_Error,Yes		;Interpret something bad?

	JE	$$LL31				;If so, don't parse any more
	call	SysParse			;Go parse
	cmp	ax,End_Of_Parse			;Check for end of parse

	JNE $$IF30				;Is it?

$$LL31: 					;All done
	JMP	SHORT $$SR30			;Not end

$$IF30:
	cmp	ax,0				;Check for parse error

	JNE	$$EN30				;Stop if there was one
	call	Interpret_Parse 		;Go find what we parsed
	mov	word ptr es:Command_Old_Ptr,si

	JMP	SHORT $$DO30			;Parse error, see what it was

$$EN30:
	mov	byte ptr ds:[si],0
	push	di
	push	ax
	mov	di,offset es:Sublist_MsgParse_Error
	mov	ax,word ptr es:Command_Old_Ptr
	mov	word ptr es:[di+2],ax
	mov	word ptr es:[di+4],ds
	pop	ax
	pop	di
	PARSE_MESSAGE				;Display parse error
	mov	es:Fatal_Error,YES		;Indicate death!

$$SR30:
	pop	ds
	ret

Parse_Command_Line endp

;*****************************************************************************
;Routine name: Interpret_Parse
;*****************************************************************************
;
;Description: Set the SwitchMap  field with the switches found on the
;	      command line. Get the drive letter. /FS will be handled before
;	      here, will not be seen in this parse or accepted. Also, if /V
;	      see if volume label entered and verify it is good, setting up
;	      FCB for later create
;
;Called Procedures: Get_11_Characters
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: SwitchMap set
;	 DriveLetter set
;	 DriveNum set A=0,B=1 etc...
;	 Command_Line = YES/NO
;	 Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	IF Drive letter parsed
;	Drive = Parsed drive number -1
;	DriveLetter = (Parsed drive number - 1) +'A'
;	ENDIF
;	IF /1
;	  or	SwitchMap,Switch_1
;	ENDIF
;	IF /4
;	  or	SwitchMap,Switch_4
;	ENDIF
;	IF /8
;	  or	SwitchMap,Switch_8
;	ENDIF
;	IF /S
;	  or	SwitchMap,Switch_S
;	ENDIF
;	IF /BACKUP
;	  or	SwitchMap,Switch_BACKUP
;	ENDIF
;	IF /B
;	  or	SwitchMap,Switch_B
;	ENDIF
;	IF /T
;	  or	SwitchMap,Switch_T
;	  TrackCnt = entered value
;	ENDIF
;	IF /N
;	  or	SwitchMap,Switch_N
;	  NumSectors = entered value
;	ENDIF
;	IF /SELECT
;	  or	SwitchMap,Switch_SELECT
;	ENDIF
;	IF /V
;	  or	SwitchMap,Switch_V
;	  IF string entered
;	     Build ASCIIZ string for next call (CALL Build_String)
;	     Verify DBCS and setup FCB (CALL Get_11_Characters)
;	     Command_Line = YES
;		IF error
;		  Invalid label message
;		  Fatal_Error = YES
;		ENDIF
;	  ENDIF
;	ENDIF
;	IF /AUTOTEST
;	  or	SwitchMap,Switch_AUTOTEST
;	ENDIF
;
;	IF /F
;	  or	SwitchMap,Switch_F
;	  or	Size_Map,Item_Tag
;	ENDIF
;	IF /Z	(only if assembled)
;	  or	SwitchMap,Switch_Z
;	ENDIF
;	ret
;*****************************************************************************

Procedure Interpret_Parse

	push	ds				;Save segment
	push	si				;Restore SI for parser
	push	cx
	push	di

	Set_Data_Segment			;Set DS,ES to Data segment

; See if user put /? on command line.

	cmp	Switch_Buffer.Switch_Pointer,offset Switch_?_Control.Keyword
	jne	@F				; skip if not on
	call	Display_Options			; give the message
	mov     Fatal_Error, Yes		; flag get out now
	jmp	Interpret_Parse_Exit		;  and leave this routine
@@:
	;Have drive letter?

	cmp	byte ptr Drive_Letter_Buffer.Drive_Type,Type_Drive

	JNE	$$IF36				;Yes, save info
						;Get drive entered
	mov	al,Drive_Letter_Buffer.Drive_Number
	dec	al				;Make it 0 based
	mov	Drive,al			; "  "	  "  "
	add	al,'A'				;Make it a drive letter
	mov	DriveLetter,al			;Save it

$$IF36:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_U_Control.Keyword
	jne	@F
	mov	Switch_U_Control.Keyword,20h
	or	SwitchMap,Switch_U

@@:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_Q_Control.Keyword
	jne	@F
	mov	Switch_Q_Control.Keyword,20h
	or	SwitchMap,Switch_Q

@@:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_1_Control.Keyword
	JNE	$$IF38
	mov	Switch_1_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_1

$$IF38:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_4_Control.Keyword
	JNE	$$IF40
	mov	Switch_4_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_4

$$IF40:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_8_Control.Keyword
	JNE	$$IF42
	mov	Switch_8_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_8

$$IF42:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_S_Control.Keyword
	JNE	$$IF44
	mov	Switch_S_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_S

$$IF44:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_Backup_Control.Keyword
	JNE	$$IF46
	mov	   Switch_Backup_Control.Keyword,20h ;remove switch from table
	or	   SwitchMap,Switch_Backup

$$IF46:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_Select_Control.Keyword
	JNE	$$IF48
	mov	Switch_Select_Control.Keyword,20h ;remove switch from table
	or	SwitchMap,Switch_Select

$$IF48:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_B_Control.Keyword
	JNE	$$IF50
	mov	Switch_B_Control.Keyword,20H
	or	SwitchMap,Switch_B

$$IF50:
	cmp	Switch_Num_Buffer.Switch_Num_Pointer, \
		offset es:Switch_T_Control.Keyword

	JNE	$$IF52
	mov	Switch_T_Control.Keyword,20h ;remove switch from table
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0 ;Init for next switch
	test	SwitchMap,Switch_T		;Don't allow if switch already
	JNZ	$$IF53				; entered

	or	SwitchMap,Switch_T
						;Get entered tracks
	mov	ax,Switch_Num_Buffer.Switch_Number_Low
	mov	TrackCnt,ax			;1024 or less, so always dw
	JMP SHORT $$EN53

$$IF53:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN53:
$$IF52:
	cmp	Switch_Num_Buffer.Switch_Num_Pointer, \
		offset Switch_N_Control.Keyword
	JNE	$$IF57
	mov	Switch_N_Control.Keyword,20h ;remove switch from table
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0 ;Init for next switch
	test	SwitchMap,Switch_N		;Make sure switch not already

	JNZ	$$IF58				; entered
	or	SwitchMap,Switch_N
	mov	ax,Switch_Num_Buffer.Switch_Number_Low ;Get entered tracks
	xor	ah,ah				;clear high byte
	mov	NumSectors,ax			;Save tracks per sector
	JMP SHORT $$EN58

$$IF58:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN58:
$$IF57:
	cmp	Switch_String_Buffer.Switch_String_Pointer, \
		offset Switch_V_Control.Keyword
	JNE	$$IF62				;If /v and haven't already done

	mov	   Switch_String_Buffer.Switch_String_Pointer,0 ;Init for next switch
	mov	   Switch_V_Control.Keyword,20h ;remove switch from table
	test	SwitchMap,Switch_V		; it - Only allow one /V entry

	JNZ	$$IF63
	or	SwitchMap,Switch_V	;Set /v indicator
	mov	ds,Switch_String_Buffer.Switch_String_Seg ;Get string address

	assume	ds:nothing

; M009 - Begin
;

	cld
	mov	cx,si				; Save end of /V parameter
	mov	si,es:Switch_String_Buffer.Switch_String_Off
	cmp	byte ptr ds:[si],None	;Is there a string there?

	jne	GotAString

	push	es
	
	mov	di,Command_Old_ptr
	sub	cx,di				; cx = length of whole /v

	mov	es,es:PSP_Segment
	
	mov	al,':'
	repnz	scasb
	pop	es

	push	es
	pop	ds
	assume	DS:DATA,ES:DATA
	jcxz	$$IF64

	mov	Vol_Label_Buffer,0	
	mov	Command_Line,YES
	jmp	short $$IF64
;	JE	$$IF64				;Yep
;M009 - End

GotAString:
	assume	DS:nothing
	mov	di,offset es:Vol_Label_Buffer ;Point at buffer to move string
	mov	cx,Label_Length+1		;Max length of string
	rep	movsb				;This will copy string & always
						; leave ASCIIZ end in buffer,
						; which is init'd to 13 dup(0)
	push	es
	pop	ds				;Set DS,ES to Data segment
	assume	DS:DATA,ES:DATA

	mov	si,offset Vol_Label_Buffer	;Point at string
	mov	Command_Line,YES		;Set flag indicating vol label
	call	Get_11_Characters		;Check DBCS and build FCB

	JNC	$$IF65				;Bad DBCS setup
	Message msgBadVolumeID		;Tell user
	mov	Fatal_Error,YES			;Indicate time to quit

$$IF65:
$$IF64:
	JMP	SHORT $$EN63
$$IF63:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN63:
$$IF62:
	cmp	Switch_Buffer.Switch_Pointer, \
		offset Switch_Autotest_Control.Keyword
	JNE	$$IF71
						;remove switch from table
	mov	Switch_Autotest_Control.Keyword,20h
	or	SwitchMap,Switch_Autotest

$$IF71:

IF ShipDisk
						;/Z switch?
	cmp	Switch_Buffer.Switch_Pointer, \
		offset Switch_Z_Control.Keyword
	JNE	$$IF73				;yes

	mov	Switch_Z_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_Z		;signal switch found

$$IF73:
ENDIF

	cmp	Switch_String_Buffer.Switch_Pointer, \
		offset Switch_F_Control.Keyword
	JNE	$$IF75
	mov	Switch_F_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	test	SwitchMap,Switch_F		; it - do this because SysParse

	JNZ	$$IF76				; reuses string buff each time
	or	SwitchMap,Switch_F
						; Indicate what size
	mov	al,Switch_String_Buffer.Switch_String_Item_Tag
	or	SizeMap,al
	JMP	SHORT $$EN76

$$IF76:
	Message msgSameSwitch
	mov	Fatal_Error,Yes
$$EN76:
$$IF75:
Interpret_Parse_Exit:

	pop	di				;Restore parse regs
	pop	cx
	pop	si
	pop	ds
	ret

Interpret_Parse endp

;*****************************************************************************
;Routine name: Display_Options
;*****************************************************************************
;
;Description: Display the options help message on standard output.
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/2/90	       c-PaulB
;
;Input:  No value passed
;
;Output: No value returned
;
;*****************************************************************************

Procedure Display_Options

DO_Loop:
	Message	msgOptions			; display the options
	cmp	word ptr [msgOptions], MSG_OPTIONS_LAST	; last msg?
	je	DO_Done				; done if so
	inc	word ptr [msgOptions]		; else get next msg
	jmp	short DO_Loop			;  and go do it
DO_Done:
	ret

Display_Options endp

;*****************************************************************************
;Routine name: Validate_Target_Drive
;*****************************************************************************
;
;Description: Control routine for validating the specified format target drive.
;	      If any of the called routines find an error, they will print
;	      message and terminate program, without returning to this routine
;
;Called Procedures: Check_Target_Drive
;		    Check_For_Network
;		    Check_Translate_Drive
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	CALL Check_Target_Drive
;	IF !Fatal_Error
;	   CALL Check_For_Network
;	   IF !Fatal_Error
;	      CALL Check_Translate_Drive
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Validate_Target_Drive

	call	Check_Target_Drive		;See if valid drive letter
	cmp	Fatal_Error,YES 		;Can we continue?
	JE	$$IF80				;Yep
	call	Check_For_Network		;See if Network drive letter
	cmp	Fatal_Error,YES			;Can we continue?

	JE	$$IF80				;Yep
	call	Check_Translate_Drive		;See if Subst, Assigned
$$IF80: 					;- Fatal_Error passed back
	ret

Validate_Target_Drive endp

;*****************************************************************************
;Routine name: Check_Target_Drive
;*****************************************************************************
;
;Description: Check to see if valid DOS drive by checking if drive is
;	      removable. If error, the drive is invalid. Save default
;	      drive info.
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: BIOSFile = default drive letter
;	 DOSFile = default drive letter
;	 CommandFile = default drive letter
;	 Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	Get default drive (INT 21h, AH = 19h)
;	Convert it to drive letter
;	Save into BIOSFile,DOSFile,CommandFile
;	See if drive removable (INT 21h, AX=4409h IOCtl)
;	IF error - drive invalid
;	   Display Invalid drive message
;	   Fatal_Error= YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_Target_Drive

	DOS_Call Get_Default_Drive		;Find the current drive
	add	al,'A'				;Convert to drive letter
	mov	BIOSFile,al			;Put it into path strings
	mov	DOSFile,al
	mov	CommandFile,al
	mov	bl,Drive			;Set up for next call
	inc	bl				;A=1,B=2 for IOCtl call
	mov	al,09h				;See if drive is local
	DOS_Call IOCtl				;-this will fail if bad drive

	JNC	$$IF84				;CY means invalid drive
	Extended_Message			;Print message
	mov	Fatal_Error,Yes			;Indicate error
$$IF84:
	ret					;And we're outa here

Check_Target_Drive endp

;*****************************************************************************
;Routine name: Check_For_Network
;*****************************************************************************
;
;Description: See if target drive isn't local, or if it is a shared drive. If
;	      so, exit with error message. The IOCtl call is not checked for
;	      an error because it is called previously in another routine, and
;	      invalid drive is the only error it can generate. That condition
;	      would not get this far
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Drive
;	   Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	See if drive is local (INT 21h, AX=4409 IOCtl)
;	IF not local
;	   Display network message
;	   Fatal_ERROR = YES
;	ELSE
;	   IF  8000h bit set on return
;	      Display assign message
;	      Fatal_Error = YES
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_For_Network

	mov	bl,Drive			;Drive is 0=A, 1=B
	inc	bl				;Get 1=A, 2=B for IOCtl call
	mov	al,09h				;See if drive is local or remote
	DOS_CALL IOCtl				;We will not check for error
	test	dx,Net_Check			;if (x & 1200H)(redir or shared);

	JZ	$$IF86				;Found a net drive
	Message MsgNetDrive			;Tell 'em
	mov	Fatal_Error,Yes			;Indicate bad stuff
	JMP	SHORT $$EN86			;Local drive, now check assign

$$IF86:
	test	dx,Assign_Check			;8000h bit is bad news
	JZ	$$IF88				;Found it

	Message MsgAssignedDrive		;Tell error
	mov	Fatal_Error,Yes			;Indicate bad stuff

$$IF88:
$$EN86:
	ret

Check_For_Network endp

;*****************************************************************************
;Routine name: Check_Translate_Drive
;*****************************************************************************
;
;Description: Do a name translate call on the drive letter to see if it is
;	      assigned by SUBST or ASSIGN
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Drive
;	   Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	Put drive letter in ASCIIZ string "d:\",0
;	Do name translate call (INT 21)
;	IF drive not same
;	   Display assigned message
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_Translate_Drive

	mov	bl,Drive			;Get drive
	add	byte ptr [TranSrc],bl		;Make string "d:\"
	mov	si,offset TranSrc		;Point to translate string
	push	ds				;Set ES=DS (Data segment)
	pop	es				;     "  "	"  "
	mov	di,offset Command_Line_Buffer	;Point at output buffer
	DOS_Call xNameTrans			;Get real path
	mov	bl,byte ptr [TranSrc]		;Get drive letter from path
	cmp	bl,byte ptr Command_Line_Buffer ;Did drive letter change?

	JE	$$IF91				;If not the same, it be bad
	Message MsgAssignedDrive		;Tell user
	mov	Fatal_Error,Yes			;Setup error flag

$$IF91:
	ret

Check_Translate_Drive endp

;*****************************************************************************
;Routine name: Hook_CNTRL_C
;*****************************************************************************
;
;Description: Change the interrupt handler for INT 13h to point to the
;	      ControlC_Handler routine
;
;Called Procedures: None
;
;Change History: Created	4/21/87 	MT
;
;Input: None
;
;Output: None
;
;Psuedocode
;----------
;
;	Point at ControlC_Handler routine
;	Set interrupt handler (INT 21h, AX=2523h)
;	ret
;*****************************************************************************

Procedure Hook_CNTRL_C

	mov	al,23H				;Specify CNTRL handler
	mov	dx, offset ControlC_Handler	;Point at it
	push	ds				;Save data seg
	push	cs				;Point to code segment
	pop	ds				;
	DOS_Call Set_Interrupt_Vector		;Set the INT 23h handler
	pop	ds				;Get Data degment back
	ret

Hook_CNTRL_C endp

;=========================================================================
; Check_For_Invalid_Drive	: This routine checks the AX received by
;				  FORMAT on its entry.	This value will
;				  tell us if we are attempting to format
;				  a JOINED drive.
;
;	Inputs	: Org_AX	- AX on entry to FORMAT
;
;	Outputs : Fatal_Error	- Yes if AL contained FFh
;=========================================================================

Procedure Check_For_Invalid_Drive

	push	ax				;save ax
	cmp	FAT_Flag,Yes			;FAT system?
	JNE	$$IF93				;yes
	mov	ax,Org_AX			;get its org. value
	cmp	al,0ffh 			;Invalid drive?
	JNE	$$IF94				;yes
	mov	Fatal_Error,YES 		;flag an error
	mov	ax,Invalid_Drive		;error message
	Extended_Message			;tell error

$$IF94:
$$IF93:
	pop	ax
	ret

Check_For_Invalid_Drive endp


;=========================================================================
; Determine_FAT_Non_FAT 	- This routine determines whether or
;				  not a device is formatted to a FAT
;				  specification versus a Non-FAT
;				  specification.
;
;	Inputs	: DX - Pointer to device parameters buffer
;
;	Outputs : DeviceParameters - buffer containing BPB.
;
;	Date	: 11/6/87
;=========================================================================

Procedure Determine_FAT_Non_FAT
;
; M031: With memory card media, a get default BPB requires a media
; in the drive. At this point, we haven't outputted the "Insert disk ..."
; message. This code was also buggy because if the GetDeviceParameters
; failed, FAT_Flag was not properly initialized (it is a DB ?, so it would
; have been equivalent to No). I patched the code to first check if there is
; a CMCDD disk. If so, we will set FAT_flag to Yes.

	push	ax				;save regs
	push	dx

	call	CheckCMCDD			; M033
	cmp	CMCDDFlag, Yes
	je	$$IF98				; M031

	lea	dx, deviceParameters		;point to buffer
	mov	deviceParameters.DP_SpecialFunctions, 0	 ;get default BPB
	call	GetDeviceParameters		;make the call
	JC	$$IF97				;no error occurred

						;non-FAT system?
	cmp	byte ptr DeviceParameters.DP_BPB.BPB_NumberOfFATS,00h
	JNE	$$IF98				;yes
			; Can't create recovery file or do quick
			; format for non FAT disks

	or	SwitchMap,Switch_U
	and	Switchmap, NOT Switch_Q

	mov	FAT_Flag,No			;signal system non-FAT
	mov	ax,5f07h			;allow access to disk
	mov	dl,Drive			;get 0 based driver number
	int	21h				;allow access to the drive

	JMP	SHORT $$EN98			;FAT system
$$IF98:
	mov	FAT_Flag,Yes			;flag FAT system

$$EN98:
$$IF97:

	pop	dx				;restore regs
	pop	ax
	ret

Determine_FAT_Non_FAT	endp

;M033 - Begin
;=========================================================================
; CheckCMCDD	 		- This routine determines whether or
;				  not the drive is a CMCDD drive.
;
;	Inputs	: None
;
;	Outputs : CMCDDFlag is Yes iff we are on a CMCDD drive
;
;	Trashes : AX, BX, CX, DX
;
;	Date	: 6/5/91
;=========================================================================
procedure CheckCMCDD

	mov	ax,(IOCTL shl 8) or IOCTL_QUERY_BLOCK ; Check if function supported
	mov	bl, Drive
	inc	bl				; 1 based
	mov	cx,(RAWIO shl 8) or 73h		; Determine if get_system_info
						; exist (only CMCDD has it).
	int	21h				; see if CMCDD
	jc	notCMCDD

	mov	CMCDDFlag, Yes
	ret

notCMCDD:
	mov	CMCDDFlag, No
	ret

CheckCMCDD	endp
;M033 - end

; =========================================================================

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forlabel.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;*****************************************************************************
;*****************************************************************************
;
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: FORLABEL.SAL
;
;		Interpret_Parse
;			|
;*			|
;ĿĿ|Ŀ Ŀ
;VolIDôGet_New_LabelĴGet_11_Characters´Change_Blanks
;  ٳ
;					    Ŀ
;					    ôSkip_Blanks
;					    
;					    ĿĿ
;					    ôCheck_DBCS_OverrunôCheck_DBCS_Character
;					    
;					    Ŀ
;					    Copy_FCB_String
;					     
;*****************************************************************************
;*****************************************************************************

;
;----------------------------------------------------------------------------
;
; m023 : Bug #5253. get volume label function checks for carry flag
;		after doing a input flush call. But this function call does
;		not return aything in the carry flag.
;
;----------------------------------------------------------------------------
;
data	segment public para 'DATA'

Bad_Char_Table	label	byte			 ;table of invalid vol ID chars
	db	"*"
	db	"?"
	db	"["
	db	"]"
	db	":"
	db	"<"
	db	"|"
	db	">"
	db	"+"
	db	"="
	db	";"
	db	","
	db	"/"
	db	"\"
	db	'.'
	db	'"'
	db	"("
	db	")"
	db	"&"
	db	"^"
Bad_Char_Table_Len	equ	$-Bad_Char_Table ;length of table

DBCS_Vector_Off dw 0
DBCS_Vector_Seg dw 0


data	ends

.xlist
INCLUDE FORCHNG.INC
INCLUDE FORMACRO.INC
INCLUDE SYSCALL.INC
INCLUDE FOREQU.INC
INCLUDE FORSWTCH.INC
.list

;
;*****************************************************************************
; Equates
;*****************************************************************************
;

None	equ	0
StdIn	equ	0
StdOut	equ	1
StdErr	equ	2
Tab	equ	09h
Label_Buffer_length equ 80h
Create_Worked equ 0


;
;*****************************************************************************
; External Data Declarations
;*****************************************************************************
;

	Extrn	SwitchMap:Word
	Extrn	Switch_String_Buffer:Byte
	Extrn	VolFCB:Byte
	Extrn	MsgBadCharacters:Byte
	Extrn	MsgLabelPrompt:Byte
	Extrn	MsgBadVolumeID:Byte
	Extrn	MsgCRLF:Byte
	Extrn	VolNam:Byte
	Extrn	Vol_Label_Count:Byte
	Extrn	VolDrive:Byte
	Extrn	Drive:Byte
	Extrn	Command_Line:Byte
	Extrn	Vol_Label_Buffer:Byte
	Extrn	DelDrive:Byte
	Extrn	DelFCB:Byte

code	segment public para 'CODE'
	assume	cs:code,ds:data	

;************************************************************************************************
;Routine name Volid
;************************************************************************************************
;
;Description: Get volume id from command line /V:xxxxxxx if it is there, or
;	      else prompt user for volume label, parse the input. At this
;	      point setup the FCB and create the volume label. If failure,
;	      prompt user that they entered bad input, and try again.
;
;	      Note: This routine in 3.30 and prior used to check for /V
;		    switch. Volume labels are always required now, so /V
;		    is ignored, except to get volume label on command line.
;
;Called Procedures: Message (macro)
;		    Get_New_Label
;
;Change History: Created	5/1/87	       MT
;
;Input: Switch_V
;	Command_Line = YES/NO
;
;Output: None
;
;Psuedocode
;----------
;
;	Save registers
;	IF /V switch entered
;	   IF /v:xxxxx form not entered
;	      CALL Get_New_Label     ;Return string in Volume_Label
;	   ENDIF
;	ELSE
;	   CALL Get_New_Label	  ;Return string in Volume_Label
;	ENDIF
;	DO
;	   Create volume label
;	LEAVE Create Ok
;	   Display Bad Character message
;	   CALL Get_New_Label	;Return string in Volume_Label
;	ENDDO
;	Restore registers
;	ret
;*****************************************************************************

Procedure Volid

	push	ds				;Save registers
	push	si

	test	SwitchMap,Switch_Select		; Was format spawned by the
	jnz	LabelDone			; DOS 5.x install program

	test	SwitchMap,Switch_V		;Was /V entered
	je	AskForLabel			;Yes, see if label entered also
; M009 - Begin
	cmp	Command_Line,No			;Is there a string there?
	je	AskForLabel			;Yes
	cmp	Vol_Label_Buffer,0		;Is it /V:""
	je	LabelDone
	jmp	short GotLabel
; M009 - End

AskForLabel:
	call	Get_New_Label			;Go get volume label from user

GotLabel:
	mov	dl,drive			;Get drive number  A=0
	inc	dl				;Make it 1 based
	mov	DelDrive,dl			;Put into FCBs
	mov	VolDrive,dl
	mov	dx,offset DelFCB		;Point at FCB to delete label
	DOS_CALL FCB_Delete			;Do the delete
	mov	dx,offset VolFCB		;Point at FCB for create
	DOS_CALL FCB_Create			;Go create it
	cmp	al,Create_Worked		;See if the create worked
	jne	LabelDone

	mov	dx,offset VolFCB		;Point to the FCB created
	DOS_Call FCB_Close			;Close the newly created FCB

LabelDone:
	pop	si				;Restore registers
	pop	ds
	ret

Volid	endp

;*****************************************************************************
;Routine name: Get_New_Label
;*****************************************************************************
;
;Description: Prompts, inputs and verifies a volume label string. Continues
;	      to prompt until valid vol label is input
;
;Called Procedures: Message (macro)
;		    Build_String
;		    Get_11_Characters
;
;Change History: Created	3/18/87 	MT
;
;Input: None
;
;Output: Volume_Label holds
;
;Psuedocode
;----------
;
;	DO
;	   Display  new volume label prompt
;	   Input vol label
;	   IF No error (NC)
;	      Build Asciiz string with label, pointer DS:SI (CALL Build_String)
;	      Call Get_11_Characters (Error returned CY)
;	   ENDIF
;	LEAVE no error (NC)
;	   Display label error
;	ENDDO
;	ret
;*****************************************************************************

Procedure Get_New_Label

$$DO8:						;Loop until we get good one
	Message msgLabelPrompt			;Prompt to input Vol label
						;clean out input
	mov	ax,(Std_Con_Input_Flush shl 8) + 0
	int	21h
	mov	dx,offset Vol_Label_Count	;beginning of buffer
	mov	ah,Std_Con_String_Input 	;get input
	int	21h
						;clean out input
	mov	ax,(Std_Con_Input_Flush shl 8) + 0
	int	21h
;
; m023 - this function call does not return carry/nocaryy
;
;	JC	$$IF9				;Read ok if NC, Bad sets CY

	mov	si,offset Vol_Label_Buffer	;Get pointer to string
	call	Get_11_Characters		;Handle DBCS stuff on input

$$IF9:						;Ret CY if error
	JNC $$EN8				;Done if NC
	Message MsgCRLF 			;next line
	Message msgBadVolumeID			;Tell user error

	JMP	SHORT $$DO8			;Try again
$$EN8:
	Message MsgCRLF 			;next line
	ret

Get_New_Label endp

;*****************************************************************************
;Routine name: Get_11_Characters
;*****************************************************************************
;
;Description: Handle DBCS considerations, and build FCB to create vol label
;
;
;Called Procedures: Change_Blanks
;		    Skip_Blanks
;		    Check_DBCS_Overrun
;		    Copy_FCB_String
;
;Change History: Created	5/12/87 	MT
;
;Input: DS:SI = Asciiz string containing volume label input
;	Command_Line = YES/NO
;
;Output: Volname will contain an 8.3 volume label in FCB
;	 CY set on invalid label
;
;Psuedocode
;----------
;	Save regs used
;	Scan line replacing all DBCS blanks with SBCS  (CALL_Change_Blanks)
;	Skip over leading blanks (Call Skip_Blanks)
;	IF leading blanks ,AND
;	IF Command line
;	   Indicate invalid label (STC)
;	ELSE
;	   See if DBCS character at 11th byte (CALL Check_DBCS_Overrun)
;	   IF DBCS character at 11th byte
;	      Indicate invalid label (STC)
;	   ELSE
;	   Put string into FCB (CALL Copy_FCB_STRING)
;	   CLC
;	   ENDIF
;	ENDIF
;	Restore regs
;	ret
;*****************************************************************************

Procedure Get_11_Characters

	call	Change_Blanks			;Change DBCS blanks to SBCS
	call	Skip_Blanks			;Skip over leading blanks
	JNC	$$IF13				;Find leading blanks?

	cmp	Command_Line,YES		;Is this command line input?
	JNE	$$IF13				;Yes

	stc					;Indicate error (CY set)
	JMP	SHORT $$EN13			;Leading blanks ok

$$IF13:
	call Check_DBCS_Overrun 		;Is DBCS char at 11th byte?
	JNC	$$IF15				;Yes
	stc					;Indicate invalid label
	JMP	SHORT $$EN15			;No, good characters

$$IF15:
	call	Copy_FCB_String 		;Put string into FCB
	clc					;Indicate everything A-OK!

$$EN15:
$$EN13:
	ret

Get_11_Characters endp

;*****************************************************************************
;Routine name: Change_Blanks
;*****************************************************************************
;
;Description: Replace all DBCS blanks with SBCS blanks, end string with
;	      Asciiz character if one doesn't already exist
;
;Called Procedures: Check_DBCS_Character
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = String containing volume label input
;
;Output: DS:SI = ASCIIZ string with all DBCS blanks replaced with 2 SBCS blanks
;
;
;Psuedocode
;----------
;
;	Save pointer to string
;	DO
;	LEAVE End of string (0)
;	   See if DBCS character (Check_DBCS_Character)
;	   IF CY (DBCS char found)
;	      IF first byte DBCS blank, AND
;	      IF second byte DBCS blank
;		 Convert to SBCS blanks
;	      ENDIF
;	      Point to next byte to compensate for DBCS character
;	   ENDIF
;	ENDDO
;	Tack on ASCIIZ character to string
;	Restore pointer to string
;
;*****************************************************************************

Procedure Change_Blanks

	push	si				;Save pointer to string
	push	cx
	push	ax
	xor	cx,cx

$$DO19: 					;Do while not CR
	cmp	byte ptr [si],Asciiz_End	;Is it end of string?
	JE	$$EN19				;All done if so

	cmp	byte ptr [si],CR		;Is it CR?
	JE	$$EN19				;Exit if yes,end of label

	inc	cx				;Count the character
	cmp	cx,Label_Buffer_Length		;Reached max chars? (80h)
	JE	$$EN19				;Exit if so

	mov	   al,byte ptr [si]		;Get char to test for DBCS
	call	Check_DBCS_Character		;Test for dbcs lead byte
	JNC	$$IF21				;We have a lead byte

	cmp	byte ptr [si],DBCS_Blank_hi	;Is it a lead blank?
	JNE	$$IF22				;If a dbcs char

	cmp	byte ptr [si+1],DBCS_Blank_lo	;Is it an Asian blank?
	JNE	$$IF22				;If an Asian blank

	mov	byte ptr [si+1],Blank		;set up moves
	mov	byte ptr [si],Blank		;to replace

$$IF22:
	inc	si				;Point to dbcs char

$$IF21: 					;End lead byte test
	inc	si				;Point to si+1
	JMP	SHORT $$DO19			;End do while

$$EN19:
	mov	byte ptr [si],Asciiz_End	;Mark end of string
	pop	ax				;Restore regs
	pop	cx
	pop	si
	ret					;return to caller

Change_Blanks endp

;*****************************************************************************
;Routine name: Skip_Blanks
;*****************************************************************************
;
;Description: Scan ASCIIZ string for leading blanks, return pointer to first
;	      non-blank character. Set CY if blanks found
;
;Called Procedures: None
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = ASCIIZ string containing volume label input
;
;Output: DS:SI = Input string starting at first non-blank character
;	 CY set if blanks found
;
;
;
;Psuedocode
;----------
;
;	Save original pointer, DI register
;	DO
;	  Look at character from string
;	LEAVE End of string (0)
;	  IF character is blank,OR
;	  IF character is tab
;	     INC pointer (SI)
;	     Indicate blank
;	  ELSE
;	     Indicate non-blank
;	  ENDIF
;	ENDDO non-blank
;	Get back pointer
;	Cmp string pointer to original pointer
;	IF NE
;	   STC
;	ELSE
;	   CLC
;	ENDIF
;	ret
;*****************************************************************************

Procedure Skip_Blanks

	push	di				;Preserve DI, just in case
	push	si				;Save pointer to string

$$DO26: 					;Look at entire ASCIIZ string
	cmp	byte ptr [si],ASCIIZ_End	;End of string?
	JE	$$EN26				;Yep, exit loop

	cmp	byte ptr [si],Blank		;Find a blank?
	JE	$$LL28				;Yes

	cmp	byte ptr [si],TAB		;Is it tab?
	JNE	$$IF28				;Yes

$$LL28:
	inc	si				;Bump pointer to next character
	clc					;Indicate found blank
	JMP	SHORT $$EN28			;Not blank or tab

$$IF28:
	stc					;Force exit

$$EN28:
	JNC	$$DO26				;Go look at next character

$$EN26:
	pop	di				;Get back original pointer
	cmp	di,si				;Are they the same?
	JE	$$IF32				;If not equal blanks were found
	stc					;Set CY
	JMP	SHORT $$EN32			;No leading blanks found

$$IF32:
	clc					;Clear CY

$$EN32:
	pop	di				;Restore DI
	ret

Skip_Blanks endp


;*****************************************************************************
;Routine name: Copy_FCB_String
;*****************************************************************************
;
;Description: Build an 11 character string in the FCB from ASCIIZ string
;	      If nothing entered, than terminated with 0. Also add drive
;	      number in FCB
;
;Called Procedures: None
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = String containing volume label input
;
;Output: VOLNAM is filled in with Volume label string
;
;
;
;Psuedocode
;----------
;
;	Save regs
;	Init VolNam to blanks
;	DO
;	LEAVE if character is end of ASCIIZ string
;	   Mov character to FCB
;	   Inc counter
;	ENDDO all 11 chars done
;	Restore regs
;*****************************************************************************

Procedure Copy_FCB_String

	push	di
	push	cx
	push	si				;Save pointer to string
	cld					;Set string direction to up
	mov	di,offset Volnam		;Init FCB field to blanks
	mov	al,Blank
	mov	cx,Label_Length
	rep	stosb
	pop	si				;Get back pointer to string
	mov	di,offset VolNam		;Point at FCB field
	xor	cx,cx				;Init counter

$$DO35: 					;Copy characters over
	cmp	byte ptr [si],ASCIIZ_End	;End of String?
	JE	$$EN35				;Yes, don't copy - leave blanks

	movsb					;Nope, copy character
	inc	cx				;Bump up count
	cmp	cx,Label_Length			;Have we moved 11?
	JNE	$$DO35				;Quit if so
$$EN35:
	pop	cx
	pop	di
	ret

Copy_FCB_String endp


;*****************************************************************************
;Routine name: Check_DBCS_Overrun
;*****************************************************************************
;
;Description: Check 11th byte, if the string is that long, to see
;	      if it is a DBCS character that is split down the middle. Must
;	      scan entire string to properly find DBCS characters, due to
;	      the fact a second byte of a DBCS character can fall into
;	      the range of the first byte environment vector, and thus look
;	      like a DBCS char when it really isn't
;
;Called Procedures: Check_DBCS_Character
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = String containing volume label input
;
;Output: CY set if DBCS character at bytes 11-12 in string
;
;*****************************************************************************

Procedure Check_DBCS_Overrun

	push	si				;Save pointer
	push	ax				;Save registers
	push	cx				;  "  "   "  "
	mov	cx,si				;Get start of string
	add	cx,Label_Length 		;Find where to check for overrun

Check_DBCS_OverRun_Cont:			;Scan string for DBCS chars

	cmp	byte ptr [si],ASCIIZ_End	;End of string?
	je	DBCS_Good_Exit			;Yep

	mov	al,[si]				;Get character for routine
	call	Check_DBCS_Character		;See if DBCS leading character
	JNC	$$IF38				;DBCS if CY set

	inc	si				;Next byte to handle DBCS
	cmp	si,cx				;Is DBCS char spanning 11-12?
	JNE	$$IF39				;truncate string

	mov	byte ptr [si-1],20h;blank it out
	mov	byte ptr [si],20h	;blank it out
	jmp	SHORT DBCS_Good_Exit;exit

$$IF39:
	JMP	SHORT $$EN38			;Not DBCS character

$$IF38:
	mov	al,[si] 			;Get character for routine
	call	Scan_For_Invalid_Char		;See if invalid vol ID char
	jc	DBCS_Bad_Exit			;Bad char entered - exit

$$EN38:
	inc	   si				;Point to next character
	jmp	   Check_DBCS_OverRun_Cont	;Continue looping

DBCS_Good_Exit:
	clc					;Signal no error
	jmp	SHORT DBCS_Exit			;Exit routine

DBCS_Bad_Exit:
	stc					;Signal error

DBCS_Exit:
	pop	cx				;Restore registers
	pop	ax
	pop	si				;Restore string pointer
	ret

Check_DBCS_Overrun endp

;*****************************************************************************
;Routine name: Check_DBCS_Character
;*****************************************************************************
;
;Description: Check if specified byte is in ranges of DBCS vectors
;
;Called Procedures: None
;
;Change History: Created	6/12/87 	MT
;
;Input: AL = Character to check for DBCS lead character
;	DBCS_Vector = YES/NO
;
;Output: CY set if DBCS character
;	 DBCS_VECTOR = YES
;
;
;Psuedocode
;----------
;	Save registers
;	IF DBCS vector not found
;	   Get DBCS environmental vector (INT 21h
;	   Point at first set of vectors
;	ENDIF
;	SEARCH
;	LEAVE End of DBCS vectors
;	EXITIF Character > X1,AND  (X1,Y1) are environment vectors
;	EXITIF Character < Y1
;	  STC (DBCS character)
;	ORELSE
;	   Inc pointer to next set of vectors
;	ENDLOOP
;	   CLC (Not DBCS character)
;	ENDSRCH
;	Restore registers
;	ret
;*****************************************************************************

Procedure Check_DBCS_Character

	push	ds				;Save registers
	push	si
	push	ax
	push	ds
	pop	es				;Establish addressability
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?
	push	ax				;Save input character
	JE	$$IF43				;Nope

	mov	al,0				;Get DBCS environment vectors
	DOS_Call Hongeul			;  "  "    "  "
	mov	byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector
	mov	es:DBCS_Vector_Off,si		;Save the vector
	mov	ax,ds
	mov	es:DBCS_Vector_Seg,ax

$$IF43: 					; for next time in
	pop	ax				;Restore input character
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer
	mov	ds,si
	mov	si,es:DBCS_Vector_Off

$$DO45: 					;Check all the vectors
	cmp	word ptr ds:[si],End_Of_Vector ;End of vector table?
	JE	$$EN45				;Yes, done

	cmp	al,ds:[si]			;See if char is in vector
	JNAE	$$IF45				;If >= to lower, and

	cmp	al,ds:[si+1]			; =< than higher range
	JNBE	$$IF45				; then DBCS character

	stc					;Set CY to indicate DBCS
	JMP	SHORT $$SR45			;Not in range, check next

$$IF45:
	add	si,DBCS_Vector_Size		;Get next DBCS vector
	JMP	SHORT $$DO45			;We didn't find DBCS char

$$EN45:
	clc					;Clear CY for exit

$$SR45:
	pop	ax				;Restore registers
	pop	si
	pop	ds				;Restore data segment
	ret

Check_DBCS_Character endp

;=========================================================================
; Scan_For_Invalid_Char : This routine scans the bad character table
;			  to determine if the referenced character is
;			  invalid.
;
;	Inputs	: Bad_Char_Table	- Table of bad characters
;		  Bad_Char_Table_Len	- Length of table
;		  AL			- Character to be searched for
;
;	Outputs : CY			- Bad character
;		  NC			- Character good
;=========================================================================

Procedure Scan_For_Invalid_Char

	push	ax				;save ax
	push	cx				;save cx
	push	di				;save di

	lea	di,Bad_Char_Table		;point to bad character table
	mov	cx,Bad_Char_Table_Len		;get its length
	repnz	scasb				;scan the table
	clc					;Assume right
	jne	CharacterSet			;Yes - a good character

	stc					;flag a bad character

CharacterSet:

	pop	di				;restore di
	pop	cx				;restore cx
	pop	ax				;restore ax

	ret

Scan_For_Invalid_Char	endp

;=========================================================================

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\formacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */







;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

Message macro   Message_Name                    ;                               ;AN000;
                                                ;
        mov     dx,offset data:Message_Name     ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Parse_Message macro                             ;                               ;AN000;

                                                ;
        push    ds
        mov     dx,data
        mov     ds,dx
        mov     word ptr Parse_Error_Msg,ax     ;                               ;AN000;
        mov     dx,offset Parse_Error_Msg       ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds                              ;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Extended_Message macro                          ;                               ;AN000;
                                                ;

        push    ds
        mov     dx,data
        mov     ds,dx
        mov     word ptr Extended_Error_Msg,ax       ;                               ;AN000;
        mov     dx,offset data:Extended_Error_Msg    ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds
        endm                                    ;                               ;AN000;

;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure       macro   Proc_Name

Public  Proc_Name
Proc_Name    proc

        endm
;-----------------------------------------------------------------------------

DOS_Call        macro   Function

        mov     ah,Function
        int     21h

        endm
;-----------------------------------------------------------------------------

Popff   macro

        jmp     $+3
        iret
        push    cs
        call    $-2

        endm


;-----------------------------------------------------------------------------

Set_Data_Segment     macro

        push    ax
        mov     ax,data                         ;Point to data segment
        mov     ds,ax                           ;
        push    ds
        pop     es
        pop     ax

assume  ds:data,es:data

        endm




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\format.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;page	 84,132
;
;	 SCCSID	= @(#)format.asm 1.26 85/10/20
;	 SCCSID	= @(#)format.asm 1.26 85/10/20
; =======================================================================
;
;	 86-DOS	FORMAT DISK UTILITY
;
;	 This routine formats a	new disk,clears	the FAT	and DIRECTORY then
;	 optionally copies the SYSTEM and COMMAND.COM to this new disk
;
;	 SYNTAX: FORMAT	 [drive][/switch1][/switch2]...[/switch16]
;
;	 Regardless of the drive designator , the user will be prompted	to
;	 insert	the diskette to	be formatted.
;
; =======================================================================
;
;	     5/12/82 ARR Mod to	ask for	volume ID
;	     5/19/82 ARR Fixed rounding	bug in CLUSCAL:
;   REV 1.5
;	     Added rev number message
;	     Added dir attribute to DELALL FCB
;   REV 2.00
;	     Redone for	2.0
;   REV 2.10
;	     5/1/83 ARR	Re-do to transfer system on small memory systems
;   REV 2.20
;	     6/17/83 system size re-initialization bug -- mjb001
;   Rev 2.25
;	     8/31/83 16-bit fat	insertion
;   Rev 2.26
;	     11/2/83 MZ	fix signed compare problems for	bad sectors
;   Rev 2.27
;	     11/8/83 EE	current	directories are	always saved and restored
;   Rev 2.28
;	     11/9/83 NP	Printf and changed to an .EXE file
;   Rev 2.29
;	     11/11/83 ARR Fixed	ASSIGN detection to use	NameTrans call to see
;			 if drive letter remapped. No longer IBM only
;   Rev 2.30
;	     11/13/83 ARR SS does NOT =	CS, so all use of BP needs CS override
;   Rev 2.31
;	     12/27/83 ARR REP STOSB instruction	at Clean: changed to be
;			 sure ES = CS.
;
;   Rev 5.00 Summer '90  SA  Reworked Format code.
; =======================================================================

;
;----------------------------------------------------------------------------
;
; M00x : Assume Media is formatted if Query_BLock_IOCTL is not supported
;	 Bug #4801.
;
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc. Reclaimed
;		the msgBadDrive which was not being used. Removed the
;		unwanted EXTRN msgBadDrive.
;
; M025 : Removed obsolete IBMCOPYRIGHT conditional
;
;---------------------------------------------------------------------------
;

;----------------------------------------------------------------------------
;
CODE	 SEGMENT PUBLIC PARA 'CODE'
CODE	 ENDS

; =======================================================================


DATA	 SEGMENT PUBLIC PARA 'DATA'
DATA	 ENDS

; =======================================================================

End_Of_Memory SEGMENT PUBLIC PARA 'BUFFERS'
End_Of_Memory ENDS

; =======================================================================

;===========================================================================
;Declaration of include files
;===========================================================================

debug	 equ	 0
	 .xlist
	 INCLUDE VERSION.INC
;	 INCLUDE VERSIONA.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
;	 INCLUDE ERROR.INC
	 INCLUDE DPB.INC
	 INCLUDE CPMFCB.INC
	 INCLUDE DIRENT.INC
	 INCLUDE CURDIR.INC
;	 INCLUDE PDB.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 INCLUDE IOCTL.INC
	 INCLUDE FORSWTCH.INC
;	 INCLUDE SYSVAR.INC
       	 INCLUDE SAFE.INC		; Extrn	declarations for SAFE.ASM
	 INCLUDE SAFEDEF.INC
	 .list

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Bytes
	EXTRN	fBigFat	 		:BYTE
	EXTRN	CommandFile		:BYTE
IFDEF DBLSPACE_HOOKS
	EXTRN	DblSpaceFile		:BYTE
ENDIF
	EXTRN	msgNoRoomDestDisk	:BYTE
	EXTRN	msgAssignedDrive	:BYTE
	EXTRN	msgBadDosVersion	:BYTE
	EXTRN	msgDirectoryWriteError	:BYTE
	EXTRN	msgFormatComplete	:BYTE
	EXTRN	msgFormatNotSupported	:BYTE
	EXTRN	msgFatwriteError	:BYTE
	EXTRN	msgLabelPrompt		:BYTE
	EXTRN	msgNeedDrive		:BYTE
	EXTRN	msgNoSystemFiles	:BYTE
	EXTRN	msgNetDrive		:BYTE
	EXTRN	msgInsertDisk		:BYTE
	EXTRN	msgHardDiskWarning	:BYTE
	EXTRN	msgSystemTransfered	:BYTE
	EXTRN	msgFormatAnother?	:BYTE
	EXTRN	msgBadCharacters	:BYTE
;	EXTRN	msgBadDrive		:BYTE		; M024
	EXTRN	msgParametersNotSupported:BYTE
	EXTRN	msgReInsertDisk 	:BYTE
	EXTRN	msgInsertDosDisk	:BYTE
	EXTRN	msgFormatFailure	:BYTE
	EXTRN	msgNotSystemDisk	:BYTE
	EXTRN	msgDiskUnusable 	:BYTE
	EXTRN	msgOutOfMemory		:BYTE
	EXTRN	msgCurrentTrack 	:BYTE
	EXTRN	msgWriteProtected	:BYTE
	EXTRN	msgInterrupt		:BYTE
	EXTRN	msgCrLf 		:BYTE
	EXTRN	msgShowKBytes		:BYTE
	EXTRN	msgShowMBytes		:BYTE
	EXTRN	msgDecimalMBytes	:BYTE
	EXTRN	msgDecimalNumberofDecimal:BYTE
	EXTRN	msgSysWarning		:BYTE
	EXTRN	msgVerifyShowKBytes	:BYTE
	EXTRN	msgVerifyShowMBytes	:BYTE
	EXTRN	msgVerifyDecimalMBytes	:BYTE
	EXTRN	msgSavingUNFORMATInfo	:BYTE
	EXTRN	msgQuickFormatShowKBytes:BYTE
	EXTRN	msgQuickFormatShowMBytes:BYTE
	EXTRN	msgQuickFormatDecimalMBytes:BYTE

	EXTRN	msgFileCreationError	:BYTE
	EXTRN	ContinueMsg		:BYTE
	EXTRN	Fatal_Error		:BYTE
	EXTRN	Read_Write_Relative	:BYTE
	EXTRN	Parse_Error_Msg 	:BYTE
	EXTRN	Extended_Error_Msg	:BYTE

	EXTRN	CMCDDFlag		:BYTE		; M033
	EXTRN	GetDeviceParameters	:NEAR

;Words
	EXTRN	PSP_Segment		:WORD
;	EXTRN	sector_in_buffer	:WORD
	EXTRN	TotalClusters		:WORD

;Pointers

;Functions
	EXTRN	Global_Init		:NEAR
	EXTRN	Phase1Initialisation	:NEAR
	EXTRN	Disk_Format_Proc	:NEAR
	EXTRN	SetDeviceParameters	:NEAR
	EXTRN	Prompt_User_For_Disk	:NEAR
	EXTRN	Multiply_32_Bits	:NEAR
;	EXTRN	Fat_Init		:NEAR
	EXTRN	calc_sector_and_offset	:NEAR
	EXTRN	ReadFatSector		:NEAR
	EXTRN	GetSetFatEntry		:NEAR
	EXTRN	GetFatSectorEntry	:NEAR
	EXTRN	Yes?			:NEAR
	EXTRN	Mirror			:NEAR

;Structures

;Labels
	EXTRN	WriteDos 		:NEAR

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

;===============================
;
; Exit Status defines
;
;===============================

EXIT_OK			equ	0
EXIT_CTRLC		equ	3
EXIT_FATAL		equ	4
EXIT_NO			equ	5
EXIT_DRV_NOT_READY	equ	6	; Drive not ready error
EXIT_WRIT_PROTECT	equ	7	; write protect error

DOSVER_LOW		equ	0300H+20
DOSVER_HIGH		equ	0300H+20

RECLEN			equ	fcb_RECSIZ+7
RR			equ	fcb_RR+7

Fbig			equ	0ffh		; flag for big Fat
PSP_Environ		equ	2ch		; location of
						; environ. segment
						; in PSP
MIRROR_SIGNATURE	equ	5050h		; Parameter to Mirror to tell
						; it Format's calling it

SavedParams		A_DEVICEPARAMETERS	<>	;default
DeviceParameters	A_DEVICEPARAMETERS	<>	;dynamic
SwitchDevParams		A_DEVICEPARAMETERS	<>	;switch-based
Disk_Access		A_DiskAccess_Control	<>
FormatPacket		A_FormatPacket		<>

DirectorySector 	dd	0	; pointer to root directory buffer
FatSpace		dd	?	; pointer to FAT buffer
FatSector		dd	?	; pointer to 1-sector buffer used for
					;  reading old FAT from disk
;No more SAFE module
;HeaderBuf		dd	0	; pointer to header buffer for restore file
DirBuf			dd	0	; pointer to DIR buffer for reading
					;  old fat chains


; ========================================================================

Bios			a_FileStructure <>
dos			a_FileStructure <>
command 		a_FileStructure <>
IFDEF DBLSPACE_HOOKS
DblSpaceBin		a_FileStructure <>
ENDIF

;***	public IsReal
;***IsReal	DB	1



ValidSavedDeviceParameters	db		0
NoDPChange		db	0	; It is sometimes necessary not to
					; modify the drive parameters, even
					; in a Fatal exit.  This flag is set
					; in that case.
FirstHead		dw	?
FirstCylinder		dw	?
TracksLeft		dd	?	; M018
TracksPerDisk		dd	?	; M018


;M025 - obsolete data items removed here
;IF ibmcopyright
;
;file_ptr		dw	0
;			dw	20290, 19282
;
;VER			db	"D"	; version number e.g., 410
;VER_YYY 		db	"410"	; the first 3 chars are placed here
;			db	" R"	; revision number e.g., 01
;VER_XX			db	"00"	; the next 2 chars are placed here
;
;ENDIF

; ========================================================================

Formatted_Tracks_Low	dw	0
Formatted_Tracks_High	dw	0


NumSectors		dw	0FFFFh
TrackCnt		dw	0FFFFh

Old_Dir 		db	FALSE

SectorsInRootDirectory	dw	?

PrintStringPointer	dw	0

ExitStatus		db	0


; =======================================================================

RootStr 		db	?
			db	":\",0
DblFlg			db	0	;Initialize flags to zero
mStart			dw	?	; Start of sys	file buffer (para#)
mSize			dw	?	; Size	of above in paragraphs

					; Storage for users current directory

UserDirs		db	DIRSTRLEN + 3 DUP(?)

; ===========================================================================
	PUBLIC	Paras_Per_Fat
; ===========================================================================

Paras_Per_Fat		dw	0000h		; holds Fat para count


CommandFile_Buffer	db	127	 dup(0) ; allow room for copy


VolFcb			db	-1,0,0,0,0,0,8
VolDrive		db	0
VolNam			db	"           "
			db	8
			db	26 DUP(?)

DelFcb			db	-1,0,0,0,0,0,8
DelDrive		db	0
dELnam			db	"???????????"
			db	8
			db	26 DUP(?)

TranSrc 		db	"A:CON",0,0 ; Device so we don't hit the Drive
TranDst 		db	"A:\",0,0,0,0,0,0,0,0,0,0

BegSeg			dw	?
SwitchMap		dw	?
SwitchCopy		dw	?
Fat			dw	?
			dw	?
ClusSiz 		dw	?
SecSiz			dw	?
Sectors 		dw	?
InBuff			db	80,0
			db	80 dup(?)


Drive			db	0
DriveLetter		db	"x"
SystemDriveLetter	db	"x"

Ctrl_Break_Vector	dd	?		 ; Holds CTRL-Break
						 ; vector

Command_Path		dd	 ?		 ; hold pointer to
						 ; COMMAND's path



Environ_Segment 	dw	 ?			 ; hold segment of
						 ; environ. vector
; =======================================================================
;
; Disk Table
; Used if NumberOfFats in BPB
; is 0.
;		I documented this table format some, but I don't know what
;		the low byte of the 3rd word is used for; couldn't find
;		a user!  - jgl
;
; =======================================================================

;				disk sectors	sec/	root	12/16 bit
;			     loword    hiword	clus   dirents	fat

DiskTable		dw	0,	32680,	0803h,	512,	0
			dw	4h,	0000h,	0402h,	512,	Fbig
			dw	8h,	0000h,	0803h,	512,	Fbig
			dw	10h,	0000h,	1004h,	512,	Fbig
			dw	20h,	0000h,	2005h,	512,	Fbig

Org_AX			dw	?			 ;AX	on entry

ClustBound_Adj_Factor	dw	?


ClustBound_SPT_Count	dw	?


ClustBound_Flag		db	False



ClustBound_Buffer_Seg	dw	?

Relative_Sector_Low	dw	?
Relative_Sector_High	dw	?

Fat_Flag		db	?

Msg_Allocation_Unit_Val dd	?

SizeInK			dw	0		; Variables used in format size message
SizeInM			dw	0
DecSizeInM		dw	0

RWErrorCode		dw	0		; Used to save error code returned
						; from Int25/26 in ReadWriteSectors,
						; module SAFE. Used by Phase1Initialisation
FoundN			db	FALSE		; flag used in search for N contiguous clusters
Cluster			dw	0		; cluster variable used in FAT search
SpecialCase		db	FALSE		; special case when /S is specified, with safe format

sector_to_read		DW	?		; Logical sector number of FAT required
sector_in_buffer	DW	0ffffh		; FAT sector currently in memory, init.
						;  to high value to force first read
NumClusters		DW	?		; Holds #clusters required for 1.5K
						;  (Will be 1,2 or 3)

EndValue		DW	?		; Holds FAT entry value for end of chain

;NeedSysDisk		db	0		; flag for sys disk required,
						; when buffer not big enough
						; to read in all sys files
IFDEF DBLSPACE_HOOKS
fDblSpace		db	FALSE		; TRUE if DblSpace.bin found
ENDIF

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	 SEGMENT PUBLIC  PARA	 'CODE'

	 ASSUME  CS:CODE,DS:NOTHING,ES:NOTHING


; =======================================================================
;
; Define as public for	debugging
;
; =======================================================================

; procedures

	PUBLIC	ShrinkMemory
	PUBLIC	InitSysParm
	PUBLIC	ZeroAllBuffers
	PUBLIC	ZeroBuffer
	PUBLIC	FindNClusters
	PUBLIC	WriteDiskInfo
	PUBLIC	RestoreDevParm
;	PUBLIC	GetSize
	PUBLIC	AddToSystemSize
	PUBLIC	Div32
	PUBLIC	Phase2Initialisation
	PUBLIC	ShowFormatSize
	PUBLIC	Done
;	PUBLIC	PrintErrorAbort
	
	PUBLIC	GetCmdSize
	PUBLIC	Start
;	PUBLIC	FatAllocated
;	PUBLIC	SysLoop

;	PUBLIC	Cleared
;	PUBLIC	Louse
;	PUBLIC	LouseP
;	PUBLIC	FatWrt
;	PUBLIC	SysOk
;	PUBLIC	Status
;	PUBLIC	ReportC
;	PUBLIC	OnClus
	PUBLIC	More
	PUBLIC	FatalExit
	PUBLIC	SysPrm
;	PUBLIC	DoPrompt
	PUBLIC	IsRemovable
	PUBLIC	DoSafe
;	PUBLIC	CheckRemove
;	PUBLIC	IsRemove
;	PUBLIC	NotRemove
	PUBLIC	CrLf
	PUBLIC	PrintString
	PUBLIC	Std_Printf
;	PUBLIC	NotBigTotalSectors
;	PUBLIC	WriteDIRloop
	PUBLIC	Main_Routine
	PUBLIC	ControlC_Handler
	PUBLIC	GetBioSize
	PUBLIC	GetDosSize

; bytes
	PUBLIC	RootStr
	PUBLIC	DblFlg
	PUBLIC	Drive
	PUBLIC	UserDirs
	PUBLIC	VolFcb
	PUBLIC	VolNam
	PUBLIC	TranSrc
	PUBLIC	TranDst
	PUBLIC	InBuff
	PUBLIC	DriveLetter
	PUBLIC	SystemDriveLetter
	PUBLIC	ExitStatus
	PUBLIC	VolDrive
	PUBLIC	DelFcb
	PUBLIC	DelDrive
	PUBLIC	Fat_Flag
	PUBLIC  Old_Dir
	PUBLIC	ClustBound_Flag
	PUBLIC	ValidSavedDeviceParameters
	PUBLIC	NoDPChange
;	PUBLIC	NeedSysDisk
IFDEF DBLSPACE_HOOKS
	PUBLIC	fDblSpace
ENDIF

; words
	PUBLIC	FatSpace
	PUBLIC	FirstHead
	PUBLIC	FirstCylinder
	PUBLIC	TracksLeft
	PUBLIC	TracksPerDisk
	PUBLIC	SectorsInRootDirectory
	PUBLIC	PrintStringPointer
	PUBLIC	mStart
	PUBLIC	mSize
	PUBLIC	BegSeg
	PUBLIC	SwitchMap
	PUBLIC	SwitchCopy
	PUBLIC	Fat
	PUBLIC	ClusSiz
	PUBLIC	SecSiz
	PUBLIC	Formatted_Tracks_High
	PUBLIC	Formatted_Tracks_Low
	PUBLIC  NumSectors
	PUBLIC  TrackCnt
	PUBLIC  Org_AX
	PUBLIC	ClustBound_Adj_Factor
	PUBLIC	ClustBound_SPT_Count
	PUBLIC	ClustBound_Buffer_Seg
	PUBLIC	Relative_Sector_Low
	PUBLIC	Relative_Sector_High
	PUBLIC	Environ_Segment
	PUBLIC	RWErrorCode
	PUBLIC	SizeInK
	PUBLIC	SizeInM
	PUBLIC	DecSizeInM
	PUBLIC	sector_to_read
	PUBLIC	sector_in_buffer

;constants
	PUBLIC  EXIT_OK
	PUBLIC	EXIT_CTRLC		
	PUBLIC	EXIT_FATAL	
	PUBLIC	EXIT_NO			
	PUBLIC	EXIT_DRV_NOT_READY	
	PUBLIC	EXIT_WRIT_PROTECT	

;pointers
	PUBLIC	DirectorySector
	PUBLIC	FatSpace
	PUBLIC  FatSector
	PUBLIC  DirBuf
;	PUBLIC  HeaderBuf

	

; other
	PUBLIC	DeviceParameters
	PUBLIC	SavedParams
	PUBLIC	SwitchDevParams
	PUBLIC	Disk_Access
	PUBLIC	FormatPacket
	PUBLIC	bios
	PUBLIC	dos
	PUBLIC	command
IFDEF DBLSPACE_HOOKS
	PUBLIC	DblSpaceBin
ENDIF
	PUBLIC	Msg_Allocation_Unit_Val
	PUBLIC  DiskTable
	PUBLIC	ExitProgram
	PUBLIC	SEG_ADJ

;For FORPROC and FORMES modules

	PUBLIC	ClusSiz
	PUBLIC	InBuff
	PUBLIC	CrLf
	PUBLIC	Std_Printf
	PUBLIC	Drive
	PUBLIC	DriveLetter
	PUBLIC	PrintString

	EXTRN	CheckSwitches		:NEAR
	EXTRN	LastChanceToSaveIt	:NEAR
	EXTRN	VolId			:NEAR
	EXTRN	WriteBootSector 	:NEAR
	EXTRN	OemDone 		:NEAR
	EXTRN	AccessDisk		:NEAR
	EXTRN	Main_Init		:NEAR
	EXTRN	Read_Disk		:NEAR
	EXTRN	Write_Disk		:NEAR

; =======================================================================

DATA	SEGMENT PUBLIC	 PARA	 'DATA'

	EXTRN	BiosFile		:BYTE
	EXTRN	DosFile 		:BYTE
	EXTRN	SysSiz			:DWORD
	EXTRN	BioSiz			:DWORD
	EXTRN	UnformattedHardDrive	:BYTE
DATA	ENDS

; =======================================================================
;
; For FORPROC module
;
; =======================================================================

	EXTRN	FormatAnother?		:NEAR
;	EXTRN	Yes?			:NEAR
	EXTRN	report			:NEAR
	EXTRN	user_string		:NEAR

; =======================================================================

;No more SAFE module		
					; *rup 10-10-89
;	EXTRN	BuildRestoreFile	:NEAR
;	EXTRN	DoDirCopy		:NEAR
;	EXTRN	ClearDirSector		:NEAR
;	EXTRN	FatFixup		:NEAR
;	EXTRN	SwapFats		:NEAR
;	EXTRN	Hook_Int_24		:NEAR
;	EXTRN	Restore_Int_24		:NEAR
					; jh
; =======================================================================


;************************************************************************							
; =======================================================================
;
; Entry point to DOS format program.
;
; =======================================================================
;************************************************************************

Start:
	xor	BX,BX
	push	BX
	Set_Data_Segment
	mov	Org_AX,AX			; save AX on entry

	call	Main_Init

	mov	DX,SwitchMap			; save a copy of SwitchMap
	mov	SwitchCopy,DX

Main_Routine:				
	call	ShrinkMemory			; set memory requirements

; M033 - begin
; M031: With memory card, we cannot do a GetDefaultBPB prior to having
; inserted the media. This code should normally be put in glblinit.asm
; but version.inc is not included (Why?).

	cmp	CMCDDFlag, Yes
	jne	the_usual			; If not CMCDD, do the old logic

	call	Prompt_User_For_Disk		; Else ask the user to insert
						; the disk NOW
the_usual:
	call	Global_Init    			; allocate buffers, read in
						; system files if needed
	jnc	FatAllocated	      		; check for failure

FatalExiting:					; M031; just the label
	Message msgFormatFailure
	inc	NoDPChange			; Not necc. to modify drive
						; parameters if Global_Init failed

	jmp	FatalExit

FatAllocated:
SysLoop:
	mov	NoDPChange,0			; M004; assume we will restore
	call	InitSysParm 			; initialize some parameters
						; for each format iteration
	call	ZeroAllBuffers			; initialize buffers


	cmp	CMCDDFlag, Yes
	jne	the_usual2			; If CMCDD, let's make sure

	lea	DX, DeviceParameters		; Get the default drive parameters
						; (again!)
	mov	DeviceParameters.DP_SpecialFunctions, 0
	call	GetDeviceParameters
	jc	NotThisDisk

	mov	AX, DeviceParameters.DP_BPB.BPB_SectorsPerFat
	cmp	AX, SavedParams.DP_BPB.BPB_SectorsPerFat
	ja	NotThisDisk

	mov	AX, DeviceParameters.DP_BPB.BPB_RootEntries
	cmp	AX, SavedParams.DP_BPB.BPB_RootEntries
	jbe	go_on

NotThisDisk:
	Message msgFormatNotSupported
	jmp	SHORT FatalExiting

the_usual2:
	call	Prompt_User_For_Disk		; Else ask the user to insert the disk

go_on:

; M033- end

	call	Get_Disk_Access			; ensure disk access
	call	Phase1Initialisation		; determine deviceparameters
	jnc	@f

;	Message	msgFormatFailure		; m004; fatal error from Phase1
	inc	NoDPChange			; Not necc. to modify drive
						; parameters if Phase1 failed
	jmp	SHORT NextDisk			; M004; prompt for next disk

@@:
	call	DoSafe				; build recovery file if needed
; M005 - begin
	jnc	@f
	or	ax,ax				; is it failure write protect?
	jz	NextDisk
	jmp	SHORT ExitProgram		; terminate program (requested by user)

@@:
; M005 - end
	call	Phase2Initialisation		; determine starting points
	call	ShowFormatSize			; size being formatted message

;==========================================================================
;IF DEBUG_MODEL
;	jmp	 DrtFat				; If debugging don't
;						; need to really do format
;ENDIF
;==========================================================================

	call	Disk_Format_Proc
	jc	NextDisk			; Prompt for next disk if error

DrtFat:
	call	WriteDiskInfo			; write out the control information
;	jc	FatalExit			; M013; check for error
	cmp	ExitStatus,EXIT_NO		; does user want to continue?
	jz	ExitProgram			; terminate program

NextDisk:
	call	RestoreDevParm			; Restore device parameters
	call	More				; See if More disks to format
	jnc	SysLoop				; Continue if no carry

ExitProgram:
;	xor	BX,BX				; Prepare BX for IsRemovalbe call
;	mov	BL,Drive			; Get Drive number
;	inc	BL				; Make it 1 based
;	call	IsRemovable			; Do not restore original device
;	jnc	DoNotRestore			; parameters here, for removable media

;Now always do Restore Parameters


DoNotRestore:
	call	Format_Access_Wrap_Up		; Determine access status

	mov	AH,DISK_RESET			; Do a disk reset (flush buffers)
	int	21h	

	mov	AL,ExitStatus			; Get Errorlevel
	DOS_Call Exit				; Exit program
	int	20h				; If other exit	fails


FatalExit:
	Set_Data_Segment			; Ensure addressibility
	mov	ExitStatus,EXIT_FATAL
	call	RestoreDevParm			; Restore device parameters
	jmp	SHORT ExitProgram		; Perform normal exit




;=========================================================================
;  SHRINKMEMORY :	This procedure resizes the memory block allocated
;			to the format utility by calling Int 21H Function
;			4AH (74).  This is done in order to make room for
;			the FAT buffers.
;
;  CALLS :		none
;  CALLED BY :		Main
;  MODIFIES :		BX, ES, AH
;
;=========================================================================

ShrinkMemory	proc	near

	mov	BX,PSP_Segment			; Shrink to free space for Fat
	mov	ES,BX
	mov	BX,End_Of_Memory
	sub	BX,PSP_Segment
	Dos_Call Setblock
	ret

ShrinkMemory	endp

;=========================================================================
; Get_Disk_Access	 : This	routine	will determine the access state	of
;			   the disk.  If access is currently not allowed, it
;			   will be allowed by calling Set_Disk_Access_On_Off.
;
;
;	 Inputs	 : DX -	pointer	to buffer
;	 Outputs : Disk_Access.DAC_Access_Flag - 0ffh signals access allowed
;						 to the	disk previously.
;		   Access to the disk will be allowed.
;
;  CALLS :	Set_Disk_Access_On_Off
;  CALLED BY :  Main
;  MODIFIES :	Disk_Access.DAC_Access_Flag
;
;  M00x : This routine was re-worked for this modification
;
;=========================================================================

Procedure Get_Disk_Access

	push	AX				; Save regs
	push	BX
	push	CX
	push	DX

	mov	UnformattedHardDrive,FALSE	; Assume formatted disk
	mov	Disk_Access.DAC_Access_Flag, 0ffh; Assume we already have
						;  access to disk

	mov	AX,(IOCTL shl 8) or IOCTL_QUERY_BLOCK ; Check if function supported
	xor	BX,BX				; Clear BX
	mov	BL,Drive			; Get Drive letter
	inc	BL				; Make it 1 based
	mov	CX,(RAWIO shl 8) or Get_Access_Flag ; Determine disk access
	lea	DX,Disk_Access			; Point to parm list
 	int 	21h
	jc	gda_exit			;Not supported on carry

	mov	AX,(IOCTL shl 8) or Generic_IOCTL  ;Now can perform generic IOCtl call
	int	21h
	cmp	Disk_Access.DAC_Access_Flag,01h	; Access is currently allowed?
	jne	@f
	mov	Disk_Access.DAC_Access_Flag,0ffh; Mark that we already have
						;  access to disk
	jmp	short gda_exit
@@:
						; not previously allowed
	mov	UnformattedHardDrive,TRUE	; Won't do CheckExistingFormat
	inc	Disk_Access.DAC_Access_Flag	; signal disk access
	call	Set_Disk_Access_On_Off		; allow disk access

gda_exit:
	pop	DX				; Restore regs
	pop	CX
	pop	BX
	pop	AX
	ret
Get_Disk_Access ENDP

;===========================================================================
;
;  ZeroAllBuffers :	This procedure initializes all allocated buffers
;			by filling them with zeroes.
;
;  Buffers Modified :	DirectorySector
;			FatSpace
;			FatSector
;			xxxHeaderBufxxx (No more SAFE module)
;			DirBuf
;
;  Registers Modified:	AX,BX,CX,DI
;
;===========================================================================

ZeroAllBuffers	proc	NEAR

	Set_Data_Segment
	push	ES

	les	DI,DirectorySector	; ES:DI --> DirectorySector buffer
	mov	CX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	call	ZeroBuffer

;---------------------------------------------------------------------------
;					; The size of FatSpace is given by the
;					; larger of the FAT, root directory and
;					; #clusters for 1.5K
;	les	DI,FatSpace  		
;	mov	AX,DeviceParameters.DP_BPB.BPB_BytesPerSector
;	mul	DeviceParameters.DP_BPB.BPB_SectorsPerFat
;	mov	BX,AX			; Save FAT size in bytes in BX
;
;	mov	AX,DeviceParameters.DP_BPB.BPB_RootEntries
;	mov	CL,5
;	shl	AX,CL			; Multiply by 32 to get total byte size
;
;	cmp	AX,BX			; now see which is bigger
;	ja	ChkClust		; Use root dir size if AX > BX
;
;UseFatSize:
;	mov	AX,BX			; FAT is bigger
;
;
;ChkClust:
;	mov	BX,AX			; Now BX contains the larger of the
;					; FAT and RootDir size, in bytes
;					; Calculate the byte size of the #
;					; clusters needed for 1.5K
;	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
;	mov	CL,deviceParameters.DP_BPB.BPB_SectorsPerCluster
;	xor	CH,CH			; Sectors per cluster in CX
;	mul	CX			; DX:AX= bytes per cluster
;	mov	CX,AX			; CX = #bytes per cluster
;	mov	AX,1536			; AX = 1.5K
;	div	CX			; Calc. # clusters needed for 1.5K
;	or	DX,DX			; Non-zero remainder?
;	jz	Rounded			; No need to round up for zero remainder
;	inc	AX			; Increment #clusters needed, for non-zero remainder
;Rounded:
;	mul	CX			; Calculate byte size needed (#Clusters * BytesPerCluster)
;	cmp	BX,AX			; Is Max(FAT,RootDir) > Clusters in 1.5K?
;	jna	ZeroAsIs		; Clusters in 1.5K is bigger
;
;UseOldMax:
;	mov	AX,BX			; Clusters in 1.5K is smaller
;
;ZeroAsIs:
;	mov	CX,AX			; CX = bytes to zero out (size of FatSpace)
;	call	ZeroBuffer
;---------------------------------------------------------------------------

				; Not neccessary to init. FatSpace here since
				; this is done in DSKFRMT	
;	call	Fat_Init		; Fills FatSpace buffer with Fat_Init_Value

	les	DI,FatSector		; ES:DI --> FatSector buffer
	mov	CX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	call	ZeroBuffer

;	les	DI,HeaderBuf		; ES:DI --> HeaderBuf buffer
;	mov	CX,deviceParameters.DP_BPB.BPB_BytesPerSector
;	add	CX,HEADER_SIZE
;	call	ZeroBuffer

	les	DI,DirBuf
	mov	CX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	call	ZeroBuffer

	pop	ES

	ret
ZeroAllBuffers	endp

;=========================================================================
;
;  ZeroBuffer :		This procedure initializes buffer space to zero.
;			Note: This routine will not work for buffer sizes
;			greater than 64K, due to segment wrap.
;
;  Assumes     :	ES:DI gives location of buffer
;			CX = size of buffer in bytes
;  Modifies    :	AX, CX
;
;=========================================================================

ZeroBuffer	proc	near

	xor	AX,AX
	shr	CX,1		; Get buffer size in words
	rep	stosw

	ret
ZeroBuffer	endp

; ==========================================================================
;
; IsRemovable :  Determine if the Drive indicated in BX is removable or not.
;
;
;   Inputs:	 BX has	Drive (0=def, 1=A)
;   Outputs:	 Carry clear
;		     Removable
;		 Carry set
;		     not removable
;   Registers modified: DX
; ==========================================================================

IsRemovable PROC NEAR

	SaveReg <AX>
	mov	AX,(IOCTL shl 8) OR 8		; Rem media check
	int	21H
	jnc	CheckRemove

	mov	AX,(IOCTL shl 8) + 9		; Is it a NET Drive?
	int	21h
	jc	NotRemove			; Yipe, say non-removable

	test	DX,1000h
	jnz	NotRemove			; Is NET Drive, flag non-removeable
	jmp	SHORT IsRemove			; Is local, say removable

CheckRemove:
	test	AX,1
	jnz	NotRemove

IsRemove:
	clc
	RestoreReg <AX>
	return

NotRemove:
	stc
	RestoreReg <AX>
	ret

IsRemovable ENDP

;=========================================================================
; Set_Disk_Access_On_Off: This	routine	will either turn access	on or off
;			   to a	disk depending on the contents of the
;			   buffer passed in DX.

;	 Inputs	 : DX -	pointer	to buffer

;=========================================================================

Procedure Set_Disk_Access_On_Off

	push	AX				; Save regs
	push	BX
	push	CX
	push	DX

	xor	BX,BX				; Clear BX
	mov	BL,Drive			; Get Drive number
	inc	BL				; Make it 1 based
	call	IsRemovable			; See if removable media
	jnc	$$IF126 			; Not removable

	mov	AX,(IOCTL shl 8) or IOCTL_QUERY_BLOCK ; Check if function supported
	xor	BX,BX				; Clear BX
	mov	BL,Drive			; Get Drive letter
	inc	BL				; Make it 1 based
	mov	CX,(RAWIO shl 8) or Set_Access_Flag ; Allow access to disk
	int	21h
	jc 	$$IF126				; Not supported on carry
	mov	AX,(IOCTL shl 8) or Generic_IOCTL  ; Can now perform generic IOCTL
   	int	21h

$$IF126:
	pop	DX				; Restore regs
	pop	CX
	pop	BX
	pop	AX

	ret
Set_Disk_Access_On_Off ENDP


;=========================================================================
;
; DoSafe :   This procedure checks in case SWITCH_U is set.  If it
;	     isn't, the restoration file is created by calling Mirror.
;	     Before invoking Mirror it is necessary to de-allocate the
;	     FatSpace buffer.  This buffer has already been allocated so
;	     as to be big enough for all the buffers Mirror will require.
;
;	     The interface used with Mirror is as follows.
;		Passed In :	AX = MIRROR_SIGNATURE (5050h)
;				BL = 0-based target drive (0 = A)
;
;		Passed Out:	AL = Exit code from Mirror, as follows
;					0 - Success
;					4 - Physical error
;					5 - Logical error
;
; M005; if AL=4, AH=INT 26 return code
;
;	     If Mirror is successful the FatSpace buffer is re-allocated,
;	     but this time it is made only as big as the FAT.  Format
;	     then proceeds as normal.
;
;	     If Mirror is unsuccessful the user is asked whether to continue with
;	     an unconditional format (since the recovery file was not built).
;	     If he chooses to continue, the FatSpace buffer is re-allocated,
;	     Switch_U is set and Switch_Q is turned off, and Format proceeds
;	     as normal.  If he chooses not to continue, ExitStatus is set
;	     to EXIT_NO, and the program will be terminated upon returning
;	     from DoSafe.
;
;  Inputs :	None
;  Output :	NC --> Continue with Format
;		CY --> Exit program
;
;  Destroys:	Possibly all, except DS,ES which are set to DATA
;
;=========================================================================

DoSafe  proc	near

	assume	DS:DATA,ES:DATA
	test	SwitchMap,SWITCH_U		; Check	for unconditional format
	jz	BuildSafeFile			; Must do a safe format

	clc					; No recovery file needed
	ret					; Continue with Format

BuildSafeFile:
	mov	AH,Dealloc			; De-allocate FatSpace buffer
	mov	ES,WORD PTR FatSpace+2		; ES --> FatSpace segment
	assume	ES:NOTHING

	int	21h

	jnc	MemoryFree			; check for error here
	jmp	FatalExit			; de-allocation error occurred

MemoryFree:
	Message msgSavingUNFORMATInfo
	mov	AX,MIRROR_SIGNATURE		; Load interface parameters
	xor	BX,BX
	mov	BL,Drive			; BL = target drive (0 = A)

	call	Mirror				; invoke Mirror utility

	Set_Data_Segment
	assume	DS:DATA,ES:DATA

	or	AL,AL				; check exit code
	jz	GetMemory			; recovery file built
	
	cmp	ax,3*256+4			; M005;
	jz	WriteProtect

	Message	msgFileCreationError		; ask user whether to continue
	call	Yes?				;  with unconditional format

	pushf					; save flags for response
	Message	msgCrLf				; cursor on next line
	popf					; restore flags

	jnc	MakeUnconditional		; user wants to continue

	mov	ExitStatus,EXIT_NO		; set user-terminated exit code
	mov	ax,1				; M005; terminate format
DSFailed:
	stc					; signal termination required
	ret					; return to main routine

; M005 - begin
WriteProtect:
	Message msgCrLf
	Message msgCrLf
	mov	ax,13h				; Write protect error
	Extended_Message
	Message msgFormatFailure
	mov	ExitStatus,EXIT_FATAL		; M006;
	xor	ax,ax
	jmp	SHORT DSFailed
; M005 - end

MakeUnconditional:
			; allow continuation of quick format/track verify
			; PYS: but make it /u /q if /q
	test	SwitchMap,SWITCH_Q
	jz	GetMemory

	or	SwitchMap,SWITCH_U		; make unconditional
;	and	SwitchMap,not SWITCH_Q		; turn off Quick Format

GetMemory:
	mov	BX,Paras_Per_Fat		; BX = FAT size in paras

	mov	AH,Alloc			; allocate memory block
	int	21h

	jnc	MemoryAllocated			; check for error here
	jmp	FatalExit

MemoryAllocated:
	mov	WORD PTR FatSpace+2,AX		; save buffer pointer
	xor	AX,AX
	mov	WORD PTR FatSpace,AX

				; Not neccessary to init. FatSpace here since
				; this is done in DSKFRMT	
;	call	Fat_Init			; fill FatSpace buffer with zeroes

	clc					; signal to continue with Format
	ret

DoSafe	ENDP


;========================================================================
;
;  INITSYSPARM :	This procedure initializes parameters for each
;			iteration of the disk format process.
;
;  CALLS :	none
;  CALLED BY :	Main
;  MODIFIES :	SysSiz
;		SysSiz+2
;		ExitStatus
;		DblFlg
;		SwitchMap
;		sector_in_buffer
;		RWErrorCode
;		old_dir
;		DeviceParameters.DP_BPB (reset to SavedParams)
;
;========================================================================

InitSysParm	proc	near

	mov	WORD PTR SysSiz,0		; Must intialize for each
	mov	WORD PTR SysSiz+2,0		; iteration
	mov	BYTE PTR DblFlg,0
	mov	ExitStatus, EXIT_OK
	mov	DX,SwitchCopy			; restore original SwitchMap
	mov	SwitchMap,DX			; for each disk formatted
	mov	sector_in_buffer,0ffffh		; Initialize to force first read
	mov	RWErrorCode,0			; error code from reading disk
	mov	Old_Dir,FALSE
	mov	SpecialCase,FALSE		; used in WriteDiskInfo
						; Copy SavedParams into
						;  DeviceParameters
	push	DS				; copy DS into ES
	pop	ES

;	lea	SI,SavedParams.DP_BPB		; DS:SI --> source BPB
;	lea	DI,DeviceParameters.DP_BPB	; ES:DI --> dest. BPB
;	mov	CX,size a_BPB			; bytes to move

	mov	SavedParams.DP_SpecialFunctions,0 ; restore to original value
	mov	SI,OFFSET SavedParams		; DS:SI --> source parameters
	mov	DI,OFFSET DeviceParameters	; ES:DI --> dest. parameters
	mov	CX,SIZE A_DEVICEPARAMETERS	; bytes to move

	cld
	rep	movsb	

	ret
InitSysParm	ENDP


; ==========================================================================
; Calculate the size in bytes of the system rounded up to sector and
; cluster boundries, the store answer in SysSiz
; ==========================================================================

GetSize proc	 near

	call	GetBioSize
	call	GetDosSize
	call	GetCmdSize
IFDEF DBLSPACE_HOOKS
	call	GetDblSize
ENDIF
	return

GetSize endp

; ==========================================================================

GetBioSize proc near
	mov	AX,WORD PTR Bios.fileSizeInBytes
	mov	DX,WORD PTR Bios.fileSizeInBytes+2
	call	AddToSystemSize
	return
GetBioSize endp

; ==========================================================================

GetDosSize proc near

	mov	AX,WORD PTR dos.fileSizeInBytes
	mov	DX,WORD PTR dos.fileSizeInBytes+2
	call	AddToSystemSize
	return

GetDosSize endp

; ==========================================================================

GetCmdSize proc near
	 mov	 AX,WORD PTR command.fileSizeInBytes
	 mov	 DX,WORD PTR command.fileSizeInBytes+2
	 call	 AddToSystemSize
	 return
GetCmdSize endp

IFDEF DBLSPACE_HOOKS
; ==========================================================================
GetDblSize proc near
	 mov	 AX,WORD PTR DblSpaceBin.fileSizeInBytes
	 mov	 DX,WORD PTR DblSpaceBin.fileSizeInBytes+2
	 call	 AddToSystemSize
	 return
GetDblSize endp
ENDIF

; ==========================================================================
;
; Calculate the	number of Sectors used for the system
;
; Input:	DX:AX holds size to be added on
; Ouput:	Updated SysSiz variable
;
; ==========================================================================

	PUBLIC	 AddToSystemSize
AddToSystemSize proc near

	push	BX
	div	DeviceParameters.DP_BPB.BPB_BytesPerSector
	or	DX,DX
	jz	FNDSIZ0
	inc	AX			; Round up to next sector
FNDSIZ0:
	push	AX
	xor	DX,DX
	xor	BX,BX
	mov	bl, DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	div	BX
	pop	AX
	or	DX,DX
	jz	OnClus
	sub	DX, BX
	neg	dx
	add	AX,DX			; Round up sector count to cluster
					; boundry
OnClus:
	mul	DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	WORD PTR SysSiz,AX
	adc	WORD PTR SysSiz+2,DX
	pop	BX
	return

AddToSystemSize endp

; ==========================================================================
;
; ChkSpace - Check free space to see if there is enough room to load the
;	      system.
;	 On entry: DL =	Drive
;	 On exit:  carry flag set if not enough	room
;		   no other registers are affected
;
; ==========================================================================

Procedure ChkSpace
	push	AX			; Save	registers
	push	BX
	push	CX
	push	DX
	mov	AH,36h			; Get free space
	int	21h
					; 16 bit math okay here
					; no danger of overflow
	mul	CX			; Get bytes/cluster
	mov	CX,AX
	mov	AX,WORD PTR SysSiz	; Get # of bytes for system
	mov	DX,WORD PTR SysSiz+2
	div	CX			; Get # of clusters for system

	cmp	AX,BX			 ; Is there enough space?
	jbe	EnoughSpace		 ;  Y: Go clear	carry
	stc				 ;  N: Set carry
	jmp	short RestoreRegs

EnoughSpace:
	clc

RestoreRegs:
	pop	DX			 ; Restore registers
	pop	CX
	pop	BX
	pop	AX
	ret

ChkSpace endp

; ==========================================================================
;
;  More :	This procedure prompts the user for the formatting of
;		another disk.
;
;  Output  :	User wants to continue - CY clear
;		User wants to exit     - CY set
;
; ==========================================================================

More PROC NEAR
	
	mov	Formatted_Tracks_Low,0		; Reinit the track counter
	mov	Formatted_Tracks_High,0		; in case of another format

; Begin M035		
	cmp	CMCDDFlag, Yes			; If flash disk we don't
	jne	@f				; allow multiple formats
	stc					; so signal an exit
	jmp	SHORT Exit_More
@@:
;end m035
						; If exec'd from select, then
						; don't give user choice
	test	SwitchMap,(SWITCH_SELECT or SWITCH_AUTOTEST or SWITCH_BACKUP)
	jz	@F
	stc  					; flag automatic 'no' response
	jmp	SHORT Exit_More

@@:						; Would not want to format
						; another hard disk!
	cmp	DeviceParameters.DP_DeviceType,DEV_HARDDISK
	jnz	NotAHardDisk
	stc  					; flag automatic 'no' response
	jmp	SHORT Exit_More

NotAHardDisk:
	call	FormatAnother?			; Get yes or no	response
        pushf                                   ; Save the result
        call    CrLf                            ; One new line
        popf                                    ; Get the result back
	jnc	WantsToContinue
;M002; Do not change ExitStatus
	stc
	jmp	SHORT Exit_More

WantsToContinue:
	call	CrLf

						; M033
	cmp	CMCDDFlag, Yes
	jne	more_standard_exit

	call	Prompt_User_For_disk		; If FLASH, we ask the
						; disk here if yes to more

more_standard_exit:

	clc

Exit_More:
	ret

More ENDP

; ==========================================================================
;
;  RestoreDevParm :	This procedure will prepare for exiting the program
;			by restoring the device parameters to their original
;			value.
;			Note: A call to SetDeviceParameters has the following
;			results:
;			With bit 0 of the SpecialFunctions byte SET,
;				BPB in parameter block is copied into BDS_BPB
;			With bit 0 of the SpecialFunctions byte RESET,
;				BPB in parameter block is copied into BDS_RBPB
;
; ==========================================================================

RestoreDevParm	proc	near

; M034 - begin
	cmp	CMCDDFlag, Yes			; This extra set_DPB would
	je	EndRestoreDevParm		; make the current card have
						; the size of the first card.
; M034 - end

	test	ValidSavedDeviceParameters, 0ffH
	jz	EndRestoreDevParm

	cmp	ExitStatus,EXIT_FATAL
	jnz	Non_Fatal			; NZ --> ExitStatus!=EXIT_FATAL

	test	NoDPChange,0ffh			; Check if drive parameters should not be modified
	jnz	Non_Fatal			; NoDPChange=1 --> do not modify

			; For a Fatal exit, it is necessary to reset the
			; BDS_BPB to the default settings, since it may have
			; been set to an invalid value

	mov	SavedParams.DP_TrackTableEntries,0	; There is no track layout info in SavedParams
	mov	SavedParams.DP_SpecialFunctions,INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD

	lea	DX, SavedParams
	call	SetDeviceParameters

	mov	FormatPacket.FP_SpecialFunctions,STATUS_FOR_FORMAT
	mov	AX,(IOCTL shl 8) or GENERIC_IOCTL
	mov	BL,Drive
	inc	BL
	mov	CX,(RAWIO shl 8) or FORMAT_TRACK
	lea	DX,FormatPacket
	int	21h

Non_Fatal:
	mov	SavedParams.DP_TrackTableEntries,0	; There is no track layout info in SavedParams
	mov	SavedParams.DP_SpecialFunctions,TRACKLAYOUT_IS_GOOD
	lea	DX, SavedParams
	call	SetDeviceParameters

EndRestoreDevParm:
	ret

RestoreDevParm	endp

;==========================================================================
;
;  SysPrm :	This procedure prompts the user for a system diskette
;		in the default drive.
;
;===========================================================================

SysPrm	proc	near

	mov	AH,GET_DEFAULT_Drive		; Find out the default Drive
	int	21h				; Default now in AL
	mov	BL,AL
	inc	BL				; A = 1
	add	AL,41h				; Now in Ascii
	mov	SystemDriveLetter,AL		; Text now ok
	call	IsRemovable
	jnc	DoPrompt

		; Media is non-removable. Switch sys disk to Drive A.
		; Check, though, to see if Drive A is removable too.

	 mov	 AL,"A"
	 mov	 BYTE PTR [SystemDriveLetter],AL
	 mov	 [BiosFile],AL
	 mov	 [DosFile],AL
	 mov	 [CommandFile],AL
IFDEF DBLSPACE_HOOKS
	 mov	 [DblSpaceFile], al
ENDIF
	 mov	 BX,1
	 call	 IsRemovable
	 jnc	 DoPrompt
	 Message msgNoSystemFiles

	 jmp	 FatalExit

DoPrompt:
	 mov	 AL, SystemDriveLetter
	 sub	 AL, 'A'
	 call	 AccessDisk
	 Message msgInsertDOSDisk
	 Message ContinueMsg

	 call	 USER_STRING			; Wait for a key
	 call	 CrLf
	 call	 CrLf

         ret
SysPrm	endp
;===========================================================================

ControlC_Handler:
	mov	AX, seg data
	mov	DS, AX
	Message msgInterrupt
	mov	ExitStatus, EXIT_CTRLC

				; Restore original Device Settings, as would
				; be done after completion of normal format

; M034 - begin
	cmp	CMCDDFlag, Yes		; This extra set_DPB would
	je	GotoExitProgram		; make the current card have
					; the size of the first card.

					; Note that this one is less critical
					; than the one in RestoreDevParams
					; (the disk is probably non-functional
					; anyway).
; M034 - end

	mov	SavedParams.DP_TrackTableEntries,0	; There is no track layout info in SavedParams
	mov	SavedParams.DP_SpecialFunctions,TRACKLAYOUT_IS_GOOD
	lea	DX, SavedParams
	call	SetDeviceParameters

GotoExitProgram:
	jmp	ExitProgram


CrLf:
	mov	DX,offset msgCrLf		; CR,LF	added to message
PrintString:
Std_Printf:
	call	Display_Interface
	return

;M018 - begin
;----------------------------------------------------------------------------
;
; Procedure Name : DIV32 (borrowed from dos\disk3.asm)
;
; Inputs:
;       DX:AX = 32 bit dividend   BX= divisor
; Function:
;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
; Outputs:
;       CX:AX = quotient , DX= remainder
; Uses:
;       All registers except AX,CX,DX preserved.
;----------------------------------------------------------------------------
Div32	proc	near

	mov	cx,ax		; Save least significant word
	mov	ax,dx
	xor	dx,dx
	div	bx		; 0:AX/BX
	xchg	cx,ax		; Restore least significant word and save
				; most significant word
	div	bx		; DX:AX/BX
	ret

Div32	endp
;M018 - end

; ==========================================================================
;
;    Phase2Initialisation:
;	 Use device parameters to build	information that will be
;	 required for each format
;
;    Algorithm:
;	 Calculate first head/cylinder to format
;	 Calculate number of tracks to format
;	 Calculate the total bytes on the disk and save	for later printout
;	 First initialise the directory	buffer
;
; ==========================================================================

Phase2Initialisation proc near
					; Calculate first track/head to format
					; (round up - kludge)
	mov	AX, DeviceParameters.DP_BPB.BPB_HiddenSectors
	mov	DX, DeviceParameters.DP_BPB.BPB_HiddenSectors + 2
	add	AX, DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	adc	DX, 0
	dec	AX
	sbb	DX, 0

;M018	div	DeviceParameters.DP_BPB.BPB_SectorsPerTrack
;M018	xor	DX,DX

;M018 - begin
	mov	BX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	call	Div32
	mov	DX,CX			; Forget remainder. DX:AX= tracks*heads
					; before M018 we were assuming tracks*head
					; fitted in a word.
;M018 - end

	div	DeviceParameters.DP_BPB.BPB_Heads

	mov	FirstCylinder,	AX
	mov	FirstHead, DX
					; Calculate the total number of tracks
					; to be formatted (round down - kludge)
	mov	AX, DeviceParameters.DP_BPB.BPB_TotalSectors
	xor	DX,DX
					; if (TotalSectors == 0) then use
					; BigTotalSectors
	or	AX,AX
	jnz	NotBigTotalSectors
	mov	AX, DeviceParameters.DP_BPB.BPB_BigTotalSectors
	mov	DX, DeviceParameters.DP_BPB.BPB_BigTotalSectors + 2

NotBigTotalSectors:
;M018	div	DeviceParameters.DP_BPB.BPB_SectorsPerTrack
;M018	mov	TracksPerDisk,	AX

;M018 - begin
	mov	BX,DeviceParameters.DP_BPB.BPB_SectorsPerTrack
	call	div32
	mov	word ptr TracksPerDisk, AX
	mov	word ptr TracksPerDisk+2, CX
;M018 - end

	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	xor	DX, DX
	mov	BX, size dir_entry
	div	BX
	mov	CX, AX

	les	BX, DirectorySector
					; If Old_Dir =	TRUE then put the first
					; letter of each must be 0E5H
	xor	AL, AL
	cmp	old_Dir, TRUE
	jne	StickE5
	mov	AL, 0e5H

StickE5:
	mov	ES:[BX], AL
	add	BX, size dir_entry
	loop	stickE5

	ret

Phase2Initialisation endp

;========================================================================
;
; ShowFormatSize :	This procedure calculates the size of the disk
;			being formatted, and displays an appropriate
;			message.
;
; Strategy :	The total number of bytes on the volume are first calculated.
;		This is converted to K by dividing by 1024.  If the number
;		is less than 1000, the size in K is printed.  Otherwise
;		the number is converted to Megs, as follows.  If size in K
;		is less than 10,000
;			Megs = Kbytes / 1000
;		else
;			Megs = Kbytes / 1024
;		Nonzero decimals will be printed for megs.
;
; Calls :	Multiply_32_Bits
;
; Registers Destroyed :	AX,BX,CX,DX
;
;
;========================================================================

ShowFormatSize	proc	near

	mov	CX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	xor	DX,DX
	mov	AX,DeviceParameters.DP_BPB.BPB_TotalSectors
	or	AX,AX				; If zero, use BigTotalSectors
	jnz	UseSmall

UseBigSectors:
	mov	AX,DeviceParameters.DP_BPB.BPB_BigTotalSectors
	mov	BX,DeviceParameters.DP_BPB.BPB_BigTotalSectors[2]
	call	Multiply_32_Bits
	jnc	NoOverflow
	ret

NoOverflow:
	mov	DX,BX				; Now DX:AX has total bytes
	jmp	SHORT DoDivide

UseSmall:
	mul	CX				; Now DX:AX has total bytes

DoDivide:
	mov	CX,10				; Set up shift count
Div1024:
	shr	DX,1   				; Rotate DX:AX
	rcr	AX,1
	loop	Div1024					

	cmp	AX,999				; Check if DX:AX >= 1000
	ja	GetMegs
	or	DX,DX				; DX nonzero --> Very big number!
	jnz	GetMegs

	mov	SizeInK,AX
	mov	dx,offset data:msgQuickFormatShowKBytes
	test	SwitchMap,SWITCH_Q
	jnz	GotoDisplaySize
	mov	dx,offset data:msgShowKBytes
	test	SwitchMap,SWITCH_U
	jnz	GotoDisplaySize
	mov	dx,offset data:msgVerifyShowKBytes

GotoDisplaySize:
	jmp	DisplaySize	

GetMegs:
	cmp	AX,10000			; Check if DX:AX > 10000
	ja	UseRealMegs
	or	DX,DX
	jnz	UseRealMegs

UseFloppyMegs:
	mov	BX,1000				; DX:AX <= 10000
	div	BX				; Get size in Megs
	jmp	SHORT DoneDivision

UseRealMegs:
	mov	BX,1024				; DX:AX > 10000
	div	BX				; Get size in Megs

;M003 - begin
	push	AX				; bring reminder
	mov	AX,DX				; to 1/1000 instead
	xor	DX,DX				; of 1/1024
	mov	BX,250				; multiply by 250
	mul	BX
	mov	DH,DL				; divide by 256
	mov	DL,AH
	pop	AX
;M003 - end
	
DoneDivision:
	mov	SizeInM,AX
	cmp	DX,10				; Check for nonzero decimals
	jnb	ShowDecimals
	mov	dx,offset data:msgQuickFormatShowMBytes
	test	SwitchMap,SWITCH_Q
	jnz	DisplaySize
	mov	dx,offset data:msgShowMBytes
	test	SwitchMap,SWITCH_U
	jnz	DisplaySize
	mov	dx,offset data:msgVerifyShowMBytes
	jmp	short DisplaySize	

;M007 - begin

ShowDecimals:
	mov	AX,DX				; set up for division of
	xor	DX,DX				;  remainder by 10
	mov	BX,10
	div	BX
	mov	CX,AX
	xor	DX,DX
	div	BX
	or 	DX,DX				; Do not display 2d.p.s if 2nd d.p. is zero
	jnz	TwoDecPlaces			; Must display 2 d.p.

OneDecPlace:
	mov	DecSizeInM,AX			; Display only 1 d.p.
	mov	msgDecimalNumberofDecimal,1
	jmp	SHORT ShowDecMessage

TwoDecPlaces:
	mov	DecSizeInM,CX			; Display original 2 d.p.s
	mov	msgDecimalNumberofDecimal,2

ShowDecMessage:
	mov	dx,offset data:msgQuickFormatDecimalMBytes
	test	SwitchMap,SWITCH_Q
	jnz	DisplaySize
	mov	dx,offset data:msgDecimalMBytes
	test	SwitchMap,SWITCH_U
	jnz	DisplaySize
	mov	DX,offset data:msgVerifyDecimalMBytes

DisplaySize:
	call	Display_Interface
	ret

;M007 - end

ShowFormatSize	endp

;=========================================================================
; WRITE_Fat	 :	 This routine writes the logical sector	count requested.
;			 It will write a mAXimum of 40h	Sectors.  If More
;			 than 40h exists it will continue looping until
;			 all Sectors have been written.
;
;	 Inputs	 :	 AL - Drive letter
;			 DS:BX - Segment:offset	of transfer address
;			 CX - Sector count
;			 DX - 1st. sector
;
;	 Outputs :	 Logical Sectors written
;=========================================================================

procedure write_Fat

	mov	CX, ES:DeviceParameters.DP_BPB.BPB_SectorsPerFat

;	$do					; while Sectors left
$$DO67:
	cmp	CX,00h				; any Sectors?
	je	$$EN67				; no

  	cmp	CX,40h
	jna	$$IF69				; yes

	push	CX				; save CX
	mov	CX,40h
	push	AX				; save AX
	call	write_disk			; write it
	pop	AX				; restore AX
	pop	CX				; restore CX
	jc	Write_Exit			; exit if fail

	mov	SI,8000h
	call	seg_adj				; adjust segment
	mov	BX,SI				; new offset
	add	DX,40h
	sub	CX,40h
	jmp	SHORT $$EN69			; < 64k

$$IF69:
	push	AX				; save AX
	call	write_disk			; write it
	pop	AX				; restore AX
	xor	CX,CX				; set CX to 0 - last read

$$EN69:
	jmp	SHORT $$DO67

$$EN67:
	Write_Exit:
	ret

write_Fat ENDP

;=========================================================================
; SEG_ADJ	 :	 This routine adjusts the segment:offset to prevent
;			 address wrap.
;
;	 Inputs	 :	 SI - Offset to	adjust segment with
;			 DS - Segment to be adjusted
;
;	 Outputs :	 SI - New offset
;			 DS - Adjusted segment
;=========================================================================

procedure seg_adj

	push	AX
	push	BX
	push	DX

	mov	AX,SI				; get offset
	mov	BX,0010h			; 16
	xor	DX,DX				; clear DX
	div	BX				; get para count
	jnc	$$IF73				; overflow?
	adc	BX,0				; pick it up

$$IF73:
	mov	BX,DS				; get seg
	add	BX,AX				; adjust for paras
	mov	DS,BX				; save new seg
	mov	SI,DX				; new offset

	pop	DX
	pop	BX
	pop	AX
	ret

seg_adj  ENDP

; =========================================================================
;	 format	is done... so clean up the disk!
; =========================================================================

Done PROC NEAR


	call	OemDone
	return

Done	 ENDP


; =========================================================================
;	PrintErrorAbort:
;	 Print an error	message	and abort
;
;    Input:
;	 DX - Pointer to error message string
; =========================================================================

PrintErrorAbort PROC NEAR

	push	DX
	call	CrLf
	pop	DX
	call	PrintString
	jmp	FatalExit

PrintErrorAbort ENDP





;=========================================================================
; Ctrl_Break_Write	 : This	routine	takes the control break	request
;			   an returns.	In essence, it disables	the CTRL-BREAK.
;			   This	routine	is used	during the writing of the
;			   Fat,	DIR, and SYSTEM.
;
;=========================================================================

Ctrl_Break_Write:

	iret					; return to caller


;=========================================================================
; Ctrl_Break_Save	 : This	routine	gets the current vector	of
;			   int 23h and saves it	in CTRL_BREAK_VECTOR.
;	 Inputs	 : none
;
;	 Outputs : CTRL_BREAK_VECTOR - holds address of	int 23h	routine
;=========================================================================

Ctrl_Break_Save PROC NEAR

	push	ES
	push	BX
	push	AX

	mov	AX,3523h			; Get CTRL-BREAK
						; Interrupt vector
	int	21h

	mov	WORD PTR Ctrl_Break_Vector,BX	; Get vector offset
	mov	WORD PTR Ctrl_Break_Vector+2,ES ; Get vector segment

	pop	AX
	pop	BX
	pop	ES

	ret


Ctrl_Break_Save ENDP

;=========================================================================
; Set_Ctrl_Break	 : This	routine	sets the CTRL-Break vector to one
;			   defined by the user.
;
;	 Inputs	 : none
;
;	 Outputs : CTRL_BREAK_VECTOR - holds address of	int 23h	routine
;=========================================================================

Set_Ctrl_Break PROC NEAR

	push	DS				; Save ds
	push	AX				; Save AX
	push	BX				; Save BX
	push	DX				; Save DX

	push	CS				; Swap cs with DS
	pop	DS				; Point to code seg

	mov	DX,offset Ctrl_Break_Write	; Get interrupt vec.
	mov	AX,2523h			; Set CTRL-BREAK
						; Interrupt vector
	int	21h

	pop	DX				; Restore DX
	pop	BX				; Restore BX
	pop	AX				; Restore AX
	pop	DS				; Restore DS

	ret

Set_Ctrl_Break ENDP

;=========================================================================
; Reset_Ctrl_Break	 : This	routine	resets the CTRL-Break vector to	that
;			   originally defined.

;	 Inputs	 : CTRL_BREAK_VECTOR - holds address of	int 23h	routine

;	 Outputs : none
;=========================================================================

Reset_Ctrl_Break PROC NEAR

	push	DS
	push	AX
	push	BX
	push	DX

	mov	AX,WORD PTR Ctrl_Break_Vector+2 ; Get seg. of vector
	mov	BX,WORD PTR Ctrl_Break_Vector	; Get off. of vector
	mov	DS,AX				; Get seg.
	mov	DX,BX				; Get off.
	mov	AX,2523h			; Set CTRL-BREAK
						; Interrupt vector
	int	21h

; ========================================================================
;IF SAFE
;	call	Restore_Int_24			; Restore int 24h handler
;ENDIF
; ========================================================================

	pop	DX
	pop	BX
	pop	AX
	pop	DS

	ret


Reset_Ctrl_Break ENDP


; =========================================================================
; Get_PSP_Parms
; =========================================================================

Procedure Get_PSP_Parms

	Set_Data_Segment
	mov	AX,PSP_Segment			; Get segment of PSP
	mov	DS,AX

	assume	DS:notHING			; Setup segment of Environment
	mov	AX,DS:PSP_Environ		; string, get from PSP
	mov	ES:Environ_Segment,AX
	Set_Data_Segment
	ret

Get_PSP_Parms ENDP


;=========================================================================
; Cap_Char	 : This	routine	will capitalize	the character passed in
;		   DL.
;
;	 Inputs	 : DL -	Character to be	capitalized
;
;	 Outputs : DL -	Capitalized character
;=========================================================================

Procedure Cap_Char

	push	AX				; Save AX
	mov	AX,6520h			; Capitalize character
	int	21h
	pop	AX				; Restore AX
	ret

Cap_Char ENDP


;=========================================================================
;
; Set_CDS_Off			 - This	routine	disallows access to a
;				   disk	if a format fails on a non-Fat
;				   formatted disk.
;
;=========================================================================

Procedure Set_CDS_Off

	push	AX				; Save regs
	push	DX

	mov	AX,5f08h			; Reset CDS
	mov	DL,Drive			; Drive to reset
	int	21h

	pop	DX				; Restore regs
	pop	AX

	ret

Set_CDS_Off ENDP


;=========================================================================
;
; Format_Access_Wrap_Up	 -	This routine determines whether or
;				not access should be allowed to the
;				disk based on the exit Status of
;				format.
;
;=========================================================================

Procedure Format_Access_Wrap_Up

	cmp	Disk_Access.DAC_Access_Flag,0ffh ; Access prev. allowed?
	je	$$IF140 			; No

	cmp	ExitStatus,EXIT_OK		; Good exit?
	je	$$IF141 			; No
	cmp	ExitStatus,EXIT_NO		; User said no?
	je	$$IF141 			; No

	lea	DX,Disk_Access			; Point to parm block
	mov	Disk_Access.DAC_Access_Flag,00h ; Signal no disk access
	call	Set_Disk_Access_On_Off		; Don't allow disk access
	jmp	SHORT $$EN141			; Bad exit

$$IF141:
	lea	DX,Disk_Access			; Point to parm block
	mov	Disk_Access.DAC_Access_Flag,01h ; Signal disk access
	call	Set_Disk_Access_On_Off		; Allow disk access

$$EN141:
$$IF140:
	cmp	Fat_Flag,No			; Non-Fat format?
	jne	$$IF145 			; Yes

	cmp	ExitStatus,EXIT_OK		; Good exit?
	je	$$IF146 			; No

	call	Set_CDS_Off			; Disallow Fat access

$$IF146:
$$IF145:
	ret

Format_Access_Wrap_Up ENDP

;=====================================================================
;
;  FindNClusters :	This procedure will search through the FAT on
;			disk to find N consecutive free clusters.
;
;			N = number of clusters required to allow space for
;			    a file of size 1.5Kbytes (i.e. IO.SYS) e.g. with
;			    2 sectors/cluster, N=2.
;
;			If these are found, a disk reset will be performed
;			and disk allocation will be forced to start from
;			the start of these cluster blocks.  This is to ensure
;			that when the system files are written out, IO.SYS
;			(which is written first), will  be contiguous, and
;			hence the disk can be bootable.
;
;  Arguments :	NumClusters = N
;
;  Returns   :  NC --> Success
;		CY --> Failure  (no action taken)
;
;  Calls     :	calc_sector_and_offset
;		ReadFatSector
;		GetFatSectorEntry
;
;  Destroys  :	AX,BX,CX,DX,DS
;
;=======================================================================

FindNClusters	proc	NEAR

	mov	AX,DATA
	mov	ES,AX				; ES --> DATA
	assume	DS:NOTHING,ES:DATA

	mov	ES:FoundN,FALSE			;initialize flag
	mov	ES:Cluster,2			;search from cluster 2
	mov	ES:sector_in_buffer,0ffffh	;force first FAT read

Search:	mov	AX,ES:Cluster			;load current cluster
	call	calc_sector_and_offset		;find location in FAT

	mov	BX,ES:sector_in_buffer
	mov	AX,ES:sector_to_read
	cmp	AX,BX				;is required sector in buffer?
	jz	IsInBuffer

	call	ReadFatSector			;read it in
	jnc	IsInBuffer			;check for error
	jmp	ErrorExit			;abort if error

IsInBuffer:
	lds	SI,ES:FatSector			;DS:SI --> FAT buffer
	call	GetFatSectorEntry		;AX = cluster value

	or	AX,AX				;is this cluster free?
	jnz	FreeNotFound			;nonzero --> not free

	mov	ES:FoundN,TRUE			;initialize to success
	mov	CX,ES:NumClusters		;CX = N, loop control variable

CheckFreeChain:
	mov	AX,ES:Cluster			;load current cluster
	push	CX				;preserve CX!
	call	calc_sector_and_offset		;find location in FAT
	pop	CX				;restore CX

	mov	BX,ES:sector_in_buffer		;N cluster block may overlap FAT sectors
	mov	AX,ES:sector_to_read
	cmp	AX,BX				;is required sector in buffer?
	jz	IsInBuffer2

	push	CX				;preserve CX!
	call	ReadFatSector			;read it in
	pop	CX				;restore CX
	jc	ErrorExit			;abort if error

IsInBuffer2:
	lds	SI,ES:FatSector			;DS:SI --> FAT buffer
	push	CX				;preserve CX!
	call	GetFatSectorEntry		;AX = cluster value
	pop	CX				;restore CX

	or	AX,AX				;is this cluster free?
	jnz	FreeChainTooSmall		;did not find N consecutive free clusters

	inc	ES:Cluster			;check next consecutive cluster
	loop	CheckFreeChain			;check for N consecutive free clusters

	jmp	SHORT CheckExitState

FreeChainTooSmall:
	mov	ES:FoundN,FALSE			;not enough free consecutive clusters
	jmp	SHORT CheckExitState		;terminate loop now

FreeNotFound:
	inc	ES:Cluster			;advance current cluster

CheckExitState:
	cmp	ES:FoundN,TRUE			;did we succeed yet?
	jz	Success				;yes, set NC

	mov	AX,ES:Cluster
	cmp	AX,ES:TotalClusters		;no more clusters?
	ja	Failure				;M015; reached last cluster, set CY

	jmp	Search				;search until found or clusters exhausted

Success:
				;at this point we have
				;starting cluster of free block = Cluster - N

	mov	AH,DISK_RESET			;DOS disk reset function 0dh
	int	21h				;reset disk to flush all buffers
	jc	ErrorExit			;check for errors

	mov	DL,ES:Drive			;get drive number
	inc	DL				;convert to DOS drive (1=A)
	mov	AH,GET_DPB			;undocumented DOS function
	int	21h
	cmp	AL,-1				;check for errors
	jz	ErrorExit

	mov	AX,ES:Cluster			;find start of free cluster block
	sub	AX,ES:NumClusters

	mov	[BX.dpb_next_free],AX		;start allocation from this cluster
	clc
	jmp	SHORT ExitFindN

Failure:
ErrorExit:
	stc

ExitFindN:
	ret

FindNClusters	endp



;=========================================================================
;
;  WriteDiskInfo :	This procedure writes out all the control info to
;			the disk, after it has been formatted/verified/
;			quick formatted.  This includes the Boot Sector,
;			Root Directory and FAT.  If /s is present System
;			files will also be written out, if there is enough
;			disk space.
;
;  STRATEGY :		If a safe format is being done (/U not present), it
;			is not necessary to have a directory entry for the
;			recovery file.  A special case arises when a safe
;			format is being done, and /S is present (system
;			required).  In this case it is necessary to write out
;			the system files with the old FAT intact, so as to
;			prevent over-writing any old files.  The FAT chains
;			must then be copied to the new FAT, which is then
;			written out to disk.
;
;  DESTROYS :		AX,BX,CX,DX,SI,DI
;
;=========================================================================

WriteDiskInfo	proc	NEAR

	Set_Data_Segment			;DS,ES = DATA
	assume	DS:DATA,ES:DATA

	test	SwitchMap,SWITCH_S		;if system requested, calculate size
	jz	Cleared

	test	SwitchMap,SWITCH_U		;check for not(/U) & /S combination
	jnz	@F				;normal case

	mov	SpecialCase,TRUE		;special case of not(/U) & /S

@@:	cmp	BYTE PTR DblFlg,0		;is sys space already calculated?
	jnz	Cleared				;yes

	inc	BYTE PTR DblFlg			;no --	set the	flag
	call	GetSize				;calculate the	system size

Cleared:
	call	Ctrl_Break_Save			;disallow Ctrl_C here
	call	Set_Ctrl_Break

	call	WriteBootSector			;write out Boot Sector
	jnc	BootSectorOk			;check for error

	call	Reset_Ctrl_Break		;error occurred
;	Message	msgDiskUnusable			; M013
	jmp	Problems

BootSectorOk:
	push	DS				;preserve DS
	lds	BX,DirectorySector		;set up for call
	call	ClearDirSector			;fill root dir sector with zeroes
	pop	DS				;restore Ds

	call	WriteRootDir			;write out Root Directory
	jnc	RootDirOk			;check for error

	call	Reset_Ctrl_Break		;error occurred
	Message	msgDirectoryWriteError
	jmp	Problems

RootDirOk:
	cmp	SpecialCase,TRUE
	jz	@F				;don't write FAT yet for special case

DestroyOldFat:
	call	WriteFat			;write out FAT
	jnc	FatOk				;check for error

	call	Reset_Ctrl_Break		;error occurred
	Message	msgFatWriteError
	jmp	Problems

@@:
FatOk:
						;restore good tracklayout for drive
	mov	SavedParams.DP_TrackTableEntries,0
	mov	SavedParams.DP_SpecialFunctions,TRACKLAYOUT_IS_GOOD
	lea	DX,SavedParams
	call	SetDeviceParameters

				;now perform an undocumented GET_DPB call to
				;force allocation to be reset from the start
				;of the disk, and force free disk space to be
				;calculated

	push	DS				;preserve DS

	mov	DL,Drive			;set up for function call
	inc	DL				;convert to DOS drive (1=A)
	mov	AH,GET_DPB
	int	21h
	cmp	AL,-1				;check for error
	jnz	GotDpb

	pop	DS				;error occurred, restore DS here
	call	Reset_Ctrl_Break
	Message	msgDiskUnusable
	jmp	Problems

GotDpb:	mov	[BX.dpb_next_free],0		;reset allocation to start of disk
	mov	[BX.dpb_free_cnt],-1		;force free space to be computed

	pop	DS				;restore DS

	test	SwitchMap,SWITCH_S		;is system desired?
	jnz	@F				;yes, transfer it
	jmp	ResetCtrlBreak			;no, go finish up

@@:	mov	DL,Drive			;system is required, set up for call
	inc	DL				;DL = drive code (1 = A)
	call	ChkSpace			;check if there's enough space
	jnc	SpaceOK				;  Y: Go load system files

NoRoom:	cmp	SpecialCase,TRUE		;is SAFE format being done?
	jnz	DiskTooSmall			;no - disk is actually too small

						;there is no space for system
						; due to old disk files
	Message	msgSysWarning			;ask user for choice
	call	Yes?
	
	pushf	       				;save flags
	Message	msgCrLf				;cursor to next screen line
	popf					;restore flags
	
	jc	SaysNo				;user entered "No"

						;user wants unconditional sys transfer
	mov	SpecialCase,FALSE		;write out sys as for unconditional format
	jmp	DestroyOldFat			;write out new FAT & system files

SaysNo:	mov	ExitStatus,EXIT_NO		;terminate Format after this disk
						; (since sys size is zeroed out)
	jmp	SHORT CancelSystem		;skip the message below
	
DiskTooSmall:					;disk is physically too small
	Message msgNoRoomDestDisk		;  N: Print error message

CancelSystem:
	mov	WORD PTR SysSiz+2,0		;no system transferred
	mov	WORD PTR SysSiz,0		;reset system sizes to zero

	xor	AX,AX
	mov	word ptr [Dos.FileSizeInBytes+0],AX	;get low word
	mov	word ptr [Dos.FileSizeInBytes+2],AX	;get high word
	mov	word ptr [Bios.FileSizeInBytes+0],AX	;get bios size
	mov	word ptr [Bios.FileSizeInBytes+2],AX
	mov	word ptr [Command.FileSizeInBytes+0],AX ;get command size
	mov	word ptr [Command.FileSizeInBytes+2],AX

IFDEF DBLSPACE_HOOKS
	mov	word ptr [DblSpaceBin.FileSizeInBytes+0], ax	; clr dblspace
	mov	word ptr [DblSpaceBin.FileSizeInBytes+2], ax	;   size
ENDIF

	cmp	SpecialCase,TRUE		;is this a special case?
	jz	WriteFatNow			;yes, write FAT after sys transfer
	jmp	ResetCtrlBreak			;no, FAT is already written

WriteFatNow:
	call	WriteFat			;write out FAT now, since no space for system files
	jc	FatError			;check for error
	jmp	ResetCtrlBreak			

FatError:
	call	Reset_Ctrl_Break		;error occurred
	Message	msgFatWriteError
	jmp	Problems

SpaceOK:
	cmp	SpecialCase,TRUE		;is this a special case?
	jnz	WriteSys			;no, go ahead and transfer system

	call	ComputeN			;determine value of NumClusters

	cmp	NumClusters,1			;do we need only 1 cluster for IO.SYS?
	jz	@F				;yes, no need to find contiguous clusters

	push	DS				;preserve DS
	call	FindNClusters			;search for N contiguous clusters
						; and force allocation to start from there
	pop	DS				;restore DS
	jnc	WriteSys			;NC --> successful
	jmp	NoRoom				;CY --> unsuccessful.  Give
						; message & write FAT

@@:
WriteSys:
	mov	AL,Drive
	call	AccessDisk			;note what is current logical drive

;				; this func. was used to call writedos in a loop
;	call	WriteSysFiles
;
	push	DS				; preserve DS & ES!
	push	ES

	call	WriteDos			;write	the BIOS & DOS

	pop	ES				; restore DS & ES!
	pop	DS

	jnc	SysOk				;check for error

	Message msgNotSystemDisk		;no system transferred
	mov	WORD PTR SysSiz+2,0		;reset system size to zero
	mov	WORD PTR SysSiz,0

	cmp	SpecialCase,TRUE		;is this a special case?
	jnz	CleanUp				;no

	call	WriteRootDir			;write out Root Directory again
						; to zero out any new entry
	jnc	RootDirOk2			;check for error

	call	Reset_Ctrl_Break		;error occurred
	Message	msgDirectoryWriteError
	jmp	SHORT Problems

RootDirOk2:
	jmp	WriteFatNow			;write out new FAT now, since
						; system transfer failed
CleanUp:
	jmp	SHORT ResetCtrlBreak		;go finish up

SysOk:						;don't display if EXEC'd by Select
	test	SwitchMap,(SWITCH_SELECT or SWITCH_AUTOTEST)
	jnz	@F				;skip message

	Message msgSystemTransfered

@@:	cmp	SpecialCase,TRUE		;is this a special case?
	jnz	ResetCtrlBreak			;no, not necc to copy FAT chains

	mov	AL,Drive			;signal drive to access (0 = A)
	call	CopyFatChains			;copy system file chains to new FAT
	jmp	WriteFatNow			;now write out the FAT

ResetCtrlBreak:
	call	Reset_Ctrl_Break		;restore CTRL-Break
	call	CrLf

	mov	AH,DISK_RESET			;do a disk reset
	int	21h

	call	DONE				;final call to OEM module
	jnc	ReportC				;check for error

	jmp	SHORT Problems			;report an error

ReportC:					;temp fix for /AUTOtest
	test	SwitchMap,(SWITCH_AUTOTEST or SWITCH_8)
	jnz	@F				;volume label not supported with /8
	call	VolId				;handle volume label

@@: 						;need to shut down the report?
	test	SwitchMap,(SWITCH_SELECT or SWITCH_AUTOTEST)
	jnz	Successful_End		 	;no report if exec'd by Select

	call	Report				;print report
	jmp	SHORT Successful_End

Problems:
	test	SwitchMap,SWITCH_SELECT		;SELECT option?
	jnz	@F				;no message if EXEC'd

	Message msgFormatFailure
	mov	ExitStatus,EXIT_FATAL
	stc
	jmp	SHORT End_WriteDiskInfo

Successful_End:
	clc

End_WriteDiskInfo:
	ret

WriteDiskInfo	ENDP


;========================================================================
;
;  WriteRootDir :	This procedure writes out a zeroed root directory
;			to disk.
;
;  RETURNS  :	NC --> success
;		CY --> failure
;
;  DESTROYS :	AX,BX,CX,DX
;
;========================================================================

WriteRootDir	proc	NEAR

	assume	DS:DATA,ES:DATA
					;find sector offset of root dir on disk
	xor	DX,DX
	xor	BX,BX
	mov	BL,DeviceParameters.DP_BPB.BPB_NumberOfFats
	mov	AX,DeviceParameters.DP_BPB.BPB_SectorsPerFat
	mul	BX				;AX = total FAT Sectors

	mov	DX,DeviceParameters.DP_BPB.BPB_ReservedSectors
	add	DX,AX				;DX = root dir start sector

	mov	CX,SectorsInRootDirectory	;CX = sectors to write, loop control

WriteASector:
	mov	AL,Drive
				; Assume dir is always contained in first
				; 32mb of partition
	mov	Read_Write_Relative.Start_Sector_High,0

	push	CX				;preserve loop count CX
	mov	CX,1				;CX = sectors to write

	push	DS				;preserve DS
	lds	BX,DirectorySector		;DS:BX --> zeroed sector
	assume	DS:NOTHING,ES:DATA

	call	Write_Disk			;write all the sectors
	pop	DS				;restore DS
	assume	DS:DATA,ES:DATA

	pop	CX				;restore CX
	jc	@F				;if error occurred, break loop

	inc	DX				;write to next sector
	loop	WriteASector			;write all sectors of root dir

@@:	ret
WriteRootDir	endp



;==========================================================================
;
;  WriteFat :		This procedure copies the contents of the FatSpace
;			buffer to each of the FAT areas on disk.
;
;  RETURNS  :	NC --> success
;		CY --> failure
;
;  CALLS    :   Write_Fat
;
;  DESTROYS :	AX,BX,CX,DX,SI
;
;==========================================================================

WriteFat	proc	NEAR

	assume	DS:DATA,ES:DATA

	push	DS				;preserve DS

	xor	CX,CX
	mov	CL,DeviceParameters.DP_BPB.BPB_NumberOfFats	;loop control
	or	CX,CX				;check for zero
	jz	ExitWriteFat

	mov	DX,DeviceParameters.DP_BPB.BPB_ReservedSectors	;starting sector
	mov	AL,Drive

	lds	BX,FatSpace			;DS:BX --> FatSpace
	assume	DS:NOTHING,ES:DATA

	mov	SI,BX				;Set up for add. calc
	call	SEG_ADJ 			;Get adjusted seg:off
	mov	BX,SI				;Get new offset

WriteFatLoop: 					;loop while FATs > 0
	push	BX				;save Fat offset
	push	DS				;save Fat segment
	push	CX				;save Fat count
	push	DX				;reserved Fat sector
	call	Write_Fat			;write the Fat
	pop	DX				;get 1st. Fat sector
	pop	CX				;get Fat count
	pop	DS				;restore Fat segment
	pop	BX				;restore Fat offset
	jc	ExitWriteFat			;check for errors

	add	DX,ES:DeviceParameters.DP_BPB.BPB_SectorsPerFat	;next FAT start sector

	loop	WriteFatLoop			;write all FATs

	clc					;signal success

ExitWriteFat:
	pop	DS				;restore DS
	assume	DS:DATA

	ret
WriteFat	endp







;===============s============================================================
; Routine name: CopyFatChains
;===========================================================================
;
; Description: Copies the system FAT file chains from the existing
;	       FAT into the new FAT in memory that was created by
;	       by format.
;
; Arguments:		AL = DOS drive number
;			ES = DATA
; -------------------------------------------
; Returns:   		Carry set if disk error
; ---------------------------------------------
; Registers destroyed:	AX BX CX DX
; ---------------------------------
; Strategy
; --------
;	Read in first sector of the root directory
;	Set up a loop to find the starting cluster of each
;	file and then copy it's cluster chain to the new
;	FAT the was created during FORMAT.
;
;===========================================================================

CopyFatChains PROC NEAR

	Set_Data_Segment
	assume	DS:DATA,ES:DATA

	push	DI
	push	SI
	push	DS
	push	ES

	mov	sector_in_buffer,0ffffh	; force first read to ensure valid buffer

; Read in the root directory
	lds	BX,DirBuf		; DS:BX --> Read buffer
	assume	DS:NOTHING,ES:DATA

	mov	CX,1			; CX = Number of sector to read

	push	AX			; Preserve AX

					; Calculate root dir starting sector
	mov	AX,ES:DeviceParameters.DP_BPB.BPB_SECTORSPERFAT
						; Find sectors in all fats
	mul	ES:DeviceParameters.DP_BPB.BPB_NUMBEROFFATS
						 ; Add reserved sectors
	add	AX,ES:DeviceParameters.DP_BPB.BPB_RESERVEDSECTORS

	mov	DX,AX			; DX = Start sector
	pop	AX			; Restore AX
					; we are accessing < 32mb
	mov	ES:Read_Write_Relative.Start_Sector_High,0

	call	Read_Disk		; Read in the sector
	jnc	SetupCount		; If no error then walk the FAT
	jmp	SHORT CopyChainExit	; Error detected

SetupCount:
	mov	CX,NUM_SYS_FILES	; Set number of files to walk

IFDEF DBLSPACE_HOOKS
	cmp	es:fDblSpace, TRUE	; One less file to walk if
	je	AllSysFiles		;   DblSpace.bin wasn't copied
	dec	cx
AllSysFiles:
ENDIF

	mov	SI,BX			; DS:SI --> First directory entry

	test	ES:fBigFAT,0ffh		; See if 16 bit fat
	jz	Set12BitCluster		; If zero then 12 bit fat
	mov	BX,0fff8h		; Set 16 bit value for end chain
	jmp	SHORT ClearDirection

Set12BitCluster:
	mov	BX,0ff8h		; Set 12 bit value for end chain

ClearDirection:
	cld				; Clear the direction flag
	mov	ES:EndValue,BX

; Loop once for each entry in the Dir buffer
CopyChainLoop:
	push	CX			; Save loop count
	push	SI			; Save pointers to directory
	push	DS

	mov	AL,[SI]			; Get first char of entry name
	or	AX,AX			; Check for null entry
	jz	SetupNextWalk
	cmp	AL,0e5h			; See if entry is deleted
	je	SetupNextWalk		; If deleted nothing to do this loop
	mov	AX,[SI+26]		; AX = Starting cluster number
	or	AX,0			; Make sure cluster is not zero
	jz	SetupNextWalk
	mov	DI,AX			; DI will always hold current cluster


GetNextFatCluster:
	call	calc_sector_and_offset	; Find entry location in FAT

	mov	BX,ES:sector_in_buffer
	mov	AX,ES:sector_to_read
	cmp	AX,BX			; check if required sector is in buffer
	je	NoNeedToRead

	call	ReadFatSector		; read a sector of the FAT into buffer
	jc	CopyChainExit		; check for error

NoNeedToRead:
	lds	SI,ES:FatSector		; DS:SI --> Fat buffer
	call	GetFatSectorEntry	; AX = next cluster in the chain

CopyToFormatBuffer:
	mov	CX,AX			; CX = Value to set in format's buf
	mov	AX,DI			; AX = This cluster number
	mov	DI,CX			; Set up for next loop
	lds	SI,ES:FatSpace		; DS:SI --> Format's fat buffer
	call	GetSetFatEntry		; Set the cluster in format's buffer

	mov	AX,DI			; set up for next offset calculation

	mov	BX,ES:EndValue		; Restore end of chain value
	cmp	DI,BX			; Check for end of cluster chain
	jb	GetNextFatCluster	; Not end of chain

SetupNextWalk:
	pop	DS			; DS:SI --> This dir entry + 1
	pop	SI
	pop	CX			; CX = Count
	add	SI,DIR_ENTRY_LEN	; DS:SI --> Next dir entry
	loop	CopyChainLoop		; Keep looping until CX = 0
	clc				; Signal no errors

CopyChainExit:
	pop	ES
	pop	DS
	pop	SI
	pop	DI
	ret

CopyFatChains ENDP



;=========================================================================
;
;  ComputeN :	This procedure calculates the number of clusters needed
;		to hold 1.5Kbytes.  This value is stored in the variable
;		NumClusters.
;
;  ARGUMENTS:	DeviceParameters.DP_BPB.BPB_BytesPerSector
;		DeviceParameters.DP_BPB.BPB_SectorsPerCluster
;
;  DESTROYS :
;
;=========================================================================

ComputeN	proc	NEAR

	assume	DS:NOTHING,ES:DATA

	mov	AX,ES:DeviceParameters.DP_BPB.BPB_BytesPerSector	; Sector size
	xor	CX,CX
	mov	CL,ES:DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	mul	CX				; AX = bytes per cluster
	mov	CX,AX				; CX = bytes per cluster
	mov	AX,1536				; Find how many clusters needed
						; for 1.5K
	xor	DX,DX
	div	CX				; now AX= No. clusters needed
	or	DX,DX				; round up if remainder nonzero
	jz	RoundedUp
	inc	AX
RoundedUp:
	mov	ES:NumClusters,AX

	ret
ComputeN	endp


;===========================================================================
; Routine name: ClearDirSector
;===========================================================================
;
; Description: Fill a sector size area of memory with zeros
;
; Arguments:		DS:BX --> Sector to clear
;			ES    = DATA
; ---------------------------
; Returns:   		Void
; ---------------------------
; Registers destroyed:	NONE
; ----------------------------------
; Strategy
; --------
;	Save all registers used and set ES:DI to DS:BX
;	Then do a store string, cleanup and leave
;
;===========================================================================

ClearDirSector PROC NEAR

	push	AX			; Can't destroy anything
	push	CX
	push	DI
	push	ES
	
	mov	CX,ES:deviceParameters.DP_BPB.BPB_BytesPerSector ;Num of bytes
	shr	CX,1			; Convert bytes to words

	mov	AX,DS			; Set ES:DI == DS:BX
	mov	ES,AX
	mov	DI,BX

	xor	AX,AX
	cld				; Clear the direction flag
	rep	stosw			; Fill the buffer with 0s

	pop	ES			; Leave with everything intact
	pop	DI
	pop	CX
	pop	AX
	ret

ClearDirSector ENDP

; ==========================================================================

CODE	 ENDS
	 END	 Start

; ==========================================================================


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forswtch.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;FORMAT Pre-defined switches

 SWITCH_S EQU		0001h			   ; System transfer
 SWITCH_V EQU		0002h			   ; Volume ID prompt
 SWITCH_BACKUP EQU	0004h
 SWITCH_Q EQU		0008h
 SWITCH_T EQU		0010h
 SWITCH_N EQU		0020h
 SWITCH_1 EQU		0040h
 SWITCH_4 EQU		0080h
 SWITCH_8 EQU		0100h
 SWITCH_B EQU		0200h
 SWITCH_SELECT	EQU	0400h
 SWITCH_AUTOTEST EQU	0800h
 SWITCH_F	EQU	1000h
 SWITCH_FS	EQU	2000h

IF ShipDisk

 SWITCH_Z	EQU	4000h
						; 1 sector/cluster switch
ENDIF

SWITCH_U	EQU	8000h			; *5.00 No restoration file


; The following is a list of equates to define each IBM defined diskette size
; for use with the /F switch


Size_160	equ	0001h			;Flag settings for size switch
Size_180	equ	0002h
Size_320	equ	0004h
Size_360	equ	0008h
Size_720	equ	0010h
Size_1200	equ	0020h
Size_1440	equ	0040h
Size_2880	equ	0080h

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;



data	segment public para 'DATA'

;
;*****************************************************************************
; Publics
;*****************************************************************************
;

	Public	Drive_Letter_Buffer
	Public	Switch_Buffer
	Public	Switch_Num_Buffer
	Public	Switch_String_Buffer


;
;***************************************************************************
; Equates
;***************************************************************************
;

;Match Flags

Numeric_Value		equ	8000h		;				;AN000;
Signed_Numeric_Value	equ	4000h		;				;AN000;
Simple_String		equ	2000h		;				;AN000;
Date_String		equ	1000h		;				;AN000;
Time_String		equ	0800h		;				;AN000;
Complex_List		equ	0400h		;				;AN000;
Filespec		equ	0200h		;				;AN000;
Drive_Only		equ	0100h		;				;AN000;
Quoted_String		equ	0080h		;				;AN000;
Ignore_Colon		equ	0010h		;				;AN000;
Repeats_Allowed 	equ	0002h		;				;AN000;
Optional		equ	0001h		;				;AN000;

;Function_Flags

File_Table_Capitalize	equ	1		;				;AN000;
Char_Table_Capitalize	equ	2		;				;AN000;
Remove_Colon		equ	10h		;				;AN000;

;Extra delimeters and EOL

Delimiters_Only 	equ	1		;				;AN000;
EOL_Or_Delimiters	equ	2		;				;AN000;

Semi_Colon		equ	";"             ;                               ;AN000;
Tab			equ	09h		;				;AN000;
Colon			equ	":"             ;                               ;AN000;


;Parse Errors

No_Error		equ	0		;				;AN000;
Too_Many_Operands	equ	1		;				;AN000;
Operand_Missing 	equ	2		;				;AN000;
Not_In_Switch_List	equ	3		;				;AN000;
Not_In_Keyword_List	equ	4		;				;AN000;
Out_Of_Range		equ	6		;				;AN000;
Not_In_Value_List	equ	7		;				;AN000;
Not_In_String_List	equ	8		;				;AN000;
Syntax_Error		equ	9		;				;AN000;
End_Of_Parse		equ	-1		;				;AN000;

;Return types

Type_Reserved		equ	0		;				;AN000;
Type_Number		equ	1		;				;AN000;
Type_List_Index 	equ	2		;				;AN000;
Type_String		equ	3		;				;AN000;
Type_Complex		equ	4		;				;AN000;
Type_Filespec		equ	5		;				;AN000;
Type_Drive		equ	6		;				;AN000;
Type_Date		equ	7		;				;AN000;
Type_Time		equ	8		;				;AN000;
Type_Quoted_String	equ	9		;				;AN000;

;Other

None			equ	0		;				;AN000;
No_Error		equ	0		;				;AN000;
Switch_Found		equ	0FFFFh		;				;AN000;
Range_Ok		equ	1		;				;AN000;
Command_Line_Parms	equ	81h		;				;AN000;

;
;*****************************************************************************
; Parse Structures
;*****************************************************************************
;

Control 	 struc

Match_Flags	dw	?
Function_Flags	dw	?
Result		dw	?
Values		dw	?
Num_Keywords	db	?
Keyword 	db	?

Control 	ends

Drive_Letter_Return	struc			;				;AN000;

Drive_Type	db	0			;				;AN000;
Drive_Item_Tag	db	0			;				;AN000;
Drive_Pointer	dw	0			;				;AN000;
Drive_Number	db	0			;A=1, B=2, C=3			;AN000;
Drive_debug	db	8 dup(0)

Drive_Letter_Return	ends			;				;AN000;

Switch_Return	 struc				;				;AN000;

Switch_Type	db	0			;				;AN000;
Switch_Item_Tag db	0			;				;AN000;
Switch_Pointer	dw	0			;				;AN000;
Switch_Debug	db	4 dup(0)

Switch_Return	 ends				;				;AN000;

Switch_Num_Return    struc			;				;AN000;

Switch_Num_Type     db	    0			    ;				    ;AN000;
Switch_Num_Item_Tag db	    0			    ;				    ;AN000;
Switch_Num_Pointer  dw	    0			    ;				    ;AN000;
Switch_Number_Low   dw	    0		    ;				    ;AN000;
Switch_Number_High  dw	    0		    ;				    ;AN000;

Switch_Num_Return    ends			;				;AN000;

Switch_String_Return   struc			;				;AN000;

Switch_String_Type     db      0		       ;			       ;AN000;
Switch_String_Item_Tag db      0		       ;			       ;AN000;
Switch_String_Pointer  dw      0		       ;			       ;AN000;
Switch_String_Off	dw	0		;				;AN000;
Switch_String_Seg	dw	0		;				;AN000;

Switch_String_Return ends			;				;AN000;


;
;**************************************************************************
; Parse tables
;**************************************************************************
;

IF FSExec					;conditionally assemble /FS:	;an018; dms;

Switch_FS_Table       label byte		;				;AN000;

	dw	Drive_Control_Definition	;Point to next level		;AN000;
	db	0				;				;AN000;

ENDIF						;end conditional assembly /FS:	;an018; dms;

Command_Line_Table label byte			;				;AN000;

	dw	Command_Control 		;Point to next level		;AN000;
	db	0				;				;AN000;

;
;**************************************************************************
;Define Positionals, Switches and Keywords
;**************************************************************************
;


IF FSExec					;conditionally assemble /FS:	;an018; dms;

Drive_Control_Definition label byte		;				;AN000;

	db	1,1				;Only drive letter posistional	;AN000;
	dw	Positional_Control		;Pointer to control table	;AN000;
	db	1				;1 switch			;AN000;
	dw	Switch_FS_Control		;				;AN000;
	db	None				;No Keywords (maxk)		;AN000;

ENDIF						;end conditional assembly /FS:	;an018; dms;

Command_Control label byte			;				;AN000;

	db	1,1				;Only drive letter posistional	;AN000;
	dw	Positional_Control		;Pointer to control table	;AN000;

IF	ShipDisk
		db	16	; /U and /Z switches needed
ELSE
		db	15	; /Z only extra switch needed
ENDIF

	dw	Switch_V_Control		;Without quotes 		AN000;
	dw	Switch_S_Control		;				;AN000;
	dw	Switch_4_Control		;				;AN000;
	dw	Switch_1_Control		;				;AN000;
	dw	Switch_8_Control		;				;AN000;
	dw	Switch_B_Control		;				;AN000;
	dw	Switch_T_Control		;				;AN000;
	dw	Switch_N_Control		;				;AN000;
	dw	Switch_Select_Control		;				;AN000;
	dw	Switch_Backup_Control		;				;AN000;
	dw	Switch_Autotest_Control 	;				;AN000;
	dw	Switch_F_Control		;				;AC001;

IF ShipDisk
	dw	Switch_Z_Control		;1 sector/cluster switch	;an000; dms;
ENDIF

	dw	Switch_U_Control		; No restore file switch

	dw	Switch_?_Control		; Display options
	dw	Switch_Q_Control		; Quick format option
	db	None				;No Keywords (maxk)		;AN000;


;
;**************************************************************************
;Control Tables
;**************************************************************************
;

Positional_Control label byte			;				;AN000;

	dw	Drive_Only			;Match_Flag			;AN000;
	dw	None				;No function flags		;AN000;
	dw	Drive_Letter_Buffer		;Where it will be returned	;AN000;
	dw	No_Value			;No value ranges defined	;AN000;
	db	None				;No defined switches/keywords	;AN000;

IF FSExec					;conditionally assemble /FS:	;an018; dms;

Switch_FS_Control label byte
	dw	Simple_String			;/FS:xxxxx			;AN000;
	dw	File_Table_Capitalize		;Make it uppercase		;AN000;
	dw	Switch_String_Buffer		;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/FS",0                         ;                               ;AN000;

ENDIF						;end conditional assembly /FS:	;an018; dms;

Switch_V_Control label byte			;				;AN000;

	dw	Simple_String+Quoted_String+Optional ;/v:xxxxxxxx		;AN000;
	dw	File_Table_Capitalize		;				;AN000;
	dw	Switch_String_Buffer		;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/V",0                          ;                               ;AN000;

Switch_S_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/S",0                          ;                               ;AN000;

Switch_4_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/4",0                          ;                               ;AN000;

Switch_1_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/1",0                          ;                               ;AN000;

Switch_8_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/8",0                          ;                               ;AN000;

Switch_B_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/B",0                          ;                               ;AN000;

Switch_T_Control label byte			;				;AN000;

	dw	Numeric_Value			;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Num_Buffer		;				;AN000;
	dw	Switch_T_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/T",0                          ;                               ;AN000;

Switch_N_Control label byte			;				;AN000;

	dw	Numeric_Value			;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Num_Buffer		;				;AN000;
	dw	Switch_N_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/N",0                          ;                               ;AN000;

Switch_Select_Control label byte		;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/SELECT",0                     ;                               ;AN000;

Switch_Backup_Control label byte		;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/BACKUP",0                     ;                               ;AN000;

Switch_Autotest_Control label byte		;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/AUTOTEST",0                   ;                               ;AN000;

Switch_F_Control label byte			;				;AN001;
	dw	Simple_String			;/F:xxxxx			;AN001;
	dw	File_Table_Capitalize		;Make it uppercase		;AN001;
	dw	Switch_String_Buffer		;				;AN001;
	dw	Switch_Size_Value		;				;AN001;
	db	1				;				;AN001;
	db	"/F",0                          ;                               ;AN001;

IF ShipDisk

Switch_Z_Control label	byte			;control structure for /Z	;an000; dms;
	dw	None				;				;an000; dms;
	dw	None				;				;an000; dms;
	dw	Switch_Buffer			;				;an000; dms;
	dw	No_Value			;				;an000; dms;
	db	1				;				;an000; dms;
	db	"/Z",0                          ;                               ;an000; dms;

ENDIF

Switch_U_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/U",0        

; New switch added 4/18/90 for display options
; c-PaulB

Switch_?_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/?",0        

		; Added for /Q quick format switch t-sa 6/27/90

Switch_Q_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/Q",0        


;
;************************************************************************
; PARSE Value Lists
;************************************************************************
;

Switch_T_Value label byte			;				;AN000;

	db	1				;Range only			;ANOOO;
	db	1				;1 range			;ANOOO;
	db	Range_OK			;Item_Tag			;ANOOO;
	dd	1				;1 is low bound 		;ANOOO;
	dd	1024				;2**10 is max			;AN000;

Switch_N_Value label byte			;				;AN000;

	db	1				;Range only			;ANOOO;
	db	1				;1 range			;ANOOO;
	db	Range_OK			;Item_Tag			;ANOOO;
	dd	1				;1 is low bound 		;ANOOO;
	dd	64				;2**6  is max			;AN000;

Switch_Size_Value	label	byte		;				;AN001;

	db	3				;Look for strings		;AN001;
	db	0				;No ranges			;AN001;
	db	0				;No numerics			;AN001;

;	db	27				;16 possible strings		;AN001;
	db	27+8				;

	db	Size_160			;				;AN001;
	dw	String_160k_1			;/F:160 			;AN001;
	db	Size_160			;				;AN001;
	dw	String_160k_2			;/F:160K			;AN001;
	db	Size_160			;				;AN001;
	dw	String_160k_3			;/F:160KB			;AN001;
	db	Size_180			;				;AN001;
	dw	String_180k_1			;/F:180 			;AN001;
	db	Size_180			;				;AN001;
	dw	String_180k_2			;/F:180K			;AN001;
	db	Size_180			;				;AN001;
	dw	String_180k_3			;/F:180KB			;AN001;
	db	Size_320			;				;AN001;
	dw	String_320k_1			;/F:320 			;AN001;
	db	Size_320			;				;AN001;
	dw	String_320k_2			;/F:320K			;AN001;
	db	Size_320			;				;AN001;
	dw	String_320k_3			;/F:320KB			;AN001;
	db	Size_360			;				;AN001;
	dw	String_360k_1			;/F:360 			;AN001;
	db	Size_360			;				;AN001;
	dw	String_360k_2			;/F:360K			;AN001;
	db	Size_360			;				;AN001;
	dw	String_360k_3			;/F:360KB			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_1			;/F:720 			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_2			;/F:720K			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_3			;/F:720KB			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_1			;/F:1200			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_2			;/F:1200K			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_3			;/F:1200KB			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_4			;/F:1.2 			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_5			;/F:1.2M			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_6			;/F:1.2MB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_1			;/F:1440			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_2			;/F:1440K			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_3			;/F:1440KB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_4			;/F:1.44			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_5			;/F:1.44M			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_6			;/F:1.44MB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_5			;/F:1.44M			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_6			;/F:1.44MB			;AN001;
	
	db	Size_2880			;				;AN001;
	dw	String_2880k_1			;/F:2880			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_2			;/F:2880K			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_3			;/F:2880KB			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_4			;/F:2.88			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_5			;/F:2.88M			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_6			;/F:2.88MB			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_5			;/F:2.88M			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_6			;/F:2.88MB			;AN001;

No_Value	label	byte			;				;AN000;
	db	0				;				;AN000;

;
;*****************************************************************************
; Data Area for value lists
;*****************************************************************************
;

;
;The following are a list of the allowed strings for the /F:xxxxx switch.
;

String_160k_1	db	"160"  ,Asciiz_End      ;                               ;AN001;
String_160k_2	db	"160K" ,Asciiz_End      ;                               ;AN001;
String_160k_3	db	"160KB" ,Asciiz_End      ;                               ;AN001;

String_180k_1	db	"180"  ,Asciiz_End      ;                               ;AN001;
String_180k_2	db	"180K" ,Asciiz_End      ;                               ;AN001;
String_180k_3	db	"180KB" ,Asciiz_End      ;                               ;AN001;

String_320k_1	db	"320"  ,Asciiz_End      ;                               ;AN001;
String_320k_2	db	"320K" ,Asciiz_End      ;                               ;AN001;
String_320k_3	db	"320KB" ,Asciiz_End      ;                               ;AN001;
String_360k_1	db	"360"  ,Asciiz_End      ;                               ;AN001;

String_360k_2	db	"360K" ,Asciiz_End      ;                               ;AN001;
String_360k_3	db	"360KB" ,Asciiz_End      ;                               ;AN001;
String_720k_1	db	"720"  ,Asciiz_End      ;                               ;AN001;
String_720k_2	db	"720K" ,Asciiz_End      ;                               ;AN001;
String_720k_3	db	"720KB" ,Asciiz_End      ;                               ;AN001;

String_1200k_1	db	"1200" ,Asciiz_End      ;                               ;AN001;
String_1200k_2	db	"1200K",Asciiz_End      ;                               ;AN001;
String_1200k_3	db	"1200KB",Asciiz_End      ;                               ;AN001;
String_1200k_4	db	"1.2" ,Asciiz_End      ;                               ;AN001;
String_1200k_5	db	"1.2M" ,Asciiz_End      ;                               ;AN001;
String_1200k_6	db	"1.2MB" ,Asciiz_End      ;                               ;AN001;

String_1440k_1	db	"1440" ,Asciiz_End      ;                               ;AN001;
String_1440k_2	db	"1440K",Asciiz_End      ;                               ;AN001;
String_1440k_3	db	"1440KB",Asciiz_End      ;                               ;AN001;
String_1440k_4	db	"1.44",Asciiz_End      ;                               ;AN001;
String_1440k_5	db	"1.44M",Asciiz_End      ;                               ;AN001;
String_1440k_6	db	"1.44MB",Asciiz_End      ;                               ;AN001;

String_2880k_1	db	"2880" ,Asciiz_End      ;                               ;AN001;
String_2880k_2	db	"2880K",Asciiz_End      ;                               ;AN001;
String_2880k_3	db	"2880KB",Asciiz_End      ;                               ;AN001;
String_2880k_4	db	"2.88",Asciiz_End      ;                               ;AN001;
String_2880k_5	db	"2.88M",Asciiz_End      ;                               ;AN001;
String_2880k_6	db	"2.88MB",Asciiz_End      ;                               ;AN001;

;
;************************************************************************
; PARSE Return Buffers
;************************************************************************
;

Drive_Letter_Buffer	Drive_Letter_Return	<> ;Example of structure	;AN000;
Switch_Buffer		Switch_Return		<> ;				;AN000;
Switch_Num_Buffer	Switch_Num_Return	<> ;				;AN000;
Switch_String_Buffer	Switch_String_Return	<> ;				;AN000;

data	ends

;
;*****************************************************************************
; SysParse Routines
;*****************************************************************************
;


code	segment public	para 'CODE'
	assume cs:code,ds:Data

FarSW	equ	Not_Include							;AN000;
DateSW	equ	Not_Include			;				;AN000;
TimeSW	equ	Not_Include			;				;AN000;
FileSW	equ	Do_Include			;				;AN000;
CAPSW	equ	Do_Include			;				;AN000;
CmpxSW	equ	Not_Include			;				;AN000;
NumSW	equ	Do_Include			;				;AN000;
KeySW	equ	Not_Include			;				;AN000;
SwSW	equ	Do_Include			;				;AN000;
Val1SW	equ	DO_Include			;				;AN000;
Val2SW	equ	Not_Include			;				;AN000;
Val3SW	equ	Do_Include			;				;AN001;
DrvSW	equ	Do_Include			;				;AN000;
QusSW	equ	Do_Include			;				;AN000;

include version.inc
INCLUDE PARSE.ASM				;				;AN000;


code	ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\glblinit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 
; FILE: GLBLINIT.ASM
;
;===========================================================================

;===========================================================================
;Declaration of include files
;===========================================================================

;
;---------------------------------------------------------------------------
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc 
;
;---------------------------------------------------------------------------
;
debug	 equ	 0

        .xlist

	INCLUDE		BPB.INC
;	INCLUDE		VERSION.INC
;	INCLUDE		VERSIONA.INC
	INCLUDE		DOSMAC.INC
	INCLUDE		SYSCALL.INC
;	INCLUDE		DPB.INC
	INCLUDE		FOREQU.INC	
	INCLUDE		FORMACRO.INC
	INCLUDE		IOCTL.INC
	INCLUDE		FORSWTCH.INC
	INCLUDE		SAFEDEF.INC
	INCLUDE		SYSVAR.INC
	.list


;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Bytes
	EXTRN	msgOutOfMemory		  :BYTE
	EXTRN	msgInsufficientMemory	  :BYTE		; M024
	EXTRN	Drive			  :BYTE
	EXTRN	ClustBound_Flag		  :BYTE
	EXTRN	FileStat		  :BYTE
	EXTRN	SystemDriveLetter	  :BYTE

;Words
	EXTRN	SwitchMap		  :WORD
	EXTRN 	mSize			  :WORD
	EXTRN	mStart			  :WORD
	EXTRN	ClustBound_Buffer_Seg	  :WORD
	EXTRN	Paras_per_fat		  :WORD

;Pointers
	EXTRN	DirectorySector		  :DWORD
	EXTRN	FatSpace	  	  :DWORD
	EXTRN	FatSector		  :DWORD
;No more SAFE module
;	EXTRN	HeaderBuf		  :DWORD
	EXTRN	DirBuf			  :DWORD

;Functions

;Messages
	EXTRN	msgFormatNotSupported	  :BYTE

;Structures
	EXTRN	SavedParams		  :BYTE
	EXTRN	DeviceParameters	  :BYTE
	EXTRN	Bios			  :BYTE
	EXTRN  	Dos			  :BYTE
	EXTRN	Command 		  :BYTE

;Labels
	EXTRN	FatalExit		  :NEAR
	EXTRN	ReadDos			  :NEAR
	EXTRN	SysPrm			  :NEAR

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

SECTORS_FOR_MIRROR	EQU	7		; # extra buffer sectors
						; required by Mirror utility,
						; apart from FAT & Root Dir
DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA


;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	Global_Init
	PUBLIC	GetDeviceParameters

; for debug

	PUBLIC	Copy_Device_Parameters
	PUBLIC	Alloc_Dir_Buf
	PUBLIC	Alloc_Fat_Buf
	PUBLIC	Alloc_Fat_Sec_Buf
	PUBLIC	Alloc_DirBuf2
	PUBLIC	Alloc_Cluster_Buf
	PUBLIC	Do_Switch_S


;===========================================================================
;
;  Global_Init  :	This procedure first gets the default drive parameters.
;			It then allocates buffer space for the root directory
;			sector, FAT,a fat sector, a file header and first
;			root DIR sector based on these parameters.  It
;			then checks for the /s switch and if this is present,
;			a buffer is allocated for the system files and these
;			are read into memory.  A prompt to insert the system
;			disk will be given in the case of removable media.
;
;===========================================================================

Global_Init	proc	near

	lea	DX, DeviceParameters	; Get the default drive parameters
	mov	DeviceParameters.DP_SpecialFunctions, 0
	call	GetDeviceParameters
	
	jnc	GotDeviceParameters
	Message msgFormatNotSupported
	stc 				; Let the jump to FatalExit be made
	ret				;  in the main routine, upon returning

GotDeviceParameters:			
	call	Copy_Device_Parameters	; Save the device parameters
					; for when we exit
	call	Alloc_Dir_Buf		; Allocate root directory buffer
	jc	gi_memerr		; M024

	call	Alloc_Fat_Buf		; Allocate FAT buffer
	jc	gi_memerr		; M024

	call	Alloc_Fat_Sec_Buf	; Allocate fat sector buffer
	jc	gi_memerr		; M024

;No more SAFE module
;	call	Alloc_Header_Buf	; Allocate buffer for restoration file
;	retc
	call	Alloc_DirBuf2		; Allocate 1-sector buffer DirBuf (general-
					; purpose use)
	jc	gi_memerr		; M024

	call	Alloc_Cluster_Buf	; get room for retry buffer

	call	Do_Switch_S		; Load system files if needed

					; carry flag determined by Do_Switch_S
;	clc				; Signal no error
	ret
gi_memerr:				; M024
	Message msgInsufficientMemory	; M024
	stc				; M024
	ret				; M024
Global_Init	endp

; =========================================================================
;
;   GetDeviceParameters:
;	Get the	device parameters
;
;   Input:
;	Drive
;	DX - pointer to	device parameters
; =========================================================================

GetDeviceParameters proc near

	mov	AX, (IOCTL shl 8) or GENERIC_IOCTL
	mov	bl, Drive
	inc	bl
	mov	CX, (RAWIO shl 8) or GET_DEVICE_PARAMETERS
	int	21H
	return

GetDeviceParameters endp

;==========================================================================
;
; Copy_Device_Parameters :	This procedure saves a copy of the original
;				device parameters in the structure 
;				SavedParams.
;
;==========================================================================

Copy_Device_Parameters	proc	near
					
	lea	SI, DeviceParameters	
	lea	DI, SavedParams
	mov	CX, size a_DeviceParameters
	push	DS
	pop	ES

	rep	movsb

	ret
Copy_Device_Parameters	endp


;==========================================================================
;
;  Alloc_Dir_Buf  :  This procedure allocates a memory block for the root 
;		     directory buffer, based on the device parameters only.
;
;  Inputs   	  :  DeviceParameters.DP_BPB.BPB_BytesPerSector
;  Outputs	  :  CY CLEAR - DirectorySector pointer to buffer
;		     CY SET   - failure
;  Modifies	  :  AX, BX, DirectorySector
;
;==========================================================================

Alloc_Dir_Buf	proc	near
					; DirectorySector =
				 	; malloc( Bytes Per Sector )
	mov	BX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	BX, 0fH
	shr	BX, 1			; Divide by 16 to get #paragraphs
	shr	BX, 1
	shr	BX, 1
	shr	BX, 1
	mov	AH, Alloc
	int	21h
	jc      Exit_Alloc_Dir_Buf
					; Base address of newly allocated
					; block is AX:0000
	mov	WORD PTR DirectorySector+2,AX
	xor	AX,AX
	mov	WORD PTR DirectorySector,AX

Exit_Alloc_Dir_Buf:
	ret

Alloc_Dir_Buf	endp

;==========================================================================
;
;  Alloc_Fat_Buf  :  This procedure allocates a memory block for the FAT
;		     buffer, based on the device parameters only.  In order
;		     to ensure there is enough buffer space for the Mirror
;	  	     utility, the FatSpace buffer is initially allocated
;		     with size:
;			FAT + RootDir + 6 sectors + 1 surplus sector
;		     which is all the buffer space required by Mirror.
;
;  Inputs   	  :  DeviceParameters.DP_BPB.BPB_BytesPerSector
;		     DeviceParameters.DP_BPB.BPB_SectorsPerFat
;		     DeviceParameters.DP_BPB.BPB_RootEntries
;
;  Outputs	  :  CY CLEAR - FatSpace pointer to buffer
;		     CY SET   - failure
;
;  Modifies	  :  AX, BX, DX, FatSpace
;
;==========================================================================

Alloc_Fat_Buf	proc	near
					; FatSpace =
					; malloc( BytesPerSec * SecPerFat +
					; 32 * RootEntries + 6 * ByesPerSec)
	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	AX, 0fH			; round up for next para
	shr	AX, 1			; convert to paras
	shr	AX, 1
	shr	AX, 1
	shr	AX, 1
	mul	DeviceParameters.DP_BPB.BPB_SectorsPerFat
	mov	BX,AX			; Save FAT size in paras in BX

;No more SAFE module
; Old Logic Was :    Since this buffer is used in SAFE to hold the root
;		     directory from the disk, the size of the buffer is
;		     allocated as the larger of the drive defaults for
;		     the FAT or the whole root directory.
;		     The size of FatSpace must be the largest of
;			1) FAT
;			2) Root Dir
;			3) Cluster size needed for 1.5K
;
;	mov	AX,DeviceParameters.DP_BPB.BPB_RootEntries
;	shl	AX,1			; Multiply by 2 to get total para size
;					; (Each entry is 32 bytes)
;
;	cmp	AX,BX			; now see which is bigger
;	jna	CheckClusters		; Use FAT size if BX >= AX
;
;UseDirSize:
;	mov	BX,AX			; Root directory is bigger
;
;CheckClusters:				; Now BX contains the larger of the
;					; FAT and RootDir size, in paras
;					; Calculate the para size of the #
;					; clusters needed for 1.5K
;	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
;	mov	CL,deviceParameters.DP_BPB.BPB_SectorsPerCluster
;	xor	CH,CH			; Sectors per cluster in CX
;	mul	CX			; DX:AX= bytes per cluster
;	mov	CX,AX			; CX = #bytes per cluster
;	mov	AX,1536			; AX = 1.5K
;	div	CX			; Calc. # clusters needed for 1.5K
;	or	DX,DX			; Non-zero remainder?
;	jz	Rounded			; No need to round up for zero remainder
;	inc	AX			; Increment #clusters needed, for non-zero remainder
;Rounded:
;	mul	CX			; Calculate byte size needed (#Clusters * BytesPerCluster)
;	add	AX, 0fH			; Convert to paras
;	shr	AX, 1
;	shr	AX, 1
;	shr	AX, 1
;	shr	AX, 1
;
;	cmp	AX,BX			; Now AX=para size for clusters in 1.5K
;	jna	AllocateAsIs		; Use larger of FAT,RootDir if not bigger
;
;UseClustSize:
;	mov	BX,AX			; Clusters in 1.5K is bigger

SaveFatSize:
	mov	Paras_per_fat,BX	; Set paras_per_fat here, to 
					;  avoid having to calculate it later
					; Now add on root dir + extra sectors
	mov	AX,DeviceParameters.DP_BPB.BPB_RootEntries
	shl	AX,1			; AX = para size of root dir

	add	BX,AX			; BX = FAT + root dir

	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	AX, 0fH			; round up for next para
	shr	AX, 1			; convert to paras
	shr	AX, 1
	shr	AX, 1
	shr	AX, 1			; AX = sector size in paras

	mov	CX,SECTORS_FOR_MIRROR	; CX = # additional sectors needed by Mirror
	mul	CX			; AX = total extra sector size in paras

	add	BX,AX			; BX = FAT + root dir + extra sectors
					;  in paras
	mov	AH,Alloc
	int	21h
	jc      Exit_Alloc_Fat_Buf

	mov	WORD PTR FatSpace+2,AX
	xor	AX,AX
	mov	WORD PTR FatSpace,AX

Exit_Alloc_Fat_Buf:
	ret

Alloc_Fat_Buf	endp

;==========================================================================
;
;  Alloc_Fat_Sec_Buf : This procedure allocates a memory block for the fat 
;		       sector buffer which is used when copying chains from
;		       the old FAT to the new FAT.
;
;  Inputs   	  :  DeviceParameters.DP_BPB.BPB_BytesPerSector
;  Outputs	  :  CY CLEAR - FatSector pointer to buffer
;		     CY SET   - failure
;  Modifies	  :  AX, BX, FatSector
;
;==========================================================================

Alloc_Fat_Sec_Buf	proc	near
					; FatSector =
				 	; malloc( Bytes Per Sector )
	mov	BX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	BX, 0fH
	shr	BX, 1			; Divide by 16 to get #paragraphs
	shr	BX, 1
	shr	BX, 1
	shr	BX, 1
	mov	AH, Alloc
	int	21h
	jc      Exit_Alloc_Fat_Sec_Buf
					; Base address of newly allocated
					; block is AX:0000
	mov	WORD PTR FatSector+2,AX
	xor	AX,AX
	mov	WORD PTR FatSector,AX

Exit_Alloc_Fat_Sec_Buf:
	ret

Alloc_Fat_Sec_Buf	endp

;===========================================================================
; Routine name:	Alloc_Header_Buf
;===========================================================================
;
; Description: Allocate the work buffers that will be needed by SAFE to
;	       build the restore file.
;
; Arguments:		None
; ---------------------------
; Returns:   		Carry set if error
; ----------------------------------------
; Registers destroyed:	AX BX DX
; ----------------------------------------
; Strategy:
; ---------
;	Allocate Buffer for file header	+ first root DIR sector
;===========================================================================

;Alloc_Header_Buf	 proc	 near
;
;	mov	BX,deviceParameters.DP_BPB.BPB_BytesPerSector ; Sector size
;	add	BX,(HEADER_SIZE + 15)		; Add header size and round
;						; for para conversion
;ConvertToParas:
;	shr	BX,1				; Convert to paragrphs by
;	shr	BX,1				; dividing by 16
;	shr	BX,1
;	shr	BX,1
;
;	mov	AH,48h				; DOS allocate memory function
;	int	21h
;	jc	Exit_Alloc_Header_Buf		; Check for error
;
;SaveAddresses:
;	mov	WORD PTR HeaderBuf[2],AX	; Save header buffer segment
;	mov	WORD PTR HeaderBuf,0		; Set offset to 0
;
;	add	AX,(Header_Size SHR 4)		; Find header buffer segment
;	mov	WORD PTR DirBuf[2],AX		; Save DIR buf segment address
;	mov	WORD PTR DirBuf,0		; Set offset to 0
;
;Exit_Alloc_Header_Buf:
;	ret
;
;Alloc_Header_Buf	endp



;==========================================================================
;
;  Alloc_DirBuf2  :  This procedure allocates a memory block for a 1-sector
;		     buffer.  This buffer is used when reading in the boot
;		     sector in Phase1.
;
;  Inputs   	  :  DeviceParameters.DP_BPB.BPB_BytesPerSector
;  Outputs	  :  CY CLEAR - DirBuf pointer to buffer
;		     CY SET   - failure
;  Modifies	  :  AX, BX, DirBuf
;
;==========================================================================

Alloc_DirBuf2	proc	near
					; DirBuf =
				 	; malloc( Bytes Per Sector )
	mov	BX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	BX, 0fH
	shr	BX, 1			; Divide by 16 to get #paragraphs
	shr	BX, 1
	shr	BX, 1
	shr	BX, 1
	mov	AH, Alloc
	int	21h
	jc      Exit_Alloc_DirBuf2
					; Base address of newly allocated
					; block is AX:0000
	mov	WORD PTR DirBuf+2,AX
	xor	AX,AX
	mov	WORD PTR DirBuf,AX

Exit_Alloc_DirBuf2:
	ret

Alloc_DirBuf2	endp



;=========================================================================
; Alloc_Cluster_Buf	         : This	routine	will allocate a	buffer
;				   based on a cluster's	size.  If enough
;				   space does not exist, a cluster will
;				   be redefined	to a smaller size for
;				   purposes of sector retries.
;				   Note: This buffer is used only for bad
;				   tracks on hard disks.
;
;	 Inputs	 : DeviceParameters.DP_BPB.BPB_BytesPerSector
;		   DeviceParameters.DP_BPB.BPB_SectorsPerCluster
;
;	 Outputs : ClustBound_Flag	 - True	(space available)
;					   False(not enough space)
;		   ClustBound_Buffer_Seg - Pointer to buffer
;=========================================================================

Procedure Alloc_Cluster_Buf

	push	AX				; Save regs
	push	BX

	mov	AX,(Alloc shl 8)		; Allocate memory
	mov	BX,0ffffh			; Get available memory
	int	21h

	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
	add	AX, 0fH
	shr	AX, 1
	shr	AX, 1
	shr	AX, 1
	shr	AX, 1
	mul	DeviceParameters.DP_BPB.BPB_SectorsPerCluster

	cmp	BX,AX				; Enough room
	jna	$$IF137 			; Yes

	mov	BX,AX				; Allocate needed memory
	mov	AX,(Alloc shl 8)
	int	21h
	mov	ClustBound_Buffer_Seg,AX	; Save pointer to buffer
	mov	ClustBound_Flag,True		; Signal space available
	jmp	SHORT $$EN137			; Not enough room

$$IF137:
	mov	ClustBound_Flag,False		; Signal not enough space

$$EN137:
	pop	BX				; Restore regs
	pop	AX

	ret

Alloc_Cluster_Buf ENDP

;=========================================================================
;
;  DO_SWITCH_S  :	This procedure will load the system files into
;			memory (if there's space) if the /s switch is
;			specified.
;
;  CALLS  :		ReadDos
;			SysPrm
;  CALLED BY :		Global_Init
;  STRATEGY :		The largest block of memory available is first
;			determined.  The program is aborted if this is zero.
;			This block is then allocated, and the system files
;			are read into it.  A prompt for the system disk
;			will be given if the system files are not found.
;
;=========================================================================

Do_Switch_S	proc	near

	test	SwitchMap,SWITCH_S
	jz	End_Do_Switch_S			; System files not required
						; allocate memory for system files
	mov	BX,0ffffh			; This call will actually fail
	mov	AH,Alloc			; so that BX returns max block avlbl
	int	21h

	or	BX,BX
	jz	MemErr  			; No memory
	mov	[mSize],BX			; Now allocate the largest block
	mov	AH,alloc
	int	21h
	jnc	Mem_OK

MemErr:
	mov	AX, seg data			; Check for memory allocation error
	mov	DS, AX
	Message msgOutOfMemory			; call PrintString
;	jmp	FatalExit
	stc 				; Let the jump to FatalExit be made
	jmp	SHORT End_Do_Switch_S	;  in the main routine, upon returning

Mem_OK:
	mov	[mStart],AX			; Save the starting paragraph

; =========================================================================
; This call to ReadDos may not be able to read in all of the DOS files if
; there is insufficient memory available. In that case the files will
; be read in after the disk is formatted. If the Drive being formatted is
; also the boot Drive this function will read the files from that
; Drive if there is enough memory. If there is insufficent memory it will
; force the files to be read from Drive A: if the Drive being formatted
; is also the boot Drive
; M011; Wrong: Try Boot, Then Default, Then sysprm (usually "A").
;       If not enough memory at boot time, we fail.
; =========================================================================

RdFrst:

;M011 - begin

	mov	AH,GET_DEFAULT_Drive		; Find out default Drive
	int	21h
	push	AX				; save default Drive
	mov	AH,Get_In_Vars			; Find out boot	Drive
	int	21h
						; get 1 based Drive ID
	mov	AL,BYTE PTR ES:[BX].SysI_Boot_Drive
	add	AL,40h				; Make it ASCII
	pop	BX				; restore default Drive
	cmp	AL,41h				; Q: Booted from Drive A?
	jnz	go_get_Bios			;  N: Not a special case
	cmp	bl,1				; Q: is	B: current Drive
	jnz	go_get_Bios			;  N: Not a special case
	jmp	short check_default		; check	default	Drive

go_get_Bios:					; Here to check booted
	call	Get_Host_Drive			; Translate to DblSpace host
	mov	SystemDriveLetter,AL		;   (if necessary)

	call	ReadDos
	jnc	CheckAllFilesIn

check_default:					; Here to check default
	mov	AH,GET_DEFAULT_Drive		; Find out default Drive
	int	21h
	add	AL,41h				; Make it ASCII, 1 based
	call	Get_Host_Drive			; Translate to DblSpace host
	mov	SystemDriveLetter,AL

TryThisOne:
	call	ReadDos				; Read BIOS and	DOS
	jnc	CheckAllFilesIn			; Files read in OK
NeedSys:
	call	SysPrm				; Prompt for system disk
	jmp	TryThisOne			; Try again

;M011 - end


CheckAllFilesIn:
				; abort program here if all system files
				; have not been read into memory, since
				; program fails when trying to read them
				; in after formatting is complete
	and	FileStat,3fh			; zero out 2 msb
	cmp	FileStat,2ah			; are all 3 sys files in memory?
	jne	MemErr				; no - abort program

	clc					; yes
End_Do_Switch_S:
	ret

Do_Switch_S	ENDP

;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_Host_Drive
;*******************************************************************************
;
;Description: Given a drive letter in AL, check to see if it is a dblspace
;	      drive, and if so, translate the drive letter to the host
;	      drive letter.
;
;Called Procedures: None
;
;Input: ASCII drive letter in AL
;
;Output: drive letter in AL
;
;Change History: Created			11/21/92	 MD
;		 Cut and paste from SYS command 12/07/92	 JEM
;
;******************* END OF SPECIFICATIONS *************************************

public Get_Host_Drive

Get_Host_Drive PROC NEAR

        push    ax
   	mov	ax,4a11h	; DBLSPACE multiplex number
	xor	bx,bx		; inquire version number
	int	2fh
	or	ax,ax		; error?
	jnz	not_dblspace
	cmp	bx,'DM'		; stamp returned correctly?
	jnz	not_dblspace

;	DBLSPACE.BIN is loaded.  At this time:
;
;	(dx & 0x7fff) == driver internal version number
;	high bit of DH set of driver has not yet been permanently placed
;	cl == first disk letter reserved for DBLSPACE
;	ch == number of disk letters reserved for DBLSPACE

	mov	ax,4a11h	; DBLSPACE multiplex number
	mov	bx,1		; inquire drive map
        pop     dx
	push	dx
	sub	dl, 'A' 	; convert drv letter to 0 based drv number
	int	2fh
	test	bl,80h		; COMPRESSED bit true?
	jz	not_dblspace

;	Drive is compressed.  At this time:
;
;	(bl & 0x7f) == host drive's CURRENT drive number
;	bh          == CVF extension number
;
        mov     al,bl
	and	al,7Fh
	add	al, 'A' 	; convert drv number to drv letter
        cbw
        pop     dx
        push    ax

not_dblspace:
        pop     ax
        ret

Get_Host_Drive	ENDP

CODE	ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\formsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;

;
;*****************************************************************************
; Macro's
;*****************************************************************************
;
;
;---------------------------------------------------------------------------
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc. Reclaimed
;		the msgBadDrive which was not being used.
;
; M028 : B#6073. Changed width of cluster number field from 8 to 5
;		in msgVerify sublist.
;
;---------------------------------------------------------------------------
;

Define_Msg macro Message_Name			;				;AN000;
						;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input;AN000;
						;
	endm					;				;AN000;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;		;AN000;

Public	Parm1
Parm1	label	word				;				;AN000;
	dw	Parm2				;				;AN000;
	dw	Parm3				;				;AN000;
	dw	Parm4				;				;AN000;
	dw	Parm5				;				;AN000;
	db	Parm6				;				;AN000;
	db	Parm7				;				;AN000;
	dw	Parm8				;				;AN000;
	endm					;				;AN000;


;
;*****************************************************************************
; External data declarations
;*****************************************************************************
;

	Extrn	DriveLetter:Byte
	Extrn	SystemDriveLetter:Byte
	Extrn	CurrentHead:Byte
	Extrn	CurrentCylinder:Word
	Extrn	FdskSiz:Word
	Extrn	SysSiz:Word
	Extrn	BadSiz:Word
	Extrn	DataSiz:Word
	Extrn	Drive_Letter_Msg:Byte
	Extrn	PercentComplete:Byte
	Extrn	AllocSize:Dword
	Extrn	AllocNum:Word
	Extrn	Serial_Num_Low:Word
	Extrn	Serial_Num_High:Word
	Extrn	Command_Old_Ptr:Word
	Extrn	Msg_Allocation_Unit_Val:Dword
	Extrn	SizeInK		:Word
	Extrn	SizeInM		:Word
	Extrn	DecSizeInM	:Word
;
;*****************************************************************************
; Publics
;*****************************************************************************
;

	Public	msgDecimalNumberofDecimal

;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************
;

Format_Msg		equ	'C'

N_A			equ	0
Sublist_Length		equ	11
None			equ	0

Blank			equ	" "
No_Function		equ	0
No_Replace		equ	0

Msg_Ser_Class		equ	0
Ext_Err_Class		equ	1
Parse_Err_Class 	equ	2
Utility_Msg_Class	equ	0FFh

Reserved		equ	0

	PUBLIC	MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST
MSG_OPTIONS_FIRST	equ	300	; first options help msg
MSG_OPTIONS_LAST        equ     316     ;  and last


data	segment public	para	'DATA'
	assume	ds:data


;
;*****************************************************************************
; Message Sublist Tables
;*****************************************************************************
;
;The  following  control  blocks  are	used   for   messages  with
;replaceable  paramaters.  These  control  blocks  are	used by  the
;SysDispMsg routine.
;

;---------------------------			;
Sublist_msgCurrentTrack label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset PercentComplete	;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_Word ;				 ;AN000;
	db		3			;Max % is 100			;AN000;
	db		3			;Min % is 0			;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgDblspaceDrv  label dword
Sublist_msgDblspaceHost label dword
Sublist_msgInsertDisk	label dword		;				;AN000;
Sublist_msgReInsertDisk label dword		;				;AN000;
Sublist_MsgHardDiskWarning label dword		;
Sublist_msgFormatNotSupported label dword	;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset DriveLetter	;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_Char ;			   ;AN000;
	db		1			;				;AN000;
	db		1			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgInsertDOSDisk label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset SystemDriveLetter;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_Char ;				;AN000;
	db		1			;				;AN000;
	db		1			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgTotalDiskSpace label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset FdskSiz		;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_Dword ;				 ;AN000;
	db		10			;				;AN000;
	db		10			;4,000,000,000 limit		;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgSystemSpace	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset SysSiz		;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_DWord ;			   ;AN000;
	db		10			;				;AN000;
	db		10			;64k*3 max			;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgBadSpace	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset BadSiz		;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_DWord ;			   ;AN000;
	db		10			;				;AN000;
	db		10			;4,000,000,000 max		;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgDataSpace	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		Offset DataSiz		;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_DWord ;			   ;AN000;
	db		10			;				;AN000;
	db		10			;4,000,000,000 max		;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgWhatIsVolumeId?  label dword 	;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset DriveLetter	;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_Char ;				;AN000;
	db		1			;				;AN000;
	db		1			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgEXECFailure	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		Drive_Letter_Msg	;						;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;				;AN000;
	db		2			;				;AN000;
	db		2			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgAllocNum	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset AllocNum 	;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_Word ;				;AN000;
	db		10			;				;AN000;
	db		10			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgAllocSize	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset AllocSize	;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_DWord ;				  ;AN000;
	db		10			;				;AN000;
	db		10			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_msgSerialNumber label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset Serial_Num_Low	;				;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Bin_Hex_Word ;				;AN000;
	db		4			;				;AN000;
	db		4			;				;AN000;
	db		'0'                     ;Display leading 0's            ;AN000;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset Serial_Num_High	;				;AN000;
	dw		data			;				;AN000;
	db		2			;				;AN000;
	db		Right_Align+Bin_hex_Word ;				;AN000;
	db		4			;				;AN000;
	db		4			;				;AN000;
	db		'0'                     ;                               ;AN000;

Public	Sublist_MsgParse_Error
Sublist_msgParse_Error	      label dword	;				;AN000;

	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		0			;				;AN000;
	dw		Data			;				;AN000;
	db		0			;				;AN000;
	db		Left_Align+Char_Field_ASCIIZ ;			   ;AN000;
	db		20			;				;AN000;
	db		01			;				;AN000;
	db		Blank			;				;AN000;
;---------------------------			;
Sublist_MsgVerify	label dword		;				;AN000;
						;
	db		Sublist_Length		;				;AN000;
	db		Reserved		;				;AN000;
	dw		offset Msg_Allocation_Unit_Val; 			;AN000;
	dw		data			;				;AN000;
	db		1			;				;AN000;
	db		Right_Align+Unsgn_Bin_DWord;				;AN000;
	db		5			; Max 65355 M028			;AN000;
	db		5			;	    M028			;AN000;
	db		Blank
;----------------------------
Sublist_msgShowKBytes label dword		;				;Added with quick format
						;
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset SizeInK		;				
	dw		data			;				
	db		1			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		3			;Max is 999			
	db		3			;				
	db		Blank			;				
;---------------------------			;
Sublist_msgShowMBytes label dword		;				
						;
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset SizeInM		;				
	dw		data			;				
	db		1			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		4			;Max is 9999			
	db		4			;Min is 1			
	db		Blank			;				
;---------------------------			;
Sublist_msgDecimalMBytes label dword		;				
						;
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset SizeInM		;				
	dw		data			;				
	db		1			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		4			;				
	db		0			;				
	db		'0'
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset DecSizeInM	;				
	dw		data			;				
	db		2			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		2			;Max is .99			
msgDecimalNumberofDecimal label byte		;M007; 
	db		2			;Min is .10 ; M007: Not anymore 
	db		'0'
;----------------------------	
;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

;---------------------- 			;
Message_Number	= 1				;				;AN000;
Handle		= No_Handle			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgBadDOSVersion	;				;AN000;
;---------------------- 			;
Message_Number	= 2				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgCurrentTrack	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgCurrentTrack 	;				;AN000;
;---------------------- 			;
Message_Number	= 3				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgDataSpace		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgDataSpace		;				;AN000;
;---------------------- 			;
Message_Number	= 4				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgFormatComplete	;				;AN000;
;---------------------- 			;
Message_Number	= 5				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgBadSpace		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgBadSpace		;				;AN000;
;---------------------- 			;
Message_Number	= 6				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgTotalDiskSpace	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgTotalDiskSpace	;				;AN000;
;---------------------- 			;
Message_Number	= 7				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgInsertDisk 	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgInsertDisk		;				;AN000;
;---------------------- 			;
Message_Number	= 8				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgSystemSpace	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgSystemSpace		;				;AN000;
;---------------------- 			;
Message_Number	= 9				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgReInsertDisk	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg   msgReInsertDisk		;				;AN000;
;---------------------- 			;
Message_Number	= 10				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgLabelPrompt		;				;AN000;
;---------------------- 			;
Message_Number	= 11				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgFormatNotSupported ;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgFormatNotSupported	;				;AN000;
;---------------------- 			;
Message_Number	= 12				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgInvalidDeviceParameters;				;AN000;
;---------------------- 			;
Message_Number	= 13				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgErrorInIOCTL 	;				;AN000;
;---------------------- 			;
Message_Number	= 14				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgNotBlockDevice	;				;AN000;
;---------------------- 			;
Message_Number	= 15				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgFATwriteError	;				;AN000;
;---------------------- 			;
Message_Number	= 16				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgDirectoryWriteError	;				;AN000;
;---------------------- 			;
Message_Number	= 17				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgAssignedDrive	;				;AN000;
;---------------------- 			;
Message_Number	= 18				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgNoSystemFiles	;				;AN000;
;---------------------- 			;
Message_Number	= 19				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgNetDrive		;				;AN000;
;---------------------- 			;
Message_Number	= 20				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgBadCharacters	;				;AN000;
;---------------------- 			;
Message_Number	= 21				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgParametersNotSupported ;				;AN000;
;---------------------- 			;
Message_Number	= 22				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgFormatFailure	;				;AN000;
;---------------------- 			;
Message_Number	= 23				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgNotSystemDisk	;				;AN000;
;---------------------- 			;
Message_Number	= 24				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgDiskUnusable 	;				;AN000;
;---------------------- 			;
Message_Number	= 25				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgBootWriteError	;				;AN000;
;---------------------- 			;
Message_Number	= 26				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgDirectoryReadError	;				;AN000;
;---------------------- 			;
Message_Number	= 27				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgNeedDrive		;				;AN000;
;---------------------- 			;
Message_Number	= 28				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	ContinueMsg		;				;AN000;
;---------------------- 			;
Message_Number	= 29				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgBadVolumeId		;				;AN000;
;---------------------- 			;
Message_Number	= 30				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgSystemTransfered	;				;AN000;
;---------------------- 			;
Message_Number	= 31				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgWhatIsVolumeId?	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgWhatIsVolumeId?	;				;AN000;
;---------------------- 			;
Message_Number	= 32				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgIncompatibleParametersForHardDisk ;			;AN000;
;---------------------- 			;

Message_Number	= 33				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgWriteProtected	;				;AN000;
;---------------------- 			;
Message_Number	= 34				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgNotReady		;				;AN000;
;---------------------- 			;

Message_Number	= 35				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgPartitionTableReadErr ;				;AN000;
;---------------------- 			;
Message_Number	= 36				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgSerialNumber	;				;AN000;
Count		= 2				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgSerialNumber 	;			      ;AN000;
;---------------------- 			;
Message_Number	= 37				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgFormatBroken 	;				;AN000;
;---------------------- 			;
Message_Number	= 38				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgEXECFailure	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgEXECFailure		;				;AN000;
;---------------------- 			;
Message_Number	= 39				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	NO_SYS_MESS		;				;AN000;
;---------------------- 			;
Message_Number	= 40				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgbadpartitiontable	;				;AN000;
;---------------------- 			;
Message_Number	= 41				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgParametersNotSupportedByDrive ;			;AN000;
;---------------------- 			;
Message_Number	= 42				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgCRLF 		;				;AN000;
;---------------------- 			;
Message_Number	= 43				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgInterrupt		;				;AN000;
;---------------------- 			;
Message_Number	= 44				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_MsgInsertDOSDisk	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgInsertDOSDisk	;				;AN000;
;---------------------- 			;
Message_Number	= 45				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_MsgHardDiskWarning	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgHardDiskWarning	;				;AN000;
;---------------------- 			;
Message_Number	= 46				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgFormatAnother?	;				;AN000;
;---------------------- 			;
Message_Number	= 47				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgPartitionTableReadError ;				;AN000;
;---------------------- 			;
Message_Number	= 48				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgPartitionTableWriteError ;				;AN000;
;---------------------- 			;
Message_Number	= 49				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgIncompatibleParameters ;				;AN000;
;---------------------- 			;
Message_Number	= 50				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_MsgAllocNum		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgAllocNum		;				;AN000;
;---------------------- 			;
Message_Number	= 51				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_MsgAllocSize		;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgAllocSize		;				;AN000;
;---------------------- 			;
Message_Number	= 52				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgPartitionTableWriteErr ;				;AN000;
;---------------------- 			;
Message_Number	= 53				;				;AN002;
Handle		= STDOUT			;				;AN002;
Sublist 	= No_Replace			;				;AN002;
Count		= N_A				;				;AN002;
Class		= Utility_Msg_Class		;				;AN002;
Function	= No_Function			;				;AN002;
Input		= N_A				;				;AN002;
	Define_Msg	msgSameSwitch		;				;AN002;
;---------------------- 			;
Message_Number	= 54				;				;AN009;
Handle		= STDOUT			;				;AN009;
Sublist 	= No_Replace			;				;AN009;
Count		= N_A				;				;AN009;
Class		= Utility_Msg_Class		;				;AN009;
Function	= No_Function			;				;AN009;
Input		= N_A				;				;AN009;
	Define_Msg	msgBad_T_N		;				;AN009;
;---------------------- 			;
Message_Number	= 55				;				;an019; dms;
Handle		= STDOUT			;				;an019; dms;
Sublist 	= Sublist_MsgVerify		;				;an019; dms;
Count		= 1				;				;an019; dms;
Class		= Utility_Msg_Class		;				;an019; dms;
Function	= No_Function			;				;an019; dms;
Input		= N_A				;				;an019; dms;
	Define_Msg	MsgVerify		;				;an019; dms;
;----------------------
Message_Number	= 56
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgNoRoomForRestore

;----------------------
Message_Number	= 57
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgNoRoomDestDisk

;----------------------
Message_Number	= 58
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgNotCompatablePart
;----------------------
Message_Number	= 59
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgFileCreationError

;---------------------- 			;
Message_Number	= 60				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBad_8_V		;

;---------------------- 			;
Message_Number	= MSG_OPTIONS_FIRST
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgOptions

;---------------------- 			;
Message_Number	= 0				;
Handle		= STDERR			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Ext_Err_Class 		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	Extended_Error_Msg	;
;----------------------
Message_Number	= 0				;				;AN000;
Handle		= STDERR			;				;AN000;
Sublist 	= Sublist_MsgParse_Error	;				;AN000;
Count		= 1				;				;AN000;
Class		= Parse_Err_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	Parse_Error_Msg 	;				;AN000;
;-----------------------



;
;These need to be coded as extended an parse errors, but left here to link.
;



Message_Number	= 70				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgOutOfMemory		;				;AN000;
;---------------------- 			;
Message_Number	= 71				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgInsufficientMemory	;M024				;AN000;
;---------------------- 			;
Message_Number	= 10				;				;AN000;
Handle		= StdErr			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Parse_Err_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgInvalidParameter	;				;AN000;
;---------------------- 			;
Message_Number	= 73				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Input			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgLoadFailure		;				;AN000;
;-----------------------
Message_Number	= 75				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= No_Replace			;				;AN000;
Count		= N_A				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgQuickFormatAnother?	;				;AN000;
;-----------------------
Message_Number	= 76
Handle		= STDOUT			
Sublist 	= No_Replace			
Count		= N_A				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgExistingFormatDiffers
;----------------------
Message_Number	= 77
Handle		= STDOUT			
Sublist 	= No_Replace			
Count		= N_A				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgNoQuickFormat
;----------------------
Message_Number	= 78				
Handle		= STDOUT			
Sublist 	= Sublist_msgShowKBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgShowKBytes 	
;---------------------- 			
Message_Number	= 79
Handle		= STDOUT			
Sublist 	= Sublist_msgShowMBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgShowMBytes 	
;---------------------- 			
Message_Number	= 80
Handle		= STDOUT			
Sublist 	= Sublist_msgDecimalMBytes
Count		= 2				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgDecimalMBytes 	
;---------------------- 			
Message_Number	= 81
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgSysWarning
;----------------------
Message_Number	= 82
Handle		= STDOUT			
Sublist 	= Sublist_msgShowKBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgVerifyShowKBytes 	
;---------------------- 			
Message_Number	= 83
Handle		= STDOUT			
Sublist 	= Sublist_msgShowMBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgVerifyShowMBytes 	
;---------------------- 			
Message_Number	= 84
Handle		= STDOUT			
Sublist 	= Sublist_msgDecimalMBytes
Count		= 2				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgVerifyDecimalMBytes 	
;---------------------- 			
Message_Number	= 85
Handle		= STDOUT
Sublist 	= No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Input
Input		= N_A
	Define_Msg	msgSavingUNFORMATInfo
;---------------------- 			
Message_Number	= 86
Handle		= STDOUT
Sublist 	= No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Input
Input		= N_A
	Define_Msg	msgCheckExistingDiskFormat
;---------------------- 			
Message_Number	= 87
Handle		= STDOUT			
Sublist 	= Sublist_msgShowKBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgQuickFormatShowKBytes 	
;---------------------- 			
Message_Number	= 88
Handle		= STDOUT			
Sublist 	= Sublist_msgShowMBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgQuickFormatShowMBytes 	
;---------------------- 			
Message_Number	= 89
Handle		= STDOUT			
Sublist 	= Sublist_msgDecimalMBytes
Count		= 2				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgQuickFormatDecimalMBytes 	

;---------------------- 			;
Message_Number	= 90				;				;AN000;
Handle		= STDOUT			;				;AN000;
Sublist 	= Sublist_msgDblspaceDrv 	;				;AN000;
Count		= 1				;				;AN000;
Class		= Utility_Msg_Class		;				;AN000;
Function	= No_Function			;				;AN000;
Input		= N_A				;				;AN000;
	Define_Msg	msgDblspaceDrv		;				;AN000;

;----------------------
Message_Number	= 91
Handle		= STDOUT
Sublist 	= Sublist_msgDblspaceHost
Count		= 1
Class		= Utility_Msg_Class
Function	= No_Function
Input		= N_A
	Define_Msg	msgDblspaceHost

data ends

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\forproc.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)forproc.asm	1.2 85/07/25

.xlist
.xcref
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

	include bpb.inc
	INCLUDE FORCHNG.INC
	INCLUDE SYSCALL.INC
	INCLUDE FOREQU.INC
	INCLUDE FORMACRO.INC
	INCLUDE FORSWTCH.INC
	INCLUDE IOCTL.INC
.cref
.list
data	segment public para 'DATA'
data	ends

code	segment public para 'CODE'
	assume	cs:code,ds:data

	PUBLIC	FormatAnother?,Yes?,REPORT,USER_STRING
	public	fdsksiz,badsiz,syssiz,datasiz,biosiz
	public	AllocSize,AllocNum

	extrn	std_printf:near,crlf:near,PrintString:near
	extrn	Multiply_32_Bits:near
	extrn	AddToSystemSize:near

;No more SAFE module
;	EXTRN	UpdateSystemSize:NEAR

data	segment public	para	'DATA'
	extrn	driveLetter:byte
	extrn	msgInsertDisk:byte
	extrn	msgFormatAnother?:byte
	extrn	msgQuickFormatAnother?:byte
	extrn	msgTotalDiskSpace:byte
	extrn	msgSystemSpace:byte
	extrn	msgBadSpace:byte
	extrn	msgDataSpace:byte
	extrn	Read_Write_Relative:byte
	extrn	msgAllocSize:byte
	extrn	MsgAllocNum:Byte
	extrn	deviceParameters:byte
	extrn	bios:byte
	extrn	dos:byte
	extrn	command:byte
IFDEF DBLSPACE_HOOKS
	extrn	DblSpaceBin:byte
ENDIF
	extrn	Serial_Num_Low:Word
	extrn	Serial_Num_High:Word
	extrn	msgSerialNumber:Byte
	extrn	SwitchMap:Word
	extrn	SwitchCopy:Word
	extrn	inbuff:byte


fdsksiz dd	0

syssiz	dd	0
biosiz	dd	0

badsiz	dd	0

datasiz dd	0

AllocSize dd	0
AllocNum dw	0
	dw	offset driveLetter
data	ends

;***************************************************************************
; Wait for key. If yes return carry clear, else no. Insures
;   explicit Y or N answer.
;***************************************************************************

FormatAnother? proc near

	test	SwitchCopy,SWITCH_Q		;use different message with /Q
	jz	@F
	Message msgQuickFormatAnother?
	jmp	SHORT CheckResponse

@@:
	Message msgFormatAnother?

CheckResponse:
	CALL	Yes?
        pushf                                   ; save result
        call    CrLf                            ; send a new line
        popf                                    ; retrieve the result
	jnc	WAIT20
        jz      Wait20
	JMP	SHORT FormatAnother?
WAIT20:
	RET
FormatAnother? endp

;***************************************************************************
;Routine name:Yes?
;***************************************************************************
;
;Description: Validate that input is valid Y/N for the country dependent info
;	      Wait for key. If YES return carry clear,else carry set.
;	      If carry is set, Z is set if explicit NO, else key was not Yes or No.
;
;Called Procedures: Message (macro)
;		    User_String
;
;Change History: Created	4/32/87 	MT
;
;Input: None
;
;Output: CY = 0 Yes is entered
;	 CY = 1, Z = No
;	 CY = 1, NZ = other
;
;Psuedocode
;----------
;
;	Get input (CALL USER STRING)
;	IF got character
;	   Check for country dependent Y/N (INT 21h, AX=6523h Get Ext Country)
;	   IF Yes
;	      clc
;	   ELSE (No)
;	      IF No
;		 stc
;		 Set Zero flag
;	      ELSE (Other)
;		 stc
;		 Set NZ
;	      ENDIF
;	   ENDIF
;	ELSE  (nothing entered)
;	   stc
;	   Set NZ flag
;	ENDIF
;	ret
;***************************************************************************

Procedure YES?

	call	User_String		;Get character

	jz	$$IF1			;Got one if returned NZ
	mov	AL,23h			;See if it is Y/N
	mov	dl,[InBuff+2]		;Get character
	DOS_Call GetExtCntry		;Get country info call
	cmp	AX,Found_Yes		;Which one?

	jne	$$IF2			;Got a Yes
	clc				;Clear CY for return

	jmp	SHORT $$EN2		;Not a Yes
$$IF2:
	cmp	AX,Found_No		;Is it No?

	jne	$$IF4			;Yep
	stc				;Set CY for return

	jmp	SHORT $$EN4		;Something else we don't want
$$IF4:
	xor	AL,AL			;Set NZ flag for ret
	cmp	AL,1			; " "	 " "
	stc				;And CY flag for good measure

$$EN4:
$$EN2:

	jmp	SHORT $$EN1		;No char found at all
$$IF1:
	xor	AL,AL			;Set NZ flag for ret
	cmp	AL,1
	stc				;And CY flag for good measure

$$EN1:
	ret

Yes?	endp


;***************************************************************************

USER_STRING:

;***************************************************************************
; Get a string from user. Z is set if user typed no chars (imm CR)
;  We need to flush a second time to get rid of incoming Kanji characters also.

	mov	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0 ; Clean out input
	int	21h
	mov	DX,OFFSET InBuff
	mov	AH,STD_CON_STRING_INPUT
	int	21h
	mov	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0 ; Clean out input
	int	21h
	cmp	byte ptr [InBuff+1],0
	ret

;*********************************************
; Make a status report including the following information:
; Total disk capacity
; Total system area used
; Total bad space allocated
; Total data space available
; Number of allocation units
; Size of allocation units

Report:
	call	crlf

	call	Calc_System_Space		;calc system space
	call	Calc_Total_Addressible_Space	;calc total space

	Message msgTotalDiskSpace
						;call std_printf
	cmp	word ptr SysSiz,0
	jnz	SHOWSYS
	cmp	word ptr SysSiz+2,0
	jz	CHKBAD
ShowSys:
	Message msgSystemSpace
						;CALL	 std_printf
						;Report space used by system
ChkBad:
	cmp	word ptr BadSiz,0
	jnz	ShowBad
	cmp	word ptr BadSiz+2,0
	jz	ShowData
ShowBad:
	Message msgBadSpace
						;call	 std_printf
ShowData:
	mov	CX,word ptr Fdsksiz
	mov	BX,word ptr Fdsksiz+2
	sub	CX,word ptr BadSiz
	sbb	BX,word ptr BadSiz+2
	sub	CX,word ptr SysSiz
	sbb	BX,word ptr SysSiz+2
	mov	word ptr datasiz,CX
	mov	word ptr datasiz+2,BX
	Message msgDataSpace			;call	 std_printf

	call	crlf
	mov	AX,deviceParameters.DP_BPB.BPB_BytesPerSector ;
	mov	CL,deviceParameters.DP_BPB.BPB_SectorsPerCluster ;
	xor	CH,CH
	mul	CX				;Get bytes per alloc

	mov	word ptr AllocSize,AX		;Save allocation size
	mov	word ptr AllocSize+2,DX 	; for message
	Message msgAllocSize			;Print size of cluster
	call	Get_Free_Space				;get disk space

	mov	word ptr AllocNum,BX		;Put result in msg
	Message msgAllocNum			; = cluster/disk
	call	crlf
	test	switchmap, SWITCH_8		;If 8 tracks, don't display
	jnz	NoSerialNumber			;serial number
	Message msgSerialNumber 		;Spit out serial number
	call	crlf

NoSerialNumber:
	ret

;***************************************************************************
;Routine name: Read_Disk
;***************************************************************************
;
;description: Read in data using Generic IOCtl
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: AL = Drive number (0=A)
;	DS:BX = Transfer address
;	CX = Number of sectors
;	Read_Write_Relative.Start_Sector_High = Number of sectors high
;	DX = logical sector number low
;
;Output: CY if error
;	 AH = INT 25h error code
;
;Psuedocode
;----------
;	Save registers
;	Setup structure for function call
;	Read the disk (AX=440Dh, CL = 6Fh)
;	Restore registers
;	ret
;***************************************************************************

Procedure Read_Disk

					;This is setup for INT 25h right
					;Change it to Read relative sect
	push	BX			;Save registers
	push	CX
	push	DX
	push	SI
	push	DI
	push	BP
	push	ES
	push	DS
	mov	SI,data
	mov	ES,SI

	assume	ES:data,DS:nothing
					;Get transfer buffer add
	mov	ES:Read_Write_Relative.Buffer_Offset,BX
	mov	BX,DS
	mov	ES:Read_Write_Relative.Buffer_Segment,BX ;Get segment
	mov	BX,data 		;Point DS at parameter list
	mov	DS,BX

	assume	DS:data,ES:data

	mov	Read_Write_Relative.Number_Sectors,CX ;Number of sec to read
	mov	Read_Write_Relative.Start_Sector_Low,DX ;Start sector
	mov	BX,offset Read_Write_Relative
	mov	CX,0ffffh		;Read relative sector
	int	25h			;Do the read
	pop	DX			;Throw away flags on stack
	pop	DS
	pop	ES
	pop	BP
	pop	DI
	pop	SI
	pop	DX			;Restore registers
	pop	CX
	pop	BX
	ret


Read_Disk endp

;***************************************************************************
;Routine name: Write_Disk
;***************************************************************************
;
;description: Write Data using Generic IOCtl
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: AL = Drive number (0=A)
;	DS:BX = Transfer address
;	CX = Number of sectors
;	Read_Write_Relative.Start_Sector_High = Number of sectors high
;	DX = logical sector number low
;
;Output: CY if error
;	 AH = INT 26h error code
;
;Psuedocode
;----------
;	Save registers
;	Setup structure for function call
;	Write to disk (AX=440Dh, CL = 4Fh)
;	Restore registers
;	ret
;***************************************************************************

Procedure Write_Disk


					;This is setup for INT 26h right
					;Change it to Read relative sect

	push	BX			;Save registers
	push	CX
	push	DX
	push	SI
	push	DI
	push	BP
	push	ES
	push	DS
	mov	SI,data
	mov	ES,SI

	assume	ES:data, DS:nothing
					;Get transfer buffer add
	mov	ES:Read_Write_Relative.Buffer_Offset,BX
	mov	BX,DS
	mov	ES:Read_Write_Relative.Buffer_Segment,BX ;Get segment
	mov	BX,data 		;Point DS at parameter list
	mov	DS,BX

	assume	DS:data, ES:data

	mov	Read_Write_Relative.Number_Sectors,CX ;Number of sec to write
	mov	Read_Write_Relative.Start_Sector_Low,DX ;Start sector
	mov	BX,offset Read_Write_Relative
	mov	CX,0ffffh		;Write relative sector
	int	26h			;Do the write
	pop	DX			;Throw away flags on stack
	pop	DS
	pop	ES
	pop	BP
	pop	DI
	pop	SI
	pop	DX			;Restore registers
	pop	CX
	pop	BX
	ret

Write_Disk endp

;=========================================================================
; Calc_Total_Addressible_Space	: Calculate the total space that is
;				  addressible on the the disk by DOS.
;
;	Inputs	: none
;
;	Outputs : Fdsksiz - Size in bytes of the disk
;=========================================================================

Procedure Calc_Total_Addressible_Space

	push	AX				;save affected regs
	push	DX
	push	BX

	call	Get_Free_Space			;get free disk space

	push	BX				;save avail. cluster
	push	DX				;save total. cluster

	mov	AX,DX				;get total clusters

	xor	BX,BX				;clear BX
	xor	CX,CX				;clear CX
						;get total sectors
	mov	CL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	call	Multiply_32_Bits

	xor	CX,CX				;clear CX
						;get total bytes
	mov	CX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	call	Multiply_32_Bits		; multiply

	mov	word ptr FdskSiz,AX		;save high word
	mov	word ptr FdskSiz+2,BX		;save low word

	pop	DX				;get total clusters
	pop	BX				;get avail clusters

	mov	AX,DX				;get total clusters
	sub	AX,BX				;get bad clusters

	xor	BX,BX				;clear BX
	xor	CX,CX				;clear CX
						;get total sectors
	mov	CL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	call	Multiply_32_Bits

	xor	CX,CX				;clear CX
						;get total bytes
	mov	CX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	call	Multiply_32_Bits

	sub	AX,word ptr SysSiz
	sbb	BX,word ptr SysSiz+2		;size

	mov	word ptr BadSiz,AX		;save high word
	mov	word ptr BadSiz+2,BX		;save low word

	pop	BX
	pop	DX				;restore regs
	pop	AX

	ret

Calc_Total_Addressible_Space	endp


;=========================================================================
; Get_Free_Space	: Get the free space on the disk.
;
;	Inputs	: none
;
;	Outputs : BX - Available space in clusters
;		  DX - Total space in clusters
;=========================================================================

Procedure Get_Free_Space

	xor	AX,AX				;clear ax
	mov	AH,36h				;Get disk free space
	mov	DL,DriveLetter			;get drive letter
	sub	DL,"A"				;get 0 based number
	inc	DL				;make it 1 based
	int	21h
	ret

Get_Free_Space	endp

;=========================================================================
; Calc_System_Space	: This routine calculates the space occupied by
;			  the system on the disk.
;
;	Inputs	: DOS.FileSizeInBytes
;		  BIOS.FileSizeInBytes
;		  Command.FileSizeInBytes
;
;	Outputs : SysSiz			- Size of the system
;=========================================================================

Procedure Calc_System_Space

	push	AX					;save regs
	push	DX

	mov	word ptr SysSiz+0,00h			;clear variable
	mov	word ptr SysSiz+2,00h

	mov	AX,word ptr [Dos.FileSizeInBytes+0]	;get low word
	mov	DX,word ptr [Dos.FileSizeInBytes+2]	;get high word
	call	AddToSystemSize 			;add in values

	mov	AX,word ptr [Bios.FileSizeInBytes+0]	;get bios size
	mov	DX,word ptr [Bios.FileSizeInBytes+2]
	call	AddToSystemSize 			;add in values

	mov	AX,word ptr [Command.FileSizeInBytes+0] ;get command size
	mov	DX,word ptr [Command.FileSizeInBytes+2]
	call	AddToSystemSize 			;add in values

IFDEF DBLSPACE_HOOKS
	mov	ax, word ptr [DblSpaceBin.FileSizeInBytes]	;get dblspace
	mov	dx, word ptr [DblSpaceBin.FileSizeInBytes+2]	; size--may be
	call	AddToSystemSize 				; zero
ENDIF

;No more SAFE module
;	call	UpdateSystemSize			;add on restore file size

	pop	DX									;restore regs
	pop	AX
	ret

Calc_System_Space	endp

code	ends
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\safe.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1989 - 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 	                                    
; 
; FILE: SAFE.INC
;
; Contains all extern declarations for SAFE.ASM
;
; johnhe - 10/09/89
;===========================================================================

EXTRN		msgNoRoomForRestore:BYTE

DEBUG_MODEL	EQU	0

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\phase1.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 
; FILE: PHASE1.ASM
;
;===========================================================================

;===========================================================================
;Include file declarations
;===========================================================================
debug	 equ	 0
	 .xlist
;	 INCLUDE VERSION.INC
;	 INCLUDE VERSIONA.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
;	 INCLUDE DPB.INC
;	 INCLUDE CPMFCB.INC
	 INCLUDE DIRENT.INC
;	 INCLUDE CURDIR.INC
;	 INCLUDE PDB.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 INCLUDE IOCTL.INC
	 INCLUDE FORSWTCH.INC
;	 INCLUDE SYSVAR.INC
	 .list
;
;---------------------------------------------------------------------------
;
; M020 : Looked for EXT_BOOT_SIG before assuming that the BPB in the boot
;	 sector is an extended one. Bug #4946
;
;---------------------------------------------------------------------------
;



;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Constants
	EXTRN	EXIT_NO			  :ABS
	EXTRN	EXIT_FATAL		  :ABS
;Bytes
	EXTRN  CMCDDFlag:Byte			; m035

	EXTRN	ValidSavedDeviceParameters:BYTE
	EXTRN	Drive			  :BYTE
	EXTRN	msgFormatNotSupported	  :BYTE
	EXTRN	msgInsertDisk		  :BYTE
	EXTRN	msgInvalidDeviceParameters:BYTE
	EXTRN	ContinueMsg		  :BYTE
	EXTRN	msgNotCompatablePart	  :BYTE
	EXTRN	msgExistingFormatDiffers  :BYTE
	EXTRN	msgNoQuickFormat	  :BYTE
	EXTRN	msgCrLf			  :BYTE
	EXTRN	msgCheckExistingDiskFormat:BYTE
	EXTRN	Extended_Error_Msg	  :BYTE
	EXTRN	old_dir			  :BYTE
	EXTRN	ExitStatus		  :BYTE

;Words
	EXTRN	SectorsInRootDirectory	  :WORD
	EXTRN	Paras_Per_Fat		  :WORD
	EXTRN	SwitchMap		  :WORD
	EXTRN	SwitchCopy		  :WORD
	EXTRN	DiskTable		  :WORD
	EXTRN	RWErrorCode		  :WORD

;Pointers
	EXTRN	FatSpace		  :DWORD	; M016

;Functions
	EXTRN	AccessDisk		  :NEAR
	EXTRN	USER_STRING		  :NEAR
	EXTRN	CrLf			  :NEAR
	EXTRN	CheckSwitches		  :NEAR

;No more SAFE module
;	EXTRN	ReadWriteSectors	  :NEAR
	EXTRN	Read_Disk		  :NEAR

	EXTRN	Yes?			  :NEAR

		;Now use DeviceAttributes field in DevParms to check for removable
;	EXTRN	IsRemovable		  :NEAR

;Structures
	EXTRN	SavedParams		  :BYTE
	EXTRN	DeviceParameters	  :BYTE
	EXTRN	SwitchDevParams		  :BYTE
	EXTRN	Read_Write_Relative	  :BYTE

;Labels
	EXTRN	FatalExit		  :NEAR
	EXTRN	ExitProgram		  :NEAR

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

fBig			EQU	0ffh		; flag for 12- or 16-bit FAT

fBigFat			DB	FALSE
ThisSysInd		DB	0		; indicates size of FAT

StartSector		DW	?		; holds first data sector
TotalClusters		DW	?		; holds total #clusters on disk

UnformattedHardDrive	DB	?

MediaSensePacket	A_MEDIA_SENSE		<> ; structure used in media
						   ; sensing call

; the following table provides templates for
; BPBs used in CP/M disks.
; Order is very important (used by both MSFOR and PHASE1)

CustomCPMBPBs	LABEL	BYTE
BPB320	a_BPB	<512, 2, 1, 2, 112,  2*8*40, 0ffh, 1,  8, 2, 0, 0, 0, 0>
BPB160  a_BPB   <512, 1, 1, 2,  64,  1*8*40, 0feh, 1,  8, 1, 0, 0, 0, 0>
BPB360  a_BPB  	<512, 2, 1, 2, 112,  2*9*40, 0fdh, 2,  9, 2, 0, 0, 0, 0>
BPB180  a_BPB	<512, 1, 1, 2,  64,  1*9*40, 0fch, 2,  9, 1, 0, 0, 0, 0>

EndCustomCPMBPBs LABEL	BYTE

; This must folow CustomCPMBPBs

BPB12	a_BPB	<512, 1, 1, 2, 224, 2*15*80, 0F9h, 7, 15, 2, 0, 0, 0, 0>
BPB720	a_BPB	<512, 2, 1, 2, 112, 2* 9*80, 0F9h, 3,  9, 2, 0, 0, 0, 0>
BPB1440	a_BPB	<512, 1, 1, 2, 224, 2*18*80, 0F0h, 9, 18, 2, 0, 0, 0, 0>
BPB2880	a_BPB	<512, 2, 1, 2, 240, 2*36*80, 0F0h, 9, 36, 2, 0, 0, 0, 0>
EndStandardBPBs	LABEL	BYTE	

				; the following table indicates the switches
				; which must be set for the given CP/M media
CPMSwitchTable	LABEL	BYTE
	dw	Switch_4 + Switch_8		;320K
	dw	Switch_1 + Switch_4 + Switch_8	;160K
	dw	Switch_4			;360K
	dw	Switch_1 + Switch_4		;180K

; ========================================================================
; Tables added for media sense support in 5.00.
; ========================================================================

MediaTable	LABEL WORD

	dw	0			; 0
	dw	0 			; 1
	dw	OFFSET BPB720		; 2
	dw	0			; 3
	dw	0			; 4
	dw	0			; 5
	dw	0			; 6
	dw	OFFSET BPB1440		; 7
	dw	0			; 8
	dw	OFFSET BPB2880		; 9

EndMediaTable	LABEL WORD

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA


;===========================================================================
; Declarations for all publics in this module
;===========================================================================


	PUBLIC	Phase1Initialisation
	PUBLIC	MediaSense
	PUBLIC	TargPrm
	PUBLIC	CopyToSwitchDevParams
	PUBLIC	CompareDevParams
	PUBLIC	LoadSwitchDevParams
	PUBLIC	DetermineExistingFormat
	PUBLIC	IsValidBpb
	PUBLIC	ResetDeviceParameters
	PUBLIC	DetermineCPMFormat
;	PUBLIC	ModifySwitchMap		; M019
	PUBLIC	SetCPMParameters
	PUBLIC	Set_BPB_Info
	PUBLIC	Scan_Disk_Table
	PUBLIC	Calc_Big_Fat
	PUBLIC	Calc_Small_Fat
	PUBLIC	SetStartSector
	PUBLIC	SetfBigFat
	PUBLIC	GetTotalClusters
	PUBLIC	fBigFat
	PUBLIC	StartSector
	PUBLIC	TotalClusters
	PUBLIC	CustomCPMBPBs
	PUBLIC	CPMSwitchTable
	PUBLIC	EndStandardBPBs
	PUBLIC	BPB720
	PUBLIC	UnformattedHardDrive

; ==========================================================================
; Phase1Initialisation:
;    This routine sets up fBigFat
;    It also does most	of the other initialisation
;
;    Algorithm:
;	Perform media sensing and if present adjust DeviceParameters
;	Check switches against parameters
;	Use switches to modify device parameters
;	Save a copy of current DeviceParameters in SwitchDevParams
;
;	IF (!SWITCH_U)
;	{
;	  IF (!ValidBootRecord || !ValidBPB)
;	    set SWITCH_U
;	  ELSE
;	  {
;	    get device layout from BPB on disk
;	    IF (DeviceParameters = SwitchDevParams)
;	      do safe/quick format
;	    ELSE
;	    {
;	      IF (Switch_N || Switch_T || Switch_F)
;	      {
;	        Issue warning
;	        Format with BPB from SwitchDevParams if user continues
;	      }
;	      ELSE	
;	        do safe/quick format
;	    }
;	  }
;	}
;	
;	Calculate start sector (first sector not used by DOS)
;	fBigFat = (((TotalSectors - StartSector)/SectorsPerCluster) >= 4086)
; ==========================================================================

Phase1Initialisation proc near

;	xor	BX,BX				; Prepare BX for IsRemovable call
;	mov	BL,Drive			; Get Drive number
;	inc	BL				; Make it 1 based
;	call	IsRemovable			; Do not do media sensing for non-removable media!!
;	jc	@F				; CY --> disk is not removable
				; use DevParms to check for removable instead of call
	test	DeviceParameters.DP_DeviceAttributes,1
	jnz	@F				; Bit 0=1 --> not removable

		; New media sensing call added for 5.00 will see if
		; see if media sensing is avaliable and if it is will
		; reset DeviceParameters to the real parameters for
		; the type of disk being formatted.

	call	MediaSense
@@:
					; Ensure that there is	a valid #
					; of Sectors in	the track table
	mov	SavedParams.DP_TrackTableEntries, 0
	mov	ValidSavedDeviceParameters, 1

					; Initialise to zero to see if
					; CheckSwitches define track layout
	mov	DeviceParameters.DP_TrackTableEntries,0

	call	Set_BPB_Info		; Check to see if we are on
					; Fat system.If not set BPB to proper
					; values for format.
SetMTsupp:
					; Check switches against parameters
					; and use switches to modify device
					; parameters
	call	CheckSwitches
	retc

	call	CopyToSwitchDevParams	; Save a copy of deviceparameters as
					; returned by CheckSwitches

	mov	ax,SwitchMap		; No need to check existing format
	and	ax,SWITCH_U+SWITCH_Q
	cmp	ax,SWITCH_U		; if unconditional format specified
	jnz	CheckExistingFormat
	jmp	DevParamsOk

CheckExistingFormat:
		; New call added for 5.00 to see if the disk has been
		; previously formatted, and if so this will reset
		; DeviceParameters to those of the existing format. 

	call	DetermineExistingFormat   
	jnc	ValidExistingFormat	; carry clear if valid existing format

InvalidExistingFormat:
	and	RWErrorCode,0ffh	; check low byte for 'drive not ready' error	
	cmp	RWErrorCode,ERROR_I24_NOT_READY	;'not ready' error  code = 2
	jne	CheckForQ		; no error reading disk
		
					; 'not ready' error occurred, give msg
	mov	AX,21			; load AX with extended error code for not ready
	Extended_Message		; deliver message "Not Ready"
	mov	ExitStatus,EXIT_FATAL	; M006;
	stc
	jmp	EndPhase1

CheckForQ:
	test	SwitchMap,SWITCH_Q	; Need to give message if /q was specified
	jz	MakeUnconditional

	test	SwitchCopy,(SWITCH_T or SWITCH_N or SWITCH_F)	; did user specify size?
	jnz	TurnOffQ		; do an unconditional format at specified size

	Message	msgNoQuickFormat	; Inform user quick format cannot be done
	call	Yes?			; Continue with unconditional format?

	pushf
	Message	msgCrLf
	popf

	jnc	TurnOffQ
	mov	ExitStatus,EXIT_NO	; load exit code 5 (response is 'no')
	jmp	ExitProgram		; User wants to exit

TurnOffQ:
	and	SwitchMap,NOT SWITCH_Q	; Turn off /Q to continue

MakeUnconditional:
	or	SwitchMap,SWITCH_U	; Enable /U since invalid existing format
	jmp	SHORT DevParamsOk	; Device parameters will not have been
					; modified since invalid existing format

ValidExistingFormat:
	call	CompareDevParams	; see if SwitchDevParams = DeviceParameters
	jnc	DevParamsOk		; they are equal

					; Check if user had specified a format
					; size, since DeviceParameters on disk
					; are different.

;M001
;	test	SwitchCopy,(SWITCH_T or SWITCH_N or SWITCH_F \
;		            or SWITCH_1 or SWITCH_4 or SWITCH_8)	; M000
;	jz	DevParamsOk		; use the ones found on the disk

	test	SwitchMap,SWITCH_Q	; special case where size was specified
					; together with /Q :- use size specified
					; only if invalid existing format
	jnz	DevParamsOk		; use the parameters found on disk

	Message	msgExistingFormatDiffers ; Warn user that SAFE format cannot be done
	call	Yes?

	pushf
	Message	msgCrLf
	popf

	jnc	WantsToContinue	 
	mov	ExitStatus,EXIT_NO	; load exit code 5 (response is 'no')
	jmp	ExitProgram		; User wants to exit

WantsToContinue:
	or	SwitchMap,SWITCH_U	; Enable /U since new format specified
	call	LoadSwitchDevParams	; Set deviceparameters to SwitchDevParams
					; i.e. follow user-specified size
DevParamsOk:
	call	SetDOS_Dpb		; m035 Setup default DOS DPB for this
					;      drive (for memory cards).

IF ShipDisk

	test	SwitchMap,Switch_Z	; 1 sector/cluster disk?
	jz	$$IF19
					; set BPB accordingly
	mov	DeviceParameters.DP_BPB.BPB_SectorsPerCluster,01h
	call	Calc_Small_Fat		; calc Fat size
$$IF19:

ENDIF

	cmp	DeviceParameters.DP_TrackTableEntries,0
	jne	TrackLayoutSet		; There is a good track layout

					; Store sector table info (layout of
					; each track)
	mov	CX, DeviceParameters.DP_BPB.BPB_SectorsPerTrack;CX = loop count
	mov	DeviceParameters.DP_TrackTableEntries,CX
	mov	AX, 1					       ;AX = sector #
	mov	BX, DeviceParameters.DP_BPB.BPB_bytesPerSector ;BX = sector size
	lea	DI, DeviceParameters.DP_SectorTable

LoadSectorTable:
	stosw				; Write the sector number
	xchg	AX, BX			; Get the sector size in bytes
	stosw				; Write the sector size
	xchg	AX, BX
	inc	AX			; Go to the next sector
	loop	LoadSectorTable

TrackLayoutSet:	    
;	call	SetParasPerFat		; Now paras_per_fat is set when buffer is allocated
	call	SetStartSector
	call	SetfBigFat
	call	GetTotalClusters
	clc

EndPhase1:
	return

Phase1Initialisation endp

;==========================================================================
;
; SetParasPerFat :	This procedure will initialize the value of
;			the variable Paras_Per_Fat, based on the settings
;			of DeviceParameters.
;
;==========================================================================

;SetParasPerFat	proc	near
;
;	mov	AX, DeviceParameters.DP_BPB.BPB_BytesPerSector
;	add	AX, 0fH
;	shr	AX, 1
;	shr	AX, 1
;	shr	AX, 1
;	shr	AX, 1
;	mul	DeviceParameters.DP_BPB.BPB_SectorsPerFat
;	mov	Paras_Per_Fat,AX	; 128k Fat
;
;	ret
;SetParasPerFat	endp

; =========================================================================
;
;   MediaSense
;	Checks for media sensing via IOCtl 440d subfuction 0868.
;	If sensing is supported the user will be prompted to insert
;	the disk if it's not detect and then the device parameters
;	will be set according to the type of media being used.
;
;	Before we can use the type returned we must be sure it's
;	not a larger size disk than is formattable in the drive.
;	We can do this by checking the media type byte in the
;	saved device parameters.
;
;   Input:
;	Drive	- Must have already been set
;
; =========================================================================

MediaSense PROC NEAR

	mov	BL, Drive
	inc	BX
	mov	CX, (RAWIO shl 8) or SENSE_MEDIA_TYPE
	lea	DX,MediaSensePacket

					; First check if BIOS supports call
	mov	AX, (IOCTL shl	8) or IOCTL_QUERY_BLOCK
	int	21h
	jc	MediaSenseExit

					; Now do actual call
	mov	AX, (IOCTL shl	8) or GENERIC_IOCTL
	int	21h

	jnc	GotMediaSense

	cmp	AL,error_not_ready
	jne	MediaSenseExit		; Machine does not support media sensing

	call	TargPrm			; Insert disk prompt
	jmp	SHORT MediaSense	; Retry the operation

		; See if the type of media inserted is the same as the
		; default for this type of drive and if not check to
		; be sure it's 

GotMediaSense:
;	test	MediaSensePacket.MS_ISDEFAULT,1	; Is it default media type
;	jnz	MediaSenseExit		; If yes don't need to modify DevParms

	mov	AL,MediaSensePacket.MS_DEVICETYPE ; AL == media type
	cmp	SavedParams.DP_DEVICETYPE,AL 	  ; If the media in the
	jl	MediaSenseExit		; drv is > default size, use default

					; Load BPB for sensed media
	xor	AH,AH
	shl	AX,1			; AX == word offset in media table
	mov	BX, offset MediaTable	; BX -> Start of media table
	add	BX, AX			; BX -> Sensed type in media table

	cmp	BX, offset EndMediaTable ; Make sure we're still in the table
	jge	MediaSenseExit


	mov	SI,[BX]			; DS:SI -> Sensed device parameters
	or	SI,SI
	je	MediaSenseExit		; Unknown Media?!

	lea	DI, DeviceParameters.DP_BPB ; ES:DI -> Format parameters
	mov	CX, size a_BPB		; CX = bytes to move

	cld
	rep	movsb

MediaSenseExit:
	ret

MediaSense ENDP

;========================================================================
;
;  TargPrm :	This procedure prompts the user to insert the target disk
;		into the drive.
;
;========================================================================

TargPrm PROC NEAR

	 mov	 AL, Drive
	 call	 AccessDisk
	 Message MsgInsertDisk
	 Message ContinueMsg
	 call	 USER_STRING
	 call	 CrLf
	 ret

TargPrm ENDP

;=========================================================================
;
;  CopyToSwitchDevParams :	This procedure copies the structure
;				DeviceParameters into SwitchDevParams.
;  Registers destroyed :	CX,DI,SI
;  Assumes :			DS:DATA, ES:Nothing
;  
;=========================================================================

CopyToSwitchDevParams	proc	NEAR

	push	DS
	pop	ES

	mov	DI,OFFSET SwitchDevParams		; ES:DI --> dest. parms

	mov	SI,OFFSET DeviceParameters		; DS:SI --> src. parms

	mov	CX,SIZE A_DEVICEPARAMETERS		; byte transfer count

	cld
	rep	movsb

	ret
CopyToSwitchDevParams	endp

;=========================================================================
;
;  CompareDevParams :		This procedure compares the structure
;				DeviceParameters with SwitchDevParams.
;  Registers destroyed :	CX,DI,SI
;  Assumes :			DS:DATA, ES:Nothing
;
;=========================================================================

CompareDevParams	proc	NEAR

	push	DS
	pop	ES

	mov	DI,OFFSET SwitchDevParams	; ES:DI --> dest. parms

	mov	SI,OFFSET DeviceParameters	; DS:SI --> src. parms

	mov	CX,SIZE A_DEVICEPARAMETERS	; Set up count in bytes
	cld					; Set the direction
	repe	cmpsb				; Compare the two BPBs
	jz	EqualParams			; If ZR then BPBs matched

NotEqualParams:
	stc					; Signal BPBs don't match
	jmp	SHORT CompareParamsExit

EqualParams:
	clc					; Signal BPB matches

CompareParamsExit:
	ret
CompareDevParams	endp
;=========================================================================
;
;  LoadSwitchDevParams :	This procedure copies the structure 
;				SwitchDevParams into DeviceParameters.
;  Registers destroyed :	CX,DI,SI
;  Assumes :			DS:DATA,ES:Nothing
;
;=========================================================================

LoadSwitchDevParams	proc	NEAR

	push	DS
	pop	ES

	mov	DI,OFFSET DeviceParameters		; ES:DI --> dest. parms

	mov	SI,OFFSET SwitchDevParams		; DS:SI --> src. parms

	mov	CX,SIZE A_DEVICEPARAMETERS		; byte transfer count

	cld
	rep	movsb

	ret
LoadSwitchDevParams	endp

;=========================================================================
;
;  DetermineExistingFormat :	This procedure will check if there is a
;				valid format existing on the disk, in 
;				which case DeviceParameters will be reset
;				to that format.
;				
;				It is assumed the destination disk is 
;				already in the drive.
;
;
;  Calls :	IsValidBpb
;		ResetDeviceParameters
;		DetermineCPMFormat
;
;  Called by :  Phase1Initialisation
;
;=========================================================================

DetermineExistingFormat	proc	near

	push	DS
	push	ES
	Set_Data_Segment			;ensure addressibility

	cmp	UnformattedHardDrive,TRUE
	je	InvalidBootRecord

	Message	msgCheckExistingDiskFormat

;M016 - begin

 	xor	DX,DX				; Starting sector  to 0
	mov	AL,Drive			; Set drive number
	mov	AH,DH				; Signal this is a read AH=0
	lds	BX,FatSpace			; Load transfer address
	assume	DS:NOTHING,ES:DATA

	mov	CX,2				; # of sectors to read
						; we are accessing < 32mb
	mov	ES:Read_Write_Relative.Start_Sector_High,0
 
	call	Read_Disk			; Disk sector read
 
	mov	ES:RWErrorCode,AX		; Save error code (if any)
	jc	InvalidBootRecord		; Check for read error

	cmp	BYTE PTR [BX],0e9h		; Check for JMP opcode
	je	TestBootSignature		; If Ok then check signature
						; we can not know #reserved sectors)
	cmp	BYTE PTR [BX],0ebh		; Else check for SHORT jmp	
	jne	TryCPM				; No match then not valid boot
	cmp	BYTE PTR [BX+2],90h		; Now check for NOP opcode
	jne	TryCPM				; No match then not valid boot

TestBootSignature:
	cmp	WORD PTR [BX + 510],0aa55h	; Check for 55 AA sequence
	jne	TryCPM				; Error if not equal

CheckTheBpb:
	call	IsValidBpb
	jc	TryCPM				; CY --> Invalid format

	call	ResetDeviceParameters		; set DeviceParameters to
	clc					; existing ones on the disk
	jmp	SHORT EndDetermine

TryCPM:
						; check in case a CP/M disk is present
;	xor	BX,BX				; first check for removable media
;	mov	BL,Drive
;	inc	BL				; make it 1-based
;	call	IsRemovable
;	jc	InvalidExistingFormat		; No need to check further for non-removable media
						; use DevParms to check for removable instead of call
	test	ES:DeviceParameters.DP_DeviceAttributes,1
	jnz	InvalidBootRecord		; Bit 0=1 --> not removable

	call	DetermineCPMFormat
	jmp	SHORT EndDetermine 		; CP/M disk present, DeviceParameters
						; will have been modified
						; Carry propagated up to
						; Note: DS can be anything
;M016 - end
InvalidBootRecord:
	stc					;flag invalid format

EndDetermine:
	pop	ES
	pop	DS

	ret

DetermineExistingFormat	endp

;=========================================================================
;
; IsValidBpb :	This procedure will inspect the BPB loaded into
;			memory by the DetermineExistinFormat procedure.  
;
; Input  :	DS:BX Buffer holding boot sector (FatSpace) ; M016
; Output :	BPB is valid   - NC
;		BPB is invalid - CY
;
; Assumes:	DS:BX: FatSpace (preserved); M016
;
;=========================================================================

IsValidBpb	proc	near

	assume	DS:NOTHING,ES:DATA

	push	BX			; M016; preserve BX
	add	BX,OFFSET_BPB		; DS:BX points to start of BPB

	cmp	WORD PTR [BX],200h	; check BytesPerSector=512
	jne	NotValidBpb

	and	WORD PTR [BX+8h],0ffffh	; check that both TotalSectors
	jnz	ResetBigTotalSectors	; and BigTotalSectors are not zero
	and	WORD PTR [BX+15h],0ffffh; low word
	jnz	CheckMore
	and	WORD PTR [BX+17h],0ffffh; high word
	jz	NotValidBpb
	jmp	SHORT CheckMore

ResetBigTotalSectors:			; if TotalSectors<>0 set 
	and	WORD PTR [BX+15h],0h	; BigTotalSectors to zero
	and	WORD PTR [BX+17h],0h

CheckMore:
	and	WORD PTR [BX+0bh],0ffffh; check SectorsPerFat <> 0
	jz	NotValidBpb

	cmp	WORD PTR [BX+0dh],1h	; check 0 < SectorsPerTrack < 64
	jb	NotValidBpb
	cmp	WORD PTR [BX+0dh],3fh
	ja	NotValidBpb
	
	cmp	WORD PTR [BX+0fh],1h	; check 0 < Heads < 256
	jb	NotValidBpb
	cmp	WORD PTR [BX+0fh],0ffh
	ja	NotValidBpb

BpbIsValid:
	clc
	jmp	SHORT EndIsValidBpb

NotValidBpb:
	stc

EndIsValidBpb:
	pop	BX			; M016; restore BX
	ret

IsValidBpb	endp

;=========================================================================
;
; ResetDeviceParameters :	This procedure will copy the BPB of the
;				disk into DeviceParameters.  It will also
;				set the fields DP_CYLINDERS and  DP_MEDIATYPE,
;				for removable media.
;
; Inputs :	DS:BX Boot sector held in FatSpace ; M016
; Output :	Modified DeviceParameters
; Modifies:	ES,SI,DI,CX,DX,BX,AX
; Assumes:	DS:BX Boot sector, ES:DATA
;
;=========================================================================

ResetDeviceParameters	proc	near

	assume	DS:NOTHING,ES:DATA

	mov	SI,BX			; Use SI instead of BX for copy
	add	SI,OFFSET_BPB		;DS:SI source BPB in buffer

				;No need to modify DP_CYLINDERS,DP_MEDIATYPE
				;(and DP_DEVICETYPE) for fixed disks.
;	xor	BX,BX			; Prepare BX for IsRemovable call
;	mov	BL,ES:Drive		; Get Drive number
;	inc	BL			; Make it 1 based
;	call	IsRemovable
;	jc	CopyBpb			; CY --> disk is not removable
				; use DevParms to check for removable instead of call
	test	ES:DeviceParameters.DP_DeviceAttributes,1
	jnz	CopyBpb				; Bit 0=1 --> not removable

					;first compute total cylinders as
					;total sectors /(sectors per track)*#heads
	xor	DX,DX
	mov	AX,WORD PTR [SI+8]	;get total sectors
	or	AX,AX			;do we need to use Big total sectors?
	jnz	GotTotalSectors		;don't need to if not zero

UseBigTotalSectors:
	mov	AX,WORD PTR [SI+15h]	;load big total sectors
	mov	DX,WORD PTR [SI+17h]

GotTotalSectors:			;now DX:AX has total #sectors
	mov	BX,WORD PTR [SI+0Dh]	;get sectors per track
	div	BX
	xor	DX,DX			;clear the remainder
	mov	CX,WORD PTR [SI+0Fh]	;get number of heads
	div	CX
	or	DX,DX
	jz	CylindersOk
	inc	AX

;BUGBUG: Arithmetic may result in CYLINDERS being 1 less than actual value,
;	 for big disks (hence this calculation is skipped for fixed disks)
; PYS: fixed using same code as MSINIT.ASM

CylindersOk:
	mov	ES:DeviceParameters.DP_CYLINDERS,AX

					;now determine DP_MEDIATYPE & DP_DEVICETYPE

	mov	ES:DeviceParameters.DP_MEDIATYPE,0	; init. to zero
	cmp	AX,40					; only 360K or less has 40 cylinders
;	ja	Not360K
	jne	CopyBpb					; MEDIATYPE has been set

	cmp	ES:DeviceParameters.DP_DEVICETYPE,DEV_5INCH96TPI
	jne	CopyBpb

Is360K:
	mov	ES:DeviceParameters.DP_MEDIATYPE,1	; set to 1 only for 360K in 1.2M


;BUGBUG: Changing the value of DEVICETYPE can result in SwitchDevParams !=
;	 DeviceParameters, and hence a just-formatted 360K disk may not be
;	 recognized!  -is it really necessary to set DEVICETYPE?

;	mov	ES:DeviceParameters.DP_DEVICETYPE,DEV_5INCH	; found 360K
;	jmp	SHORT CopyBpb
;
;Not360K:	    			; BX = sectors per track
;	cmp	BX,9			; is it 720K?
;	jnz	Not720
;	mov	ES:DeviceParameters.DP_DEVICETYPE,DEV_3INCH720KB	; found 720K
;	jmp	SHORT CopyBpb
;
;Not720:
;	cmp	BX,15			; is it 1.2M?
;	jnz	Not96TPI
;	mov	ES:DeviceParameters.DP_DEVICETYPE,DEV_5INCH96TPI	; found 1.2M
;	jmp	SHORT CopyBpb
;
;Not96TPI:
;	cmp	BX,18			; is it 1.44M?
;	jnz	Not144
;	mov	ES:DeviceParameters.DP_DEVICETYPE,DEV_3INCH1440KB	; found 1.44M
;	jmp	SHORT CopyBpb
;
;Not144:
;	mov	ES:DeviceParameters.DP_DEVICETYPE,DEV_3INCH2880KB	; found 2.88M


;Following code was taken out earlier, due to its ignorance of 3.5in media
;	cmp	BX,9			;now determine media type
;	ja	HighDensity
;
;	cmp 	ES:DeviceParameters.DP_DEVICETYPE,1	;set MEDIATYPE to 1 only if
;	jne	HighDensity				;DEVICETYPE is 1
;	
;	mov	ES:DeviceParameters.DP_MEDIATYPE,1	;320/360KB since 9sectors/track
;	jmp	SHORT CopyBpb
;
;HighDensity:
;	mov	ES:DeviceParameters.DP_MEDIATYPE,0	;1.2M since >9sectors/track
	
CopyBpb:
	mov	DI,OFFSET ES:DeviceParameters.DP_BPB
					;ES:DI destination BPB in DeviceParameters
	mov	CX,BPB_LENGTH		;byte transfer count
;
; M020 - BEGIN
;
	cmp	byte ptr [si+26h], 29h	; extended BPB ?
	je	@f
	mov	cx,(BPB_LENGTH-6)	; small BPB
@@:
;
; M020 - END
;

	cld				;set the direction  
	rep	movsb			;write the new BPB
	ret

ResetDeviceParameters	endp

;=========================================================================
;
; DetermineCPMFormat :		This procedure will check the media 
;				descriptor in the FAT of the disk.  The
;				disk has a valid CP/M format if this is
;				in the range FCh - FFh.
;
;  Assumes :	DS:BX points to boot sectors. ; M016
;  Modifies :	DS ; M016
;  Returns :	NC - Valid CP/M format detected
;		     DeviceParameters modified
;		CY - Invalid format
;
;==========================================================================

DetermineCPMFormat	proc	NEAR

;M016 - begin
	assume	DS:NOTHING,ES:DATA	

	cmp	ES:DeviceParameters.DP_BPB.BPB_BytesPerSector,512
	stc				; Checking default for drive
					; (cannot check BPB since disk
					;  may not have one)
	jne	ExitDetCPMFormat
	add	BX,512			; DS:BX points to first FAT


	mov	CL,BYTE PTR [BX]  	; load media descriptor byte into CL
	cmp	CL,0fch
	jb	ExitDetCPMFormat	; below = carry, how practical!

	Set_Data_Segment		; For the two following calls

;M016 - end

;	call	ModifySwitchMap		; M019; set the required switches
	call	SetCPMParameters	; modify DeviceParameters accordingly

ExitDetCPMFormat:
	ret
DetermineCPMFormat	endp

;M019 - begin
;========================================================================
;
; ModifySwitchMap :	This procedure sets the required switches for the
;			type of CP/M format detected. Also, old_dir is set
;			to TRUE if /8 is set.
;
; Returns :		Modified SwitchMap
;			Modified old_dir
;
; Assumes :		CL has media descriptor
;
; Modifies :		AX,SI
;
;=========================================================================
;
;ModifySwitchMap	proc	NEAR
; 	
;	xor	AX,AX			; find offset in table by subtracting
;	mov	AL,0ffh			; media descriptor from ffh
;	sub	AL,CL
;
;	shl	AX,1			; get word offset
;	lea	SI,CPMSwitchTable	; get required switches from table
;	add	SI,AX
;
;	mov	AX,WORD PTR [SI]	; load mask into AX
;	or	SwitchMap,AX
;
;	test	SwitchMap,SWITCH_8
;	jz	ExitModifySwitchMap
;
;	mov	old_dir,TRUE
;
;ExitModifySwitchMap:
;	ret
;ModifySwitchMap	endp
;M019 - end

;=========================================================================
;
; SetCPMParameters :	This procedure copies the required BPB from the
;			CP/M BPB table into DeviceParameters.BPB.  Also,
;			DeviceParameters.MediaType is set to 1, and
;			DeviceParameters.Cylinders is set to 40.
;			
;			In case the disk has a 160K or 320K format, the /8
;			switch is set, so that 
; Returns :	NC - DeviceParameters updated
;		CY - Error (out of table boundaries)
;
; Modifies :	AX,BX,CX,DX,SI,DI,ES
;		DeviceParameters
;
; Assumes :	CL contains media descriptor byte
;
;=========================================================================

SetCPMParameters	proc	NEAR

	xor	AX,AX			; find index into CP/M BPB table by
	mov	AL,0ffh			; subtracting media descriptor from ffh
	sub	AL,CL

	mov	BX,SIZE A_BPB		; now find byte offset by multiplying
	mul	BX			; by entry size
	
	lea	SI,CustomCPMBPBs
	add	SI,AX
	cmp	SI,OFFSET EndCustomCPMBPBs ; check we are still in table
	ja	NotInTable

	lea	DI,DeviceParameters.DP_BPB
	mov	CX,SIZE A_BPB		; set up byte transfer count

	push	DS			; set ES=DS
	pop	ES		

	rep	movsb			; load the BPB

	mov	BYTE PTR DeviceParameters.DP_MediaType,1
	mov	BYTE PTR DeviceParameters.DP_Cylinders,40

	clc
	jmp	SHORT ExitSetCPMParm

NotInTable:
	stc

ExitSetCPMParm:
	ret
SetCPMParameters	endp

;=========================================================================
; Set_BPB_Info	 :	 When we have a	Fat count of 0,	we must	calculate
;			 certain parts of the BPB.  The	following code
;			 will do just that.
;
;	 Inputs	 : DeviceParameters
;
;	 Outputs : BPB information
;=========================================================================

Procedure Set_BPB_Info			; Calc new BPB

	Set_Data_Segment		; Set up addressibility
					; See if we have 0 Fats specified
	cmp	DeviceParameters.DP_BPB.BPB_NumberOfFats,00h
	jne	$$IF101 		; Yes, 0 FatS specified
	call	Scan_Disk_Table 	; Access disk table
	mov	BL,BYTE PTR DS:[SI+8]	; Get Fat type
	mov	CX,WORD PTR DS:[SI+4]	; Get Sectors/cluster
	mov	DX,WORD PTR DS:[SI+6]	; Number of entries for the root DIR

	mov	DeviceParameters.DP_BPB.BPB_RootEntries,DX
	mov	DeviceParameters.DP_BPB.BPB_SectorsPerCluster,CH
	mov	DeviceParameters.DP_BPB.BPB_BytesPerSector,0200h
	mov	DeviceParameters.DP_BPB.BPB_ReservedSectors,0001h
	mov	DeviceParameters.DP_BPB.BPB_NumberOfFats,02h

	cmp	BL,FBIG			; Big Fat?
	jne	$$IF102 		; Yes
	call	Calc_Big_Fat		; Calc big Fat info
	jmp	SHORT $$EN102
$$IF102:
	call	Calc_Small_Fat		; Calc small Fat info

$$EN102:
$$IF101:
	ret

Set_BPB_Info ENDP

;=========================================================================
; Scan_Disk_Table	 : Scans the table containing information on
;			   the disk's attributes.  When	it finds the
;			   applicable data, it returns a pointer in
;			   DS:SI for reference by the calling proc.
;
;	 Inputs	 : DiskTable - Contains	data about disk	types
;
;	 Outputs : DS:SI     - Points to applicable disk data
;=========================================================================

Procedure Scan_Disk_Table

	cmp	DeviceParameters.DP_BPB.BPB_TotalSectors,00h ; small disk?
	je	$$IF106 			; Yes

	mov	DX,00h				; Set high to 0
	mov	AX,WORD PTR DeviceParameters.DP_BPB.BPB_TotalSectors
	jmp	SHORT $$EN106

$$IF106:
	mov	DX,WORD PTR DeviceParameters.DP_BPB.BPB_BigTotalSectors[+2]
	mov	AX,WORD PTR DeviceParameters.DP_BPB.BPB_BigTotalSectors[+0]

$$EN106:
	mov	SI,offset DiskTable		; Point to disk data
Scan:

	cmp	DX,WORD PTR DS:[SI]		; Below?
	jb	Scan_Disk_Table_Exit		; Yes, exit
	ja	Scan_Next			; No, continue

	cmp	AX,WORD PTR DS:[SI+2]		; Below or equal?
	jbe	Scan_Disk_Table_Exit		; Yes, exit

Scan_Next:
	add	SI,5*2				; Adjust pointer
	jmp	Scan				; Continue scan

Scan_Disk_Table_Exit:

	ret

Scan_Disk_Table ENDP

;=========================================================================
; Calc_Big_Fat	 :	 Calculates the	Sectors	per Fat	for a 16 bit Fat.
;
;	 Inputs	 : DeviceParameters.DP_BPB.BPB_BigTotalSectors	 or
;		   DeviceParameters.DP_BPB.BPB_TotalSectors
;
;	 Outputs : DeviceParameters.DP_BPB.BPB_SectorsPerFat
;=========================================================================

Procedure Calc_Big_Fat

	cmp	DeviceParameters.DP_BPB.BPB_TotalSectors,00h ; Small disk?
	je	$$IF109 		; Yes

	mov	DX,00h			; Set high to 0
	mov	AX,WORD PTR DeviceParameters.DP_BPB.BPB_TotalSectors
	jmp	SHORT $$EN109

$$IF109:
	 mov	DX,WORD PTR DeviceParameters.DP_BPB.BPB_BigTotalSectors[+2]
	 mov	AX,WORD PTR DeviceParameters.DP_BPB.BPB_BigTotalSectors[+0]

$$EN109:
	mov	CL,04h			; 16 DIR entries per	sector
	push	DX			; Save total	Sectors (high)
					; Get root entry count
	mov	DX,DeviceParameters.DP_BPB.BPB_RootEntries
	shr	DX,CL			; Divide by 16
	sub	AX,DX
	pop	DX			; Restore DX
	sbb	DX,0
	sub	AX,1			; AX	= T - R	- D
	sbb	DX,0
	mov	BL,02h
					; Get Sectors per cluster
	mov	BH,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	add	AX,BX			; AX	= T-R-D+256*SPC+2
	adc	DX,0
	sub	AX,1			; AX	= T-R-D+256*SPC+1
	sbb	DX,0
	div	BX			; Sec/Fat = CEIL((TOTAL-DIR-RES)/
					; (256*SECPERCLUS+2)
					; sectors/cluster

	mov	WORD PTR DeviceParameters.DP_BPB.BPB_SectorsPerFat,AX
	ret

Calc_Big_Fat ENDP


;=========================================================================
; Calc_Small_Fat:	 Calculates the	Sectors	per Fat	for a 12 bit Fat.
;
;	 Inputs	 : DeviceParameters.DP_BPB.BPB_BigTotalSectors	 or
;		   DeviceParameters.DP_BPB.BPB_TotalSectors
;
;	 Outputs : DeviceParameters.DP_BPB.BPB_SectorsPerFat
;=========================================================================

Procedure Calc_Small_Fat

	cmp	DeviceParameters.DP_BPB.BPB_TotalSectors,00h ;small disk?
	je	$$IF112 			; Yes

	mov	DX,00h				; Set high to 0
	mov	AX,WORD PTR DeviceParameters.DP_BPB.BPB_TotalSectors
	jmp	SHORT $$EN112

$$IF112:
	mov	DX,WORD PTR DeviceParameters.DP_BPB.BPB_BigTotalSectors[+2]
	mov	AX,WORD PTR DeviceParameters.DP_BPB.BPB_BigTotalSectors[+0]

$$EN112:
	xor	BX,BX
	mov	BL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	div	BX
						; Now multiply	by 3/2
	mov	BX,3
	mul	BX				; Div by log 2 of Sectors/clus
	mov	BX,2
	div	BX
	xor	DX,DX
						; Now divide by 512
	mov	BX,512
	div	BX
	inc	AX
						; DX:AX contains number of Fat
						; sectors necessary
	mov	DeviceParameters.DP_BPB.BPB_SectorsPerFat,AX
	ret

Calc_Small_Fat ENDP

; ==========================================================================
; StartSector = number	of reserved Sectors
;	  + number of Fat Sectors	 ( Number of FatS * Sectors Per	Fat )
;	  + number of directory	Sectors	 ( 32* Root Entries / bytes Per	Sector )
;					 ( above is rounded up )
;
; Calculate the number	of directory Sectors
; ==========================================================================

SetStartSector	proc near

	 mov	 AX, DeviceParameters.DP_BPB.BPB_RootEntries
	 mov	 BX, size dir_entry
	 mul	 BX
	 add	 AX, DeviceParameters.DP_BPB.BPB_bytesPerSector
	 dec	 AX
	 xor	 DX,DX
	 div	 DeviceParameters.DP_BPB.BPB_bytesPerSector
	 mov	 SectorsInRootDirectory,AX
	 mov	 StartSector, AX				;not done yet!

; Calculate the number	of Fat Sectors
	 mov	 AX, DeviceParameters.DP_BPB.BPB_SectorsPerFat
	 mul	 DeviceParameters.DP_BPB.BPB_numberOfFats
; add in the number of	boot Sectors
	 add	 AX, DeviceParameters.DP_BPB.BPB_ReservedSectors
	 add	 StartSector, AX

	 return

SetStartSector	endp

; ==========================================================================
;
; fBigFat = ( ( (TotalSectors - StartSector) / SectorsPerCluster) >= 4086 )
;
; ==========================================================================

SetfBigFat proc near

						; > 32mb part?
	cmp	DeviceParameters.DP_BPB.BPB_BigTotalSectors+2,0
	je	$$IF21				; Yes, big Fat

	mov	fBigFat, TRUE			; Set flag
	mov	ThisSysInd,6
	jmp	SHORT $$EN21			; Nope, < 32,b

$$IF21: 					; Assume this used
	mov	AX,DeviceParameters.DP_BPB.BPB_BigTotalSectors
	cmp	AX,0				; Was this field used?

	jne	$$IF23				; Nope, use other sector field
	mov	AX, DeviceParameters.DP_BPB.BPB_TotalSectors

$$IF23: 					; ** Fix for PTM PCDOS P51
	mov	ThisSysInd,1			; Set small Fat for default
	sub	AX,StartSector			; Get Sectors in data area
	xor	DX,DX
	xor	BX,BX
	mov	bl,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	div	BX				; Get total clusters

	cmp	AX,BIG_Fat_THRESHOLD		; Is clusters >= 4086?	
	jnae	$$IF25

	mov	fBigFat,TRUE			; 16 bit Fat if	>=4096
						; ** END fix for PTM PCDOS P51
	mov	ThisSysInd,4			; set large Fat
$$IF25:
$$EN21:
	return

SetfBigFat endp

;==========================================================================
;
; GetTotalClusters :	This procedure initializes the variable TotalClusters.
;			This is utilized by Quick Format to check for when all
;			the clusters have been processed.
; Destroys :	AX,BX,CX,DX
; Strategy :	TotalClusters = (TotalSectors-Fats-Root-Reserved)/SectorsPerCluster
;
;==========================================================================

GetTotalClusters	proc	NEAR

	xor	DX,DX
	mov	AX,DeviceParameters.DP_BPB.BPB_TotalSectors
	or	AX,AX			; Check if BigTotalSectors must be used
	jnz	GoSubstract		; M015; Substrack Fats, Root and reserved

GetBigSectors:
	mov	AX,DeviceParameters.DP_BPB.BPB_BigTotalSectors
	mov	DX,DeviceParameters.DP_BPB.BPB_BigTotalSectors[2]

;M015 - begin
GoSubstract:
	sub	AX,DeviceParameters.DP_BPB.BPB_ReservedSectors
	sbb	DX,0

	xor	CH,CH
	mov	CL,DeviceParameters.DP_BPB.BPB_NumberOfFats
	jcxz	GoDivide		; M017; if non fat, don't even do the root

SubstractAFat:
	sub	AX,DeviceParameters.DP_BPB.BPB_SectorsPerFat
	sbb	DX,0
	loop	SubstractAFat

GoSubstractRoot:
;M017 - Begin
; Assumes that BytesPerSectors is a power of 2 and at least 32
; Those are valid assumptions since BIOS requires the same.

	mov	BX,DeviceParameters.DP_BPB.BPB_BytesPerSector
	mov	CL,5			; divide by 32
	shr	BX,CL			; BX = root entries per sector (a power of 2)

	or	BX,BX			; Sanity check for infinite looping
	jz	SayWhat

	mov	CX,DeviceParameters.DP_BPB.BPB_RootEntries

SubstractRootLoop:
	test	BX,1
	jnz	SubstractRootReady
	shr	BX,1
	shr	CX,1
	jmp	short SubstractRootLoop

SubstractRootReady:
;M017 - end

	sub	AX,CX
	sbb	DX,0

GoDivide:
	xor	BH,BH
	mov	BL,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	cmp	DX,BX
	jae	SayWhat
	
	div	BX

	inc	AX			; M015; Bump by 1 since start with 2
	cmp	AX,0FFEFh		; M017; Sanity check
	ja	SayWhat			; M017;

	mov	TotalClusters,AX
	ret

SayWhat:
	Message	msgInvalidDeviceParameters
	jmp	FatalExit

;M015 - end
	
GetTotalClusters	endp

	; m035 Start - Need to set the DPB for a memory card because the
	;	       default will be for the last disk accessed in the
	;	       the drive and may not be correct for the current
	;	       disk.

SetDOS_Dpb PROC

	cmp	CMCDDFlag, Yes
	je	@f
	ret
@@:

	push	AX
	push	BX
	push	DX
	push	BP
	push	SI
	push	ES

	push	DS
	mov	AH,32h
	mov	DL,Drive
	inc	DL
	int	21h				; Get DPB in DS:BX

	push	DS
	pop	ES
	mov	BP,BX				; ES:BP -> DPB

	pop	DS
	mov	SI, OFFSET DeviceParameters.DP_BPB ; DS:SI --> BPB for disk

	mov	AH,53h
	int	21h				; Create correct DPB from BPB

	pop	ES
	pop	SI
	pop	BP
	pop	DX
	pop	BX
	pop	AX

	ret

SetDOS_Dpb ENDP

	; m035 End
;==========================================================================

CODE	ENDS

END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\safedef.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1989 - 1991
; *                      All Rights Reserved.																
; */
;===========================================================================
;
;
; FILE: SAFEDEF.INC
;
; Contains all structure declarations and equates for SAFE.ASM
;
; johnhe - 10/09/89
;===========================================================================


;===========================================================================
; Entry layout for a DOS file in a DOS directory									*/
;===========================================================================

Dir STRUC
	fName		DB	'        '	; File primary name
	fExt		DB	'   '		; File extension
	fAttrib		DB	0		; File attributes
	fReserved	DB	10 DUP (0)	; Reserved by DOS
	fTime		DW	0		; Packed creation time
	fDate		DW	0		; Packed creation date
	fCluster	DW	0		; Files starting cluster
	fSize		DD	0		; File lenght in bytes
Dir ENDS

;===========================================================================
; Layout of the recovery file header
;===========================================================================

FileHeader STRUC

	fhSign1		DB	4 DUP (?)	; 055h, 0AAh, 0AAh, 055h
	fhSign2		DB	16 DUP (?)	; "Microsoft Corp.",0
	fhHeadChksum	DB	(?)		; Chksum for 1st 512 bytes
	fhFileChkSum	DB	(?)		; Chksum for rest of the file
	fhChainOffset	DW	(?)		; File's cluster chain		

	fhBootSize	DD	(?)		; Size of boot record
	fhFatSize	DD	(?)		; Size of FAT
	fhDirSize	DD	(?)		; Size of root directory
	fhClustSize	DD	(?)		; Size of the 2 cluster

	fhBootOffset	DD	(?)		; Offset of boot record
	fhFatOffset	DD	(?)		; Offset of FAT
	fhDirOffset	DD	(?)		; Offset of root directory
	fhClustOffset	DD	(?)		; Offset of the 2 cluster

	fhDir		DB	32 DUP (?)	; This file's directory entry
	fhBpb		DB	25 DUP (?)	; Disk's BPB structure
	fhFileReserve	DB	(?)		; Start of reserved area

FileHeader ENDS

;===========================================================================
; Layout of the int 25 & 26 packets
;===========================================================================

DiskPacket STRUC
	pAddr		DD	(?)		; Buffer address
	pSectors	DW	(?)		; Number of sectors
	pStart		DD	(?)		; Relative starting sector
DiskPacket ENDS

;===========================================================================
; Misc. equates
;===========================================================================

IGNORE_BIT	EQU	00001000b	; Mask to get ignore bit from AH
					; at entry to int 24h handler
SECTOR_SIZE	EQU 	512		; Normal sector size
HEADER_SIZE	EQU	2048		; Smallest cluster on a hard disk
MAX_SECTORS	EQU	3fh		; Max secters for read or write
OFFSET_BPB	EQU	11		; Offset of BPB in boot record
BPB_LENGTH	EQU	25		; Length of BPB structure
DIR_ENTRY_LEN	EQU	32		; Lenght of a directory entry
DIR_NAME_LEN	EQU 	11		; Bytes in a directory file name
ERASED_FILE	EQU	0e5h

IFDEF DBLSPACE_HOOKS
  NUM_SYS_FILES	EQU	4	    ; IO.SYS MSDOS.SYS COMMAND.COM DBLSPACE.BIN
ELSE
  NUM_SYS_FILES	EQU	3	    ; IO.SYS MSDOS.SYS COMMAND.COM
ENDIF

DO_READ		EQU	0		; Signal to do a read
DO_WRITE	EQU	1		; Signal to do a write
MAX_BLOCK_SIZE	EQU	0fff0h		; Max bytes for DOS read or write

BOOT_VALUE	EQU	0		; Layout of values in the arrays
FAT_VALUE	EQU	1		; which describe the offset in
DIR_VALUE	EQU	2		; in the restore file and each
CLUSTER_VALUE	EQU	3		; areas length

RESTORE_ATTRIBS	EQU 	7		; Restore file's attributes

;===========================================================================



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\msfor.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; e forproc.sal= @(#)ibmfor.asm 1.28 85/10/15
	name	OemFormatRoutines
;
;******************************************************************************
;AN001 - ???
;AN002 - D304 Modify Boot record structure for OS2		  11/09/87 J.K.
;******************************************************************************

INCLUDE FORCHNG.INC
debug	equ	0

; ============================================================================

; Public for debugging only

	public	WriteBootSector
	public	WriteBogusDos
	public	ConvertToOldDirectoryFormat
	public	SetPartitionTable
	public	ReadSector
	public	WriteSector
	public	SectorIO
	public	GetVolumeId

	public	EndSwitchCheck
	public	GetBPBs
	public	CalcTotal
	public	WeCanNotIgnoreThisError
	public	HardDisk?
	public	BogusDos
	public	sys_mess_loop
	public	end_sys_loop
	public	DirectoryRead
	public	wrtdir
	public	DirectoryWritten
	public	FCBforVolumeIdSearch
	public	CopyVolumeId
;M008	public	CompareVolumeIds
;M008	public	BadVolumeId

	public	boot2
	public	boot
	public	scratchBuffer

	public	oldDrive
	public	oldVolumeId
	public	Read_Write_Relative
	public	Serial_Num_Low
	public	Serial_Num_High
	public	SizeMap

	public	ptr_msgWhatIsVolumeId?

	public	trackReadWritePacket
	public	CheckSwitch8B

; ============================================================================

data	segment public para 'DATA'
data	ends

; ============================================================================

code	segment public para 'CODE'
	assume	cs:code,ds:data

; ============================================================================

	public	AccessDisk
	public	CheckSwitches
	public	LastChanceToSaveIt
	public	OemDone
	public	BiosFile
	public	DosFile

data	segment public	para	'DATA'
	extrn	AddToSystemSize:near
	extrn	currentCylinder:word
	extrn	currentHead:word
	extrn	deviceParameters:byte
	extrn	drive:byte
	extrn	driveLetter:byte
	extrn	fBigFAT:byte
	extrn	inbuff:byte
	extrn	switchmap:word
	extrn	Old_Dir:byte
	extrn	fLastChance:byte
	extrn	Fatal_Error:byte
	extrn	Bios:byte
	extrn	Dos:byte
	extrn	Command:byte
	extrn	CustomCPMBPBs:byte
	extrn	EndStandardBPBs:byte
	extrn	CPMSwitchTable:byte
	extrn	BPB720:byte

	extrn	msgBad_T_N:byte
	extrn	msgBadVolumeId:byte
	extrn	msgBadPartitionTable:byte
	extrn	msgBootWriteError:byte
	extrn	msgFormatFailure:byte
	extrn	msgDirectoryReadError:byte
	extrn	msgDirectoryWriteError:byte
	extrn	msgIncompatibleParameters:byte
	extrn	msgIncompatibleParametersForHardDisk:byte
	extrn	msgParametersNotSupportedByDrive:byte
	extrn	msgPartitionTableReadError:byte
	extrn	msgPartitionTableWriteError:byte
	extrn	msgWhatIsVolumeId?:byte
	extrn   msgBad_8_V:byte
	extrn	Extended_Error_Msg:byte

	extrn	NumSectors:word, TrackCnt:word

IF	DEBUG
	extrn	msgFormatBroken:byte
ENDIF

; ============================================================================

data	ends

; ============================================================================

	extrn	PrintString:near
	extrn	std_printf:near
	extrn	crlf:near
	extrn	user_string:near
	extrn	Read_Disk:near
	extrn	Write_Disk:near
	extrn	FatalExit:near


; ============================================================================
; Constants
; ============================================================================

.xlist
INCLUDE	BPB.INC
INCLUDE DOSMAC.INC
INCLUDE FORMACRO.INC
INCLUDE FOREQU.INC
INCLUDE FORSWTCH.INC

; This defines all the int 21H system calls
INCLUDE SYSCALL.INC

; Limits

INCLUDE filesize.inc

; ============================================================================
; These are the data structures which we will need
; ============================================================================

INCLUDE DIRENT.INC
INCLUDE ioctl.INC
INCLUDE version.inc

.list

; ============================================================================
; And this is the actual data
; ============================================================================

data	segment public	para	'DATA'

Read_Write_Relative Relative_Sector_Buffer <>


	IF IBMCOPYRIGHT
BiosFile db	"x:\IBMBIO.COM", 0
DosFile db	"x:\IBMDOS.COM", 0
	ELSE
BiosFile db	"x:\IO.SYS", 0
DosFile db	"x:\MSDOS.SYS", 0
	ENDIF

Dummy_Label db	"NO NAME    "
Dummy_Label_Size dw  11

Serial_Num_Low dw 0
Serial_Num_High dw 0

SizeMap db	0

trackReadWritePacket a_TrackReadWritePacket <>

boot2	db	0,0,0, "Boot 1.x"
	db	512 - 11 dup(?)

REORG2	LABEL	BYTE
	ORG	BOOT2
	INCLUDE BOOT11.INC
	ORG	REORG2



INCLUDE BOOTFORM.INC


BOOT	LABEL	BYTE
	INCLUDE BOOT.INC

scratchBuffer db 512 dup(?)

ptr_msgWhatIsVolumeId? dw offset msgWhatIsVolumeId?
	dw	offset driveLetter


FAT12_String db "FAT12   "
FAT16_String db "FAT16   "

Media_ID_Buffer Media_ID <>

; ============================================================================

data	ends

; ============================================================================
; AccessDisk:
;    Called whenever a different disk is about to be accessed
;
;    Input:
;	al - drive letter (0=A, 1=B, ...)
;
;    Output:
;	none
; ============================================================================

AccessDisk proc near

	push	ax				; save drive letter
	mov	bl,al				; Set up GENERIC IOCTL REQUEST
	inc	bl				; preamble
	mov	ax,(IOCTL SHL 8) + Set_Drv_Owner ; IOCTL function
	int	21h
	pop	ax
	return

AccessDisk endp

; ============================================================================
;    CheckSwitches:
;	Check switches against device parameters
;	Use switches to modify device parameters
;
;    Input:
;	deviceParameters
;
;    Output:
;	deviceParameters may be modified
;	Carry set if error
;
;
;  /B <> /S
;  /B/8 <> /V
;  /1 or /8 <> /T/N
;
; ============================================================================

	Public	CHeckSwitches
CheckSwitches proc near

	cld					; Everything forward
						; Disallow /C
;	test	switchmap, SWITCH_C
;	jz	CheckExcl
;	Message msgInvalidParameter		; call PrintString
;
;SwitchError:
;	stc
;	ret

CheckExcl:
	test	SwitchMap,SWITCH_Q		;Quick Format?
	jz	No_q

;	test	SwitchMap,not(SWITCH_Q or SWITCH_S or SWITCH_V or SWITCH_B)
						;/Q is allowed only with 
						;/S,/V,/B,/T,/N,/1,/4,/8,/F /U
	test	SwitchMap,not(SWITCH_Q or SWITCH_S or SWITCH_V or SWITCH_B or\
			      SWITCH_T or SWITCH_N or SWITCH_1 or SWITCH_U or\
			      SWITCH_4 or SWITCH_8 or SWITCH_F)

	jz	Q_Is_Valid
	jmp	SHORT Incompatible

No_q:
Q_Is_Valid:
	test	SwitchMap,Switch_F		;Specify size?
	JZ	$$IF1				;Yes
	test	SwitchMap,(Switch_1+Switch_8+Switch_4+Switch_N+Switch_T)
	JZ	$$IF2				;/F replaces above switches

Incompatible:
	Message msgIncompatibleParameters	;Print error
	mov	Fatal_Error,Yes			;Force exit
	JMP	SHORT $$EN2

$$IF2:
	call	Size_To_Switch			;Go set switches based
						; on the size

$$EN2:
$$IF1:
	cmp	Fatal_Error,NO
	JNE	$$IF6

	call	CheckSwitch8B
	call	CheckTN

$$IF6:
	cmp	Fatal_Error,Yes
	jne	ExclChkDone
	
;M014 - begin
	Message	msgFormatFailure
	jmp	FatalExit	
;	stc
;	ret
;M014 - end

; ============================================================================


ExclChkDone:

; ============================================================================
; Patch the boot sector so that the boot strap loader knows what disk to
; boot from

	mov	Boot.EXT_PHYDRV, 00H
	cmp	deviceParameters.DP_DeviceType, DEV_HARDDISK
	jne	CheckFor5InchDrives

; Formatting a hard disk so we must repatch the boot sector

	mov	Boot.EXT_PHYDRV, 80H
	test	switchmap,not (SWITCH_S or SWITCH_V or SWITCH_Select or \
			  SWITCH_AUTOTEST or Switch_B or SWITCH_U or SWITCH_Q)

	jz	SwitchesOkForHardDisk

	Message msgIncompatibleParametersForHardDisk
	stc
	ret

; ============================================================================
; Before checking the Volume Id we need to verify that a valid one exists
; We assume that unless a valid boot sector exists on the target disk, no
; valid Volume Id can exist.
; Assume Dir for vol ID exists in 1st 32mb of partition
; ============================================================================

SwitchesOkForHardDisk:

	SaveReg <ax,bx,cx,dx,ds>
	mov	al,drive
	mov	cx,LogBootSect
	xor	dx,dx
	lea	bx,scratchBuffer

	mov	Read_Write_Relative.Start_Sector_High,0
	call	Read_Disk			;INT	 25h

	jnc	CheckSignature
	stc
	RestoreReg <ds,dx,cx,bx,ax>
	ret

CheckSignature: 				;IF (Boot_Signature != aa55)
	mov	ax, word ptr ScratchBuffer.Boot_Signature
	cmp	ax, 0aa55h			;Find a valid boot record?
	RestoreReg <ds,dx,cx,bx,ax>
	clc					;No, so no need to check label
	JNZ	$$IF8				;No further checking needed
						;Should we prompt for vol label?
	test	SwitchMap,(SWITCH_Select or SWITCH_AUTOTEST)
	JNZ	$$IF9				;Yes, if /Select not entered

	call	CheckVolumeId			;Go ask user for vol label
	JMP	SHORT $$EN9			;/Select entered

$$IF9:
	clc					;CLC indicates passed label test

$$EN9:
$$IF8:
	return

; ============================================================================

Incomp_Message: 				; fix PTM 809

	Message msgIncompatibleParameters	; print incompatible parms
	stc					; signal error
	return					; return to caller

Print_And_Return:
						; call PrintString
	stc
	return


CheckFor5InchDrives:

; Switch is set in FORMAT.ASM if disk is removable
; =========================================================================
;IF SAFE
;					; If we got to this point it means
;					; that the disk being formatted is
;					; not a hard disk so no restore file
;	or	SwitchMap,Switch_U
;ENDIF
; =========================================================================

			;If drive type is anything other than 48 or 96,
			;then only /V/S/H/N/T allowed
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
	je	Got96

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH
	je	Got48

	xor	ax,ax
	or	ax,(Switch_V or Switch_S or Switch_N or Switch_T or Switch_B)
	or	ax,(Switch_Backup or Switch_Select or Switch_Autotest)

IF ShipDisk
	or	ax,Switch_Z
ENDIF
	or	AX,SWITCH_U
	
	or	AX,SWITCH_Q

	not	ax
	test	switchmap,ax			;invalid switch?
	jz	Goto_Got_BPB1			;continue format

	Message msgParametersNotSupportedByDrive
	jmp	short Print_And_Return

Goto_Got_BPB1:
	jmp	SHORT Goto_Got_BPB

				; We have a 96tpi floppy drive /4 allows just
				; about all switches however, /1 requires
Got96:

;;;;;test	switchmap, SWITCH_8		 If /8 we have an error
;;;;;jnz	Incomp_message			 tell user error

	test	switchmap, SWITCH_4
	jnz	CheckForInterestingSwitches	;If /4 check /N/T/V/S

	test	switchmap, SWITCH_1		;If /1 and /4 check others
	jz	Got48

					;If only /1 with no /4, see if /N/T
	test	SwitchMap,(Switch_N or Switch_T)
	jnz	CheckForInterestingSwitches

	jmp	Incomp_message			; tell user error occurred

Got48:
					;Ignore /4 for non-96tpi 5 1/4" drives
	and	switchmap, not SWITCH_4

					;Ignore /1 if drive has only one head
					;and not /8

	cmp	word ptr deviceParameters.DP_BPB.BPB_Heads, 1
	ja	CheckForInterestingSwitches
	test	switchmap, SWITCH_8
	jz	CheckForInterestingSwitches
	and	switchmap, not SWITCH_1

					;Are any interesting switches set?
CheckForInterestingSwitches:
	test	switchmap, not (SWITCH_V or SWITCH_S or Switch_Backup or \
				SWITCH_SELECT or SWITCH_AUTOTEST or \
				Switch_B or SWITCH_U or SWITCH_Q)

	jz	Goto_EndSwitchCheck		;No, everything ok

			;At this point there are switches other than /v/s/h
	test	SwitchMap,(SWITCH_N or SWITCH_T)
	jz	Use_48tpi		;Not /n/t, so must be /b/1/8/4
					;We've got /N/T, see if there are others
	test	SwitchMap, not (SWITCH_N or SWITCH_T or SWITCH_V or \
				SWITCH_S or Switch_Backup or SWITCH_SELECT \
				or SWITCH_AUTOTEST or SWITCH_U or SWITCH_B \
				or SWITCH_Q)

	jz	NT_Compatible			;Nope, all is well

	;If 96tpi drive and /1 exists with /N/T, then okay, otherwise error

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
	jne	Bad_NT_Combo


;; ============================================================================
;IF SAFE
;	test	SwitchMap, not (SWITCH_1 or SWITCH_N or SWITCH_T or \
;				SWITCH_V or SWITCH_U or SWITCH_B)
;ELSE
;	test	SwitchMap, not (SWITCH_1 or SWITCH_N or SWITCH_T or \
;				SWITCH_V or SWITCH_B)
;ENDIF
;; ============================================================================
;
;	jz	Goto_Got_BPB
;
	test	SwitchMap, not (SWITCH_1 or SWITCH_N or SWITCH_T or \
				SWITCH_V or SWITCH_U or SWITCH_B or \
				SWITCH_S or Switch_Backup or SWITCH_SELECT or \
				Switch_Autotest or SWITCH_Q)
	jz	 Goto_Got_BPB

Bad_NT_Combo:
	Message msgIncompatibleParameters
	jmp	Print_And_Return

Goto_Got_BPB:
	jmp	SHORT Got_BPB_Ok		;Sleazy, but je won't reach it

Goto_EndSwitchCheck:
	jmp	EndSwitchCheck

; ============================================================================
; There is a problem with /N/T in that IBMBIO will default to a BPB with the
; media byte set to F0 (other) if the /N/T combo is used for the format. This
; will cause problems if we are creating a media that has an assigned media
; byte, i.e. 160,180,320,360, or 720k media using /N/T. To avoid this problem,
; if we detect a /N/T combo that would correspond to one of these medias, then
; we will set things up using the /4/1/8 switches instead of the /N/T
; MT - 7/17/86 PTR 33D0110
;
; Combo's that we look for - 96tpi drive @ /T:40, /N:9
;			     96tpi drive @ /T:40, /N:8
;
; Look for this combo after we set everything up with the /T/N routine
;			     1.44 drive  @ /T:80, /N:9
; ============================================================================

NT_Compatible:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
	jne	Goto_Got_BPB

	cmp	TrackCnt,40			;Look for 40 tracks
	jne	Got_BPB_Ok

	cmp	NumSectors,9			;9 sectors?
	je	Found_48tpi_Type

	cmp	NumSectors,8			;8 sectors?
	jne	Goto_Got_BPB			;Nope diff type let it go thru

	or	SwitchMap,SWITCH_8		;Yes, turn on /8 switch

Found_48tpi_Type:
	and	SwitchMap,not (SWITCH_N or SWITCH_T) ;Turn off /T/N

; ============================================================================
; End PTR fix
; if we have a 96 tpi drive then we will be using it in 48 tpi mode
; ============================================================================

Use_48tpi:
	cmp	byte ptr deviceParameters.DP_DeviceType, DEV_5INCH96TPI
	jne	Not96tpi

	mov	byte ptr deviceParameters.DP_MediaType, 1
	mov	word ptr deviceParameters.DP_Cylinders, 40
Not96tpi:

; ============================================================================
; Since we know we are formatting in 48 tpi mode turn on /4 switch
; (We use this info in LastChanceToSaveIt)
; ============================================================================

	or	switchmap, SWITCH_4

; ============================================================================
; At this point we know that we will require a special BPB
; It will be one of:
;    0) 9 track 2 sides - if no switches
;    1) 9 track 1 side	- if only /1 specified
;    2) 8 track 2 sides - if only /8 specified
;    3) 8 track 1 side	- if /8 and /1 specified
;
; ============================================================================

GetBPBs:

	mov	cx,4		; 4 values to try
	mov	bx,offset data:CPMSwitchTable
	mov	si,offset data:CustomCPMBPBs
	mov	ax,SwitchMap
	and	ax,SWITCH_4+SWITCH_8+SWITCH_1

FindItLoop:
	cmp	ax,[bx]
	jz	FoundIt
	inc	bx
	inc	bx
	add	si,size a_BPB
	loop	FindItLoop		; Cannot failed

FoundIt:
	test	switchmap, SWITCH_8
	jz	Not8SectorsPerTrack
					; /8 implies Old_Dir = TRUE
	mov	Old_Dir,TRUE

Not8SectorsPerTrack:

				; Ok now we know which BPB to use so lets move
				; it to the device parameters
	lea	di, deviceParameters.DP_BPB
	mov	cx, size a_BPB
	push	ds
	pop	es
	repnz	movsb
	jmp	EndSwitchCheck

; ============================================================================
; /N/T DCR stuff.  Possible flaw exists if we are dealing with a
; HardDisk. If they support the  "custom format" features for
; Harddisks too, then CheckForInterestingSwitches should
; consider /n/t UNinteresting, and instead of returning
; after setting up the custom BPB we fall through and do our
; Harddisk Check.
; ============================================================================

Got_BPB_OK:
	test	switchmap,SWITCH_N+SWITCH_T
	jnz	Setup_Stuff
	jmp	EndSwitchCheck
Setup_Stuff:
; Set up NumSectors and SectorsPerTrack entries correctly
	test	switchmap,SWITCH_N
	jz	No_Custom_Seclim
	mov	ax,word ptr NumSectors
	mov	DeviceParameters.DP_BPB.BPB_SectorsPerTrack,ax
	jmp	short Handle_Cyln
No_Custom_Seclim:
	mov	ax,deviceParameters.DP_BPB.BPB_SectorsPerTrack
	mov	NumSectors,ax

Handle_Cyln:
	test	switchmap,SWITCH_T
	jz	No_Custom_Cyln
; Set up TrackCnt and Cylinders entries correctly
	mov	ax,TrackCnt
	mov	DeviceParameters.DP_Cylinders,ax
	jmp	short Check_720
No_Custom_Cyln:
	mov	ax,DeviceParameters.DP_Cylinders
	mov	TrackCnt,ax

; ============================================================================
; PTM P868  -	Always making 3 1/2 media byte 0F0h. If 720, then set to
;		0F9h and use the DOS 3.20 BPB. Should check all drives
;		at this point (Make sure not 5 inch just for future
;		protection)
;		We will use the known BPB info for 720 3 1/2 diskettes for
;		this special case. All other new diskette media will use the
;		calculations that follow CalcTotal for BPB info.
; Fix MT	11/12/86
; ============================================================================

Check_720:

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
	je	CalcTotal

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH
	je	CalcTotal

	cmp	TrackCnt,80
	jne	CalcTotal

	cmp	NumSectors,9
	jne	CalcTotal

; ============================================================================
; At this point we know we have a 3 1/2 720kb diskette to format. Use the
; built in BPB rather than the one handed to us by DOS, because the DOS one
; will be based on the default for that drive, and it can be different from
; what we used in DOS 3.20 for the 720's. Short sighted on our part to use
; 0F9h as the media byte, should have use 0F0h (OTHER) and then we wouldn't
; have this problem.
; ============================================================================

	SaveReg <ds,es,si,di,cx>

	mov	cx,seg data			; Setup seg regs, just in
	mov	ds,cx				; case they ain't!
	mov	es,cx

	mov	si,offset BPB720		;Copy the BPB!
	mov	di,offset deviceParameters.DP_BPB
	mov	cx,size a_BPB
	rep	movsb
	RestoreReg <cx,di,si,es,ds>
	jmp	SHORT EndSwitchCheck

; ============================================================================
; End PTM P868 fix
; ============================================================================

CalcTotal:
	mov	ax,NumSectors
	mov	bx,DeviceParameters.DP_BPB.BPB_Heads
	mul	bl				; AX = # of sectors * # of heads
	mul	TrackCnt			; DX:AX = Total Sectors
	or	dx,dx
	jnz	Got_BigTotalSectors
	mov	DeviceParameters.DP_BPB.BPB_TotalSectors,ax
	jmp	short Set_BPB
Got_BigTotalSectors:
	mov	DeviceParameters.DP_BPB.BPB_BigTotalSectors,ax
	mov	DeviceParameters.DP_BPB.BPB_BigTotalSectors+2,dx
	push	dx				; preserve dx for further use
	xor	dx,dx
	mov	DeviceParameters.DP_BPB.BPB_TotalSectors,dx
	pop	dx

Set_BPB:

; ============================================================================
; We calculate the number of sectors required in a FAT. This is done as:
; # of FAT Sectors = TotalSectors / SectorsPerCluster * # of bytes in FAT to
; represent one cluster (i.e. 3/2) / BytesPerSector (i.e. 512)
; ============================================================================

	xor	bx,bx
	mov	bl,DeviceParameters.DP_BPB.BPB_SectorsPerCluster
	div	bx				; DX:AX contains # of clusters
; now multiply by 3/2
	mov	bx,3
	mul	bx
	mov	bx,2
	div	bx
	xor	dx,dx				; throw away modulo
; now divide by 512
	mov	bx,512
	div	bx
; dx:ax contains number of FAT sectors necessary
	inc	ax				; Go one higher
	mov	DeviceParameters.DP_BPB.BPB_SectorsPerFAT,ax
	mov	DeviceParameters.DP_MediaType,0

; M010 - begin
	mov	si,offset data:CustomCPMBPBs
	lea	di,DeviceParameters.DP_BPB	; All matches
	push	ds
	pop	es
WhileLoop:
	cmp	si,offset data:EndStandardBPBs	; Find the compatible BPB
	je	MediaNotFound
	mov	ax,[si].BPB_TotalSectors
	cmp	ax,[di].BPB_TotalSectors
	jne	NotThisOne
	mov	ax,[si].BPB_SectorsPerTrack
	cmp	ax,[di].BPB_SectorsPerTrack
	jne	NotThisOne
	
	mov	cx,size a_BPB
	rep	movsb
	jmp	short EndSwitchCheck

NotThisOne:
	add	si,size a_BPB
	jmp	short WhileLoop

MediaNotFound:
	mov	DeviceParameters.DP_BPB.BPB_MediaDescriptor,Custom_Media
; M010 - end

EndSwitchCheck:
	clc
	return

CheckSwitches endp

;*****************************************************************************
;Routine name: Size_To_Switch
;*****************************************************************************
;
;Description: Given the SizeMap field as input indicating the SIZE= value
;	      entered, validate that the specified size is valid for the
;	      drive, and if so, turn on the appropriate data fields and
;	      switches that would be turned on by the equivilent command line
;	      using only switchs. All defined DOS 4.00 sizes are hardcoded,
;	      in case a drive type of other is encountered that doesn't
;	      qualify as a DOS 4.00 defined drive. Exit with error message if
;	      unsupported drive. The switches will be setup for the CheckSwitches
;	      routine to sort out, using existing switch matrix logic.
;
;Called Procedures: Low_Density_Drive
;		    High_Capacity_Drive
;		    720k_Drives
;		    Other_Drives
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap = appropriate Switch_?? values turned on
;	 TrackCnt, NumSectors set if Switch_T,Switch_N turned on
;*****************************************************************************

Procedure Size_To_Switch

	cmp	SizeMap,0			;Are there sizes entered?
	JE	$$IF13				;Yes
	cmp	deviceParameters.DP_DeviceType,DEV_HARDDISK
	JNE	$$IF14				;No size for fixed disk

	Message msgIncompatibleParametersForHardDisk
	JMP	SHORT $$EN14			;Diskette, see what type
$$IF14:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH
	JNE	$$IF16				;Found 180/360k drive

	call	Low_Density_Drive		;Go set switches
	JMP	SHORT $$EN16			;Check for 96TPI

$$IF16:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
	JNE	$$IF18				;Found it

	call	High_Capacity_Drive
	JMP	SHORT $$EN18

$$IF18:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_3INCH720KB
	JNE	$$IF20				;Found 720k drive
	call	  Small_Drives
	JMP SHORT $$EN20

$$IF20:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_OTHER
	JNE	NewType				;Must be 1.44mb
	call	Other_Drives
	JMP	SHORT $$EN22

NewType:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_3INCH2880KB
	JNE	$$IF22
	call	Other_Drives
	JMP	SHORT $$EN22

$$IF22:
	Message msgParametersNotSupportedByDrive
	mov	  Fatal_Error,Yes

$$EN22:
$$EN20:
$$EN18:
$$EN16:
$$EN14:
$$IF13:
	cmp	Fatal_Error,Yes
	JNE	$$IF30
	Message msgIncompatibleParameters

$$IF30:

	cmp	deviceParameters.DP_DeviceType,DEV_HARDDISK
	JNE	$$IF32
	mov	Fatal_Error,Yes

$$IF32:
	and	SwitchMap,not Switch_F		;Turn off /F so doesn't effect
	ret					; following logic

Size_To_Switch endp

;*****************************************************************************
;Routine name: High_Capacity_Drive
;*****************************************************************************
;
;Description: See if 1.2mb diskette, or one of the other 5 1/4 sizes. Turn
;	      on /4 if 360k or lower
;
;Called Procedures: Low_Density_Drive
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap = Switch_4 if 360k or lowere
;*****************************************************************************

Procedure High_Capacity_Drive

	test	SizeMap,Size_1200		;1.2mb diskette?
	JNZ	$$IF34				;Nope

	call	Low_Density_Drive		;Check for /4 valid types
	cmp	Fatal_Error, No			;Find 160/180/320/360k?
	JNE	$$IF35				;Yes

	or	SwitchMap,Switch_4		;Turn on /4 switch
	JMP	SHORT $$EN35			;Did not find valid size

$$IF35:
	mov	Fatal_Error,Yes			;Indicate invalid device

$$EN35:
$$IF34:
	ret

High_Capacity_Drive endp

;*****************************************************************************
;Routine name: Low_Density_Drive
;*****************************************************************************
;
;Description: See if 360k diskete or one of the other 5 1/4 sizes. Turn
;	      on the /1/8 switch to match sizes
;
;Called Procedures: Low_Density_Drive
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap = Switch_1, Switch_8 to define size
;
;	360k = No switch
;	320k = Switch_8
;	180k = Switch_1
;	160k = Switch_1 + Switch_8
;*****************************************************************************


Procedure Low_Density_Drive

	test	SizeMap,Size_160
	JZ	@F
	or	SwitchMap,Switch_1+Switch_8
	JMP	SHORT $$EN39

@@:
	test	SizeMap,Size_180
	JZ	@F
	or	SwitchMap,Switch_1
	JMP	SHORT $$EN39

@@:
	test	SizeMap,Size_320
	JZ	@F
	or	SwitchMap,Switch_8
	JMP	SHORT $$EN39

@@:
	test	SizeMap,Size_360
	JNZ	$$EN39				;None of the above, not valid
	mov	Fatal_Error,Yes

$$EN39:
	ret

Low_Density_Drive endp

;*****************************************************************************
;Routine name: Small_Drives
;*****************************************************************************
;
;Description: See if 720k media in 720 drive, set up /T/N if so, otherwise
;	      error
;
;Called Procedures: None
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap
;	 TrackCnt
;	 NumSectors
;	720k = /T:80 /N:9
;*****************************************************************************

Procedure Small_Drives

	test	SizeMap,Size_720		;Ask for 720k?
	JNZ	@F				;Nope, thats all drive can do
	mov	Fatal_Error,Yes 		;Indicate error
@@:
	ret

Small_Drives endp


;*****************************************************************************
;Routine name: Other_Drives
;*****************************************************************************
;
;Description: See if 1.44 media or 720k media, setup /t/n, otherwise error
;
;Called Procedures: Small_Drives
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap
;	 TrackCnt
;	 NumSectors
;	720k = /T:80 /N:9
;*****************************************************************************

Procedure Other_Drives

	test	SizeMap,Size_2880		;Ask for 1.44mb diskette?
	jnz	Do_2880


	test	SizeMap,Size_1440		;Ask for 1.44mb diskette?
	JNZ	Do_1440				;Nope

	call	Small_Drives			;See if 720k
	cmp	Fatal_Error,No			;Fatal_error=Yes if not
	JNE	@F				;Got 720k

	or	SwitchMap,Switch_T+Switch_N	;Turn on /T:80 /N:9
	mov	TrackCnt,80
	mov	NumSectors,9

@@:
	JMP	SHORT OtherDrivesExit

Do_1440:
	or	SwitchMap,Switch_T+Switch_N	;Turn on /T:80 /N:18;
	mov	TrackCnt,80			;This will protect SIZE=1440
	mov	NumSectors,18			; from non-standard drives with
	JMP	SHORT OtherDrivesExit


Do_2880:
	or	SwitchMap,Switch_T+Switch_N	;Turn on /T:80 /N:18;
	mov	TrackCnt,80			;This will protect SIZE=1440
	mov	NumSectors,36			; from non-standard drives with


OtherDrivesExit:
	ret

Other_Drives endp


;*****************************************************************************
;Routine name:CheckTN
;*****************************************************************************
;
;Description: Make sure than if /T is entered, /N is also entered
;
;Called Procedures:  None
;
;Change History: Created	8/23/87  MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;*****************************************************************************

Procedure CheckTN

	test	SwitchMap,Switch_N		;Make sure /T entered if /N
	JZ	@F

	test	SwitchMap,Switch_T
	JNZ	@F

	Message msgBad_T_N			;It wasn't, so barf
	mov	Fatal_Error,Yes 		;Indicate error
	JMP	SHORT $$EN57

@@:
	test	SwitchMap,Switch_T		;Make sure /N entered if /T
	JZ	$$EN57

	test	SwitchMap,Switch_N
	JNZ	$$EN57				;It wasn't, so also barf
	Message msgBad_T_N
	mov	Fatal_Error,Yes 		;Indicate error

$$EN57:
	ret

CheckTN endp

;------------------------------------------------------------------------------
;    LastChanceToSaveIt:
;	This routine is called when an error is detected in DiskFormat.
;	If it returns with carry not set then DiskFormat is restarted.
;	It gives the oem one last chance to try formatting differently.
;	fLastChance gets set Then to prevent multiple prompts from being
;	issued for the same diskette.
;
;	Algorithm:
;		IF (error_loc == Track_0_Head_1) &
;			  ( Device_type < 96TPI )
;		   THEN
;			fLastChance  := TRUE
;			try formatting 48TPI_Single_Sided
;		   ELSE return ERROR
;
;------------------------------------------------------------------------------

LastChanceToSaveIt proc near

	cmp	currentCylinder, 0
	jne	WeCanNotIgnoreThisError
	cmp	currentHead, 1
	jne	WeCanNotIgnoreThisError

	cmp	deviceParameters.DP_DeviceType, DEV_5INCH
	ja	WeCanNotIgnoreThisError

	mov	fLastChance, TRUE

	or	switchmap, SWITCH_1
	call	CheckSwitches
	clc
	ret

WeCanNotIgnoreThisError:
	stc
	ret

LastChanceToSaveIt endp


;*****************************************************************************
;Routine name WriteBootSector
;*****************************************************************************
;
;DescriptioN: Copy EBPB information to boot record provided by Get recommended
;	      BPB, write out boot record, error
;	      if can write it, then fill in new fields (id, etc..). The volume
;	      label will not be added at this time, but will be set by the
;	      create volume label call later.
;
;Called Procedures: Message (macro)
;
;Change History: Created	4/20/87 	MT
;
;Input: DeviceParameters.DP_BPB
;
;Output: CY clear if ok
;	 CY set if error writing boot or media_id info
;
;Psuedocode
;----------
;
;	Copy recommended EBPB information to canned boot record
;	Write boot record out (INT 26h)
;	IF error
;	   Display boot error message
;	   stc
;	ELSE
;	   Compute serial id and put into field (CALL Create_Serial_ID)
;	   Point at 'FAT_12' string for file system type
;	   IF fBIGFat	 ;16 bit FAT
;	      Point at 'FAT_16' for file system type
;	   ENDIF
;	   Copy file system string into media_id field
;	   Write info to boot (INT 21h AX=440Dh, CX=0843h SET MEDIA_ID)
;	   IF error (CY set)
;	      Display boot error message
;	      stc
;	   ELSE
;	      clc
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure WriteBootSector

	lea	si, deviceParameters.DP_BPB	;Copy EBPB to the boot record
	lea	di, Boot.EXT_BOOT_BPB
	mov	cx, size EXT_BPB_INFO
	push	ds				;Set ES=DS (data segment)
	pop	es
	repnz	movsb				;Do the copy
						;Write out the boot record
	mov	al, drive			;Get drive letter
	mov	cx, 1				;Specify 1 sector
	xor	dx, dx				;Logical sector 0
	lea	bx, boot			;Point at boot record

	mov	Read_Write_Relative.Start_Sector_High,0
	call	Write_Disk
	JNC	$$IF62				;Error on write

	cmp	ah,3				; M013
	jnz	NotWriteProtected		; M013
	mov	ax,19				; M013
	Extended_message			; M013
	stc					; M013
	ret					; M013

NotWriteProtected:				; M013
	Message msgBootWriteError		;Print error
	stc					;CY=1 means error
	ret

$$IF62:
	mov	cx,Dummy_Label_Size		;Put in dummy volume label
	lea	si,Dummy_Label			; size ac028
	lea	di,Media_ID_Buffer.Media_ID_Volume_Label
	rep	movsb
	call	Create_Serial_ID		;Go create unique ID number
	lea	si,FAT12_String			;Assume 12 bit FAT
	cmp	fBigFAT,TRUE			;Is it?
	JNE	$$IF64				;Not if fBigFat is set....
	lea	si,FAT16_String 		;Got 16 bit FAT

$$IF64:
						;Copy file system string
	mov	cx,8				; to buffer
	lea	di,Media_ID_Buffer.Media_ID_File_System
	repnz	movsb
	mov	bl,Drive			;Get drive
	inc	bl				;Make it 1 based
	xor	bh,bh				;Set bh=0
	mov	ch,RawIO			;Set Media ID call
	mov	cl,Set_Media_ID
	mov	dx,offset Media_ID_Buffer	;Point at buffer

	mov	al,IOCTL_QUERY_BLOCK		;Check if function is supported
	DOS_Call IOCtl				;before attempting it
	JC	$$IF66				;Skip over operation since not
						;supported on carry
	mov	al,Generic_IOCtl		;Perform actual function since
	DOS_Call IOCtl				;got no carry from ioctl query
	JNC	$$IF66				;Error ? (Write or old boot rec)

	Message msgBootWriteError		;Indicate we couldn't write it
	stc					;CY=1 for error return
	JMP	SHORT $$EN66			;Set Media ID okay

$$IF66:
	clc					;CY=0 for good return
$$EN66:
$$EN62:
	ret

WriteBootSector endp


;*****************************************************************************
;Routine name Create_Serial_ID
;*****************************************************************************
;
;DescriptioN&gml Create unique 32 bit serial number by getting current date and
;	      time and then scrambling it around.
;
;Called Procedures: Message (macro)
;
;Change History&gml Created	   4/20/87	   MT
;
;Input&gml None
;
;Output&gml Media_ID_Buffer.Serial_Number = set
;	    AX,CX,DX destroyed
;	    Serial_Num_Low/High = Serial number generated
;
;Psuedocode
;----------
;
;	Get date (INT 21h, AH=2Bh)
;	Get time (INT 21h, AH=2Ch)
;	Serial_ID+0 = DX reg date + DX reg time
;	Serial_ID+2 = CX reg date + CX reg time
;	Serial_Num_Low = Serial_ID+2
;	Serial_Num_High = Serial_ID+0
;	ret
;*****************************************************************************

Procedure Create_Serial_ID

	DOS_Call Get_Date			;Get date from DOS
	push	cx				;Save results
	push	dx
	DOS_Call Get_Time			;Get_Time
	mov	ax,dx				;Scramble it
	pop	dx
	add	ax,dx
	mov	word ptr Media_ID_Buffer.Media_ID_Serial_Number+2,ax
	mov	Serial_Num_Low,ax
	mov	ax,cx
	pop	cx
	add	ax,cx
	mov	word ptr Media_ID_Buffer.Media_ID_Serial_Number,ax
	mov	Serial_Num_High,ax
	ret

Create_Serial_ID endp

;-------------------------------------------------------------------------------
;
; OemDone:
;
;-------------------------------------------------------------------------------

OemDone proc	near

; if /b write out a fake dos & bios
	test	switchmap, SWITCH_B
	jz	Switch8?
	call	WriteBogusDos
	retc

Switch8?:
	test	switchmap, SWITCH_8
	jz	HardDisk?
	call	ConvertToOldDirectoryFormat
	retc

HardDisk?:
	cmp	deviceParameters.DP_DeviceType, DEV_HARDDISK
	clc
	retnz
	call	SetPartitionTable

	return

OemDone endp

;------------------------------------------------------------------------------
; simple code to stuff bogus dos in old-style diskette.
;------------------------------------------------------------------------------

BogusDos:
	push	cs
	pop	ds
	mov	al,20h
	out	20h,al				; turn on the timer so the
	jmp	SHORT DelayJump 		; disk motor
						; shuts off
DelayJump:
	mov	si,mesofs

sys_mess_loop:
	lodsb

if ibmcopyright
end_sys_loop:
endif

	or	al,al
	jz	end_sys_loop
	mov	ah,14
	mov	bx,7
	int	16
	jmp	sys_mess_loop

if not ibmcopyright
end_sys_loop:
	xor	ah, ah				; get next char function
	int	16h				; call keyboard services
	int	19h				; reboot
endif

	include BOOT.CL1
mesofs	equ	sysmsg - BogusDos

; ===========================================================================

WriteBogusDos proc near

	mov	al,driveLetter
	mov	biosFile,al
	mov	dosFile,al
	mov	cx, ATTR_HIDDEN or ATTR_SYSTEM
	lea	dx, biosFile
	mov	ah,CREAT
	int	21h
	mov	bx,ax
	mov	cx, BIOS_SIZE
	push	ds
	push	cs
	pop	ds
	assume	ds:code
	lea	dx, BogusDos
	mov	ah,WRITE
	int	21h
	pop	ds
	assume	ds:data
	mov	ah,CLOSE
	int	21h
	mov	cx, ATTR_HIDDEN or ATTR_SYSTEM
	lea	dx, dosFile
	mov	ah,CREAT
	int	21h
	mov	bx,ax
	mov	cx, DOS_SIZE
	lea	dx, BogusDos
	mov	ah,WRITE
	int	21h
	mov	ah,CLOSE
	int	21h

			; Comunicate system size to the main format program

	mov	word ptr DOS.FileSizeInBytes,DOS_SIZE	;get size of DOS
	mov	word ptr DOS.FileSizeInBytes+2,00h

	xor	dx,dx
	mov	ax,DOS_SIZE
	call	AddToSystemSize

	mov	word ptr Bios.FileSizeInBytes,BIOS_SIZE ;get size of BIOS
	mov	word ptr Bios.FileSizeInBytes+2,00h

	xor	dx,dx
	mov	ax,BIOS_SIZE
	call	AddToSystemSize

	clc
	return

WriteBogusDos endp

;-----------------------------------------------------------------------------
; convert to 1.1 directory
;-----------------------------------------------------------------------------

ConvertToOldDirectoryFormat proc near


	mov	al,drive			; Get 1st sector of directory
	mov	cx,1				; 1.1 directory always starts
	mov	dx,3				; on sector 3
	lea	bx,scratchBuffer
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Read_Disk
	jnc	DirectoryRead

	Message msgDirectoryReadError
	stc
	ret

DirectoryRead:

					; fix attribute of ibmbio and ibmdos
	lea	bx,scratchBuffer
	mov	byte ptr [bx].dir_attr, ATTR_HIDDEN or ATTR_SYSTEM
	add	bx, size dir_entry
	mov	byte ptr [bx].dir_attr, ATTR_HIDDEN or ATTR_SYSTEM

wrtdir:
	mov	al,[drive]			; write out the directory
	cbw
	mov	cx,1
	mov	dx,3
	lea	bx,scratchBuffer
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Write_Disk
	jnc	DirectoryWritten
	Message msgDirectoryWriteError
	stc
	ret

DirectoryWritten:
	test	switchmap, SWITCH_S		; Was system requested?
	retnz					; yes, don't write old boot sec

	mov	al,drive
	cbw

	push	DI 				; Fix for old style disk
	push	SI				; we have to copy the
	push	ES				; BPB to the boot record

	mov	SI,DS
	mov	ES,SI

	mov	DI,offset boot2 + OFFSET_BPB	
	mov	SI,OFFSET deviceParameters.DP_BPB
	mov	CX,OLD_BPB_LEN
	rep	movsb

	pop	ES
	pop	SI
	pop	DI

	mov	bx,offset boot2 		; no,  write old boot sector
	cmp	deviceParameters.DP_BPB.BPB_Heads, 1
	je	bootset8
	mov	word ptr [bx+3],0103h		; start address for double
						; sided drives

bootset8:
	mov	cx,1
	xor	dx,dx
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Write_Disk
	retnc

	Message msgBootWriteError
	stc
	ret

ConvertToOldDirectoryFormat endp

;-------------------------------------------------------------------------------

a_PartitionTableEntry struc
BootInd 	db	?
BegHead 	db	?
BegSector	db	?
BegCylinder	db	?
SysInd		db	?
EndHead 	db	?
EndSector	db	?
EndCylinder	db	?
RelSec		dd	?
CSec		dd	?
a_PartitionTableEntry ends

;-------------------------------------------------------------------------------

; structure of the IBM hard disk boot sector:
IBMBoot STRUC
	db	512 - (4*size a_PartitionTableEntry + 2) dup(?)
PartitionTable db 4*size a_PartitionTableEntry dup(?)
Signature dw	?
IBMBoot ENDS


;*****************************************************************************
;Routine name: SetPartitionTable
;*****************************************************************************
;
;Description: Find location for DOS partition in partition table, get the
;	      correct system indicator byte, and write it out. If can not
;	      read/write boot record or can't find DOS partition, display
;	      error
;
;Called Procedures: Message (macro)
;		    Determine_Partition_Type
;		    ReadSector
;		    WriteSector
;
;Change History: Created	4/20/87 	MT
;
;Input: None
;
;Output: CY set if error
;
;Psuedocode
;----------
;
;	Read the partition table (Call ReadSector)
;	IF ok
;	   IF boot signature of 55AAh
;	       Point at system partition table
;	       SEARCH
;		  Assume DOS found
;		  IF System_Indicator <> 1,AND
;		  IF System_Indicator <> 4,AND
;		  IF System_Indicator <> 6
;		    STC   (DOS not found)
;		  ELSE
;		    CLC
;		  ENDIF
;	       EXITIF DOS found (CLC)
;		  CALL Determine_Partition_Type
;		  Write the partition table (CALL WriteSector)
;		  IF error
;		     Display boot write error message
;		     stc
;		  ELSE
;		     clc
;		  ENDIF
;	       ORELSE
;		  Point at next partition entry (add 16 to partition table ptr)
;	       ENDLOOP if checked all 4 partition entries
;		  Display Bad partition table message
;		  stc
;	       ENDSRCH
;	   ELSE invalid boot record
;	      Display Bad partition table message
;	      stc
;	   ENDIF
;	ELSE error
;	   Display Partition table error
;	   stc
;	ENDIF
;	ret
;*****************************************************************************

Procedure SetPartitionTable

	xor	ax, ax				;Head
	xor	bx, bx				;Cylinder
	xor	cx, cx				;Sector
	lea	dx, boot2			;Never use 1.x boot on hardfile
	call	ReadSector			;this will use space as buffer
	JC	$$IF70				;If read okay

	cmp	Boot2.Boot_Signature,Boot_ID
	JNE	$$IF71				;Does signature match?

	lea	bx, boot2.PartitionTable	;Yes, point at partition table

$$DO72: 					;Look for DOS partition
	cmp	[bx].sysind,FAT12_File_System
	JE	$$IF73

	cmp	[bx].sysind,FAT16_File_System
	JE	$$IF73

	cmp	[bx].sysind,New_File_System
	JE	$$IF73

	stc					;We didn't find partition
	JMP	SHORT $$EN73

$$IF73:
	clc					;Indicate found partition

$$EN73:
	JC	$$IF72				;Get correct id for it

	CALL	Determine_Partition_Type
	mov	ax, 0				;Head
	mov	bx, 0				;Cylinder
	mov	cx, 0				;Sector
	lea	dx, boot2			;
	call	WriteSector			;Write out partition table
	JNC	$$IF77				;Error writing boot record

	MESSAGE msgPartitionTableWriteError
	stc					;Set CY to indicate error
	JMP	SHORT $$EN77

$$IF77:
	clc					;No error means no CY

$$EN77:
	JMP	SHORT $$SR72

$$IF72:
	add	bx,size a_PartitionTableEntry
	cmp	bx,(offset Boot2.PartitionTable)+4*size a_PartitionTableEntry
	JMP	SHORT $$DO72			;Checked all 4 partition entries

;*** No way to get to this code

	MESSAGE msgBadPartitionTable		;Tell user bad table
	stc					;Set CY for exit

$$SR72:
	JMP	SHORT $$EN71			;Invalid boot record

$$IF71:
	MESSAGE msgBadPartitionTable
	stc					;Set CY for error return

$$EN71:
	JMP	SHORT $$EN70			;Couldn't read boot record

$$IF70:
	MESSAGE msgPartitionTableReadError
	stc					;Set CY for error return

$$EN70:
	ret

SetPartitionTable endp

;*****************************************************************************
;Routine name: Determine_Partition_Type
;*****************************************************************************
;
;DescriptioN: Set the system indicator field to its correct value as
;	      determined by the following rules:
;
;	     - Set SysInd = 01h if partition or logical drive size is < 10mb
;	       and completely contained within the first 32mb of DASD.
;	     - Set SysInd = 04h if partition or logical drive size is >10mb,
;	       <32mb, and completely contained within the first 32mb of DASD
;	     - Set SysInd to 06h if partition or logical drive size is > 32mb,
;
;Called Procedures: Message (macro)
;
;Change History: Created	3/18/87 	MT
;
;Input: BX has offset of partition table entry
;	fBigFAT = TRUE if 16bit FAT
;
;Output: BX.SysInd = correct partition system indicator value (1,4,6)
;
;Psuedocode
;----------
;	Add partition start location to length of partition
;	IF end > 32mb
;	   BX.SysInd = 6
;	ELSE
;	   IF fBigFat
;	      BX.SysInd = 4
;	   ELSE
;	      BX.SysInd = 1
;	   ENDIF
;	ret
;*****************************************************************************

Procedure Determine_Partition_Type

	mov	dx,word ptr [bx].Csec+2 	; Get high word of sector count
	cmp	dx,0				; > 32Mb?
	JE	$$IF87

	mov	[BX].SysInd,New_File_System	; type 6
	JMP	SHORT $$EN87

$$IF87:
	call	Calc_Total_Sectors_For_Partition ;returns DX:AX total sectors
	cmp	DeviceParameters.DP_BPB.BPB_HiddenSectors[+2],0  ;> 32Mb?
	JE	$$IF89				; yes

	mov	[bx].SysInd,New_File_System	; type 6
	JMP	SHORT $$EN89

$$IF89:
	cmp	dx,0				; partition > 32 Mb?
	JE	$$IF91				; yes
	mov	[bx].SysInd,New_File_System	; type 6
	JMP	SHORT $$EN91			; < 32 Mb partition
$$IF91:
	cmp	fBigFat,True			; 16 bit FAT
	JNE	$$IF93				; yes

	mov	[BX].SysInd,FAT16_File_System	; type 4
	JMP	SHORT $$EN93			; 12 bit FAT
$$IF93:
	mov	[bx].SysInd,FAT12_File_System	; type 1
$$EN93:
$$EN91:
$$EN89:
$$EN87:
	ret

Determine_Partition_Type endp


;=========================================================================
; Calc_Total_Sectors_For_Partition	: This routine determines the
;					  total number of sectors within
;					  this partition.
;
;	Inputs	: DeviceParameters
;
;	Outputs : DX:AX - Double word partition size
;=========================================================================

Procedure Calc_Total_Sectors_For_Partition

	mov	ax,word ptr DeviceParameters.DP_BPB.BPB_HiddenSectors[0]
	mov	dx,word ptr DeviceParameters.DP_BPB.BPB_HiddenSectors[2]
	cmp	DeviceParameters.DP_BPB.BPB_TotalSectors,0 ; extended BPB?
	JNE	$$IF99			; yes

	add	ax,word ptr DeviceParameters.DP_BPB.BPB_BigTotalSectors[0]
	adc	dx,0			; pick up carry if any

	add	dx,word ptr DeviceParameters.DP_BPB.BPB_BigTotalSectors[2]
	JMP	SHORT $$EN99		; standard BPB

$$IF99:
	add	ax,word ptr DeviceParameters.DP_BPB.BPB_TotalSectors
	adc	dx,0			; pick up carry if any

$$EN99:
	ret

Calc_Total_Sectors_For_Partition	endp


;-------------------------------------------------------------------------------
; ReadSector:
;    Read one sector
;
;    Input:
;	ax - head
;	bx - cylinder
;	cx - sector
;	dx - transfer address

ReadSector proc near

	mov	TrackReadWritePacket.TRWP_FirstSector, cx
	mov	cx,(RAWIO shl 8) or READ_TRACK
	call	SectorIO
	return

ReadSector endp

;-------------------------------------------------------------------------------
; WriteSector:
;    Write one sector
;
;    Input:
;	ax - head
;	bx - cylinder
;	cx - sector
;	dx - transfer address

WriteSector proc near

	mov	TrackReadWritePacket.TRWP_FirstSector, cx
	mov	cx,(RAWIO shl 8) or WRITE_TRACK
	call	SectorIO
	return

WriteSector endp

;-------------------------------------------------------------------------------
; SectorIO:
;    Read/Write one sector
;
;    Input:
;	ax - head
;	bx - cylinder
;	cx - (RAWIO shl 8) or READ_TRACK
;	   - (RAWIO shl 8) or WRITE_TRACK
;	dx - transfer address

SectorIO proc	near

	mov	TrackReadWritePacket.TRWP_Head, ax
	mov	TrackReadWritePacket.TRWP_Cylinder, bx
	mov	WORD PTR TrackReadWritePacket.TRWP_TransferAddress, dx
	mov	WORD PTR TrackReadWritePacket.TRWP_TransferAddress + 2, ds
	mov	TrackReadWritePacket.TRWP_SectorsToReadWrite, 1

	mov	bl, drive
	inc	bl
	mov	ax, (IOCTL shl 8) or GENERIC_IOCTL
	lea	dx, trackReadWritePacket
	int	21H
	return

SectorIO endp

; ==========================================================================

data	segment public	para	'DATA'

oldDrive db	?

FCBforVolumeIdSearch db 0ffH
	db	5 dup(0)
	db	08H
	db	0
	db	"???????????"
	db	40 DUP(0)

data	ends

; ==========================================================================

GetVolumeId proc near
; Input:
;    dl = drive
;    di = name buffer

; Save current drive
	mov	ah,19H
	int	21H
	mov	oldDrive, al

; Change current drive to the drive that has the volume id we want
	mov	ah, 0eH
	int	21H

; Search for the volume id
	mov	ah, 11H
	lea	dx, FCBforVolumeIdSearch
	int	21H
	push	ax

; Restore current drive
	mov	ah, 0eH
	mov	dl,oldDrive
	int	21H

; Did the search succeed?
	pop	ax
	or	al,al
	jz	CopyVolumeId
	stc
	ret

CopyVolumeId:
		; Find out where the FCB for the located volume id was put
	mov	ah,2fH
	int	21H

; Copy the Volume Id
	mov	si, bx
	add	si, 8
	push	es
	push	ds
	pop	es
	pop	ds
	mov	cx, 11
	rep	movsb
	push	es
	pop	ds

	clc
	ret

GetVolumeId endp

; ==========================================================================

data	segment public	para	'DATA'
oldVolumeId db	11 dup(0)
data	ends

; ==========================================================================

CheckVolumeId proc near

; Get the volume id that's on the disk
	lea	di, oldVolumeId
	mov	dl, drive
	call	GetVolumeId
;	jnc	Ask_User			;M008; Did we find one?
						;M008; we may still need to get it
	clc					;No, return with no error
	ret

; M008 - begin
; Ask the user to enter the volume id that he/she thinks is on the disk
; (first blank out the input buffer)
;
;Ask_User:
;
;
;	Message msgWhatIsVolumeId?
;
;	call	user_string
;	call	crlf
;
; If the user just pressed ENTER, then there must be no label
;
;	cmp	inbuff+1, 0
;	jne	CompareVolumeIds
;	cmp	oldVolumeId, 0
;	jne	BadVolumeId
;	ret
;
;CompareVolumeIds:
;
;		; pad the reponse with blanks
;		; The buffer is big enough so just add 11 blanks to what
;		; the user typed in
;
;	push	ds
;	pop	es
;	mov	cx, Label_Length
;	xor	bx,bx
;	mov	bl, inbuff + 1
;	lea	di, inbuff + 2
;	add	di, bx
;	mov	al, ' '
;	rep	stosb
;
;		; Make the reply all uppercase
;
;	mov	byte ptr Inbuff+2+Label_Length,ASCIIZ_End ;Make string ASCIIZ
;	mov	dx, offset inbuff + 2		;Start of buffer
;	mov	al,22h				;Capitalize asciiz
;	DOS_Call GetExtCntry			;Do it
;
;		; Now compare what the user specified with what is
;		; really out there
;
;	mov	cx, Label_Length
;	lea	si, inbuff + 2
;	lea	di, oldVolumeId
;	repe	cmpsb
;	jne	BadVolumeId
;	ret
;
;BadVolumeId:
;	Message msgBadVolumeID
;	stc
;	ret
;
; M008 - end

CheckVolumeId endp


; ==========================================================================

CheckSwitch8B	proc	near

	test	SwitchMap, SWITCH_B		;/8/B <> /V because
	JZ	$$IF102 			; old directory type

	test	SwitchMap, Switch_8		; used which didn't support
	JZ	$$IF102 			; volume labels.

	test	SwitchMap, SWITCH_V
	JZ	$$IF102

	Message msgBad_8_V			; Tell user
	mov	Fatal_Error,Yes			; Bad stuff
	JMP	SHORT $$EN102			; No problem so far

$$IF102:
	test	SwitchMap, Switch_B		; Can't reserve space and
	JZ	$$IF104 			; install sys files at the

	test	SwitchMap, Switch_S		; same time.
	JZ	$$IF104 			; No /S/B

	Message msgIncompatibleParameters ;Tell user
	mov	Fatal_Error,Yes	;Bad stuff
	JMP	SHORT $$EN104			;Still okay

$$IF104:
	test	SwitchMap,Switch_1		;/1/8/4 not okay with /N/T
	JNZ	$$LL106

	test	SwitchMap,Switch_8
	JNZ	$$LL106

	test	SwitchMap,Switch_4
	JZ	$$IF106

$$LL106:
	test	SwitchMap,(Switch_T or Switch_N)
	JZ	$$IF107 			;Found /T/N <> /1/8
	Message msgIncompatibleParameters	;Tell user
	mov	Fatal_Error,Yes 		;Bad stuff
	JMP	SHORT $$EN107

$$IF107:
	test	SwitchMap,Switch_V
	JZ	$$IF109
	test	SwitchMap,Switch_8
	JZ	$$IF109

	Message msgBad_8_V
	mov	Fatal_Error,Yes

$$IF109:
$$EN107:
$$IF106:
$$EN104:
$$EN102:
	 ret

CheckSwitch8B	endp

; ==========================================================================

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\format\switch_s.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
;
; FILE: .ASM
;
;===========================================================================

;===========================================================================
;Declaration of include files
;===========================================================================
debug	 equ	 0
	 .xlist
;	 INCLUDE VERSION.INC
;	 INCLUDE VERSIONA.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
;	 INCLUDE DPB.INC
;	 INCLUDE CPMFCB.INC
	 INCLUDE DIRENT.INC
;	 INCLUDE CURDIR.INC
;	 INCLUDE PDB.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
;	 INCLUDE IOCTL.INC
;	 INCLUDE FORSWTCH.INC
	 .list
;
;---------------------------------------------------------------------------
;
; M029 : Remove the assumption that COMSPEC= has an absolute path name.
;	  and build the file name (COMMAND.COM) in a different buffer
;	  other than the buffer in which COMSPEC was stored.
;
;---------------------------------------------------------------------------
;

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Bytes
	EXTRN	DriveLetter		:BYTE
	EXTRN	SystemDriveLetter	:BYTE
	EXTRN	Extended_Error_Msg	:BYTE
	EXTRN	BiosFile		:BYTE
	EXTRN	DosFile			:BYTE
;	EXTRN	NeedSysDisk		:BYTE
IFDEF DBLSPACE_HOOKS
	EXTRN	fDblSpace		:BYTE
ENDIF

;Words
	EXTRN	mStart			:WORD
	EXTRN	mSize			:WORD
	EXTRN	Environ_Segment 	:WORD
	EXTRN	PSP_Segment		:WORD

;Pointers

;Functions
	EXTRN	SysPrm			:NEAR
	EXTRN	TargPrm			:NEAR
	EXTRN	Get_PSP_Parms		:NEAR
	EXTRN	Cap_Char		:NEAR

;Labels
	EXTRN	FatalExit		:NEAR
	EXTRN	Find_Path_In_Environment:NEAR
	EXTRN	Path_Crunch		:NEAR
	EXTRN	Search			:NEAR

;Structures
	EXTRN	Bios			:BYTE
	EXTRN	dos			:BYTE
	EXTRN	command 		:BYTE
IFDEF DBLSPACE_HOOKS
	EXTRN	DblSpaceBin		:BYTE
ENDIF

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

BiosAttributes		equ	attr_hidden + attr_system + attr_read_only
DosAttributes		equ	attr_hidden + attr_system + attr_read_only

IFDEF DBLSPACE_HOOKS
DblSpaceAttributes	equ	attr_hidden + attr_system + attr_read_only
ENDIF

CommandAttributes	equ	0

CommandFile		db	"X:\COMMAND.COM",0
			db	(128 - 15) DUP (0)	; M012

Comspec_ID		db	 "COMSPEC=",00	 ; Comspec target
FileStat		db	?	; In memory Status of files
					; XXXXXX00B BIOS not in
					; XXXXXX01B BIOS partly in
					; XXXXXX10B BIOS all in
					; XXXX00XXB DOS not in
					; XXXX01XXB DOS partly	in
					; XXXX10XXB DOS all in
					; XX00XXXXB COMMAND not in
					; XX01XXXXB COMMAND partly in
					; XX10XXXXB COMMAND all in

Command_Com		DB	"X:\COMMAND.COM",0			; M029


IFDEF DBLSPACE_HOOKS
DblSpaceFile		db	"X:\DBLSPACE.BIN",0 ;full path to source copy
			db	64 DUP (0)	    ;  of dblspace.bin

DblSpaceTargetName	db	"X:\"             ;target dblspace.bin name
DblSpaceBase		db	"DBLSPACE.BIN",0  ;base name used to srch PATH
ENDIF


DOS_BUFFER		db	45 dup (?)	; Find First/Next buffer

TempHandle		dw	?

IOCNT			dd	?

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA


;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	ReadDos
	PUBLIC	WriteDos
	PUBLIC	CommandFile

IFDEF DBLSPACE_HOOKS
	PUBLIC	DblSpaceFile
ENDIF

	PUBLIC	FileStat

; ==========================================================================
; Copy IO.SYS, MSDOS.SYS, COMMAND.COM, and DBLSPACE.BIN (if present) into
; data area.
; Carry set if	problems
; M011; SystemDriveLetter=Drive to Try
; ==========================================================================

ReadDos:
;M011 - begin
	xor	ax, ax
	mov	Bios.FileSizeInParagraphs, ax	; Initialize file sizes
	mov	Dos.FileSizeInParagraphs, ax
	mov	Command.FileSizeInParagraphs, ax
IFDEF DBLSPACE_HOOKS
	mov	DblSpaceBin.FileSizeInParagraphs, ax
ENDIF
	mov	AL,SystemDriveLetter
	mov	[BiosFile],AL			; Stuff it in file specs.
	mov	[DosFile],AL
	mov	[CommandFile],AL
IFDEF DBLSPACE_HOOKS
	mov	[DblSpaceFile], al
ENDIF

	call	Get_Bios
	jnc	RdFils
;M011 - end
	return

RdFils:
	mov	BYTE PTR [FileStat],0
	mov	BX,[Bios.fileHandle]
	mov	AX,[mStart]
	mov	DX,AX
	add	DX,[mSize]			; CX first bad para
	mov	[Bios.fileStartSegment],AX
	mov	CX,[Bios.fileSizeInParagraphs]
	add	AX,CX
	cmp	AX,DX
	jbe	GotBios

	mov	BYTE PTR [FileStat],00000001B	; Got part of Bios
	mov	SI,[mSize]
	xor	DI,DI
	call	DISIX4

	push	DS
	mov	DS,[Bios.fileStartSegment]

	assume	DS:NOTHING
	call	ReadFile
	pop	DS

	assume	DS:data
	jc	ClsAll
	xor	DX,DX
	mov	CX,DX
	mov	AX,(LSEEK shl 8) OR 1
	int	21H
	mov	WORD PTR [Bios.fileOffset],AX
	mov	WORD PTR [Bios.fileOffset+2],DX

FilesDone:
	clc

ClsAll:
	pushF
	call	FILE_CLS
	popF
	return

; ==========================================================================

GotBios:
	mov	BYTE PTR [FileStat],00000010B	; Got all of Bios
	push	ES
	les	SI,[Bios.fileSizeInBytes]
	mov	DI,ES
	pop	ES
	push	DS
	mov	DS,[Bios.fileStartSegment]

	assume	DS:nothing
	call	ReadFile
	pop	DS

	assume	DS:data
	jc	ClsAll

	push	AX
	push	DX
	call	File_Cls
	call	Get_DOS
	pop	DX
	pop	AX

	jnc	Found_IBMDOS
	return

; ==========================================================================

Found_IBMDOS:

	mov	BX,[dos.fileHandle]
	mov	[dos.fileStartSegment],AX
	cmp	AX,DX				 ; No room left?
	jz	ClsAll				 ; Yes
	mov	CX,[dos.fileSizeInParagraphs]
	add	AX,CX
	cmp	AX,DX
	jbe	GotDos

	or	BYTE PTR [FileStat],00000100B	 ; Got part of DOS
	sub	DX,[dos.fileStartSegment]
	mov	SI,DX
	xor	DI,DI
	call	DISIX4
	push	DS
	mov	DS,[dos.fileStartSegment]

	assume	DS:nothing
	call	ReadFile
	pop	DS

	assume	DS:data
	jc	ClsAll

	xor	DX,DX
	mov	CX,DX
	mov	AX,(LSEEK shl 8) OR 1
	int	21H
	mov	WORD PTR [dos.fileOffset],AX
	mov	WORD PTR [dos.fileOffset+2],DX
	jmp	FilesDone

GotDos:
	or	BYTE PTR [FileStat],00001000B	 ; Got all of DOS
	push	ES
	les	SI,[dos.fileSizeInBytes]
	mov	DI,ES
	pop	ES
	push	DS
	mov	DS,[dos.fileStartSegment]

	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data

ClsAllJ:
	jnc	notClsAll
	jmp	ClsAll

NotClsAll:
	push	AX
	push	DX
	call	File_cls
	call	Get_Command_Path		; get path of COMMAND.COM
	call	Get_Command			; Point to COMMAND and read it
	pop	DX
	pop	AX
	jnc	Found_Command

	return

;  ==========================================================================

Found_COMMAND:
	mov	BX,[command.fileHandle]
	mov	[command.fileStartSegment],AX
	cmp	AX,DX				; No room left?
	jz	ClsAllJ				; Yes

	mov	CX,[command.fileSizeInParagraphs]
	add	AX,CX
	cmp	AX,DX
	jbe	GotCom

	or	BYTE PTR [FileStat],00010000B	; Got part of COMMAND
	sub	DX,[command.fileStartSegment]
	mov	SI,DX
	xor	DI,DI
	call	DISIX4
	push	DS
	mov	DS,[command.fileStartSegment]
	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data
	jc	ClsAllJ

	xor	DX,DX
	mov	CX,DX
	mov	AX,(LSEEK shl 8) OR 1
	int	21h
	mov	WORD PTR [command.fileOffset],AX
	mov	WORD PTR [command.fileOffset+2],DX
	jmp	FilesDone

GotCom:
	or	BYTE PTR [FileStat],00100000B	; Got all of COMMAND
	push	ES
	les	SI,[command.fileSizeInBytes]
	mov	DI,ES
	pop	ES
	push	DS
	mov	DS,[command.fileStartSegment]
	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data
	jc	ClsAllJ



IFDEF DBLSPACE_HOOKS

	; Attempt to locate dblspace.bin

	push	ax
	push	dx
	call	File_cls			; close COMMAND.COM
	call	Get_DblSpace
	pop	dx
	pop	ax
	jnc	Found_DblSpace

	; DblSpace.bin is nowhere to be found!	This isn't fatal, clear
	; carry and return.

	clc
	return

;  ==========================================================================

	; DblSpace.bin has been located, will it fit in memory?
	; AX has next free location in memory buffer, DX has
	; (just past) end of buffer address.

Found_DblSpace:
	mov	bx, [DblSpaceBin.fileHandle]
	mov	[DblSpaceBin.fileStartSegment], ax

	cmp	ax, dx				; any room left?
	jz	ClsAllJ2			; no!

	mov	cx, [DblSpaceBin.fileSizeInParagraphs]
	add	ax, cx
	cmp	ax, dx
	jbe	GotDblSpace

ClsAllJ2:					; insufficient memory, skip
	jmp	ClsAll				;   dblspace.bin (CY is clear)

GotDblSpace:
	mov	[fDblSpace], TRUE				; got it!
	mov	si, word ptr [DblSpaceBin.fileSizeInBytes]
	mov	di, word ptr [DblSpaceBin.fileSizeInBytes+2]	; di:si = size
	push	ds
	mov	ds, [DblSpaceBin.fileStartSegment]		; ds:0 = addr
	assume	ds:nothing
	call	ReadFile					; load it
	pop	ds
	assume	ds:data

ENDIF



	jmp	ClsAll

; ==========================================================================
; Write	Bios DOS COMMAND to the	newly formatted	disk.
; ==========================================================================

	ASSUME	 DS:DATA

WriteDos:
	 mov	 CX,BiosAttributes
	 mov	 DX,OFFSET BiosFile		; DS:DX --> ASCIIZ pathname
	 push	 ES
	 les	 SI,[Bios.fileSizeInBytes]
	 mov	 DI,ES				; DI:SI is file size
	 pop	 ES
	 call	 MakeFil			; create & open file in dest. drive
	 retc

	 mov	 [TempHandle],BX		; save file handle
	 test	 BYTE PTR FileStat,00000010B	; is BIOS all in already?
	 jnz	 GotAllBio			; yes, write it out
	 call	 Get_Bios			; no, read it in
	 jnc	 Got_WBios			; check for error
	 ret

; ==========================================================================

Got_WBios:

	 push	 ES
	 LES	 SI,[Bios.fileOffset]
	 mov	 DI,ES				; DI:SI is file pointer
	 pop	 ES
	 mov	 WORD PTR [IOCNT],SI
	 mov	 WORD PTR [IOCNT+2],DI
	 mov	 BP,OFFSET Bios			; BP --> parameter block for BIOS file
	 call	 GotTArg
	 retc
	 jmp	 SHORT BiosDone

GotAllBio:
	 push	 ES
	 LES	 SI,[Bios.fileSizeInBytes]
	 mov	 DI,ES				; DI:SI is BIOS file size
	 pop	 ES
	 push	 DS
	 mov	 DS,[Bios.fileStartSegment]	; DS:0 --> start of BIOS in memory
	 assume	 DS:nothing
	 call	 WriteFile			; write BIOS to disk
	 pop	 DS
	 assume	 DS:data
BiosDone:
	 mov	 BX,[TempHandle]
	 mov	 CX,Bios.fileTime
	 mov	 DX,Bios.fileDate
	 call	 ClosetArg			; close BIOS file on target disk
	 mov	 CX,DosAttributes
	 mov	 DX,OFFSET DosFile		; DS:DX --> ASCIIZ pathname
	 push	 ES
	 LES	 SI,[dos.fileSizeInBytes]
	 mov	 DI,ES
	 pop	 ES
	 call	 MakeFil			; create & open DOS file in dest. disk
	 retc

GotNdos:
	 mov	 [TempHandle],BX		; save file handle
	 test	 BYTE PTR FileStat,00001000B	; is DOS already all in memory?
	 jnz	 GotAllDos			; yes
	 call	 Get_DOS			; no, read it in
	 jnc	 Got_WDOS			; check for error
	 ret

Got_WDOS:
	 mov	 BP,OFFSET dos			; BP --> parameter block for DOS file
	 test	 BYTE PTR FileStat,00000100B	; is DOS file partly in?
	 jnz	 PartDos			; yes
	 mov	 WORD PTR [dos.fileOffset],0	; no, not in at all
	 mov	 WORD PTR [dos.fileOffset+2],0
	 call	 GETSYS3
	 retc
	 jmp	 SHORT DosDone

PartDos:
	 push	 ES				; DOS is partly in memory
	 LES	 SI,[dos.fileOffset]
	 mov	 DI,ES
	 pop	 ES
	 mov	 WORD PTR [IOCNT],SI		; IOCNT = size already in memory
	 mov	 WORD PTR [IOCNT+2],DI
	 call	 GotTArg
	 retc
	 jmp	 SHORT DosDone

GotAllDos:
	 push	 ES
	 LES	 SI,[dos.fileSizeInBytes]
	 mov	 DI,ES
	 pop	 ES
	 push	 DS
	 mov	 DS,[dos.fileStartSegment]
	 assume	 DS:nothing
	 call	 WriteFile
	 pop	 DS
	 assume	 DS:data
DosDone:
	 mov	 BX,[TempHandle]
	 mov	 CX,dos.fileTime
	 mov	 DX,dos.fileDate
	 call	 ClosetArg
	 mov	 CX,CommandAttributes

;M029	 call	 Command_Root			 ;adjust path for
;M029						 ;COMMAND.COM creation

	 mov	 DX,OFFSET Command_Com		 ; M029
	 push	 ES
	 les	 SI,[command.fileSizeInBytes]
	 mov	 DI,ES
	 pop	 ES
	 call	 MakeFil
	 retc

	 mov	 [TempHandle],BX
	 test	 BYTE PTR FileStat,00100000B
	 jnz	 GotAllCom
	 call	 Get_COMMAND
	 jnc	 Got_WCOM
	 ret

Got_WCOM:
	 mov	 BP,OFFSET command		; BP --> parameter block for COMMAND file
	 test	 BYTE PTR FileStat,00010000B
	 jnz	 PartCom
	 mov	 WORD PTR [command.fileOffset],0
	 mov	 WORD PTR [command.fileOffset+2],0
	 call	 GETSYS3
	 retc
	 jmp	 SHORT ComDone

PartCom:
	 push	 ES
	 LES	 SI,[command.fileOffset]
	 mov	 DI,ES
	 pop	 ES
	 mov	 WORD PTR [IOCNT],SI
	 mov	 WORD PTR [IOCNT+2],DI
	 call	 GotTArg
	 retc
	 jmp	 SHORT ComDone

GotAllCom:
	 push	 ES
	 les	 SI,[command.fileSizeInBytes]
	 mov	 DI,ES
	 pop	 ES
	 push	 DS
	 mov	 DS,[command.fileStartSegment]
	 assume	 DS:nothing
	 call	 WriteFile
	 pop	 DS
	 assume	 DS:data
ComDone:
	 mov	 BX,[TempHandle]
	 mov	 CX,command.fileTime
	 mov	 DX,command.fileDate
	 call	 ClosetArg



IFDEF DBLSPACE_HOOKS

	; Write dblspace.bin to target disk if it was located and loaded
	; into memory.

	cmp	[fDblSpace], TRUE			;Have it?
	jne	WriteDosDone				;  no...

	mov	cx, DblSpaceAttributes			;Create file on
	mov	dx, offset DblSpaceTargetName		;  target disk
	mov	si, word ptr [DblSpaceBin.fileSizeInBytes]
	mov	di, word ptr [DblSpaceBin.fileSizeInBytes+2]
	call	MakeFil
	retc

	mov	[TempHandle], bx

	mov	si, word ptr [DblSpaceBin.fileSizeInBytes]
	mov	di, word ptr [DblSpaceBin.fileSizeInBytes+2]
	push	ds
	mov	ds, [DblSpaceBin.fileStartSegment]
	assume	ds:nothing
	call	WriteFile			;Write dblspace.bin image
	pop	ds
	assume	ds:data

	mov	bx, [TempHandle]		;Set time/date, close
	mov	cx, [DblSpaceBin.fileTime]	;  DblSpace.bin
	mov	dx, [DblSpaceBin.fileDate]
	call	ClosetArg

WriteDosDone:

ENDIF



; ==========================================================================
; I don't see the need	for the	following code!! - RS 3.20
;	 cmp	 BYTE PTR [FileStat],00101010B
;	 jz	 NOREDOS
;RdFrst2:
;	 call	 Readdos		 ; Start back with Bios
;	 jnc	 NOREDOS
;	 call	 SysPrm			 ;Prompt for system disk
;	 jmp	 RdFrst2		 ;Try again
;NOREDOS:
; ==========================================================================
	 clc
	 return

; ==========================================================================
; Create a file on target disk
; CX =	attributes, DX points to name
; DI:SI is size file is to have
;
;   There is a	bug in DOS 2.00	and 2.01 having	to do with writes
;   from the end of memory. In	order to circumvent it this routine
;   must create files with the	length in DI:SI
;
; On return BX	is handle, carry set if	problem
; ==========================================================================

MakeFil:
	 mov	 BX,DX				; BX --> ASCIIZ pathname
	 push	 WORD PTR [BX]			; save drive letter in pathname
	 mov	 AL,DriveLetter
	 mov	 [BX],AL			; set new drive letter in pathname
	 mov	 AH,CREAT
	 int	 21H				; create the file on disk
	 pop	 WORD PTR [BX]			; restore original drive letter in pathname
	 mov	 BX,AX				; save handle in BX
	 jc	 CheckMany
	 mov	 CX,DI
	 mov	 DX,SI				; CX:DX is size of file
	 mov	 AX,LSEEK shl 8
	 int	 21H				 ; Seek	to eventual EOF
	 xor	 CX,CX
	 mov	 AH,WRITE
	 int	 21H				 ; Set size of file to position
	 xor	 CX,CX
	 mov	 DX,CX
	 mov	 AX,LSEEK shl 8
	 int	 21H				 ; Seek	back to	start
	 return

; ==========================================================================
; Examine error code in AX to see if it is too-many-open-files.
; If it is, we	abort right here. Otherwise we return.
; ==========================================================================

CheckMany:
	 cmp	 AX,error_too_many_open_files
	 retnz
	 Extended_Message
	 jmp	 FatalExit

;*********************************************
; Close a file	on the target disk
; CX/DX is time/date, BX is handle

ClosetArg:
	 mov	 AX,(FILE_TIMES	shl 8) OR 1
	 int	 21H
	 mov	 AH,CLOSE
	 int	 21H
	 return

;****************************************
; Transfer system files
; BP points to	data structure for file	involved
; offset is set to current amount read	in
; Start set to	start of file in buffer
; TempHandle is handle	to write to on target

IoLoop:
	 mov	 AL,[SystemDriveLetter]
	 cmp	 AL,[DriveLetter]
	 jnz	 GotTArg
	 mov	 AH,DISK_RESET
	 int	 21H
	 call	 TargPrm			 ;Get target disk


; ==========================================================================
; Enter	here if	some of	file is	already	in buffer, IOCNT must be set
; to size already in buffer.
; ==========================================================================

	ASSUME	 DS:DATA
GotTArg:
	 mov	 BX,[TempHandle]
	 mov	 SI,WORD PTR [IOCNT]
	 mov	 DI,WORD PTR [IOCNT+2]
	 push	 DS
	 mov	 DS,DS:[BP.fileStartSegment]
	 assume	 DS:nothing
	 call	 WriteFile			 ; Write next part
	 pop	 DS
	 assume	 DS:data
	 retc

	 push	 ES
	 LES	 AX,DS:[BP.fileOffset]
	 cmp	 AX,WORD PTR DS:[BP.fileSizeInBytes]	; has all the file been written?
	 jnz	 GETSYS3				; no, read rest in
	 mov	 AX,ES
	 cmp	 AX,WORD PTR DS:[BP.fileSizeInBytes+2]
	 jnz	 GETSYS3
	 pop	 ES
	 return					 ; Carry clear from cmp

GETSYS3:

; ==========================================================================
; Enter	here if	none of	file is	in buffer
; (or none of what remains to be written is in buffer)
; ==========================================================================
	pop	ES
	mov	AH,DISK_RESET
	int	21H
	mov	AX,[mStart]			; Furthur IO done start here
	mov	DS:[BP.fileStartSegment],AX	; point	to start of buffer
	mov	AL,[SystemDriveLetter]		; see if we have system	disk
	cmp	AL,[DriveLetter]
	jnz	TestSys
gSys:
				; Need to prompt for system disk
;	call 	File_Cls			;SA; close file that was opened
	mov	AH,DISK_RESET
	int	21H
	call	SysPrm				; Prompt for system disk
;	inc	NeedSysDisk			;SA;signal need for sys disk
;	stc					;SA;force return to caller
;	ret					;SA;handle SysPrm in WriteSysFiles

TestSys:
;	call	TestSysDISK
	jc	gSys				; repeat prompt if needed
	mov	BX,WORD PTR DS:[BP.fileHandle]	; CS over ARR 2.30
	push	ES
	LES	DX,dWORD PTR DS:[BP.fileOffset] ; CS over ARR 2.30
	mov	CX,ES				; CX:DX = required offset in file
	pop	ES
	push	DX
	mov	AX,LSEEK shl 8
	int	21H
	pop	DX
	push	ES
	LES	SI,dWORD PTR DS:[BP.fileSizeInBytes] ; CS over
	mov	DI,ES				; put high word	in di
	pop	ES
	SUB	SI,DX				; get low word value
	SBB	DI,CX				; DI:SI is #bytes to go
	push	DI
	push	SI
	add	SI,15				; round	up 1 para
	ADC	DI,0				; pick up carry
	call	DISID4				; div 16 to get	para count
	mov	AX,SI				; put para count in AX
	pop	SI				; restore bytes	remaining
	pop	DI				; restore bytes	remaining
	cmp	AX,[mSize]			; enough memory	for remainder?
	jbe	GOTSIZ2			 	; yes
	mov	SI,[mSize]
	xor	DI,DI
	call	DISIX4
GOTSIZ2:
	mov	WORD PTR [IOCNT],SI		; save byte count for read
	mov	WORD PTR [IOCNT+2],DI
	push	DS
	mov	DS,[mStart]
	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data
	jnc	GetOffs
	call	ClsAll
	jmp	gSys
GetOffs:
	xor	DX,DX				; clear	DX
	mov	CX,DX				; clear	CX
	mov	AX,(LSEEK shl 8) OR 1
	int	21H
	mov	WORD PTR DS:[BP.fileOffset],AX
	mov	WORD PTR DS:[BP.fileOffset+2],DX
	jmp	IoLoop

; ==========================================================================
; Test	to see if correct system disk. Open handles
; ==========================================================================

CRET12:
	stc
	return

; ==========================================================================
; TestSysDISK:
; ==========================================================================

Get_Bios:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET BiosFile		; DS:DX --> ASCIIZ pathname
	int	21H
	jnc	SetBios
	jmp	CheckMany

SetBios:
	mov	[Bios.fileHandle],AX		; save file handle
	mov	BX,AX				; BX = file handle
	call	GetFsiz
	cmp	[Bios.fileSizeInParagraphs],0
	jz	SetBioSize
	cmp	[Bios.fileSizeInParagraphs],AX
	jz	SetBioSize
BiosCls:
	mov	AH,CLOSE
	mov	BX,[Bios.fileHandle]
	int	21h
	ret

; ==========================================================================

SetBioSize:
	mov	[Bios.fileSizeInParagraphs],AX
	mov	WORD PTR [Bios.fileSizeInBytes],SI
	mov	WORD PTR [Bios.fileSizeInBytes+2],DI
	mov	[Bios.fileDate],DX
	mov	[Bios.fileTime],CX
	clc
	ret
; ==========================================================================

Get_DOS:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET DosFile		; DS:DX --> ASCIIZ pathname
					; Note: Drive letter is original drive name,
					;       not necc. target drive.
	int	21H
	jnc	DosOpenOK
;	call	CheckMany
;	jmp	BiosCls				CheckMany no ret.
	jmp	CheckMany

DosOpenOK:
	mov	[dos.fileHandle],AX		; save new file handle
	mov	BX,AX
	call	GetFsiz				; get file size info
	cmp	[dos.fileSizeInParagraphs],0
	jz	SetDosSize
	cmp	[dos.fileSizeInParagraphs],AX
	jz	SetDosSize

DosCls:
	mov	AH,CLOSE			; this file is empty, close it
	mov	BX,[dos.fileHandle]
	int	21H

	ret
; ==========================================================================

SetDosSize:

	mov	[dos.fileSizeInParagraphs],AX
	mov	WORD PTR [dos.fileSizeInBytes],SI
	mov	WORD PTR [dos.fileSizeInBytes+2],DI
	mov	[dos.fileDate],DX
	mov	[dos.fileTime],CX
	clc
	ret

; ==========================================================================

Get_COMMAND:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET CommandFile
	int	21H
	jnc	GotComHand
	jmp	CheckMany

GotComHand:
	mov	[command.fileHandle],AX
	mov	BX,AX
	call	GetFsiz
	cmp	[command.fileSizeInParagraphs],0
	jz	SetComSize
	cmp	[command.fileSizeInParagraphs],AX
	jz	SetComSize
ComCls:
	mov	AH,CLOSE
	mov	BX,[command.fileHandle]
	int	21H
	ret

; ==========================================================================

SetComSize:
	mov	[command.fileSizeInParagraphs],AX
	mov	WORD PTR [command.fileSizeInBytes],SI
	mov	WORD PTR [command.fileSizeInBytes+2],DI
	mov	[command.fileDate],DX
	mov	[command.fileTime],CX
	CLC
	return



IFDEF DBLSPACE_HOOKS
; ==========================================================================
Get_DblSpace:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET DblSpaceFile
	int	21H
	jnc	GotDblHand

	; We didn't locate DblSpace.bin in the root directory, look for
	; it along the PATH

	call	Find_DblSpace_on_Path		; sets CY if not found
	retc

	mov	AX,OPEN shl 8			; open the copy found
	mov	DX,OFFSET DblSpaceFile
	int	21H
	retc

GotDblHand:
	mov	[DblSpaceBin.fileHandle],AX

	mov	BX,AX
	call	GetFsiz

	mov	[DblSpaceBin.fileSizeInParagraphs],AX
	mov	WORD PTR [DblSpaceBin.fileSizeInBytes],SI
	mov	WORD PTR [DblSpaceBin.fileSizeInBytes+2],DI
	mov	[DblSpaceBin.fileDate],DX
	mov	[DblSpaceBin.fileTime],CX

	CLC
	return

ENDIF



; ==========================================================================

FILE_CLS:
	mov	AH,CLOSE
	int	21H
	ret

; ==========================================================================
; Handle in BX, return	file size in para in AX
; File	size in	bytes DI:SI, file date in DX, file
; time	in CX.
; ==========================================================================

GetFsiz:
	mov	AX,(LSEEK shl 8) OR 2
	xor	CX,CX
	mov	DX,CX
	int	21h
	mov	SI,AX
	mov	DI,DX
	add	AX,15				; Para	round up
	adc	DX,0
	and	DX,0fH				; If file is larger than this
				 		; it is bigger than the 8086
				 		; address space!
	mov	CL,12
	shl	DX,CL
	mov	CL,4
	shr	AX,CL
	or	AX,DX
	push	AX
	mov	AX,LSEEK shl 8
	xor	CX,CX
	mov	DX,CX
	int	21H
	mov	AX,FILE_TIMES shl 8
	int	21H
	pop	AX
	return

; ==========================================================================
; Read/Write file
;	 DS:0 is Xaddr
;	 DI:SI is byte count to	I/O
;	 BX is handle
; Carry set if	screw up
;
; I/O SI bytes
; I/O 64K - 1 bytes DI	times
; I/O DI bytes
; ==========================================================================

ReadFile:					; Must preserve AX,DX
	push	AX
	push	DX
	push	BP
	mov	BP,READ shl 8
	call	FilIo

	pop	BP
	pop	DX
	pop	AX
	return

WriteFile:
	push	BP
	mov	BP,WRITE shl 8
	call	FilIo
	pop	BP
	return

FilIo:
	xor	DX,DX
	mov	CX,SI
	jCXZ	K64IO
	mov	AX,BP
	int	21H
	retc
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	retnz
	call	Normalize
K64IO:
	CLC
	mov	CX,DI
	jCXZ	IoRet
	mov	AX,BP
	int	21H
	retc
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	retnz
	call	Normalize
	mov	CX,DI
K64M1:
	push	CX
	xor	AX,AX
	OR	DX,DX
	jz	NormIo
	mov	CX,10H
	SUB	CX,DX
	mov	AX,BP
	int	21H
	jc	IoRetP
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	jnz	IoRetP
	call	Normalize
NormIo:
	mov	CX,0FFFFH
	SUB	CX,AX
	mov	AX,BP
	int	21H
	jc	IoRetP
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	jnz	IoRetP
	call	Normalize			; Clears carry
	pop	CX
	LOOP	K64M1
	push	CX
IoRetP:
	pop	CX
IoRet:
	return


; ==========================================================================
; Shift DI:SI left 4 bits
; ==========================================================================

DISIX4:
	mov	CX,4
@@:
	shl	SI,1
	rcl	DI,1
	loop	@B
	return

; ==========================================================================
; Shift DI:SI right 4 bits
; ==========================================================================

DISID4:
	mov	CX,4
@@:
	shr	DI,1
	rcr	SI,1
	loop	@B
	return

; ==========================================================================
; Normalize DS:DX
; ==========================================================================

Normalize:
	 push	 DX
	 push	 AX
	 SHR	 DX,1
	 SHR	 DX,1
	 SHR	 DX,1
	 SHR	 DX,1
	 mov	 AX,DS
	 add	 AX,DX
	 mov	 DS,AX
	 pop	 AX
	 pop	 DX
	 and	 DX,0FH				 ; Clears carry
	 return

;=========================================================================
; Get_Command_Path		 : This	routine	finds the path where
;				   COMMAND.COM resides based on	the
;				   environmental vector.  Once the
;				   path	is found it is copied to
;				   CommandFile.
;
;	 Inputs	 : Exec_Block.Segment_Env - Segment of environmental vector
;		   Comspec_ID		  - "COMSPEC="
;
;	 Outputs : CommandFile		  - Holds path to COMMAND.COM
;=========================================================================

Procedure Get_Command_Path

	push	DS
	push	ES

	Set_Data_Segment			; DS,ES = Data
	call	Get_PSP_Parms			; Gets PSP info.
	cld					; Clear direction
	mov	AX,ES:Environ_Segment		; Get seg. of
						; Environ. vector
	mov	DS,AX				; Put it in DS
	assume	DS:nothing
	xor	SI,SI				; Clear SI

;M012 - begin

GCP_WhileNotFound:
	mov	BX,SI				; Save SI
	cmp	byte ptr DS:[SI],0
	jz	GCP_NotFound
	
	mov	DI,offset Comspec_ID
	mov	CX,8				; Loop 8 times
	repe	cmpsb				; "COMSPEC=" ?
	jnz	GCP_NotThisLine			; "COMSPEC=" not found

						; "COMSPEC=" found
	mov	DI,offset ES:CommandFile
	lodsb					; Priming read

			; Copy COMSPEC even if COMSPEC drive != boot drive
;	mov	DL,AL				; Prepare for capitalization
;	call	Cap_Char			; Capitalize character in DL
;	cmp	DL,ES:CommandFile		; COMSPEC same as boot Drive?
;	jne	GCP_NotFound			; COMSPEC drive != boot drive

GCP_GetPath: 					; While AL not = 0
	stosb					; Save it
	or	al,al				; At end?
	je	GCP_Done			; Yes

	lodsb					; Get character
	jmp	SHORT GCP_GetPath

GCP_NotThisLine:
	mov	SI,BX				; Restore SI

GCP_Find0Terminator:
	lodsb					; Loop until past the first 0.
	or	al,al
	jnz	GCP_Find0Terminator
	jmp	GCP_WhileNotFound
		
GCP_NotFound:
						; Nothing to do
						; since commandfile is
						; already patched to try
						; in the root of the
						; default or boot drive
GCP_Done:

;M012 - end

	pop	ES
	pop	DS

	ret

Get_Command_Path ENDP

comment ^					; M029
;
; This routine is no longer required		; M029
;
;=========================================================================
; Command_Root	 :	 This routine sets up CommandFile so that the
;			 COMMAND.COM will be written to	the root.
;			 It does this by copying at offset 3 of	CommandFile
;			 the literal COMMAND.COM.  This	effectively
;			 overrides the original	path, but maintains the
;			 Drive letter that is to be written to.
;
;	 Inputs	 :	 CommandFile - Holds full path to default COMMAND.COM
;	 Outputs :	 CommandFile - Holds modified path to new COMMAND.COM
;				       on target Drive.
;=========================================================================



Procedure Command_Root

	push	DS
	push	ES
	push	DI
	push	SI
	push	CX

	Set_Data_Segment
	mov	DI,offset CommandFile+3 	; Point to path past drive spec
	mov	SI,offset Command_Com		; Holds the literal COMMAND.COM
	mov	CX,000ch			; Len. of literal
	rep	movsb				; Move it

	pop	CX
	pop	SI
	pop	DI
	pop	ES
	pop	DS

	ret

Command_Root ENDP

endcomment ^					; M029



IFDEF DBLSPACE_HOOKS

;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Find_DblSpace_on_Path
;*******************************************************************************
;
;Description:	    Search Path for Dblspace.bin
;
;Output: no error - CF = 0	  DblSpaceFile filled in with
;                                 full path to dblspace.bin
;	    error - CF = 1	  Dblspace.bin not found
;
; Cut and pasted from SYS command code:   12/07/92  JEM
;
;******************* END OF SPECIFICATIONS *************************************

Find_DblSpace_on_Path PROC NEAR

        push es
        push ds                         ; save our segments
        push si                         ; save DTA address

	mov	ax, PSP_Segment
	mov	es, ax			; get our PSP to ES

        call Find_Path_In_Environment   ; returns ptr to path string in ES:DI
        jc   fdp_exit                   ; no path, can't find dblspace.bin

        assume es:nothing
        mov  ax,ds                      ; swap DS and ES
        push es
        pop  ds
        assume ds:nothing
        mov  si,di                      ; DS:SI ==> Path string
        mov  es,ax
        assume es:data

fdp_path_loop:
        mov  bh,';'                     ; path separator character
	mov  dx,offset DblSpaceBase	; base file name
	mov  di,offset DblSpaceFile	; buffer to stick full path in
        call Path_Crunch                ; concatenate name and path
        pushf                           ; save result
        push ds                         ; save segment of Path
        push es
        pop  ds
        assume ds:data
	mov  dx,offset DblSpaceFile	; buffer with full path name
        mov  bx,offset DOS_BUFFER       ; DMA buffer for finds
        mov  al,1                       ; extension is specified
        call Search
        or   al,al                      ; found the file?
        pop  ds                         ; recover path segment
        assume ds:nothing
        pop  ax                         ; recover flags in AX
        jnz  fdp_exit                   ; found it!
        xchg ah,al
        sahf                            ; check Path_Crunch result
        jnc  fdp_path_loop

fdp_exit:
        pop  si
        pop  ds
        pop  es
        assume ds:data
        ret

Find_DblSpace_on_Path ENDP

ENDIF



CODE  	ENDS

END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtab.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTAB - DEFINE ROM GRAPHIC CHARACTERS FOR 128-255

LISTPARM =	1			;0=SUPPRESS LIST; 1=ALLOW LIST

;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: GRTAB
;	       (MAIN ROUTINE FOR UTILITY "GRAFTABL")

; DESCRIPTIVE NAME: Makes resident a 1K block of data defining the
;		    graphic character set when in graphics mode.

;FUNCTION:  When in normal text mode (BASIC SCREEN 0), the CGA will properly
;	    handle all 255 characters in the screen display.
;	    However, when in graphics mode (BASIC SCREEN 1), then only the
;	    first 128 characters are properly shown on the screen.
;	    The upper 128 characters are defined in graphics mode by
;	    the 8 by 128 byte table pointed to by interrupt 1FH
;	    vector, which is normally set to 0:0, thus producing
;	    garbage on the screen for the upper set of characters.

;	    The purpose of this routine is to define an 8 by 128 byte
;	    table that defines each of these graphic characters in
;	    the upper 128 byte range, and also to put the vector
;	    pointer to this table into the interrupt 1FH.  Once
;	    loaded, this table remains resident.

;	    An interrupt handler is hooked into the INT 2FH vector that
;	    screens INT 2FH calls for the MULTIPLEX ID value of hex B0,
;	    as defined by an equate, MY_MULTIPLEX_NUMBER, in GRATABHAN.
;	    The response indicates that GRAFTABL has been loaded, thus
;	    permitting the redefinition of the original 1K table with
;	    some new specification.

; ENTRY POINT: Entry_Point, JMP from GRTABHAN.SAL at his ORG 100H.
;    LINKAGE: [d:][path] GRAFTABL [437 | 850 | 860 | 863 | 865 | 852 | /STATUS]

; INPUT: (DOS COMMAND LINE PARAMETERS)
;	'/STATUS'- (OR /STA) Identify the table already loaded, if any.
;	'?'	- Display the list of operands supported by GRAFTABL.
;	437  - Install the USA Graphic Character Set
;	(BLANK) - Means same as '437', the 'USA' definition table
;	850  - Install the Multi-lingual Graphic Character Set
;	852  - Install the Latin II Graphic Character Set
;	860  - Install the Portuguese Graphic Character Set
;	863  - Install the Canadian French Graphic Character Set
;	865  - Install the Nordic Graphic Character Set

; EXIT-NORMAL:	ERRORLEVEL 0 - Leaving the 1K block of newly defined
;			       characters resident.  There was no
;			       previously defined character table.
;			       Available RAM reduced by hex 1360 bytes.

;		ERRORLEVEL 1 - No change in size of available RAM storage.
;			       A previously loaded character table exists.
;			       If a new table was requested, it has replaced
;			       the previous table at its original location.

;		ERRORLEVEL 2 - No change in size of available RAM storage.
;			       No previously loaded character table exists.
;
;				(The request for status, with parm="/sta[tus]",
;				or the request for HELP, with parm="?",
;				will result in either code 1 or 2.)

; EXIT-ERROR: ERRORLEVEL 3 - Incorrect parameter.
;			     No action taken, assumes "?" requested HELP.
;			     No change in size of available RAM storage.

;	      ERRORLEVEL 4 - Incorrect version of DOS, DOS 4.0 required

; EFFECTS: Either the desired table is hooked into Interrupt 1FH,
;	   or the identity of the previously loaded table is
;	   displayed.

; INTERNAL REFERENCES:
;    ROUTINES:
;	FINDTYPE - Scan existing table to see who is already loaded
;	MOVTAB - Moves the specified table to overlay a portion of the PSP
;	BADPARMS - Displays error message, and sets error ERRORLEVEL code
;	SENDMSG - passes parms to regs and invokes the system message routine.

;    DATA AREAS:
;	PSP - Contains the DOS command line parameters.  Partly overlayed
;	      with the installation of the character table.
;	WORKAREA - Temporary storage

; EXTERNAL REFERENCES:
;    ROUTINES:
;	GRTABHAN (ENTRY is "HANDLER") - hooked into INT 2FH to identify
;		 that GRAFTABL is loaded and resident.
;	SYSDISPMSG - Uses the MSG parm lists to construct the messages
;		 on STDOUT.
;	SYSLOADMSG - Loads messages, makes them accessable.
;	SYSPARSE - Processes the DOS Command line, finds parms.
;	PARSE - Interfaces with the system Parser.

;    DATA AREAS:
;	GRTABUS - 1k binary table of the USA graphic character set
;	GRTABML - 1k binary table of the Multi-Lingual graphic
;		  character set
;	GRTABPO - 1k binary table of the Portuguese graphic
;		  character set
;	GRTABCF - 1k binary table of the Canada French graphic
;		  character set
;	GRTABNO - 1k binary table of the Nordic graphic character
;		  set
;	GRTABSM - Definition of messages, text and MSG parm lists,
;		  and COPYRIGHT notice
;	GRTABPAR - Control blocks to define the DOS command line parms.
;	MPEXNUM - Byte containing the value of the multiplex number
;		(For ease of patching, if such should ever become needed,
;		this byte is immediately just before the interrupt 2FH
;		handler's entry point, after that handler is loaded.  To
;		change this value here in these source modules, that value
;		is defined in GRTABHAN as the equate: MY_MULTIPLEX_NUMBER.
;		For purposes of patching the GRAFTABL.EXE file, this byte
;		is at offset 5FH into the module.)

; NOTES:
;	 This module should be processed with the SALUT preprocessor
;	 with the re-alignment not requested, as:

;		SALUT GRTAB,NUL

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 Sample LINK command:

; LINK @GRTABLK.ARF

; Where the GRTABLK.ARF is defined as:
;	 GRTABHAN+    (must be first in this list)
;	 GRTABUS+     (these languages must be linked in this order)
;	 GRTABML+     (Multi-Lingual)
;	 GRTABPO+     (Portuguese)
;	 GRTABCF+     (Canadian French)
;	 GRTABNO+     (Nordic)
;	 GRTABSM+     (contains COPYRIGHT, SYSDISPMSG, SYSLOADMSG code)
;	 GRTABPAR+    (contains PARSE control blocks, code to call SYSPARSE)
;	 GRTABP+      (contains SYSPARSE to decode COMMAND line parms)
;	 GRTAB	      (MAIN ROUTINE)
;	 GRAFTABL;

;	 These modules must be linked in this order.  The load module is
;	 a COM file, to be converted to COM with EXE2BIN.

; REVISION HISTORY:
;	     A000 Version 4.00: add PARSER, System Message Handler,
;	     A001 PTM 382 display "ACTIVE" OR "PREVIOUS" CP.
;	     A002 PTM 474 Avoid duplicate switches
;	     A003 PTM 538 Display parm in error
;	     A004 PTM1821 INCLUDE COPYRIGH.INC moved to msg_service macro.
;	     A005 PTM3262 specify BASESW EQU 1 before PARSE.ASM
;	     A006 PTM3512 PATHGEN START/END LABELS
;	     A007 PTM3621 break up large help msg into smaller messages
;	     A008 PTM3899 Free Environment, close all STDxxx handles
;			when leaving a resident portion
;

;****************** END OF SPECIFICATIONS *****************************
	HEADER	<MACRO DEFINITIONS, LOCAL EQUATES>
	INCLUDE PATHMAC.INC
;				   $SALUT (0,36,41,52)
DOSCALL 			   MACRO FN,SF	   ;;
				   IFNB <FN>	   ;;ARE THERE ANY PARMS AT ALL?
				   IFNB <SF>	   ;;
				   MOV	AX,(FN SHL 8)+SF ;;AH=FN;AH=SF
				   ELSE 	   ;;SINCE THERE IS NO SUB FUNC
				   MOV	AH,FN	   ;;
				   ENDIF	   ;;
				   ENDIF	   ;;
				   INT	21H	   ;;
				   ENDM 	   ;;
; =  =	=  =  =  =  =  =  =  =	=  =
;		  $SALUT (4,19,23,36)
FIXLIST 	  MACRO LP,DOIT    ;;
IF		  LP		   ;;
DOIT				   ;;
ENDIF				   ;;
		  ENDM		   ;;
; =  =	=  =  =  =  =  =  =  =	=  =
HEADER		  MACRO TEXT	   ;;
		  FIXLIST LISTPARM,.XLIST ;;
		  SUBTTL TEXT	   ;;
		  FIXLIST LISTPARM,.LIST ;;
		  PAGE		   ;;
		  ENDM		   ;;
; =  =	=  =  =  =  =  =  =  =	=  =
;		DEFINITION OF FUNCTIONS TO BE REQUESTED OF INT 2FH
GET_INST_STATE	  EQU 0 	   ;FUNCTION = "GET INSTALLED STATE"
WHERE_R_U	  EQU 1 	   ;FUNCTION = "WHERE ARE YOU?"
				   ; REQUESTS VECTOR OF LOADED TABLE BE
				   ; PUT IN VECTOR POINTED TO BY DS:[BX]

;		DOS FUNCTIONS:
SHOW_MSG	  EQU 09H	   ;"SEND MESSAGE TO CONSOLE" DOS FUNCTION
SET_VECT	  EQU 25H	   ;"SET VECTOR" DOS FUNCTION
GET_VERSION	  EQU 30H	   ;"GET DOS VERSION"
RET_RES 	  EQU 31H	   ;"RETURN TO DOS" REMAIN RESIDENT
GET_VECT	  EQU 35H	   ;"GET VECTOR" DOS FUNCTION
CLOSE		  EQU 3EH	   ; CLOSE A FILE HANDLE
FREE_AL_MEM	  EQU 49H	   ; FREE ALLOCATED MEM
RET_FN		  EQU 4CH	   ;"RETURN TO DOS" NOT REMAIN RESIDENT

;		VECTOR TABLE ENTRIES USED
VEC_GRAF_CHAR	  EQU 1FH	   ;VECTOR THAT POINTS TO GRAPHIC CHAR TABLE
VEC_MULTIPLX	  EQU 2FH	   ;VECTOR OF MULTIPLEX HANDLER
VEC_DOS 	  EQU 21H	   ;VECTOR POINTS TO DOS FUNCTIONS
VEC_RET 	  EQU 20H	   ;RETURN TO DOS, WITHOUT RET CODE

;		DOS COMMAND LINE PARAMETERS
RETCODE_QUESTION  EQU -1	   ;VALUE IN BX, IF PARM=?
RETCODE_PARSE_ERROR EQU 1	   ;Value in BX if parse error occurred
ZERO		  EQU 0 	   ;VALUE IN BX IF PARM=/STATUS OR /STA
		  FIXLIST LISTPARM,.XLIST ;
;SLASH		EQU  "/"	    ;REQUEST FOR STATUS
;PARM?		EQU  "?"	    ;REQUEST FOR HELP
;				THE PARM THAT ASKS FOR A PARTICULAR LANGUAGE
;				IS THE TWO CHAR PAIR, DEFINED AS "LANID"
;				IN THE STRUC, "LANGUAGE"
		  FIXLIST LISTPARM,.LIST ;

;		STANDARD FILE HANDLES
STDIN		  EQU 0 	   ;STANDARD INPUT DEVICE
STDOUT		  EQU 1 	   ;STANDARD OUTPUT DEVICE
STDERR		  EQU 2 	   ;STANDARD ERROR OUTPUT DEVICE
STDAUX		  EQU 3 	   ;STANDARD AUX DEVICE
STDPRN		  EQU 4 	   ;STANDARD PRINTER DEVICE

;		OTHER EQUATES
BLANK		  EQU " "	   ;BLANK CHARACTER
NIBBLE_SIZE	  EQU 4 	   ;SHIFT COUNT TO MOVE ONE NIBBLE		;
		  FIXLIST LISTPARM,.XLIST ;					;
;CASEBIT	EQU  0FFH-20H	    ;TURN OFF THIS BIT TO MAKE UPPER CASE
;LOWERA 	EQU  'a'	    ;LOWER CASE CHARACTER 'a'
;LOWERZ 	EQU  "z"	    ;LOWER CASE CHARACTER 'z'
		  FIXLIST LISTPARM,.LIST ;					;

		  EXTRN HANDLER_SIZE:ABS ;THE BYTE SIZE REQUIREMENTS
		  EXTRN CPID_L:ABS ;NO. BYTES IN EACH CPID ENTRY

VECTOR		  STRUC 	   ;DEFINITION OF ANY DOUBLE WORD VECTOR POINTER
VECOFF		  DW  ? 	   ;OFFSET PORTION OF VECTOR POINTER
VECSEG		  DW  ? 	   ;SEGMENT PORTION OF VECTOR POINTER
VECTOR		  ENDS
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
LANGUAGE	  STRUC 	   ;DEFINITION OF EACH LANGUAGE TABLE
LANCHAR 	  DB  1024 DUP(?)  ;8 BYTES PER EACH OF 128 CHARACTERS
LANID		  DW  ? 	   ;TWO BYTE CODEPAGE ID, TO MATCH
				   ; GRAFTABL CMD LINE PARM
LANNAME 	  DB  14 DUP(?)    ;ASCIIZ STRING NAME OF LANGUAGE
LANGUAGE	  ENDS

TABSIZE 	  EQU SIZE LANCHAR + SIZE LANID + SIZE LANNAME ;SIZE OF
				   ; EACH GRAPHIC CHAR TABLE + ID + NAME
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;		VALUES FOR THE MSG_DESC CONTROL BLOCK
ONE_SUBS	  EQU 1 	   ;ONE VARIABLE FIELD IN MESSAGE		;
TWO_SUBS	  EQU 2 	   ;TWO VARIABLE FIELDS IN MESSAGE		;
CLASS_1 	  EQU 0100H	   ;CLASS 1 (DOS EXTENDED ERRORS)		;
CLASS_2 	  EQU 0200H	   ;CLASS 2 (PARSE ERRORS)			;
CLASS_A 	  EQU 0A00H	   ;CLASS A TYPE MESSAGE			;

;THIS MESSAGE DESCRIPTOR CONTROL BLOCK IS GENERATED, ONE PER MESSAGE,
;TO DEFINE THE SEVERAL PARAMETERS THAT ARE EXPECTED TO BE PASSED IN
;CERTAIN REGISTERS WHEN THE SYSDISPMSG FUNCTION IS TO BE INVOKED.

MSG_DESC	  STRUC 	   ;						;
MSG_NUM 	  DW  0 	   ;MESSAGE NUMBER (TO AX)			;
MSG_HANDLE	  DW  STDOUT	   ;HANDLE OF OUTPUT DEVICE (TO BX)		;
MSG_SUBLIST	  DW  0 	   ;POINTER TO SUBLIST (TO SI)			;
MSG_COUNT	  DW  0 	   ;SUBSTITUTION COUNT (TO CX)			;
MSG_CLASS	  DW  CLASS_A	   ;MESSAGE CLASS (IN HIGH BYTE, TO DH) 	;
				   ; LOW BYTE HAS 0 (FUNCTION "NO INPUT", TO DL)
MSG_DESC	  ENDS		   ;						;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
SUBLIST 	  STRUC 	   ;						;
SUB_SIZE	  DB  SIZE SUBLIST ;SUBLIST SIZE (POINTER TO NEXT SUBLIST)	;
SUB_RES 	  DB  0 	   ;RESERVED					;
				   ;NEXT FIELD IS TO BE USED AS A DOUBLE WORD
SUB_VALUE	  DW  0 	   ;TIME, DATE, OR PTR TO DATA ITEM		;
SUB_VALUE_SEG	  DW  0 	   ;SEG ID OF PTR				;
				   ;(ABOVE FIELD MUST BE FILLED AT EXECUTION TIME
				   ; IF THIS IS A .COM FILE)
SUB_ID		  DB  0 	   ;N OF %N					;
SUB_FLAGS	  DB  0 	   ;DATA TYPE FLAGS				;
SUB_MAX_WIDTH	  DB  0 	   ;MAXIMUM FIELD WIDTH (0=UNLIMITED)		;
SUB_MIN_WIDTH	  DB  0 	   ;MINIMUM FIELD WIDTH 			;
SUB_PAD_CHAR	  DB  " "	   ;CHARACTER FOR PAD FIELD			;
SUBLIST 	  ENDS		   ;						;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DEFPSP		  STRUC
		  DB  2CH DUP(?)
ENVIRON_SEG	  DW  ? 	   ; SEG ID OF ENVIRONMENT
		  DB  32H DUP(?)   ; SET WHERE
MOV_DEST	  DB  20H DUP(?)   ; INT HANDLER IS TO BE MOVED TO
				   ;AT MOV_DEST+HANDLER_SIZE WILL GO THE
				   ; TABLE ITSELF
PARMCNT 	  DB  ? 	   ;COUNT OF CHARS IN DOS COMMAND LINE PARM LIST
PARMDOS 	  DB  127 DUP(?)   ;DOS COMMAND LINE PARM TEXT
DEFPSP		  ENDS

PSPSIZE 	  EQU SIZE DEFPSP  ;SIZE OF THE PSP ITSELF
SHIFT_SIZE	  EQU PSPSIZE - MOV_DEST ; HOW FAR HANDLER/TABLE MOVED
				   ;WHEN THEY BECAME RESIDENT
SHIFT_SIZE_SEG	  EQU SHIFT_SIZE SHR NIBBLE_SIZE ;DIVIDE BY 16			;
				   ; TO CONVERT BYTES TO SEGS
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
.LIST
		  HEADER <EXTERNALS AND WORKAREA>
;    $SALUT (4,6,12,28)

CSEG SEGMENT WORD PUBLIC
     ASSUME CS:CSEG	   ;AS A .COM FILE, THE DOS
     ASSUME DS:CSEG	   ;  LOADER HAS ALREADY
     ASSUME ES:CSEG	   ;  INITIALIZED ALL THESE
     ASSUME SS:CSEG	   ;  SEGMENT REGISTERS

GRTAB_BASE EQU $	   ;FOR EASE IN DEBUGGING				;
     PUBLIC GRTAB_BASE	   ; TELL LINK MAP WHERE THIS IS			;

     EXTRN END_PSP:BYTE    ;MOVE RESIDENT CODE FROM HERE TO "MOV_DEST"
     EXTRN MPEXNUM:BYTE    ;MULTIPLEXOR ID VALUE
     EXTRN HANDLER:NEAR    ;ENTRY TO INT2FH HANDLER
     EXTRN PREV_OWN:DWORD  ;VECTOR TO SAVE PREVIOUS INT2FH OWNER
     EXTRN PATCH_OFF:WORD  ;THESE TWO PATCH LOCATION IN GRTABHAN.SAL
     EXTRN PATCH_SEG:WORD  ; ARE TO RECEIVE LOCATION WHERE TABLE IS MOVED TO
     EXTRN TABLEUS:BYTE    ;START OF THE USA CHAR TABLE
     EXTRN COPYRIGHT:BYTE  ;USED TO MARK THE END OF THE ARRAY OF CHAR TABLES
			   ; THE COPYRIGHT TEXT IS ITSELF UN-REFERENCED
     FIXLIST LISTPARM,.XLIST ;							;
;    EXTRN MSG1:WORD	   ;NON-STD VER OF GRAPHIC CHAR SET TABLE IS ALREADY LOADED
;    EXTRN MSG2:WORD	   ;XXX VER OF GRAPHIC CHAR SET TABLE IS ALREADY LOADED
;    EXTRN MSG3:WORD	   ;XXX VER OF GRAPHIC CHAR SET HAS JUST BEEN LOADED
;    EXTRN MSG4:WORD	   ;INCORRECT PARAMETER
;    EXTRN MSG5:WORD	   ;NO VER OF GRAPHIC CHAR SET TABLE IS ALREADY LOADED
;    EXTRN MSG6:WORD	   ;INCORRECT DOS VERSION
;    EXTRN MSG7:WORD	   ;DOS COMMAND LINE PARAMETERS SUPPORTED:
;    EXTRN MSG8:WORD	   ;ID - LANGUAGE NAME
;    EXTRN LANGUAGE_NAME:BYTE ;14 BYTE AREA TO RECEIVE ASCIIZ OF LANGUAGE NAME
     FIXLIST LISTPARM,.LIST ;
     EXTRN MSGNUM_EXTERR:WORD ;ALL DOS EXTENDED ERRORS
     EXTRN MSGNUM_PARSE:WORD ;ALL PARSING ERRORS
     EXTRN SUBLIST_PARSE:WORD ;DEFINES THE BAD PARM AS %0
     EXTRN MSGNUM_VER:WORD ;"Incorrect DOS Version"
     EXTRN MSGNUM_ACTIVE:WORD ;"Active Code Page: %1"
     EXTRN MSGNUM_PREVIOUS:WORD ;"Previous Code Page: %1"
     EXTRN CPID:BYTE	   ;4 BYTE STRING OF CODE PAGE ID
     EXTRN SLIST_23:WORD   ;SET VECTOR TO POINT TO "NONE" OR "NON-STANDARD",
			   ; OR TO ONE OF THE "CPID" ENTRIES
     EXTRN MSGNUM_NONE:WORD ;"None"
     EXTRN MSGNUM_NSTD:WORD ;"Non-Standard"
     EXTRN MSGNUM_HELP_OPTIONS	: WORD	; MSG_DESC for all options messages
     EXTRN MSG_OPTIONS_FIRST	: ABS	; number of first message
     EXTRN MSG_OPTIONS_LAST	: ABS	;  and last
     EXTRN SYSDISPMSG:NEAR ;DISPLAY MESSAGE SUBROUTINE
     EXTRN SYSLOADMSG:NEAR ;LOAD MESSAGE SUBROUTINE
     EXTRN SYSGETMSG:NEAR  ;GET MESSAGE SUBROUTINE
     EXTRN PARSER:NEAR	   ;INVOKES SYSTEM DOS COMMAND LINE PARSER
;		$SALUT (4,17,22,32)
WHERE		DD   0	       ;VECTOR POINTING TO PREVIOUS GRAFTABL TABLE
			       ; VECTOR AS SET BY "GRTABHAN" MULTIPLEX HANDLER.
			       ;THIS IS NOT NECESSARILY WHAT INT 1FH HAS.
ADPSP		DW   0	       ;SEG ID OF PSP.
			       ; CHANGED TO SHOW ITS SHIFTED LOCATION
		FIXLIST LISTPARM,.XLIST ;
;ACC		 DW   0 	;ACCUMULATES VALUE OF CODEPAGE ID
;TEN		 DW   10	;CONSTANT TO CONVERT ASCII DECIMAL TO BINARY
;TOKEN		 DB   "    "	;RECEIVES THE TEXT OF DOS PARMS, AND OVERFLOW AREA
;TOKEN_SIZE	 EQU  $-TOKEN
		FIXLIST LISTPARM,.LIST ;
RESSIZE_PARA	DW   0	       ;SIZE OF RESIDENT PORTION, HANDLER+TABLE, IN PARAGRAPHS
RESSIZE_BYTE	DW   0	       ;SIZE OF RESIDENT PORTION, HANDLER+TABLE, IN BYTES
SAVESI		DW   0	       ;REMEMBER WHERE CURRENT TABLE STARTS
CPIDPOINTER	DW   CPID      ;POINTER TO ENTRY IN CPID TABLE OF PREVIOUS ENTRY
ACTIVECPID	DW   CPID      ;POINTER TO ENTRY IN CPID TABLE OF ACTIVE ENTRY
		PUBLIC ACTIVECPID
IDXXX		DW   0	       ;ID OF PREVIOUSLY LOADED TABLE
INSTALLED	DB   0	       ;OUTPUT OF INT 2FH, "FF"=GRAFTABL ALREADY INSTALLED
			       ; AND 'WHERE' WILL POINT TO PREVIOUS TABLE
			       ;"00"=GRAFTABL NOT INSTALLED

;		DEFINITIONS OF VALUES OF CONTENTS OF "INSTALLED".
LOADED		EQU  0FFH      ;GRAFTABLE IS ALREADY IN VECTOR


;		DEFINITIONS OF VALUES OF CONTENTS OF 'EXITFL'.
;		THESE VALUES ARE THE RETURN CODES CHECKED BY ERRORLEVEL.
EXVER		EQU  4	       ;RETURN TO DOS, INVALID DOS VERSION
EXPAR		EQU  3	       ;RETURN TO DOS, INVALID DOS COMMAND LINE PARMS
			       ; OR SYSTEM MESSAGE HANDLER ERROR
EXNONE		EQU  2	       ;RETURN TO DOS, NO TABLE WAS LOADED
EXDOS		EQU  1	       ;RETURN TO DOS, CHAR TABLE PREVIOUSLY LOADED
EXRES		EQU  0	       ;RETURN TO DOS, LEAVING THE 1K BLOCK OF CHAR RESIDENT

EXITFL		DB   EXDOS     ;ERRORLEVEL RETURN CODE, INITIALLY SET TO "EXDOS"
		PUBLIC EXITFL
BAD1F		DB   0	       ;FLAG, GET SET TO "RESET" IF GRAFTABL FONT IS
RESET		EQU  1	       ; LOADED, BUT 1FH DOES NOT POINT TO IT
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
		PATHLABL GRTAB
;  $SALUT (3,4,9,32)
   HEADER <EXECUTABLE CODE, INITIALIZATION>
MAIN PROC NEAR
ENTRY_POINT LABEL NEAR	       ;JUMPED TO FROM ENTRY POINT IN GRTABHAN
   PUBLIC ENTRY_POINT
;VERSION CHECKING AND SYSTEM MESSAGE INITIALIZATION

   CALL SYSLOADMSG	       ; INIT SYSMSG HANDLER

;  $IF	C		       ; IF THERE WAS A PROBLEM
   JNC $$IF1
      CALL SYSDISPMSG	       ; LET HIM SAY WHY HE HAD A PROBLEM

      MOV  EXITFL,EXVER        ; TELL ERRORLEVEL BAD DOS VERSION
      MOV  AH,RET_FN	       ;RETURN TO DOS, DO NOT STAY RESIDENT
;  $ELSE		       ; SINCE SYSDISPMSG IS HAPPY
   JMP SHORT $$EN1
$$IF1:
      CLD		       ;CLEAR DIRECTION TO AUTO-INCREMENT
      CALL MAIN_GRTAB	       ;PERFORM REST OF GRAFTABL FUNCTIONS
			       ;AH=DOS FUNCTION OF TYPE OF RETURN TO DOS
;  $ENDIF		       ;LOAD OF SYS MSGS OK?
$$EN1:
   MOV	AL,EXITFL	       ;PASS BACK ERRORLEVEL RET CODE
   INT	VEC_DOS 	       ;(21H) RETURN TO DOS WITH RET CODE

   INT	VEC_RET 	       ;(20H) IF ABOVE NOT WORK, EXIT ANYWAY
MAIN ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   HEADER <MAIN_GRTAB - PERFORM FUNCTIONS INDICATED BY PARMS>
MAIN_GRTAB PROC NEAR
   PUBLIC MAIN_GRTAB
;INPUT: SYSTEM MESSAGE HANDLER IS LOADED, DOS VERSION IS CORRECT.
;OUTPUT: AH=FUNCTION NUMBER FOR PROPER TYPE OF RETURN TO DOS.

   MOV	SLIST_23.SUB_VALUE_SEG,CS ;DO MY OWN SEGMENT FIXUPS
   MOV	SUBLIST_PARSE.SUB_VALUE_SEG,CS ;

   MOV	ADPSP,ES	       ;SAVE SEG ID OF PSP
   SUB	ADPSP,SHIFT_SIZE_SEG   ;WHERE THE SEG BASE OF MOVED INT HANDLER WILL BE
   PUSH ES		       ;SAVE PSP SEGID

   MOV	AX,HANDLER_SIZE        ;GET SIZE OF MULTIPLEX HANDLER (NOT PSP)
   ADD	AX,TABSIZE	       ;ADD THE SIZE OF THE CHAR TABLE
   MOV	RESSIZE_BYTE,AX        ;SAVE BYTE LENGTH OF HANDLER + CHAR TABLE
			       ; THIS IS THE AMOUNT TO BE SHIFTED
   ADD	AX,OFFSET MOV_DEST     ;ADD ON PART OF PSP NOT OVERLAID BY CODE MOVE
   MOV	CL,NIBBLE_SIZE	       ;DIVIDE
   SHR	AX,CL		       ; BYTE SIZE BY 16
   MOV	RESSIZE_PARA,AX        ;SAVE PARA LENGTH OF HANDLER + CHAR TABLE
			       ; AND FIRST PART OF PSP
			       ;THIS IS THE AMOUNT TO STAY RESIDENT

			       ;PATCH INT2FH HANDLER IN CASE LATER
			       ; IT BECOMES RESIDENT AND IS ASKED
			       ; TO TELL WHERE ITS CHAR TABLE WENT
   MOV	AX,ADPSP	       ;TELL INT2FH HANDLER WHERE TO SAY HIS TABLE IS
   MOV	PATCH_SEG,AX
   MOV	PATCH_OFF,OFFSET TABLEUS ;TELL INT2FH HANDLER
			       ; WHERE TO SAY HIS TABLE IS
   MOV	AH,GET_VECT	       ;REQUEST "GET VECTOR" FUNCTION
   MOV	AL,VEC_MULTIPLX        ; FOR INTERRUPT 2FH
   INT	VEC_DOS 	       ;OUTPUT: ES:BX = VECTOR OF CONTENTS

   ASSUME ES:NOTHING	       ;SINCE ORIG PSP POINTER IS LOST
			       ;PATCH INT2FH HANDLER TO TELL HIM WHERE
			       ; THE CURRENT INT2FH HANDLER IS IN CASE
			       ; THIS NEW HANDLER REPLACES THE OLD ONE
   MOV	PREV_OWN.VECOFF,BX     ;REMEMBER WHERE THE PREVIOUS
   MOV	PREV_OWN.VECSEG,ES     ; OWNER OF INT 2FH WAS

   POP	ES		       ;RESTORE THE PSP SEGID BAS
   ASSUME ES:CSEG	       ;REG IS RESET BACK LIKE IT WAS
   CALL FINDTYPE	       ;SET 'IDXXX' TO SHOW
			       ; WHAT IS IN THE LOW RAM TABLE NOW

   FIXLIST LISTPARM,.XLIST     ;
;  CALL PROCESS 	       ;RESPOND TO REQUEST DEFINED BY PARMS
;			       ; SETTING 'EXITFL' TO INDICATE RESULTS
   FIXLIST LISTPARM,.LIST      ;
   CALL PARSER		       ;LOOK AT DOS COMMAND LINE PARMS

			       ;IF A CODEPAGE NUMBER WAS SPECIFIED
			       ;   BX = OFFSET TO LANGUAGE TABLE TO BE LOADED
			       ;   DX = INTEGER VALUE OF CODEPAGE SPECIFIED
			       ;IF /STATUS WAS SPECIFIED
			       ;   BX = 0
			       ;IF /? WAS SPECIFIED
			       ;   BX = -1
			       ; If parse error occurred
			       ;   BX = 1

   CALL DOFUNCTION	       ; RESPOND TO PARMS
			       ; SETTING 'EXITFL' TO INDICATE RESULTS


   FIXLIST LISTPARM,.XLIST     ;
;  $ELSE		       ;SINCE THE DOS VERSION IS NOT ACCEPTABLE,
;				THE LOCATION, "MSG6", CONTAINS OFFSET TO TEXT OF
;     MOV  DX,MSG6	       ;"INCORRECT DOS VERSION" (THIS MSG ENDS WITH "$")
;			       ;GET POINTER TO MESSAGE TEXT TO DS:DX
;     MOV  AH,SHOW_MSG	       ;'WRITE TO CONSOLE' DOS FUNCTION
;     INT  VEC_DOS
;
;     MOV  EXITFL,EXVER        ;SET ERROR CODE TO ERROR TERMINATION, BAD VERSION
;  $ENDIF		       ;CHECK DOS VERSION NUMBER
   FIXLIST LISTPARM,.LIST      ;

   CMP	EXITFL,EXRES	       ;CHECK THE EXIT TYPE FLAG
;  $IF	E		       ;IF NEW TABLE HAS JUST BEEN LOADED
   JNE $$IF4
;THE INT2FH HANDLER AND THE CHAR TABLE HAVE ALREADY BEEN MOVED INTO THE PSP.
;CHANGE THE TWO VECTORS TO POINT TO WHERE THEN WENT.
;THE TWO VECTORS ARE:
;      2FH  - MULTIPLEX INTERRUPT HANDLER
;      1FH  - 128 CHAR DEFINITION TABLE

      PUSH DS

      MOV  AX,ADPSP
      MOV  DS,AX	       ;FIND SEG WHERE TABLE WENT
      ASSUME DS:NOTHING

;SET INTERRUPT VECTOR 1FH TO POINT TO WHERE THE CHAR TABLE IS
      LEA  DX,TABLEUS	       ;WHERE CHAR TABLE IS
			       ; DS:DX = VECTOR POINTING TO CHAR TABLE AFTER MOVE
      MOV  AH,SET_VECT	       ;FUNCTION TO MOVE DS:DX INTO VECTOR FOR INT 1FH
      MOV  AL,VEC_GRAF_CHAR    ;INTERRUPT NUMBER TO RECEIVE NEW CONTENTS
      INT  VEC_DOS	       ;CHANGE THE VECTOR

;SET INTERRUPT VECTOR 2FH (MULTIPLEXOR) TO WHERE THE INTERRUPT HANDLER IS
      LEA  DX,HANDLER	       ;SET DS:DX = INT 2FH INTERRUPT HANDLER
      MOV  AH,SET_VECT	       ;FUNCTION TO MOVE DS:DX INTO VECTOR FOR INT 2FH
      MOV  AL,VEC_MULTIPLX     ;CHANGE THE CONTENTS OF THE MULTIPLEX INTERRUPT
      INT  VEC_DOS	       ;HOOK IN THE INTERRUPT HANDLER

      POP  DS		       ;RESTORE SEG REG
      ASSUME DS:CSEG

;FREE THE SEGMENT CONTAINING THE ENVIRONMENT
      PUSH ES		       ; SAVE NORMAL ES
      MOV  AX,DS:ENVIRON_SEG   ; FROM PSP GET SEG OF ENVIRONMENT
      MOV  ES,AX	       ; SET SEGREG TO POINT TO ENVIRONMENT SEG
      ASSUME ES:NOTHING        ; ES NOW HAS SEG OF ENVIRONMENT

      MOV  AH,FREE_AL_MEM      ; (49H) FREE MEM ALLOC TO ENVIRON
			       ;ES = SEGID OF BLOCK BEING RETURNED
      INT  VEC_DOS	       ; FREE ENVIRONMENT
			       ;IF CARRY IS SET, THERE WAS A PROBLEM
			       ;THIS IS NOT CHECKED, IGNORING ANY ERROR

      POP  ES		       ; RESTORE ES TO NORMAL VALUE
      ASSUME ES:CSEG	       ;

;LOOP THRU ALL THE STANDARD EXTERNALLY OPENED HANDLES, 0-4,
; AND CLOSE EACH ONE BEFORE RETURNING TO DOS, STAYING RESIDENT.
      MOV  BX,STDIN	       ; START WITH FIRST STANDARD HANDLE
;     $DO  COMPLEX
      JMP SHORT $$SD5
$$DO5:
	 INC  BX	       ; SELECT NEXT HANDLE
;     $STRTDO
$$SD5:
	 MOV  AH,CLOSE	       ; (3EH) CLOSE A FILE HANDLE
			       ; BX=FILE HANDLE
	 INT  VEC_DOS	       ; CLOSE THE HANDLE
			       ;CARRY IS SET IF A PROBLEM WITH CLOSE
			       ;IN THIS CASE, ERRORS ARE IGNORED.

	 CMP  BX,STDPRN        ; WAS THIS THE LAST ONE?
;     $ENDDO E		       ; QUIT IF LAST ONE
      JNE $$DO5

;SET UP TO LEAVE A PORTION OF GRAFTABL RESIDENT:
; THE MULTIPLEXOR INTERRUPT HANDLER, AND
; THE FIRST 1K PIXEL TABLE.

      MOV  DX,RESSIZE_PARA     ;MARK END OF AREA TO REMAIN RESIDENT
      MOV  AH,RET_RES	       ;FUNCTION TO RETURN TO DOS, BUT STAY RESIDENT
;  $ELSE		       ;SINCE NEW TABLE NOT LOADED
   JMP SHORT $$EN4
$$IF4:
			       ; MAYBE BECAUSE TABLE ALREADY LOADED
			       ; OR MAYBE BECAUSE BAD DOS COMMAND LINE PARMS
      MOV  AH,RET_FN	       ;RETURN TO DOS, DO NOT STAY RESIDENT
;  $ENDIF
$$EN4:
   RET			       ;RETURN TO CALLER
MAIN_GRTAB ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   HEADER <LOCAL SUBROUTINES, SCAN TO SEE WHO IS ALREADY LOADED>
FINDTYPE PROC NEAR
   PUBLIC FINDTYPE
;OUTPUT =  IDXXX HAS 2 CHAR ID OF WHATEVER IS ALREADY LOADED
;	     OR IS JUST 0 IF 1FH DOES NOT POINT TO A GRAFTABL DEFINED FONT.
;	   SUBLIST_23 IS SET TO CONTAIN THE ORIGINAL CP PREVIOUSLY LOADED
;	   OR "NONE".  THIS SUBLIST IS USED BY BOTH MESSAGES 2 AND 3
;	   WHICH STATE THE "ACTIVE CODEPAGE" AND "PREVIOUS CODEPAGE".
;	   THE MESSAGE ACTUALLY TO USE THIS SUBLIST IS SELECTED IN "DOFUNCTION"
;	   AFTER INTERROGATING THE PARMS, SO THAT "/STATUS" & "?" WILL REFER TO
;	   THE "ACTIVE CODEPAGE", AND OTHER REQUESTS WILL SAY "PREVIOUS CP".

   ASSUME ES:NOTHING
   MOV	AH,MPEXNUM	       ;REQUEST "GET INSTALLED STATE"
   MOV	AL,GET_INST_STATE      ;IDENTIFY THAT IT IS ME I AM LOOKING FOR
			       ;AH=MULTIPLEXOR NUMBER, AL=FUNCTION REQUEST
   INT	VEC_MULTIPLX	       ;SEE IF I AM ALREADY LOADED

   MOV	INSTALLED,AL	       ;SAVE THE "INSTALLED?" INDICATOR
   CMP	AL,LOADED
;  $IF	E		       ;IF I AM ALREADY INSTALLED
   JNE $$IF10
;		GRAFTABL HAS BEEN LOADED.  SEVERAL CONDITIONS MAY EXIST:
;		  INT 1FH STILL POINTS TO THE TABLE GRAFTABL LOADED
;			AND THAT TABLE HAS NOT BEEN ALTERED.
;		  INT 1FH STILL POINTS TO THE TABLE GRAFTABL LOADED
;			BUT THE CONTENTS OF THAT TABLE HAS BEEN ALTERED.
;		  INT 1FH NO LONGER POINTS TO THE TABLE GRAFTABL LOADED,
;			BUT POINTS TO SOME OTHER CHARACTER TABLE.

;		NOW WE ASK THE MULTIPLEXOR HANDLER OF GRAFTABLE, SINCE WE
;		KNOW HE HAS BEEN LOADED, TO TELL US WHERE HIS GRAFTABL
;		CHARACTER FONT TABLE IS IN RESIDENT RAM, BY SETTING THE
;		DWORD AT "WHERE" TO POINT TO THE OLD GRAFTABL FONT TABLE.

			       ;AH STILL SHOULD HAVE "MY_MULTIPLEX_NUMBER"
      MOV  AL,WHERE_R_U        ;ASK "WHERE ARE YOU"
      LEA  BX,WHERE	       ;PASS POINTER TO VECTOR TO RECEIVE ANSWER
			       ;AH=MULTIPLEXOR NUMBER, AL=FUNCTION REQUEST
			       ;DS:BX POINTS TO "WHERE", TO RECEIVE RESPONSE
      INT  VEC_MULTIPLX        ;SET VECTOR "WHERE" TO POINT TO HIS TABLE

;		COMPARE THE CONTENTS OF VECTOR 1FH WITH THE VECTOR AT "WHERE"
;		WHICH POINTS TO THE CURRENTLY LOADED TABLE OF GRAFTABL.
;		THE USER MAY HAVE ALTERED THE CONTENTS OF VECTOR 1FH AFTER
;		HAVING PREVIOUSLY LOADED A GRAFTABL CHARACTER FONT.
      XOR  AX,AX	       ;ZERO A REG
      MOV  ES,AX	       ;LOOK AT THE VECTOR TABLE
			       ;ES IS STILL ASSUMED "NOTHING"
      MOV  AX,ES:[VEC_GRAF_CHAR * DWORD]
      CMP  AX,WHERE.VECOFF
;     $IF  E,AND
      JNE $$IF11
      MOV  AX,ES:[VEC_GRAF_CHAR * 4]+2
      CMP  AX,WHERE.VECSEG
;     $IF  E		       ;IF THE 1FH VECTOR IS POINTING TO A GRAFTABLE
      JNE $$IF11
			       ; DEFINED CHARACTER TABLE.
			       ;NOW TO FIND OUT WHICH TABLE HE IS POINT TO.
	 LEA  SI,TABLEUS       ;GET WHERE NEW TABLE IS IN THIS LOAD MODULE
			       ; DS:SI POINT TO NEW TABLE
;		IN THIS SEARCH, WE ARE GOING TO STEP THRU THE ARRAY OF
;		TABLES WE HAVE DEFINED, COMPARING EACH ONE WITH WHATEVER "WHERE"
;		POINTS TO, TO SEE IF WHAT WAS PREVIOUSLY LOADED IS LIKE ONE
;		OF THE TABLES WE HAVE DEFINED HERE.  A MATCH LETS US IDENTIFY
;		THE ONE PREVIOUSLY LOADED; A NON-MATCH MEANS THAT WHATEVER
;		THAT WAS PREVIOUSLY LOADED HAS APPARENTLY BEEN ALTERED,
;		SO WHATEVER IT WAS, WE CANNOT SAY WHICH TABLE IT IS, AND SO WE
;		IDENTIFY IT AS SIMPLY A NON-STANDARD TABLE.  THIS SEARCH WILL
;		SELECT WHICH OF TWO MESSAGES TO BE DISPLAYED.
	 MOV  SAVESI,SI        ;SAVE WHERE TABLE STARTS
;	 $SEARCH COMPLEX
	 JMP SHORT $$SS12
$$DO12:
	    ADD  CPIDPOINTER,CPID_L ;BUMP TO NEXT ENTRY IN CPID TABLE.
	    MOV  SI,SAVESI     ;GO BACK TO START OF TABLE
	    ADD  SI,TABSIZE    ;BUMP TO NEXT TABLE
	    MOV  SAVESI,SI     ;SAVE WHERE TABLE STARTS
;	 $STRTSRCH
$$SS12:
;		   THIS CHANGES ES TO PREVIOUSLY LOADED TABLE

	    LES  DI,WHERE      ;GET THE CONTENTS OF THE VECTOR
			       ;ES:DI POINTS TO THE OLD TABLE OF CHARACTERS
			       ;ES IS STILL ASSUMED "NOTHING"
	    MOV  CX,TABSIZE    ;GET SIZE OF TABLE
	    REP  CMPSB	       ;COMPARE ES:[DI] WITH DS:[SI]
;	 $EXITIF E	       ;IF THIS TABLE ALREADY LOADED
	 JNE $$IF12
	    LES  DI,WHERE      ;RESTORE THE POINTERS TO RESIDENT TABLE
	    MOV  AX,ES:[DI].LANID ;PICK UP 2 CHAR ID OF PREVIOUS TABLE
	    MOV  IDXXX,AX      ;REMEMBER WHAT THAT WAS PREVIOUSLY LOADED

	    PUSH DS	       ;SET UP THE ES REG TO
	    POP  ES	       ;  BE THE SAME AS DS, THE COMMON SEGMENT
	    ASSUME ES:CSEG     ;

	    MOV  AX,CPIDPOINTER ;GET OFFSET TO CURRENT CPID ENTRY
	    MOV  SLIST_23.SUB_VALUE,AX ;PUT CP NAME IN MSG
			       ;SO MSG IS "PREVIOUS CODE PAGE: XXX"
	    FIXLIST LISTPARM,.XLIST ;
;	     LEA  DI,LANGUAGE_NAME ;TO THE MESSAGES' VARIABLE NAME OF LANGUAGE FIELD
;	     MOV  SI,SAVESI	;FROM THE NAME OF THE LANGUAGE
;	     ADD  SI,OFFSET LANNAME ; IN THE NEW TABLE
;	     MOV  CX,SIZE LANNAME ;PASS NAME OF LANGUAGE
;	     REP  MOVSB 	;  TO THE MESSAGES
;				; AND THEN TELL THE OPERATOR WHAT WAS FOUND
;	     LEA  AX,MSG2	;XXX VER OF GRAPHIC CHAR SET TABLE IS ALREADY LOADED
	    FIXLIST LISTPARM,.LIST ;						;
;	 $ORELSE	       ;SINCE THIS VERSION IS NOT ALREADY LOADED
	 JMP SHORT $$SR12
$$IF12:
	    ASSUME ES:NOTHING  ;SINCE BASE REG NOT RESET YET,
	    LEA  AX,COPYRIGHT  ;WHICH IS IMMEDIATELY FOLLOWING THE LAST TABLE
	    CMP  AX,SI	       ;HAVE WE INCREMENTED THE INDEX TO BE BEYOND
			       ; THE LAST TABLE TO BE CHECKED
;	 $ENDLOOP BE	       ;QUIT IF NO NEXT TABLE TO BE LOOKED AT
	 JNBE $$DO12
	    PUSH DS	       ;SET UP THE ES REG TO				;
	    POP  ES	       ;  BE THE SAME AS DS, THE COMMON SEGMENT 	;
	    ASSUME ES:CSEG     ;TELL THE ASSEMBLER WHAT I JUST DID		;

	    FIXLIST LISTPARM,.XLIST ;						;
;	    LEA  AX,MSG1       ;NON-STD VER OF GRAPHIC CHAR SET TABLE IS ALREADY LOADED
	    FIXLIST LISTPARM,.LIST ;						;
	    CALL PREV_NONSTD   ;SET MSG TO SAY "NON STANDARD"			;
			       ; SO MSG IS "PREVIOUS CODE PAGE: NON-STANDARD"
;	 $ENDSRCH
$$SR12:
;     $ELSE		       ;SINCE THE 1FH VECTOR DOES NOT POINT TO
      JMP SHORT $$EN11
$$IF11:
			       ; THE SAME PLACE AS "WHERE"
			       ; THEN THE USER MUST HAVE USED GRAFTABL TO
			       ; LOAD A CHAR FONT, THEN LOADED SOME OTHER
			       ; TABLE AND CHANGED VECTOR 1FH TO POINT TO THE NEW ONE.
	 PUSH DS	       ;SET UP THE ES REG TO				;
	 POP  ES	       ;  BE THE SAME AS DS, THE COMMON SEGMENT 	;
	 ASSUME ES:CSEG        ;TELL THE ASSEMBLER WHAT I JUST DID		;

	 CALL PREV_NONSTD      ;SET MSG TO SAY "NON STANDARD"			;

	 FIXLIST LISTPARM,.XLIST ;						;
;	  LEA  AX,MSG1		;NON-STD VER OF GRAPHIC CHAR SET TABLE IS ALREADY LOADED
	 FIXLIST LISTPARM,.LIST ;						;
	 MOV  BAD1F,RESET      ;INDICATE THAT THE 1FH VECTOR DOES NOT POINT
			       ; TO THE GRAFTABL FONT
;     $ENDIF		       ;HAS 1Fh BEEN CHANGED?
$$EN11:
;  $ELSE		       ;SINCE GRAFTABLE IS NOT LOADED,
   JMP SHORT $$EN10
$$IF10:
      PUSH DS		       ;SET UP THE ES REG TO				;
      POP  ES		       ;  BE THE SAME AS DS, THE COMMON SEGMENT 	;
      ASSUME ES:CSEG	       ;TELL THE ASSEMBLER WHAT I JUST DID		;

      CALL PREV_NONE	       ;SET MSG TO SAY "NONE"				;

      FIXLIST LISTPARM,.XLIST  ;						;
;      LEA  AX,MSG5		;NO VER OF CHAR TABLE IS ALREADY LOADED
      FIXLIST LISTPARM,.LIST   ;						;
;  $ENDIF		       ;ALREADY INSTALLED?
$$EN10:
   RET
FINDTYPE ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   HEADER <PREV_NONSTD - SET UP MESSAGE TO SAY 'NON-STANDARD'> ;		;
PREV_NONSTD PROC NEAR	       ;						;
   PUBLIC PREV_NONSTD	       ;						;
;SET UP SUBLIST FOR MSGS 2-3 TO HAVE THE VARIABLE TEXT: "NON-STANDARD".
   ASSUME ES:CSEG	       ;						;

   MOV	AX,MSGNUM_NSTD.MSG_NUM ;PASS MESSAGE NUMBER OF "NON-STANDARD"		;
   MOV	DH,BYTE PTR MSGNUM_NSTD.MSG_CLASS+BYTE ;PASS MSG'S CLASS                ;
   CALL SYSGETMSG	       ;FIND WHERE THE TEXT OF "NON-STANDARD" IS	;
			       ;ES:SI=VECTOR TO MESSAGE TEXT
   MOV	SLIST_23.SUB_VALUE,SI  ;PUT OFFSET INTO SUBLIST 			;
   RET			       ;RETURN TO CALLER				;
PREV_NONSTD ENDP	       ;						;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   HEADER <PREV_NONE - SET UP MESSAGE TO SAY 'NONE'> ;				;
PREV_NONE PROC NEAR	       ;						;
   PUBLIC PREV_NONE	       ;						;
;SET UP SUBLIST FOR MSGS 2-3 TO HAVE THE VARIABLE TEXT: "NONE".
   ASSUME ES:CSEG	       ;						;

   MOV	AX,MSGNUM_NONE.MSG_NUM ;PASS MESSAGE NUMBER OF "NONE"			;
   MOV	DH,BYTE PTR MSGNUM_NONE.MSG_CLASS+BYTE ;PASS MSG'S CLASS                ;
   CALL SYSGETMSG	       ;FIND WHERE THE TEXT OF "NONE" IS		;
			       ;ES:SI=VECTOR TO MESSAGE TEXT
   MOV	SLIST_23.SUB_VALUE,SI  ;PUT OFFSET INTO SUBLIST 			;
   RET			       ;RETURN TO CALLER				;
PREV_NONE ENDP		       ;						;
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   FIXLIST LISTPARM,.XLIST     ;						    ;
;   HEADER <PARSE THE COMMAND LINE PARMS>
;PROCESS PROC NEAR		;LOOK AT RESPONSE TO DOS COMMAND LINE PARMS
;   PUBLIC PROCESS
;INPUT: DS, ES - PSP SEG ID
;OUTPUT:EXITFL IS SET TO REFLECT EXISTING CONDITIONS

;   CALL PARSER 		;LOOK AT DOS COMMAND LINE PARMS
;
;				;IF A CODEPAGE NUMBER WAS SPECIFIED
;				;   BX = OFFSET TO LANGUAGE TABLE TO BE LOADED
;				;   DX = INTEGER VALUE OF CODEPAGE SPECIFIED
;				;IF /STATUS WAS SPECIFIED
;				;   BX = 0
;				;IF QUESTION MARK WAS SPECIFIED
;				;   BX=-1
;				; if parse error occurred
;				;   bx = 1
;
;   CALL DOFUNCTION		; RESPOND TO PARMS
;				; SETTING 'EXITFL' TO INDICATE RESULTS
;
;   ASSUME ES:CSEG
;   PUSH ES			;SAVE BASE REG
;   MOV  SI,OFFSET PARMDOS	;GET WHERE DOS PARMS START
;   SUB  DI,DI			;INIT INDEX TO ZERO, WHERE TO PUT PARMS IN TOKEN
;   MOV  CL,DS:PARMCNT		;GET HOW MANY CHARS ARE IN THE DOS COMMAND LINE
;   XOR  CH,CH			;CLEAR COUNTER OF OUTPUT CHARS
;   CALL UPCASE 		;CONVERT ANY LOWER CASE CHARS TO UPPERCASE
;
;   $SEARCH
;      CMP  CL,0		;ANY DOS PARMS?
;   $LEAVE BE			;QUIT IF NOT PARMS
;      MOV  DL,BYTE PTR [SI]	;SET DL TO A PARM CHAR FROM PARMDOS IN PSP
;      CMP  DL,BLANK		;IGNORE THE SPECIAL CHARS:
;      $IF  A			;  BLANK AND LOWER NUMBERED CONTROL CHARS
;	  CMP  DL,"?"		;IS THE SPECIFIED PARAMETER
;	  $IF  E		; A QUESTION MARK?
;	     MOV  BYTE PTR TOKEN[DI],DL ;PUT DL CONVERTED TO TOKEN
;	     INC  DI		;BUMP TO NEXT AVAIL SPOT IN TOKEN
;	     ADD  CH,3		;COUNT THIS AS AN OUTPUT CHAR,WITH NO ROOM FOR MORE
;	  $ELSE 		;SINCE NOT "?"
;	     CMP  DL,'0'	;IF CHAR IN RANGE OF NUMERICS
;	     $IF  AE,AND	;UNSIGNED TEST
;	     CMP  DL,'9'
;	     $IF  BE
;		PUSH DX
;		MOV  AX,ACC
;		IMUL TEN	;CLOBBERS DX
;		POP  DX 	;FIX IT BACK
;		SUB  DL,'0'	;CONVERT FROM NUMERIC CHAR TO BINARY
;		ADD  AL,DL	;ADD NEW NUMBER FROM PARM
;		ADC  AH,0	;PROPOGATE CARRY
;		MOV  ACC,AX	;SAVE RESULTS SO FAR
;		INC  CH 	;COUNT THIS AS AN OUTPUT CHAR
;	     $ELSE		;SINCE NOT A NUMERIC CHARACTER
;		MOV  CH,TOKEN_SIZE ;FORCE PARM ERROR, MAY BE CHANGED TO OK
;		CMP  CL,4
;		$IF  AE 	;IF AT LEAST 4 CHARS ARE PRESENT
;		   CMP	WORD PTR [SI],"S/" ;FIRST TWO CHARS OF "/STA"
;		   $IF	E,AND
;		   CMP	WORD PTR [SI]+WORD,"AT" ;NEXT TWO CHARS OF "/STA"
;		   $IF	E
;		      MOV  BYTE PTR TOKEN[DI],'/' ;PUT "/" CONVERTED TO TOKEN
;		      INC  DI	;BUMP TO NEXT AVAIL SPOT IN TOKEN
;		      MOV  CH,3 ;COUNT THIS AS AN OUTPUT CHAR,WITH NO ROOM FOR MORE
;		      MOV  CL,1 ;PRETEND THAT IS ALL OF THE COMMAND LINE THERE IS
;		   $ENDIF	;"/STA"?
;		$ENDIF		;LENGTH 4?
;	     $ENDIF		;IS CHAR IN NUMERIC RANGE?
;	  $ENDIF		;IS PARM A QUESTION MARK?
;      $ENDIF			;BLANK OR LOWER VALUED CONTROL CHARS?
;      CMP  CH,TOKEN_SIZE	;IS OUTPUT AREA OVERLY FULL?
;   $EXITIF GE
;      CALL BADPARMS		;FUSS ABOUT INVALID PARMS
;   $ORELSE
;      INC  SI			;BUMP INDEX TO NEXT PARM CHAR IN PSP
;      DEC  CL			;DEC COUNT OF INPUT CHARS FROM PARMS
;   $ENDLOOP
;				;SINCE CL COUNT WENT TO ZERO,
;      CMP  CH,0		;ANY DOS PARMS LEFT AFTER CLEANUP?
;      $IF  E			;IF NONE,
;	  MOV  WORD PTR TOKEN,437 ;MAKE IT LOOK LIKE "US" WAS SPECIFIED
;      $ELSE			;SOME PARM WAS SPECIFIED
;	  CMP  BYTE PTR TOKEN,PARM?
;	  $IF  NE,AND		;IF NOT A QUESTION MARK, AND
;	  CMP  BYTE PTR TOKEN,SLASH
;	  $IF  NE		;IF NOT A SLASH (FOR /STATUS)
;	     MOV  AX,ACC	;GET ACCUMULATOR
;	     MOV  WORD PTR TOKEN,AX ; TO TOKEN
;	  $ENDIF		;QUESTION MARK?
;      $ENDIF			;ANY DOS PARMS?
;      CALL DOFUNCTION		;RESPOND TO PARAMETER IN "TOKEN"
;
;   $ENDSRCH			;SCANNING DOS COMMAND LINE FOR PARMS
;
;   POP  ES			;RESTORE BASE REG
;   ASSUME ES:CSEG
;
;   RET
;PROCESS ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;UPCASE PROC NEAR
;;CONVERT CHARACTERS IN PARMLIST TO UPPER CASE
;;INPUT: SI=OFFSET IN DS: TO PARM TEXT
;;	 CX=NUMBER OF CHARS OF PARMS
;
;   OR	 CX,CX			;IF THERE ARE CHARS IN PARMLIST
;   $IF  NZ			; THEN GO LOOK AT EACH CHAR
;      PUSH SI			;SAVE POINTER TO PARMS
;      PUSH CX			;SAVE COUNTER OF PARMS
;      $DO			;STEP THRU ALL CHARS OF PARM LIST, CONVERTING TO UPPER CASE
;	  MOV  AL,[SI]		;GET CHAR FROM PARMLIST TO AL
;	  CMP  AL,LOWERA	;COMPARE WITH LOWER CASE "a"
;	  $IF  AE,AND		;UNSIGNED TEST
;	  CMP  AL,LOWERZ	;COMPARE WITH LOWER CASE "z"
;	  $IF  BE		;IF CHAR IS LOWER CASE
;	     AND  AL,CASEBIT	;CONVERT TO UPPER CASE BY DELETING THE 20H BIT
;	     MOV  [SI],AL	;RESTORE CHAR TO PARMLIST
;	  $ENDIF
;	  INC  SI		;BUMP INDEX TO LOOK AT NEXT CHAR
;      $ENDDO LOOP
;      POP  CX			;RESTORE COUNTER OF PARMS
;      POP  SI			;RESTORE POINTER TO PARMS
;   $ENDIF			;ANY CHARS IN PARMLIST?
;
;   RET
;UPCASE ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   FIXLIST LISTPARM,.LIST      ;						;
   HEADER <RESPOND TO PARAMETER> ;AC000;
DOFUNCTION PROC NEAR	       ;RESPOND TO PARM 				;AC000;
   PUBLIC DOFUNCTION
;INPUT: IF A CODEPAGE NUMBER WAS SPECIFIED
;	    BX = OFFSET TO LANGUAGE TABLE TO BE LOADED
;	    DX = INTEGER VALUE OF CODEPAGE SPECIFIED
;	 IF /STATUS WAS SPECIFIED
;	    BX = 0
;	 IF QUESTION MARK WAS SPECIFIED
;	    BX=-1
;	 If a parse error occurred,
;	    BX = 1

   ASSUME ES:CSEG

   ; Check for error.  Then check for /? option found by parser.
   ; If so, display the options message and exit.

   CMP	BX, RETCODE_PARSE_ERROR
   JE	$$EN22		       ; exit directly on error
   CMP	BX, RETCODE_QUESTION   ;IS QUESTION MARK SPECFIED?
   JNE $$IF22
   CALL HELP		       ;DISPLAY RESULTS OF "?" SPECIFICATION
   JMP SHORT $$EN22
$$IF22:

      CMP  BX,ZERO	       ;IS /STATUS SPECIFIED?
;     $IF  NE		       ;IF NOT STATUS, MUST BE REQUEST TO LOAD A TABLE
      JE $$IF24
	 LEA  DI,MSGNUM_PREVIOUS ;"Previous Code Page: xxx"
	 CALL SENDMSG	       ;SEND THE MSG TO STDOUT

	 MOV  DX,[BX].LANID    ;FETCH THE TWO CHAR ID FROM TABLE
	 CMP  DX,IDXXX	       ;IS THIS ONE ALREADY LOADED?
;	 $IF  NE	       ;IF NOT, LOAD IT
	 JE $$IF25

	    FIXLIST LISTPARM,.XLIST ;						;
;	       MOV  CX,LENGTH LANNAME ;GET LENGTH OF NAME FIELD
;	       LEA  SI,[BX].LANNAME ;GET WHERE NAME FIELD IS IN THE NEW TABLE
;	       LEA  DI,LANGUAGE_NAME ;WHERE WHERE TO PUT NAME IN VARIABLE MESSAGE FIELD
;	       REP  MOVSB      ;MOVE LANGUAGE NAME TO PRINTF VARIABLE FIELD
	    FIXLIST LISTPARM,.LIST ;						;

	    MOV  SI,BX	       ;PASS START OF CHAR TABLE
	    CALL MOVTAB        ;PUT THIS TABLE INTO THE USA POSITION

	    FIXLIST LISTPARM,.XLIST ;						;
;	       LEA  AX,MSG3    ;XXXXX VER OF GRAPHIC CHAR SET HAS JUST BEEN LOADED
	    FIXLIST LISTPARM,.LIST ;						;
	    LEA  DI,MSGNUM_ACTIVE ;"ACTIVE CODE PAGE: XXX"			;
	    MOV  AX,ACTIVECPID ;GET POINTER TO CP JUST ACTIVATED		;
	    MOV  SLIST_23.SUB_VALUE,AX ;INTO SUBLIST				;
	    CALL SENDMSG       ;SHOW "ACTIVE CODE PAGE: XXX"			;

	    CMP  BAD1F,RESET   ;THIS FLAG SET TO '1' MEANS INT 1FH POINTS TO
;	    $IF  E	       ; A TABLE OTHER THAN ONE LOADED BY GRAFTABL
	    JNE $$IF26
	       PUSH DS
	       ASSUME DS:NOTHING
	       LDS  DX,WHERE   ;SET DS:DX POINT TO PREVIOUSLY LOADED GRAFTABL FONT
	       MOV  AH,SET_VECT ;FUNCTION TO MOVE DS:DX INTO VECTOR FOR INT 1FH
	       MOV  AL,VEC_GRAF_CHAR ;INTERRUPT NUMBER TO RECEIVE NEW CONTENTS
	       INT  VEC_DOS    ;CHANGE THE VECTOR

	       POP  DS
	       ASSUME DS:CSEG
;	    $ENDIF	       ;BAD 1FH?
$$IF26:
;	 $ENDIF 	       ;THIS TABLE ALREADY LOADED?
$$IF25:
	 FIXLIST LISTPARM,.XLIST ;						;
;	    ADD  BX,SIZE LANGUAGE ;STEP BASE TO NEXT TABLE
;	    LEA  AX,COPYRIGHT  ;AT START OF MSGS, BEYOND LAST TABLE
;	    CMP  BX,AX
;	 $ENDLOOP AE	       ;GO TRY THE NEXT TABLE, IF ANY
;			       ;NOT ANY NEXT TABLE
;	    CALL BADPARMS      ;FUSS ABOUT INVALID PARMS
;
;	 $ENDSRCH	       ;COMPARING TOKEN WITH ID IN TABLES
	 FIXLIST LISTPARM,.LIST ;						;
;     $ELSE		       ;SINCE /STATUS SPECIFIED,
      JMP SHORT $$EN24
$$IF24:
	 LEA  DI,MSGNUM_ACTIVE ;POINT TO "ACTIVE CODE PAGE: XXX"
	 CALL SENDMSG	       ; VARIABLE FILLED BY "FINDTYPE"

	 CMP  IDXXX,ZERO       ;SEE WHO IS LOADED, IF ANYBODY
;	 $IF  E
	 JNE $$IF30
	    MOV  EXITFL,EXNONE ;SET EXIT CODE TO SAY NO TABLE LOADED AT ALL
;	 $ELSE		       ;SINCE SOMEONE IS LOADED,
	 JMP SHORT $$EN30
$$IF30:
	    MOV  EXITFL,EXDOS  ;SAY A TABLE IS LOADED
;	 $ENDIF 	       ;ANY TABLE PREVIOUSLY LOADED?
$$EN30:

;     $ENDIF		       ;/STATUS?
$$EN24:
;  $ENDIF		       ;QUESTION MARK?
$$EN22:
   RET
DOFUNCTION ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   HEADER <LOCAL SUBROUTINE, INSTALL A PARTICULAR TABLE>
MOVTAB PROC NEAR
   PUBLIC MOVTAB
;INPUT: SI = OFFSET OF SOURCE TABLE
;	ES = PSP
   ASSUME ES:CSEG
;OUTPUT: THE SOURCE TABLE WILL BE MOVED TO ONE OF TWO PLACES,
;	EITHER
;	(IF THIS IS THE FIRST TIME FOR GRAFTABL)
;	TO THE "TABLEUS" IN THE PSP (IF USA NOT SPECIFIED),
;	AND THEN BOTH INT2FH AND TABLEUS MOVED TO MOV_DEST IN THE PSP,
;	OR
;	ON TOP OF THE PREVIOUS TABLE LEFT BY A PREVIOUS GRAFTABL CALL,
;	AS POINTED TO BY THE VECTOR, "WHERE".

   PUSH ES		       ;SAVE THE PSP
   CMP	INSTALLED,LOADED       ;IF A PREVIOUS COPY OF GRAFTABL
;  $IF	E		       ; HAS ALREADY BEEN LOADED
   JNE $$IF35

      LES  DI,WHERE	       ;REMEMBER WHERE PREVIOUSLY TABLE WENT
      ASSUME ES:NOTHING        ;ES IS BASE OF OLD PREVIOUSLY LOADED TABLE
      MOV  CX,TABSIZE	       ;THE TABLE,2 CHAR ID,& LANGUAGE NAME ARE TO BE MOVED
      REP  MOVSB	       ;MOVE NEW TABLE ON TOP OF OLD TABLE
			       ;WHEN EXITING, LEAVE NOTHING RESIDENT
;  $ELSE		       ;SINCE NO PREVIOUS LOAD OF GRAFTABL EXISTS,
   JMP SHORT $$EN35
$$IF35:
      ASSUME ES:CSEG	       ;SINCE ES WAS NOT CHANGED,
      MOV  EXITFL,EXRES        ;WHEN EXITING, LEAVE TABLE RESIDENT
			       ; ALONG WITH THE INT2FH HANDLER

			       ;SINCE IT IS THE USA TABLE THAT IS
			       ; PHYSICALLY NEXT TO THE INTERRUPT HANDLER,
			       ; THAT PAIR OF AREAS IS WHAT WILL STAY
			       ; RESIDENT.  IF THE USA TABLE IS NOT THE
			       ; DESIRED VERSION, THEN FIRST MOVE THE
			       ; VERSION DESIRED ON TOP OF THE USA VERSION,
			       ; THEN MOVE THE PAIR DOWN ON TOP OF THE PSP
			       ; WHERE THEY WILL STAY RESIDENT.

      LEA  DI,TABLEUS	       ;FIND WHERE FIRST TABLE NOW IS
      CMP  SI,DI
;     $IF  NE		       ;IF NOT THE USA TABLE,
      JE $$IF37
	 MOV  CX,TABSIZE       ;SIZE OF THE TABLE
	 REP  MOVSB	       ;MOVE THE XX TABLE ONTO THE USA TABLE
;     $ENDIF
$$IF37:
      MOV  DI,OFFSET MOV_DEST  ;WHERE TO MOVE EVERYTHING TO
      LEA  SI,END_PSP	       ;START WITH THE INT2FH HANDLER, ON THRU THE TABLE
			       ;ES:DI POINT TO DESTINATION, DS:SI POINT TO SOURCE
      MOV  CX,RESSIZE_BYTE     ;GET SIZE OF TABLE + RESIDENT CODE INT HANDLER
      REP  MOVSB	       ;MOVE THE TABLE ONTO THE PSP OF THIS LOAD
;  $ENDIF
$$EN35:
   POP	ES		       ;RESTORE THE PSP POINTER TO ES
   RET
MOVTAB ENDP

; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   HEADER <HELP - GENERATE DISPLAY RESPONDING TO STATUS REQUEST>
HELP PROC NEAR
   PUBLIC HELP

;INPUT: DS, ES = POINTS TO PSP
;	IDXXX = CP OF WHO IS ALREADY LOADED
;	EXITFL = ERROR LEVEL RET CODE
;		NORMAL VALUE SAYS SOME TABLE HAS BEEN LOADED, BUT
;		INVALID PARMS COULD HAVE ALREADY ALTERED THIS VALUE.
;OUTPUT: EXITFL MAY BE CHANGED TO "EXNONE", IF NO TABLE LOADED
;
;NOTES:
;  04/24/90 c-PaulB: Modified this from handling a "?" on the command
;  line, to handling the standard "/?".  This function now displays
;  the help message and sets EXITFL for a fast way out, so the user
;  can try the command again.

   ASSUME ES:CSEG

   ; Set the exit flag so we can bail out
   ; after displaying the options help messages.

;   CMP	EXITFL,EXDOS	       ;IS RET CODE UNTOUCHED SO FAR?
;   JNE $$IF40
;      CMP  IDXXX,ZERO	       ;SEE WHO IS LOADED, IF ANYBODY
;      JNE $$IF41

   MOV  EXITFL,EXNONE    ;SET EXIT CODE TO SAY NO TABLE LOADED AT ALL

;$$IF41:
;$$IF40:

   FIXLIST LISTPARM,.XLIST     ;						;
   FIXLIST LISTPARM,.LIST      ;						;

   ; Display the options help message.
   ; Lines of the message are displayed starting
   ; with MSG_OPTIONS_FIRST through and including
   ; MSG_OPTIONS_LAST.  The numbers are defined
   ; in GRTABMS.INC, and the messages themselves
   ; are defined in GRAFTABL.SKL and the message files.

   lea	di, MSGNUM_HELP_OPTIONS		; point to options help msg struct
HelpMessageLoop:
   call	sendmsg				; display that message
   cmp	MSGNUM_HELP_OPTIONS.MSG_NUM, MSG_OPTIONS_LAST	; last msg to send?
   je	HelpMessageDone			;  done if so
   inc	MSGNUM_HELP_OPTIONS.MSG_NUM	; bump the message number
   jmp	short HelpMessageLoop		;  and go do the next message
HelpMessageDone:

   FIXLIST LISTPARM,.XLIST     ;						;
   FIXLIST LISTPARM,.LIST      ;					       ;
   RET
HELP ENDP


; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   FIXLIST LISTPARM,.XLIST     ;					       ;
;BADPARMS PROC NEAR
;   LEA  AX,MSG4		;"INCORRECT PARAMETER"
;   CALL SENDMSG
;
;   CALL HELP			;DISPLAY RESULTS OF "?" SPECIFICATION
;
;   MOV  EXITFL,EXPAR		;ERRORLEVEL CODE TO "PARM ERROR"
;   RET
;BADPARMS ENDP
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   FIXLIST LISTPARM,.LIST

   HEADER <SENDMSG - PASS IN REGS DATA FROM MSG DESCRIPTOR TO DISP MSG> ;
SENDMSG PROC NEAR	       ;						;
   PUBLIC SENDMSG	       ;						;
;INPUT - DI=POINTER TO MSG_DESC STRUC FOR THIS MESSAGE
;OUTPUT - IF CARRY SET, EXTENDED ERROR MSG ATTEMPTED DISPLAYED
;	   IF CARRY CLEAR, ALL OK
;	   IN EITHER CASE, DI AND AX ALTERED, OTHERS OK
;  =  =  =  =  =  =  =	=  =  =  =  =

   PUSH BX		       ; SAVE CALLER'S REGS                             ;
   PUSH CX		       ;						;
   PUSH DX		       ;						;
   PUSH SI		       ;						;

;		 PASS PARMS TO MESSAGE HANDLER IN
;		 THE APPROPRIATE REGISTERS IT NEEDS.
   MOV	AX,[DI].MSG_NUM        ;MESSAGE NUMBER					;
   MOV	BX,[DI].MSG_HANDLE     ;HANDLE TO DISPLAY TO				;
   MOV	SI,[DI].MSG_SUBLIST    ;OFFSET IN ES: OF SUBLIST, OR 0 IF NONE		;
   MOV	CX,[DI].MSG_COUNT      ;NUMBER OF %PARMS, 0 IF NONE			;
   MOV	DX,[DI].MSG_CLASS      ;CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW	;
   CALL SYSDISPMSG	       ;DISPLAY THE MESSAGE				;

;  $IF	C		       ;IF THERE IS A PROBLEM				;
   JNC $$IF44
			       ;AX=EXTENDED ERROR NUMBER			;
      LEA  DI,MSGNUM_EXTERR    ;GET REST OF ERROR DESCRIPTOR			;
      MOV  BX,[DI].MSG_HANDLE  ;HANDLE TO DISPLAY TO				;
      MOV  SI,[DI].MSG_SUBLIST ;OFFSET IN ES: OF SUBLIST, OR 0 IF NONE		;
      MOV  CX,[DI].MSG_COUNT   ;NUMBER OF %PARMS, 0 IF NONE			;
      MOV  DX,[DI].MSG_CLASS   ;CLASS IN HIGH BYTE, INPUT FUNCTION IN LOW	;
      CALL SYSDISPMSG	       ;TRY TO SAY WHAT HAPPENED			;

      STC		       ;REPORT PROBLEM					;
;  $ENDIF		       ;PROBLEM WITH DISPLAY?				;
$$IF44:

   POP	SI		       ;RESTORE CALLER'S REGISTERS                      ;
   POP	DX		       ;						;
   POP	CX		       ;						;
   POP	BX		       ;						;
   FIXLIST LISTPARM,.XLIST     ;						;
;;INPUT: AX = OFFSET OF MSG PARM LIST
;  PUSH AX
;  PUSH CS		       ;MATCH REQUIREMENTS OF PRINTF, WHICH IS "FAR"
;  CALL PRINTF		       ;USING MSG PARM LIST, BUILD MSG, DISPLAY MSG
;			       ;PRINTF WILL POP OFF THE PARM, PUSHED FROM AX
;
   FIXLIST LISTPARM,.LIST      ;						;

   RET			       ;						;
SENDMSG ENDP		       ;						;
   PATHLABL GRTAB	       ;
CSEG ENDS
   END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabml.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;AN000;A2
	TITLE	GRTABML - MULTI-LINGUAL EUROPEAN STANDARD ;AN000;
;This module is to be linked with the OBJ of GRTAB.SAL.  Refer to the
;Prolog of that module for more complete description.

;This module contains the binary description of the pixels that are used
;in graphics mode to define the multi-lingual character set when loaded to
;interrupt 1FH by the GRAFTABL command in DOS 3.3.
	IF1				;AN000;
	    %OUT    GRTABML.ASM...	;AN000;
	ELSE				;AN000;
;    %OUT GRTABML.ASM...
	ENDIF				;AN000;
CSEG	SEGMENT PARA PUBLIC		;AN000;
TABLEML EQU	THIS BYTE		;AN000;
	PUBLIC	TABLEML 		;AN000;

;(note: the display of the character to the right of the decimal number
;value of this location is not necessarily the graphic that these pixels
;will produce.	The displayed character is from the USA character set, and
;does not represent the language character set generated by this table.)

;These fonts are as defined in the Multi-lingual Code Page = 850.

;			     128   
	DB	00000000B		;AN000;
	DB	00111110B		;AN000;
	DB	01100000B		;AN000;
	DB	01100000B		;AN000;
	DB	01100000B		;AN000;
	DB	00111110B		;AN000;
	DB	00001100B		;AN000;
	DB	00111110B		;AN000;
;			     129   
	DB	00000000B		;AN000;
	DB	11001100B		;AN000;
	DB	00000000B		;AN000;
	DB	11001100B		;AN000;
	DB	11001100B		;AN000;
	DB	11001100B		;AN000;
	DB	01110110B		;AN000;
	DB	00000000B		;AN000;
.XLIST					;AN000;
;			     130   
	DB	00000000B		;AN000;
	DB	00011110B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11111100B		;AN000;
	DB	01111110B		;AN000;
	DB	00000000B		;AN000;
;			     131   
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	00011110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     132   
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	00011110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     133   
	DB	00000000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	00011110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     134   
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	00111000B		;AN000;
	DB	01111100B		;AN000;
	DB	00011110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     135   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111110B		;AN000;
	DB	01100000B		;AN000;
	DB	01100000B		;AN000;
	DB	00111110B		;AN000;
	DB	00001100B		;AN000;
	DB	00111110B		;AN000;
;			     136   
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11111100B		;AN000;
	DB	01111110B		;AN000;
	DB	00000000B		;AN000;
;			     137   
	DB	00000000B		;AN000;
	DB	11001100B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11111100B		;AN000;
	DB	01111110B		;AN000;
	DB	00000000B		;AN000;
;			     138   
	DB	00000000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11111100B		;AN000;
	DB	01111110B		;AN000;
	DB	00000000B		;AN000;
;			     139   
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	00111000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     140   
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     141   
	DB	00000000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     142   
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     143   
	DB	00011000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     144   
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	11111110B		;AN000;
	DB	01100000B		;AN000;
	DB	01111100B		;AN000;
	DB	01100000B		;AN000;
	DB	11111110B		;AN000;
	DB	00000000B		;AN000;
;			     145   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11101110B		;AN000;
	DB	00110011B		;AN000;
	DB	11011110B		;AN000;
	DB	01111111B		;AN000;
	DB	00000000B		;AN000;
;			     146   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	01111111B		;AN000;
	DB	11001100B		;AN000;
	DB	11111111B		;AN000;
	DB	11001100B		;AN000;
	DB	11001111B		;AN000;
	DB	00000000B		;AN000;
;			     147   
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     148   
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     149   
	DB	00000000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     150   
	DB	00000000B		;AN000;
	DB	01111110B		;AN000;
	DB	11000011B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     151   
	DB	00000000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     152   
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111110B		;AN000;
	DB	00000110B		;AN000;
	DB	01111100B		;AN000;
;			     153   
	DB	11000110B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	00000000B		;AN000;
;			     154   
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     155   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000010B		;AN000;
	DB	01111100B		;AN000;
	DB	11011110B		;AN000;
	DB	11110110B		;AN000;
	DB	01111100B		;AN000;
	DB	10000000B		;AN000;
;			     156   
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	01100100B		;AN000;
	DB	11110000B		;AN000;
	DB	01100000B		;AN000;
	DB	11100110B		;AN000;
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
;			     157   
	DB	00000000B		;AN000;
	DB	00000010B		;AN000;
	DB	01110100B		;AN000;
	DB	11001110B		;AN000;
	DB	11010110B		;AN000;
	DB	11100110B		;AN000;
	DB	01011100B		;AN000;
	DB	10000000B		;AN000;
;			     158   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     159   
	DB	00001110B		;AN000;
	DB	00011011B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	11011000B		;AN000;
	DB	01110000B		;AN000;
;			     160   
	DB	00000000B		;AN000;
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	00011110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111011B		;AN000;
	DB	00000000B		;AN000;
;			     161   
	DB	00000000B		;AN000;
	DB	00011110B		;AN000;
	DB	00000000B		;AN000;
	DB	00111000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     162   
	DB	00000000B		;AN000;
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     163   
	DB	00000000B		;AN000;
	DB	00011110B		;AN000;
	DB	00000000B		;AN000;
	DB	11001100B		;AN000;
	DB	11001100B		;AN000;
	DB	11001100B		;AN000;
	DB	01110110B		;AN000;
	DB	00000000B		;AN000;
;			     164   
	DB	00000000B		;AN000;
	DB	01110110B		;AN000;
	DB	11011100B		;AN000;
	DB	01111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     165   
	DB	01110110B		;AN000;
	DB	11011100B		;AN000;
	DB	01100110B		;AN000;
	DB	01110110B		;AN000;
	DB	01111110B		;AN000;
	DB	01101110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     166   
	DB	00111100B		;AN000;
	DB	01101100B		;AN000;
	DB	01101100B		;AN000;
	DB	00111110B		;AN000;
	DB	00000000B		;AN000;
	DB	01111110B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     167   
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	01101100B		;AN000;
	DB	00111000B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     168   
	DB	00110000B		;AN000;
	DB	00000000B		;AN000;
	DB	00110000B		;AN000;
	DB	01100000B		;AN000;
	DB	11000000B		;AN000;
	DB	11001100B		;AN000;
	DB	01111000B		;AN000;
	DB	00000000B		;AN000;
;			     169   
	DB	00111100B		;AN000;
	DB	01000010B		;AN000;
	DB	10111001B		;AN000;
	DB	10101101B		;AN000;
	DB	10111001B		;AN000;
	DB	10101101B		;AN000;
	DB	01000010B		;AN000;
	DB	00111100B		;AN000;
;			     170   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
	DB	00001100B		;AN000;
	DB	00001100B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     171   
	DB	11000011B		;AN000;
	DB	11000110B		;AN000;
	DB	11001100B		;AN000;
	DB	11011110B		;AN000;
	DB	00110011B		;AN000;
	DB	01100110B		;AN000;
	DB	11001100B		;AN000;
	DB	00001111B		;AN000;
;			     172   
	DB	11000011B		;AN000;
	DB	11000110B		;AN000;
	DB	11001100B		;AN000;
	DB	11011011B		;AN000;
	DB	00110111B		;AN000;
	DB	01101111B		;AN000;
	DB	11001111B		;AN000;
	DB	00000011B		;AN000;
;			     173   
	DB	00000000B		;AN000;
	DB	00011000B		;AN000;
	DB	00000000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00000000B		;AN000;
;			     174   
	DB	00000000B		;AN000;
	DB	00110011B		;AN000;
	DB	01100110B		;AN000;
	DB	11001100B		;AN000;
	DB	01100110B		;AN000;
	DB	00110011B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     175   
	DB	00000000B		;AN000;
	DB	11001100B		;AN000;
	DB	01100110B		;AN000;
	DB	00110011B		;AN000;
	DB	01100110B		;AN000;
	DB	11001100B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     176   
	DB	00100010B		;AN000;
	DB	10001000B		;AN000;
	DB	00100010B		;AN000;
	DB	10001000B		;AN000;
	DB	00100010B		;AN000;
	DB	10001000B		;AN000;
	DB	00100010B		;AN000;
	DB	10001000B		;AN000;
;			     177   
	DB	01010101B		;AN000;
	DB	10101010B		;AN000;
	DB	01010101B		;AN000;
	DB	10101010B		;AN000;
	DB	01010101B		;AN000;
	DB	10101010B		;AN000;
	DB	01010101B		;AN000;
	DB	10101010B		;AN000;
;			     178   
	DB	11011011B		;AN000;
	DB	01110111B		;AN000;
	DB	11011011B		;AN000;
	DB	11101110B		;AN000;
	DB	11011011B		;AN000;
	DB	01110111B		;AN000;
	DB	11011011B		;AN000;
	DB	11101110B		;AN000;
;			     179   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     180   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	11111000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     181   
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     182   
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     183   
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     184   
	DB	00111100B		;AN000;
	DB	01000010B		;AN000;
	DB	10111101B		;AN000;
	DB	10100001B		;AN000;
	DB	10100001B		;AN000;
	DB	10111101B		;AN000;
	DB	01000010B		;AN000;
	DB	00111100B		;AN000;
;			     185   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	11110110B		;AN000;
	DB	00000110B		;AN000;
	DB	11110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     186   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     187   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111110B		;AN000;
	DB	00000110B		;AN000;
	DB	11110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     188   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	11110110B		;AN000;
	DB	00000110B		;AN000;
	DB	11111110B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     189   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	01111110B		;AN000;
	DB	11000000B		;AN000;
	DB	11000000B		;AN000;
	DB	01111110B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     190   
	DB	11001100B		;AN000;
	DB	11001100B		;AN000;
	DB	01111000B		;AN000;
	DB	11111100B		;AN000;
	DB	00110000B		;AN000;
	DB	11111100B		;AN000;
	DB	00110000B		;AN000;
	DB	00110000B		;AN000;
;			     191   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     192   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     193   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     194   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     195   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011111B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     196   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     197   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	11111111B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     198   
	DB	00000000B		;AN000;
	DB	01110110B		;AN000;
	DB	11011100B		;AN000;
	DB	11111000B		;AN000;
	DB	00111100B		;AN000;
	DB	11001100B		;AN000;
	DB	01110110B		;AN000;
	DB	00000000B		;AN000;
;			     199   
	DB	00110110B		;AN000;
	DB	01101100B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
;			     200   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110111B		;AN000;
	DB	00110000B		;AN000;
	DB	00111111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     201   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111111B		;AN000;
	DB	00110000B		;AN000;
	DB	00110111B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     202   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	11110111B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     203   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	11110111B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     204   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110111B		;AN000;
	DB	00110000B		;AN000;
	DB	00110111B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     205   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     206   
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	11110111B		;AN000;
	DB	00000000B		;AN000;
	DB	11110111B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
	DB	00110110B		;AN000;
;			     207   
	DB	00000000B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	00000000B		;AN000;
;			     208   
	DB	00000000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111110B		;AN000;
	DB	00001100B		;AN000;
	DB	01111110B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	00000000B		;AN000;
;			     209   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
	DB	01100110B		;AN000;
	DB	11110110B		;AN000;
	DB	01100110B		;AN000;
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
;			     210   
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	11111110B		;AN000;
	DB	01100000B		;AN000;
	DB	01111100B		;AN000;
	DB	01100000B		;AN000;
	DB	11111110B		;AN000;
	DB	00000000B		;AN000;
;			     211   
	DB	11000110B		;AN000;
	DB	00000000B		;AN000;
	DB	11111110B		;AN000;
	DB	01100000B		;AN000;
	DB	01111100B		;AN000;
	DB	01100000B		;AN000;
	DB	11111110B		;AN000;
	DB	00000000B		;AN000;
;			     212   
	DB	11111000B		;AN000;
	DB	00000000B		;AN000;
	DB	01111111B		;AN000;
	DB	00110000B		;AN000;
	DB	00111110B		;AN000;
	DB	00110000B		;AN000;
	DB	01111111B		;AN000;
	DB	00000000B		;AN000;
;			     213   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     214   
	DB	00011110B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     215   
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     216   
	DB	01100110B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     217   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	11111000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     218   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00011111B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
;			     219   
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
;			     220   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
;			     221   
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00000000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00000000B		;AN000;
;			     222   
	DB	01111000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     223   
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	11111111B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     224   
	DB	00011111B		;AN000;
	DB	00000000B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	00000000B		;AN000;
;			     225   
	DB	00000000B		;AN000;
	DB	01111000B		;AN000;
	DB	11001100B		;AN000;
	DB	11111000B		;AN000;
	DB	11001100B		;AN000;
	DB	11111000B		;AN000;
	DB	11000000B		;AN000;
	DB	11000000B		;AN000;
;			     226   
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	00000000B		;AN000;
;			     227   
	DB	11111000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111110B		;AN000;
	DB	01100011B		;AN000;
	DB	01100011B		;AN000;
	DB	01100011B		;AN000;
	DB	00111110B		;AN000;
	DB	00000000B		;AN000;
;			     228   
	DB	00000000B		;AN000;
	DB	01110110B		;AN000;
	DB	11011100B		;AN000;
	DB	00111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     229   
	DB	01110110B		;AN000;
	DB	11011100B		;AN000;
	DB	01111100B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	11000110B		;AN000;
	DB	01111100B		;AN000;
	DB	00000000B		;AN000;
;			     230   
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01111100B		;AN000;
	DB	01100000B		;AN000;
	DB	11000000B		;AN000;
;			     231   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11100000B		;AN000;
	DB	01111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111100B		;AN000;
	DB	01100000B		;AN000;
	DB	11111000B		;AN000;
;			     232   
	DB	11110000B		;AN000;
	DB	01100000B		;AN000;
	DB	01111100B		;AN000;
	DB	01100110B		;AN000;
	DB	01111100B		;AN000;
	DB	01100000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
;			     233   
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     234   
	DB	01111110B		;AN000;
	DB	11000011B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     235   
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     236   
	DB	00000000B		;AN000;
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111110B		;AN000;
	DB	00000110B		;AN000;
	DB	01111100B		;AN000;
;			     237   
	DB	00001111B		;AN000;
	DB	00000000B		;AN000;
	DB	01100110B		;AN000;
	DB	01100110B		;AN000;
	DB	00111100B		;AN000;
	DB	00011000B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
;			     238   
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     239   
	DB	00001100B		;AN000;
	DB	00011000B		;AN000;
	DB	00110000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     240   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     241   
	DB	00110000B		;AN000;
	DB	00110000B		;AN000;
	DB	11111100B		;AN000;
	DB	00110000B		;AN000;
	DB	00110000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
;			     242   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
;			     243   
	DB	11100011B		;AN000;
	DB	00010110B		;AN000;
	DB	01110100B		;AN000;
	DB	00010011B		;AN000;
	DB	11100111B		;AN000;
	DB	00001111B		;AN000;
	DB	01101111B		;AN000;
	DB	11000011B		;AN000;
;			     244   
	DB	01111111B		;AN000;
	DB	11011011B		;AN000;
	DB	11011011B		;AN000;
	DB	01111011B		;AN000;
	DB	00011011B		;AN000;
	DB	00011011B		;AN000;
	DB	00011011B		;AN000;
	DB	00000000B		;AN000;
;			     245   
	DB	00111110B		;AN000;
	DB	01100011B		;AN000;
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	01101100B		;AN000;
	DB	00111000B		;AN000;
	DB	11001100B		;AN000;
	DB	01111000B		;AN000;
;			     246   
	DB	00110000B		;AN000;
	DB	00110000B		;AN000;
	DB	00000000B		;AN000;
	DB	11111100B		;AN000;
	DB	00000000B		;AN000;
	DB	00110000B		;AN000;
	DB	00110000B		;AN000;
	DB	00000000B		;AN000;
;			     247   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111000B		;AN000;
	DB	00001100B		;AN000;
	DB	11111000B		;AN000;
;			     248   
	DB	00111000B		;AN000;
	DB	01101100B		;AN000;
	DB	01101100B		;AN000;
	DB	00111000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     249   
	DB	11000110B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     250   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00011000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     251   
	DB	00110000B		;AN000;
	DB	01110000B		;AN000;
	DB	00110000B		;AN000;
	DB	00110000B		;AN000;
	DB	01111000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     252   
	DB	11110000B		;AN000;
	DB	00011000B		;AN000;
	DB	01110000B		;AN000;
	DB	00011000B		;AN000;
	DB	11110000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     253   
	DB	01110000B		;AN000;
	DB	11011000B		;AN000;
	DB	00110000B		;AN000;
	DB	01100000B		;AN000;
	DB	11111000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
.LIST					;AN000;
;			     254   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00111100B		;AN000;
	DB	00111100B		;AN000;
	DB	00111100B		;AN000;
	DB	00111100B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
;			     255   
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;
	DB	00000000B		;AN000;

	DW	850			;AN000;TABLE ID
	DB	"Multi-lingual",0	;AN000;LANGUAGE NAME, IN ASCIIZ FORMAT
	IF	($-CSEG) MOD 16 	;AN000;IF NOT ALREADY ON 16 BYTE BOUNDARY
	    DB	    (16-(($-CSEG) MOD 16)) DUP(0) ;AN000;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	ENDIF				;AN000;
CSEG	ENDS				;AN000;
	END				;AN000;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabcf.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTABCF - CANADIAN FRENCH CHARACTER SET FOR GRAFTABL COMMAND
;This module is to be linked with the OBJ of GRTAB.SAL.  Refer to the
;Prolog of that module for more complete description.

;This module contains the binary description of the pixels that are used
;in graphics mode to define the Canadian French character set when loaded to
;interrupt 1FH by the GRAFTABL command in DOS 3.3.
	IF1
	    %OUT    GRTABCF.ASM...
	ELSE
;    $OUT GRTABCF.ASM...
	ENDIF
CSEG	SEGMENT PARA PUBLIC
TABLECF EQU	THIS BYTE
	PUBLIC	TABLECF

;(note: the display of the character to the right of the decimal number
;value of this location is not necessarily the graphic that these pixels
;will produce.	The displayed character is from the USA character set, and
;does not represent the language character set generated by this table.)

;These fonts are as defined in the Canadian French Code Page = 863.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	8 x 8 Character Set information
;	for the 5153 A/N and low-res APA
;
;	CODE NAME: CARIBOU (L'ACCENT)
;	CODE PAGE: 863
;	DATE:	   12-06-86
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;			     128   
	DB	01111000B
	DB	11001100B
	DB	11000000B
	DB	11000000B
	DB	11001100B
	DB	01111000B
	DB	00011000B
	DB	01110000B
;			     129   
	DB	00000000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     130   
	DB	00110000B
	DB	01100000B
	DB	01111000B
	DB	11001100B
	DB	11111100B
	DB	11000000B
	DB	01111000B
	DB	00000000B
;			     131   
	DB	01111100B
	DB	11000110B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     132   
	DB	01111100B
	DB	11000110B
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11111110B
	DB	11000110B
	DB	00000000B
;			     133   
	DB	00110000B
	DB	00011000B
	DB	01111000B
	DB	00001100B
	DB	01111100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     134   
	DB	01111111B
	DB	11011011B
	DB	11011011B
	DB	01111011B
	DB	00011011B
	DB	00011011B
	DB	00011011B
	DB	00000000B
;			     135   
	DB	00000000B
	DB	00000000B
	DB	01111100B
	DB	11000000B
	DB	11000000B
	DB	01111100B
	DB	00011000B
	DB	01110000B
;			     136   
	DB	01111110B
	DB	11000011B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;			     137   
	DB	01100110B
	DB	00000000B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;			     138   
	DB	00011000B
	DB	00001100B
	DB	00111100B
	DB	01100110B
	DB	01111110B
	DB	01100000B
	DB	00111100B
	DB	00000000B
;			     139   
	DB	01100110B
	DB	00000000B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;			     140   
	DB	01111100B
	DB	11000110B
	DB	00111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;			     141   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
;			     142   
	DB	00011000B
	DB	00001100B
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11111110B
	DB	11000110B
	DB	00000000B
;			     143   
	DB	00111110B
	DB	01100011B
	DB	00111000B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	11001100B
	DB	01111000B
;			     144   
	DB	00011000B
	DB	00110000B
	DB	11111100B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	11111100B
	DB	00000000B
;			     145   
	DB	01100000B
	DB	00110000B
	DB	11111100B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	11111100B
	DB	00000000B
;			     146   
	DB	01111100B
	DB	11000110B
	DB	11111100B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	11111100B
	DB	00000000B
;			     147   
	DB	01111000B
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     148   
	DB	11001100B
	DB	00000000B
	DB	11111100B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	11111100B
	DB	00000000B
;			     149   
	DB	11001100B
	DB	00000000B
	DB	01111000B
	DB	00110000B
	DB	00110000B
	DB	00110000B
	DB	01111000B
	DB	00000000B
;			     150   
	DB	01111000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     151   
	DB	01100000B
	DB	00110000B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     152   
	DB	00000000B
	DB	11000110B
	DB	01111100B
	DB	11000110B
	DB	11000110B
	DB	01111100B
	DB	11000110B
	DB	00000000B
;			     153   
	DB	01111100B
	DB	10000010B
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	01101100B
	DB	00111000B
	DB	00000000B
;			     154   
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     155   
	DB	00011000B
	DB	00011000B
	DB	01111110B
	DB	11000000B
	DB	11000000B
	DB	01111110B
	DB	00011000B
	DB	00011000B
;			     156   
	DB	00111000B
	DB	01101100B
	DB	01100100B
	DB	11110000B
	DB	01100000B
	DB	11100110B
	DB	11111100B
	DB	00000000B
;			     157   
	DB	01100000B
	DB	00110000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     158   
	DB	01111000B
	DB	11001100B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     159   
	DB	00001110B
	DB	00011011B
	DB	00011000B
	DB	00111100B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	01110000B
;			     160   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     161   
	DB	00001100B
	DB	00011000B
	DB	00110000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     162   
	DB	00011000B
	DB	00110000B
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     163   
	DB	00011000B
	DB	00110000B
	DB	00000000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	01111110B
	DB	00000000B
;			     164   
	DB	00000000B
	DB	11000110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     165   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00001100B
	DB	01111000B
;			     166   
	DB	01110000B
	DB	00011000B
	DB	01110000B
	DB	00011000B
	DB	01110000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     167   
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     168   
	DB	01111110B
	DB	10000001B
	DB	00111100B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00111100B
	DB	00000000B
;			     169   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	11000000B
	DB	11000000B
	DB	00000000B
	DB	00000000B
;			     170   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00000110B
	DB	00000110B
	DB	00000000B
	DB	00000000B
;			     171   
	DB	11100001B
	DB	01100010B
	DB	01100100B
	DB	01101110B
	DB	00010011B
	DB	00100110B
	DB	01001100B
	DB	10001111B
;			     172   
	DB	11100001B
	DB	01100010B
	DB	01100100B
	DB	01101010B
	DB	00010110B
	DB	00101010B
	DB	01011111B
	DB	10000010B
;			     173   
	DB	11100001B
	DB	00110010B
	DB	01100100B
	DB	00111010B
	DB	11110110B
	DB	00101010B
	DB	01011111B
	DB	10000010B
;			     174   
	DB	00000000B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	00000000B
	DB	00000000B
;			     175   
	DB	00000000B
	DB	11001100B
	DB	01100110B
	DB	00110011B
	DB	01100110B
	DB	11001100B
	DB	00000000B
	DB	00000000B
;			     176   
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
	DB	00100010B
	DB	10001000B
;			     177   
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
	DB	01010101B
	DB	10101010B
;			     178   
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B
	DB	11011011B
	DB	01110111B
	DB	11011011B
	DB	11101110B
;			     179   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     180   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     181   
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     182   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     183   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     184   
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     185   
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     186   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     187   
	DB	00000000B
	DB	00000000B
	DB	11111110B
	DB	00000110B
	DB	11110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     188   
	DB	00110110B
	DB	00110110B
	DB	11110110B
	DB	00000110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     189   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111110B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     190   
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     191   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     192   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     193   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     194   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     195   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     196   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     197   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     198   
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     199   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     200   
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     201   
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     202   
	DB	00110110B
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     203   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     204   
	DB	00110110B
	DB	00110110B
	DB	00110111B
	DB	00110000B
	DB	00110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     205   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     206   
	DB	00110110B
	DB	00110110B
	DB	11110111B
	DB	00000000B
	DB	11110111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     207   
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     208   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     209   
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00000000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     210   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     211   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     212   
	DB	00011000B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     213   
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     214   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     215   
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	00110110B
	DB	11111111B
	DB	00110110B
	DB	00110110B
	DB	00110110B
;			     216   
	DB	00011000B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	11111111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     217   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     218   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011111B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     219   
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
;			     220   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
;			     221   
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
	DB	11110000B
;			     222   
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
	DB	00001111B
;			     223   
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	11111111B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     224   
	DB	00000000B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	11001000B
	DB	11011100B
	DB	01110110B
	DB	00000000B
;			     225   
	DB	00000000B
	DB	01111000B
	DB	11001100B
	DB	11111000B
	DB	11001100B
	DB	11111000B
	DB	11000000B
	DB	11000000B
;			     226   
	DB	00000000B
	DB	11111100B
	DB	11001100B
	DB	11000000B
	DB	11000000B
	DB	11000000B
	DB	11000000B
	DB	00000000B
;			     227   
	DB	00000000B
	DB	11111110B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B
;			     228   
	DB	11111100B
	DB	11001100B
	DB	01100000B
	DB	00110000B
	DB	01100000B
	DB	11001100B
	DB	11111100B
	DB	00000000B
;			     229   
	DB	00000000B
	DB	00000000B
	DB	01111110B
	DB	11011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B
	DB	00000000B
;			     230   
	DB	00000000B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01100110B
	DB	01111100B
	DB	01100000B
	DB	11000000B
;			     231   
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
;			     232   
	DB	11111100B
	DB	00110000B
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00110000B
	DB	11111100B
;			     233   
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11111110B
	DB	11000110B
	DB	01101100B
	DB	00111000B
	DB	00000000B
;			     234   
	DB	00111000B
	DB	01101100B
	DB	11000110B
	DB	11000110B
	DB	01101100B
	DB	01101100B
	DB	11101110B
	DB	00000000B
;			     235   
	DB	00011100B
	DB	00110000B
	DB	00011000B
	DB	01111100B
	DB	11001100B
	DB	11001100B
	DB	01111000B
	DB	00000000B
;			     236   
	DB	00000000B
	DB	00000000B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	00000000B
	DB	00000000B
;			     237   
	DB	00000110B
	DB	00001100B
	DB	01111110B
	DB	11011011B
	DB	11011011B
	DB	01111110B
	DB	01100000B
	DB	11000000B
;			     238   
	DB	00111000B
	DB	01100000B
	DB	11000000B
	DB	11111000B
	DB	11000000B
	DB	01100000B
	DB	00111000B
	DB	00000000B
;			     239   
	DB	01111000B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	11001100B
	DB	00000000B
;			     240   
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	00000000B
;			     241   
	DB	00110000B
	DB	00110000B
	DB	11111100B
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
;			     242   
	DB	01100000B
	DB	00110000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
;			     243   
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	00110000B
	DB	00011000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
;			     244   
	DB	00001110B
	DB	00011011B
	DB	00011011B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
;			     245   
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	00011000B
	DB	11011000B
	DB	11011000B
	DB	01110000B
;			     246   
	DB	00110000B
	DB	00110000B
	DB	00000000B
	DB	11111100B
	DB	00000000B
	DB	00110000B
	DB	00110000B
	DB	00000000B
;			     247   
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	01110110B
	DB	11011100B
	DB	00000000B
	DB	00000000B
;			     248   
	DB	00111000B
	DB	01101100B
	DB	01101100B
	DB	00111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     249   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     250   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00011000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     251   
	DB	00001111B
	DB	00001100B
	DB	00001100B
	DB	00001100B
	DB	11101100B
	DB	01101100B
	DB	00111100B
	DB	00011100B
;			     252   
	DB	01111000B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	01101100B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     253   
	DB	01110000B
	DB	00011000B
	DB	00110000B
	DB	01100000B
	DB	01111000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;			     254   
	DB	00000000B
	DB	00000000B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00111100B
	DB	00000000B
	DB	00000000B
;			     255   
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
	DB	00000000B
;
	DW	863			;TABLE ID
;	include graftcfm.inc
	DB	"Can. French",0 	;LANGUAGE NAME, IN ASCIIZ FORMAT
;(the above "DB" is an example of the ENGLISH version of the above include file)
	IF	($-CSEG) MOD 16 	;IF NOT ALREADY ON 16 BYTE BOUNDARY
	    DB	    (16-(($-CSEG) MOD 16)) DUP(0) ;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	ENDIF
CSEG	ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabee.asm ===
PAGE	90,132			;A2
	TITLE	GRTABEE - LATIN 2 CHARACTER SET
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */

;This module is to be linked with the OBJ of GRTAB.ASM.  Refer to the
;Prolog of that module for more complete description.

;This module contains the binary description of the pixels that are used
;in graphics mode to define the multi-lingual character set when loaded to
;interrupt 1FH by the GRAFTABL command in DOS 3.3.
	IF1
	    %OUT    GRTABEE.ASM...
	ELSE
;    %OUT GRTABEE.ASM...
	ENDIF
CSEG	SEGMENT PARA PUBLIC
TABLEEE EQU	THIS BYTE
	PUBLIC	TABLEEE

;(note: the display of the character to the right of the decimal number
;value of this location is not necessarily the graphic that these pixels
;will produce.	The displayed character is from the USA character set, and
;does not represent the language character set generated by this table.)

;These fonts are as defined in the LATIN 2 Code Page = 852.

;       *** HEX 80 ***
        DB      00111100B    ;128   C sedilla
        DB      01100110B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      01100110B
        DB      00111100B
        DB      00001100B
;
;       *** HEX 81 ***
        DB      11001100B   ;129 
        DB      00000000B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      01110110B
        DB      00000000B
;
;       *** HEX 82 ***
        DB      00011100B    ;130 
        DB      00000000B
        DB      01111000B
        DB      11001100B
        DB      11111100B
        DB      11000000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 83 ***
        DB      01111000B    ;131 
        DB      10000100B
        DB      01111000B
        DB      00001100B
        DB      01111100B
        DB      11001100B
        DB      01110110B
        DB      00000000B
;
;       *** HEX 84 ***
        DB      11001100B    ;132 
        DB      00000000B
        DB      01111000B
        DB      00001100B
        DB      01111100B
        DB      11001100B
        DB      01111110B
        DB      00000000B
;
;       *** HEX 85 ***       chnaged
        DB      00110000B    ;133 u circle
        DB      11001100B
        DB      00110000B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      01110110B
        DB      00000000B
;
;       *** HEX 86 ***       changed
        DB      00001100B    ;134 c acute
        DB      00110000B
        DB      00111100B
        DB      11000110B
        DB      11000000B
        DB      11000110B
        DB      00111100B
        DB      00000000B
;
;       *** HEX 87 ***
        DB      00000000B    ;135 
        DB      00000000B
        DB      01111000B
        DB      11001100B
        DB      11000000B
        DB      11001100B
        DB      01111000B
        DB      00011000B
;
;       *** HEX 88 ***       changed
        DB      00110000B    ;136 l slash
        DB      00110110B
        DB      00111100B
        DB      00111000B
        DB      00110000B
        DB      01110000B
        DB      11011100B
        DB      00000000B
;
;       *** HEX 89 ***
        DB      11001100B    ;137 
        DB      00000000B
        DB      01111000B
        DB      11001100B
        DB      11111100B
        DB      11000000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 8A ***       changed
        DB      11101110B    ;138 O double acute
        DB      10001000B
        DB      01111100B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX 8B ***       changed
        DB      11101110B    ;139 o with double acute
        DB      10001000B
        DB      01111000B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 8C ***
        DB      01110000B   ;140 
        DB      10001000B
        DB      01110000B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 8D ***      changed
        DB      00011100B   ;141 Z acute
        DB      00010000B
        DB      11111110B
        DB      00001100B
        DB      00110000B
        DB      01100000B
        DB      11111110B
        DB      00000000B
;
;       *** HEX 8E ***
        DB      11000110B   ;142 
        DB      00111000B
        DB      01101100B
        DB      11000110B
        DB      11111110B
        DB      11000110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX 8F ***      changed
        DB      00011100B   ;143 C acute
        DB      00010000B
        DB      01111100B
        DB      11000110B
        DB      11000000B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX 90 ***      changed
        DB      00011100B   ;144 
        DB      00010000B
        DB      11111100B
        DB      01100000B
        DB      01111000B
        DB      01100000B
        DB      11111100B
        DB      00000000B
;
;       *** HEX 91 ***      changed
        DB      11001110B   ;145 
        DB      11001000B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      11111110B
        DB      00000000B
;
;       *** HEX 92 ***      CHANGED
        DB      11001110B   ;146 l acute
        DB      11001000B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 93 ***
        DB      01111000B   ;147 
        DB      11001100B
        DB      00000000B
        DB      01111000B
        DB      11001100B
        DB      11001100B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 94 ***
        DB      11001100B   ;148 
        DB      00000000B
        DB      01111000B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 95 ***      changed
        DB      11010010B   ;149 L caron
        DB      11001100B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      11111110B
        DB      00000000B
;
;       *** HEX 96 ***      changed
        DB      11010010B   ;150 l caron
        DB      11001100B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      11000000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX 97 ***      CHANGED
        DB      00011100B   ;151 S ACUTE
        DB      00010000B
        DB      01111110B
        DB      11000000B
        DB      01111100B
        DB      00000110B
        DB      11111100B
        DB      00000000B
;
;       *** HEX 98 ***      changed
        DB      00011100B   ;152 s acute
        DB      00010000B
        DB      00111110B
        DB      01100000B
        DB      00111100B
        DB      00000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX 99 ***      changed
        DB      11000110B   ;153 
        DB      01111100B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX 9A ***      changed
        DB      11000110B   ;154 
        DB      00000000B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX 9B ***      changed
        DB      01001000B   ;155 T caron
        DB      00110000B
        DB      11111100B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      00000000B
;
;       *** HEX 9C ***      changed
        DB      01001000B   ;156 t caron
        DB      00110000B
        DB      00110000B
        DB      11111100B
        DB      00110000B
        DB      00110000B
        DB      00011110B
        DB      00000000B
;
;       *** HEX 9D ***      chnaged
        DB      01100000B   ;157 L stroke
        DB      01101100B
        DB      01111000B
        DB      01110000B
        DB      01100000B
        DB      11100000B
        DB      01111110B
        DB      00000000B
;
;       *** HEX 9E ***
        DB      00000000B   ;158   multiply
        DB      11000110B
        DB      01101100B
        DB      00111000B
        DB      01101100B
        DB      11000110B
        DB      00000000B
        DB      00000000B
;
;       *** HEX 9F ***      chnaged
        DB      00100100B   ;159   c caron
        DB      00011000B
        DB      00111100B
        DB      01100110B
        DB      01100000B
        DB      01100110B
        DB      00111100B
        DB      00000000B
;
;       *** HEX A0 ***      changed
        DB      00011100B   ;160 
        DB      00010000B
        DB      01111000B
        DB      00001100B
        DB      01111100B
        DB      11001100B
        DB      01111110B
        DB      00000000B
;
;       *** HEX A1 ***      changed
        DB      00011100B   ;161 
        DB      00010000B
        DB      00111000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00111100B
        DB      00000000B
;
;       *** HEX A2 ***      changed
        DB      00000000B   ;162 
        DB      00011100B
        DB      00010000B
        DB      01111000B
        DB      11001100B
        DB      11001100B
        DB      01111000B
        DB      00000000B
;
;       *** HEX A3 ***      changed
        DB      00000000B   ;163 
        DB      00011100B
        DB      00010000B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      01111110B
        DB      00000000B
;
;       *** HEX A4 ***      changed
        DB      00111000B   ;164 A foot
        DB      01101100B
        DB      11000110B
        DB      11111110B
        DB      11000110B
        DB      11010110B
        DB      00001100B
        db      00001110b
;
;       *** HEX A5 ***      changed
        DB      00000000B   ;165 a foot
        DB      00000000B
        DB      01111000B
        DB      00001100B
        DB      01111100B
        DB      11001100B
        DB      01110110B
        DB      00001111B
;
;       *** HEX A6 ***      changed
        DB      00100100B   ;166 Z caron
        DB      00011000B
        DB      11111110B
        DB      00001100B
        DB      00011000B
        DB      01100000B
        DB      11111110B
        DB      00000000B
;
;       *** HEX A7 ***      chnaged
        DB      00100100B   ;167 z caron
        DB      00011000B
        DB      00000000B
        DB      01111110B
        DB      00001100B
        DB      00110000B
        DB      01111110B
        DB      00000000B
;
;       *** HEX A8 ***      changed
        DB      11111110B   ;168 E foot
        DB      11000000B
        DB      11000000B
        DB      11111000B
        DB      11000000B
        DB      11000000B
        DB      11111110B
        DB      00011100B
;
;       *** HEX A9 ***      changed
        DB      00000000B   ;169  e foot
        DB      00000000B
        DB      01111000B
        DB      11001100B
        DB      11111100B
        DB      11000000B
        DB      01111000B
        DB      00011100B
;

;       *** HEX AA ***      changed
        DB      00000000B   ;170  not defined
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX AB ***      changed
        DB      00011100B   ;171  z acute
        DB      00010000B
        DB      00000000B
        DB      01111110B
        DB      00001100B
        DB      00110000B
        DB      01111110B
        DB      00000000B
;
;       *** HEX AC ***      changed
        DB      00100100B   ;172  C caron
        DB      00011000B
        DB      01111100B
        DB      11000110B
        DB      11000000B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX AD ***      changed
        DB      00000000B   ;173 s foot
        DB      00000000B
        DB      00111100B
        DB      11000000B
        DB      01111000B
        DB      00001100B
        DB      11111000B
        DB      00111000B
;
;       *** HEX AE ***
        DB      00000000B   ;174   
        DB      00110011B
        DB      01100110B
        DB      11001100B
        DB      01100110B
        DB      00110011B
        DB      00000000B
        DB      00000000B
;
;       *** HEX AF ***
        DB      00000000B   ;175     *
        DB      11001100B
        DB      01100110B
        DB      00110011B
        DB      01100110B
        DB      11001100B
        DB      00000000B
        DB      00000000B
;
;       *** HEX B0 ***
        DB      00100010B   ;176 
        DB      10001000B
        DB      00100010B
        DB      10001000B
        DB      00100010B
        DB      10001000B
        DB      00100010B
        DB      10001000B
;
;       *** HEX B1 ***
        DB      01010101B   ;177 
        DB      10101010B
        DB      01010101B
        DB      10101010B
        DB      01010101B
        DB      10101010B
        DB      01010101B
        DB      10101010B
;
;       *** HEX B2 ***
        DB      11011011B   ;178 
        DB      01110111B
        DB      11011011B
        DB      11101110B
        DB      11011011B
        DB      01110111B
        DB      11011011B
        DB      11101110B
;
;       *** HEX B3 ***
        DB      00011000B   ;179 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX B4 ***
        DB      00011000B   ;180 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      11111000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX B5 ***
        DB      00011100B   ;181 A grave
        DB      00010000B
        DB      01111100B
        DB      11000110B
        DB      11111110B
        DB      11000110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX B6 ***
        DB      01111100B   ;182 A circumflex
        DB      10000010B
        DB      01111100B
        DB      11000110B
        DB      11111110B
        DB      11000110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX B7 ***      changed
        DB      01001000B   ;183 E caron
        DB      00110000B
        DB      11111110B
        DB      11000000B
        DB      11111000B
        DB      11000000B
        DB      11111110B
        DB      00000000B
;
;       *** HEX B8 ***
        DB      01111000B   ;184 S foot
        DB      11001100B
        DB      01100000B
        DB      00110000B
        DB      00011000B
        DB      11001100B
        DB      01111000B
        DB      00110000B
;
;       *** HEX B9 ***
        DB      00110110B   ;185 
        DB      00110110B
        DB      11110110B
        DB      00000110B
        DB      11110110B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX BA ***
        DB      00110110B   ;186 
        DB      00110110B
        DB      00110110B
        DB      00110110B
        DB      00110110B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX BB ***
        DB      00000000B   ;187 
        DB      00000000B
        DB      11111110B
        DB      00000110B
        DB      11110110B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX BC ***
        DB      00110110B   ;188 
        DB      00110110B
        DB      11110110B
        DB      00000110B
        DB      11111110B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX BD ***
        DB      00011000B   ;189 Z overdot
        DB      11111110B
        DB      11000110B
        DB      00001100B
        DB      00110000B
        DB      11000110B
        DB      11111110B
        DB      00000000B
;
;       *** HEX BE ***      changed
        DB      00000000B   ;190 z overdot
        DB      00011000B
        DB      00000000B
        DB      01111100B
        DB      00011000B
        DB      00110000B
        DB      01111100B
        DB      00000000B
;
;       *** HEX BF ***
        DB      00000000B   ;191 
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      11111000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX C0 ***
        DB      00011000B   ;192 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX C1 ***
        DB      00011000B   ;193 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      11111111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX C2 ***
        DB      00000000B   ;194 
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      11111111B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX C3 ***
        DB      00011000B   ;195 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011111B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX C4 ***
        DB      00000000B   ;196 
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      11111111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX C5 ***
        DB      00011000B   ;197 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      11111111B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX C6 ***      changed
        DB      11000110B   ;198 A breve
        DB      01111100B
        DB      01111100B
        DB      11000110B
        DB      11111110B
        DB      11000110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX C7 ***      changed
        DB      11001100B   ;199 a breve
        DB      01111000B
        DB      01111000B
        DB      00001100B
        DB      01111100B
        DB      11001100B
        DB      01110110B
        DB      00000000B
;
;       *** HEX C8 ***
        DB      00110110B   ;200 
        DB      00110110B
        DB      00110111B
        DB      00110000B
        DB      00111111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX C9 ***
        DB      00000000B   ;201 
        DB      00000000B
        DB      00111111B
        DB      00110000B
        DB      00110111B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX CA ***
        DB      00110110B  ;202 
        DB      00110110B
        DB      11110111B
        DB      00000000B
        DB      11111111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX CB ***
        DB      00000000B  ;203 
        DB      00000000B
        DB      11111111B
        DB      00000000B
        DB      11110111B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX CC ***
        DB      00110110B   ;204 
        DB      00110110B
        DB      00110111B
        DB      00110000B
        DB      00110111B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX CD ***
        DB      00000000B   ;205 
        DB      00000000B
        DB      11111111B
        DB      00000000B
        DB      11111111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX CE ***
        DB      00110110B  ;206 
        DB      00110110B
        DB      11110111B
        DB      00000000B
        DB      11110111B
        DB      00110110B
        DB      00110110B
        DB      00110110B
;
;       *** HEX CF ***
        DB      00000000B   ;207 currency symbol
        DB      01000010B
        DB      00111100B
        DB      01100110B
        DB      01100110B
        DB      00111100B
        DB      01000010B
        DB      00000000B
;
;       *** HEX D0 ***      changed
        DB      00001100B   ;208 d dash
        DB      00111110B
        DB      00001100B
        DB      01111100B
        DB      11001100B
        DB      11001100B
        DB      01110110B
        DB      00000000B
;
;       *** HEX D1 ***      changed
        DB      01111100B   ;209 D dash
        DB      01100110B
        DB      01100110B
        DB      11110110B
        DB      01100110B
        DB      01100110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX D2 ***      changed
        DB      01001000B   ;210 D caron
        DB      00110000B
        DB      11111100B
        DB      01100110B
        DB      01100110B
        DB      01100110B
        DB      11111100B
        DB      00000000B
;
;       *** HEX D3 ***
        DB      11001100B   ;211 
        DB      00000000B
        DB      11111100B
        DB      01100000B
        DB      01111000B
        DB      01100000B
        DB      11111100B
        DB      00000000B
;
;       *** HEX D4 ***      changed
        DB      10010110B   ;212 d caron
        DB      01100110B
        DB      00000110B
        DB      01111110B
        DB      11000110B
        DB      11000110B
        DB      01111110B
        DB      00000000B
;
;       *** HEX D5 ***      changed
        DB      00100100B   ;213 N caron
        DB      00011000B
        DB      11100110B
        DB      11110110B
        DB      11011110B
        DB      11001110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX D6 ***
        DB      00011100B   ;214 I acute
        DB      00010000B
        DB      01111000B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX D7 ***
        DB      01111000B   ;215 I Circumflex
        DB      10000100B
        DB      01111000B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX D8 ***      changed
        DB      01001000B   ;216 e caron
        DB      00110000B
        DB      01111000B
        DB      11001100B
        DB      11111100B
        DB      11000000B
        DB      01111000B
        DB      00000000B
;
;       *** HEX D9 ***
        DB      00011000B   ;217 
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      11111000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX DA ***
        DB      00000000B  ;218 
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00011111B
        DB      00011000B
        DB      00011000B
        DB      00011000B
;
;       *** HEX DB ***
        DB      11111111B   ;219 
        DB      11111111B
        DB      11111111B
        DB      11111111B
        DB      11111111B
        DB      11111111B
        DB      11111111B
        DB      11111111B
;
;       *** HEX DC ***
        DB      00000000B  ;220 
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      11111111B
        DB      11111111B
        DB      11111111B
        DB      11111111B
;
;       *** HEX DD ***      changed
        DB      01111110B   ;221 T foot
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00011000B
        DB      00001110B
;
;       *** HEX DE ***      chnaged
        DB      00010000B   ;222 U circle
        DB      00101000B
        DB      11010110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX DF ***
        DB      11111111B   ;223 
        DB      11111111B
        DB      11111111B
        DB      11111111B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX E0 ***      changed
        DB      00011100B   ;224 O acute
        DB      00010000B
        DB      01111100B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX E1 ***
        DB      00000000B   ;225 
        DB      01111000B
        DB      11001100B
        DB      11111000B
        DB      11001100B
        DB      11111000B
        DB      11000000B
        DB      11000000B
;
;       *** HEX E2 ***      changed
        DB      01111100B   ;226 O circumflex
        DB      10000010B
        DB      01111100B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX E3 ***     changed
        DB      00011100B   ;227 N acute
        DB      00010000B
        DB      11100110B
        DB      11110110B
        DB      11011110B
        DB      11001110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX E4 ***      changed
        DB      00011100B   ;228 n acute
        DB      00010000B
        DB      11011100B
        DB      11100110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX E5 ***      changed
        DB      00100100B   ;228 n caron
        DB      00011000B
        DB      11011100B
        DB      11100110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      00000000B
;
;       *** HEX E6 ***      changed
        DB      01001000B   ;230 S caron
        DB      00110000B
        DB      01111110B
        DB      11100000B
        DB      00111000B
        DB      00001110B
        DB      11111100B
        DB      00000000B
;
;       *** HEX E7 ***      changed
        DB      01001000B   ;231 s caron
        DB      00110000B
        DB      01111100B
        DB      01000000B
        DB      00111000B
        DB      00000100B
        DB      01111100B
        DB      00000000B
;
;       *** HEX E8 ***      changed
        DB      00011100B   ;232 R acute
        DB      00010000B
        DB      11111100B
        DB      11000110B
        DB      11111100B
        DB      11011000B
        DB      11001100B
        DB      00000000B
;
;       *** HEX E9 ***      chnaged
        DB      00001110B   ;233 U acute
        DB      00001000B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX EA ***      changed
        DB      00111000B   ;234 r acute
        DB      00100000B
        DB      11001110B
        DB      11110000B
        DB      11100000B
        DB      11000000B
        DB      11000000B
        DB      00000000B
;
;       *** HEX EB ***      changed
        DB      11101110B   ;235 U dbl acute
        DB      10001000B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      11000110B
        DB      01111100B
        DB      00000000B
;
;       *** HEX EC ***      chnaged
        DB      00011100B   ;236 y acute
        DB      00010000B
        DB      11000110B
        DB      11000110B
        DB      01100110B
        DB      00111110B
        DB      00001100B
        DB      01111000B
;
;       *** HEX ED ***      changed
        DB      00011100B   ;237 Y acute
        DB      11010110B
        DB      11000110B
        DB      01100110B
        DB      00111100B
        DB      00011000B
        DB      00110000B
        DB      00000000B
;
;       *** HEX EE ***      chnaged
        DB      00110000B   ;238 t foot
        DB      01111000B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      00110000B
        DB      00011100B
        DB      00001110B
;
;       *** HEX EF ***      changed
        DB      00001110B   ;239 acute
        DB      00001000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX F0 ***
        DB      00000000B   ;240 minus
        DB      00000000B
        DB      00000000B
        DB      00111100B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX F1 ***      chnaged
        DB      11101110B   ;241 dbl acute
        DB      10001000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX F2 ***
        DB      00000000B   ;242 foot
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00010000B
        DB      00011100B
;
;       *** HEX F3 ***      changed
        DB      01001000B   ;243 caron
        DB      00110000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX F4 ***      changed
        DB      11000110B   ;244 breve
        DB      01111100B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX F5 ***
        DB      00111110B   ;245 paragraph
        DB      01100011B
        DB      00111000B
        DB      01101100B
        DB      01101100B
        DB      00111000B
        DB      11001100B
        DB      01111000B
;
;       *** HEX F6 ***
        DB      00011000B   ;246 divide
        DB      00011000B
        DB      00000000B
        DB      01111110B
        DB      00000000B
        DB      00011000B
        DB      00011000B
        DB      00000000B
;
;       *** HEX F7 ***      changed
        DB      00000000B   ;247 foot
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000100B
        DB      00011100B
;
;       *** HEX F8 ***       changed
        DB      00111000B   ;248 circle
        DB      01101100B
        DB      01101100B
        DB      00111000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX F9 ***      changed
        DB      01100110B   ;249 umlaut
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX FA ***      chnaged
        DB      00011000B   ;250 overdot
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;
;       *** HEX FB ***      changed
        DB      11101110B   ;251 u dbl acute
        DB      10001000B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      11001100B
        DB      01110110B
        DB      00000000B
;
;       *** HEX FC ***      changed
        DB      01001000B   ;252 R caron
        DB      00110000B
        DB      11111100B
        DB      11000110B
        DB      11111100B
        DB      11011000B
        DB      11001100B
        DB      00000000B
;
;       *** HEX FD ***      changed
        DB      01001000B   ;253 r caron
        DB      00110000B
        DB      11001110B
        DB      11011000B
        DB      11100000B
        DB      11000000B
        DB      11000000B
        DB      00000000B
.LIST
;
;       *** HEX FE ***
        DB      00000000B   ;254 
        DB      00000000B
        DB      00111100B
        DB      00111100B
        DB      00111100B
        DB      00111100B
        DB      00000000B
        DB      00000000B
;
;       *** HEX FF ***
        DB      00000000B   ;255
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
        DB      00000000B
;


	DW	852			 ;TABLE ID
	DB	"Latin-2",0		 ;LANGUAGE NAME, IN ASCIIZ FORMAT
	IF	($-CSEG) MOD 16 	 ;IF NOT ALREADY ON 16 BYTE BOUNDARY
	    DB	    (16-(($-CSEG) MOD 16)) DUP(0)  ;ADD PADDING TO GET TO 16 BYTE BOUNDARY
	ENDIF
CSEG	ENDS
	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\cmd\graftabl\grtabhan.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981 - 1991
; *                      All Rights Reserved.
; */
	PAGE	90,132			;A2
	TITLE	GRTABHAN - INTERRUPT HANDLER FOR INT 2FH, GRAFTABL LOADED
;****************** START OF SPECIFICATIONS *****************************
; MODULE NAME: GRTABHAN.SAL

; DESCRIPTIVE NAME: For GRAFTABL, this is the Multiplexor Interrupt Handler

;FUNCTION: This module contains the Interrupt Handler that will be hooked
;	    into the INT 2FH vector.  When invoked with AL=0, it responds
;	    that GRAFTABL is loaded by changing AL to contain hex FF.  If
;	    option AL=1 specified, it puts into the vector at DS:[BX] the
;	    pointer to the previously loaded table.

; NOTES:
;	 This module should be processed with the SALUT preprocessor:

;		SALUT GRTABHAN

;	 To assemble these modules, the alphabetical or sequential
;	 ordering of segments may be used.

;	 For LINK instructions, refer to the PROLOG of the main module,
;	 GRTAB.SAL.  This module, containing a resident interrupt handler,
;	 should be first in the list of .OBJ to be linked.

;	 At the time this handler code is made resident, the loader, GRTAB,
;	 made certain instruction modifications.  PATCH_OFF and PATCH_SEG
;	 are the immediate word fields of two move word immediate to
;	 storage type of instructions.	The loaded Revised these to
;	 contain the offset and the segid respectively of where the
;	 resident font table would be that is to stay resident.

;	 Also at load time, GRTAB made another instruction modification by
;	 changing the JUMP DUMMY instruction's DWORD immediate field to
;	 contain the vector pointing to the previous owner of the
;	 Multiplexor Interrupt Vector.

; ENTRY POINT: There are two entry points: one, from DOS at 100H, is
;	    END_PSP.  The jump instruction there has nothing to do with
;	    the interrupt handler, but merely jumps to the GRTAB module to
;	    what is effectively the real DOS entry point, ENTRY_POINT.

;	    The other is where the interrupt vector will be set to point,
;	    the entry point to the interrupt handler code:  HANDLER.

;	    For the rest of this module description, the HANDLER entry
;	    point conditions are being described.

; INPUT: AH = Multiplexor Number.  I do nothing if this is not my own.
;	      The value of the Multiplexor Number is defined in the EQU:
;	      MY_MULTIPLEXOR_NUMBER as being the value, B0H.
;	 AL = Function Request.  There are two functions recognized:
;		    0 = "GET INSTALLED STATE"
;		    1 = "WHERE ARE YOU?"
;			 and DS:BX points to vector to receive pointer
;			 to the previously installed GRAFTABL table.
;		    If Function request is not '1', it is assumed to be '0'.

; EXIT-NORMAL: If the proper multiplexor number is presented, respond with
;	       AH = 0FFH, otherwise, pass control to previous owner
;	       of this interrupt.

; EXIT-ERROR: None

; INTERNAL REFERENCES:
;    ROUTINES: none

;    DATA AREAS:
;	   PUBLIC symbols:
;	 PREV_OWN      Far jump direct to previous owner of interrupt 2FH.
;	 PATCH_OFF     Offset portion of vector pointing to loaded char cable.
;	 PATCH_SEG     Segment portion of vector pointing to loaded char table.
;	 HANDLER       Entry point pointed to by the vector at interrupt 2FH.
;	 HANDLER_SIZE  Location of the end of the resident code portion of the
;		   interrupt 2FH handler, including the 60H bytes left of
;		   the PSP, so this offset is relative to the start of the PSP
;		   after the code has been relocated downward into the PSP.
;	 MPEXNUM       The byte containing the value defined
;		   as being the id checked for when INT 2FH is called used
;		   to identify this GRAFTABL member of the multiplexor chain.
;

; EXTERNAL REFERENCES:
;    ROUTINES: none

;    DATA AREAS: none

;****************** END OF SPECIFICATIONS *****************************
	IF1
	    %OUT    COMPONENT=GRAFTABL, MODULE=GRTABHAN.SAL...
	ENDIF
;		    $SALUT (4,21,25,41)
		    HEADER <MACRO DEFINITIONS, STRUC DEFINITIONS, EQUATES>
		    INCLUDE PATHMAC.INC ;AN006;
HEADER		    MACRO TEXT
.XLIST
		    SUBTTL TEXT
.LIST
		    PAGE
		    ENDM
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
VECTOR		    STRUC
VECOFF		    DW	?		;OFFSET PORTION OF VECTOR POINTER
VECSEG		    DW	?		;SEGMENT PORTION OF VECTOR POINTER
VECTOR		    ENDS
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
;		DEFINITION OF FUNCTIONS TO BE REQUESTED OF INT 2FH
GET_INST_STATE	    EQU 0		;FUNCTION = "GET INSTALLED STATE"
WHERE_R_U	    EQU 1		;FUNCTION = "WHERE ARE YOU?"
					; REQUESTS VECTOR OF LOADED TABLE BE
					; PUT IN VECTOR POINTED TO BY DS:[BX]
RES_FUNC	    EQU 0F8H		;RESERVED FUNCTIONS IN RANGE OF F8 TO FF, IGNORE

;		OTHER EQUATES
PATCHED 	    EQU 0		;DUMMY VALUE, TO BE REPLACED AT EXECUTION TIME
INSTALLED	    EQU 0FFH		;RESPONSE, INDICATES THIS HANDLER IS INSTALLED
MY_MULTIPLEX_NUMBER EQU 0B0H		;THE UNIQUE IDENTIFICATION NUMBER ASSIGNED
					; TO "GRAFTABL" FOR INT 2FH
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
DUMMY_SEG	    SEGMENT AT 0
DUMMY		    LABEL FAR		;NOTHING HERE REALLY, ONLY
					; USED TO MAKE MASM GENERATE A FAR CALL DIRECT
					; THE ABSOLUTE VECTOR IN THAT INS WILL BE PATCHED

DUMMY_SEG	    ENDS
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
		    HEADER <DOS ENTRY POINT>
CSEG		    SEGMENT PARA PUBLIC
;THIS SEGMENT IS ALIGNED ON PARA SINCE IT IS THE START OF THE LOAD MODULE,
; WHICH IS ON A PARA BOUNDARY ANYWAY.  THIS MODULE IS PADDED AT THE END
; TO A MULTIPLE OF 16 BYTES, SO THE NEXT SEGMENT WILL ALSO START
; ON A PARA BOUNDARY, WHICH WILL BE THE US CHARACTER SET TABLE.

		    ASSUME CS:CSEG

		    EXTRN ENTRY_POINT:NEAR

		    ORG 60H
		    PUBLIC MOV_DEST
MOV_DEST	    LABEL BYTE		;WHERE THIS INTERRUPT HANDLER
					; WILL BE MOVED TO, FOLLOWED BY THE 1K TABLE.
		    ORG 100H
		    PUBLIC END_PSP	;BEGINNING HERE, THIS WILL BE MOVED TO "MOV_DEST"
END_PSP 	    EQU $		;ENTRY POINT FROM DOS
		    JMP ENTRY_POINT	;INIT THE INT HANDLER, SET UP CHAR TABLES
					; THIS JUMP TARGET IS DEFINED
					;  IN THE GRTAB.SAL MODULE
;		AREAS TO BE PATCHED WITHIN THIS MODULE

		    PUBLIC PREV_OWN	;PATCH IS IN JMP INSTR TO PREVIOUS OWNER
;THE ABOVE PATCH IS FIXED BY THE GRTAB.SAL MODULE, JUST BEFORE ALTERING THE 2FH VECTOR

		    PUBLIC PATCH_OFF	;OFFSET PORTION OF VECTOR POINTING TO LOADED CHAR TABLE
		    PUBLIC PATCH_SEG	;SEGMENT PORTION OF VECTOR POINTING TO LOADED CHAR TABLE
;THE